This is chris-ansicl.info, produced by makeinfo version 4.8 from
temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: chris-ansicl.info,  Node: Top,  Next: Credits,  Up: (dir)

ANSI Common Lisp
****************

This is a Texinfo version(1) of the draft ANSI Common Lisp standard.
Some font information has been lost in the conversion, and errors may
have been introduced.  Report discrepancies with the hardcopy version to
Jesper Harder <jesper.harder@gmail.com>.

* Menu:

* Credits::
* Introduction::
* Syntax::
* Evaluation and Compilation::
* Types and Classes::
* Data and Control Flow::
* Iteration::
* Objects::
* Structures::
* Conditions::
* Symbols::
* Packages::
* Numbers::
* Characters::
* Conses::
* Arrays::
* Strings::
* Sequences::
* Hash Tables::
* Filenames::
* Files::
* Streams::
* Printer::
* Reader::
* System Construction::
* Environment::
* Glossary::
* Appendix::
* Index::
* Symbol Index::
* List of Figures::

---------- Footnotes ----------

(1) The converter is available from `http://purl.org/harder/dpans.html'


File: chris-ansicl.info,  Node: Credits,  Next: Introduction,  Prev: Top,  Up: Top

Credits
*******

Principal Technical Editors:
----------------------------

Kent M. Pitman         Harlequin, Inc.        1993-present
                       Symbolics, Inc.        1990-1992
Kathy Chapman          Digital Equipment      1987-1989
                       Corporation            

Occasional Guest Editors:
-------------------------

Richard P. Gabriel     Lucid, Inc.
Sandra Loosemore       self

Financial Contributors to the Editing Process:
----------------------------------------------

Digital Equipment Corporation
Harlequin, Ltd. and Harlequin, Inc.
Symbolics, Inc.
Apple, Inc.
Franz, Inc.
Lucid, Inc.

Special thanks to Guy L. Steele Jr. and Digital Press for producing
`Common Lisp: The Language', and for relaxing copyright restrictions
enough to make it possible for that document's text to provide an early
basis of this work.

Edit and Review History:
------------------------

01-Jan-89   Pitman      Draft of Chapters 5.1 (conditions).
01-May-89   Chapman     Draft of 1.2-1.6.
01-May-89   Gabriel     Rewrite of Chapters 1.1 and 5.1.
01-Jun-89   Loosemore   Review of Chapter 4.2.
01-Jun-89   Pitman      Review of Glossary
15-Jun-89   Gabriel     Rewrite of Glossary
16-Jun-89   Margolin    Comments on Chapters 2.1-2.4 (types, objects).
23-Jun-89   Gabriel     Rewrite of 4.2.
07-Jul-89   Moon        Review of Chapters 4.1, 4.3
12-Jul-89   Gabriel     Revision of 4.2.
15-Jul-89   Pitman      Review of Glossary
18-Jul-89   Gray        Comments on 5.1
25-Jul-89   Gabriel     Revision of Chapters 1.2-1.6, 2.2
26-Jul-89   Gabriel     Rewrite of 5.1
26-Jul-89   Gabriel     Rewrite of 4.1.
27-Jul-89   Pitman      Revision of 5.1
27-Jul-89   Gabriel     Revision of 5.1
28-Jul-89   Chapman     Draft of 2.2, 3.2, 3.3, 5.4
28-Jul-89   Gabriel     Revision of Glossary.
01-Oct-89   Margolin    Review of Dictionary from Jun-89 draft.
20-Jan-91   Pitman      Draft 8.81 (for X3J13 review). Document
                        X3J13/91-101.
29-Jan-91   Waters      Review of 8.81/Chapter 23 (Printer).
01-Mar-91   Moon        Review of 8.81/Chapter 4 (Evaluation and
                        Compilation).
01-Mar-91   Barrett     Review of 8.81/Chapter 4 (Evaluation and
                        Compilation).
01-Mar-91   Moon        Review of 8.81/Glossary.
13-Mar-90   Wechsler    Review of 8.81/Glossary.
21-Mar-91   Kerns       Review of 8.81/Chapter 1.
26-Apr-91   Margolin    Review of 8.81/Chapters 1-12.
15-May-91   Barrett     Review of 8.81/Chapters 5 (Misc), 11 (Conditions).
04-Jun-91   Laddaga     Review of 9.60/Chapter 20 (Pathnames).
10-Jun-91   Pitman      Draft 9.126 (for X3J13 review). Document
                        X3J13/91-102.
02-Sep-91   Barrett     Review of 9.28/Chapter 4 (Evaluation and
                        Compilation).
02-Sep-91   Barrett     Review of 9.52/Chapter 4 (Evaluation and
                        Compilation).
15-Sep-91   Barrett     Review of 9.126/Chapter 4 (Evaluation and
                        Compilation)
                        and Chapter 7 (Evaluation/Compilation).
                        (some comments not yet merged)
18-Sep-91   Wechsler    Review of 9.126.
21-Sep-91   Barrett     Review of 10.16/Chapter 7
                        (Evaluation/Compilation).
                        (some comments not yet merged)
28-Sep-91   Barrett     Review of 10.95/Chapter 25 (Printer).
                        (some comments not yet merged)
13-Oct-91   Barrett     Review (and help editing) of 10.104/Chapter 4
                        (Evaluation and Compilation)
15-Oct-91   Waters      Review of 10.95/Chapter 25 (Printer).
24-Oct-91   Pitman      Draft 10.156 (for X3J13 review). Document
                        X3J13/91-103.
04-Nov-91   Moon        Review of 10.156/Chapter 5 (Data and Control Flow)
                        and Chapter 26 (Glossary).
11-Nov-91   Loosemore   Review of 10.156/Chapter 2 (Syntax),
                        Chapter 3 (Evaluation and Compilation),
                        Chapter 5 (Data and Control Flow), and Chapter 8
                        (Structures).
02-Dec-91   Barrett     Review of 10.156/Chapter 4 (Types and Classes),
                        and Chapter 10 (Symbols).
02-Dec-91   Barrett     Review of 10.156/Chapter 3 (Evaluation and
                        Compilation),
                        Chapter 6 (Iteration), Chapter 9 (Conditions),
                        and Chapter 14 (Conses).
                        (some comments not yet merged)
09-Dec-91   Gabriel     Review of 10.156/Chapter 1 (Introduction),
                        Chapter 2 (Syntax), and Chapter 3 (Evaluation and
                        Compilation).
09-Dec-91   Ida         Light review of 10.156/Chapters 1-5.
09-Dec-91   Moon        Review of 10.156/Chapter 3 (Evaluation and
                        Compilation).
                        (some comments not yet merged)
10-Dec-91   Loosemore   Review of 10.156/Chapter 10 (Symbols),
                        Chapter 20 (Files), and Chapter 13 (Characters).
10-Dec-91   Loosemore   Review of 10.156/Chapter 14 (Conses).
                        (some comments not yet merged)
10-Dec-91   Laubsch     Review of 10.156/Chapters 1 (Introduction),
                        Chapter 2 (Syntax), Chapter 3 (Evaluation and
                        Compilation),
                        Chapter 4 (Types and Classes), Chapter 5 (Data
                        and Control Flow),
                        Chapter 7 (Objects), Chapter 11 (Packages),
                        Chapter 19 (Filenames), and Chapter 21 (Streams).
18-Dec-91   Margolin    Review of 10.156/Chapter 18 (Hash Tables).
04-Jan-92   White       Review of 10.156/Chapter 6 (Iteration),
                        Chapter 11 (Packages), Chapter 18 (Hash Tables),
                        and Chapter 23 (Reader).
04-Jan-92   White       Review of 10.156/Chapter 26 (Glossary).
                        (some comments not yet merged)
04-Jan-92   Barrett     Review of 10.156/Chapter 18 (Hash Tables) and
                        Chapter 16 (Strings).
04-Jan-92   Barrett     Review of 10.156/Chapter 15 (Arrays) and Chapter
                        21 (Streams).
                        (some comments not yet merged)
06-Jan-92   Loosemore   Review of 10.156/Chapter 16 (Strings),
                        Chapter 17 (Sequences), and Chapter 25
                        (Environment).
06-Jan-92   Loosemore   Review of 10.156/Chapter 21 (Streams) and Chapter
                        23 (Reader).
                        (some comments not yet merged)
06-Jan-92   Margolin    Review of 10.156/Chapter 2 (Syntax).
07-Jan-92   Margolin    Review of 10.156/Chapter 4 (Types and Classes).
03-Feb-92   Aspinall    Review of 10.156/Chapter 12 (Numbers).
16-Feb-92   Pitman      Draft 11.82 (for X3J13 letter ballot). Document
                        X3J13/92-101.
16-Mar-92   Loosemore   Review of 11.82/Chapter 1, 3, 4, 5, 7, 8, 9, 10,
                        11, 12, 18, 22, 23, 24, 25, and 26.
16-Feb-92   Pitman      Draft 12.24 (for X3 consideration). Document
                        X3J13/92-102.
09-Sep-92   Samson      Public Review Comments (#1). Documents
                        X3J13/92-1001 to 92-1003.
22-Oct-92   Rose, Yen   Public Review Comments (#2). Documents
                        X3J13/92-1101 to 92-1103.
23-Oct-92   Staley      Public Review Comments (#3). Documents
                        X3J13/92-1201 to 92-1204.
09-Nov-92   Barrett     Public Review Comments (#4). Documents
                        X3J13/92-3101 to 92-3110.
11-Nov-92   Moon        Public Review Comments (#5). Documents
                        X3J13/92-3201 to 92-3248.
17-Nov-92   Loosemore   Public Review Comments (#6). Documents
                        X3J13/92-1301 to 92-1335.
23-Nov-92   Margolin    Public Review Comments (#7). Documents
                        X3J13/92-1401 to 92-1419.
23-Nov-92   Withington  Public Review Comments (#8a). Documents
                        X3J13/92-1501 to 92-1512.

23-Nov-92   Feinberg    Public Review Comments (#8b). Documents
                        X3J13/92-1601 to 92-1603.
23-Nov-92   Wechsler    Public Review Comments (#8c). Documents
                        X3J13/92-1701 to 92-1703.
23-Nov-92   Moore       Public Review Comments (#9). Documents
                        X3J13/92-1801 to 92-1802.
23-Nov-92   Flanagan    Public Review Comments (#10). Documents
                        X3J13/92-1901 to 92-1910.
23-Nov-92   Dalton      Public Review Comments (#11). Documents
                        X3J13/92-2001 to 92-2012.
23-Nov-92   Gallagher   Public Review Comments (#12). Documents
                        X3J13/92-2101 to 92-2103.
23-Nov-92   Norvig      Public Review Comments (#13). Documents
                        X3J13/92-2201 to 92-2208.
24-Nov-92   Robertson   Public Review Comments (#14). Document
                        X3J13/92-2301.
23-Nov-92   Kawabe      Public Review Comments (#15). Documents
                        X3J13/92-2401 to 92-2403.
23-Nov-92   Barrett     Public Review Comments (#16). Documents
                        X3J13/92-2511 to X3J13/92-2531.
23-Nov-92   Wertheimer  Public Review Comments (#17). Document
                        X3J13/92-2601.
24-Nov-92   Pitman      Public Review Comments (#18). Documents
                        X3J13/92-2701 to 92-2742.
24-Nov-92   Mato Mira   Public Review Comments (#19). Documents
                        X3J13/92-2801 to 92-2805.
24-Nov-92   Philpot     Public Review Comments (#20). Document
                        X3J13/92-2901.
23-Nov-92   Cerys       Public Review Comments (#21). Document
                        X3J13/92-3001.
30-Aug-93   Pitman      Draft 13.65 (for X3J13 consideration). Document
                        X3J13/93-101.
04-Oct-93   X3J13       Minor fixes to Draft 13.65 before sending to X3.
05-Oct-93   Pitman      Draft 14.10 (for X3 consideration). Document
                        X3J13/93-102.
08-Nov-93   Dalton      "reply to reply to pr comments".  Document
                        X3J13/94-311.
04-Apr-94   Boyer,      
            Kaufmann,   
            Moore       Public Review Comments (#1).  Document
                        X3J13/94-305.
05-Apr-94   Pitman      Public Review Comments (#2).  Document
                        X3J13/94-306.
14-Mar-94   Schulenburg Public Review Comments (#3).  Document
                        X3J13/94-307.
04-Apr-94   Shepard     Late commentary.  Document X3J13/94-309.
05-May-94   X3J13       Editorial-only changes to Draft 14.10 in response
                        to comments.
10-May-94   Pitman      Draft 15.17R (for X3 consideration). Document
                        X3J13/94-101R.

The following lists of information are almost certainly incomplete, but
it was felt that it was better to risk publishing incomplete information
than to fail to acknowledge important contributions by the many people
and organizations who have contributed to this effort.

Mention here of any individual or organization does not imply
endorsement of this document by that individual or organization.

Ad Hoc Group Chairs:
--------------------

Charter                              Ennis, Susan P.
Cleanup                              Masinter, Larry
                                     Fahlman, Scott
Compiler                             Haflich, Steve
                                     Loosemore, Sandra
Conditions                           Pitman, Kent M.
Editorial                            Chapman, Kathy
Graphics & Windows                   Douglas Rand
Iteration                            White, JonL
Lispá/Lispà                          Gabriel, Richard P.
Macros                               Haflich, Steve
                                     Pitman, Kent M.
Objects                              Bobrow, Daniel G.
Presentation of Standard             Brown, Gary
Pretty Printer                       Waters, Richard C.
Public Review                        Ida, Masayuki
Types & Declarations                 Scherlis, William
Validation                           Berman, Richard
                                     Balzer, Bob

Major Administrative Contributions:
-----------------------------------

Steele, Guy L., Jr.                  Eiron, Hanoch
Zubkoff, Jan L.                      Haflich, Steve
Gabriel, Richard P.                  Ida, Masayuki
Masinter, Larry                      Loeffler, David D.
Loosemore, Sandra                    Tyson, Mabry
Pitman, Kent M.                      Whittemore, Susan
Barrett, Kim                         Woodyatt, Anne

Major Technical Contributions:
------------------------------

Loosemore, Sandra                                 
Bobrow, Daniel G.        Margolin, Barry          
Daniels, Andy            Moon, David A.           
DeMichiel, Linda G.      Pitman, Kent M.          
Dussud, Patrick H.       Perdue, Crispin          
Gabriel, Richard P.      Steele, Guy L., Jr.      
Ida, Masayuki            Waters, Richard C.       
Kiczales, Gregor         White, JonL              

Participating Companies and Organizations:
------------------------------------------

LMI                                  
AI Architects                        Loosemore, Sandra
Amoco Production Co.                 Lucid, Inc.
Aoyama Gakuin University             MCC
Apple Computer                       MIT
Barrett, Kim                         MITRE Corporation
Boeing Advanced Technology Center    MSC
Carnegie-Mellon University           NASA Ames Research Center
Chestnut Software                    Nihon Symbolics
Computer Sciences                    National Bureau of Standards
CONTEL                               Prime Computer
Digital Equipment Corporation        Siemens
Evans & Sutherland                   Southern Illinois University
Encore                               Sperry
Franz, Inc.                          SRI
Gigamos                              Sun Microsystems
GMD                                  Symbolics
Gold Hill                            Tektronix
Greenblatt, Richard                  Texas Instruments
Grumman Data Systems Corporation     Thinking Machines Corporation
Harlequin, Ltd.                      Unisys
Hewlett-Packard                      University of Bath
Honeywell                            University of Edinburgh
IBM                                  University of Utah
Integrated Inference Machines        US Army
International LISP Associates        USC/ISI
Johnson Controls                     Xerox

Individual Participants:
------------------------

Arbaugh, Bill            Hornig, Charles          Philipp, Christopher
Balzer, Bob              Ida, Masayuki            Pierson, Dan
Barrett, Kim             Keene, Sonya             Pitman, Kent M.
Bartley, David           Keller, Shaun            Raghavan, B.
Beckerle, Mike           Kempf, James             Rand, Douglas
Beiser, Paul             Kerns, Robert W.         Rininger, Jeff
Benson, Eric             Kiczales, Gregor         Rosenking, Jeff
Berman, Richard          Kolb, Dieter             Scherlis, William
Bobrow, Daniel G.        Koschmann, Timothy       Shiota, Eiji
Boelk, Mary              Kosinski, Paul           Sizer, Andy
Brittain, Skona          Larson, Aaron            Slater, David
Brown, Gary              Latto, Andy              Sodan, Angela
Chailloux, Jerome        Laubsch, Joachim         Soley, Richard
Chapman, Kathy           Layer, Kevin             St. Clair, Bill
Clinger, Will            Linden, Thom             Stanhope, Philip
Coffee, Peter C.         Loeffler, David D.       Steele, Guy L., Jr.
Cugini, John             Loosemore, Sandra        Tucker, Paul
Curtis, Pavel            Magataca, Mituhiro       Turba, Thomas
Dabrowski, Christopher   Margolin, Barry          Unietis, Dave
Daessler, Klaus          Masinter, Larry          van Roggen, Walter
Dalton, Jeff             Mathis, Robert           van Roggen, Walter
Daniels, Andy            Matthews, Dave           Waldrum, Ellen
DeMichiel, Linda G.      McCarthy, John           Waters, Richard C.
Duggan, Jerry            Mikelsons, Martin        Wechsler, Allan
Dussud, Patrick H.       Moon, David A.           Wegman, Mark
Ennis, Susan P.          Moore, Timothy           Weinreb, Daniel
Fahlman, Scott           Nicoud, Stephen          White, JonL
Gabriel, Richard P.      Nilsson, Jarl            Wieland, Alexis
Giansiracusa, Bob        O'Dell, Jim              Withington, P. Tucker
Gray, David              Ohlander, Ron            Wright, Whitman
Greenblatt, Richard      Padget, Julian           York, Bill
Hadden, George D.        Palter, Gary             Zacharias, Gail
Haflich, Steve           Peck, Jeff               Zubkoff, Jan L.
Harris, Richard M.       Pellegrino, Bob          


File: chris-ansicl.info,  Node: Introduction,  Next: Syntax,  Prev: Credits,  Up: Top

1 Introduction
**************

* Menu:

* Scope; Purpose; and History::
* Organization of the Document::
* Referenced Publications::
* Definitions::
* Conformance::
* Language Extensions::
* Language Subsets::
* Deprecated Language Features::
* Symbols in the COMMON-LISP Package::


File: chris-ansicl.info,  Node: Scope; Purpose; and History,  Next: Organization of the Document,  Up: Introduction

1.1 Scope, Purpose, and History
===============================

* Menu:

* Scope and Purpose::
* History::


File: chris-ansicl.info,  Node: Scope and Purpose,  Next: History,  Up: Scope; Purpose; and History

1.1.1 Scope and Purpose
-----------------------

The specification set forth in this document is designed to promote the
portability of Common Lisp programs among a variety of data processing
systems. It is a language specification aimed at an audience of
implementors and knowledgeable programmers. It is neither a tutorial nor
an implementation guide.


File: chris-ansicl.info,  Node: History,  Prev: Scope and Purpose,  Up: Scope; Purpose; and History

1.1.2 History
-------------

Lisp is a family of languages with a long history.  Early key ideas in
Lisp were developed by John McCarthy during the 1956 Dartmouth Summer
Research Project on Artificial Intelligence.  McCarthy's motivation was
to develop an algebraic list processing language for artificial
intelligence work.  Implementation efforts for early dialects of Lisp
were undertaken on the IBM 704, the IBM 7090, the Digital Equipment
Corporation (DEC) PDP-1, the DEC PDP-6, and the PDP-10. The primary
dialect of Lisp between 1960 and 1965 was Lisp 1.5. By the early 1970's
there were two predominant dialects of Lisp, both arising from these
early efforts: MacLisp and Interlisp.  For further information about
very early Lisp dialects, see `The Anatomy of Lisp' or `Lisp 1.5
Programmer's Manual'.

MacLisp improved on the Lisp 1.5 notion of special variables and error
handling. MacLisp also introduced the concept of functions that could
take a variable number of arguments, macros, arrays, non-local dynamic
exits, fast arithmetic, the first good Lisp compiler, and an emphasis
on execution speed.  By the end of the 1970's, MacLisp was in use at
over 50 sites.  For further information about Maclisp, see `Maclisp
Reference Manual, Revision 0' or `The Revised Maclisp Manual'.

Interlisp introduced many ideas into Lisp programming environments and
methodology. One of the Interlisp ideas that influenced Common Lisp was
an iteration construct implemented by Warren Teitelman that inspired
the ÿloopþ macro used both on the Lisp Machines and in MacLisp, and now
in Common Lisp.  For further information about Interlisp, see
`Interlisp Reference Manual'.

Although the first implementations of Lisp were on the IBM 704 and the
IBM 7090, later work focussed on the DEC PDP-6 and, later, PDP-10
computers, the latter being the mainstay of Lisp and artificial
intelligence work at such places as Massachusetts Institute of
Technology (MIT), Stanford University, and Carnegie Mellon University
(CMU) from the mid-1960's through much of the 1970's.  The PDP-10
computer and its predecessor the PDP-6 computer were, by design,
especially well-suited to Lisp because they had 36-bit words and 18-bit
addresses. This architecture allowed a cons cell to be stored in one
word; single instructions could extract the car and cdr parts.  The
PDP-6 and PDP-10 had fast, powerful stack instructions that enabled
fast function calling.  But the limitations of the PDP-10 were evident
by 1973: it supported a small number of researchers using Lisp, and the
small, 18-bit address space (2^18 = 262,144 words) limited the size of
a single program.  One response to the address space problem was the
Lisp Machine, a special-purpose computer designed to run Lisp programs.
The other response was to use general-purpose computers with address
spaces larger than 18 bits, such as the DEC VAX and the S-1 Mark IIA.
For further information about S-1 Common Lisp, see "S-1 Common Lisp
Implementation."

The Lisp machine concept was developed in the late 1960's.  In the
early 1970's, Peter Deutsch, working with Daniel Bobrow, implemented a
Lisp on the Alto, a single-user minicomputer, using microcode to
interpret a byte-code implementation language. Shortly thereafter,
Richard Greenblatt began work on a different hardware and instruction
set design at MIT.  Although the Alto was not a total success as a Lisp
machine, a dialect of Interlisp known as Interlisp-D became available
on the D-series machines manufactured by Xerox--the Dorado, Dandelion,
Dandetiger, and Dove (or Daybreak).  An upward-compatible extension of
MacLisp called Lisp Machine Lisp became available on the early MIT Lisp
Machines.  Commercial Lisp machines from Xerox, Lisp Machines (LMI), and
Symbolics were on the market by 1981.  For further information about
Lisp Machine Lisp, see `Lisp Machine Manual'.

During the late 1970's, Lisp Machine Lisp began to expand towards a
much fuller language.  Sophisticated lambda lists, ÿsetfþ, multiple
values, and structures like those in Common Lisp are the results of
early experimentation with programming styles by the Lisp Machine group.
Jonl White and others migrated these features to MacLisp.  Around 1980,
Scott Fahlman and others at CMU began work on a Lisp to run on the
Scientific Personal Integrated Computing Environment (SPICE)
workstation.  One of the goals of the project was to design a simpler
dialect than Lisp Machine Lisp.

The Macsyma group at MIT began a project during the late 1970's called
the New Implementation of Lisp (NIL) for the VAX, which was headed by
White.  One of the stated goals of the NIL project was to fix many of
the historic, but annoying, problems with Lisp while retaining
significant compatibility with MacLisp.  At about the same time, a
research group at Stanford University and Lawrence Livermore National
Laboratory headed by Richard P. Gabriel began the design of a Lisp to
run on the S-1 Mark IIA supercomputer.  S-1 Lisp, never completely
functional, was the test bed for adapting advanced compiler techniques
to Lisp implementation.  Eventually the S-1 and NIL groups collaborated.
For further information about the NIL project, see "NIL--A Perspective."

The first effort towards Lisp standardization was made in 1969, when
Anthony Hearn and Martin Griss at the University of Utah defined
Standard Lisp--a subset of Lisp 1.5 and other dialects--to transport
REDUCE, a symbolic algebra system.  During the 1970's, the Utah group
implemented first a retargetable optimizing compiler for Standard Lisp,
and then an extended implementation known as Portable Standard Lisp
(PSL).  By the mid 1980's, PSL ran on about a dozen kinds of computers.
For further information about Standard Lisp, see "Standard LISP Report."

PSL and Franz Lisp--a MacLisp-like dialect for Unix machines--were the
first examples of widely available Lisp dialects on multiple hardware
platforms.

One of the most important developments in Lisp occurred during the
second half of the 1970's: Scheme. Scheme, designed by Gerald J.
Sussman and Guy L. Steele Jr., is a simple dialect of Lisp whose design
brought to Lisp some of the ideas from programming language semantics
developed in the 1960's.  Sussman was one of the prime innovators
behind many other advances in Lisp technology from the late 1960's
through the 1970's.  The major contributions of Scheme were lexical
scoping, lexical closures, first-class continuations, and simplified
syntax (no separation of value cells and function cells). Some of these
contributions made a large impact on the design of Common Lisp.  For
further information about Scheme, see `IEEE Standard for the Scheme
Programming Language' or "Revised³ Report on the Algorithmic Language
Scheme."

In the late 1970's object-oriented programming concepts started to make
a strong impact on Lisp.  At MIT, certain ideas from Smalltalk made
their way into several widely used programming systems.  Flavors, an
object-oriented programming system with multiple inheritance, was
developed at MIT for the Lisp machine community by Howard Cannon and
others.  At Xerox, the experience with Smalltalk and Knowledge
Representation Language (KRL) led to the development of Lisp Object
Oriented Programming System (LOOPS) and later Common LOOPS.  For
further information on Smalltalk, see `Smalltalk-80: The Language and
its Implementation'.  For further information on Flavors, see `Flavors:
A Non-Hierarchical Approach to Object-Oriented Programming'.

These systems influenced the design of the Common Lisp Object System
(CLOS).  CLOS was developed specifically for this standardization
effort, and was separately written up in "Common Lisp Object System
Specification."  However, minor details of its design have changed
slightly since that publication, and that paper should not be taken as
an authoritative reference to the semantics of the object system as
described in this document.

In 1980 Symbolics and LMI were developing Lisp Machine Lisp;
stock-hardware implementation groups were developing NIL, Franz Lisp,
and PSL; Xerox was developing Interlisp; and the SPICE project at CMU
was developing a MacLisp-like dialect of Lisp called SpiceLisp.

In April 1981, after a DARPA-sponsored meeting concerning the
splintered Lisp community, Symbolics, the SPICE project, the NIL
project, and the S-1 Lisp project joined together to define Common
Lisp.  Initially spearheaded by White and Gabriel, the driving force
behind this grassroots effort was provided by Fahlman, Daniel Weinreb,
David Moon, Steele,  and Gabriel.  Common Lisp was designed as a
description of a family of languages.  The primary influences on Common
Lisp were Lisp Machine Lisp, MacLisp, NIL, S-1 Lisp, Spice Lisp, and
Scheme.  `Common Lisp: The Language' is a description of that design.
Its semantics were intentionally underspecified in places where it was
felt that a tight specification would overly constrain Common Lisp
research and use.

In 1986 X3J13 was formed as a technical working group to produce a
draft for an ANSI Common Lisp standard. Because of the acceptance of
Common Lisp, the goals of this group differed from those of the
original designers. These new goals included stricter standardization
for portability, an object-oriented programming system, a condition
system, iteration facilities, and a way to handle large character sets.
To accommodate those goals, a new language specification, this
document, was developed.


File: chris-ansicl.info,  Node: Organization of the Document,  Next: Referenced Publications,  Prev: Scope; Purpose; and History,  Up: Introduction

1.2 Organization of the Document
================================

This is a reference document, not a tutorial document.  Where possible
and convenient, the order of presentation has been chosen so that the
more primitive topics precede those that build upon them;  however,
linear readability has not been a priority.

This document is divided into chapters by topic.  Any given chapter
might contain conceptual material, dictionary entries, or both.

Defined names within the dictionary portion of a chapter are grouped in
a way that brings related topics into physical proximity.  Many such
groupings were possible, and no deep significance should be inferred
from the particular grouping that was chosen.  To see defined names
grouped alphabetically, consult the index.  For a complete list of
defined names, see *Note Section 1.9 (Symbols in the COMMON-LISP
Package): Symbols in the COMMON-LISP Package.

In order to compensate for the sometimes-unordered portions of this
document, a glossary has been provided; see *Note Chapter 26
(Glossary): Glossary.  The glossary provides connectivity by providing
easy access to definitions of terms, and in some cases by providing
examples or cross references to additional conceptual material.

For information about notational conventions used in this document, see
*Note Section 1.4 (Definitions): Definitions.

For information about conformance, see *Note Section 1.5 (Conformance):
Conformance.

For information about extensions and subsets, see *Note Section 1.6
(Language Extensions): Language Extensions.  and *Note Section 1.7
(Language Subsets): Language Subsets.

For information about how programs in the language are parsed by the
Lisp reader, see *Note Chapter 2 (Syntax): Syntax.

For information about how programs in the language are compiled and
executed, see *Note Chapter 3 (Evaluation and Compilation): Evaluation
and Compilation.

For information about data types, see *Note Chapter 4 (Types and
Classes): Types and Classes.  Not all types and classes are defined in
this chapter; many are defined in chapter corresponding to their
topic-for example, the numeric types are defined in *Note Chapter 12
(Numbers): Numbers.  For a complete list of standardized types, see
*Note Figure 4.2: StandardizedAtomicTypeSpecs.

For information about general purpose control and data flow, see *Note
Chapter 5 (Data and Control Flow): Data and Control Flow. or *Note
Chapter 6 (Iteration): Iteration.


File: chris-ansicl.info,  Node: Referenced Publications,  Next: Definitions,  Prev: Organization of the Document,  Up: Introduction

1.3 Referenced Publications
===========================

   * `The Anatomy of Lisp', John Allen, McGraw-Hill, Inc., 1978.

   * `The Art of Computer Programming, Volume 3', Donald E. Knuth,
     Addison-Wesley Company (Reading, MA), 1973.

   * `The Art of the Metaobject Protocol', Kiczales et al., MIT Press
     (Cambridge, MA), 1991.

   * "Common Lisp Object System Specification," D. Bobrow, L.
     DiMichiel, R.P. Gabriel, S. Keene, G. Kiczales, D. Moon, SIGPLAN
     Notices V23, September, 1988.

   * `Common Lisp: The Language', Guy L. Steele Jr., Digital Press
     (Burlington, MA), 1984.

   * `Common Lisp: The Language Second Edition', Guy L. Steele Jr.,
     Digital Press (Bedford, MA), 1990.

   * `Exceptional Situations in Lisp', Kent M. Pitman, Proceedings of
     the First European Conference on the Practical Application of LISP
     (EUROPAL '90), Churchill College, Cambridge, England, March 27-29,
     1990.

   * `Flavors: A Non-Hierarchical Approach to Object-Oriented
     Programming', Howard I. Cannon, 1982.

   * `IEEE Standard for Binary Floating-Point Arithmetic', ANSI/IEEE
     Std 754-1985, Institute of Electrical and Electronics Engineers,
     Inc. (New York), 1985.

   * `IEEE Standard for the Scheme Programming Language', IEEE Std
     1178-1990, Institute of Electrical and Electronic Engineers, Inc.
     (New York), 1991.

   * `Interlisp Reference Manual', Third Revision, Teitelman, Warren,
     et al, Xerox Palo Alto Research Center (Palo Alto, CA), 1978.

   * `ISO 6937/2', Information processing--Coded character sets for
     text communication--Part 2: Latin alphabetic and non-alphabetic
     graphic characters, ISO, 1983.

   * `Lisp 1.5 Programmer's Manual', John McCarthy, MIT Press
     (Cambridge, MA), August, 1962.

   * `Lisp Machine Manual', D.L. Weinreb and D.A. Moon, Artificial
     Intelligence Laboratory, MIT (Cambridge, MA), July, 1981.

   * `Maclisp Reference Manual, Revision 0', David A. Moon, Project MAC
     (Laboratory for Computer Science), MIT (Cambridge, MA), March,
     1974.

   * "NIL--A Perspective," JonL White, Macsyma User's Conference, 1979.

   * `Performance and Evaluation of Lisp Programs', Richard P. Gabriel,
     MIT Press (Cambridge, MA), 1985.

   * "Principal Values and Branch Cuts in Complex APL," Paul Penfield
     Jr., APL 81 Conference Proceedings, ACM SIGAPL (San Francisco,
     September 1981), 248-256.  Proceedings published as APL Quote Quad
     12, 1 (September 1981).

   * `The Revised Maclisp Manual', Kent M. Pitman, Technical Report 295,
     Laboratory for Computer Science, MIT (Cambridge, MA), May 1983.

   * "Revised³ Report on the Algorithmic Language Scheme," Jonathan
     Rees and William Clinger (editors), SIGPLAN Notices V21, #12,
     December, 1986.

   * "S-1 Common Lisp Implementation," R.A. Brooks, R.P. Gabriel, and
     G.L. Steele, Conference Record of the 1982 ACM Symposium on Lisp
     and Functional Programming, 108-113, 1982.

   * `Smalltalk-80: The Language and its Implementation', A. Goldberg
     and D. Robson, Addison-Wesley, 1983.

   * "Standard LISP Report," J.B. Marti, A.C. Hearn, M.L. Griss, and C.
     Griss, SIGPLAN Notices V14, #10, October, 1979.

   * `Webster's Third New International Dictionary the English
     Language, Unabridged', Merriam Webster (Springfield, MA), 1986.

   * `XP: A Common Lisp Pretty Printing System', R.C. Waters, Memo
     1102a, Artificial Intelligence Laboratory, MIT (Cambridge, MA),
     September 1989.


File: chris-ansicl.info,  Node: Definitions,  Next: Conformance,  Prev: Referenced Publications,  Up: Introduction

1.4 Definitions
===============

This section contains notational conventions and definitions of terms
used in this manual.

* Menu:

* Notational Conventions::
* Error Terminology::
* Sections Not Formally Part Of This Standard::
* Interpreting Dictionary Entries::


File: chris-ansicl.info,  Node: Notational Conventions,  Next: Error Terminology,  Up: Definitions

1.4.1 Notational Conventions
----------------------------

The following notational conventions are used throughout this document.

1.4.1.1 Font Key
................

Fonts are used in this document to convey information.

name
     Denotes a formal term whose meaning is defined in the Glossary.
     When this font is used, the Glossary definition takes precedence
     over normal English usage.

     Sometimes a glossary term appears subscripted, as in "whitespaceà."
     Such a notation selects one particular Glossary definition out of
     several, in this case the second.  The subscript notation for
     Glossary terms is generally used where the context might be
     insufficient to disambiguate among the available definitions.

"name"
     Denotes the introduction of a formal term locally to the current
     text.  There is still a corresponding glossary entry, and is
     formally equivalent to a use of "name," but the hope is that
     making such uses conspicuous will save the reader a trip to the
     glossary in some cases.

name
     Denotes a symbol in the ÿCOMMON-LISPþ package.  For information
     about case conventions, see *Note Section 1.4.1.4.1 (Case in
     Symbols): CaseInSymbols.

ÿnameþ
     Denotes a sample name or piece of code that a programmer might
     write in Common Lisp.

     This font is also used for certain standardized names that are not
     names of external symbols of the ÿCOMMON-LISPþ package, such as
     keywordsá, package names, and loop keywords.

NAME
     Denotes the name of a parameter or value.

     In some situations the notation "«NAME»" (i.e., the same font, but
     with surrounding "angle brackets") is used instead in order to
     provide better visual separation from surrounding characters.
     These "angle brackets" are metasyntactic, and never actually
     appear in program input or output.

1.4.1.2 Modified BNF Syntax
...........................

This specification uses an extended Backus Normal Form (BNF) to
describe the syntax of Common Lisp macro forms and special forms.  This
section discusses the syntax of BNF expressions.

1.4.1.2.1 Splicing in Modified BNF Syntax
.........................................

The primary extension used is the following:

     ùOø

An expression of this form appears whenever a list of elements is to be
spliced into a larger structure and the elements can appear in any
order. The symbol O represents a description of the syntax of some
number of syntactic elements to be spliced; that description must be of
the form

     Oá | ... | O_l

where each O_i can be of the form S or of the form S* or of the form S¹.
The expression ùOø means that a list of the form

     (O_{iá}... O_{i_j}) 1ó j

is spliced into the enclosing expression, such that if n â m and 1ó
n,mó j, then either O_{i_n}â O_{i_m} or O_{i_n} = O_{i_m} = Q_k, where
for some 1ó k ó n, O_k is of the form Q_k*.  Furthermore, for each
O_{i_n} that is of the form Q_k¹, that element is required to appear
somewhere in the list to be spliced.

For example, the expression

ÿ(x ùA | B* | Cø y)þ

means that at most one ÿAþ, any number of ÿBþ's, and at most one ÿCþ
can occur in any order.  It is a description of any of these:

 (x y)
 (x B A C y)
 (x A B B B B B C y)
 (x C B A B B B y)

but not any of these:

 (x B B A A C C y)
 (x C B C y)

In the first case, both ÿAþ and ÿCþ appear too often, and in the second
case ÿCþ appears too often.

The notation ùOá | Oà | ...ø+ adds the additional restriction that at
least one item from among the possible choices must be used.  For
example:

ÿ(x ùA | B* | Cø+ y)þ

means that at most one ÿAþ, any number of ÿBþ's, and at most one ÿCþ
can occur in any order, but that in any case at least one of these
options must be selected.  It is a description of any of these:

 (x B y)
 (x B A C y)
 (x A B B B B B C y)
 (x C B A B B B y)

but not any of these:

 (x y)
 (x B B A A C C y)
 (x C B C y)

In the first case, no item was used; in the second case, both ÿAþ and
ÿCþ appear too often; and in the third case ÿCþ appears too often.

Also, the expression:

ÿ(x ùA¹ | B¹ | Cø y)þ

can generate exactly these and no others:

 (x A B C y)
 (x A C B y)
 (x A B y)
 (x B A C y)
 (x B C A y)
 (x B A y)
 (x C A B y)
 (x C B A y)

1.4.1.2.2 Indirection in Modified BNF Syntax
............................................

An indirection extension is introduced in order to make this new syntax
more readable:

     ûO

If O is a non-terminal symbol, the right-hand side of its definition is
substituted for the entire expression ûO.  For example, the following
BNF is equivalent to the BNF in the previous example:

ÿ(x ùûOø y)þ

O::=
     ÿAþ | ÿBþ* | ÿCþ

1.4.1.2.3 Additional Uses for Indirect Definitions in Modified BNF Syntax
.........................................................................

In some cases, an auxiliary definition in the BNF might appear to be
unused within the BNF, but might still be useful elsewhere.  For
example, consider the following definitions:

 -- Macro: case keyform {ûnormal-clause}* [ûotherwise-clause] ý
          {result}*

 -- Macro: ccase keyplace {ûnormal-clause}* ý {result}*

 -- Macro: ecase keyform {ûnormal-clause}* ý {result}*

NORMAL-CLAUSE::=
     (keys {form}*)

OTHERWISE-CLAUSE::=
     ({otherwise | t} {form}*)

CLAUSE::=
     normal-clause | otherwise-clause

Here the term "CLAUSE" might appear to be "dead" in that it is not used
in the BNF.  However, the purpose of the BNF is not just to guide
parsing, but also to define useful terms for reference in the
descriptive text which follows.  As such, the term "CLAUSE" might
appear in text that follows, as shorthand for "NORMAL-CLAUSE or
OTHERWISE-CLAUSE."

1.4.1.3 Special Symbols
.......................

The special symbols described here are used as a notational convenience
within this document, and are part of neither the Common Lisp language
nor its environment.

ý
     This indicates evaluation.  For example:

      (+ 4 5) ý 9

     This means that the result of evaluating the form ÿ(+ 4 5)þ is ÿ9þ.

     If a form returns multiple values, those values might be shown
     separated by spaces, line breaks, or commas.  For example:

      (truncate 7 5)
     ý 1 2
      (truncate 7 5)
     ý 1
        2
      (truncate 7 5)
     ý 1, 2

     Each of the above three examples is equivalent, and specifies that
     ÿ(truncate 7 5)þ returns two values, which are ÿ1þ and ÿ2þ.

     Some conforming implementations actually type an arrow (or some
     other indicator) before showing return values, while others do not.

orý
     The notation "orý" is used to denote one of several possible
     alternate results.  The example

      (char-name #\a)
     ý NIL
     orý "LOWERCASE-a"
     orý "Small-A"
     orý "LA01"

     indicates that ÿnilþ, ÿ"LOWERCASE-a"þ, ÿ"Small-A"þ, ÿ"LA01"þ are
     among the possible results of ÿ(char-name #\a)þ--each with equal
     preference.  Unless explicitly specified otherwise, it should not
     be assumed that the set of possible results shown is exhaustive.
     Formally, the above example is equivalent to

      (char-name #\a) ý implementation-dependent

     but it is intended to provide additional information to illustrate
     some of the ways in which it is permitted for implementations to
     diverge.

notý
     The notation "notý" is used to denote a result which is not
     possible.  This might be used, for example, in order to emphasize
     a situation where some anticipated misconception might lead the
     reader to falsely believe that the result might be possible.  For
     example,

      (function-lambda-expression
         (funcall #'(lambda (x) #'(lambda () x)) nil))
     ý NIL, true, NIL
     orý (LAMBDA () X), true, NIL
     notý NIL, false, NIL
     notý (LAMBDA () X), false, NIL

Õ
     This indicates code equivalence. For example:

      (gcd x (gcd y z)) Õ (gcd (gcd x y) z)

     This means that the results and observable side-effects of
     evaluating the form ÿ(gcd x (gcd y z))þ  are always the same as
     the results and observable side-effects of ÿ(gcd (gcd x y) z)þ 
     for any ÿxþ, ÿyþ, and ÿzþ.

Ö
     Common Lisp specifies input and output with respect to a
     non-interactive stream model.  The specific details of how
     interactive input and output are mapped onto that non-interactive
     model are implementation-defined.

     For example, conforming implementations are permitted to differ in
     issues of how interactive input is terminated.  For example, the
     function ÿreadþ terminates when the final delimiter is typed on a
     non-interactive stream.  In some implementations, an interactive
     call to ÿreadþ returns as soon as the final delimiter is typed,
     even if that delimiter is not a newline.  In other
     implementations, a final newline is always required.  In still
     other implementations, there might be a command which "activates"
     a buffer full of input without the command itself being visible on
     the program's input stream.

     In the examples in this document, the notation "Ö" precedes lines
     where interactive input and output occurs.  Within such a scenario,
     "`this notation'" notates user input.

     For example, the notation

      (+ 1 (print (+ (sqrt (read)) (sqrt (read)))))
     Ö 9 16
     Ö 7
     ý 8

     shows an interaction in which "ÿ(+ 1 (print (+ (sqrt (read)) (sqrt
     (read)))))þ" is a form to be evaluated, "ÿ9 16 þ" is interactive
     input, "ÿ7þ" is interactive output, and "ÿ8þ" is the value yielded
     from the evaluation.

     The use of this notation is intended to disguise small differences
     in interactive input and output behavior between implementations.

     Sometimes, the non-interactive stream model calls for a newline.
     How that newline character is interactively entered is an
     implementation-defined detail of the user interface, but in that
     case, either the notation "<Newline>" or "ô" might be used.

      (progn (format t "~&Who? ") (read-line))
     Ö Who? Fred, Mary, and Sallyô
     ý "Fred, Mary, and Sally", false


1.4.1.4 Objects with Multiple Notations
.......................................

Some objects in Common Lisp can be notated in more than one way.  In
such situations, the choice of which notation to use is technically
arbitrary, but conventions may exist which convey a "point of view" or
"sense of intent."

1.4.1.4.1 Case in Symbols
.........................

While case is significant in the process of interning a symbol, the
Lisp reader, by default, attempts to canonicalize the case of a symbol
prior to interning; see *Note Section 23.1.2 (Effect of Readtable Case
on the Lisp Reader): Effect of Readtable Case on the Lisp Reader.  As
such, case in symbols is not, by default, significant.  Throughout this
document, except as explicitly noted otherwise, the case in which a
symbol appears is not significant; that is, ÿHELLOþ, ÿHelloþ, ÿhElLoþ,
and ÿhelloþ are all equivalent ways to denote a symbol whose name is
ÿ"HELLO"þ.

The characters backslash and vertical-bar are used to explicitly quote
the case and other parsing-related aspects of characters.  As such, the
notations ÿ|hello|þ and ÿ\h\e\l\l\oþ are equivalent ways to refer to a
symbol whose name is ÿ"hello"þ, and which is distinct from any symbol
whose name is ÿ"HELLO"þ.

The symbols that correspond to Common Lisp defined names have uppercase
names even though their names generally appear in lowercase in this
document.

1.4.1.4.2 Numbers
.................

Although Common Lisp provides a variety of ways for programs to
manipulate the input and output radix for rational numbers, all numbers
in this document are in decimal notation unless explicitly noted
otherwise.

1.4.1.4.3 Use of the Dot Character
..................................

The dot appearing by itself in an expression such as

ÿ(ITEM1 ITEM2 . TAIL)þ

means that TAIL represents a list of objects at the end of a list.  For
example,

ÿ(A B C . (D E F))þ

is notationally equivalent to:

ÿ(A B C D E F)þ

Although dot is a valid constituent character in a symbol, no
standardized symbols contain the character dot, so a period that
follows a reference to a symbol at the end of a sentence in this
document should always be interpreted as a period and never as part of
the symbol's name.  For example, within this document, a sentence such
as "This sample sentence refers to the symbol ÿcarþ."  refers to a
symbol whose name is ÿ"CAR"þ (with three letters), and never to a
four-letter symbol ÿ"CAR."þ

1.4.1.4.4 NIL
.............

ÿnilþ has a variety of meanings.  It is a symbol in the ÿCOMMON-LISPþ
package with the name ÿ"NIL"þ, it is boolean (and generalized boolean)
false, it is the empty list, and it is the name of the empty type (a
subtype of all types).

Within Common Lisp, ÿnilþ can be notated interchangeably as either
ÿNILþ or ÿ()þ.  By convention, the choice of notation offers a hint as
to which of its many roles it is playing.

For Evaluation?   Notation   Typically Implied Role
Yes               ÿnilþ      use as a boolean.
Yes               ÿ'nilþ     use as a symbol.
Yes               ÿ'()þ      use as an empty list
No                ÿnilþ      use as a symbol or boolean.
No                ÿ()þ       use as an empty list.

Figure 1.1: Notations for NIL

Within this document only, ÿnilþ is also sometimes notated as false to
emphasize its role as a boolean.

For example:

 (print ())                          ;avoided
 (defun three nil 3)                 ;avoided
 '(nil nil)                          ;list of two symbols
 '(() ())                            ;list of empty lists
 (defun three () 3)                  ;Emphasize empty parameter list.
 (append '() '()) ý ()              ;Emphasize use of empty lists
 (not nil) ý true                   ;Emphasize use as Boolean false
 (get 'nil 'color)                   ;Emphasize use as a symbol

A function is sometimes said to "be false" or "be true" in some
circumstance.  Since no function object can be the same as ÿnilþ  and
all function objects represent true when viewed as booleans, it would
be meaningless to say that the function was literally false and
uninteresting to say that it was literally true.  Instead, these
phrases are just traditional alternative ways of saying that the
function "returns false" or "returns true," respectively.

1.4.1.5 Designators
...................

A "designator" is an object that denotes another object.

Where a parameter of an operator is described as a designator, the
description of the operator is written in a way that assumes that the
value of the parameter is the denoted object; that is, that the
parameter is already of the denoted type.  (The specific nature of the
object denoted by a "«type» designator" or a "designator for a «type»"
can be found in the Glossary entry for "«type» designator.")

For example, "ÿnilþ" and "the value of ÿ*standard-output*þ" are
operationally indistinguishable as stream designators.  Similarly, the
symbol ÿfooþ and the string ÿ"FOO"þ are operationally indistinguishable
as string designators.

Except as otherwise noted, in a situation where the denoted object
might be used multiple times, it is implementation-dependent whether
the object is coerced only once or whether the coercion occurs each
time the object must be used.

For example, ÿmapcarþ receives a function designator as an argument,
and its description is written as if this were simply a function.  In
fact, it is implementation-dependent whether the function designator is
coerced right away or whether it is carried around internally in the
form that it was given as an argument and re-coerced each time it is
needed.  In most cases, conforming programs cannot detect the
distinction, but there are some pathological situations (particularly
those involving self-redefining or mutually-redefining functions) which
do conform and which can detect this difference.  The following program
is a conforming program, but might or might not have portably correct
results, depending on whether its correctness depends on one or the
other of the results:

 (defun add-some (x)
   (defun add-some (x) (+ x 2))
   (+ x 1)) ý ADD-SOME
 (mapcar 'add-some '(1 2 3 4))
ý (2 3 4 5)
orý (2 4 5 6)

In a few rare situations, there may be a need in a dictionary entry to
refer to the object that was the original designator for a parameter.
Since naming the parameter would refer to the denoted object, the
phrase "the «parameter-name» designator" can be used to refer to the
designator which was the argument from which the value of
«parameter-name» was computed.

1.4.1.6 Nonsense Words
......................

When a word having no pre-attached semantics is required (e.g., in an
example), it is common in the Lisp community to use one of the words
"foo," "bar," "baz," and "quux."  For example, in

 (defun foo (x) (+ x 1))

the use of the name ÿfooþ is just a shorthand way of saying "please
substitute your favorite name here."

These nonsense words have gained such prevalance of usage, that it is
commonplace for newcomers to the community to begin to wonder if there
is an attached semantics which they are overlooking--there is not.


File: chris-ansicl.info,  Node: Error Terminology,  Next: Sections Not Formally Part Of This Standard,  Prev: Notational Conventions,  Up: Definitions

1.4.2 Error Terminology
-----------------------

Situations in which errors might, should, or must be signaled are
described in the standard.  The wording used to describe such
situations is intended to have precise meaning. The following list is a
glossary of those meanings.

Safe code
     This is code processed with the ÿsafetyþ optimization at its
     highest setting (ÿ3þ).  ÿsafetyþ is a lexical property of code.
     The phrase "the function ÿFþ should signal an error" means that if
     ÿFþ is invoked from code processed with the highest ÿsafetyþ
     optimization, an error is signaled.  It is
     implementation-dependent whether ÿFþ or the calling code signals
     the error.

Unsafe code
     This is code processed with lower safety levels.

     Unsafe code might do error checking.  Implementations are
     permitted to treat all code as safe code all the time.

An error is signaled
     This means that an error is signaled in both safe and unsafe code.
     Conforming code may rely on the fact that the error is signaled in
     both safe and unsafe code.  Every implementation is required to
     detect the error in both safe and unsafe code. For example, "an
     error is signaled if ÿunexportþ is given a symbol not accessible
     in the current package."

     If an explicit error type is not specified, the default is ÿerrorþ.

An error should be signaled
     This means that an error is signaled in safe code, and an error
     might be signaled in unsafe code.  Conforming code may rely on the
     fact that the error is signaled in safe code.  Every
     implementation is required to detect the error at least in safe
     code.  When the error is not signaled, the "consequences are
     undefined" (see below).  For example, "ÿ+þ should signal an error
     of type ÿtype-errorþ if any argument is not of type ÿnumberþ."

Should be prepared to signal an error
     This is similar to "should be signaled" except that it does not
     imply that `extra effort' has to be taken on the part of an
     operator to discover an erroneous situation if the normal action
     of that operator can be performed successfully with only `lazy'
     checking.  An implementation is always permitted to signal an
     error, but even in safe code, it is only required to signal the
     error when failing to signal it might lead to incorrect results.
     In unsafe code, the consequences are undefined.

     For example, defining that "ÿfindþ should be prepared to signal an
     error of type ÿtype-errorþ if its second argument is not a proper
     list" does not imply that an error is always signaled.  The form

      (find 'a '(a b . c))

     must either signal an error of type ÿtype-errorþ in safe code,
     else return ÿAþ.  In unsafe code, the consequences are undefined.
     By contrast,

      (find 'd '(a b . c))

     must signal an error of type ÿtype-errorþ in safe code.  In unsafe
     code, the consequences are undefined.  Also,

      (find 'd '#1=(a b . #1#))

     in safe code might return ÿnilþ (as an implementation-defined
     extension), might never return, or might signal an error of type
     ÿtype-errorþ.  In unsafe code, the consequences are undefined.

     Typically, the "should be prepared to signal" terminology is used
     in type checking situations where there are efficiency
     considerations that make it impractical to detect errors that are
     not relevant to the correct operation of the operator.

The consequences are unspecified
     This means that the consequences are unpredictable but harmless.
     Implementations are permitted to specify the consequences of this
     situation. No conforming code may depend on the results or effects
     of this situation, and all conforming code is required to treat the
     results and effects of this situation as unpredictable but
     harmless.  For example, "if the second argument to
     ÿshared-initializeþ specifies a name that does not correspond to
     any slots accessible in the object, the results are unspecified."

The consequences are undefined
     This means that the consequences are unpredictable. The
     consequences may range from harmless to fatal.  No conforming code
     may depend on the results or effects. Conforming code must treat
     the consequences as unpredictable.  In places where the words
     "must," "must not," or "may not" are used, then "the consequences
     are undefined" if the stated requirement is not met and no
     specific consequence is explicitly stated.  An implementation is
     permitted to signal an error in this case.

     For example: "Once a name has been declared by ÿdefconstantþ to be
     constant, any further assignment or binding of that variable has
     undefined consequences."

An error might be signaled
     This means that the situation has undefined consequences; however,
     if an error is signaled, it is of the specified type.  For
     example, "ÿopenþ might signal an error of type ÿfile-errorþ."

The return values are unspecified
     This means that only the number and nature of the return values of
     a form are not specified.  However, the issue of whether or not
     any side-effects or transfer of control occurs is still
     well-specified.

     A program can be well-specified even if it uses a function whose
     returns values are unspecified.  For example, even if the return
     values of some function ÿFþ are unspecified, an expression such as
     ÿ(length (list (F)))þ is still well-specified because it does not
     rely on any particular aspect of the value or values returned by
     ÿFþ.

Implementations may be extended to cover this situation
     This means that the situation has undefined consequences; however,
     a conforming implementation is free to treat the situation in a
     more specific way.  For example, an implementation might define
     that      an error is signaled, or that      an error should be
     signaled, or even that a certain well-defined non-error behavior
     occurs.

     No conforming code may depend on the consequences of such a
     situation; all conforming code must treat the consequences of the
     situation as undefined. Implementations are required to document
     how the situation is treated.

     For example, "implementations may be extended to define other type
     specifiers to have a corresponding class."

Implementations are free to extend the syntax
     This means that in this situation implementations are permitted to
     define unambiguous extensions to the syntax of the form being
     described.  No conforming code may depend on this extension.
     Implementations are required to document each such extension. All
     conforming code is required to treat the syntax as meaningless. The
     standard might disallow certain extensions while allowing others.
     For example, "no implementation is free to extend the syntax of
     ÿdefclassþ."

A warning might be issued
     This means that implementations are encouraged to issue a warning
     if the context is appropriate (e.g., when compiling).  However, a
     conforming implementation is not required to issue a warning.


File: chris-ansicl.info,  Node: Sections Not Formally Part Of This Standard,  Next: Interpreting Dictionary Entries,  Prev: Error Terminology,  Up: Definitions

1.4.3 Sections Not Formally Part Of This Standard
-------------------------------------------------

Front matter and back matter, such as the "Table of Contents," "Index,"
"Figures," "Credits," and "Appendix" are not considered formally part
of this standard, so that we retain the flexibility needed to update
these sections even at the last minute without fear of needing a formal
vote to change those parts of the document.  These items are quite short
and very useful, however, and it is not recommended that they be removed
even in an abridged version of this document.

Within the concept sections, subsections whose names begin with the
words "Note" or "Notes" or "Example" or "Examples" are provided for
illustration purposes only, and are not considered part of the standard.

An attempt has been made to place these sections last in their parent
section, so that they could be removed without disturbing the
contiguous numbering of the surrounding sections in order to produce a
document of smaller size.

Likewise, the "Examples" and "Notes" sections in a dictionary entry are
not considered part of the standard and could be removed if necessary.

Nevertheless, the examples provide important clarifications and
consistency checks for the rest of the material, and such abridging is
not recommended unless absolutely unavoidable.


File: chris-ansicl.info,  Node: Interpreting Dictionary Entries,  Prev: Sections Not Formally Part Of This Standard,  Up: Definitions

1.4.4 Interpreting Dictionary Entries
-------------------------------------

The dictionary entry for each defined name is partitioned into
sections.  Except as explicitly indicated otherwise below, each section
is introduced by a label identifying that section.  The omission of a
section implies that the section is either not applicable, or would
provide no interesting information.

This section defines the significance of each potential section in a
dictionary entry.

1.4.4.1 The "Affected By" Section of a Dictionary Entry
.......................................................

For an operator, anything that can affect the side effects of or values
returned by the operator.

For a variable, anything that can affect the value of the variable
including functions that bind or assign it.

1.4.4.2 The "Arguments" Section of a Dictionary Entry
.....................................................

This information describes the syntax information of entries such as
those for declarations and special expressions which are never evaluated
as forms, and so do not return values.

1.4.4.3 The "Arguments and Values" Section of a Dictionary Entry
................................................................

An English language description of what arguments the operator accepts
and what values it returns, including information about defaults for
parameters corresponding to omittable arguments (such as optional
parameters and keyword parameters).  For special operators and macros,
their arguments are not evaluated unless it is explicitly stated in
their descriptions that they are evaluated.

Except as explicitly specified otherwise, the consequences are
undefined if these type restrictions are violated.

1.4.4.4 The "Binding Types Affected" Section of a Dictionary Entry
..................................................................

This information alerts the reader to the kinds of bindings that might
potentially be affected by a declaration.  Whether in fact any
particular such binding is actually affected is dependent on additional
factors as well.  See the "Description" section of the declaration in
question for details.

1.4.4.5 The "Class Precedence List" Section of a Dictionary Entry
.................................................................

This appears in the dictionary entry for a class, and contains an
ordered list of the classes defined by Common Lisp that must be in the
class precedence list of this class.

It is permissible for other (implementation-defined) classes to appear
in the implementation's class precedence list for the class.

It is permissible for either ÿstandard-objectþ or ÿstructure-objectþ to
appear in the implementation's class precedence list; for details, see
*Note Section 4.2.2 (Type Relationships): Type Relationships.

Except as explicitly indicated otherwise somewhere in this
specification, no additional standardized classes may appear in the
implementation's class precedence list.

By definition of the relationship between classes and types, the
classes listed in this section are also supertypes of the type denoted
by the class.

1.4.4.6 Dictionary Entries for Type Specifiers
..............................................

The atomic type specifiers are those defined names listed in *Note
Figure 4.2: StandardizedAtomicTypeSpecs.  Such dictionary entries are
of kind "Class," "Condition Type," "System Class," or "Type."  A
description of how to interpret a symbol naming one of these types or
classes as an atomic type specifier is found in the "Description"
section of such dictionary entries.

The compound type specifiers are those defined names listed in *Note
Figure 4.3: StandardizedCompoundTypeSpecNames.  Such dictionary entries
are of kind "Class," "System Class," "Type," or "Type Specifier."  A
description of how to interpret as a compound type specifier a list
whose car is such a symbol is found in the "Compound Type Specifier
Kind," "Compound Type Specifier Syntax," "Compound Type Specifier
Arguments," and "Compound Type Specifier Description" sections of such
dictionary entries.

1.4.4.6.1 The "Compound Type Specifier Kind" Section of a Dictionary Entry
..........................................................................

An "abbreviating" type specifier is one that describes a subtype for
which it is in principle possible to enumerate the elements, but for
which in practice it is impractical to do so.

A "specializing" type specifier is one that describes a subtype by
restricting the type of one or more components of the type, such as
element type or complex part type.

A "predicating" type specifier is one that describes a subtype
containing only those objects that satisfy a given predicate.

A "combining" type specifier is one that describes a subtype in a
compositional way, using combining operations (such as "and," "or," and
"not") on other types.

1.4.4.6.2 The "Compound Type Specifier Syntax" Section of a Dictionary Entry
............................................................................

This information about a type describes the syntax of a compound type
specifier for that type.

Whether or not the type is acceptable as an atomic type specifier is
not represented here; see *Note Section 1.4.4.6 (Dictionary Entries for
Type Specifiers): TypeSpecEntries.

1.4.4.6.3 The "Compound Type Specifier Arguments" Section of a Dictionary Entry
...............................................................................

This information describes type information for the structures defined
in the "Compound Type Specifier Syntax" section.

1.4.4.6.4 The "Compound Type Specifier Description" Section of a Dictionary Entry
.................................................................................

This information describes the meaning of the structures defined in the
"Compound Type Specifier Syntax" section.

1.4.4.7 The "Constant Value" Section of a Dictionary Entry
..........................................................

This information describes the unchanging type and value of a constant
variable.

1.4.4.8 The "Description" Section of a Dictionary Entry
.......................................................

A summary of the operator and all intended aspects of the operator, but
does not necessarily include all the fields referenced below it ("Side
Effects," "Exceptional Situations," etc.)

1.4.4.9 The "Examples" Section of a Dictionary Entry
....................................................

Examples of use of the operator.  These examples are not considered
part of the standard; see *Note Section 1.4.3 (Sections Not Formally
Part Of This Standard): Sections Not Formally Part Of This Standard.

1.4.4.10 The "Exceptional Situations" Section of a Dictionary Entry
...................................................................

Three kinds of information may appear here:

   * Situations that are detected by the function and formally signaled.

   * Situations that are handled by the function.

   * Situations that may be detected by the function.

This field does not include conditions that could be signaled by
functions passed to and called by this operator as arguments or through
dynamic variables, nor by executing subforms of this operator if it is
a macro or special operator.

1.4.4.11 The "Initial Value" Section of a Dictionary Entry
..........................................................

This information describes the initial value of a dynamic variable.
Since this variable might change, see type restrictions in the "Value
Type" section.

1.4.4.12 The "Argument Precedence Order" Section of a Dictionary Entry
......................................................................

This information describes the argument precedence order.  If it is
omitted, the argument precedence order is the default (left to right).

1.4.4.13 The "Method Signature" Section of a Dictionary Entry
.............................................................

The description of a generic function includes descriptions of the
methods that are defined on that generic function by the standard.  A
method signature is used to describe the parameters and parameter
specializers for each method.  Methods defined for the generic function
must be of the form described by the method signature.

F (X CLASS) (Y t) &optional Z &key K

This signature indicates that this method on the generic function F has
two required parameters: X, which must be a generalized instance of the
class CLASS; and Y, which can  be any object (i.e., a generalized
instance of the class ÿtþ).  In addition, there is an optional
parameter Z and a keyword parameter K.  This signature also indicates
that this method on ÿFþ is a primary method and has no qualifiers.

For each parameter, the argument supplied must be in the intersection
of the type specified in the description of the corresponding generic
function and the type given in the signature of some method (including
not only those methods defined in this specification, but also
implementation-defined or user-defined methods in situations where the
definition of such methods is permitted).

1.4.4.14 The "Name" Section of a Dictionary Entry
.................................................

This section introduces the dictionary entry.  It is not explicitly
labeled.  It appears preceded and followed by a horizontal bar.

In large print at left, the defined name appears; if more than one
defined name is to be described by the entry, all such names are shown
separated by commas.

In somewhat smaller italic print at right is an indication of what kind
of dictionary entry this is.  Possible values are:

Accessor
     This is an accessor function.

Class
     This is a class.

Condition Type
     This is a subtype of type ÿconditionþ.

Constant Variable
     This is a constant variable.

Declaration
     This is a declaration identifier.

Function
     This is a function.

Local Function
     This is a function that is defined only lexically within the scope
     of some other macro form.

Local Macro
     This is a macro that is defined only lexically within the scope of
     some other macro form.

Macro
     This is a macro.

Restart
     This is a restart.

Special Operator
     This is a special operator.

Standard Generic Function
     This is a standard generic function.

Symbol
     This is a symbol that is specially recognized in some particular
     situation, such as the syntax of a macro.

System Class
     This is like class, but it identifies a class that is potentially
     a built-in class.  (No class is actually required to be a built-in
     class.)

Type
     This is an atomic type specifier, and depending on information for
     each particular entry, may subject to form other type specifiers.

Type Specifier
     This is a defined name that is not an atomic type specifier, but
     that can be used in constructing valid type specifiers.

Variable
     This is a dynamic variable.

1.4.4.15 The "Notes" Section of a Dictionary Entry
..................................................

Information not found elsewhere in this description which pertains to
this operator.  Among other things, this might include cross reference
information, code equivalences, stylistic hints, implementation hints,
typical uses.  This information is not considered part of the standard;
any conforming implementation or conforming program is permitted to
ignore the presence of this information.

1.4.4.16 The "Pronunciation" Section of a Dictionary Entry
..........................................................

This offers a suggested pronunciation for defined names so that people
not in verbal communication with the original designers can figure out
how to pronounce words that are not in normal English usage.  This
information is advisory only, and is not considered part of the
standard.  For brevity, it is only provided for entries with names that
are specific to Common Lisp and would not be found in `Webster's Third
New International Dictionary the English Language, Unabridged'.

1.4.4.17 The "See Also" Section of a Dictionary Entry
.....................................................

List of references to other parts of this standard that offer
information relevant to this operator.  This list is not part of the
standard.

1.4.4.18 The "Side Effects" Section of a Dictionary Entry
.........................................................

Anything that is changed as a result of the evaluation of the form
containing this operator.

1.4.4.19 The "Supertypes" Section of a Dictionary Entry
.......................................................

This appears in the dictionary entry for a type, and contains a list of
the standardized types that must be supertypes of this type.

In implementations where there is a corresponding class, the order of
the classes in the class precedence list is consistent with the order
presented in this section.

1.4.4.20 The "Syntax" Section of a Dictionary Entry
...................................................

This section describes how to use the defined name in code.  The
"Syntax" description for a generic function describes the lambda list
of the generic function itself, while the "Method Signatures" describe
the lambda lists of the defined methods.  The "Syntax" description for
an ordinary function, a macro, or a special operator describes its
parameters.

For example, an operator description might say:

 -- Function: F x y &optional z &key k

This description indicates that the function F has two required
parameters, X and Y.  In addition, there is an optional parameter Z and
a keyword parameter K.

For macros and special operators, syntax is given in modified BNF
notation; see *Note Section 1.4.1.2 (Modified BNF Syntax): ModifiedBNF.
For functions a lambda list is given.  In both cases, however, the
outermost parentheses are omitted, and default value information is
omitted.

1.4.4.20.1 Special "Syntax" Notations for Overloaded Operators
..............................................................

If two descriptions exist for the same operation but with different
numbers of arguments, then the extra arguments are to be treated as
optional.  For example, this pair of lines:

 -- Function: file-position stream ý position

 -- Function: file-position stream position-spec ý success-p

is operationally equivalent to this line:

 -- Function: file-position stream &optional position-spec ý result

and differs only in that it provides on opportunity to introduce
different names for parameter and values for each case.  The separated
(multi-line) notation is used when an operator is overloaded in such a
way that the parameters are used in different ways depending on how
many arguments are supplied (e.g., for the function ÿ/þ) or the return
values are different in the two cases (e.g., for the function
ÿfile-positionþ).

1.4.4.20.2 Naming Conventions for Rest Parameters
.................................................

Within this specification, if the name of a rest parameter is chosen to
be a plural noun, use of that name in PARAMETER font refers to the list
to which the rest parameter is bound.  Use of the singular form of that
name in PARAMETER font refers to an element of that list.

For example, given a syntax description such as:

 -- Function: F &rest ARGUMENTS

it is appropriate to refer either to the rest parameter named ARGUMENTS
by name, or to one of its elements by speaking of "an ARGUMENT," "some
ARGUMENT," "each ARGUMENT" etc.

1.4.4.20.3 Requiring Non-Null Rest Parameters in the "Syntax" Section
.....................................................................

In some cases it is useful to refer to all arguments equally as a single
aggregation using a rest parameter while at the same time requiring at
least one argument.  A variety of imperative and declarative means are
available in code for expressing such a restriction, however they
generally do not manifest themselves in a lambda list.  For descriptive
purposes within this specification,

 -- Function: F &rest arguments+

means the same as

 -- Function: F &rest arguments

but introduces the additional requirement that there be at least one
ARGUMENT.

1.4.4.20.4 Return values in the "Syntax" Section
................................................

An evaluation arrow "ý" precedes a list of values to be returned.  For
example:

 -- Function: F a b c ý x

indicates that ÿFþ is an operator that has three required parameters
(i.e., A, B, and C) and that returns one value (i.e., X).  If more than
one value is returned by an operator, the names of the values are
separated by commas, as in:

 -- Function: F a b c ý x, y, z

1.4.4.20.4.1 No Arguments or Values in the "Syntax" Section
...........................................................

If no arguments are permitted, or no values are returned, a special
notation is used to make this more visually apparent.  For example,

 -- Function: F <no arguments> ý <no values>

indicates that ÿFþ is an operator that accepts no arguments and returns
no values.

1.4.4.20.4.2 Unconditional Transfer of Control in the "Syntax" Section
......................................................................

Some operators perform an unconditional transfer of control, and so
never have any return values.  Such operators are notated using a
notation such as the following:

 -- Function: F a b c ý|

1.4.4.21 The "Valid Context" Section of a Dictionary Entry
..........................................................

This information is used by dictionary entries such as "Declarations"
in order to restrict the context in which the declaration may appear.

A given "Declaration" might appear in a declaration (i.e., a declare
expression), a proclamation (i.e., a ÿdeclaimþ or ÿproclaimþ form), or
both.

1.4.4.22 The "Value Type" Section of a Dictionary Entry
.......................................................

This information describes any type restrictions on a dynamic variable.

Except as explicitly specified otherwise, the consequences are
undefined if this type restriction is violated.


File: chris-ansicl.info,  Node: Conformance,  Next: Language Extensions,  Prev: Definitions,  Up: Introduction

1.5 Conformance
===============

This standard presents the syntax and semantics to be implemented by a
conforming implementation (and its accompanying documentation).  In
addition, it imposes requirements on conforming programs.

* Menu:

* Conforming Implementations::
* Conforming Programs::


File: chris-ansicl.info,  Node: Conforming Implementations,  Next: Conforming Programs,  Up: Conformance

1.5.1 Conforming Implementations
--------------------------------

A "conforming implementation" shall adhere to the requirements outlined
in this section.

1.5.1.1 Required Language Features
..................................

A conforming implementation shall accept all features (including
deprecated features) of the language specified in this standard, with
the meanings defined in this standard.

A conforming implementation shall not require the inclusion of
substitute or additional language elements in code in order to
accomplish a feature of the language that is specified in this standard.

1.5.1.2 Documentation of Implementation-Dependent Features
..........................................................

A conforming implementation shall be accompanied by a document that
provides a definition of all implementation-defined aspects of the
language defined by this specification.

In addition, a conforming implementation is encouraged (but not
required) to document items in this standard that are identified as
implementation-dependent, although in some cases such documentation
might simply identify the item as "undefined."

1.5.1.3 Documentation of Extensions
...................................

A conforming implementation shall be accompanied by a document that
separately describes any features accepted by the implementation that
are not specified in this standard, but that do not cause any ambiguity
or contradiction when added to the language standard.  Such extensions
shall be described as being "extensions to Common Lisp as specified by
ANSI «standard number»."

1.5.1.4 Treatment of Exceptional Situations
...........................................

A conforming implementation shall treat exceptional situations in a
manner consistent with this specification.

1.5.1.4.1 Resolution of Apparent Conflicts in Exceptional Situations
....................................................................

If more than one passage in this specification appears to apply to the
same situation but in conflicting ways, the passage that appears to
describe the situation in the most specific way (not necessarily the
passage that provides the most constrained kind of error detection)
takes precedence.

1.5.1.4.1.1 Examples of Resolution of Apparent Conflicts
........................................................

in Exceptional Situations

Suppose that function ÿfooþ is a member of a set S of functions that
operate on numbers.  Suppose that one passage states that an error must
be signaled if any function in S is ever given an argument of ÿ17þ.
Suppose that an apparently conflicting passage states that the
consequences are undefined if ÿfooþ receives an argument of ÿ17þ.  Then
the second passage (the one specifically about ÿfooþ) would dominate
because the description of the situational context is the most
specific, and it would not be required that ÿfooþ signal an error on an
argument of ÿ17þ even though other functions in the set S would be
required to do so.

1.5.1.5 Conformance Statement
.............................

A conforming implementation shall produce a conformance statement as a
consequence of using the implementation, or that statement shall be
included in the accompanying documentation.  If the implementation
conforms in all respects with this standard, the conformance statement
shall be


     "«Implementation» conforms with the requirements of ANSI «standard
     number»"

If the implementation conforms with some but not all of the
requirements of this standard, then the conformance statement shall be


     "«Implementation» conforms with the requirements of ANSI «standard
     number» with the following exceptions: «reference to or complete
     list of the requirements of the standard with which the
     implementation does not conform»."


File: chris-ansicl.info,  Node: Conforming Programs,  Prev: Conforming Implementations,  Up: Conformance

1.5.2 Conforming Programs
-------------------------

Code conforming with the requirements of this standard shall adhere to
the following:

  1. Conforming code shall use only those features of the language
     syntax and semantics that are either specified in this standard or
     defined using the extension mechanisms specified in the standard.

  2. Conforming code may use implementation-dependent features and
     values, but shall not rely upon any particular interpretation of
     these features and values other than those that are discovered by
     the execution of code.

  3. Conforming code shall not depend on the consequences of undefined
     or unspecified situations.

  4. Conforming code does not use any constructions that are prohibited
     by the standard.

  5. Conforming code does not depend on extensions included in an
     implementation.

1.5.2.1 Use of Implementation-Defined Language Features
.......................................................

Note that conforming code may rely on particular implementation-defined
values or features. Also note that the requirements for conforming code
and conforming implementations do not require that the results produced
by conforming code always be the same when processed by a conforming
implementation. The results may be the same, or they may differ.

Conforming code may run in all conforming implementations, but might
have allowable implementation-defined behavior that makes it
non-portable code.  For example, the following are examples of forms
that are conforming, but that might return different values in
different implementations:

 (evenp most-positive-fixnum) ý implementation-dependent
 (random) ý implementation-dependent
 (> lambda-parameters-limit 93) ý implementation-dependent
 (char-name #\A) ý implementation-dependent

1.5.2.1.1 Use of Read-Time Conditionals
.......................................

Use of ÿ#+þ and ÿ#-þ does not automatically disqualify a program from
being conforming.  A program which uses ÿ#+þ and ÿ#-þ is considered
conforming if there is no set of features in which the program would
not be conforming.  Of course, conforming programs are not necessarily
working programs.  The following program is conforming:

(defun foo ()
  #+ACME (acme:initialize-something)
  (print 'hello-there))

However, this program might or might not work, depending on whether the
presence of the feature ÿACMEþ really implies that a function named
ÿacme:initialize-somethingþ is present in the environment.  In effect,
using ÿ#+þ or ÿ#-þ in a conforming program means that the variable
ÿ*features*þ becomes just one more piece of input data to that program.
Like any other data coming into a program, the programmer is
responsible for assuring that the program does not make unwarranted
assumptions on the basis of input data.

1.5.2.2 Character Set for Portable Code
.......................................

Portable code is written using only standard characters.


File: chris-ansicl.info,  Node: Language Extensions,  Next: Language Subsets,  Prev: Conformance,  Up: Introduction

1.6 Language Extensions
=======================

A language extension is any documented implementation-defined behavior
of a defined name in this standard that varies from the behavior
described in this standard, or a documented consequence of a situation
that the standard specifies as undefined, unspecified, or extendable by
the implementation.  For example, if this standard says that "the
results are unspecified," an extension would be to specify the results.

If the correct behavior of a program depends on the results provided by
an extension, only implementations with the same extension will execute
the program correctly.  Note that such a program might be
non-conforming.  Also, if this standard says that "an implementation
may be extended," a conforming, but possibly non-portable, program can
be written using an extension.

An implementation can have extensions, provided they do not alter the
behavior of conforming code and provided they are not explicitly
prohibited by this standard.

The term "extension" refers only to extensions available upon startup.
An implementation is free to allow or prohibit redefinition of an
extension.

The following list contains specific guidance to implementations
concerning certain types of extensions.

Extra return values
     An implementation must return exactly the number of return values
     specified by this standard unless the standard specifically
     indicates otherwise.

Unsolicited messages
     No output can be produced by a function other than that specified
     in the standard or due to the signaling of conditions detected by
     the function.

     Unsolicited output, such as garbage collection notifications and
     autoload heralds, should not go directly to the stream that is the
     value of a stream variable defined in this standard, but can go
     indirectly to terminal I/O by using a synonym stream to
     ÿ*terminal-io*þ.

     Progress reports from such functions as ÿloadþ and ÿcompileþ are
     considered solicited, and are not covered by this prohibition.

Implementation of macros and special forms
     Macros and special operators defined in this standard must not be
     functions.


File: chris-ansicl.info,  Node: Language Subsets,  Next: Deprecated Language Features,  Prev: Language Extensions,  Up: Introduction

1.7 Language Subsets
====================

The language described in this standard contains no subsets, though
subsets are not forbidden.

For a language to be considered a subset, it must have the property
that any valid program in that language has equivalent semantics and
will run directly (with no extralingual pre-processing, and no special
compatibility packages) in any conforming implementation of the full
language.

A language that conforms to this requirement shall be described as
being a "subset of Common Lisp as specified by ANSI «standard number»."


File: chris-ansicl.info,  Node: Deprecated Language Features,  Next: Symbols in the COMMON-LISP Package,  Prev: Language Subsets,  Up: Introduction

1.8 Deprecated Language Features
================================

Deprecated language features are not expected to appear in future
Common Lisp standards, but are required to be implemented for
conformance with this standard; see *Note Section 1.5.1.1 (Required
Language Features): ReqLangFeatures.

Conforming programs can use deprecated features; however, it is
considered good programming style to avoid them.  It is permissible for
the compiler to produce style warnings about the use of such features
at compile time, but there should be no such warnings at program
execution time.

* Menu:

* Deprecated Functions::
* Deprecated Argument Conventions::
* Deprecated Variables::
* Deprecated Reader Syntax::


File: chris-ansicl.info,  Node: Deprecated Functions,  Next: Deprecated Argument Conventions,  Up: Deprecated Language Features

1.8.1 Deprecated Functions
--------------------------

The functions in the next figure are deprecated.

assoc-if-not    nsubst-if-not        require
count-if-not    nsubstitute-if-not   set
delete-if-not   position-if-not      subst-if-not
find-if-not     provide              substitute-if-not
gentemp         rassoc-if-not        
member-if-not   remove-if-not        

Figure 1.2: Deprecated Functions


File: chris-ansicl.info,  Node: Deprecated Argument Conventions,  Next: Deprecated Variables,  Prev: Deprecated Functions,  Up: Deprecated Language Features

1.8.2 Deprecated Argument Conventions
-------------------------------------

The ability to pass a numeric argument to ÿgensymþ has been deprecated.

The :test-not argument to the functions in the next figure are
deprecated.

adjoin              nset-difference     search
assoc               nset-exclusive-or   set-difference
count               nsublis             set-exclusive-or
delete              nsubst              sublis
delete-duplicates   nsubstitute         subsetp
find                nunion              subst
intersection        position            substitute
member              rassoc              tree-equal
mismatch            remove              union
nintersection       remove-duplicates   

Figure 1.3: Functions with Deprecated :TEST-NOT Arguments

The use of the situation names compile, load, and eval in ÿeval-whenþ
is deprecated.


File: chris-ansicl.info,  Node: Deprecated Variables,  Next: Deprecated Reader Syntax,  Prev: Deprecated Argument Conventions,  Up: Deprecated Language Features

1.8.3 Deprecated Variables
--------------------------

The variable ÿ*modules*þ is deprecated.


File: chris-ansicl.info,  Node: Deprecated Reader Syntax,  Prev: Deprecated Variables,  Up: Deprecated Language Features

1.8.4 Deprecated Reader Syntax
------------------------------

The ÿ#Sþ reader macro forces keyword names into the ÿKEYWORDþ package;
see *Note Section 2.4.8.13 (Sharpsign S): SharpsignS.  This feature is
deprecated; in the future, keyword names will be taken in the package
they are read in, so symbols that are actually in the ÿKEYWORDþ package
should be used if that is what is desired.


File: chris-ansicl.info,  Node: Symbols in the COMMON-LISP Package,  Prev: Deprecated Language Features,  Up: Introduction

1.9 Symbols in the COMMON-LISP Package
======================================

The figures on the next twelve pages contain a complete enumeration of
the 978 external symbols in the ÿCOMMON-LISPþ package.  

&allow-other-keys             *print-miser-width*
&aux                          *print-pprint-dispatch*
&body                         *print-pretty*
&environment                  *print-radix*
&key                          *print-readably*
&optional                     *print-right-margin*
&rest                         *query-io*
&whole                        *random-state*
*                             *read-base*
**                            *read-default-float-format*
***                           *read-eval*
*break-on-signals*            *read-suppress*
*compile-file-pathname*       *readtable*
*compile-file-truename*       *standard-input*
*compile-print*               *standard-output*
*compile-verbose*             *terminal-io*
*debug-io*                    *trace-output*
*debugger-hook*               +
*default-pathname-defaults*   ++
*error-output*                +++
*features*                    -
*gensym-counter*              /
*load-pathname*               //
*load-print*                  ///
*load-truename*               /=
*load-verbose*                1+
*macroexpand-hook*            1-
*modules*                     <
*package*                     <=
*print-array*                 =
*print-base*                  >
*print-case*                  >=
*print-circle*                abort
*print-escape*                abs
*print-gensym*                acons
*print-length*                acos
*print-level*                 acosh
*print-lines*                 add-method

Figure 1.4: Symbols in the COMMON-LISP package (part one of twelve).

adjoin                       atom           boundp
adjust-array                 base-char      break
adjustable-array-p           base-string    broadcast-stream
allocate-instance            bignum         broadcast-stream-streams
alpha-char-p                 bit            built-in-class
alphanumericp                bit-and        butlast
and                          bit-andc1      byte
append                       bit-andc2      byte-position
apply                        bit-eqv        byte-size
apropos                      bit-ior        caaaar
apropos-list                 bit-nand       caaadr
aref                         bit-nor        caaar
arithmetic-error             bit-not        caadar
arithmetic-error-operands    bit-orc1       caaddr
arithmetic-error-operation   bit-orc2       caadr
array                        bit-vector     caar
array-dimension              bit-vector-p   cadaar
array-dimension-limit        bit-xor        cadadr
array-dimensions             block          cadar
array-displacement           boole          caddar
array-element-type           boole-1        cadddr
array-has-fill-pointer-p     boole-2        caddr
array-in-bounds-p            boole-and      cadr
array-rank                   boole-andc1    call-arguments-limit
array-rank-limit             boole-andc2    call-method
array-row-major-index        boole-c1       call-next-method
array-total-size             boole-c2       car
array-total-size-limit       boole-clr      case
arrayp                       boole-eqv      catch
ash                          boole-ior      ccase
asin                         boole-nand     cdaaar
asinh                        boole-nor      cdaadr
assert                       boole-orc1     cdaar
assoc                        boole-orc2     cdadar
assoc-if                     boole-set      cdaddr
assoc-if-not                 boole-xor      cdadr
atan                         boolean        cdar
atanh                        both-case-p    cddaar

Figure 1.5: Symbols in the COMMON-LISP package (part two of twelve).

cddadr              clear-input                   copy-tree
cddar               clear-output                  cos
cdddar              close                         cosh
cddddr              clrhash                       count
cdddr               code-char                     count-if
cddr                coerce                        count-if-not
cdr                 compilation-speed             ctypecase
ceiling             compile                       debug
cell-error          compile-file                  decf
cell-error-name     compile-file-pathname         declaim
cerror              compiled-function             declaration
change-class        compiled-function-p           declare
char                compiler-macro                decode-float
char-code           compiler-macro-function       decode-universal-time
char-code-limit     complement                    defclass
char-downcase       complex                       defconstant
char-equal          complexp                      defgeneric
char-greaterp       compute-applicable-methods    define-compiler-macro
char-int            compute-restarts              define-condition
char-lessp          concatenate                   define-method-combination
char-name           concatenated-stream           define-modify-macro
char-not-equal      concatenated-stream-streams   define-setf-expander
char-not-greaterp   cond                          define-symbol-macro
char-not-lessp      condition                     defmacro
char-upcase         conjugate                     defmethod
char/=              cons                          defpackage
char<               consp                         defparameter
char<=              constantly                    defsetf
char=               constantp                     defstruct
char>               continue                      deftype
char>=              control-error                 defun
character           copy-alist                    defvar
characterp          copy-list                     delete
check-type          copy-pprint-dispatch          delete-duplicates
cis                 copy-readtable                delete-file
class               copy-seq                      delete-if
class-name          copy-structure                delete-if-not
class-of            copy-symbol                   delete-package

Figure 1.6: Symbols in the COMMON-LISP package (part three of twelve).

denominator                     eq
deposit-field                   eql
describe                        equal
describe-object                 equalp
destructuring-bind              error
digit-char                      etypecase
digit-char-p                    eval
directory                       eval-when
directory-namestring            evenp
disassemble                     every
division-by-zero                exp
do                              export
do*                             expt
do-all-symbols                  extended-char
do-external-symbols             fboundp
do-symbols                      fceiling
documentation                   fdefinition
dolist                          ffloor
dotimes                         fifth
double-float                    file-author
double-float-epsilon            file-error
double-float-negative-epsilon   file-error-pathname
dpb                             file-length
dribble                         file-namestring
dynamic-extent                  file-position
ecase                           file-stream
echo-stream                     file-string-length
echo-stream-input-stream        file-write-date
echo-stream-output-stream       fill
ed                              fill-pointer
eighth                          find
elt                             find-all-symbols
encode-universal-time           find-class
end-of-file                     find-if
endp                            find-if-not
enough-namestring               find-method
ensure-directories-exist        find-package
ensure-generic-function         find-restart

Figure 1.7: Symbols in the COMMON-LISP package (part four of twelve).

find-symbol                        get-internal-run-time
finish-output                      get-macro-character
first                              get-output-stream-string
fixnum                             get-properties
flet                               get-setf-expansion
float                              get-universal-time
float-digits                       getf
float-precision                    gethash
float-radix                        go
float-sign                         graphic-char-p
floating-point-inexact             handler-bind
floating-point-invalid-operation   handler-case
floating-point-overflow            hash-table
floating-point-underflow           hash-table-count
floatp                             hash-table-p
floor                              hash-table-rehash-size
fmakunbound                        hash-table-rehash-threshold
force-output                       hash-table-size
format                             hash-table-test
formatter                          host-namestring
fourth                             identity
fresh-line                         if
fround                             ignorable
ftruncate                          ignore
ftype                              ignore-errors
funcall                            imagpart
function                           import
function-keywords                  in-package
function-lambda-expression         incf
functionp                          initialize-instance
gcd                                inline
generic-function                   input-stream-p
gensym                             inspect
gentemp                            integer
get                                integer-decode-float
get-decoded-time                   integer-length
get-dispatch-macro-character       integerp
get-internal-real-time             interactive-stream-p

Figure 1.8: Symbols in the COMMON-LISP package (part five of twelve).

intern                                   lisp-implementation-type
internal-time-units-per-second           lisp-implementation-version
intersection                             list
invalid-method-error                     list*
invoke-debugger                          list-all-packages
invoke-restart                           list-length
invoke-restart-interactively             listen
isqrt                                    listp
keyword                                  load
keywordp                                 load-logical-pathname-translations
labels                                   load-time-value
lambda                                   locally
lambda-list-keywords                     log
lambda-parameters-limit                  logand
last                                     logandc1
lcm                                      logandc2
ldb                                      logbitp
ldb-test                                 logcount
ldiff                                    logeqv
least-negative-double-float              logical-pathname
least-negative-long-float                logical-pathname-translations
least-negative-normalized-double-float   logior
least-negative-normalized-long-float     lognand
least-negative-normalized-short-float    lognor
least-negative-normalized-single-float   lognot
least-negative-short-float               logorc1
least-negative-single-float              logorc2
least-positive-double-float              logtest
least-positive-long-float                logxor
least-positive-normalized-double-float   long-float
least-positive-normalized-long-float     long-float-epsilon
least-positive-normalized-short-float    long-float-negative-epsilon
least-positive-normalized-single-float   long-site-name
least-positive-short-float               loop
least-positive-single-float              loop-finish
length                                   lower-case-p
let                                      machine-instance
let*                                     machine-type

Figure 1.9: Symbols in the COMMON-LISP package (part six of twelve).

machine-version                 mask-field
macro-function                  max
macroexpand                     member
macroexpand-1                   member-if
macrolet                        member-if-not
make-array                      merge
make-broadcast-stream           merge-pathnames
make-concatenated-stream        method
make-condition                  method-combination
make-dispatch-macro-character   method-combination-error
make-echo-stream                method-qualifiers
make-hash-table                 min
make-instance                   minusp
make-instances-obsolete         mismatch
make-list                       mod
make-load-form                  most-negative-double-float
make-load-form-saving-slots     most-negative-fixnum
make-method                     most-negative-long-float
make-package                    most-negative-short-float
make-pathname                   most-negative-single-float
make-random-state               most-positive-double-float
make-sequence                   most-positive-fixnum
make-string                     most-positive-long-float
make-string-input-stream        most-positive-short-float
make-string-output-stream       most-positive-single-float
make-symbol                     muffle-warning
make-synonym-stream             multiple-value-bind
make-two-way-stream             multiple-value-call
makunbound                      multiple-value-list
map                             multiple-value-prog1
map-into                        multiple-value-setq
mapc                            multiple-values-limit
mapcan                          name-char
mapcar                          namestring
mapcon                          nbutlast
maphash                         nconc
mapl                            next-method-p
maplist                         nil

Figure 1.10: Symbols in the COMMON-LISP package (part seven of twelve).

nintersection          package-error
ninth                  package-error-package
no-applicable-method   package-name
no-next-method         package-nicknames
not                    package-shadowing-symbols
notany                 package-use-list
notevery               package-used-by-list
notinline              packagep
nreconc                pairlis
nreverse               parse-error
nset-difference        parse-integer
nset-exclusive-or      parse-namestring
nstring-capitalize     pathname
nstring-downcase       pathname-device
nstring-upcase         pathname-directory
nsublis                pathname-host
nsubst                 pathname-match-p
nsubst-if              pathname-name
nsubst-if-not          pathname-type
nsubstitute            pathname-version
nsubstitute-if         pathnamep
nsubstitute-if-not     peek-char
nth                    phase
nth-value              pi
nthcdr                 plusp
null                   pop
number                 position
numberp                position-if
numerator              position-if-not
nunion                 pprint
oddp                   pprint-dispatch
open                   pprint-exit-if-list-exhausted
open-stream-p          pprint-fill
optimize               pprint-indent
or                     pprint-linear
otherwise              pprint-logical-block
output-stream-p        pprint-newline
package                pprint-pop

Figure 1.11: Symbols in the COMMON-LISP package (part eight of twelve).

pprint-tab                  read-char
pprint-tabular              read-char-no-hang
prin1                       read-delimited-list
prin1-to-string             read-from-string
princ                       read-line
princ-to-string             read-preserving-whitespace
print                       read-sequence
print-not-readable          reader-error
print-not-readable-object   readtable
print-object                readtable-case
print-unreadable-object     readtablep
probe-file                  real
proclaim                    realp
prog                        realpart
prog*                       reduce
prog1                       reinitialize-instance
prog2                       rem
progn                       remf
program-error               remhash
progv                       remove
provide                     remove-duplicates
psetf                       remove-if
psetq                       remove-if-not
push                        remove-method
pushnew                     remprop
quote                       rename-file
random                      rename-package
random-state                replace
random-state-p              require
rassoc                      rest
rassoc-if                   restart
rassoc-if-not               restart-bind
ratio                       restart-case
rational                    restart-name
rationalize                 return
rationalp                   return-from
read                        revappend
read-byte                   reverse

Figure 1.12: Symbols in the COMMON-LISP package (part nine of twelve).

room                           simple-bit-vector
rotatef                        simple-bit-vector-p
round                          simple-condition
row-major-aref                 simple-condition-format-arguments
rplaca                         simple-condition-format-control
rplacd                         simple-error
safety                         simple-string
satisfies                      simple-string-p
sbit                           simple-type-error
scale-float                    simple-vector
schar                          simple-vector-p
search                         simple-warning
second                         sin
sequence                       single-float
serious-condition              single-float-epsilon
set                            single-float-negative-epsilon
set-difference                 sinh
set-dispatch-macro-character   sixth
set-exclusive-or               sleep
set-macro-character            slot-boundp
set-pprint-dispatch            slot-exists-p
set-syntax-from-char           slot-makunbound
setf                           slot-missing
setq                           slot-unbound
seventh                        slot-value
shadow                         software-type
shadowing-import               software-version
shared-initialize              some
shiftf                         sort
short-float                    space
short-float-epsilon            special
short-float-negative-epsilon   special-operator-p
short-site-name                speed
signal                         sqrt
signed-byte                    stable-sort
signum                         standard
simple-array                   standard-char
simple-base-string             standard-char-p

Figure 1.13: Symbols in the COMMON-LISP package (part ten of twelve).

standard-class              sublis
standard-generic-function   subseq
standard-method             subsetp
standard-object             subst
step                        subst-if
storage-condition           subst-if-not
store-value                 substitute
stream                      substitute-if
stream-element-type         substitute-if-not
stream-error                subtypep
stream-error-stream         svref
stream-external-format      sxhash
streamp                     symbol
string                      symbol-function
string-capitalize           symbol-macrolet
string-downcase             symbol-name
string-equal                symbol-package
string-greaterp             symbol-plist
string-left-trim            symbol-value
string-lessp                symbolp
string-not-equal            synonym-stream
string-not-greaterp         synonym-stream-symbol
string-not-lessp            t
string-right-trim           tagbody
string-stream               tailp
string-trim                 tan
string-upcase               tanh
string/=                    tenth
string<                     terpri
string<=                    the
string=                     third
string>                     throw
string>=                    time
stringp                     trace
structure                   translate-logical-pathname
structure-class             translate-pathname
structure-object            tree-equal
style-warning               truename

Figure 1.14: Symbols in the COMMON-LISP package (part eleven of twelve).

truncate                              values-list
two-way-stream                        variable
two-way-stream-input-stream           vector
two-way-stream-output-stream          vector-pop
type                                  vector-push
type-error                            vector-push-extend
type-error-datum                      vectorp
type-error-expected-type              warn
type-of                               warning
typecase                              when
typep                                 wild-pathname-p
unbound-slot                          with-accessors
unbound-slot-instance                 with-compilation-unit
unbound-variable                      with-condition-restarts
undefined-function                    with-hash-table-iterator
unexport                              with-input-from-string
unintern                              with-open-file
union                                 with-open-stream
unless                                with-output-to-string
unread-char                           with-package-iterator
unsigned-byte                         with-simple-restart
untrace                               with-slots
unuse-package                         with-standard-io-syntax
unwind-protect                        write
update-instance-for-different-class   write-byte
update-instance-for-redefined-class   write-char
upgraded-array-element-type           write-line
upgraded-complex-part-type            write-sequence
upper-case-p                          write-string
use-package                           write-to-string
use-value                             y-or-n-p
user-homedir-pathname                 yes-or-no-p
values                                zerop

Figure 1.15: Symbols in the COMMON-LISP package (part twelve of twelve).


File: chris-ansicl.info,  Node: Syntax,  Next: Evaluation and Compilation,  Prev: Introduction,  Up: Top

2 Syntax
********

* Menu:

* Character Syntax::
* Reader Algorithm::
* Interpretation of Tokens::
* Standard Macro Characters::


File: chris-ansicl.info,  Node: Character Syntax,  Next: Reader Algorithm,  Up: Syntax

2.1 Character Syntax
====================

The Lisp reader takes characters from a stream, interprets them as a
printed representation of an object, constructs that object, and
returns it.

The syntax described by this chapter is called the "standard syntax".
Operations are provided by Common Lisp so that various aspects of the
syntax information represented by a readtable can be modified under
program control; see *Note Chapter 23 (Reader): Reader.  Except as
explicitly stated otherwise, the syntax used throughout this document
is standard syntax.

* Menu:

* Readtables::
* Variables that affect the Lisp Reader::
* Standard Characters::
* Character Syntax Types::


File: chris-ansicl.info,  Node: Readtables,  Next: Variables that affect the Lisp Reader,  Up: Character Syntax

2.1.1 Readtables
----------------

Syntax information for use by the Lisp reader is embodied in an object
called a "readtable".  Among other things, the readtable contains the
association between characters and syntax types.

The next figure lists some defined names that are applicable to
readtables.

*readtable*                     readtable-case                 
copy-readtable                  readtablep                     
get-dispatch-macro-character    set-dispatch-macro-character   
get-macro-character             set-macro-character            
make-dispatch-macro-character   set-syntax-from-char           

Figure 2.1: Readtable defined names

2.1.1.1 The Current Readtable
.............................

Several readtables describing different syntaxes can exist, but at any
given time only one, called the "current readtable", affects the way in
which expressionsà are parsed into objects by the Lisp reader.  The
current readtable in a given dynamic environment is the value of
ÿ*readtable*þ in that environment.  To make a different readtable
become the current readtable, ÿ*readtable*þ can be assigned or bound.

2.1.1.2 The Standard Readtable
..............................

The "standard readtable" conforms to standard syntax.  The consequences
are undefined if an attempt is made to modify the standard readtable.
To achieve the effect of altering or extending standard syntax, a copy
of the standard readtable can be created; see the function *Note
copy-readtable::.

The readtable case of the standard readtable is :upcase.

2.1.1.3 The Initial Readtable
.............................

The "initial readtable" is the readtable that is the current readtable
at the time when the Lisp image starts.  At that time, it conforms to
standard syntax.  The initial readtable is distinct from the standard
readtable.  It is permissible for a conforming program to modify the
initial readtable.


File: chris-ansicl.info,  Node: Variables that affect the Lisp Reader,  Next: Standard Characters,  Prev: Readtables,  Up: Character Syntax

2.1.2 Variables that affect the Lisp Reader
-------------------------------------------

The Lisp reader is influenced not only by the current readtable, but
also by various dynamic variables.  The next figure lists the variables
that influence the behavior of the Lisp reader.

*package*     *read-default-float-format*   *readtable*
*read-base*   *read-suppress*               

Figure 2.2: Variables that influence the Lisp reader.


File: chris-ansicl.info,  Node: Standard Characters,  Next: Character Syntax Types,  Prev: Variables that affect the Lisp Reader,  Up: Character Syntax

2.1.3 Standard Characters
-------------------------

All implementations must support a character repertoire called
ÿstandard-charþ; characters that are members of that repertoire are
called "standard characters".

The ÿstandard-charþ repertoire consists of the non-graphic character
newline, the graphic character space, and the following additional
ninety-four graphic characters or their equivalents:

Graphic ID   Glyph   Description   Graphic ID   Glyph   Description
---------------------------------------------------------------------- 
LA01         ÿaþ     small a       LN01         ÿnþ     small n
LA02         ÿAþ     capital A     LN02         ÿNþ     capital N
LB01         ÿbþ     small b       LO01         ÿoþ     small o
LB02         ÿBþ     capital B     LO02         ÿOþ     capital O
LC01         ÿcþ     small c       LP01         ÿpþ     small p
LC02         ÿCþ     capital C     LP02         ÿPþ     capital P
LD01         ÿdþ     small d       LQ01         ÿqþ     small q
LD02         ÿDþ     capital D     LQ02         ÿQþ     capital Q
LE01         ÿeþ     small e       LR01         ÿrþ     small r
LE02         ÿEþ     capital E     LR02         ÿRþ     capital R
LF01         ÿfþ     small f       LS01         ÿsþ     small s
LF02         ÿFþ     capital F     LS02         ÿSþ     capital S
LG01         ÿgþ     small g       LT01         ÿtþ     small t
LG02         ÿGþ     capital G     LT02         ÿTþ     capital T
LH01         ÿhþ     small h       LU01         ÿuþ     small u
LH02         ÿHþ     capital H     LU02         ÿUþ     capital U
LI01         ÿiþ     small i       LV01         ÿvþ     small v
LI02         ÿIþ     capital I     LV02         ÿVþ     capital V
LJ01         ÿjþ     small j       LW01         ÿwþ     small w
LJ02         ÿJþ     capital J     LW02         ÿWþ     capital W
LK01         ÿkþ     small k       LX01         ÿxþ     small x
LK02         ÿKþ     capital K     LX02         ÿXþ     capital X
LL01         ÿlþ     small l       LY01         ÿyþ     small y
LL02         ÿLþ     capital L     LY02         ÿYþ     capital Y
LM01         ÿmþ     small m       LZ01         ÿzþ     small z
LM02         ÿMþ     capital M     LZ02         ÿZþ     capital Z

Figure 2.3: Standard Character Subrepertoire (Part 1 of 3: Latin
Characters)

Graphic ID   Glyph   Description   Graphic ID   Glyph   Description
---------------------------------------------------------------------- 
ND01         ÿ1þ     digit 1       ND06         ÿ6þ     digit 6
ND02         ÿ2þ     digit 2       ND07         ÿ7þ     digit 7
ND03         ÿ3þ     digit 3       ND08         ÿ8þ     digit 8
ND04         ÿ4þ     digit 4       ND09         ÿ9þ     digit 9
ND05         ÿ5þ     digit 5       ND10         ÿ0þ     digit 0

Figure 2.4: Standard Character Subrepertoire (Part 2 of 3: Numeric
Characters)

Graphic ID   Glyph Description
------------------------------------------------------------- 
SP02         ÿ!þ   exclamation mark
SC03         ÿ$þ   dollar sign
SP04         ÿ"þ   quotation mark, or double quote
SP05         ÿ'þ   apostrophe, or [single] quote
SP06         ÿ(þ   left parenthesis, or open parenthesis
SP07         ÿ)þ   right parenthesis, or close parenthesis
SP08         ÿ,þ   comma
SP09         ÿ_þ   low line, or underscore
SP10         ÿ-þ   hyphen, or minus [sign]
SP11         ÿ.þ   full stop, period, or dot
SP12         ÿ/þ   solidus, or slash
SP13         ÿ:þ   colon
SP14         ÿ;þ   semicolon
SP15         ÿ?þ   question mark
SA01         ÿ+þ   plus [sign]
SA03         ÿ<þ   less-than [sign]
SA04         ÿ=þ   equals [sign]
SA05         ÿ>þ   greater-than [sign]
SM01         ÿ#þ   number sign, or sharp[sign]
SM02         ÿ%þ   percent [sign]
SM03         ÿ&þ   ampersand
SM04         ÿ*þ   asterisk, or star
SM05         ÿ@þ   commercial at, or at-sign
SM06         ÿ[þ   left [square] bracket
SM07         ÿ\þ   reverse solidus, or backslash
SM08         ÿ]þ   right [square] bracket
SM11         ÿ{þ   left curly bracket, or left brace
SM13         ÿ|þ   vertical bar
SM14         ÿ}þ   right curly bracket, or right brace
SD13         ÿ`þ   grave accent, or backquote
SD15         ÿ^þ   circumflex accent
SD19         ÿ~þ   tilde

Figure 2.5: Standard Character Subrepertoire (Part 3 of 3: Special
Characters)

The graphic IDs are not used within Common Lisp, but are provided for
cross reference purposes with `ISO 6937/2'.  Note that the first letter
of the graphic ID categorizes the character as follows: L--Latin,
N--Numeric, S--Special.


File: chris-ansicl.info,  Node: Character Syntax Types,  Prev: Standard Characters,  Up: Character Syntax

2.1.4 Character Syntax Types
----------------------------

The Lisp reader constructs an object from the input text by
interpreting each character according to its syntax type.  The Lisp
reader cannot accept as input everything that the Lisp printer produces,
and the Lisp reader has features that are not used by the Lisp printer.
The Lisp reader can be used as a lexical analyzer for a more general
user-written parser.

When the Lisp reader is invoked, it reads a single character from the
input stream and dispatches according to the "syntax type" of that
character.  Every character that can appear in the input stream is of
one of the syntax types shown in *Note Figure 2.6: PossibleSyntaxTypes.

constituent   macro character   single escape
invalid       multiple escape   whitespaceà

Figure 2.6: Possible Character Syntax Types

The syntax type of a character in a readtable determines how that
character is interpreted by the Lisp reader while that readtable is the
current readtable.  At any given time, every character has exactly one
syntax type.

*Note Figure 2.7: CharSyntaxTypesInStdSyntax.  lists the syntax type of
each character in standard syntax.

character   syntax type                  charactersyntax type
--------------------------------------------------------------------------- 
Backspace   constituent                  0-9      constituent
Tab         whitespaceà                  :        constituent
Newline     whitespaceà                  ;        terminating macro char
Linefeed    whitespaceà                  ÿ<þ      constituent
Page        whitespaceà                  =        constituent
Return      whitespaceà                  ÿ>þ      constituent
Space       whitespaceà                  ?        constituent
!           constituent                  ÿ@þ      constituent
ÿ"þ         terminating macro char       A-Z      constituent
#           non-terminating macro char   ÿ[þ      constituent
$           constituent                  ÿ\þ      single escape
%           constituent                  ÿ]þ      constituent
&           constituent                  ^        constituent
'           terminating macro char       ÿ_þ      constituent
(           terminating macro char       `        terminating macro char
)           terminating macro char       a-z      constituent
ÿ*þ         constituent                  ÿ{þ      constituent
+           constituent                  ÿ|þ      multiple escape
,           terminating macro char       ÿ}þ      constituent
-           constituent                  ÿ~þ      constituent
.           constituent                  Rubout   constituent
/           constituent                           

Figure 2.7: Character Syntax Types in Standard Syntax

The characters marked with an asterisk (*) are initially constituents,
but they are not used in any standard Common Lisp notations.  These
characters are explicitly reserved to the programmer.  ÿ~þ is not used
in Common Lisp, and reserved to implementors.  ÿ$þ and ÿ%þ are
alphabeticà characters, but are not used in the names of any standard
Common Lisp defined names.

Whitespaceà characters serve as separators but are otherwise ignored.
Constituent and escape characters are accumulated to make a token,
which is then interpreted as a number or symbol.  Macro characters
trigger the invocation of functions (possibly user-supplied) that can
perform arbitrary parsing actions.  Macro characters are divided into
two kinds, terminating and non-terminating, depending on whether or not
they terminate a token.  The following are descriptions of each kind of
syntax type.

2.1.4.1 Constituent Characters
..............................

Constituent characters are used in tokens.  A "token" is a
representation of a number or a symbol.  Examples of constituent
characters are letters and digits.

Letters in symbol names are sometimes converted to letters in the
opposite case when the name is read; see *Note Section 23.1.2 (Effect
of Readtable Case on the Lisp Reader): Effect of Readtable Case on the
Lisp Reader.  Case conversion can be suppressed by the use of single
escape or multiple escape characters.

2.1.4.2 Constituent Traits
..........................

Every character has one or more constituent traits that define how the
character is to be interpreted by the Lisp reader when the character is
a constituent character.  These constituent traits are alphabeticà,
digit, package marker, plus sign, minus sign, dot, decimal point, ratio
marker, exponent marker, and invalid.  *Note Figure 2.8:
ConstituentTraitsOfStdChars. shows the constituent traits of the
standard characters and of certain semi-standard characters; no
mechanism is provided for changing the constituent trait of a character.
Any character with the alphadigit constituent trait in that figure is a
digit if the current input base is greater than that character's digit
value, otherwise the character is alphabeticà.  Any character quoted by
a single escape is treated as an alphabeticà constituent, regardless of
its normal syntax.

constituent   traits         constituent   traits
characters                   characters    
Backspace     invalid        ÿ{þ           alphabeticà
Tab           invalid*       ÿ}þ           alphabeticà
Newline       invalid*       +             alphabeticà, plus sign
Linefeed      invalid*       -             alphabeticà, minus sign
Page          invalid*       .             alphabeticà, dot, decimal point
Return        invalid*       /             alphabeticà, ratio marker
Space         invalid*       A, a          alphadigit
!             alphabeticà    B, b          alphadigit
ÿ"þ           alphabeticà*   C, c          alphadigit
#             alphabeticà*   D, d          alphadigit, double-float exponent marker
$             alphabeticà    E, e          alphadigit, float exponent marker
%             alphabeticà    F, f          alphadigit, single-float exponent marker
&             alphabeticà    G, g          alphadigit
'             alphabeticà*   H, h          alphadigit
(             alphabeticà*   I, i          alphadigit
)             alphabeticà*   J, j          alphadigit
ÿ*þ           alphabeticà    K, k          alphadigit
,             alphabeticà*   L, l          alphadigit, long-float exponent marker
0-9           alphadigit     M, m          alphadigit
:             package        N, n          alphadigit
              marker                       
;             alphabeticà*   O, o          alphadigit
ÿ<þ           alphabeticà    P, p          alphadigit
=             alphabeticà    Q, q          alphadigit
ÿ>þ           alphabeticà    R, r          alphadigit
?             alphabeticà    S, s          alphadigit, short-float exponent marker
ÿ@þ           alphabeticà    T, t          alphadigit
ÿ[þ           alphabeticà    U, u          alphadigit
ÿ\þ           alphabeticà*   V, v          alphadigit
ÿ]þ           alphabeticà    W, w          alphadigit
^             alphabeticà    X, x          alphadigit
ÿ_þ           alphabeticà    Y, y          alphadigit
`             alphabeticà*   Z, z          alphadigit
ÿ|þ           alphabeticà*   Rubout        invalid
ÿ~þ           alphabeticà                  

Figure 2.8: Constituent Traits of Standard Characters and Semi-Standard
Characters

The interpretations in this table apply only to characters whose syntax
type is constituent.  Entries marked with an asterisk (*) are normally
shadowedà because the indicated characters are of syntax type
whitespaceà, macro character, single escape, or multiple escape; these
constituent traits apply to them only if their syntax types are changed
to constituent.

2.1.4.3 Invalid Characters
..........................

Characters with the constituent trait invalid cannot ever appear in a
token except under the control of a single escape character.  If an
invalid character is encountered while an object is being read, an
error of type ÿreader-errorþ is signaled.  If an invalid character is
preceded by a single escape character, it is treated as an alphabeticà
constituent instead.

2.1.4.4 Macro Characters
........................

When the Lisp reader encounters a macro character on an input stream,
special parsing of subsequent characters on the input stream is
performed.

A macro character has an associated function called a "reader macro
function" that implements its specialized parsing behavior.  An
association of this kind can be established or modified under control of
a conforming program by using the functions ÿset-macro-characterþ and
ÿset-dispatch-macro-characterþ.

Upon encountering a macro character, the Lisp reader calls its reader
macro function, which parses one specially formatted object from the
input stream.  The function either returns the parsed object, or else
it returns no values to indicate that the characters scanned by the
function are being ignored (e.g., in the case of a comment).  Examples
of macro characters are backquote, single-quote, left-parenthesis, and
right-parenthesis.

A macro character is either terminating or non-terminating.  The
difference between terminating and non-terminating macro characters
lies in what happens when such characters occur in the middle of a
token.  If a "non-terminating" macro character occurs in the middle of
a token, the function associated with the non-terminating macro
character is not called, and the non-terminating macro character does
not terminate the token's name; it becomes part of the name as if the
macro character were really a constituent character.  A "terminating"
macro character terminates any token, and its associated reader macro
function is called no matter where the character appears.  The only
non-terminating macro character in standard syntax is sharpsign.

If a character is a dispatching macro character Cá, its reader macro
function is a function supplied by the implementation.  This function
reads decimal digit characters until a non-digit Cà is read.  If any
digits were read, they are converted into a corresponding integer infix
parameter P; otherwise, the infix parameter P is ÿnilþ.  The
terminating non-digit Cà is a character (sometimes called a
"sub-character" to emphasize its subordinate role in the dispatching)
that is looked up in the dispatch table associated with the dispatching
macro character Cá.  The reader macro function associated with the
sub-character Cà is invoked with three arguments: the stream, the
sub-character Cà, and the infix parameter P.  For more information
about dispatch characters, see the function *Note
set-dispatch-macro-character::.

For information about the macro characters that are available in
standard syntax, see *Note Section 2.4 (Standard Macro Characters):
Standard Macro Characters.

2.1.4.5 Multiple Escape Characters
..................................

A pair of "multiple escape" characters is used to indicate that an
enclosed sequence of characters, including possible macro characters
and whitespaceà characters, are to be treated as alphabeticà characters
with case preserved.  Any single escape and multiple escape characters
that are to appear in the sequence must be preceded by a single escape
character.

Vertical-bar is a multiple escape character in standard syntax.

2.1.4.5.1 Examples of Multiple Escape Characters
................................................

 ;; The following examples assume the readtable case of *readtable*
 ;; and *print-case* are both :upcase.
 (eq 'abc 'ABC) ý true
 (eq 'abc '|ABC|) ý true
 (eq 'abc 'a|B|c) ý true
 (eq 'abc '|abc|) ý false

2.1.4.6 Single Escape Character
...............................

A "single escape" is used to indicate that the next character is to be
treated as an alphabeticà character with its case preserved, no matter
what the character is or which constituent traits it has.

Backslash is a single escape character in standard syntax.

2.1.4.6.1 Examples of Single Escape Characters
..............................................

 ;; The following examples assume the readtable case of *readtable*
 ;; and *print-case* are both :upcase.
 (eq 'abc '\A\B\C) ý true
 (eq 'abc 'a\Bc) ý true
 (eq 'abc '\ABC) ý true
 (eq 'abc '\abc) ý false

2.1.4.7 Whitespace Characters
.............................

Whitespaceà characters are used to separate tokens.

Space and newline are whitespaceà characters in standard syntax.

2.1.4.7.1 Examples of Whitespace Characters
...........................................

 (length '(this-that)) ý 1
 (length '(this - that)) ý 3
 (length '(a
           b)) ý 2
 (+ 34) ý 34
 (+ 3 4) ý 7


File: chris-ansicl.info,  Node: Reader Algorithm,  Next: Interpretation of Tokens,  Prev: Character Syntax,  Up: Syntax

2.2 Reader Algorithm
====================

This section describes the algorithm used by the Lisp reader to parse
objects from an input character stream, including how the Lisp reader
processes macro characters.

When dealing with tokens, the reader's basic function is to distinguish
representations of symbols from those of numbers.  When a token is
accumulated, it is assumed to represent a number if it satisfies the
syntax for numbers listed in *Note Figure 2.9: SyntaxForNumericTokens.
If it does not represent a number, it is then assumed to be a potential
number if it satisfies the rules governing the syntax for a potential
number.  If a valid token is neither a representation of a number nor a
potential number, it represents a symbol.

The algorithm performed by the Lisp reader is as follows:

  1. If at end of file, end-of-file processing is performed as specified
     in ÿreadþ.  Otherwise, one character, X,  is read from the input
     stream, and dispatched according to the syntax type of X to one of
     steps 2 to 7.

  2. If X is an invalid character, an error of type ÿreader-errorþ is
     signaled.

  3. If X is a whitespaceà character, then it is discarded and step 1
     is re-entered.

  4. If X is a terminating or non-terminating macro character then its
     associated reader macro function is called with two arguments, the
     input stream and X.

     The reader macro function may read characters from the input
     stream; if it does, it will see those characters following the
     macro character.  The Lisp reader may be invoked recursively from
     the reader macro function.

     The reader macro function must not have any side effects other
     than on the input stream; because of backtracking and restarting
     of the ÿreadþ operation, front ends to the Lisp reader (e.g.,
     "editors" and "rubout handlers") may cause the reader macro
     function to be called repeatedly during the reading of a single
     expression in which X only appears once.

     The reader macro function may return zero values or one value.  If
     one value is returned, then that value is returned as the result
     of the read operation; the algorithm is done.  If zero values are
     returned, then step 1 is re-entered.

  5. If X is a single escape character then the next character, Y, is
     read, or an error of type ÿend-of-fileþ is signaled if at the end
     of file.  Y is treated as if it is a constituent whose only
     constituent trait is alphabeticà.  Y is used to begin a token, and
     step 8 is entered.

  6. If X is a multiple escape character then a token (initially
     containing no characters) is  begun and step 9 is entered.

  7. If X is a constituent character, then it begins a token.  After
     the token is read in, it will be interpreted either as a
     Lisp object or as being of invalid syntax.  If the token
     represents an object, that object is returned as the result of the
     read operation.  If the token is of invalid syntax, an error is
     signaled.  If X is a character with case, it might be replaced
     with the corresponding character of the opposite case, depending
     on the readtable case of the current readtable, as outlined in
     *Note Section 23.1.2 (Effect of Readtable Case on the Lisp
     Reader): Effect of Readtable Case on the Lisp Reader.  X is used
     to begin a token, and step 8 is entered.

  8. At this point a token is being accumulated, and an even number of
     multiple escape characters have been encountered.  If at end of
     file, step 10 is entered.  Otherwise, a character, Y, is read, and
     one of the following actions is performed according to its syntax
     type:

        * If Y is a constituent or non-terminating macro character:

             - If Y is a character with case, it might be replaced with
               the corresponding character of the opposite case,
               depending on the readtable case of the current readtable,
               as outlined in *Note Section 23.1.2 (Effect of Readtable
               Case on the Lisp Reader): Effect of Readtable Case on
               the Lisp Reader.

             - Y is appended to the token being built.

             - Step 8 is repeated.

        * If Y is a single escape character, then the next character,
          Z, is read, or an error of type ÿend-of-fileþ is signaled if
          at end of file.  Z is treated as if it is a constituent whose
          only constituent trait is alphabeticà.  Z is appended to the
          token being built, and step 8 is repeated.

        * If Y is a multiple escape character, then step 9 is entered.

        * If Y is an invalid character, an error of type ÿreader-errorþ
          is signaled.

        * If Y is a terminating macro character, then it terminates the
          token.  First the character Y is unread (see ÿunread-charþ),
          and then step 10 is entered.

        * If Y is a whitespaceà character, then it terminates the
          token.  First the character Y is unread if appropriate (see
          ÿread-preserving-whitespaceþ), and then step 10 is entered.

  9. At this point a token is being accumulated, and an odd number of
     multiple escape characters have been encountered.  If at end of
     file, an error of type ÿend-of-fileþ is signaled.  Otherwise, a
     character, Y, is read, and one of the following actions is
     performed according to its syntax type:

        * If Y is a constituent, macro, or whitespaceà character, Y is
          treated as a constituent whose only constituent trait is
          alphabeticà.  Y is appended to the token being built, and
          step 9 is repeated.

        * If Y is a single escape character, then the next character,
          Z, is read, or an error of type ÿend-of-fileþ is signaled if
          at end of file.  Z is treated as a constituent whose only
          constituent trait is alphabeticà.  Z is appended to the token
          being built, and step 9 is repeated.

        * If Y is a multiple escape character, then step 8 is entered.

        * If Y is an invalid character, an error of type ÿreader-errorþ
          is signaled.

 10. An entire token has been accumulated.  The object represented by
     the token is returned as the result of the read operation, or an
     error of type ÿreader-errorþ is signaled if the token is not of
     valid syntax.


File: chris-ansicl.info,  Node: Interpretation of Tokens,  Next: Standard Macro Characters,  Prev: Reader Algorithm,  Up: Syntax

2.3 Interpretation of Tokens
============================

* Menu:

* Numbers as Tokens::
* Constructing Numbers from Tokens::
* The Consing Dot::
* Symbols as Tokens::
* Valid Patterns for Tokens::
* Package System Consistency Rules::


File: chris-ansicl.info,  Node: Numbers as Tokens,  Next: Constructing Numbers from Tokens,  Up: Interpretation of Tokens

2.3.1 Numbers as Tokens
-----------------------

When a token is read, it is interpreted as a number or symbol.  The
token is interpreted as a number if it satisfies the syntax for numbers
specified in the next figure.

NUMERIC-TOKEN   ::=   ûinteger | ûratio   | ûfloat
INTEGER         ::=   [SIGN] {DECIMAL-DIGIT}+ DECIMAL-POINT | [SIGN] {DIGIT}+
RATIO           ::=   [SIGN] {DIGIT}+ SLASH {DIGIT}+
FLOAT           ::=   [SIGN] {DECIMAL-DIGIT}* DECIMAL-POINT {DECIMAL-DIGIT}+ [ûexponent]
                      | [SIGN] {DECIMAL-DIGIT}+  [DECIMAL-POINT  {DECIMAL-DIGIT}*] ûexponent
EXPONENT        ::=   EXPONENT-MARKER [SIGN] {DIGIT}+

Figure 2.9: Syntax for Numeric Tokens

SIGN--a sign.
SLASH--a slash
DECIMAL-POINT--a dot.
EXPONENT-MARKER--an exponent marker.
DECIMAL-DIGIT--a digit in radix ÿ10þ.
DIGIT--a digit in the current input radix.
2.3.1.1 Potential Numbers as Tokens
...................................

To allow implementors and future Common Lisp standards to extend the
syntax of numbers, a syntax for potential numbers is defined that is
more general than the syntax for numbers.  A token is a potential
number if it satisfies all of the following requirements:

  1. The token consists entirely of digits, signs, ratio markers,
     decimal points (ÿ.þ), extension characters (^ or ÿ_þ), and number
     markers.  A number marker is a letter.  Whether a letter may be
     treated as a number marker depends on context, but no letter that
     is adjacent to another letter may ever be treated as a number
     marker.  Exponent markers are number markers.

  2. The token contains at least one digit.  Letters may be considered
     to be digits, depending on the current input base, but only in
     tokens containing no decimal points.

  3. The token begins with a digit, sign, decimal point, or extension
     character,

     but not a package marker.  The syntax involving a leading package
     marker followed by a potential number is not well-defined. The
     consequences of the use of notation such as ÿ:1þ, ÿ:1/2þ, and
     ÿ:2^3þ in a position where an expression appropriate for ÿreadþ is
     expected are unspecified.

  4. The token does not end with a sign.

If a potential number has number syntax, a number of the appropriate
type is constructed and returned, if the number is representable in an
implementation.  A number will not be representable in an implementation
if it is outside the boundaries set by the implementation-dependent
constants for numbers.  For example, specifying too large or too small
an exponent for a float may make the number impossible to represent in
the implementation.  A ratio with denominator zero (such as ÿ-35/000þ)
is not represented in any implementation.  When a token with the syntax
of a number cannot be converted to an internal number, an error of type
ÿreader-errorþ is signaled.  An error must not be signaled for
specifying too many significant digits for a float; a truncated or
rounded value should be produced.

If there is an ambiguity as to whether a letter should be treated as a
digit or as a number marker, the letter is treated as a digit.

2.3.1.1.1 Escape Characters and Potential Numbers
.................................................

A potential number cannot contain any escape characters.  An escape
character robs the following character of all syntactic qualities,
forcing it to be strictly alphabeticà and therefore unsuitable for use
in a potential number.  For example, all of the following
representations are interpreted as symbols, not numbers:

 \256   25\64   1.0\E6   |100|   3\.14159   |3/4|   3\/4   5||

In each case, removing the escape character (or characters) would cause
the token to be a potential number.

2.3.1.1.2 Examples of Potential Numbers
.......................................

As examples, the tokens in the next figure are potential numbers, but
they are not actually numbers, and so are reserved tokens; a conforming
implementation is permitted, but not required, to define their meaning.

ÿ1b5000þ                        ÿ777777qþ   ÿ1.7Jþ   ÿ-3/4+6.7Jþ   ÿ12/25/83þ
ÿ27^19þ                         ÿ3^4/5þ     ÿ6//7þ   ÿ3.1.2.6þ     ÿ^-43^þ
ÿ3.141_592_653_589_793_238_4þ   ÿ-3.7+2.6i-6.17j+19.6kþ                       

Figure 2.10: Examples of reserved tokens

The tokens in the next figure are not potential numbers; they are
always treated as symbols:

ÿ/þ      ÿ/5þ      ÿ+þ   ÿ1+þ  ÿ1-þ
ÿfoo+þ   ÿab.cdþ   ÿ_þ   ÿ^þ   ÿ^/-þ

Figure 2.11: Examples of symbols

The tokens in the next figure are potential numbers if the current
input base is ÿ16þ, but they are always treated as symbols if the
current input base is ÿ10þ.

ÿbad-faceþ   ÿ25-dec-83þ   ÿa/bþ   ÿfad_cafeþ   ÿf^þ

Figure 2.12: Examples of symbols or potential numbers


File: chris-ansicl.info,  Node: Constructing Numbers from Tokens,  Next: The Consing Dot,  Prev: Numbers as Tokens,  Up: Interpretation of Tokens

2.3.2 Constructing Numbers from Tokens
--------------------------------------

A real is constructed directly from a corresponding numeric token; see
*Note Figure 2.9: SyntaxForNumericTokens.

A complex is notated as a ÿ#Cþ (or ÿ#cþ) followed by a list of two
reals; see *Note Section 2.4.8.11 (Sharpsign C): SharpsignC.

The reader macros ÿ#Bþ, ÿ#Oþ, ÿ#Xþ, and ÿ#Rþ may also be useful in
controlling the input radix in which rationals are parsed; see *Note
Section 2.4.8.7 (Sharpsign B): SharpsignB, *Note Section 2.4.8.8
(Sharpsign O): SharpsignO, *Note Section 2.4.8.9 (Sharpsign X):
SharpsignX, and *Note Section 2.4.8.10 (Sharpsign R): SharpsignR.

This section summarizes the full syntax for numbers.

2.3.2.1 Syntax of a Rational
............................

2.3.2.1.1 Syntax of an Integer
..............................

Integers can be written as a sequence of digits, optionally preceded by
a sign and optionally followed by a decimal point; see *Note Figure
2.9: SyntaxForNumericTokens.  When a decimal point is used, the digits
are taken to be in radix ÿ10þ; when no decimal point is used, the
digits are taken to be in radix given by the current input base.

For information on how integers are printed, see *Note Section
22.1.3.1.1 (Printing Integers): PrintingIntegers.

2.3.2.1.2 Syntax of a Ratio
...........................

Ratios can be written as an optional sign followed by two non-empty
sequences of digits separated by a slash; see *Note Figure 2.9:
SyntaxForNumericTokens.  The second sequence may not consist entirely
of zeros.  Examples of ratios are in the next figure.

ÿ2/3þ                  ;This is in canonical form
ÿ4/6þ                  ;A non-canonical form for 2/3
ÿ-17/23þ               ;A ratio preceded by a sign
ÿ-30517578125/32768þ   ;This is (-5/2)^15
ÿ10/5þ                 ;The canonical form for this is ÿ2þ
ÿ#o-101/75þ            ;Octal notation for -65/61
ÿ#3r120/21þ            ;Ternary notation for 15/7
ÿ#Xbc/adþ              ;Hexadecimal notation for 188/173
ÿ#xFADED/FACADEþ       ;Hexadecimal notation for 1027565/16435934

Figure 2.13: Examples of Ratios

For information on how ratios are printed, see *Note Section 22.1.3.1.2
(Printing Ratios): PrintingRatios.

2.3.2.2 Syntax of a Float
.........................

Floats can be written in either decimal fraction or computerized
scientific notation: an optional sign, then a non-empty sequence of
digits with an embedded decimal point, then an optional decimal
exponent specification.  If there is no exponent specifier, then the
decimal point is required, and there must be digits after it.  The
exponent specifier consists of an exponent marker, an optional sign,
and a non-empty sequence of digits.  If no exponent specifier is
present, or if the exponent marker ÿeþ (or ÿEþ) is used, then the
format specified by ÿ*read-default-float-format*þ is used.  See *Note
Figure 2.9: SyntaxForNumericTokens.

An implementation may provide one or more kinds of float that
collectively make up the type ÿfloatþ.  The letters ÿsþ, ÿfþ, ÿdþ, and
ÿlþ (or their respective uppercase equivalents) explicitly specify the
use of the types ÿshort-floatþ, ÿsingle-floatþ, ÿdouble-floatþ, and
ÿlong-floatþ, respectively.

The internal format used for an external representation depends only on
the exponent marker, and not on the number of decimal digits in the
external representation.

The next figure contains examples of notations for floats:

ÿ0.0þ        ;Floating-point zero in default format
ÿ0E0þ        ;As input, this is also floating-point zero in default
             format.
             ;As output, this would appear as ÿ0.0þ.
ÿ0e0þ        ;As input, this is also floating-point zero in default
             format.
             ;As output, this would appear as ÿ0.0þ.
ÿ-.0þ        ;As input, this might be a zero or a minus zero,
             ; depending on whether the implementation supports
             ; a distinct minus zero.
             ;As output, ÿ0.0þ is zero and ÿ-0.0þ is minus zero.
ÿ0.þ         ;On input, the integer zero--not a floating-point
             number!
             ;Whether this appears as ÿ0þ or ÿ0.þ on output depends
             ;on the value of ÿ*print-radix*þ.
ÿ0.0s0þ      ;A floating-point zero in short format
ÿ0s0þ        ;As input, this is a floating-point zero in short
             format.
             ;As output, such a zero would appear as ÿ0.0s0þ
             ; (or as ÿ0.0þ if short-float was the default format).
ÿ6.02E+23þ   ;Avogadro's number, in default format
ÿ602E+21þ    ;Also Avogadro's number, in default format

Figure 2.14: Examples of Floating-point numbers

For information on how floats are printed, see *Note Section 22.1.3.1.3
(Printing Floats): PrintingFloats.

2.3.2.3 Syntax of a Complex
...........................

A complex has a Cartesian structure, with a real part and an imaginary
part each of which is a real.  The parts of a complex are not
necessarily floats but both parts must be of the same type:

either both are rationals, or both are of the same float subtype.  When
constructing a complex, if the specified parts are not the same type,
the parts are converted to be the same type internally (i.e., the
rational part is converted to a float).  An object of type ÿ(complex
rational)þ is converted internally and represented thereafter as a
rational if its imaginary part is an integer whose value is 0.

For further information, see *Note Section 2.4.8.11 (Sharpsign C):
SharpsignC. and *Note Section 22.1.3.1.4 (Printing Complexes):
PrintingComplexes.


File: chris-ansicl.info,  Node: The Consing Dot,  Next: Symbols as Tokens,  Prev: Constructing Numbers from Tokens,  Up: Interpretation of Tokens

2.3.3 The Consing Dot
---------------------

If a token consists solely of dots (with no escape characters), then an
error of type ÿreader-errorþ is signaled, except in one circumstance:
if the token is a single dot and appears in a situation where dotted
pair notation permits a dot, then it is accepted as part of such syntax
and no error is signaled.  See *Note Section 2.4.1 (Left-Parenthesis):
Left-Parenthesis.


File: chris-ansicl.info,  Node: Symbols as Tokens,  Next: Valid Patterns for Tokens,  Prev: The Consing Dot,  Up: Interpretation of Tokens

2.3.4 Symbols as Tokens
-----------------------

Any token that is not a potential number, does not contain a package
marker, and does not consist entirely of dots will always be
interpreted as a symbol.  Any token that is a potential number but does
not fit the number syntax is a reserved token and has an
implementation-dependent interpretation.  In all other cases, the token
is construed to be the name of a symbol.

Examples of the printed representation of symbols are in the next
figure.  For presentational simplicity, these examples assume that the
readtable case of the current readtable is :upcase.

ÿFROBBOZþ         The symbol whose name is ÿFROBBOZþ.
ÿfrobbozþ         Another way to notate the same symbol.
ÿfRObBozþ         Yet another way to notate it.
ÿunwind-protectþ  A symbol with a hyphen in its name.
ÿ+$þ              The symbol named ÿ+$þ.
ÿ1+þ              The symbol named ÿ1+þ.
ÿ+1þ              This is the integer ÿ1þ, not a symbol.
ÿpascal_styleþ    This symbol has an underscore in its name.
ÿfile.rel.43þ     This symbol has periods in its name.
ÿ\(þ              The symbol whose name is ÿ(þ.
ÿ\+1þ             The symbol whose name is ÿ+1þ.
ÿ+\1þ             Also the symbol whose name is ÿ+1þ.
ÿ\frobbozþ        The symbol whose name is ÿfROBBOZþ.
ÿ3.14159265\s0þ   The symbol whose name is ÿ3.14159265s0þ.
ÿ3.14159265\S0þ   A different symbol,  whose name is ÿ3.14159265S0þ.
ÿ3.14159265s0þ    A possible short float approximation to î.

Figure 2.15: Examples of the printed representation of symbols (Part 1 of
2)

ÿAPL\\360þ             The symbol whose name is ÿAPL\360þ.
ÿapl\\360þ             Also the symbol whose name  is ÿAPL\360þ.
ÿ\(b^2\) - 4*aÿ*cþþ    The name is ÿ(B^2) - 4*A*Cþ.
                       Parentheses and two spaces in it.
ÿ\(\b^2\) -\4*\a*\cþ   The name is ÿ(b^2) - 4*a*cþ.
                       Letters explicitly lowercase.
ÿ|"|þ                  The same as writing ÿ\"þ.
ÿ|(b^2) - 4*a*c|þ      The name is ÿ(b^2) - 4*a*cþ.
ÿ|frobboz|þ            The name is ÿfrobbozþ, not ÿFROBBOZþ.
ÿ|APL\360|þ            The name is ÿAPL360þ.
ÿ|APL\\360|þ           The name is ÿAPL\360þ.
ÿ|apl\\360|þ           The name is ÿapl\360þ.
ÿ|\|\||þ               Same as ÿ\|\|þ --the name is ÿ||þ.
ÿ|(B^2) - 4*A*C|þ      The name is ÿ(B^2) - 4*A*Cþ.
                       Parentheses and two spaces in it.
ÿ|(b^2) - 4*a*c|þ      The name is ÿ(b^2) - 4*a*cþ.

Figure 2.16: Examples of the printed representation of symbols (Part 2 of
2)

In the process of parsing a symbol, it is implementation-dependent which
implementation-defined attributes are removed from the characters
forming a token that represents a symbol.

When parsing the syntax for a symbol, the Lisp reader looks up the name
of that symbol in the current package.  This lookup may involve looking
in other packages whose external symbols are inherited by the current
package.  If the name is found, the corresponding symbol is returned.
If the name is not found (that is, there is no symbol of that name
accessible in the current package), a new symbol is created and is
placed in the current package as an internal symbol.  The current
package becomes the owner (home package) of the symbol, and the symbol
becomes interned in the current package.  If the name is later read
again while this same package is current, the same symbol will be found
and returned.


File: chris-ansicl.info,  Node: Valid Patterns for Tokens,  Next: Package System Consistency Rules,  Prev: Symbols as Tokens,  Up: Interpretation of Tokens

2.3.5 Valid Patterns for Tokens
-------------------------------

The valid patterns for tokens are summarized in the next figure.

ÿnnnnnþ               a number
ÿxxxxxþ               a symbol in the current package
ÿ:xxxxxþ              a symbol in the the ÿKEYWORDþ package
ÿppppp:xxxxxþ         an external symbol in the ppppp package
ÿppppp::xxxxxþ        a (possibly internal) symbol  in the ppppp package
ÿ:nnnnnþ              undefined
ÿppppp:nnnnnþ         undefined
ÿppppp::nnnnnþ        undefined
ÿ::aaaaaþ             undefined
ÿaaaaa:þ              undefined
ÿaaaaa:aaaaa:aaaaaþ   undefined

Figure 2.17: Valid patterns for tokens

Note that nnnnn has number syntax, neither xxxxx nor ppppp has number
syntax, and aaaaa has any syntax.

A summary of rules concerning package markers follows.  In each case,
examples are offered to illustrate the case; for presentational
simplicity, the examples assume that the readtable case of the current
readtable is :upcase.

  1. If there is a single package marker, and it occurs at the
     beginning of the token, then the token is interpreted as a symbol
     in the ÿKEYWORDþ package.  It also sets the ÿsymbol-valueþ of the
     newly-created symbol to that same symbol so that the symbol will
     self-evaluate.

     For example, ÿ:barþ, when read, interns ÿBARþ as an external
     symbol in the ÿKEYWORDþ package.

  2. If there is a single package marker not at the beginning or end of
     the token, then it divides the token into two parts.  The first
     part specifies a package; the second part is the name of an
     external symbol available in that package.

     For example, ÿfoo:barþ, when read, looks up ÿBARþ among the
     external symbols of the package named ÿFOOþ.

  3. If there are two adjacent package markers not at the beginning or
     end of the token, then they divide the token into two parts.  The
     first part specifies a package; the second part is the name of a
     symbol within that package (possibly an internal symbol).

     For example, ÿfoo::barþ, when read, interns ÿBARþ in the package
     named ÿFOOþ.

  4. If the token contains no package markers, and does not have
     potential number syntax, then the entire token is the name of the
     symbol.  The symbol is looked up in the current package.

     For example, ÿbarþ, when read, interns ÿBARþ in the current
     package.

  5. The consequences are unspecified if any other pattern of package
     markers in a token is used.  All other uses of package markers
     within names of symbols are not defined by this standard but are
     reserved for implementation-dependent use.

For example, assuming the readtable case of the current readtable is
:upcase, ÿeditor:bufferþ refers to the external symbol named ÿBUFFERþ
present in the package named ÿeditorþ, regardless of whether there is a
symbol named ÿBUFFERþ in the current package.  If there is no package
named ÿeditorþ, or if no symbol named ÿBUFFERþ is present in ÿeditorþ,
or if ÿBUFFERþ is not exported by ÿeditorþ, the reader signals a
correctable error.  If ÿeditor::bufferþ is seen, the effect is exactly
the same as reading ÿbufferþ with the ÿEDITORþ package being the
current package.


File: chris-ansicl.info,  Node: Package System Consistency Rules,  Prev: Valid Patterns for Tokens,  Up: Interpretation of Tokens

2.3.6 Package System Consistency Rules
--------------------------------------

The following rules apply to the package system as long as the value of
ÿ*package*þ is not changed:

Read-read consistency
     Reading the same symbol name always results in the same symbol.

Print-read consistency
     An interned symbol always prints as a sequence of characters that,
     when read back in, yields the same symbol.

     For information about how the Lisp printer treats symbols, see
     *Note Section 22.1.3.3 (Printing Symbols): PrintingSymbols.

Print-print consistency
     If two interned symbols are not the same, then their printed
     representations will be different sequences of characters.

These rules are true regardless of any implicit interning.  As long as
the current package is not changed, results are reproducible regardless
of the order of loading files or the exact history of what symbols were
typed in when.  If the value of ÿ*package*þ is changed and then changed
back to the previous value, consistency is maintained.  The rules can
be violated by changing the value of ÿ*package*þ, forcing a change to
symbols or to packages or to both by continuing from an error, or
calling one of the following functions: ÿuninternþ, ÿunexportþ,
ÿshadowþ, ÿshadowing-importþ, or ÿunuse-packageþ.

An inconsistency only applies if one of the restrictions is violated
between two of the named symbols.  ÿshadowþ, ÿunexportþ, ÿuninternþ,
and ÿshadowing-importþ can only affect the consistency of symbols with
the same names (under ÿstring=þ) as the ones supplied as arguments.


File: chris-ansicl.info,  Node: Standard Macro Characters,  Prev: Interpretation of Tokens,  Up: Syntax

2.4 Standard Macro Characters
=============================

If the reader encounters a macro character, then its associated reader
macro function is invoked and may produce an object to be returned.
This function may read the characters following the macro character in
the stream in any syntax and return the object represented by that
syntax.

Any character can be made to be a macro character.  The macro
characters defined initially in a conforming implementation include the
following:

* Menu:

* Left-Parenthesis::
* Right-Parenthesis::
* Single-Quote::
* Semicolon::
* Double-Quote::
* Backquote::
* Comma::
* Sharpsign::
* Re-Reading Abbreviated Expressions::


File: chris-ansicl.info,  Node: Left-Parenthesis,  Next: Right-Parenthesis,  Up: Standard Macro Characters

2.4.1 Left-Parenthesis
----------------------

The left-parenthesis initiates reading of a list.  ÿreadþ is called
recursively to read successive objects until a right parenthesis is
found in the input stream.  A list of the objects read is returned.
Thus

 (a b c)

is read as a list of three objects (the symbols ÿaþ, ÿbþ, and ÿcþ).
The right parenthesis need not immediately follow the printed
representation of the last object; whitespaceà characters and comments
may precede it.

If no objects precede the right parenthesis, it reads as a list of zero
objects (the empty list).

If a token that is just a dot not immediately preceded by an escape
character is read after some object then exactly one more object must
follow the dot, possibly preceded or followed by whitespaceà or a
comment, followed by the right parenthesis:

 (a b c . d)

This means that the cdr of the last cons in the list is not ÿnilþ, but
rather the object whose representation followed the dot.  The above
example might have been the result of evaluating

 (cons 'a (cons 'b (cons 'c 'd)))

Similarly,

 (cons 'this-one 'that-one) ý (this-one . that-one)

It is permissible for the object following the dot to be a list:

 (a b c d . (e f . (g))) Õ (a b c d e f g)

For information on how the Lisp printer prints lists and conses, see
*Note Section 22.1.3.5 (Printing Lists and Conses):
PrintingListsAndConses.


File: chris-ansicl.info,  Node: Right-Parenthesis,  Next: Single-Quote,  Prev: Left-Parenthesis,  Up: Standard Macro Characters

2.4.2 Right-Parenthesis
-----------------------

The right-parenthesis is invalid except when used in conjunction with
the left parenthesis character.  For more information, see *Note
Section 2.2 (Reader Algorithm): Reader Algorithm.


File: chris-ansicl.info,  Node: Single-Quote,  Next: Semicolon,  Prev: Right-Parenthesis,  Up: Standard Macro Characters

2.4.3 Single-Quote
------------------

Syntax:  ÿ'«EXP»þ

A single-quote introduces an expression to be "quoted."  Single-quote
followed by an expression EXP is treated by the Lisp reader as an
abbreviation for and is parsed identically to the expression ÿ(quote
EXP)þ.  See the special operator *Note quote::.

2.4.3.1 Examples of Single-Quote
................................

 'foo ý FOO
 ''foo ý (QUOTE FOO)
 (car ''foo) ý QUOTE


File: chris-ansicl.info,  Node: Semicolon,  Next: Double-Quote,  Prev: Single-Quote,  Up: Standard Macro Characters

2.4.4 Semicolon
---------------

Syntax: ÿ;«TEXT»þ

A semicolon introduces characters that are to be ignored, such as
comments.  The semicolon and all characters up to and including the
next newline or end of file are ignored.

2.4.4.1 Examples of Semicolon
.............................

 (+ 3 ; three
    4)
ý 7

2.4.4.2 Notes about Style for Semicolon
.......................................

Some text editors make assumptions about desired indentation based on
the number of semicolons that begin a comment.  The following style
conventions are common, although not by any means universal.

2.4.4.2.1 Use of Single Semicolon
.................................

Comments that begin with a single semicolon are all aligned to the same
column at the right (sometimes called the "comment column").  The text
of such a comment generally applies only to the line on which it
appears.  Occasionally two or three contain a single sentence together;
this is sometimes indicated by indenting all but the first with an
additional space (after the semicolon).

2.4.4.2.2 Use of Double Semicolon
.................................

Comments that begin with a double semicolon are all aligned to the same
level of indentation as a form would be at that same position in the
code.  The text of such a comment usually describes the state of the
program at the point where the comment occurs, the code which follows
the comment, or both.

2.4.4.2.3 Use of Triple Semicolon
.................................

Comments that begin with a triple semicolon are all aligned to the left
margin.  Usually they are used prior to a definition or set of
definitions, rather than within a definition.

2.4.4.2.4 Use of Quadruple Semicolon
....................................

Comments that begin with a quadruple semicolon are all aligned to the
left margin, and generally contain only a short piece of text that
serve as a title for the code which follows, and might be used in the
header or footer of a program that prepares code for presentation as a
hardcopy document.

2.4.4.2.5 Examples of Style for Semicolon
.........................................

;;;; Math Utilities

;;; FIB computes the the Fibonacci function in the traditional
;;; recursive way.

(defun fib (n)
  (check-type n integer)
  ;; At this point we're sure we have an integer argument.
  ;; Now we can get down to some serious computation.
  (cond ((< n 0)
         ;; Hey, this is just supposed to be a simple example.
         ;; Did you really expect me to handle the general case?
         (error "FIB got ~D as an argument." n))
        ((< n 2) n)             ;fib[0]=0 and fib[1]=1
        ;; The cheap cases didn't work.
        ;; Nothing more to do but recurse.
        (t (+ (fib (- n 1))     ;The traditional formula
              (fib (- n 2)))))) ; is fib[n-1]+fib[n-2].


File: chris-ansicl.info,  Node: Double-Quote,  Next: Backquote,  Prev: Semicolon,  Up: Standard Macro Characters

2.4.5 Double-Quote
------------------

Syntax: ÿ"«TEXT»"þ

The double-quote is used to begin and end a string.  When a
double-quote is encountered, characters are read from the input stream
and accumulated until another double-quote is encountered.  If a single
escape character is seen, the single escape character is discarded, the
next character is accumulated, and accumulation continues.  The
accumulated characters up to but not including the matching double-quote
are made into a simple string and returned.  It is
implementation-dependent which attributes of the accumulated characters
are removed in this process.

Examples of the use of the double-quote character are in the next
figure.

ÿ"Foo"þ                       ;A string with three characters in it
ÿ""þ                          ;An empty string
ÿ"\"APL\\360?\" he cried."þ   ;A string with twenty characters
ÿ"|x| = |-x|"þ                ;A ten-character string

Figure 2.18: Examples of the use of double-quote

Note that to place a single escape character or a double-quote into a
string, such a character must be preceded by a single escape character.
Note, too, that a multiple escape character need not be quoted by a
single escape character within a string.

For information on how the Lisp printer prints strings, see *Note
Section 22.1.3.4 (Printing Strings): PrintingStrings.


File: chris-ansicl.info,  Node: Backquote,  Next: Comma,  Prev: Double-Quote,  Up: Standard Macro Characters

2.4.6 Backquote
---------------

The backquote introduces a template of a data structure to be built.
For example, writing

 `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))

is roughly equivalent to writing

 (list 'cond
       (cons (list 'numberp x) y)
       (list* 't (list 'print x) y))

Where a comma occurs in the template, the expression following the
comma is to be evaluated to produce an object to be inserted at that
point.  Assume ÿbþ has the value 3, for example, then evaluating the
form denoted by ÿ`(a b ,b ,(+ b 1) b)þ produces the result ÿ(a b 3 4
b)þ.

If a comma is immediately followed by an at-sign, then the form
following the at-sign is evaluated to produce a list of objects.  These
objects are then "spliced" into place in the template.  For example, if
ÿxþ has the value ÿ(a b c)þ, then

 `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
ý (x (a b c) a b c foo b bar (b c) baz b c)

The backquote syntax can be summarized formally as follows.

   * ÿ`BASICþ is the same as ÿ'BASICþ, that is, ÿ(quote BASIC)þ, for
     any expression BASIC that is not a list or a general vector.

   * ÿ`,FORMþ is the same as FORM, for any FORM, provided that the
     representation of FORM does not begin with at-sign or dot.  (A
     similar caveat holds for all occurrences of a form after a comma.)

   * ÿ`,@FORMþ has undefined consequences.

   * ÿ`(x1 x2 x3 ... xn . atom)þ may be interpreted to mean

      (append [ x1] [ x2] [ x3] ... [ xn] (quote atom))

     where the brackets are used to indicate a transformation of an XJ
     as follows:

        - ÿ[FORM]þ is interpreted as ÿ(list `FORM)þ, which contains a
          backquoted form that must then be further interpreted.

        - ÿ[,FORM]þ is interpreted as ÿ(list FORM)þ.

        - ÿ[,@FORM]þ is interpreted as FORM.

   * ÿ`(x1 x2 x3 ... xn)þ may be interpreted to mean the same as the
     backquoted form ÿ`(x1 x2 x3 ... xn . ÿnilþ)þ, thereby reducing it
     to the previous case.

   * ÿ`(x1 x2 x3 ... xn . ,form)þ may be interpreted to mean

      (append [ x1] [ x2] [ x3] ... [ xn] form)

     where the brackets indicate a transformation of an ÿxjþ as
     described above.

   * ÿ`(x1 x2 x3 ... xn . ,@form)þ has undefined consequences.

   * ÿ`#(x1 x2 x3 ... xn)þ may be interpreted to mean ÿ(apply #'vector
     `(x1 x2 x3 ... xn))þ.

Anywhere "ÿ,@þ" may be used, the syntax "ÿ,.þ" may be used instead to
indicate that it is permissible to operate destructively on the list
structure  produced by the form following the "ÿ,.þ" (in effect, to use
ÿnconcþ instead of ÿappendþ).

If the backquote syntax is nested, the innermost backquoted form should
be expanded first.  This means that if several commas occur in a row,
the leftmost one belongs to the innermost backquote.

An implementation is free to interpret a backquoted form Fá as any form
Fà that, when evaluated, will produce a result that is the same under
ÿequalþ as the result implied by the above definition, provided that
the side-effect behavior of the substitute form Fà is also consistent
with the description given above.  The constructed copy of the template
might or might not share list structure with the template itself.  As
an example, the above definition implies that

 `((,a b) ,c ,@d)

will be interpreted as if it were

 (append (list (append (list a) (list 'b) 'ÿnilþ)) (list c) d 'ÿnilþ)

but it could also be legitimately interpreted to mean any of the
following:

 (append (list (append (list a) (list 'b))) (list c) d)
 (append (list (append (list a) '(b))) (list c) d)
 (list* (cons a '(b)) c d)
 (list* (cons a (list 'b)) c d)
 (append (list (cons a '(b))) (list c) d)
 (list* (cons a '(b)) c (copy-list d))

2.4.6.1 Notes about Backquote
.............................

Since the exact manner in which the Lisp reader will parse an
expression involving the backquote reader macro is not specified, an
implementation is free to choose any representation that preserves the
semantics described.

Often an implementation will choose a representation that facilitates
pretty printing of the expression, so that ÿ(pprint `(a ,b))þ will
display ÿ`(a ,b)þ and not, for example, ÿ(list 'a b)þ.  However, this
is not a requirement.

Implementors who have no particular reason to make one choice or another
might wish to refer to `IEEE Standard for the Scheme Programming
Language', which identifies a popular choice of representation for such
expressions that might provide useful to be useful compatibility for
some user communities.  There is no requirement, however, that any
conforming implementation use this particular representation.  This
information is provided merely for cross-reference purposes.


File: chris-ansicl.info,  Node: Comma,  Next: Sharpsign,  Prev: Backquote,  Up: Standard Macro Characters

2.4.7 Comma
-----------

The comma is part of the backquote syntax; see *Note Section 2.4.6
(Backquote): Backquote.  Comma is invalid if used other than inside the
body of a backquote expression as described above.


File: chris-ansicl.info,  Node: Sharpsign,  Next: Re-Reading Abbreviated Expressions,  Prev: Comma,  Up: Standard Macro Characters

2.4.8 Sharpsign
---------------

Sharpsign is a non-terminating dispatching macro character.  It reads
an optional sequence of digits and then one more character, and uses
that character to select a function to run as a reader macro function.

The standard syntax includes constructs introduced by the ÿ#þ character.
The syntax of these constructs is as follows: a character that
identifies the type of construct is followed by arguments in some form.
If the character is a letter, its case is not important; ÿ#Oþ and ÿ#oþ
are considered to be equivalent, for example.

Certain ÿ#þ constructs allow an unsigned decimal number to appear
between the ÿ#þ and the character.

The reader macros associated with the dispatching macro character ÿ#þ
are described later in this section and summarized in the next figure.

dispatch char   purpose                   dispatch char   purpose
----------------------------------------------------------------------------- 
Backspace       signals error             ÿ{þ             undefined*
Tab             signals error             ÿ}þ             undefined*
Newline         signals error             +               read-time
                                                          conditional
Linefeed        signals error             -               read-time
                                                          conditional
Page            signals error             .               read-time
                                                          evaluation
Return          signals error             /               undefined
Space           signals error             A, a            array
!               undefined*                B, b            binary rational
ÿ"þ             undefined                 C, c            complex number
#               reference to = label      D, d            undefined
$               undefined                 E, e            undefined
%               undefined                 F, f            undefined
&               undefined                 G, g            undefined
'               function abbreviation     H, h            undefined
(               simple vector             I, i            undefined
)               signals error             J, j            undefined
ÿ*þ             bit vector                K, k            undefined
,               undefined                 L, l            undefined
:               uninterned symbol         M, m            undefined
;               undefined                 N, n            undefined
ÿ<þ             signals error             O, o            octal rational
ÿ=þ             labels following object   P, p            pathname
ÿ>þ             undefined                 Q, q            undefined
?               undefined*                R, r            radix-n rational
@               undefined                 S, s            structure
[               undefined*                T, t            undefined
ÿ\þ             character object          U, u            undefined
]               undefined*                V, v            undefined
^               undefined                 W, w            undefined
ÿ_þ             undefined                 X, x            hexadecimal
                                                          rational
`               undefined                 Y, y            undefined
ÿ|þ             balanced comment          Z, z            undefined
ÿ~þ             undefined                 Rubout          undefined

Figure 2.19: Standard # Dispatching Macro Character Syntax

The combinations marked by an asterisk (*) are explicitly reserved to
the user.  No conforming implementation defines them.

Note also that digits do not appear in the preceding table.  This is
because the notations ÿ#0þ, ÿ#1þ, ..., ÿ#9þ are reserved for another
purpose which occupies the same syntactic space.  When a digit follows
a sharpsign, it is not treated as a dispatch character.  Instead, an
unsigned integer argument is accumulated and passed as an argument to
the reader macro for the character that follows the digits.  For
example, ÿ#2A((1 2) (3 4))þ is a use of ÿ#Aþ with an argument of ÿ2þ.

2.4.8.1 Sharpsign Backslash
...........................

Syntax: ÿ#\«X»þ

When the token X is a single character long, this parses as the literal
character CHAR.  Uppercase and lowercase letters are distinguished
after ÿ#\þ; ÿ#\Aþ and ÿ#\aþ denote different character objects.  Any
single character works after ÿ#\þ, even those that are normally special
to ÿreadþ, such as left-parenthesis and right-parenthesis.

In the single character case, the X must be followed by a
non-constituent character.  After ÿ#\þ is read, the reader backs up
over the slash and then reads a token, treating the initial slash as a
single escape character (whether it really is or not in the current
readtable).

When the token X is more than one character long, the X must have the
syntax of a symbol with no embedded package markers.  In this case, the
sharpsign backslash notation parses as the character whose name is
ÿ(string-upcase X)þ; see *Note Section 13.1.7 (Character Names):
Character Names.

For information about how the Lisp printer prints character objects,
see *Note Section 22.1.3.2 (Printing Characters): PrintingCharacters.

2.4.8.2 Sharpsign Single-Quote
..............................

Any EXPRESSION preceded by ÿ#'þ (sharpsign followed by single-quote),
as in ÿ#'EXPRESSIONþ, is treated by the Lisp reader as an abbreviation
for and parsed identically to the expression ÿ(function EXPRESSION)þ.
See ÿfunctionþ.  For example,

(apply #'+ l) Õ (apply (function +) l)

2.4.8.3 Sharpsign Left-Parenthesis
..................................

ÿ#(þ and ÿ)þ are used to notate a simple vector.

If an unsigned decimal integer appears between the ÿ#þ and ÿ(þ, it
specifies explicitly the length of the vector.  The consequences are
undefined if the number of objects specified before the closing ÿ)þ
exceeds the unsigned decimal integer.  If the number of objects
supplied before the closing ÿ)þ is less than the unsigned decimal
integer but greater than zero, the last object is used to fill all
remaining elements of the vector.

The consequences are undefined if the unsigned decimal integer is
non-zero and number of objects supplied before the closing ÿ)þ is zero.
For example,

 #(a b c c c c)
 #6(a b c c c c)
 #6(a b c)
 #6(a b c c)

all mean the same thing: a vector of length ÿ6þ with elements ÿaþ, ÿbþ,
and four occurrences of ÿcþ.  Other examples follow:

 #(a b c)               ;A vector of length 3
 #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)
                        ;A vector containing the primes below 50
 #()                    ;An empty vector

The notation ÿ#()þ denotes an empty vector, as does ÿ#0()þ.

For information on how the Lisp printer prints vectors, see *Note
Section 22.1.3.4 (Printing Strings): PrintingStrings, *Note Section
22.1.3.6 (Printing Bit Vectors): PrintingBitVectors, or *Note Section
22.1.3.7 (Printing Other Vectors): PrintingOtherVectors.

2.4.8.4 Sharpsign Asterisk
..........................

Syntax: ÿ#*«BITS»þ

A simple bit vector is constructed containing the indicated bits (ÿ0þ's
and ÿ1þ's), where the leftmost BIT has index zero and the subsequent
BITS have increasing indices.

Syntax: ÿ#«N»*«BITS»þ

With an argument N, the vector to be created is of length N.  If the
number of BITS is less than N but greater than zero, the last bit is
used to fill all remaining bits of the bit vector.

The notations ÿ#*þ and ÿ#0*þ each denote an empty bit vector.

Regardless of whether the optional numeric argument N is provided, the
token that follows the asterisk is delimited by a normal token
delimiter.  However, (unless the value of ÿ*read-suppress*þ is true) an
error of type ÿreader-errorþ is signaled if that token is not composed
entirely of ÿ0þ's and ÿ1þ's, or if N was supplied and the token is
composed of more than N BITS, or if N is greater than one, but no BITS
were specified.  Neither a single escape nor a multiple escape is
permitted in this token.

For information on how the Lisp printer prints bit vectors, see *Note
Section 22.1.3.6 (Printing Bit Vectors): PrintingBitVectors.

2.4.8.4.1 Examples of Sharpsign Asterisk
........................................

For example,
  #*101111
 #6*101111
 #6*101
 #6*1011

all mean the same thing: a vector of length ÿ6þ with elements ÿ1þ, ÿ0þ,
ÿ1þ, ÿ1þ, ÿ1þ, and ÿ1þ.

For example:

 #*         ;An empty bit-vector

2.4.8.5 Sharpsign Colon
.......................

Syntax:  ÿ#:«SYMBOL-NAME»þ

ÿ#:þ introduces an uninterned symbol whose name is SYMBOL-NAME.  Every
time this syntax is encountered, a distinct uninterned symbol is
created.  The SYMBOL-NAME must have the syntax of a symbol with no
package prefix.

For information on how the Lisp reader prints uninterned symbols, see
*Note Section 22.1.3.3 (Printing Symbols): PrintingSymbols.

2.4.8.6 Sharpsign Dot
.....................

ÿ#.FOOþ is read as the object resulting from the evaluation of the
object represented by FOO.  The evaluation is done during the ÿreadþ
process, when the ÿ#.þ notation is encountered.  The ÿ#.þ syntax
therefore performs a read-time evaluation of FOO.

The normal effect of ÿ#.þ is inhibited when the value of ÿ*read-eval*þ
is false.  In that situation, an error of type ÿreader-errorþ is
signaled.

For an object that does not have a convenient printed representation, a
form that computes the object can be given using the ÿ#.þ notation.

2.4.8.7 Sharpsign B
...................

ÿ#BþRATIONAL reads RATIONAL in binary (radix 2).  For example,

 #B1101 Õ 13 ;1101à
 #b101/11 Õ 5/3

The consequences are undefined if the token immediately following the
ÿ#Bþ does not have the syntax of a binary (i.e., radix 2) rational.

2.4.8.8 Sharpsign O
...................

ÿ#OþRATIONAL reads RATIONAL in octal (radix 8).  For example,

 #o37/15 Õ 31/13
 #o777 Õ 511
 #o105 Õ 69 ;105Ú

The consequences are undefined if the token immediately following the
ÿ#Oþ does not have the syntax of an octal (i.e., radix 8) rational.

2.4.8.9 Sharpsign X
...................

ÿ#XþRATIONAL reads RATIONAL in hexadecimal (radix 16).  The digits
above ÿ9þ are the letters ÿAþ through ÿFþ (the lowercase letters ÿaþ
through ÿfþ are also acceptable).  For example,

 #xF00 Õ 3840
 #x105 Õ 261 ;105áÜ

The consequences are undefined if the token immediately following the
ÿ#Xþ does not have the syntax of a hexadecimal (i.e., radix 16)
rational.

2.4.8.10 Sharpsign R
....................

ÿ#NRþ

ÿ#RADIXRRATIONALþ reads RATIONAL in radix RADIX.  RADIX must consist of
only digits that are interpreted as an integer in decimal radix; its
value must be between 2 and 36 (inclusive).  Only valid digits for the
specified radix may be used.

For example, ÿ#3r102þ is another way of writing ÿ11þ (decimal), and
ÿ#11R32þ is another way of writing ÿ35þ (decimal).  For radices larger
than 10, letters of the alphabet are used in order for the digits after
ÿ9þ.  No alternate ÿ#þ notation exists for the decimal radix since a
decimal point suffices.

The next figure contains examples of the use of ÿ#Bþ, ÿ#Oþ, ÿ#Xþ, and
ÿ#Rþ.

ÿ#2r11010101þ   ;Another way of writing ÿ213þ decimal
ÿ#b11010101þ    ;Ditto
ÿ#b+11010101þ   ;Ditto
ÿ#o325þ         ;Ditto, in octal radix
ÿ#xD5þ          ;Ditto, in hexadecimal radix
ÿ#16r+D5þ       ;Ditto
ÿ#o-300þ        ;Decimal ÿ-192þ, written in base 8
ÿ#3r-21010þ     ;Same thing in base 3
ÿ#25R-7Hþ       ;Same thing in base 25
ÿ#xACCEDEDþ     ;ÿ181202413þ, in hexadecimal radix

Figure 2.20: Radix Indicator Example

The consequences are undefined if the token immediately following the
ÿ#NRþ does not have the syntax of a rational in radix N.

2.4.8.11 Sharpsign C
....................

ÿ#Cþ reads a following object, which must be a list of length two whose
elements are both reals.  These reals denote, respectively, the real
and imaginary parts of a complex number.  If the two parts as notated
are not of the same data type, then they are converted according to the
rules of floating-point contagion described in *Note Section 12.1.1.2
(Contagion in Numeric Operations): NumericContagionRules.

ÿ#C(REAL IMAG)þ is equivalent to ÿ#.(complex (quote REAL) (quote
IMAG))þ, except that ÿ#Cþ is not affected by ÿ*read-eval*þ.  See the
function *Note complex (Function)::.

The next figure contains examples of the use of ÿ#Cþ.

ÿ#C(3.0s1 2.0s-1)þ   ;A complex with small float parts.
ÿ#C(5 -3)      þ     ;A "Gaussian integer"
ÿ#C(5/3 7.0) þ       ;Will be converted internally to ÿ#C(1.66666 7.0)þ
ÿ#C(0 1)þ            ;The imaginary unit; that is, i.

Figure 2.21: Complex Number Example

For further information, see *Note Section 22.1.3.1.4 (Printing
Complexes): PrintingComplexes. and *Note Section 2.3.2.3 (Syntax of a
Complex): SyntaxOfComplexes.

2.4.8.12 Sharpsign A
....................

ÿ#NAþ

ÿ#NÿAþOBJECTþ constructs an N-dimensional array, using OBJECT as the
value of the :initial-contents argument to ÿmake-arrayþ.

For example, ÿ#2A((0 1 5) (foo 2 (hot dog)))þ represents a 2-by-3
matrix:

 0       1       5
 foo     2       (hot dog)

In contrast, ÿ#1A((0 1 5) (foo 2 (hot dog)))þ represents a vector of
length ÿ2þ whose elements are lists:

 (0 1 5) (foo 2 (hot dog))

ÿ#0A((0 1 5) (foo 2 (hot dog)))þ represents a zero-dimensional array
whose sole element is a list:

 ((0 1 5) (foo 2 (hot dog)))

ÿ#0A fooþ represents a zero-dimensional array whose sole element is the
symbol ÿfooþ.  The notation ÿ#1A fooþ is not valid because ÿfooþ is not
a sequence.

If some dimension of the array whose representation is being parsed is
found to be ÿ0þ, all dimensions to the right (i.e., the higher numbered
dimensions) are also considered to be ÿ0þ.

For information on how the Lisp printer prints arrays, see *Note
Section 22.1.3.4 (Printing Strings): PrintingStrings, *Note Section
22.1.3.6 (Printing Bit Vectors): PrintingBitVectors, *Note Section
22.1.3.7 (Printing Other Vectors): PrintingOtherVectors, or *Note
Section 22.1.3.8 (Printing Other Arrays): PrintingOtherArrays.

2.4.8.13 Sharpsign S
....................

ÿ#s(name slot1 value1 slot2 value2 ...)þ denotes a structure.  This is
valid only if NAME is the name of a structure type already defined by
ÿdefstructþ and if the structure type has a standard constructor
function.  Let CM stand for the name of this constructor function; then
this syntax is equivalent to

 #.(cm keyword1 'value1 keyword2 'value2 ...)

where each KEYWORDJ is the result of computing

 (intern (string slotj) (find-package 'keyword))

The net effect is that the constructor function is called with the
specified slots having the specified values.  (This coercion feature is
deprecated; in the future, keyword names will be taken in the package
they are read in, so symbols that are actually in the ÿKEYWORDþ package
should be used if that is what is desired.)

Whatever object the constructor function returns is returned by the
ÿ#Sþ syntax.

For information on how the Lisp printer prints structures, see *Note
Section 22.1.3.12 (Printing Structures): PrintingStructures.

2.4.8.14 Sharpsign P
....................

ÿ#Pþ reads a following object, which must be a string.

ÿ#P«EXPRESSION»þ is equivalent to ÿ#.(parse-namestring '«EXPRESSION»)þ,
except that ÿ#Pþ is not affected by ÿ*read-eval*þ.

For information on how the Lisp printer prints pathnames, see *Note
Section 22.1.3.11 (Printing Pathnames): PrintingPathnames.

2.4.8.15 Sharpsign Equal-Sign
.............................

ÿ#N=þ

ÿ#N=OBJECTþ reads as whatever object has OBJECT as its printed
representation.  However, that object is labeled by N, a required
unsigned decimal integer, for possible reference by the syntax ÿ#N#þ.
The scope of the label is the expression being read by the outermost
call to ÿreadþ; within this expression, the same label may not appear
twice.

2.4.8.16 Sharpsign Sharpsign
............................

ÿ#N#þ

ÿ#N#þ, where N is a required unsigned decimal integer, provides a
reference to some object labeled by ÿ#N=þ; that is, ÿ#N#þ represents a
pointer to the same (ÿeqþ) object labeled by ÿ#N=þ.  For example, a
structure created in the variable ÿyþ by this code:

 (setq x (list 'p 'q))
 (setq y (list (list 'a 'b) x 'foo x))
 (rplacd (last y) (cdr y))

could be represented in this way:

 ((a b) . #1=(#2=(p q) foo #2# . #1#))

Without this notation, but with ÿ*print-length*þ set to ÿ10þ and
ÿ*print-circle*þ set to ÿnilþ, the structure would print in this way:

 ((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)

A reference ÿ#N#þ may only occur after a label ÿ#N=þ; forward
references are not permitted.  The reference may not appear as the
labeled object itself (that is, ÿ#N=#N#þ) may not be written because
the object labeled by ÿ#N=þ is not well defined in this case.

2.4.8.17 Sharpsign Plus
.......................

ÿ#+þ provides a read-time conditionalization facility; the syntax is
ÿ#+TEST EXPRESSIONþ.  If the feature expression TEST succeeds, then
this textual notation represents an object whose printed representation
is EXPRESSION.  If the feature expression TEST fails, then this textual
notation is treated as whitespaceà; that is, it is as if the "ÿ#+þ TEST
EXPRESSION" did not appear and only a space appeared in its place.

For a detailed description of success and failure in feature
expressions, see *Note Section 24.1.2.1 (Feature Expressions):
FeatureExpressions.

ÿ#+þ operates by first reading the feature expression and then skipping
over the FORM if the feature expression fails.  While reading the TEST,
the current package is the ÿKEYWORDþ package.  Skipping over the FORM
is accomplished by binding ÿ*read-suppress*þ to true and then calling
ÿreadþ.

For examples, see *Note Section 24.1.2.1.1 (Examples of Feature
Expressions): FeatureExpExamples.

2.4.8.18 Sharpsign Minus
........................

ÿ#-þ is like ÿ#+þ except that it skips the EXPRESSION if the TEST
succeeds; that is,

#-TEST EXPRESSION Õ #+(not TEST) EXPRESSION

For examples, see *Note Section 24.1.2.1.1 (Examples of Feature
Expressions): FeatureExpExamples.

2.4.8.19 Sharpsign Vertical-Bar
...............................

ÿ#|...|#þ is treated as a comment by the reader.  It must be balanced
with respect to other occurrences of ÿ#|þ and ÿ|#þ, but otherwise may
contain any characters whatsoever.

2.4.8.19.1 Examples of Sharpsign Vertical-Bar
.............................................

The following are some examples that exploit the ÿ#|...|#þ notation:

;;; In this example, some debugging code is commented out with #|...|#
;;; Note that this kind of comment can occur in the middle of a line
;;; (because a delimiter marks where the end of the comment occurs)
;;; where a semicolon comment can only occur at the end of a line
;;; (because it comments out the rest of the line).
 (defun add3 (n) #|(format t "~&Adding 3 to ~D." n)|# (+ n 3))

;;; The examples that follow show issues related to #| ... |# nesting.

;;; In this first example, #| and |# always occur properly paired,
;;; so nesting works naturally.
 (defun mention-fun-fact-1a ()
   (format t "CL uses ; and #|...|# in comments."))
ý MENTION-FUN-FACT-1A
 (mention-fun-fact-1a)
Ö CL uses ; and #|...|# in comments.
ý NIL
 #| (defun mention-fun-fact-1b ()
      (format t "CL uses ; and #|...|# in comments.")) |#
 (fboundp 'mention-fun-fact-1b) ý NIL

;;; In this example, vertical-bar followed by sharpsign needed to appear
;;; in a string without any matching sharpsign followed by vertical-bar
;;; having preceded this.  To compensate, the programmer has included a
;;; slash separating the two characters.  In case 2a, the slash is
;;; unnecessary but harmless, but in case 2b, the slash is critical to
;;; allowing the outer #| ... |# pair match.  If the slash were not present,
;;; the outer comment would terminate prematurely.
 (defun mention-fun-fact-2a ()
   (format t "Don't use |\# unmatched or you'll get in trouble!"))
ý MENTION-FUN-FACT-2A
 (mention-fun-fact-2a)
Ö Don't use |# unmatched or you'll get in trouble!
ý NIL
 #| (defun mention-fun-fact-2b ()
      (format t "Don't use |\# unmatched or you'll get in trouble!") |#
 (fboundp 'mention-fun-fact-2b) ý NIL

;;; In this example, the programmer attacks the mismatch problem in a
;;; different way.  The sharpsign vertical bar in the comment is not needed
;;; for the correct parsing of the program normally (as in case 3a), but
;;; becomes important to avoid premature termination of a comment when such
;;; a program is commented out (as in case 3b).
 (defun mention-fun-fact-3a () ; #|
   (format t "Don't use |# unmatched or you'll get in trouble!"))
ý MENTION-FUN-FACT-3A
 (mention-fun-fact-3a)
Ö Don't use |# unmatched or you'll get in trouble!
ý NIL
 #|
 (defun mention-fun-fact-3b () ; #|
   (format t "Don't use |# unmatched or you'll get in trouble!"))
 |#
 (fboundp 'mention-fun-fact-3b) ý NIL

2.4.8.19.2 Notes about Style for Sharpsign Vertical-Bar
.......................................................

Some text editors that purport to understand Lisp syntax treat any
ÿ|...|þ as balanced pairs that cannot nest (as if they were just
balanced pairs of the multiple escapes used in notating certain
symbols).  To compensate for this deficiency, some programmers use the
notation ÿ#||...#||...||#...||#þ instead of ÿ#|...#|...|#...|#þ.   Note
that this alternate usage is not a different reader macro; it merely
exploits the fact that the additional vertical-bars occur within the
comment in a way that tricks certain text editor into better supporting
nested comments.  As such, one might sometimes see code like:

 #|| (+ #|| 3 ||# 4 5) ||#

Such code is equivalent to:

 #| (+ #| 3 |# 4 5) |#

2.4.8.20 Sharpsign Less-Than-Sign
.................................

ÿ#<þ is not valid reader syntax.  The Lisp reader will signal an error
of type ÿreader-errorþ on encountering ÿ#<þ.  This syntax is typically
used in the printed representation of objects that cannot be read back
in.

2.4.8.21 Sharpsign Whitespace
.............................

ÿ#þ followed immediately by whitespaceá is not valid reader syntax.
The Lisp reader will signal an error of type ÿreader-errorþ if it
encounters the reader macro notation ÿ#<Newline>þ or ÿ#<Space>þ.

2.4.8.22 Sharpsign Right-Parenthesis
....................................

This is not valid reader syntax.

The Lisp reader will signal an error of type ÿreader-errorþ upon
encountering ÿ#)þ.


File: chris-ansicl.info,  Node: Re-Reading Abbreviated Expressions,  Prev: Sharpsign,  Up: Standard Macro Characters

2.4.9 Re-Reading Abbreviated Expressions
----------------------------------------

Note that the Lisp reader will generally signal an error of type
ÿreader-errorþ when reading an expressionà that has been abbreviated
because of length or level limits (see ÿ*print-level*þ,
ÿ*print-length*þ, and ÿ*print-lines*þ) due to restrictions on "ÿ..þ",
"ÿ...þ", "ÿ#þ" followed by whitespaceá, and "ÿ#)þ".


File: chris-ansicl.info,  Node: Evaluation and Compilation,  Next: Types and Classes,  Prev: Syntax,  Up: Top

3 Evaluation and Compilation
****************************

* Menu:

* Evaluation::
* Compilation::
* Declarations::
* Lambda Lists::
* Error Checking in Function Calls::
* Traversal Rules and Side Effects::
* Destructive Operations::

Dictionary

* lambda (Symbol)::
* lambda (Macro)::
* compile::
* eval::
* eval-when::
* load-time-value::
* quote::
* compiler-macro-function::
* define-compiler-macro::
* defmacro::
* macro-function::
* macroexpand; macroexpand-1::
* define-symbol-macro::
* symbol-macrolet::
* *macroexpand-hook*::
* proclaim::
* declaim::
* declare::
* ignore; ignorable::
* dynamic-extent::
* type::
* inline; notinline::
* ftype::
* declaration::
* optimize::
* special::
* locally::
* the::
* special-operator-p::
* constantp::


File: chris-ansicl.info,  Node: Evaluation,  Next: Compilation,  Up: Evaluation and Compilation

3.1 Evaluation
==============

Execution of code can be accomplished by a variety of means ranging
from direct interpretation of a form representing a program to
invocation of compiled code produced by a compiler.

"Evaluation" is the process by which a program is executed in Common
Lisp.  The mechanism of evaluation is manifested both implicitly
through the effect of the Lisp read-eval-print loop, and  explicitly
through the presence of the functions ÿevalþ, ÿcompileþ, ÿcompile-fileþ,
and ÿloadþ.  Any of these facilities might share the same execution
strategy, or each might use a different one.

The behavior of a conforming program processed by ÿevalþ and by
ÿcompile-fileþ might differ; see *Note Section 3.2.2.3 (Semantic
Constraints): SemanticConstraints.

Evaluation can be understood in terms of a model in which an
interpreter recursively traverses a form performing each step of the
computation as it goes.  This model, which describes the semantics of
Common Lisp programs, is described in *Note Section 3.1.2 (The
Evaluation Model): The Evaluation Model.

* Menu:

* Introduction to Environments::
* The Evaluation Model::
* Lambda Expressions::
* Closures and Lexical Binding::
* Shadowing::
* Extent::
* Return Values::


File: chris-ansicl.info,  Node: Introduction to Environments,  Next: The Evaluation Model,  Up: Evaluation

3.1.1 Introduction to Environments
----------------------------------

A "binding" is an association between a name and that which the name
denotes.  Bindings are established in a lexical environment or a
dynamic environment by particular special operators.

An "environment" is a set of bindings and other information used during
evaluation (e.g., to associate meanings with names).

Bindings in an environment are partitioned into "namespaces".  A single
name can simultaneously have more than one associated binding per
environment, but can have only one associated binding per namespace.

3.1.1.1 The Global Environment
..............................

The "global environment" is that part of an environment that contains
bindings with both indefinite scope and indefinite extent.  The global
environment contains, among other things, the following:

   * bindings of dynamic variables and constant variables.

   * bindings of functions, macros, and special operators.

   * bindings of compiler macros.

   * bindings of type and class names

   * information about proclamations.

3.1.1.2 Dynamic Environments
............................

A "dynamic environment" for evaluation is that part of an environment
that contains bindings whose duration is bounded by points of
establishment and disestablishment within the execution of the form that
established the binding.  A dynamic environment contains, among other
things, the following:

   * bindings for dynamic variables.

   * information about active catch tags.

   * information about exit points established by ÿunwind-protectþ.

   * information about active handlers and restarts.

The dynamic environment that is active at any given point in the
execution of a program is referred to by definite reference as "the
current dynamic environment," or sometimes as just "the dynamic
environment."

Within a given namespace, a name is said to be bound in a dynamic
environment if there is a binding associated with its name in the
dynamic environment or, if not, there is a binding associated with its
name in the global environment.

3.1.1.3 Lexical Environments
............................

A "lexical environment" for evaluation at some position in a program is
that part of the environment that contains information having lexical
scope within the forms containing that position.  A lexical environment
contains, among other things, the following:

   * bindings of lexical variables and symbol macros.

   * bindings of functions and macros.  (Implicit in this is
     information about those compiler macros that are locally disabled.)

   * bindings of block tags.

   * bindings of go tags.

   * information about declarations.

The lexical environment that is active at any given position in a
program being semantically processed is referred to by definite
reference as "the current lexical environment," or sometimes as just
"the lexical environment."

Within a given namespace, a name is said to be bound in a lexical
environment if there is a binding associated with its name in the
lexical environment or, if not, there is a binding associated with its
name in the global environment.

3.1.1.3.1 The Null Lexical Environment
......................................

The "null lexical environment" is equivalent to the global environment.

Although in general the representation of an environment object is
implementation-dependent, ÿnilþ can be used in any situation where an
environment object is called for in order to denote the null lexical
environment.

3.1.1.4 Environment Objects
...........................

Some operators make use of an object, called an "environment object",
that represents the set of lexical bindings needed to perform semantic
analysis on a form in a given lexical environment.  The set of bindings
in an environment object may be a subset of the bindings that would be
needed to actually perform an evaluation; for example, values
associated with variable names and function names in the corresponding
lexical environment might not be available in an environment object.

The type and nature of an environment object is
implementation-dependent.  The values of environment parameters to
macro functions are examples of environment objects.

The object ÿnilþ when used as an environment object denotes the null
lexical environment; see *Note Section 3.1.1.3.1 (The Null Lexical
Environment): NullLexicalEnv.


File: chris-ansicl.info,  Node: The Evaluation Model,  Next: Lambda Expressions,  Prev: Introduction to Environments,  Up: Evaluation

3.1.2 The Evaluation Model
--------------------------

A Common Lisp system evaluates forms with respect to lexical, dynamic,
and global environments.  The following sections describe the
components of the Common Lisp evaluation model.

3.1.2.1 Form Evaluation
.......................

Forms fall into three categories: symbols, conses, and self-evaluating
objects.  The following sections explain these categories.

3.1.2.1.1 Symbols as Forms
..........................

If a form is a symbol, then it is either a symbol macro or a variable.

The symbol names a symbol macro if there is a binding of the symbol as
a symbol macro in the current lexical environment (see
ÿdefine-symbol-macroþ and ÿsymbol-macroletþ).  If the symbol is a
symbol macro, its expansion function is obtained.  The expansion
function is a function of two arguments, and is invoked by calling the
macroexpand hook with the expansion function as its first argument, the
symbol as its second argument, and an environment object (corresponding
to the current lexical environment) as its third argument.  The
macroexpand hook, in turn, calls the expansion function with the form
as its first argument and the environment as its second argument.  The
value of the expansion function, which is passed through by the
macroexpand hook, is a form.  This resulting form is processed in place
of the original symbol.

If a form is a symbol that is not a symbol macro, then it is the name
of a variable, and the value of that variable is returned. There are
three kinds of variables: lexical variables, dynamic variables, and
constant variables.  A variable can store one object.  The main
operations on a variable are to readá and to writeá its value.

An error of type ÿunbound-variableþ should be signaled if an unbound
variable is referenced.

Non-constant variables can be assigned by using ÿsetqþ or boundß by
using ÿletþ.  The next figure lists some defined names that are
applicable to assigning, binding, and defining variables.

boundp         let                   progv
defconstant    let*                  psetq
defparameter   makunbound            set
defvar         multiple-value-bind   setq
lambda         multiple-value-setq   symbol-value

Figure 3.1: Some Defined Names Applicable to Variables

The following is a description of each kind of variable.

3.1.2.1.1.1 Lexical Variables
.............................

A lexical variable is a variable that can be referenced only within the
lexical scope of the form that establishes that variable; lexical
variables have lexical scope.  Each time a form creates a lexical
binding of a variable, a fresh binding is established.

Within the scope of a binding for a lexical variable name, uses of that
name as a variable are considered to be references to that binding
except where the variable is shadowedà by a form that establishes a
fresh binding for that variable name, or by a form that locally
declares the name ÿspecialþ.

A lexical variable always has a value.  There is no operator that
introduces a binding for a lexical variable without giving it an
initial value, nor is there any operator that can make a lexical
variable be unbound.

Bindings of lexical variables are found in the lexical environment.

3.1.2.1.1.2 Dynamic Variables
.............................

A variable is a dynamic variable if one of the following conditions
hold:

   * It is locally declared or globally proclaimed ÿspecialþ.

   * It occurs textually within a form that creates a dynamic binding
     for a variable of the same name, and the binding is not shadowedà
     by a form that creates a lexical binding of the same variable name.

A dynamic variable can be referenced at any time in any program; there
is no textual limitation on references to dynamic variables.  At any
given time, all dynamic variables with a given name refer to exactly
one binding, either in the dynamic environment or in the global
environment.

The value part of the binding for a dynamic variable might be empty; in
this case, the dynamic variable is said to have no value, or to be
unbound.  A dynamic variable can be made unbound by using ÿmakunboundþ.

The effect of binding a dynamic variable is to create a new binding to
which all references to that dynamic variable in any program refer for
the duration of the evaluation of the form that creates the dynamic
binding.

A dynamic variable can be referenced outside the dynamic extent of a
form that binds it.  Such a variable is sometimes called a "global
variable" but is still in all respects just a dynamic variable whose
binding happens to exist in the global environment rather than in some
dynamic environment.

A dynamic variable is unbound unless and until explicitly assigned a
value, except for those variables whose initial value is defined in
this specification or by an implementation.

3.1.2.1.1.3 Constant Variables
..............................

Certain variables, called constant variables, are reserved as "named
constants."  The consequences are undefined if an attempt is made to
assign a value to, or create a binding for a constant variable, except
that a `compatible' redefinition of a constant variable using
ÿdefconstantþ is permitted; see the macro *Note defconstant::.

Keywords, symbols defined by Common Lisp or the implementation as
constant (such as ÿnilþ, ÿtþ, and ÿpiþ), and symbols declared as
constant using ÿdefconstantþ are constant variables.

3.1.2.1.1.4 Symbols Naming Both Lexical and Dynamic Variables
.............................................................

The same symbol can name both a lexical variable and a dynamic variable,
but never in the same lexical environment.

In the following example, the symbol ÿxþ is used, at different times,
as the name of a lexical variable and as the name of a dynamic variable.

 (let ((x 1))            ;Binds a special variable X
   (declare (special x))
   (let ((x 2))          ;Binds a lexical variable X
     (+ x                ;Reads a lexical variable X
        (locally (declare (special x))
                 x))))   ;Reads a special variable X
ý 3

3.1.2.1.2 Conses as Forms
.........................

A cons that is used as a form is called a compound form.

If the car of that compound form is a symbol, that symbol is the name
of an operator, and the form is either a special form, a macro form, or
a function form, depending on the function binding of the operator in
the current lexical environment.  If the operator is neither a special
operator nor a macro name, it is assumed to be a function name (even if
there is no definition for such a function).

If the car of the compound form is not a symbol, then that car must be
a lambda expression, in which case the compound form is a lambda form.

How a compound form is processed depends on whether it is classified as
a special form, a macro form, a function form, or a lambda form.

3.1.2.1.2.1 Special Forms
.........................

A special form is a form with special syntax, special evaluation rules,
or both, possibly manipulating the evaluation environment, control
flow, or both.  A special operator has access to the current lexical
environment and the current dynamic environment.  Each special operator
defines the manner in which its subexpressions are treated--which are
forms, which are special syntax, etc.

Some special operators create new lexical or dynamic environments for
use during the evaluation of subforms of the special form.  For
example, ÿblockþ creates a new lexical environment that is the same as
the one in force at the point of evaluation of the ÿblockþ form with
the addition of a binding of the ÿblockþ name to an exit point from the
ÿblockþ.

The set of special operator names is fixed in Common Lisp; no way is
provided for the user to define a special operator.  The next
figure lists all of the Common Lisp symbols that have definitions as
special operators.

block       let*                   return-from
catch       load-time-value        setq
eval-when   locally                symbol-macrolet
flet        macrolet               tagbody
function    multiple-value-call    the
go          multiple-value-prog1   throw
if          progn                  unwind-protect
labels      progv                  
let         quote                  

Figure 3.2: Common Lisp Special Operators

3.1.2.1.2.2 Macro Forms
.......................

If the operator names a macro, its associated macro function is applied
to the entire form and the result of that application is used in place
of the original form.

Specifically, a symbol names a macro in a given lexical environment if
ÿmacro-functionþ is true of the symbol and that environment.  The
function returned by ÿmacro-functionþ is a function of two arguments,
called the expansion function.  The expansion function is invoked by
calling the macroexpand hook with the expansion function as its first
argument, the entire macro form as its second argument, and an
environment object (corresponding to the current lexical environment)
as its third argument.  The macroexpand hook, in turn, calls the
expansion function with the form as its first argument and the
environment as its second argument.  The value of the expansion
function, which is passed through by the macroexpand hook, is a form.
The returned form is evaluated in place of the original form.

The consequences are undefined if a macro function destructively
modifies any part of its form argument.

A macro name is not a function designator, and cannot be used as the
FUNCTION argument to functions such as ÿapplyþ, ÿfuncallþ, or ÿmapþ.

An implementation is free to implement a Common Lisp special operator
as a macro.  An implementation is free to implement any macro operator
as a special operator, but only if an equivalent definition of the
macro is also provided.

The next figure lists some defined names that are applicable to macros.

*macroexpand-hook*   macro-function   macroexpand-1
defmacro             macroexpand      macrolet

Figure 3.3: Defined names applicable to macros

3.1.2.1.2.3 Function Forms
..........................

If the operator is a symbol naming a function, the form represents a
function form, and the cdr of the list contains the forms which when
evaluated will supply the arguments passed to the function.

When a function name is not defined, an error of type
ÿundefined-functionþ should be signaled at run time; see *Note Section
3.2.2.3 (Semantic Constraints): SemanticConstraints.

A function form is evaluated as follows:

The subforms in the cdr of the original form are evaluated in
left-to-right order in the current lexical and dynamic environments.
The primary value of each such evaluation becomes an argument to the
named function; any additional values returned by the subforms are
discarded.

The functional value of the operator is retrieved from the lexical
environment, and that function is invoked with the indicated arguments.

Although the order of evaluation of the argument subforms themselves is
strictly left-to-right, it is not specified whether the definition of
the operator in a function form is looked up before the evaluation of
the argument subforms, after the evaluation of the argument subforms,
or between the evaluation of any two argument subforms if there is more
than one such argument subform.  For example, the following might
return 23 or 24.

 (defun foo (x) (+ x 3))
 (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))
 (foo (progn (bar) 20))

A binding for a function name can be established in one of several
ways.  A binding for a function name in the global environment can be
established by ÿdefunþ, ÿsetfþ of ÿfdefinitionþ, ÿsetfþ of
ÿsymbol-functionþ, ÿensure-generic-functionþ, ÿdefmethodþ (implicitly,
due to ÿensure-generic-functionþ), or ÿdefgenericþ.  A binding for a
function name in the lexical environment can be established by ÿfletþ
or ÿlabelsþ.

The next figure lists some defined names that are applicable to
functions.

apply                  fdefinition   mapcan
call-arguments-limit   flet          mapcar
complement             fmakunbound   mapcon
constantly             funcall       mapl
defgeneric             function      maplist
defmethod              functionp     multiple-value-call
defun                  labels        reduce
fboundp                map           symbol-function

Figure 3.4: Some function-related defined names

3.1.2.1.2.4 Lambda Forms
........................

A lambda form is similar to a function form, except that the function
name is replaced by a lambda expression.

A lambda form is equivalent to using funcall of a lexical closure of
the lambda expression on the given arguments.  (In practice, some
compilers are more likely to produce inline code for a lambda form than
for an arbitrary named function that has been declared ÿinlineþ;
however, such a difference is not semantic.)

For further information, see *Note Section 3.1.3 (Lambda Expressions):
Lambda Expressions.

3.1.2.1.3 Self-Evaluating Objects
.................................

A form that is neither a symbol nor a cons is defined to be a
self-evaluating object.  Evaluating such an object yields the same
object as a result.

Certain specific symbols and conses might also happen to be
"self-evaluating" but only as a special case of a more general set of
rules for the evaluation of symbols and conses; such objects are not
considered to be self-evaluating objects.

The consequences are undefined if literal objects (including
self-evaluating objects) are destructively modified.

3.1.2.1.3.1 Examples of Self-Evaluating Objects
...............................................

Numbers, pathnames, and arrays are examples of self-evaluating objects.

 3 ý 3
 #c(2/3 5/8) ý #C(2/3 5/8)
 #p"S:[BILL]OTHELLO.TXT" ý #P"S:[BILL]OTHELLO.TXT"
 #(a b c) ý #(A B C)
 "fred smith" ý "fred smith"


File: chris-ansicl.info,  Node: Lambda Expressions,  Next: Closures and Lexical Binding,  Prev: The Evaluation Model,  Up: Evaluation

3.1.3 Lambda Expressions
------------------------

In a lambda expression, the body is evaluated in a lexical environment
that is formed by adding the binding of each parameter in the lambda
list with the corresponding value from the arguments to the current
lexical environment.

For further discussion of how bindings are established based on the
lambda list, see *Note Section 3.4 (Lambda Lists): Lambda Lists.

The body of a lambda expression is an implicit progn; the values it
returns are returned by the lambda expression.


File: chris-ansicl.info,  Node: Closures and Lexical Binding,  Next: Shadowing,  Prev: Lambda Expressions,  Up: Evaluation

3.1.4 Closures and Lexical Binding
----------------------------------

A lexical closure is a function that can refer to and alter the values
of lexical bindings established by binding forms that textually include
the function definition.

Consider this code, where ÿxþ is not declared ÿspecialþ:

 (defun two-funs (x)
   (list (function (lambda () x))
         (function (lambda (y) (setq x y)))))
 (setq funs (two-funs 6))
 (funcall (car funs)) ý 6
 (funcall (cadr funs) 43) ý 43
 (funcall (car funs)) ý 43

The ÿfunctionþ special form coerces a lambda expression into a closure
in which the lexical environment in effect when the special form is
evaluated is captured along with the lambda expression.

The function ÿtwo-funsþ returns a list of two functions, each of which
refers to the binding of the variable ÿxþ created on entry to the
function ÿtwo-funsþ when it was called.  This variable has the value ÿ6þ
initially, but ÿsetqþ can alter this binding.  The lexical closure
created for the first lambda expression does not "snapshot" the value
ÿ6þ for ÿxþ when the closure is created; rather it captures the binding
of ÿxþ.  The second function can be used to alter the value in the same
(captured) binding (to ÿ43þ, in the example), and this altered variable
binding then affects the value returned by the first function.

In situations where a closure of a lambda expression over the same set
of bindings may be produced more than once, the various resulting
closures may or may not be identical, at the discretion of the
implementation.  That is, two functions that are behaviorally
indistinguishable might or might not be identical.  Two functions that
are behaviorally distinguishable are distinct.  For example:

 (let ((x 5) (funs '()))
   (dotimes (j 10)
     (push #'(lambda (z)
               (if (null z) (setq x 0) (+ x z)))
           funs))
   funs)

The result of the above form is a list of ten closures.  Each requires
only the binding of ÿxþ.  It is the same binding in each case, but the
ten closure objects might or might not be identical.  On the other
hand, the result of the form

 (let ((funs '()))
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z)
                        (if (null z) (setq x 0) (+ x z))))
             funs)))
  funs)

is also a list of ten closures.  However, in this case no two of the
closure objects can be identical because each closure is closed over a
distinct binding of ÿxþ, and these bindings can be behaviorally
distinguished because of the use of ÿsetqþ.

The result of the form

 (let ((funs '()))
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z) (+ x z)))
            funs)))
   funs)

is a list of ten closure objects that might or might not be identical.
A different binding of ÿxþ is involved for each closure, but the
bindings cannot be distinguished because their values are the same and
immutable (there being no occurrence of ÿsetqþ on ÿxþ).  A compiler
could internally transform the form to

 (let ((funs '()))
   (dotimes (j 10)
     (push (function (lambda (z) (+ 5 z)))
           funs))
  funs)

where the closures may be identical.

It is possible that a closure does not close over any variable bindings.
In the code fragment

 (mapcar (function (lambda (x) (+ x 2))) y)

the function ÿ(lambda (x) (+ x 2))þ contains no references to any
outside object. In this case, the same closure might be returned for
all evaluations of the ÿfunctionþ form.


File: chris-ansicl.info,  Node: Shadowing,  Next: Extent,  Prev: Closures and Lexical Binding,  Up: Evaluation

3.1.5 Shadowing
---------------

If two forms that establish lexical bindings with the same name N are
textually nested, then references to N within the inner form refer to
the binding established by the inner form; the inner binding for N "shadows"
the outer binding for N.  Outside the inner form but inside the outer
one, references to N refer to the binding established by the outer
form.  For example:

 (defun test (x z)
   (let ((z (* x 2)))
     (print z))
   z)

The binding of the variable ÿzþ by ÿletþ shadows the parameter binding
for the function ÿtestþ.  The reference to the variable ÿzþ in the
ÿprintþ form refers to the ÿletþ binding.  The reference to ÿzþ at the
end of the function ÿtestþ refers to the parameter named ÿzþ.

Constructs that are lexically scoped act as if new names were generated
for each object on each execution.  Therefore, dynamic shadowing cannot
occur.  For example:

 (defun contorted-example (f g x)
   (if (= x 0)
       (funcall f)
       (block here
          (+ 5 (contorted-example g
                                  #'(lambda () (return-from here 4))
                                  (- x 1))))))

Consider the call ÿ(contorted-example nil nil 2)þ.  This produces ÿ4þ.
During the course of execution, there are three calls to
ÿcontorted-exampleþ, interleaved with two blocks:

 (contorted-example nil nil 2)
   (block hereá ...)
     (contorted-example nil #'(lambda () (return-from hereá 4)) 1)
       (block hereà ...)
         (contorted-example #'(lambda () (return-from hereá 4))
                            #'(lambda () (return-from hereà 4))
                            0)
             (funcall f)
                    where f ý #'(lambda () (return-from hereá 4))
                 (return-from hereá 4)

At the time the ÿfuncallþ is executed there are two ÿblockþ exit points
outstanding, each apparently named ÿhereþ.  The ÿreturn-fromþ form
executed as a result of the ÿfuncallþ operation refers to the outer
outstanding exit point (hereá), not the inner one (hereà).  It refers
to that exit point textually visible at the point of execution of
ÿfunctionþ (here abbreviated by the ÿ#'þ syntax) that resulted in
creation of the function object actually invoked by ÿfuncallþ.

If, in this example, one were to change the ÿ(funcall f)þ to ÿ(funcall
g)þ, then the value of the call ÿ(contorted-example nil nil 2)þ would
be ÿ9þ.  The value would change because ÿfuncallþ would cause the
execution of ÿ(return-from hereà 4)þ, thereby causing a return from the
inner exit point (hereà).  When that occurs, the value ÿ4þ is returned
from the middle invocation of ÿcontorted-exampleþ, ÿ5þ is added to that
to get ÿ9þ, and that value is returned from the outer block and the
outermost call to ÿcontorted-exampleþ.  The point is that the choice of
exit point returned from has nothing to do with its being innermost or
outermost; rather, it depends on the lexical environment that is
packaged up with a lambda expression when ÿfunctionþ is executed.


File: chris-ansicl.info,  Node: Extent,  Next: Return Values,  Prev: Shadowing,  Up: Evaluation

3.1.6 Extent
------------

ÿContorted-exampleþ works only because the function named by ÿfþ is
invoked during the extent of the exit point.  Once the flow of
execution has left the block, the exit point is disestablished.  For
example:

 (defun invalid-example ()
   (let ((y (block here #'(lambda (z) (return-from here z)))))
     (if (numberp y) y (funcall y 5))))

One might expect the call ÿ(invalid-example)þ to produce ÿ5þ by the
following incorrect reasoning: ÿletþ binds ÿyþ to the value of ÿblockþ;
this value is a function resulting from the lambda expression.  Because
ÿyþ is not a number, it is invoked on the value ÿ5þ.  The ÿreturn-fromþ
should then return this value from the exit point named ÿhereþ, thereby
exiting from the block again and giving ÿyþ the value ÿ5þ which, being
a number, is then returned as the value of the call to
ÿinvalid-exampleþ.

The argument fails only because exit points have dynamic extent.  The
argument is correct up to the execution of ÿreturn-fromþ.  The
execution of ÿreturn-fromþ should signal an error of type
ÿcontrol-errorþ, however, not because it cannot refer to the exit
point, but because it does correctly refer to an exit point and that
exit point has been disestablished.

A reference by name to a dynamic exit point binding such as a catch tag
refers to the most recently established binding of that name that has
not been disestablished.  For example:

 (defun fun1 (x)
   (catch 'trap (+ 3 (fun2 x))))
 (defun fun2 (y)
   (catch 'trap (* 5 (fun3 y))))
 (defun fun3 (z)
   (throw 'trap z))

Consider the call ÿ(fun1 7)þ.  The result is ÿ10þ.  At the time the
ÿthrowþ is executed, there are two outstanding catchers with the name
ÿtrapþ: one established within procedure ÿfun1þ, and the other within
procedure ÿfun2þ.  The latter is the more recent, and so the value ÿ7þ
is returned from ÿcatchþ in ÿfun2þ.  Viewed from within ÿfun3þ, the
ÿcatchþ in ÿfun2þ shadows the one in ÿfun1þ.  Had ÿfun2þ been defined as

 (defun fun2 (y)
   (catch 'snare (* 5 (fun3 y))))

then the two exit points would have different names, and therefore the
one in ÿfun1þ would not be shadowed.  The result would then have been
ÿ7þ.


File: chris-ansicl.info,  Node: Return Values,  Prev: Extent,  Up: Evaluation

3.1.7 Return Values
-------------------

Ordinarily the result of calling a function is a single object.
Sometimes, however, it is convenient for a function to compute several
objects and return them.

In order to receive other than exactly one value from a form, one of
several special forms or macros must be used to request those values.
If a form produces multiple values which were not requested in this
way, then the first value is given to the caller and all others are
discarded; if the form produces zero values, then the caller receives
ÿnilþ as a value.

The next figure lists some operators for receiving multiple valuesà.
These operators can be used to specify one or more forms to evaluate
and where to put the values returned by those forms.

multiple-value-bind   multiple-value-prog1   return-from
multiple-value-call   multiple-value-setq    throw
multiple-value-list   return                 

Figure 3.5: Some operators applicable to receiving multiple values

The function ÿvaluesþ can produce multiple valuesà.  ÿ(values)þ returns
zero values; ÿ(values FORM)þ returns the primary value returned by FORM;
ÿ(values FORM1 FORM2)þ returns two values, the primary value of FORM1
and the primary value of FORM2; and so on.

See ÿmultiple-values-limitþ and ÿvalues-listþ.


File: chris-ansicl.info,  Node: Compilation,  Next: Declarations,  Prev: Evaluation,  Up: Evaluation and Compilation

3.2 Compilation
===============

* Menu:

* Compiler Terminology::
* Compilation Semantics::
* File Compilation::
* Literal Objects in Compiled Files::
* Exceptional Situations in the Compiler::


File: chris-ansicl.info,  Node: Compiler Terminology,  Next: Compilation Semantics,  Up: Compilation

3.2.1 Compiler Terminology
--------------------------

The following terminology is used in this section.

The "compiler" is a utility that translates code into an
implementation-dependent form that might be represented or executed
efficiently.  The term "compiler" refers to both of the functions
ÿcompileþ and ÿcompile-fileþ.

The term "compiled code" refers to objects representing compiled
programs, such as objects constructed by ÿcompileþ or by ÿloadþ when
loading a compiled file.

The term "implicit compilation" refers to compilation performed during
evaluation.

The term "literal object" refers to a quoted object or a
self-evaluating object or an object that is a substructure of such an
object.  A constant variable is not itself a literal object.

The term "coalesce" is defined as follows.  Suppose ÿAþ and ÿBþ are two
literal constants in the source code, and that ÿA'þ and ÿB'þ are the
corresponding objects in the compiled code.  If ÿA'þ and ÿB'þ are ÿeqlþ
but ÿAþ and ÿBþ are not ÿeqlþ, then it is said that ÿAþ and ÿBþ have
been coalesced by the compiler.

The term "minimal compilation" refers to actions the compiler must take
at compile time. These actions are specified in *Note Section 3.2.2
(Compilation Semantics): Compilation Semantics.

The verb "process" refers to performing minimal compilation,
determining the time of evaluation for a form, and possibly evaluating
that form (if required).

The term "further compilation" refers to implementation-dependent
compilation beyond minimal compilation.  That is, processing does not
imply complete compilation.  Block compilation and generation of
machine-specific instructions are examples of further compilation.
Further compilation is permitted to take place at run time.

Four different environments relevant to compilation are distinguished:
the startup environment, the compilation environment, the evaluation
environment, and the run-time environment.

The "startup environment" is the environment of the Lisp image from
which the compiler was invoked.

The "compilation environment" is maintained by the compiler and is used
to hold definitions and declarations to be used internally by the
compiler.  Only those parts of a definition needed for correct
compilation are saved. The compilation environment is used as the
environment argument to macro expanders called by the compiler. It is
unspecified whether a definition available in the compilation
environment can be used in an evaluation initiated in the startup
environment or evaluation environment.

The "evaluation environment" is a run-time environment in which macro
expanders and code specified by ÿeval-whenþ to be evaluated are
evaluated.  All evaluations initiated by the compiler take place in the
evaluation environment.

The "run-time environment" is the environment in which the program
being compiled will be executed.

The compilation environment inherits from the evaluation environment,
and the compilation environment and evaluation environment might be
identical.  The evaluation environment inherits from the startup
environment, and the startup environment and evaluation environment
might be identical.

The term "compile time" refers to the duration of time that the
compiler is processing source code.  At compile time, only the
compilation environment and  the evaluation environment are available.

The term "compile-time definition" refers to a definition in the
compilation environment.  For example, when compiling a file, the
definition of a function might be retained in the compilation
environment if it is declared ÿinlineþ.  This definition might not be
available in the evaluation environment.

The term "run time" refers to the duration of time that the loader is
loading compiled code or compiled code is being executed.  At run time,
only the run-time environment is available.

The term "run-time definition" refers to a definition in the run-time
environment.

The term "run-time compiler" refers to the function ÿcompileþ or
implicit compilation, for which the compilation and run-time
environments are maintained in the same Lisp image.  Note that when the
run-time compiler is used, the run-time environment and startup
environment are the same.


File: chris-ansicl.info,  Node: Compilation Semantics,  Next: File Compilation,  Prev: Compiler Terminology,  Up: Compilation

3.2.2 Compilation Semantics
---------------------------

Conceptually, compilation is a process that traverses code, performs
certain kinds of syntactic and semantic analyses using information
(such as proclamations and macro definitions) present in the
compilation environment, and produces equivalent, possibly more
efficient code.

3.2.2.1 Compiler Macros
.......................

A compiler macro can be defined for a name that also names a function
or macro.  That is, it is possible for a function name to name both a
function and a compiler macro.

A function name names a compiler macro if ÿcompiler-macro-functionþ is
true of the function name in the lexical environment in which it
appears.  Creating a lexical binding for the function name not only
creates a new local function or macro definition, but also shadowsà the
compiler macro.

The function returned by ÿcompiler-macro-functionþ is a function of two
arguments, called the expansion function.  To expand a compiler macro,
the expansion function is invoked by calling the macroexpand hook with
the expansion function as its first argument, the entire compiler macro
form as its second argument, and the current compilation environment
(or with the current lexical environment, if the form is being
processed by something other than ÿcompile-fileþ) as its third argument.
The macroexpand hook, in turn, calls the expansion function with the
form as its first argument and the environment as its second argument.
The return value from the expansion function, which is passed through
by the macroexpand hook, might either be the same form, or else a form
that can, at the discretion of the code doing the expansion, be used in
place of the original form.

*macroexpand-hook*   compiler-macro-function   define-compiler-macro

Figure 3.6: Defined names applicable to compiler macros

3.2.2.1.1 Purpose of Compiler Macros
....................................

The purpose of the compiler macro facility is to permit selective
source code transformations as optimization advice to the compiler.
When a compound form is being processed (as by the compiler), if the
operator names a compiler macro then the compiler macro function may be
invoked on the form, and the resulting expansion recursively processed
in preference to performing the usual processing on the original form
according to its normal interpretation as a function form or macro form.

A compiler macro function, like a macro function, is a function of two
arguments: the entire call form and the environment. Unlike an ordinary
macro function, a compiler macro function can decline to provide an
expansion merely by returning a value that is the same as the original
form.  The consequences are undefined if a compiler macro function
destructively modifies any part of its form argument.

The form passed to the compiler macro function can either be a list
whose car is the function name, or a list whose car is ÿfuncallþ and
whose cadr is a list ÿ(function NAME)þ; note that this affects
destructuring of the form argument by the compiler macro function.
ÿdefine-compiler-macroþ arranges for destructuring of arguments to be
performed correctly for both possible formats.

When ÿcompile-fileþ chooses to expand a top level form that is a
compiler macro form, the expansion is also treated as a top level form
for the purposes of ÿeval-whenþ processing; see *Note Section 3.2.3.1
(Processing of Top Level Forms): TopLevelForms.

3.2.2.1.2 Naming of Compiler Macros
...................................

Compiler macros may be defined for function names that name macros as
well as functions.

Compiler macro definitions are strictly global.  There is no provision
for defining local compiler macros in the way that ÿmacroletþ defines
local macros.  Lexical bindings of a function name shadow any compiler
macro definition associated with the name as well as its global
function or macro definition.

Note that the presence of a compiler macro definition does not affect
the values returned by functions that access function definitions
(e.g., ÿfboundpþ) or macro definitions (e.g., ÿmacroexpandþ).  Compiler
macros are global, and the function ÿcompiler-macro-functionþ is
sufficient to resolve their interaction with other lexical and global
definitions.

3.2.2.1.3 When Compiler Macros Are Used
.......................................

The presence of a compiler macro definition for a function or macro
indicates that it is desirable for the compiler to use the expansion of
the compiler macro instead of the original function form or macro form.
However, no language processor (compiler, evaluator, or other code
walker) is ever required to actually invoke compiler macro functions,
or to make use of the resulting expansion if it does invoke a compiler
macro function.

When the compiler encounters a form during processing that represents a
call to a compiler macro name (that is not declared ÿnotinlineþ), the
compiler might expand the compiler macro, and might use the expansion
in place of the original form.

When ÿevalþ encounters a form during processing that represents a call
to a compiler macro name (that is not declared ÿnotinlineþ), ÿevalþ
might expand the compiler macro, and might use the expansion in place
of the original form.

There are two situations in which a compiler macro definition must not
be applied by any language processor:

   * The global function name binding associated with the compiler
     macro is shadowed by a lexical binding of the function name.

   * The function name has been declared or proclaimed ÿnotinlineþ and
     the call form appears within the scope of the declaration.

It is unspecified whether compiler macros are expanded or used in any
other situations.

3.2.2.1.3.1 Notes about the Implementation of Compiler Macros
.............................................................

Although it is technically permissible, as described above, for ÿevalþ
to treat compiler macros in the same situations as compiler might, this
is not necessarily a good idea in interpreted implementations.

Compiler macros exist for the purpose of trading compile-time speed for
run-time speed.  Programmers who write compiler macros tend to assume
that the compiler macros can take more time than normal functions and
macros in order to produce code which is especially optimal for use at
run time.  Since ÿevalþ in an interpreted implementation might perform
semantic analysis of the same form multiple times, it might be
inefficient in general for the implementation to choose to call
compiler macros on every such evaluation.

Nevertheless, the decision about what to do in these situations is left
to each implementation.

3.2.2.2 Minimal Compilation
...........................

Minimal compilation is defined as follows:

   * All compiler macro calls appearing in the source code being
     compiled are expanded, if at all, at compile time; they will not
     be expanded at run time.

   * All macro and symbol macro calls appearing in the source code
     being compiled are expanded at compile time in such a way that
     they will not be expanded again at run time.  ÿmacroletþ and
     ÿsymbol-macroletþ are effectively replaced by forms corresponding
     to their bodies in which calls to macros are replaced by their
     expansions.

   * The first argument in a ÿload-time-valueþ form in source code
     processed by ÿcompileþ is evaluated at compile time; in source
     code processed by ÿcompile-fileþ , the compiler arranges for it to
     be evaluated at load time.  In either case, the result of the
     evaluation is remembered and used later as the value of the
     ÿload-time-valueþ form at execution time.

3.2.2.3 Semantic Constraints
............................

All conforming programs must obey the following constraints, which are
designed to minimize the observable differences between compiled and
interpreted programs:

   * Definitions of any referenced macros must be present in the
     compilation environment.  Any form that is a list beginning with a
     symbol that does not name a special operator or a macro defined in
     the compilation environment is treated by the compiler as a
     function call.

   * ÿSpecialþ proclamations for dynamic variables must be made in the
     compilation environment.  Any binding for which there is no
     ÿspecialþ declaration or proclamation in the compilation
     environment is treated by the compiler as a lexical binding.

   * The definition of a function that is defined and declared ÿinlineþ
     in the compilation environment must be the same at run time.

   * Within a function named F, the compiler may (but is not required
     to) assume that an apparent recursive call to a function named F
     refers to the same definition of F, unless that function has been
     declared ÿnotinlineþ.  The consequences of redefining such a
     recursively defined function F while it is executing are undefined.

   * A call within a file to a named function that is defined in the
     same file refers to that function, unless that function has been
     declared ÿnotinlineþ.  The consequences are unspecified if
     functions are redefined individually at run time or multiply
     defined in the same file.

   * The argument syntax and number of return values for all functions
     whose ÿftypeþ is declared at compile time must remain the same at
     run time.

   * Constant variables defined in the compilation environment must
     have a similar value at run time.  A reference to a constant
     variable in source code is equivalent to a reference to a literal
     object that is the value of the constant variable.

   * Type definitions made with ÿdeftypeþ or ÿdefstructþ in the
     compilation environment must retain the same definition at run
     time.  Classes defined by ÿdefclassþ in the compilation
     environment must be defined at run time to have the same
     superclasses and same metaclass.

     This implies that subtype/supertype relationships of type
     specifiers must not change between compile time and run time.

   * Type declarations present in the compilation environment must
     accurately describe the corresponding values at run time;
     otherwise, the consequences are undefined.  It is permissible for
     an unknown type to appear in a declaration at compile time, though
     a warning might be signaled in such a case.

   * Except in the situations explicitly listed above, a function
     defined in the evaluation environment is permitted to have a
     different definition or a different signature at run time, and the
     run-time definition prevails.

Conforming programs should not be written using any additional
assumptions about consistency between the run-time environment and the
startup, evaluation, and compilation environments.

Except where noted, when a compile-time and a run-time definition are
different, one of the following occurs at run time:

   * an error of type ÿerrorþ is signaled

   * the compile-time definition prevails

   * the run-time definition prevails

If the compiler processes a function form whose operator is not defined
at compile time, no error is signaled at compile time.


File: chris-ansicl.info,  Node: File Compilation,  Next: Literal Objects in Compiled Files,  Prev: Compilation Semantics,  Up: Compilation

3.2.3 File Compilation
----------------------

The function ÿcompile-fileþ performs compilation of forms in a file
following the rules specified in *Note Section 3.2.2 (Compilation
Semantics): Compilation Semantics, and produces an output file that can
be loaded by using ÿloadþ.

Normally, the top level forms appearing in a file compiled with
ÿcompile-fileþ are evaluated only when the resulting compiled file is
loaded, and not when the file is compiled.  However, it is typically
the case that some forms in the file need to be evaluated at compile
time so the remainder of the file can be read and compiled correctly.

The ÿeval-whenþ special form can be used to control whether a top level
form is evaluated at compile time, load time, or both.  It is possible
to specify any of three situations with ÿeval-whenþ, denoted by the
symbols :compile-toplevel, :load-toplevel, and :execute.  For top level
ÿeval-whenþ forms, :compile-toplevel specifies that the compiler must
evaluate the body at compile time, and ÿ:load-toplevelþ specifies that
the compiler must arrange to evaluate the body at load time. For
non-top level ÿeval-whenþ forms, :execute specifies that the body must
be executed in the run-time environment.

The behavior of this form can be more precisely understood in terms of
a model of how ÿcompile-fileþ processes forms in a file to be compiled.
There are two processing modes, called "not-compile-time" and
"compile-time-too".

Successive forms are read from the file by ÿcompile-fileþ and processed
in not-compile-time mode; in this mode, ÿcompile-fileþ arranges for
forms to be evaluated only at load time and not at compile time.  When
ÿcompile-fileþ is in compile-time-too mode, forms are evaluated both at
compile time and load time.

3.2.3.1 Processing of Top Level Forms
.....................................

Processing of top level forms in the file compiler is defined as
follows:

  1. If the form is a compiler macro form (not disabled by a
     ÿnotinlineþ declaration), the implementation might or might not
     choose to compute the compiler macro expansion of the form and,
     having performed the expansion, might or might not choose to
     process the result as a top level form in the same processing mode
     (compile-time-too or not-compile-time).  If it declines to obtain
     or use the expansion, it must process the original form.

  2. If the form is a macro form, its macro expansion is computed and
     processed as a top level form in the same processing mode
     (compile-time-too or not-compile-time).

  3. If the form is a ÿprognþ form, each of its body forms is
     sequentially processed as a top level form in the same processing
     mode.

  4. If the form is a ÿlocallyþ, ÿmacroletþ, or ÿsymbol-macroletþ,
     ÿcompile-fileþ establishes the appropriate bindings and processes
     the body forms as top level forms with those bindings in effect in
     the same processing mode.  (Note that this implies that the lexical
     environment in which top level forms are processed is not
     necessarily the null lexical environment.)

  5. If the form is an ÿeval-whenþ form, it is handled according to the
     next figure.

     CT   LT   E    Mode   Action   New Mode
     -------------------------------------------------- 
     Yes  Yes  --   --     Process  compile-time-too
     No   Yes  Yes   CTT   Process  compile-time-too
     No   Yes  Yes   NCT   Process  not-compile-time
     No   Yes  No   --     Process  not-compile-time
     Yes  No   --   --     Evaluate --
     No   No   Yes   CTT   Evaluate --
     No   No   Yes   NCT   Discard  --
     No   No   No   --     Discard  --

     Figure 3.7: EVAL-WHEN processing

     Column CT   indicates whether :compile-toplevel is specified.
     Column LT   indicates whether :load-toplevel is specified.  Column
     E    indicates whether :execute is specified.  Column Mode
     indicates the processing mode; a dash (--) indicates that the
     processing mode is not relevant.

     The Action column specifies one of three actions:


          Process: process the body as top level forms in the specified
          mode.


          Evaluate: evaluate the body in the dynamic execution context
          of the compiler, using the evaluation environment as the
          global environment and the lexical environment in which the
          ÿeval-whenþ appears.


          Discard: ignore the form.

     The New Mode column indicates the new processing mode.  A dash
     (--) indicates the compiler remains in its current mode.

  6. Otherwise, the form is a top level form that is not one of the
     special cases.  In compile-time-too mode, the compiler first
     evaluates the form in the evaluation environment and then
     minimally compiles it.  In not-compile-time mode, the form is
     simply minimally compiled.  All subforms are treated as
     non-top-level forms.

     Note that top level forms are processed in the order in which they
     textually appear in the file and that each top level form read by
     the compiler is processed before the next is read.  However, the
     order of processing (including macro expansion) of subforms that
     are not top level forms and the order of further compilation is
     unspecified as long as Common Lisp semantics are preserved.

ÿeval-whenþ forms cause compile-time evaluation only at top level.
Both :compile-toplevel and :load-toplevel situation specifications are
ignored for non-top-level forms. For non-top-level forms, an ÿeval-whenþ
specifying the :execute situation is treated as an implicit progn
including the forms in the body of the ÿeval-whenþ form; otherwise, the
forms in the body are ignored.

3.2.3.1.1 Processing of Defining Macros
.......................................

Defining macros (such as ÿdefmacroþ or ÿdefvarþ) appearing within a
file being processed by ÿcompile-fileþ normally have compile-time side
effects which affect how subsequent forms in the same file are
compiled.  A convenient model for explaining how these side effects
happen is that the defining macro expands into one or more ÿeval-whenþ
forms, and that the calls which cause the compile-time side effects to
happen appear in the body of an ÿ(eval-when (:compile-toplevel) ...)þ
form.

The compile-time side effects may cause information about the
definition to be stored differently than if the defining macro had been
processed in the `normal' way (either interpretively or by loading the
compiled file).

In particular, the information stored by the defining macros at compile
time might or might not be available to the interpreter (either during
or after compilation), or during subsequent calls to the compiler.  For
example, the following code is nonportable because it assumes that the
compiler stores the macro definition of ÿfooþ where it is available to
the interpreter:

 (defmacro foo (x) `(car ,x))
 (eval-when (:execute :compile-toplevel :load-toplevel)
   (print (foo '(a b c))))

A portable way to do the same thing would be to include the macro
definition inside the ÿeval-whenþ form, as in:

 (eval-when (:execute :compile-toplevel :load-toplevel)
   (defmacro foo (x) `(car ,x))
   (print (foo '(a b c))))

The next figure lists macros that make definitions available both in
the compilation and run-time environments.  It is not specified whether
definitions made available in the compilation environment are available
in the evaluation environment, nor is it specified whether they are
available in subsequent compilation units or subsequent invocations of
the compiler.  As with ÿeval-whenþ, these compile-time side effects
happen only when the defining macros appear at top level.

declaim                 define-modify-macro    defsetf
defclass                define-setf-expander   defstruct
defconstant             defmacro               deftype
define-compiler-macro   defpackage             defvar
define-condition        defparameter           

Figure 3.8: Defining Macros That Affect the Compile-Time Environment

3.2.3.1.2 Constraints on Macros and Compiler Macros
...................................................

Except where explicitly stated otherwise, no macro defined in the
Common Lisp standard produces an expansion that could cause any of the
subforms of the macro form to be treated as top level forms.  If an
implementation also provides a special operator definition of a Common
Lisp macro, the special operator definition must be semantically
equivalent in this respect.

Compiler macro expansions must also have the same top level evaluation
semantics as the form which they replace.  This is of concern both to
conforming implementations and to conforming programs.


File: chris-ansicl.info,  Node: Literal Objects in Compiled Files,  Next: Exceptional Situations in the Compiler,  Prev: File Compilation,  Up: Compilation

3.2.4 Literal Objects in Compiled Files
---------------------------------------

The functions ÿevalþ and ÿcompileþ are required to ensure that literal
objects referenced within the resulting interpreted or compiled code
objects are the same as the corresponding objects in the source code.
ÿcompile-fileþ, on the other hand, must produce a compiled file that,
when loaded with ÿloadþ, constructs the objects defined by the source
code and produces references to them.

In the case of ÿcompile-fileþ, objects constructed by ÿloadþ of the
compiled file cannot be spoken of as being the same as the objects
constructed at compile time, because the compiled file may be loaded
into a different Lisp image than the one in which it was compiled.
This section defines the concept of similarity which relates objects in
the evaluation environment to the corresponding objects in the run-time
environment.

The constraints on literal objects described in this section apply only
to ÿcompile-fileþ; ÿevalþ and ÿcompileþ do not copy or coalesce
constants.

3.2.4.1 Externalizable Objects
..............................

The fact that the file compiler represents literal objects externally
in a compiled file and must later reconstruct suitable equivalents of
those objects when that file is loaded imposes a need for constraints
on the nature of the objects that can be used as literal objects in
code to be processed by the file compiler.

An object that can be used as a literal object in code to be processed
by the file compiler is called an "externalizable object".

We define that two objects are "similar" if they satisfy a two-place
conceptual equivalence predicate (defined below), which is independent
of the Lisp image so that the two objects in different Lisp images can
be understood to be equivalent under this predicate.  Further, by
inspecting the definition of this conceptual predicate, the programmer
can anticipate what aspects of an object are reliably preserved by file
compilation.

The file compiler must cooperate with the loader in order to assure
that in each case where an externalizable object is processed as a
literal object, the loader will construct a similar object.

The set of objects that are "externalizable objects" are those for
which the new conceptual term "similar" is defined, such that when a
compiled file is loaded, an object can be constructed which can be
shown to be similar to the original object which existed at the time
the file compiler was operating.

3.2.4.2 Similarity of Literal Objects
.....................................

3.2.4.2.1 Similarity of Aggregate Objects
.........................................

Of the types over which similarity is defined, some are treated as
aggregate objects.  For these types, similarity is defined recursively.
We say that an object of these types has certain "basic qualities" and
to satisfy the similarity relationship, the values of the corresponding
qualities of the two objects must also be similar.

3.2.4.2.2 Definition of Similarity
..................................

Two objects S (in source code) and C (in compiled code) are defined to
be similar if and only if they are both of one of the types listed here
(or defined by the implementation) and they both satisfy all additional
requirements of similarity indicated for that type.

ÿnumberþ
     Two numbers S and C are similar if they are of the same type and
     represent the same mathematical value.

ÿcharacterþ
     Two simple characters S and C are similar if they have similar
     code attributes.

     Implementations providing additional, implementation-defined
     attributes must define whether and how non-simple characters can
     be regarded as similar.

ÿsymbolþ
     Two apparently uninterned symbols S and C are similar if their
     names are similar.

     Two interned symbols S and C are similar if their names are
     similar, and if either S is accessible in the current package at
     compile time and C is accessible in the current package at load
     time, or C is accessible in the package that is similar to the
     home package of S.

     (Note that similarity of symbols is dependent on neither the
     current readtable nor how the function ÿreadþ would parse the
     characters in the name of the symbol.)

ÿpackageþ
     Two packages S and C are similar if their names are similar.

     Note that although a package object is an externalizable object,
     the programmer is responsible for ensuring that the corresponding
     package is already in existence when code referencing it as a
     literal object is loaded.  The loader finds the corresponding
     package object as if by calling ÿfind-packageþ with that name as
     an argument.  An error is signaled by the loader if no package
     exists at load time.

ÿrandom-stateþ
     Two random states S and C are similar if S would always produce
     the same sequence of pseudo-random numbers as a copyÝ of C when
     given as the RANDOM-STATE argument to the function ÿrandomþ,
     assuming equivalent LIMIT arguments in each case.

     (Note that since C has been processed by the file compiler, it
     cannot be used directly as an argument to ÿrandomþ because
     ÿrandomþ would perform a side effect.)

ÿconsþ
     Two conses, S and C, are similar if the carà of S is similar to
     the carà of C, and the cdrà of S is similar to the cdrà of C.

ÿarrayþ
     Two one-dimensional arrays, S and C, are similar if the length of
     S is similar to the length of C, the actual array element type of
     S is similar to the actual array element type of C, and each
     active element of S is similar to the corresponding element of C.

     Two arrays of rank other than one, S and C, are similar if the
     rank of S is similar to the rank of C, each dimensioná of S is
     similar to the corresponding dimensioná of C, the actual array
     element type of S is similar to the actual array element type of C,
     and each element of S is similar to the corresponding element of C.

     In addition, if S is a simple array, then C must also be a simple
     array.  If S is a displaced array, has a fill pointer, or is
     actually adjustable, C is permitted to lack any or all of these
     qualities.

ÿhash-tableþ
     Two hash tables S and C are similar if they meet the following
     three requirements:

       1. They both have the same test (e.g., they are both ÿeqlþ hash
          tables).

       2. There is a unique one-to-one correspondence between the keys
          of the two hash tables, such that the corresponding keys are
          similar.

       3. For all keys, the values associated with two corresponding
          keys are similar.

     If there is more than one possible one-to-one correspondence
     between the keys of S and C, the consequences are unspecified.  A
     conforming program cannot use a table such as S as an
     externalizable constant.

ÿpathnameþ
     Two pathnames S and C are similar if all corresponding pathname
     components are similar.

ÿfunctionþ
     Functions are not externalizable objects.

ÿstructure-objectþ and ÿstandard-objectþ
     A general-purpose concept of similarity does not exist for
     structures and standard objects.  However, a conforming program is
     permitted to define a ÿmake-load-formþ method for any class K
     defined by that program that is a subclass of either
     ÿstructure-objectþ or ÿstandard-objectþ.  The effect of such a
     method is to define that an object S of type K in source code is
     similar to an object C of type K in compiled code if C was
     constructed from code produced by calling ÿmake-load-formþ on S.

3.2.4.3 Extensions to Similarity Rules
......................................

Some objects, such as streams, ÿreadtablesþ, and ÿmethodsþ are not
externalizable objects under the definition of similarity given above.
That is, such objects may not portably appear as literal objects in
code to be processed by the file compiler.

An implementation is permitted to extend the rules of similarity, so
that other kinds of objects are externalizable objects for that
implementation.

If for some kind of object, similarity is neither defined by this
specification nor by the implementation, then the file compiler must
signal an error upon encountering such an object as a literal constant.

3.2.4.4 Additional Constraints on Externalizable Objects
........................................................

If two literal objects appearing in the source code for a single file
processed with the file compiler are the identical, the corresponding
objects in the compiled code must also be the identical.  With the
exception of symbols and packages, any two literal objects in code
being processed by the file compiler may be coalesced if and only if
they are similar; if they are either both symbols or both packages,
they may only be coalesced if and only if they are identical.

Objects containing circular references can be externalizable objects.
The file compiler is required to preserve ÿeqlþness of substructures
within a file.  Preserving ÿeqlþness means that subobjects that are the
same in the source code must be the same in the corresponding compiled
code.

In addition, the following are constraints on the handling of literal
objects by the file compiler:


     array: If an array in the source code is a simple array, then the
     corresponding array in the compiled code will also be a simple
     array.  If an array in the source code is displaced, has a fill
     pointer, or is actually adjustable, the corresponding array in the
     compiled code might lack any or all of these qualities. If an
     array in the source code has a fill pointer, then the
     corresponding array in the compiled code might be only the size
     implied by the fill pointer.


     packages: The loader is required to find the corresponding package
     object as if by calling ÿfind-packageþ with the package name as an
     argument.  An error of type ÿpackage-errorþ is signaled if no
     package of that name exists at load time.


     random-state: A constant random state object cannot be used as the
     state argument to the function ÿrandomþ because ÿrandomþ modifies
     this data structure.


     structure, standard-object: Objects of type ÿstructure-objectþ and
     ÿstandard-objectþ may appear in compiled constants if there is an
     appropriate ÿmake-load-formþ method defined for that type.

     The file compiler calls ÿmake-load-formþ on any object that is
     referenced as a literal object if the object is a generalized
     instance of ÿstandard-objectþ, ÿstructure-objectþ, ÿconditionþ, or
     any of a (possibly empty) implementation-dependent set of other
     classes.  The file compiler only calls ÿmake-load-formþ once for
     any given object within a single file.


     symbol: In order to guarantee that compiled files can be loaded
     correctly, users must ensure that the packages referenced in those
     files are defined consistently at compile time and load time.
     Conforming programs must satisfy the following requirements:

       1. The current package when a top level form in the file is
          processed by ÿcompile-fileþ must be the same as the current
          package when the code corresponding to that top level form in
          the compiled file is executed by ÿloadþ.  In particular:

            a. Any top level form in a file that alters the current
               package must change it to a package of the same name
               both at compile time and at load time.

            b. If the first non-atomic top level form in the file is
               not an ÿin-packageþ form, then the current package at
               the time ÿloadþ is called must be a package with the
               same name as the package that was the current package at
               the time ÿcompile-fileþ was called.

       2. For all symbols appearing lexically within a top level form
          that were accessible in the package that was the current
          package during processing of that top level form at compile
          time, but whose home package was another package, at load
          time there must be a symbol with the same name that is
          accessible in both the load-time current package and in the
          package with the same name as the compile-time home package.

       3. For all symbols represented in the compiled file that were
          external symbols in their home package at compile time, there
          must be a symbol with the same name that is an external
          symbol in the package with the same name at load time.

     If any of these conditions do not hold, the package in which the
     loader looks for the affected symbols is unspecified.
     Implementations are permitted to signal an error or to define this
     behavior.


File: chris-ansicl.info,  Node: Exceptional Situations in the Compiler,  Prev: Literal Objects in Compiled Files,  Up: Compilation

3.2.5 Exceptional Situations in the Compiler
--------------------------------------------

ÿcompileþ and ÿcompile-fileþ are permitted to signal errors and
warnings, including errors due to compile-time processing of
ÿ(eval-when (:compile-toplevel) ...)þ forms, macro expansion, and
conditions signaled by the compiler itself.

Conditions of type ÿerrorþ might be signaled by the compiler in
situations where the compilation cannot proceed without intervention.

In addition to situations for which the standard specifies that
conditions of type ÿwarningþ must or might be signaled, warnings might
be signaled in situations where the compiler can determine that the
consequences are undefined or that a run-time error will be signaled.
Examples of this situation are as follows: violating type declarations,
altering or assigning the value of a constant defined with
ÿdefconstantþ, calling built-in Lisp functions with a wrong number of
arguments or malformed keyword argument lists, and using unrecognized
declaration specifiers.

The compiler is permitted to issue warnings about matters of
programming style as conditions of type ÿstyle-warningþ.  Examples of
this situation are as follows: redefining a function using a different
argument list, calling a function with a wrong number of arguments, not
declaring ÿignoreþ of a local variable that is not referenced, and
referencing a variable declared ÿignoreþ.

Both ÿcompileþ and ÿcompile-fileþ are permitted (but not required) to
establish a handler for conditions of type ÿerrorþ.  For example, they
might signal a warning, and restart compilation from some
implementation-dependent point in order to let the compilation proceed
without manual intervention.

Both ÿcompileþ and ÿcompile-fileþ return three values, the second two
indicating whether the source code being compiled contained errors and
whether style warnings were issued.

Some warnings might be deferred until the end of compilation.  See
ÿwith-compilation-unitþ.


File: chris-ansicl.info,  Node: Declarations,  Next: Lambda Lists,  Prev: Compilation,  Up: Evaluation and Compilation

3.3 Declarations
================

"Declarations" provide a way of specifying information for use by
program processors, such as the evaluator or the compiler.

"Local declarations" can be embedded in executable code using declare.  "Global
declarations", or "proclamations", are established by ÿproclaimþ or
ÿdeclaimþ.

The ÿtheþ special form provides a shorthand notation for making a local
declaration about the type of the value of a given form.

The consequences are undefined if a program violates a declaration or a
proclamation.

* Menu:

* Minimal Declaration Processing Requirements::
* Declaration Specifiers::
* Declaration Identifiers::
* Declaration Scope::


File: chris-ansicl.info,  Node: Minimal Declaration Processing Requirements,  Next: Declaration Specifiers,  Up: Declarations

3.3.1 Minimal Declaration Processing Requirements
-------------------------------------------------

In general, an implementation is free to ignore declaration specifiers
except for the ÿdeclarationþ , ÿnotinlineþ , ÿsafetyþ , and ÿspecialþ declaration
specifiers.

A ÿdeclarationþ declaration must suppress warnings about unrecognized
declarations of the kind that it declares.  If an implementation does
not produce warnings about unrecognized declarations, it may safely
ignore this declaration.

A ÿnotinlineþ declaration must be recognized by any implementation that
supports inline functions or compiler macros in order to disable those
facilities.  An implementation that does not use inline functions or
compiler macros may safely ignore this declaration.

A ÿsafetyþ declaration that increases the current safety level must
always be recognized.  An implementation that always processes code as
if safety were high may safely ignore this declaration.

A ÿspecialþ declaration must be processed by all implementations.


File: chris-ansicl.info,  Node: Declaration Specifiers,  Next: Declaration Identifiers,  Prev: Minimal Declaration Processing Requirements,  Up: Declarations

3.3.2 Declaration Specifiers
----------------------------

A "declaration specifier" is an expression that can appear at top level
of a declare expression or a ÿdeclaimþ form, or as the argument to
ÿproclaimþ.  It is a list whose car is a declaration identifier, and
whose cdr is data interpreted according to rules specific to the
declaration identifier.


File: chris-ansicl.info,  Node: Declaration Identifiers,  Next: Declaration Scope,  Prev: Declaration Specifiers,  Up: Declarations

3.3.3 Declaration Identifiers
-----------------------------

The next figure shows a list of all declaration identifiers 

defined by this standard.

declaration      ignore      special
dynamic-extent   inline      type
ftype            notinline   
ignorable        optimize    

Figure 3.9: Common Lisp Declaration Identifiers

An implementation is free to support other (implementation-defined)
declaration identifiers as well.  A warning might be issued if a
declaration identifier is not among those defined above, is not defined
by the implementation, is not a type name, and has not been declared in
a ÿdeclarationþ proclamation.

3.3.3.1 Shorthand notation for Type Declarations
................................................

A type specifier can be used as a declaration identifier.
ÿ(TYPE-SPECIFIER {var}*)þ is taken as shorthand for ÿ(type
TYPE-SPECIFIER {var}*)þ.


File: chris-ansicl.info,  Node: Declaration Scope,  Prev: Declaration Identifiers,  Up: Declarations

3.3.4 Declaration Scope
-----------------------

Declarations can be divided into two kinds: those that apply to the
bindings of variables or functions; and those that do not apply to
bindings.

A declaration that appears at the head of a binding form and applies to
a variable or function binding made by that form is called a "bound
declaration"; such a declaration affects both the binding and any
references within the scope of the declaration.

Declarations that are not bound declarations are called "free
declarations".

A free declaration in a form F1 that applies to a binding for a name N
established by some form F2 of which F1 is a subform affects only
references to N within F1; it does not to apply to other references to
N outside of F1, nor does it affect the manner in which the binding of
N by F2 is established.

Declarations that do not apply to bindings can only appear as free
declarations.

The scope of a bound declaration is the same as the lexical scope of
the binding to which it applies; for special variables, this means the
scope that the binding would have had had it been a lexical binding.

Unless explicitly stated otherwise, the scope of a free declaration
includes only the body subforms of the form at whose head it appears,
and no other subforms.  The scope of free declarations specifically
does not include initialization forms for bindings established by the
form containing the declarations.

Some iteration forms include step, end-test, or result subforms that
are also included in the scope of declarations that appear in the
iteration form.  Specifically, the iteration forms and subforms involved
are:

   * ÿdoþ, ÿdo*þ: STEP-FORMS, END-TEST-FORM, and RESULT-FORMS.

   * ÿdolistþ, ÿdotimesþ: RESULT-FORM

   * ÿdo-all-symbolsþ, ÿdo-external-symbolsþ, ÿdo-symbolsþ: RESULT-FORM

3.3.4.1 Examples of Declaration Scope
.....................................

Here is an example illustrating the scope of bound declarations.

 (let ((x 1))                ;[1] 1st occurrence of x
   (declare (special x))     ;[2] 2nd occurrence of x
   (let ((x 2))              ;[3] 3rd occurrence of x
     (let ((old-x x)         ;[4] 4th occurrence of x
           (x 3))            ;[5] 5th occurrence of x
       (declare (special x)) ;[6] 6th occurrence of x
       (list old-x x))))     ;[7] 7th occurrence of x
ý (2 3)

The first occurrence of ÿxþ establishes a dynamic binding of ÿxþ
because of the ÿspecialþ declaration for ÿxþ in the second line.  The
third occurrence of ÿxþ establishes a lexical binding of ÿxþ (because
there is no ÿspecialþ declaration in the corresponding ÿletþ form).
The fourth occurrence of ÿxþ x is a reference to the lexical binding of
ÿxþ established in the third line.  The fifth occurrence of ÿxþ
establishes a dynamic binding of x for the body of the ÿletþ form that
begins on that line because of the ÿspecialþ declaration for ÿxþ in the
sixth line. The reference to ÿxþ in the fourth line is not affected by
the ÿspecialþ declaration in the sixth line because that reference is
not within the "would-be lexical scope" of the variable ÿxþ in the
fifth line.  The reference to ÿxþ in the seventh line is a reference to
the dynamic binding of x established in the fifth line.

Here is another example, to illustrate the scope of a free declaration.
In the following:

 (lambda (&optional (x (foo 1))) ;[1]
   (declare (notinline foo))     ;[2]
   (foo x))                      ;[3]

the call to ÿfooþ in the first line might be compiled inline even
though the call to ÿfooþ in the third line must not be.  This is because
the ÿnotinlineþ declaration for ÿfooþ in the second line applies only
to the body on the third line.  In order to suppress inlining for both
calls, one might write:

 (locally (declare (notinline foo)) ;[1]
   (lambda (&optional (x (foo 1)))  ;[2]
     (foo x)))                      ;[3]

or, alternatively:

 (lambda (&optional                               ;[1]
            (x (locally (declare (notinline foo)) ;[2]
                 (foo 1))))                       ;[3]
   (declare (notinline foo))                      ;[4]
   (foo x))                                       ;[5]

Finally, here is an example that shows the scope of declarations in an
iteration form.

 (let ((x  1))                     ;[1]
   (declare (special x))           ;[2]
     (let ((x 2))                  ;[3]
       (dotimes (i x x)            ;[4]
         (declare (special x)))))  ;[5]
ý 1

In this example, the first reference to ÿxþ on the fourth line is to
the lexical binding of ÿxþ established on the third line.  However, the
second occurrence of ÿxþ on the fourth line lies within the scope of
the free declaration on the fifth line (because this is the RESULT-FORM
of the ÿdotimesþ) and therefore refers to the dynamic binding of ÿxþ.


File: chris-ansicl.info,  Node: Lambda Lists,  Next: Error Checking in Function Calls,  Prev: Declarations,  Up: Evaluation and Compilation

3.4 Lambda Lists
================

A "lambda list" is a list that specifies a set of parameters (sometimes
called lambda variables) and a protocol for receiving values for those
parameters.

There are several kinds of lambda lists.

Context                                         Kind of Lambda List
-------------------------------------------------------------------------------------------------- 
ÿdefunþ form                                    ordinary lambda list
ÿdefmacroþ form                                 macro lambda list
lambda expression                               ordinary lambda list
ÿfletþ local function definition                ordinary lambda list
ÿlabelsþ local function definition              ordinary lambda list
ÿhandler-caseþ CLAUSE specification             ordinary lambda list
ÿrestart-caseþ CLAUSE specification             ordinary lambda list
ÿmacroletþ local macro definition               macro lambda list
ÿdefine-method-combinationþ                     ordinary lambda list
ÿdefine-method-combinationþ :arguments option   define-method-combination arguments lambda list
ÿdefstructþ :constructor option                 boa lambda list
ÿdefgenericþ form                               generic function lambda list
ÿdefgenericþ method clause                      specialized lambda list
ÿdefmethodþ form                                specialized lambda list
ÿdefsetfþ form                                  defsetf lambda list
ÿdefine-setf-expanderþ form                     macro lambda list
ÿdeftypeþ form                                  deftype lambda list
ÿdestructuring-bindþ form                       destructuring lambda list
ÿdefine-compiler-macroþ form                    macro lambda list
ÿdefine-modify-macroþ form                      define-modify-macro lambda list

Figure 3.10: What Kind of Lambda Lists to Use

The next figure lists some defined names that are applicable to lambda
lists.

lambda-list-keywords   lambda-parameters-limit   

Figure 3.11: Defined names applicable to lambda lists

* Menu:

* Ordinary Lambda Lists::
* Generic Function Lambda Lists::
* Specialized Lambda Lists::
* Macro Lambda Lists::
* Destructuring Lambda Lists::
* Boa Lambda Lists::
* Defsetf Lambda Lists::
* Deftype Lambda Lists::
* Define-modify-macro Lambda Lists::
* Define-method-combination Arguments Lambda Lists::
* Syntactic Interaction of Documentation Strings and Declarations::


File: chris-ansicl.info,  Node: Ordinary Lambda Lists,  Next: Generic Function Lambda Lists,  Up: Lambda Lists

3.4.1 Ordinary Lambda Lists
---------------------------

An "ordinary lambda list" is used to describe how a set of arguments is
received by an ordinary function.  The defined names in the next
figure are those which use ordinary lambda lists:

define-method-combination   handler-case   restart-case
defun                       labels         
flet                        lambda         

Figure 3.12: Standardized Operators that use Ordinary Lambda Lists

An ordinary lambda list can contain the lambda list keywords shown in
the next figure.

ÿ&allow-other-keysþ   ÿ&keyþ        ÿ&restþ
ÿ&auxþ                ÿ&optionalþ   

Figure 3.13: Lambda List Keywords used by Ordinary Lambda Lists

Each element of a lambda list is either a parameter specifier or a
lambda list keyword.  Implementations are free to provide additional
lambda list keywords.  For a list of all lambda list keywords used by
the implementation, see ÿlambda-list-keywordsþ.

The syntax for ordinary lambda lists is as follows:

LAMBDA-LIST::=
     ({var}*
      [&optional {var | (var [init-form [supplied-p-parameter]])}*]
      [&rest VAR]
      ÿ[þ&key {var ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}*
     [&allow-other-keys]ÿ]þ
      [&aux {var | (var [init-form])}*])

A VAR or SUPPLIED-P-PARAMETER must be a symbol that is not the name of
a constant variable.

An INIT-FORM can be any form.  Whenever any INIT-FORM is evaluated for
any parameter specifier, that form may refer to any parameter variable
to the left of the specifier in which the INIT-FORM appears, including
any SUPPLIED-P-PARAMETER variables, and may rely on the fact that no
other parameter variable has yet been bound (including its own
parameter variable).

A KEYWORD-NAME can be any symbol, but by convention is normally a
keywordá; all standardized functions follow that convention.

An ordinary lambda list has five parts, any or all of which may be
empty.  For information about the treatment of argument mismatches, see
*Note Section 3.5 (Error Checking in Function Calls): Error Checking in
Function Calls.

3.4.1.1 Specifiers for the required parameters
..............................................

These are all the parameter specifiers up to the first lambda list
keyword; if there are no lambda list keywords, then all the specifiers
are for required parameters.  Each required parameter is specified by a
parameter variable VAR.  VAR is bound as a lexical variable unless it
is declared ÿspecialþ.

If there are ÿnþ required parameters (ÿnþ may be zero), there must be
at least ÿnþ passed arguments, and the required parameters are bound to
the first ÿnþ passed arguments; see *Note Section 3.5 (Error Checking
in Function Calls): Error Checking in Function Calls.  The other
parameters are then processed using any remaining arguments.

3.4.1.2 Specifiers for optional parameters
..........................................

If ÿ&optionalþ is present, the optional parameter specifiers are those
following ÿ&optionalþ up to the next lambda list keyword or the end of
the list.  If optional parameters are specified, then each one is
processed as follows.  If any unprocessed arguments remain, then the
parameter variable VAR is bound to the next remaining argument, just as
for a required parameter.  If no arguments remain, however, then
INIT-FORM is evaluated, and the parameter variable is bound to the
resulting value (or to ÿnilþ if no INIT-FORM appears in the parameter
specifier).  If another variable name SUPPLIED-P-PARAMETER appears in
the specifier, it is bound to true if an argument had been available,
and to false if no argument remained (and therefore INIT-FORM had to be
evaluated).  SUPPLIED-P-PARAMETER is bound not to an argument but to a
value indicating whether or not an argument had been supplied for the
corresponding VAR.

3.4.1.3 A specifier for a rest parameter
........................................

ÿ&restþ, if present, must be followed by a single rest parameter
specifier, which in turn must be followed by another lambda list
keyword or the end of the lambda list.  After all optional parameter
specifiers have been processed, then there may or may not be a rest
parameter.  If there is a rest parameter, it is bound to a list of all
as-yet-unprocessed arguments.  If no unprocessed arguments remain, the
rest parameter is bound to the empty list.  If there is no rest
parameter and there are no keyword parameters, then an error should be
signaled if any unprocessed arguments remain; see *Note Section 3.5
(Error Checking in Function Calls): Error Checking in Function Calls.
The value of a rest parameter is permitted, but not required, to share
structure with the last argument to ÿapplyþ.

3.4.1.4 Specifiers for keyword parameters
.........................................

If ÿ&keyþ is present, all specifiers up to the next lambda list keyword
or the end of the list are keyword parameter specifiers.  When keyword
parameters are processed, the same arguments are processed that would
be made into a list for a rest parameter.  It is permitted to specify
both ÿ&restþ and ÿ&keyþ.  In this case the remaining arguments are used
for both purposes; that is, all remaining arguments are made into a
list for the rest parameter, and are also processed for the ÿ&keyþ
parameters.  If ÿ&keyþ is specified, there must remain an even number
of arguments; see *Note Section 3.5.1.6 (Odd Number of Keyword
Arguments): OddNumberOfKeyArgs.  These arguments are considered as
pairs, the first argument in each pair being interpreted as a name and
the second as the corresponding value.  The first object of each pair
must be a symbol; see *Note Section 3.5.1.5 (Invalid Keyword
Arguments): InvalidKeyArgs.  The keyword parameter specifiers may
optionally be followed by the lambda list keyword ÿ&allow-other-keysþ.

In each keyword parameter specifier must be a name VAR for the
parameter variable.  If the VAR appears alone or in a ÿ(VAR INIT-FORM)þ
combination, the keyword name used when matching arguments to parameters
is a symbol in the ÿKEYWORDþ package whose name is the same (under
ÿstring=þ) as VAR's.  If the notation ÿ((KEYWORD-NAME VAR) INIT-FORM)þ
is used, then the keyword name used to match arguments to parameters is
KEYWORD-NAME, which may be a symbol in any package.  (Of course, if it
is not a symbol in the ÿKEYWORDþ package, it does not necessarily
self-evaluate, so care must be taken when calling the function to make
sure that normal evaluation still yields the keyword name.)  Thus

 (defun foo (&key radix (type 'integer)) ...)

means exactly the same as

 (defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)

The keyword parameter specifiers are, like all parameter specifiers,
effectively processed from left to right.  For each keyword parameter
specifier, if there is an argument pair whose name matches that
specifier's name (that is, the names are ÿeqþ), then the parameter
variable for that specifier is bound to the second item (the value) of
that argument pair.  If more than one such argument pair matches, the
leftmost argument pair is used.  If no such argument pair exists, then
the INIT-FORM for that specifier is evaluated and the parameter
variable is bound to that value (or to ÿnilþ if no INIT-FORM was
specified).  SUPPLIED-P-PARAMETER is treated as for ÿ&optionalþ
parameters: it is bound to true if there was a matching argument pair,
and to false otherwise.

Unless keyword argument checking is suppressed, an argument pair must a
name matched by a parameter specifier; see *Note Section 3.5.1.4
(Unrecognized Keyword Arguments): UnrecognizedKeyArgs.

If keyword argument checking is suppressed, then it is permitted for an
argument pair to match no parameter specifier, and the argument pair is
ignored, but such an argument pair is accessible through the rest
parameter if one was supplied.  The purpose of these mechanisms is to
allow sharing of argument lists among several lambda expressions and to
allow either the caller or the called lambda expression to specify that
such sharing may be taking place.

Note that if ÿ&keyþ is present, a keyword argument of :allow-other-keys
is always permitted--regardless of whether the associated value is true
or false.  However, if the value is false, other non-matching keywords
are not tolerated (unless ÿ&allow-other-keysþ was used).

Furthermore, if the receiving argument list specifies a regular
argument which would be flagged by :allow-other-keys, then
:allow-other-keys has both its special-cased meaning (identifying
whether additional keywords are permitted) and its normal meaning (data
flow into the function in question).

3.4.1.4.1 Suppressing Keyword Argument Checking
...............................................

If ÿ&allow-other-keysþ was specified in the lambda list of a function,
keywordà argument checking is suppressed in calls to that function.

If the :allow-other-keys argument is true in a call to a function,
keywordà argument checking is suppressed in that call.

The :allow-other-keys argument is permissible in all situations
involving keywordà arguments, even when its associated value is false.

3.4.1.4.1.1 Examples of Suppressing Keyword Argument Checking
.............................................................

;;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.
 ((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) ý 1
;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.
 ((lambda (&key x &allow-other-keys) x) :x 1 :y 2) ý 1
;;; :ALLOW-OTHER-KEYS NIL is always permitted.
 ((lambda (&key) t) :allow-other-keys nil) ý T
;;; As with other keyword arguments, only the left-most pair
;;; named :ALLOW-OTHER-KEYS has any effect.
 ((lambda (&key x) x)
  :x 1 :y 2 :allow-other-keys t :allow-other-keys nil)
ý 1
;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,
;;; so in safe code this signals a PROGRAM-ERROR (and might enter the
;;; debugger).  In unsafe code, the consequences are undefined.
 ((lambda (&key x) x)                   ;This call is not valid
  :x 1 :y 2 :allow-other-keys nil :allow-other-keys t)

3.4.1.5 Specifiers for ÿ&auxþ variables
.......................................

These are not really parameters.  If the lambda list keyword ÿ&auxþ is
present, all specifiers after it are auxiliary variable specifiers.
After all parameter specifiers have been processed, the auxiliary
variable specifiers (those following &aux) are processed from left to
right.  For each one, INIT-FORM is evaluated and VAR is bound to that
value (or to ÿnilþ if no INIT-FORM was specified).  ÿ&auxþ variable
processing is analogous to ÿlet*þ processing.

 (lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))
    Õ (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))

3.4.1.6 Examples of Ordinary Lambda Lists
.........................................

Here are some examples involving optional parameters and rest
parameters:

 ((lambda (a b) (+ a (* b 3))) 4 5) ý 19
 ((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) ý 19
 ((lambda (a &optional (b 2)) (+ a (* b 3))) 4) ý 10
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))
ý (2 NIL 3 NIL NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)
ý (6 T 3 NIL NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)
ý (6 T 3 T NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)
ý (6 T 3 T (8))
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))
  6 3 8 9 10 11)
ý (6 t 3 t (8 9 10 11))

Here are some examples involving keyword parameters:

 ((lambda (a b &key c d) (list a b c d)) 1 2) ý (1 2 NIL NIL)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) ý (1 2 6 NIL)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) ý (1 2 NIL 8)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) ý (1 2 6 8)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) ý (1 2 6 8)
 ((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) ý (:a 1 6 8)
 ((lambda (a b &key c d) (list a b c d)) :a :b :c :d) ý (:a :b :d NIL)
 ((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) ý (1 2 6 NIL)
 ((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) ý (1 2 6 NIL)

Here are some examples involving optional parameters, rest parameters,
and keyword parameters together:

 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1)
ý (1 3 NIL 1 ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 2)
ý (1 2 NIL 1 ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) :c 7)
ý (:c 7 NIL :c ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :c 7)
ý (1 6 7 1 (:c 7))
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :d 8)
ý (1 6 NIL 8 (:d 8))
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :d 8 :c 9 :d 10)
ý (1 6 9 8 (:d 8 :c 9 :d 10))

As an example of the use of ÿ&allow-other-keysþ and :allow-other-keys,
consider a function that takes two named arguments of its own and also
accepts additional named arguments to be passed to ÿmake-arrayþ:

 (defun array-of-strings (str dims &rest named-pairs
                          &key (start 0) end &allow-other-keys)
   (apply #'make-array dims
          :initial-element (subseq str start end)
          :allow-other-keys t
          named-pairs))

This function takes a string and dimensioning information and returns
an array of the specified dimensions, each of whose elements is the
specified string.  However, :start and :end named arguments may be used
to specify that a substring of the given string should be used.  In
addition, the presence of ÿ&allow-other-keysþ in the lambda list
indicates that the caller may supply additional named arguments; the
rest parameter provides access to them.  These additional named
arguments are passed to ÿmake-arrayþ.  The function ÿmake-arrayþ
normally does not allow the named arguments :start and :end to be used,
and an error should be signaled if such named arguments are supplied to
ÿmake-arrayþ.  However, the presence in the call to ÿmake-arrayþ of the
named argument :allow-other-keys with a true value causes any
extraneous named arguments, including :start and :end, to be acceptable
and ignored.


File: chris-ansicl.info,  Node: Generic Function Lambda Lists,  Next: Specialized Lambda Lists,  Prev: Ordinary Lambda Lists,  Up: Lambda Lists

3.4.2 Generic Function Lambda Lists
-----------------------------------

A "generic function lambda list" is used to describe the overall shape
of the argument list to be accepted by a generic function.  Individual
method signatures might contribute additional keyword parameters to the
lambda list of the effective method.

A generic function lambda list is used by ÿdefgenericþ.

A generic function lambda list has the following syntax:

LAMBDA-LIST::=
     ({var}*
      [&optional {var | (var)}*]
      [&rest VAR]
      ÿ[þ&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}*
     [&allow-other-keys]ÿ]þ)

A generic function lambda list can contain the lambda list keywords
shown in the next figure.

ÿ&allow-other-keysþ   ÿ&optionalþ   
ÿ&keyþ                ÿ&restþ       

Figure 3.14: Lambda List Keywords used by Generic Function Lambda Lists

A generic function lambda list differs from an ordinary lambda list in
the following ways:

Required arguments
     Zero or more required parameters must be specified.

Optional and keyword arguments
     Optional parameters and keyword parameters may not have default
     initial value forms nor use supplied-p parameters.

Use of ÿ&auxþ
     The use of ÿ&auxþ is not allowed.


File: chris-ansicl.info,  Node: Specialized Lambda Lists,  Next: Macro Lambda Lists,  Prev: Generic Function Lambda Lists,  Up: Lambda Lists

3.4.3 Specialized Lambda Lists
------------------------------

A "specialized lambda list" is used to specialize a method for a
particular signature and to describe how arguments matching that
signature are received by the method.  The defined names in the next
figure use specialized lambda lists in some way; see the dictionary
entry for each for information about how.

defmethod   defgeneric   

Figure 3.15: Standardized Operators that use Specialized Lambda Lists

A specialized lambda list can contain the lambda list keywords shown in
the next figure.

ÿ&allow-other-keysþ   ÿ&keyþ        ÿ&restþ
ÿ&auxþ                ÿ&optionalþ   

Figure 3.16: Lambda List Keywords used by Specialized Lambda Lists

A specialized lambda list is syntactically the same as an ordinary
lambda list except that each required parameter may optionally be
associated with a class or object for which that parameter is
specialized.

LAMBDA-LIST::=
     ({var | (var [specializer])}*
     [&optional {var | (var [init-form [supplied-p-parameter]])}*]
     [&rest VAR]
     [&key {var ({var | (keyword-name var)} [init-form
     [supplied-p-parameter]])}* [&allow-other-keys]]
     [&aux {var | (var [init-form])}*])


File: chris-ansicl.info,  Node: Macro Lambda Lists,  Next: Destructuring Lambda Lists,  Prev: Specialized Lambda Lists,  Up: Lambda Lists

3.4.4 Macro Lambda Lists
------------------------

A "macro lambda list" is used in describing macros defined by the
operators in the next figure.

define-compiler-macro   defmacro   macrolet
define-setf-expander               

Figure 3.17: Operators that use Macro Lambda Lists

With the additional restriction that an environment parameter may
appear only once (at any of the positions indicated), a macro lambda
list has the following syntax:

REQVARS::=
     {var | ûpattern}*

OPTVARS::=
     [&optional {var | ({var ûpattern} [init-form
     [supplied-p-parameter]])}*]

RESTVARS::=
     [{&rest | &body} {var | ûpattern}]

KEYVARS::=
     [&key {var | ({var | (keyword-name {var | ûpattern})} [init-form
     [supplied-p-parameter]])}* [&allow-other-keys]]

AUXVARS::=
     [&aux {var | (var [init-form])}*]

ENVVAR::=
     [&environment VAR]

WHOLEVAR::=
     [&whole VAR]

LAMBDA-LIST::=
     (ûwholevar ûenvvar ûreqvars ûenvvar ûoptvars ûenvvar
     ûrestvar ûenvvar ûkeyvars ûenvvar ûauxvars ûenvvar) |
     (ûwholevar ûenvvar ûreqvars ûenvvar ûoptvars ûenvvar ÿ.þ VAR)

PATTERN::=
     (ûwholevar ûreqvars ûoptvars ûrestvar ûkeyvars ûauxvars) |
     (ûwholevar ûreqvars ûoptvars ÿ.þ VAR)

A macro lambda list can contain the lambda list keywords shown in the
next figure.

ÿ&allow-other-keysþ   ÿ&environmentþ   ÿ&restþ
ÿ&auxþ                ÿ&keyþ           ÿ&wholeþ
ÿ&bodyþ               ÿ&optionalþ      

Figure 3.18: Lambda List Keywords used by Macro Lambda Lists

Optional parameters (introduced by ÿ&optionalþ) and keyword parameters
(introduced by ÿ&keyþ) can be supplied in a macro lambda list, just as
in an ordinary lambda list.  Both may contain default initialization
forms and supplied-p parameters.

ÿ&bodyþ is identical in function to ÿ&restþ, but it can be used to
inform certain output-formatting and editing functions that the
remainder of the form is treated as a body, and should be indented
accordingly.  Only one of ÿ&bodyþ or ÿ&restþ can be used at any
particular level; see *Note Section 3.4.4.1 (Destructuring by Lambda
Lists): DestructuringByLambdaLists.  ÿ&bodyþ can appear at any level of
a macro lambda list; for details, see *Note Section 3.4.4.1
(Destructuring by Lambda Lists): DestructuringByLambdaLists.

ÿ&wholeþ is followed by a single variable that is bound to the entire
macro-call form; this is the value that the macro function receives as
its first argument.  If ÿ&wholeþ and a following variable appear, they
must appear first in LAMBDA-LIST, before any other parameter or lambda
list keyword.  ÿ&wholeþ can appear at any level of a macro lambda list.
At inner levels, the ÿ&wholeþ variable is bound to the corresponding
part of the argument, as with ÿ&restþ, but unlike ÿ&restþ, other
arguments are also allowed.  The use of ÿ&wholeþ does not affect the
pattern of arguments specified.

ÿ&environmentþ is followed by a single variable that is bound to an
environment representing the lexical environment in which the macro
call is to be interpreted.  This environment should be used with
ÿmacro-functionþ, ÿget-setf-expansionþ, ÿcompiler-macro-functionþ, and
ÿmacroexpandþ (for example) in computing the expansion of the macro, to
ensure that any lexical bindings or definitions established in the
compilation environment are taken into account.  ÿ&environmentþ can
only appear at the top level of a macro lambda list, and can only
appear once, but can appear anywhere in that list; the ÿ&environmentþ
parameter is bound along with ÿ&wholeþ before any other variables in
the lambda list, regardless of where ÿ&environmentþ appears in the
lambda list.  The object that is bound to the environment parameter has
dynamic extent.

Destructuring allows a macro lambda list to express the structure of a
macro call syntax.  If no lambda list keywords appear, then the macro
lambda list is a tree containing parameter names at the leaves.  The
pattern and the macro form must have compatible tree structure; that
is, their tree structure must be equivalent, or it must differ only in
that some leaves of the pattern match non-atomic objects of the macro
form.  For information about error detection in this situation, see
*Note Section 3.5.1.7 (Destructuring Mismatch): DestructuringMismatch.

A destructuring lambda list (whether at top level or embedded) can be
dotted, ending in a parameter name.  This situation is treated exactly
as if the parameter name that ends the list had appeared preceded by
ÿ&restþ.

It is permissible for a macro form (or a subexpression of a macro form)
to be a dotted list only  when ÿ(... &rest var)þ or ÿ(... . var)þ is
used to match it. It is the responsibility of the macro to recognize
and deal with such situations.

3.4.4.1 Destructuring by Lambda Lists
.....................................

Anywhere in a macro lambda list where a parameter name can appear, and
where ordinary lambda list syntax (as described in *Note Section 3.4.1
(Ordinary Lambda Lists): Ordinary Lambda Lists.) does not otherwise
allow a list, a destructuring lambda list can appear in place of the
parameter name.  When this is done, then the argument that would match
the parameter is treated as a (possibly dotted) list, to be used as an
argument list for satisfying the parameters in the embedded lambda list.
This is known as destructuring.

Destructuring is the process of decomposing a compound object into its
component parts, using an abbreviated, declarative syntax, rather than
writing it out by hand using the primitive component-accessing
functions.  Each component part is bound to a variable.

A destructuring operation requires an object to be decomposed, a
pattern that specifies what components are to be extracted, and the
names of the variables whose values are to be the components.

3.4.4.1.1 Data-directed Destructuring by Lambda Lists
.....................................................

In data-directed destructuring, the pattern is a sample object of the
type to be decomposed.  Wherever a component is to be extracted, a
symbol appears in the pattern; this symbol is the name of the variable
whose value will be that component.

3.4.4.1.1.1 Examples of Data-directed Destructuring by Lambda Lists
...................................................................

An example pattern is

ÿ(a b c)þ

which destructures a list of three elements.  The variable ÿaþ is
assigned to the first element, ÿbþ to the second, etc.  A more complex
example is

ÿ((first . rest) . more)þ

The important features of data-directed destructuring are its syntactic
simplicity and the ability to extend it to lambda-list-directed
destructuring.

3.4.4.1.2 Lambda-list-directed Destructuring by Lambda Lists
............................................................

An extension of data-directed destructuring of trees is
lambda-list-directed destructuring.  This derives from the analogy
between the three-element destructuring pattern

ÿ(first second third)þ

and the three-argument lambda list

ÿ(first second third)þ

Lambda-list-directed destructuring is identical to data-directed
destructuring if no lambda list keywords appear in the pattern.  Any
list in the pattern (whether a sub-list or the whole pattern itself)
that contains a lambda list keyword is interpreted specially.  Elements
of the list to the left of the first lambda list keyword are treated as
destructuring patterns, as usual, but the remaining elements of the
list are treated like a function's lambda list except that where a
variable would normally be required, an arbitrary destructuring pattern
is allowed.  Note that in case of ambiguity, lambda list syntax is
preferred over destructuring syntax.  Thus, after ÿ&optionalþ a list of
elements is a list of a destructuring pattern and a default value form.

The detailed behavior of each lambda list keyword in a
lambda-list-directed destructuring pattern is as follows:

ÿ&optionalþ
     Each following element is a variable or a list of a destructuring
     pattern, a default value form, and a supplied-p variable.  The
     default value and the supplied-p variable can be omitted.  If the
     list being destructured ends early, so that it does not have an
     element to match against this destructuring (sub)-pattern, the
     default form is evaluated and destructured instead.  The
     supplied-p variable receives the value ÿnilþ if the default form
     is used, ÿtþ otherwise.

ÿ&restþ, ÿ&bodyþ
     The next element is a destructuring pattern that matches the rest
     of the list.  ÿ&bodyþ is identical to ÿ&restþ but declares that
     what is being matched is a list of forms that constitutes the body
     of form.  This next element must be the last unless a lambda list
     keyword follows it.

ÿ&auxþ
     The remaining elements are not destructuring patterns at all, but
     are auxiliary variable bindings.

ÿ&wholeþ
     The next element is a destructuring pattern that matches the entire
     form in a macro, or the entire subexpression at inner levels.

ÿ&keyþ
     Each following element is one of


          a variable,

    or
          a list of a variable, an optional initialization form, and an
          optional supplied-p variable.

    or
          a list of a list of a keyword and a destructuring pattern, an
          optional initialization form, and an optional supplied-p
          variable.

     The rest of the list being destructured is taken to be alternating
     keywords and values and is taken apart appropriately.

ÿ&allow-other-keysþ
     Stands by itself.


File: chris-ansicl.info,  Node: Destructuring Lambda Lists,  Next: Boa Lambda Lists,  Prev: Macro Lambda Lists,  Up: Lambda Lists

3.4.5 Destructuring Lambda Lists
--------------------------------

A "destructuring lambda list" is used by ÿdestructuring-bindþ.

Destructuring lambda lists are closely related to macro lambda lists;
see *Note Section 3.4.4 (Macro Lambda Lists): Macro Lambda Lists.  A
destructuring lambda list can contain all of the lambda list keywords
listed for macro lambda lists except for ÿ&environmentþ, and supports
destructuring in the same way.  Inner lambda lists nested within a
macro lambda list have the syntax of destructuring lambda lists.

A destructuring lambda list has the following syntax:

REQVARS::=
     {var | ûlambda-list}*

OPTVARS::=
     [&optional {var | ({var ûlambda-list} [init-form
     [supplied-p-parameter]])}*]

RESTVARS::=
     [{&rest | &body} {var | ûlambda-list}]

KEYVARS::=
     [&key {var | ({var | (keyword-name {var | ûlambda-list})}
     [init-form [supplied-p-parameter]])}* [&allow-other-keys]]

AUXVARS::=
     [&aux {var | (var [init-form])}*]

ENVVAR::=
     [&environment VAR]

WHOLEVAR::=
     [&whole VAR]

LAMBDA-LIST::=
     (ûwholevar ûreqvars ûoptvars ûrestvar ûkeyvars ûauxvars) |
     (ûwholevar ûreqvars ûoptvars ÿ.þ VAR)


File: chris-ansicl.info,  Node: Boa Lambda Lists,  Next: Defsetf Lambda Lists,  Prev: Destructuring Lambda Lists,  Up: Lambda Lists

3.4.6 Boa Lambda Lists
----------------------

A "boa lambda list" is a lambda list that is syntactically like an
ordinary lambda list, but that is processed in "by order of argument"
style.

A boa lambda list is used only in a ÿdefstructþ form, when explicitly
specifying the lambda list of a constructor function (sometimes called
a "boa constructor").

The ÿ&optionalþ, ÿ&restþ, ÿ&auxþ, ÿ&keyþ, and ÿ&allow-other-keysþ
lambda list keywords are recognized in a boa lambda list.  The way
these lambda list keywords differ from their use in an ordinary lambda
list follows.

Consider this example, which describes how ÿdestructþ processes its
:constructor option.

 (:constructor create-foo
         (a &optional b (c 'sea) &rest d &aux e (f 'eff)))

This defines ÿcreate-fooþ to be a constructor of one or more arguments.
The first argument is used to initialize the ÿaþ slot.  The second
argument is used to initialize the ÿbþ slot.  If there isn't any second
argument, then the default value given in the body of the ÿdefstructþ
(if given) is used instead.  The third argument is used to initialize
the ÿcþ slot.  If there isn't any third argument, then the symbol ÿseaþ
is used instead.  Any arguments following the third argument are
collected into a list and used to initialize the ÿdþ slot.  If there
are three or fewer arguments, then ÿnilþ is placed in the ÿdþ slot.
The ÿeþ slot is not initialized; its initial value is
implementation-defined.  Finally, the ÿfþ slot is initialized to
contain the symbol ÿeffþ.  ÿ&keyþ and ÿ&allow-other-keysþ arguments
default in a manner similar to that of ÿ&optionalþ arguments: if no
default is supplied in the lambda list then the default value given in
the body of the ÿdefstructþ (if given) is used instead.  For example:

 (defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)
                                             &key (d 2)
                                             &aux e (f 'eff))))
   (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))

 (create-foo 10) ý #S(FOO A 10 B 2 C SEA D 2 E implemention-dependent F EFF)
 (create-foo 10 'bee 'see :d 'dee)
ý #S(FOO A 10 B BEE C SEE D DEE E implemention-dependent F EFF)

If keyword arguments of the form ÿ((key var) [default [svar]])þ are
specified, the slot name is matched with var (not key).

The actions taken in the ÿbþ and ÿeþ cases were carefully chosen to
allow the user to specify all possible behaviors.  The ÿ&auxþ variables
can be used to completely override the default initializations given in
the body.

If no default value is supplied for an aux variable variable, the
consequences are undefined if an attempt is later made to read the
corresponding slot's value before a value is explicitly assigned.  If
such a slot has a :type option specified, this suppressed
initialization does not imply a type mismatch situation; the declared
type is only required to apply when the slot is finally assigned.

With this definition, the following can be written:

 (create-foo 1 2)

instead of

 (make-foo :a 1 :b 2)

and ÿcreate-fooþ provides defaulting different from that of ÿmake-fooþ.

Additional arguments that do not correspond to slot names but are
merely present to supply values used in subsequent initialization
computations are allowed.  For example, in the definition

 (defstruct (frob (:constructor create-frob
                  (a &key (b 3 have-b) (c-token 'c)
                          (c (list c-token (if have-b 7 2))))))
         a b c)

the ÿc-tokenþ argument is used merely to supply a value used in the
initialization of the ÿcþ slot. The supplied-p parameters associated
with optional parameters and keyword parameters might also be used this
way.


File: chris-ansicl.info,  Node: Defsetf Lambda Lists,  Next: Deftype Lambda Lists,  Prev: Boa Lambda Lists,  Up: Lambda Lists

3.4.7 Defsetf Lambda Lists
--------------------------

A "defsetf lambda list" is used by ÿdefsetfþ.

A defsetf lambda list has the following syntax:

LAMBDA-LIST::=
     ({var}*
     [&optional {var | (var [init-form [supplied-p-parameter]])}*]
     [&rest VAR]
     ÿ[þ&key {var ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}*
     [&allow-other-keys]ÿ]þ
     [&environment VAR]

A defsetf lambda list can contain the lambda list keywords shown in the
next figure.

ÿ&allow-other-keysþ   ÿ&keyþ        ÿ&restþ
ÿ&environmentþ        ÿ&optionalþ   

Figure 3.19: Lambda List Keywords used by Defsetf Lambda Lists

A defsetf lambda list differs from an ordinary lambda list only in that
it does not permit the use of ÿ&auxþ, and that it permits use of
ÿ&environmentþ, which introduces an environment parameter.


File: chris-ansicl.info,  Node: Deftype Lambda Lists,  Next: Define-modify-macro Lambda Lists,  Prev: Defsetf Lambda Lists,  Up: Lambda Lists

3.4.8 Deftype Lambda Lists
--------------------------

A "deftype lambda list" is used by ÿdeftypeþ.

A deftype lambda list has the same syntax as a macro lambda list, and
can therefore contain the lambda list keywords as a macro lambda list.

A deftype lambda list differs from a macro lambda list only in that if
no INIT-FORM is supplied for an optional parameter or keyword parameter
in the LAMBDA-LIST, the default value for that parameter is the symbol
* (rather than ÿnilþ).


File: chris-ansicl.info,  Node: Define-modify-macro Lambda Lists,  Next: Define-method-combination Arguments Lambda Lists,  Prev: Deftype Lambda Lists,  Up: Lambda Lists

3.4.9 Define-modify-macro Lambda Lists
--------------------------------------

A "define-modify-macro lambda list" is used by ÿdefine-modify-macroþ.

A define-modify-macro lambda list can contain the lambda list keywords
shown in the next figure.

ÿ&optionalþ   ÿ&restþ

Figure 3.20: Lambda List Keywords used by Define-modify-macro Lambda Lists

Define-modify-macro lambda lists are similar to ordinary lambda lists,
but do not support keyword arguments.  ÿdefine-modify-macroþ has no
need match keyword arguments, and a rest parameter is sufficient.  Aux
variables are also not supported, since ÿdefine-modify-macroþ has no
body forms which could refer to such bindings.  See the macro *Note
define-modify-macro::.


File: chris-ansicl.info,  Node: Define-method-combination Arguments Lambda Lists,  Next: Syntactic Interaction of Documentation Strings and Declarations,  Prev: Define-modify-macro Lambda Lists,  Up: Lambda Lists

3.4.10 Define-method-combination Arguments Lambda Lists
-------------------------------------------------------

A "define-method-combination arguments lambda list" is used by the
:arguments option to ÿdefine-method-combinationþ.

A define-method-combination arguments lambda list can contain the
lambda list keywords shown in the next figure.

ÿ&allow-other-keysþ   ÿ&keyþ        ÿ&restþ
ÿ&auxþ                ÿ&optionalþ   ÿ&wholeþ

Figure 3.21: Lambda List Keywords used by Define-method-combination
arguments Lambda Lists

Define-method-combination arguments lambda lists are similar to
ordinary lambda lists, but also permit the use of ÿ&wholeþ.


File: chris-ansicl.info,  Node: Syntactic Interaction of Documentation Strings and Declarations,  Prev: Define-method-combination Arguments Lambda Lists,  Up: Lambda Lists

3.4.11 Syntactic Interaction of Documentation Strings and Declarations
----------------------------------------------------------------------

In a number of situations, a documentation string can appear amidst a
series of declare expressions prior to a series of forms.

In that case, if a string S appears where a documentation string is
permissible and is not followed by either a declare expression or a form
then S is taken to be a form; otherwise, S is taken as a documentation
string.  The consequences are unspecified if more than one such
documentation string is present.


File: chris-ansicl.info,  Node: Error Checking in Function Calls,  Next: Traversal Rules and Side Effects,  Prev: Lambda Lists,  Up: Evaluation and Compilation

3.5 Error Checking in Function Calls
====================================

* Menu:

* Argument Mismatch Detection::


File: chris-ansicl.info,  Node: Argument Mismatch Detection,  Up: Error Checking in Function Calls

3.5.1 Argument Mismatch Detection
---------------------------------

3.5.1.1 Safe and Unsafe Calls
.............................

A call is a "safe call" if each of the following is either safe code or
system code (other than system code that results from macro expansion of
programmer code):

   * the call.

   * the definition of the function being called.

   * the point of functional evaluation

The following special cases require some elaboration:

   * If the function being called is a generic function, it is
     considered safe if all of the following are safe code or system
     code:

        - its definition (if it was defined explicitly).

        - the method definitions for all applicable methods.

        - the definition of its method combination.

   * For the form ÿ(coerce X 'function)þ, where X is a lambda
     expression, the value of the optimize quality ÿsafetyþ in the
     global environment at the time the ÿcoerceþ is executed applies to
     the resulting function.

   * For a call to the function ÿensure-generic-functionþ, the value of
     the optimize quality ÿsafetyþ in the environment object passed as
     the :environment argument applies to the resulting generic
     function.

   * For a call to ÿcompileþ with a lambda expression as the argument,
     the value of the optimize quality ÿsafetyþ in the global
     environment at the time ÿcompileþ is called applies to the
     resulting compiled function.

   * For a call to ÿcompileþ with only one argument, if the original
     definition of the function was safe, then the resulting compiled
     function must also be safe.

   * A call to a method by ÿcall-next-methodþ must be considered safe
     if each of the following is safe code or system code:

        - the definition of the generic function (if it was defined
          explicitly).

        - the method definitions for all applicable methods.

        - the definition of the method combination.

        - the point of entry into the body of the method defining form,
          where the binding of ÿcall-next-methodþ is established.

        - the point of functional evaluation of the name
          ÿcall-next-methodþ.


An "unsafe call" is a call that is not a safe call.

The informal intent is that the programmer can rely on a call to be
safe, even when system code is involved, if all reasonable steps have
been taken to ensure that the call is safe.  For example, if a
programmer calls ÿmapcarþ from safe code and supplies a function that
was compiled as safe, the implementation is required to ensure that
ÿmapcarþ makes a safe call as well.

3.5.1.1.1 Error Detection Time in Safe Calls
............................................

If an error is signaled in a safe call, the exact point of the signal
is implementation-dependent.  In particular, it might be signaled at
compile time or at run time, and if signaled at run time, it might be
prior to, during, or after executing the call.  However, it is always
prior to the execution of the body of the function being called.

3.5.1.2 Too Few Arguments
.........................

It is not permitted to supply too few arguments to a function.  Too few
arguments means fewer arguments than the number of required parameters
for the function.

If this situation occurs in a safe call, an error of type
ÿprogram-errorþ must be signaled; and in an unsafe call the situation
has undefined consequences.

3.5.1.3 Too Many Arguments
..........................

It is not permitted to supply too many arguments to a function.  Too
many arguments means more arguments than the number of required
parameters plus the number of optional parameters; however, if the
function uses ÿ&restþ or ÿ&keyþ, it is not possible for it to receive
too many arguments.

If this situation occurs in a safe call, an error of type
ÿprogram-errorþ must be signaled; and in an unsafe call the situation
has undefined consequences.

3.5.1.4 Unrecognized Keyword Arguments
......................................

It is not permitted to supply a keyword argument to a function using a
name that is not recognized by that function unless keyword argument
checking is suppressed as described in *Note Section 3.4.1.4.1
(Suppressing Keyword Argument Checking): SuppressingKeyArgChecks.

If this situation occurs in a safe call, an error of type
ÿprogram-errorþ must be signaled; and in an unsafe call the situation
has undefined consequences.

3.5.1.5 Invalid Keyword Arguments
.................................

It is not permitted to supply a keyword argument to a function using a
name that is not a symbol.

If this situation occurs in a safe call, an error of type
ÿprogram-errorþ must be signaled unless keyword argument checking is
suppressed as described in *Note Section 3.4.1.4.1 (Suppressing Keyword
Argument Checking): SuppressingKeyArgChecks.; and in an unsafe call the
situation has undefined consequences.

3.5.1.6 Odd Number of Keyword Arguments
.......................................

An odd number of arguments must not be supplied for the keyword
parameters.

If this situation occurs in a safe call, an error of type
ÿprogram-errorþ must be signaled unless keyword argument checking is
suppressed as described in *Note Section 3.4.1.4.1 (Suppressing Keyword
Argument Checking): SuppressingKeyArgChecks.; and in an unsafe call the
situation has undefined consequences.

3.5.1.7 Destructuring Mismatch
..............................

When matching a destructuring lambda list against a form, the pattern
and the form must have compatible tree structure, as described in *Note
Section 3.4.4 (Macro Lambda Lists): Macro Lambda Lists.

Otherwise, in a safe call, an error of type ÿprogram-errorþ must be
signaled; and in an unsafe call the situation has undefined
consequences.

3.5.1.8 Errors When Calling a Next Method
.........................................

If ÿcall-next-methodþ is called with arguments, the ordered set of
applicable methods for the changed set of arguments for
ÿcall-next-methodþ must be the same as the ordered set of applicable
methods for the original arguments to the generic function, or else an
error should be signaled.

The comparison between the set of methods applicable to the new
arguments and the set applicable to the original arguments is
insensitive to order differences among methods with the same
specializers.

If ÿcall-next-methodþ is called with arguments that specify a different
ordered set of applicable methods and there is no next method
available, the test for different methods and the associated error
signaling (when present) takes precedence over calling ÿno-next-methodþ.


File: chris-ansicl.info,  Node: Traversal Rules and Side Effects,  Next: Destructive Operations,  Prev: Error Checking in Function Calls,  Up: Evaluation and Compilation

3.6 Traversal Rules and Side Effects
====================================

The consequences are undefined when code executed during an
object-traversing operation destructively modifies the object in a way
that might affect the ongoing traversal operation.  In particular, the
following rules apply.

List traversal
     For list traversal operations, the cdr chain of the list is not
     allowed to be destructively modified.

Array traversal
     For array traversal operations, the array is not allowed to be
     adjusted and its fill pointer, if any, is not allowed to be
     changed.

Hash-table traversal
     For hash table traversal operations, new elements may not be added
     or deleted except that the element corresponding to the current
     hash key may be changed or removed.

Package traversal
     For package traversal operations (e.g., ÿdo-symbolsþ), new symbols
     may not be interned in or uninterned from the package being
     traversed or any package that it uses except that the current
     symbol may be uninterned from the package being traversed.


File: chris-ansicl.info,  Node: Destructive Operations,  Next: lambda (Symbol),  Prev: Traversal Rules and Side Effects,  Up: Evaluation and Compilation

3.7 Destructive Operations
==========================

* Menu:

* Modification of Literal Objects::
* Transfer of Control during a Destructive Operation::


File: chris-ansicl.info,  Node: Modification of Literal Objects,  Next: Transfer of Control during a Destructive Operation,  Up: Destructive Operations

3.7.1 Modification of Literal Objects
-------------------------------------

The consequences are undefined if literal objects are destructively
modified.  For this purpose, the following operations are considered
destructive:

ÿrandom-stateþ
     Using it as an argument to the function ÿrandomþ.

ÿconsþ
     Changing the cará or cdrá of the cons, or performing a destructive
     operation on an object which is either the carà or the cdrà of the
     cons.

ÿarrayþ
     Storing a new value into some element of the array, or performing
     a destructive operation on an object that is already such an
     element.

     Changing the fill pointer, dimensions, or displacement of the
     array (regardless of whether the array is actually adjustable).

     Performing a destructive operation on another array that is
     displaced to the array or that otherwise shares its contents with
     the array.

ÿhash-tableþ
     Performing a destructive operation on any key.

     Storing a new valueÞ for any key, or performing a destructive
     operation on any object that is such a value.

     Adding or removing entries from the hash table.

ÿstructure-objectþ
     Storing a new value into any slot, or performing a destructive
     operation on an object that is the value of some slot.

ÿstandard-objectþ
     Storing a new value into any slot, or performing a destructive
     operation on an object that is the value of some slot.

     Changing the class of the object (e.g., using the function
     ÿchange-classþ).

ÿreadtableþ
     Altering the readtable case.

     Altering the syntax type of any character in this readtable.

     Altering the reader macro function associated with any character
     in the readtable, or altering the reader macro functions
     associated with characters defined as dispatching macro characters
     in the readtable.

ÿstreamþ
     Performing I/O operations on the stream, or closing the stream.

All other standardized types
     [This category includes, for example, ÿcharacterþ, ÿconditionþ,
     ÿfunctionþ, ÿmethod-combinationþ, ÿmethodþ, ÿnumberþ, ÿpackageþ,
     ÿpathnameþ, ÿrestartþ, and ÿsymbolþ.]

     There are no standardized destructive operations defined on
     objects of these types.


File: chris-ansicl.info,  Node: Transfer of Control during a Destructive Operation,  Prev: Modification of Literal Objects,  Up: Destructive Operations

3.7.2 Transfer of Control during a Destructive Operation
--------------------------------------------------------

Should a transfer of control out of a destructive operation occur
(e.g., due to an error) the state of the OBJECT being modified is
implementation-dependent.

3.7.2.1 Examples of Transfer of Control during a Destructive Operation
......................................................................

The following examples illustrate some of the many ways in which the
implementation-dependent nature of the modification can manifest itself.

 (let ((a (list 2 1 4 3 7 6 'five)))
   (ignore-errors (sort a #'<))
   a)
ý (1 2 3 4 6 7 FIVE)
orý (2 1 4 3 7 6 FIVE)
orý (2)

 (prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))
   (sort a #'(lambda (x y) (if (zerop (random 5)) (return-from foo a) (> x y)))))
ý (1 2 3 4 5 6 7 8 9 10)
orý (3 4 5 6 2 7 8 9 10 1)
orý (1 2 4 3)


File: chris-ansicl.info,  Node: lambda (Symbol),  Next: lambda (Macro),  Prev: Destructive Operations,  Up: Evaluation and Compilation

lambda (Symbol)
===============

Syntax:
.......

 -- Special Form: lambda lambda-list ù{declaration}* | documentationø
          {form}*

Arguments:
..........

LAMBDA-LIST--an ordinary lambda list.

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORM--a form.

Description:
............

A lambda expression is a list that can be used in place of a function
name in certain contexts to denote a function by directly describing
its behavior rather than indirectly by referring to the name of an
established function.

DOCUMENTATION is attached to the denoted FUNCTION (if any is actually
created) as a documentation string.

See Also:
.........

*Note function (Special Operator)::, *Note documentation::, *Note
Section 3.1.3 (Lambda Expressions): Lambda Expressions, *Note Section
3.1.2.1.2.4 (Lambda Forms): LambdaForms, *Note Section 3.4.11
(Syntactic Interaction of Documentation Strings and Declarations):
Syntactic Interaction of Documentation Strings and Declarations.

Notes:
......

The lambda form

 ((lambda LAMBDA-LIST . BODY) . ARGUMENTS)

is semantically equivalent to the function form

 (funcall #'(lambda LAMBDA-LIST . BODY) . ARGUMENTS)


File: chris-ansicl.info,  Node: lambda (Macro),  Next: compile,  Prev: lambda (Symbol),  Up: Evaluation and Compilation

lambda (Macro)
==============

Syntax:
.......

 -- Macro: lambda lambda-list ù{declaration}* | documentationø {form}*
          ý FUNCTION

Arguments and Values:
.....................

LAMBDA-LIST--an ordinary lambda list.

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORM--a form.

FUNCTION--a function.

Description:
............

Provides a shorthand notation for a ÿfunctionþ special form involving a
lambda expression such that:

    (lambda LAMBDA-LIST ù{declaration}* | documentationø {form}*)
 Õ (function (lambda LAMBDA-LIST ù{declaration}* | documentationø {form}*))
 Õ #'(lambda LAMBDA-LIST ù{declaration}* | documentationø {form}*)

Examples:
.........

 (funcall (lambda (x) (+ x 3)) 4) ý 7

See Also:
.........

*Note lambda (Symbol):: (symbol)

Notes:
......

This macro could be implemented by:

(defmacro lambda (&whole form &rest bvl-decls-and-body)
  (declare (ignore bvl-decls-and-body))
  `#',form)


File: chris-ansicl.info,  Node: compile,  Next: eval,  Prev: lambda (Macro),  Up: Evaluation and Compilation

compile (Function)
==================

Syntax:
.......

 -- Function: compile name &optional definition ý function, warnings-p,
          failure-p

Arguments and Values:
.....................

NAME--a function name, or ÿnilþ.

DEFINITION--a lambda expression or a function.  The default is the
function definition of NAME if it names a function, or the macro
function of NAME if it names a macro.  The consequences are undefined
if no DEFINITION is supplied when the NAME is ÿnilþ.

FUNCTION--the FUNCTION-NAME, or a compiled function.

WARNINGS-P--a generalized boolean.

FAILURE-P--a generalized boolean.

Description:
............

Compiles an interpreted function.

ÿcompileþ produces a compiled function from DEFINITION.  If the
DEFINITION is a lambda expression, it is coerced to a function.  If the
DEFINITION is already a compiled function, ÿcompileþ either produces
that function itself (i.e., is an identity operation) or an equivalent
function.

If the NAME is ÿnilþ, the resulting compiled function is returned
directly as the primary value.  If a non-nil NAME is given, then the
resulting compiled function replaces the existing function definition
of NAME and the NAME is returned as the primary value; if NAME is a
symbol that names a macro, its macro function is updated and the NAME
is returned as the primary value.

Literal objects appearing in code processed by the ÿcompileþ function
are neither copied nor coalesced.  The code resulting from the
execution of ÿcompileþ references objects that are ÿeqlþ to the
corresponding objects in the source code.

ÿcompileþ is permitted, but not required, to establish a handler for
conditions of type ÿerrorþ.  For example, the handler might issue a
warning and restart compilation from some implementation-dependent point
in order to let the compilation proceed without manual intervention.

The secondary value, WARNINGS-P, is false if no conditions of type
ÿerrorþ or ÿwarningþ were detected by the compiler, and true otherwise.

The tertiary value, FAILURE-P, is false if no conditions of type
ÿerrorþ or ÿwarningþ (other than ÿstyle-warningþ) were detected by the
compiler, and true otherwise.

Examples:
.........

 (defun foo () "bar") ý FOO
 (compiled-function-p #'foo) ý implementation-dependent
 (compile 'foo) ý FOO
 (compiled-function-p #'foo) ý true
 (setf (symbol-function 'foo)
       (compile nil '(lambda () "replaced"))) ý #<Compiled-Function>
 (foo) ý "replaced"

Affected By:
............

ÿ*error-output*þ, ÿ*macroexpand-hook*þ.

The presence of macro definitions and proclamations.

Exceptional Situations:
.......................

The consequences are undefined if the lexical environment surrounding
the function to be compiled contains any bindings other than those for
macros, symbol macros, or declarations.

For information about errors detected during the compilation process,
see *Note Section 3.2.5 (Exceptional Situations in the Compiler):
Exceptional Situations in the Compiler.

See Also:
.........

*Note compile-file::


File: chris-ansicl.info,  Node: eval,  Next: eval-when,  Prev: compile,  Up: Evaluation and Compilation

eval (Function)
===============

Syntax:
.......

 -- Function: eval form ý {result}*

Arguments and Values:
.....................

FORM--a form.

RESULTS--the values yielded by the evaluation of FORM.

Description:
............

Evaluates FORM in the current dynamic environment and the null lexical
environment.

ÿevalþ is a user interface to the evaluator.

The evaluator expands macro calls as if through the use of
ÿmacroexpand-1þ.

Constants appearing in code processed by ÿevalþ are not copied nor
coalesced. The code resulting from the execution of ÿevalþ references
objects that are ÿeqlþ to the corresponding objects in the source code.

Examples:
.........

 (setq form '(1+ a) a 999) ý 999
 (eval form) ý 1000
 (eval 'form) ý (1+ A)
 (let ((a '(this would break if eval used local value))) (eval form))
ý 1000

See Also:
.........

*Note macroexpand-1::, *Note Section 3.1.2 (The Evaluation Model): The
Evaluation Model.

Notes:
......

To obtain the current dynamic value of a symbol, use of ÿsymbol-valueþ
is equivalent (and usually preferable) to use of ÿevalþ.

Note that an ÿevalþ form involves two levels of evaluation for its
argument.  First, FORM is evaluated by the normal argument evaluation
mechanism as would occur with any call.  The object that results from
this normal argument evaluation becomes the value of the FORM
parameter, and is then evaluated as part of the ÿevalþ form.  For
example:

 (eval (list 'cdr (car '((quote (a . b)) c)))) ý b

The argument form ÿ(list 'cdr (car '((quote (a . b)) c)))þ is evaluated
in the usual way to produce the argument ÿ(cdr (quote (a . b)))þ;
ÿevalþ then evaluates its argument, ÿ(cdr (quote (a . b)))þ, to produce
ÿbþ.  Since a single evaluation already occurs for any argument form in
any function form, ÿevalþ is sometimes said to perform "an extra level
of evaluation."


File: chris-ansicl.info,  Node: eval-when,  Next: load-time-value,  Prev: eval,  Up: Evaluation and Compilation

eval-when (Special Operator)
============================

Syntax:
.......

 -- Special Form: eval-when ({situation}*) {form}* ý {result}*

Arguments and Values:
.....................

SITUATION--One of the symbols :compile-toplevel , :load-toplevel ,
:execute , compile , load , or eval .

The use of eval, compile, and load is deprecated.

FORMS--an implicit progn.

RESULTS--the values of the forms if they are executed, or ÿnilþ if they
are not.

Description:
............

The body of an ÿeval-whenþ form is processed as an implicit progn, but
only in the SITUATIONS listed.

The use of the SITUATIONS :compile-toplevel (or ÿcompileþ) and
:load-toplevel (or ÿloadþ) controls whether and when evaluation occurs
when ÿeval-whenþ appears as a top level form in code processed by
ÿcompile-fileþ.  See *Note Section 3.2.3 (File Compilation): File
Compilation.

The use of the SITUATION :execute (or ÿevalþ) controls whether
evaluation occurs for other ÿeval-whenþ forms; that is, those that are
not top level forms, or those in code processed by ÿevalþ or ÿcompileþ.
If the :execute situation is specified in such a form, then the body
FORMS are processed as an implicit progn; otherwise, the ÿeval-whenþ
form returns ÿnilþ.

ÿeval-whenþ normally appears as a top level form, but it is meaningful
for it to appear as a non-top-level form.  However, the compile-time
side effects described in *Note Section 3.2 (Compilation): Compilation.
only take place when ÿeval-whenþ appears as a top level form.

Examples:
.........

One example of the use of ÿeval-whenþ is that for the compiler to be
able to read a file properly when it uses user-defined reader macros,
it is necessary to write

 (eval-when (:compile-toplevel :load-toplevel :execute)
   (set-macro-character #\$ #'(lambda (stream char)
                                (declare (ignore char))
                                (list 'dollar (read stream))))) ý T

This causes the call to ÿset-macro-characterþ to be executed in the
compiler's execution environment, thereby modifying its reader syntax
table.

;;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE
;;;     keyword is considered. At compile time, this has no effect.
;;;     At load time (if the LET is at toplevel), or at execution time
;;;     (if the LET is embedded in some other form which does not execute
;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which
;;;     returns 1.
 (let ((x 1))
   (eval-when (:execute :load-toplevel :compile-toplevel)
     (setf (symbol-function 'foo1) #'(lambda () x))))

;;;     If this expression occurs at the toplevel of a file to be compiled,
;;;     it has BOTH a compile time AND a load-time effect of setting
;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.
 (eval-when (:execute :load-toplevel :compile-toplevel)
   (let ((x 2))
     (eval-when (:execute :load-toplevel :compile-toplevel)
       (setf (symbol-function 'foo2) #'(lambda () x)))))

;;;     If this expression occurs at the toplevel of a file to be compiled,
;;;     it has BOTH a compile time AND a load-time effect of setting the
;;;     function cell of FOO3 to a function which returns 3.
 (eval-when (:execute :load-toplevel :compile-toplevel)
   (setf (symbol-function 'foo3) #'(lambda () 3)))

;;; #4: This always does nothing. It simply returns NIL.
 (eval-when (:compile-toplevel)
   (eval-when (:compile-toplevel)
     (print 'foo4)))

;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is
;;;     printed at compile time. If this form occurs in a non-top-level
;;;     position, nothing is printed at compile time. Regardless of context,
;;;     nothing is ever printed at load time or execution time.
 (eval-when (:compile-toplevel)
   (eval-when (:execute)
     (print 'foo5)))

;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is
;;;     printed at compile time.  If this form occurs in a non-top-level
;;;     position, nothing is printed at compile time. Regardless of context,
;;;     nothing is ever printed at load time or execution time.
 (eval-when (:execute :load-toplevel)
   (eval-when (:compile-toplevel)
     (print 'foo6)))

See Also:
.........

*Note compile-file::, *Note Section 3.2 (Compilation): Compilation.

Notes:
......

The following effects are logical consequences of the definition of
ÿeval-whenþ:

   * Execution of a single ÿeval-whenþ expression executes the body
     code at most once.

   * Macros intended for use in top level forms should be written so
     that side-effects are done by the forms in the macro expansion.
     The macro-expander itself should not do the side-effects.

     For example:

     Wrong:

      (defmacro foo ()
        (really-foo)
        `(really-foo))

     Right:

      (defmacro foo ()
        `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))

     Adherence to this convention means that such macros behave
     intuitively when appearing as non-top-level forms.

   * Placing a variable binding around an ÿeval-whenþ reliably captures
     the binding because the compile-time-too mode cannot occur (i.e.,
     introducing a variable binding means that the ÿeval-whenþ is not a
     top level form).  For example,

      (let ((x 3))
        (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))

     prints ÿ3þ at execution (i.e., load) time, and does not print
     anything at compile time.  This is important so that expansions of
     ÿdefunþ and ÿdefmacroþ can be done in terms of ÿeval-whenþ and can
     correctly capture the lexical environment.

      (defun bar (x) (defun foo () (+ x 3)))

     might expand into

      (defun bar (x)
        (progn (eval-when (:compile-toplevel)
                 (compiler::notice-function-definition 'foo '(x)))
               (eval-when (:execute :load-toplevel)
                 (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))

     which would be treated by the above rules the same as

      (defun bar (x)
        (setf (symbol-function 'foo) #'(lambda () (+ x 3))))

     when the definition of ÿbarþ is not a top level form.


File: chris-ansicl.info,  Node: load-time-value,  Next: quote,  Prev: eval-when,  Up: Evaluation and Compilation

load-time-value (Special Operator)
==================================

Syntax:
.......

 -- Special Form: load-time-value form &optional read-only-p ý object

Arguments and Values:
.....................

FORM--a form; evaluated as described below.

READ-ONLY-P--a boolean; not evaluated.

OBJECT--the primary value resulting from evaluating FORM.

Description:
............

ÿload-time-valueþ provides a mechanism for delaying evaluation of FORM
until the expression is in the run-time environment; see *Note Section
3.2 (Compilation): Compilation.

READ-ONLY-P designates whether the result can be considered a constant
object.  If ÿtþ, the result is a read-only quantity that can, if
appropriate to the implementation, be copied into read-only space
and/or coalesced with similar constant objects from other programs.  If
ÿnilþ (the default), the result must be neither copied nor coalesced;
it must be considered to be potentially modifiable data.

If a ÿload-time-valueþ expression is processed by ÿcompile-fileþ, the
compiler performs its normal semantic processing (such as macro
expansion and translation into machine code) on FORM, but arranges for
the execution of FORM to occur at load time in a null lexical
environment, with the result of this evaluation then being treated as a
literal object at run time.  It is guaranteed that the evaluation of
FORM will take place only once when the file is loaded, but the order
of evaluation with respect to the evaluation of top level forms in the
file is implementation-dependent.  

If a ÿload-time-valueþ expression appears within a function compiled
with ÿcompileþ, the FORM is evaluated at compile time in a null lexical
environment.  The result of this compile-time evaluation is treated as
a literal object in the compiled code.

If a ÿload-time-valueþ expression is processed by ÿevalþ, FORM is
evaluated in a null lexical environment, and one value is returned.
Implementations that implicitly compile (or partially compile)
expressions processed by ÿevalþ might evaluate FORM only once, at the
time this compilation is performed.

If the same list ÿ(load-time-value FORM)þ is evaluated or compiled more
than once, it is implementation-dependent whether FORM is evaluated
only once or is evaluated more than once.  This can happen both when an
expression being evaluated or compiled shares substructure, and when
the same form is processed by ÿevalþ or ÿcompileþ multiple times.
Since a ÿload-time-valueþ expression can be referenced in more than one
place and can be evaluated multiple times by ÿevalþ, it is
implementation-dependent whether each execution returns a fresh object
or returns the same object as some other execution.  Users must use
caution when destructively modifying the resulting object.

If two lists ÿ(load-time-value FORM)þ that are the same under ÿequalþ
but are not identical are evaluated or compiled, their values always
come from distinct evaluations of FORM.  Their values may not be
coalesced unless READ-ONLY-P is ÿtþ.

Examples:
.........

;;; The function INCR1 always returns the same value, even in different images.
;;; The function INCR2 always returns the same value in a given image,
;;; but the value it returns might vary from image to image.
(defun incr1 (x) (+ x #.(random 17)))
(defun incr2 (x) (+ x (load-time-value (random 17))))

;;; The function FOO1-REF references the nth element of the first of
;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for
;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the
;;; updated values.
(defvar *foo-arrays* (list (make-array 7) (make-array 8)))
(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))
(defun set-foo1-ref (n val)
  (setf (aref (load-time-value (first *my-arrays*) nil) n) val))

;;; The function BAR1-REF references the nth element of the first of
;;; the *BAR-ARRAYS* that is available at load time.  The programmer has
;;; promised that the array will be treated as read-only, so the system
;;; can copy or coalesce the array.
(defvar *bar-arrays* (list (make-array 7) (make-array 8)))
(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))

;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified, because the object was already read-only
;;; when it was written as a literal vector rather than created by a constructor.
;;; User programs must treat the vector v as read-only.
(defun baz-ref (n)
  (let ((v (load-time-value #(A B C) nil)))
    (values (svref v n) v)))

;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified in the outer situation because T was specified
;;; in the inner situation.  User programs must treat the vector v as read-only.
(defun baz-ref (n)
  (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))
    (values (svref v n) v)))

See Also:
.........

*Note compile-file::, *Note compile::, *Note eval::, *Note Section
3.2.2.2 (Minimal Compilation): MinimalCompilation, *Note Section 3.2
(Compilation): Compilation.

Notes:
......

ÿload-time-valueþ must appear outside of quoted structure in a "for
evaluation" position.  In situations which would appear to call for use
of ÿload-time-valueþ within a quoted structure, the backquote reader
macro is probably called for; see *Note Section 2.4.6 (Backquote):
Backquote.

Specifying ÿnilþ for READ-ONLY-P is not a way to force an object to
become modifiable if it has already been made read-only.  It is only a
way to say that, for an object that is modifiable, this operation is
not intended to make that object read-only.


File: chris-ansicl.info,  Node: quote,  Next: compiler-macro-function,  Prev: load-time-value,  Up: Evaluation and Compilation

quote (Special Operator)
========================

Syntax:
.......

 -- Special Form: quote object ý object

Arguments and Values:
.....................

OBJECT--an object; not evaluated.

Description:
............

The ÿquoteþ special operator just returns OBJECT.

The consequences are undefined if literal objects (including quoted
objects) are destructively modified.

Examples:
.........

 (setq a 1) ý 1
 (quote (setq a 3)) ý (SETQ A 3)
 a ý 1
 'a ý A
 ''a ý (QUOTE A)
 '''a ý (QUOTE (QUOTE A))
 (setq a 43) ý 43
 (list a (cons a 3)) ý (43 (43 . 3))
 (list (quote a) (quote (cons a 3))) ý (A (CONS A 3))
 1 ý 1
 '1 ý 1
 "foo" ý "foo"
 '"foo" ý "foo"
 (car '(a b)) ý A
 '(car '(a b)) ý (CAR (QUOTE (A B)))
 #(car '(a b)) ý #(CAR (QUOTE (A B)))
 '#(car '(a b)) ý #(CAR (QUOTE (A B)))

See Also:
.........

*Note Section 3.1 (Evaluation): Evaluation, *Note Section 2.4.3
(Single-Quote): Single-Quote, *Note Section 3.2.1 (Compiler
Terminology): Compiler Terminology.

Notes:
......

The textual notation ÿ'OBJECTþ is equivalent to ÿ(quote OBJECT)þ; see
*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology.

Some objects, called self-evaluating objects, do not require quotation
by ÿquoteþ.  However, symbols and lists are used to represent parts of
programs, and so would not be useable as constant data in a program
without ÿquoteþ.  Since ÿquoteþ suppresses the evaluation of these
objects, they become data rather than program.


File: chris-ansicl.info,  Node: compiler-macro-function,  Next: define-compiler-macro,  Prev: quote,  Up: Evaluation and Compilation

compiler-macro-function (Accessor)
==================================

Syntax:
.......

 -- Function: compiler-macro-function name &optional environment ý
          function

(setf (compiler-macro-function name &optional environment) new-function)

Arguments and Values:
.....................

NAME--a function name.

ENVIRONMENT--an environment object.

FUNCTION, NEW-FUNCTION--a compiler macro function, or ÿnilþ.

Description:
............

Accesses the compiler macro function named NAME, if any, in the
ENVIRONMENT.

A value of ÿnilþ denotes the absence of a compiler macro function named
NAME.

Exceptional Situations:
.......................

The consequences are undefined if ENVIRONMENT is non-nil in a use of
ÿsetfþ of ÿcompiler-macro-functionþ.

See Also:
.........

*Note define-compiler-macro::, *Note Section 3.2.2.1 (Compiler Macros):
CompilerMacros.


File: chris-ansicl.info,  Node: define-compiler-macro,  Next: defmacro,  Prev: compiler-macro-function,  Up: Evaluation and Compilation

define-compiler-macro (Macro)
=============================

Syntax:
.......

 -- Macro: define-compiler-macro name lambda-list ù{declaration}* |
          documentationø {form}* ý name

Arguments and Values:
.....................

NAME--a function name.

LAMBDA-LIST--a macro lambda list.

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORM--a form.

Description:
............

This is the normal mechanism for defining a compiler macro function.
Its manner of definition is the same as for ÿdefmacroþ; the only
differences are:

   * The NAME can be a function name naming any function or macro.

   * The expander function is installed as a compiler macro function
     for the NAME, rather than as a macro function.

   * The ÿ&wholeþ argument is bound to the form argument that is passed
     to the compiler macro function.  The remaining lambda-list
     parameters are specified as if this form contained the function
     name in the car and the actual arguments in the cdr, but if the car
     of the actual form is the symbol ÿfuncallþ, then the destructuring
     of the arguments is actually performed using its cddr instead.

     DOCUMENTATION is attached as a documentation string to NAME (as
     kind ÿcompiler-macroþ) and to the compiler macro function.

   * Unlike an ordinary macro, a compiler macro can decline to provide
     an expansion merely by returning a form that is the same as the
     original (which can be obtained by using ÿ&wholeþ).

Examples:
.........

 (defun square (x) (expt x 2)) ý SQUARE
 (define-compiler-macro square (&whole form arg)
   (if (atom arg)
       `(expt ,arg 2)
       (case (car arg)
         (square (if (= (length arg) 2)
                     `(expt ,(nth 1 arg) 4)
                     form))
         (expt   (if (= (length arg) 3)
                     (if (numberp (nth 2 arg))
                         `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))
                         `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))
                     form))
         (otherwise `(expt ,arg 2))))) ý SQUARE
 (square (square 3)) ý 81
 (macroexpand '(square x)) ý (SQUARE X), false
 (funcall (compiler-macro-function 'square) '(square x) nil)
ý (EXPT X 2)
 (funcall (compiler-macro-function 'square) '(square (square x)) nil)
ý (EXPT X 4)
 (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)
ý (EXPT X 2)

 (defun distance-positional (x1 y1 x2 y2)
   (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))
ý DISTANCE-POSITIONAL
 (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))
   (distance-positional x1 y1 x2 y2))
ý DISTANCE
 (define-compiler-macro distance (&whole form
                                  &rest key-value-pairs
                                  &key (x1 0  x1-p)
                                       (y1 0  y1-p)
                                       (x2 x1 x2-p)
                                       (y2 y1 y2-p)
                                  &allow-other-keys
                                  &environment env)
   (flet ((key (n) (nth (* n 2) key-value-pairs))
          (arg (n) (nth (1+ (* n 2)) key-value-pairs))
          (simplep (x)
            (let ((expanded-x (macroexpand x env)))
              (or (constantp expanded-x env)
                  (symbolp expanded-x)))))
     (let ((n (/ (length key-value-pairs) 2)))
       (multiple-value-bind (x1s y1s x2s y2s others)
           (loop for (key) on key-value-pairs by #'cddr
                 count (eq key ':x1) into x1s
                 count (eq key ':y1) into y1s
                 count (eq key ':x2) into x2s
                 count (eq key ':y1) into y2s
                 count (not (member key '(:x1 :x2 :y1 :y2)))
                   into others
                 finally (return (values x1s y1s x2s y2s others)))
         (cond ((and (= n 4)
                     (eq (key 0) :x1)
                     (eq (key 1) :y1)
                     (eq (key 2) :x2)
                     (eq (key 3) :y2))
                `(distance-positional ,x1 ,y1 ,x2 ,y2))
               ((and (if x1-p (and (= x1s 1) (simplep x1)) t)
                     (if y1-p (and (= y1s 1) (simplep y1)) t)
                     (if x2-p (and (= x2s 1) (simplep x2)) t)
                     (if y2-p (and (= y2s 1) (simplep y2)) t)
                     (zerop others))
                `(distance-positional ,x1 ,y1 ,x2 ,y2))
               ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)
                     (zerop others))
                (let ((temps (loop repeat n collect (gensym))))
                  `(let ,(loop for i below n
                               collect (list (nth i temps) (arg i)))
                     (distance
                       ,@(loop for i below n
                               append (list (key i) (nth i temps)))))))
               (t form))))))
ý DISTANCE
 (dolist (form
           '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))
             (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))
             (distance :x1 (setq x 7) :y1 (incf x))
             (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))
             (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)
             (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)
             (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))
   (print (funcall (compiler-macro-function 'distance) form nil)))
Ö (LET ((#:G6558 (SETQ X 7))
Ö       (#:G6559 (DECF X))
Ö       (#:G6560 (DECF X))
Ö       (#:G6561 (DECF X)))
Ö   (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561))
Ö (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))
Ö (LET ((#:G6567 (SETQ X 7))
Ö       (#:G6568 (INCF X)))
Ö   (DISTANCE :X1 #:G6567 :Y1 #:G6568))
Ö (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X))
Ö (DISTANCE-POSITIONAL A1 B1 A2 B2)
Ö (DISTANCE-POSITIONAL A1 B1 A2 B2)
Ö (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2)
ý NIL

See Also:
.........

*Note compiler-macro-function::, *Note defmacro::, *Note
documentation::, *Note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

The consequences of writing a compiler macro definition for a function
in the ÿCOMMON-LISPþ package are undefined; it is quite possible that
in some implementations such an attempt would override an equivalent or
equally important definition.  In general, it is recommended that a
programmer only write compiler macro definitions for functions he or
she personally maintains-writing a compiler macro definition for a
function maintained elsewhere is normally considered a violation of
traditional rules of modularity and data abstraction.


File: chris-ansicl.info,  Node: defmacro,  Next: macro-function,  Prev: define-compiler-macro,  Up: Evaluation and Compilation

defmacro (Macro)
================

Syntax:
.......

 -- Macro: defmacro name lambda-list ù{declaration}* | documentationø
          {form}* ý name

Arguments and Values:
.....................

NAME--a symbol.

LAMBDA-LIST--a macro lambda list.

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORM--a form.

Description:
............

Defines NAME as a macro by associating a macro function with that NAME
in the global environment.  The macro function is defined in the same
lexical environment in which the ÿdefmacroþ form appears.

The parameter variables in LAMBDA-LIST are bound to destructured
portions of the macro call.

The expansion function accepts two arguments, a form and an
environment.  The expansion function returns a form.  The body of the
expansion function is specified by FORMS.  FORMS are executed in order.
The value of the last FORM executed is returned as the expansion of the
macro.  The body FORMS of the expansion function (but not the
LAMBDA-LIST) are implicitly enclosed in a block whose name is NAME.

The LAMBDA-LIST conforms to the requirements described in *Note Section
3.4.4 (Macro Lambda Lists): Macro Lambda Lists.

DOCUMENTATION is attached as a documentation string to NAME (as kind
ÿfunctionþ) and to the macro function.

ÿdefmacroþ can be used to redefine a macro or to replace a function
definition with a macro definition.

Recursive expansion of the form returned must terminate, including the
expansion of other macros which are subforms of other forms returned.

The consequences are undefined if the result of fully macroexpanding a
form contains any circular list structure except in literal objects.

If a ÿdefmacroþ form appears as a top level form, the compiler must
store the macro definition at compile time, so that occurrences of the
macro later on in the file can be expanded correctly.  Users must
ensure that the body of the macro can be evaluated at compile time if
it is referenced within the file being compiled.

Examples:
.........

 (defmacro mac1 (a b) "Mac1 multiplies and adds"
            `(+ ,a (* ,b 3))) ý MAC1
 (mac1 4 5) ý 19
 (documentation 'mac1 'function) ý "Mac1 multiplies and adds"
 (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) ý MAC2
 (mac2 6) ý (6 T 3 NIL NIL)
 (mac2 6 3 8) ý (6 T 3 T (8))
 (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))
    `'(,r ,a ,b ,c ,d ,x)) ý MAC3
 (mac3 1 6 :d 8 :c 9 :d 10) ý ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10))

The stipulation that an embedded destructuring lambda list is permitted
only where ordinary lambda list syntax would permit a parameter name
but not a list is made to prevent ambiguity.  For example, the
following is not valid:

 (defmacro loser (x &optional (a b &rest c) &rest z)
   ...)

because ordinary lambda list syntax does permit a list following
&optional; the list ÿ(a b &rest c)þ would be interpreted as describing
an optional parameter named ÿaþ whose default value is that of the form
ÿbþ, with a supplied-p parameter named ÿ&restþ (not valid), and an
extraneous symbol ÿcþ in the list (also not valid).  An almost correct
way to express this is

 (defmacro loser (x &optional ((a b &rest c)) &rest z)
   ...)

The extra set of parentheses removes the ambiguity.  However, the
definition is now incorrect because a macro call such as ÿ(loser (car
pool))þ would not provide any argument form for the lambda list ÿ(a b
&rest c)þ, and so the default value against which to match the lambda
list would be ÿnilþ because no explicit default value was specified.
The consequences of this are  unspecified since the empty list, ÿnilþ,
does not have forms to satisfy the parameters ÿaþ and ÿbþ.  The fully
correct definition would be either

 (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)
   ...)

or

 (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)
   ...)

These differ slightly: the first requires that if the macro call
specifies ÿaþ explicitly then it must also specify ÿbþ explicitly,
whereas the second does not have this requirement.  For example,

 (loser (car pool) ((+ x 1)))

would be a valid call for the second definition but not for the first.

 (defmacro dm1a (&whole x) `',x)
 (macroexpand '(dm1a))  ý (QUOTE (DM1A))
 (macroexpand '(dm1a a)) is an error.

 (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))
 (macroexpand '(dm1b))  is an error.
 (macroexpand '(dm1b q))  ý (QUOTE ((DM1B Q) Q NIL))
 (macroexpand '(dm1b q r)) ý (QUOTE ((DM1B Q R) Q R))
 (macroexpand '(dm1b q r s)) is an error.

 (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))
 (macroexpand '(dm2a x y)) ý (QUOTE (FORM (DM2A X Y) A X B Y))
 (dm2a x y) ý (FORM (DM2A X Y) A X B Y)

 (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5))
                 &body f &environment env)
   ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))
 ;Note that because backquote is involved, implementations may differ
 ;slightly in the nature (though not the functionality) of the expansion.
 (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))
 ý (LIST* '(DM2B X1 (((INCF X2) X3 X4))
                   X5 X6)
            X1
            '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),
     T
 (let ((x1 5))
   (macrolet ((segundo (x) `(cadr ,x)))
     (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))
 ý ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)
      5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))

See Also:
.........

*Note define-compiler-macro::, *Note destructuring-bind::, *Note
documentation::, *Note macroexpand::, *Note *macroexpand-hook*::, *Note
macrolet::, *Note macro-function::, *Note Section 3.1 (Evaluation):
Evaluation, *Note Section 3.2 (Compilation): Compilation, *Note Section
3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations): Syntactic Interaction of Documentation Strings and
Declarations.


File: chris-ansicl.info,  Node: macro-function,  Next: macroexpand; macroexpand-1,  Prev: defmacro,  Up: Evaluation and Compilation

macro-function (Accessor)
=========================

Syntax:
.......

 -- Function: macro-function symbol &optional environment ý function

(setf (macro-function symbol &optional environment) new-function)

Arguments and Values:
.....................

SYMBOL--a symbol.

ENVIRONMENT--an environment object.

FUNCTION--a macro function or ÿnilþ.

NEW-FUNCTION--a macro function.

Description:
............

Determines whether SYMBOL has a function definition as a macro in the
specified ENVIRONMENT.

If so, the macro expansion function, a function of two arguments, is
returned.  If SYMBOL has no function definition in the lexical
environment ENVIRONMENT, or its definition is not a macro,
ÿmacro-functionþ returns ÿnilþ.

It is possible for both ÿmacro-functionþ and ÿspecial-operator-pþ to
return true of SYMBOL.  The macro definition must be available for use
by programs that understand only the standard Common Lisp special forms.

Examples:
.........

 (defmacro macfun (x) '(macro-function 'macfun)) ý MACFUN
 (not (macro-function 'macfun)) ý false

 (macrolet ((foo (&environment env)
               (if (macro-function 'bar env)
                  ''yes
                  ''no)))
    (list (foo)
          (macrolet ((bar () :beep))
             (foo))))

ý (NO YES)

Affected By:
............

ÿ(setf macro-function)þ, ÿdefmacroþ, and ÿmacroletþ.

Exceptional Situations:
.......................

The consequences are undefined if ENVIRONMENT is non-nil in a use of
ÿsetfþ of ÿmacro-functionþ.

See Also:
.........

*Note defmacro::, *Note Section 3.1 (Evaluation): Evaluation.

Notes:
......

ÿsetfþ can be used with ÿmacro-functionþ to install a macro as a
symbol's global function definition:

 (setf (macro-function symbol) fn)

The value installed must be a function that accepts two arguments, the
entire macro call and an environment, and computes the expansion for
that call.  Performing this operation causes SYMBOL to have only that
macro definition as its global function definition; any previous
definition, whether as a macro or as a function, is lost.


File: chris-ansicl.info,  Node: macroexpand; macroexpand-1,  Next: define-symbol-macro,  Prev: macro-function,  Up: Evaluation and Compilation

macroexpand, macroexpand-1 (Function)
=====================================

Syntax:
.......

 -- Function: macroexpand form &optional env ý expansion, expanded-p

 -- Function: macroexpand-1 form &optional env ý expansion, expanded-p

Arguments and Values:
.....................

FORM--a form.

ENV--an environment object.  The default is ÿnilþ.

EXPANSION--a form.

EXPANDED-P--a generalized boolean.

Description:
............

ÿmacroexpandþ and ÿmacroexpand-1þ expand macros.

If FORM is a macro form, then ÿmacroexpand-1þ expands the macro form
call once.

ÿmacroexpandþ repeatedly expands FORM until it is no longer a macro
form.  In effect, ÿmacroexpandþ calls ÿmacroexpand-1þ repeatedly until
the secondary value it returns is ÿnilþ.

If FORM is a macro form, then the EXPANSION is a macro expansion and
EXPANDED-P is true.  Otherwise, the EXPANSION is the given FORM and
EXPANDED-P is false.

Macro expansion is carried out as follows.  Once ÿmacroexpand-1þ has
determined that the FORM is a macro form, it obtains an appropriate
expansion function for the macro or symbol macro.  The value of
ÿ*macroexpand-hook*þ is coerced to a function and then called as a
function of three arguments: the expansion function, the FORM, and the
ENV.  The value returned from this call is taken to be the expansion of
the FORM.

In addition to macro definitions in the global environment, any local
macro definitions established within ENV by ÿmacroletþ or
ÿsymbol-macroletþ are considered.  If only FORM is supplied as an
argument, then the environment is effectively null, and only global
macro definitions as established by ÿdefmacroþ are considered.  Macro
definitions are shadowed by local function definitions.

Examples:
.........

 (defmacro alpha (x y) `(beta ,x ,y)) ý ALPHA
 (defmacro beta (x y) `(gamma ,x ,y)) ý BETA
 (defmacro delta (x y) `(gamma ,x ,y)) ý EPSILON
 (defmacro expand (form &environment env)
   (multiple-value-bind (expansion expanded-p)
       (macroexpand form env)
     `(values ',expansion ',expanded-p))) ý EXPAND
 (defmacro expand-1 (form &environment env)
   (multiple-value-bind (expansion expanded-p)
       (macroexpand-1 form env)
     `(values ',expansion ',expanded-p))) ý EXPAND-1


;; Simple examples involving just the global environment
 (macroexpand-1 '(alpha a b)) ý (BETA A B), true
 (expand-1 (alpha a b)) ý (BETA A B), true
 (macroexpand '(alpha a b)) ý (GAMMA A B), true
 (expand (alpha a b)) ý (GAMMA A B), true
 (macroexpand-1 'not-a-macro) ý NOT-A-MACRO, false
 (expand-1 not-a-macro) ý NOT-A-MACRO, false
 (macroexpand '(not-a-macro a b)) ý (NOT-A-MACRO A B), false
 (expand (not-a-macro a b)) ý (NOT-A-MACRO A B), false


;; Examples involving lexical environments
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (macroexpand-1 '(alpha a b))) ý (BETA A B), true
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (expand-1 (alpha a b))) ý (DELTA A B), true
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (macroexpand '(alpha a b))) ý (GAMMA A B), true
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (expand (alpha a b))) ý (GAMMA A B), true
 (macrolet ((beta (x y) `(epsilon ,x ,y)))
   (expand (alpha a b))) ý (EPSILON A B), true
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (expand a))) ý (FIRST X), true
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (macroexpand 'a))) ý A, false
 (symbol-macrolet ((b (alpha x y)))
   (expand-1 b)) ý (ALPHA X Y), true
 (symbol-macrolet ((b (alpha x y)))
   (expand b)) ý (GAMMA X Y), true
 (symbol-macrolet ((b (alpha x y))
                   (a b))
   (expand-1 a)) ý B, true
 (symbol-macrolet ((b (alpha x y))
                   (a b))
   (expand a)) ý (GAMMA X Y), true


;; Examples of shadowing behavior
 (flet ((beta (x y) (+ x y)))
   (expand (alpha a b))) ý (BETA A B), true
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (flet ((alpha (x y) (+ x y)))
     (expand (alpha a b)))) ý (ALPHA A B), false
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (let ((a x))
       (expand a)))) ý A, false

Affected By:
............

ÿdefmacroþ, ÿsetfþ of ÿmacro-functionþ, ÿmacroletþ, ÿsymbol-macroletþ

See Also:
.........

*Note *macroexpand-hook*::, *Note defmacro::, *Note setf:: of *Note
macro-function::, *Note macrolet::, *Note symbol-macrolet::, *Note
Section 3.1 (Evaluation): Evaluation.

Notes:
......

Neither ÿmacroexpandþ nor ÿmacroexpand-1þ makes any explicit attempt to
expand macro forms that are either subforms of the FORM or subforms of
the EXPANSION.  Such expansion might occur implicitly, however, due to
the semantics or implementation of the macro function.


File: chris-ansicl.info,  Node: define-symbol-macro,  Next: symbol-macrolet,  Prev: macroexpand; macroexpand-1,  Up: Evaluation and Compilation

define-symbol-macro (Macro)
===========================

Syntax:
.......

 -- Macro: define-symbol-macro symbol expansion ý symbol

Arguments and Values:
.....................

SYMBOL--a symbol.

EXPANSION--a form.

Description:
............

Provides a mechanism for globally affecting the macro expansion of the
indicated SYMBOL.

Globally establishes an expansion function for the symbol macro named
by SYMBOL.  The only guaranteed property of an expansion function for a
symbol macro is that when it is applied to the form and the environment
it returns the correct expansion.  (In particular, it is
implementation-dependent whether the expansion is conceptually stored
in the expansion function, the environment, or both.)

Each global reference to SYMBOL (i.e., not shadowedà by a binding for a
variable or symbol macro named by the same symbol) is expanded by the
normal macro expansion process; see *Note Section 3.1.2.1.1 (Symbols as
Forms): SymbolsAsForms.  The expansion of a symbol macro is subject to
further macro expansion in the same lexical environment as the symbol
macro reference, exactly analogous to normal macros.

The consequences are unspecified if a ÿspecialþ declaration is made for
SYMBOL while in the scope of this definition (i.e., when it is not
shadowedà by a binding for a variable or symbol macro named by the same
symbol).

Any use of ÿsetqþ to set the value of the SYMBOL while in the scope of
this definition is treated as if it were a ÿsetfþ.  ÿpsetqþ of SYMBOL
is treated as if it were a ÿpsetfþ, and ÿmultiple-value-setqþ is
treated as if it were a ÿsetfþ of ÿvaluesþ.

A binding for a symbol macro can be shadowedà by ÿletþ or
ÿsymbol-macroletþ.

Examples:
.........

(defvar *things* (list 'alpha 'beta 'gamma)) ý *THINGS*

(define-symbol-macro thing1 (first *things*)) ý THING1
(define-symbol-macro thing2 (second *things*)) ý THING2
(define-symbol-macro thing3 (third *things*)) ý THING3

thing1 ý ALPHA
(setq thing1 'ONE) ý ONE
*things* ý (ONE BETA GAMMA)
(multiple-value-setq (thing2 thing3) (values 'two 'three)) ý TWO
thing3 ý THREE
*things* ý (ONE TWO THREE)

(list thing2 (let ((thing2 2)) thing2)) ý (TWO 2)

Exceptional Situations:
.......................

If SYMBOL is already defined as a global variable, an error of type
ÿprogram-errorþ is signaled.

See Also:
.........

*Note symbol-macrolet::, *Note macroexpand::


File: chris-ansicl.info,  Node: symbol-macrolet,  Next: *macroexpand-hook*,  Prev: define-symbol-macro,  Up: Evaluation and Compilation

symbol-macrolet (Special Operator)
==================================

Syntax:
.......

 -- Special Form: symbol-macrolet ({(symbol expansion)}*)
          {declaration}* {form}* ý {result}*

Arguments and Values:
.....................

SYMBOL--a symbol.

EXPANSION--a form.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

ÿsymbol-macroletþ provides a mechanism for affecting the macro
expansion environment for symbols.

ÿsymbol-macroletþ lexically establishes expansion functions for each of
the symbol macros named by SYMBOLS.  The only guaranteed property of an
expansion function for a symbol macro is that when it is applied to the
form and the environment it returns the correct expansion.  (In
particular, it is implementation-dependent whether the expansion is
conceptually stored in the expansion function, the environment, or
both.)

Each reference to SYMBOL as a variable within the lexical scope of
ÿsymbol-macroletþ is expanded by the normal macro expansion process;
see *Note Section 3.1.2.1.1 (Symbols as Forms): SymbolsAsForms.  The
expansion of a symbol macro is subject to further macro expansion in
the same lexical environment as the symbol macro invocation, exactly
analogous to normal macros.

Exactly the same DECLARATIONS are allowed as for ÿletþ with one
exception: ÿsymbol-macroletþ signals an error if a ÿspecialþ
declaration names one of the symbols being defined by ÿsymbol-macroletþ.

When the FORMS of the ÿsymbol-macroletþ form are expanded, any use of
ÿsetqþ to set the value of one of the specified variables is treated as
if it were a ÿsetfþ.  ÿpsetqþ of a symbol defined as a symbol macro is
treated as if it were a ÿpsetfþ, and ÿmultiple-value-setqþ is treated
as if it were a ÿsetfþ of ÿvaluesþ.

The use of ÿsymbol-macroletþ can be shadowed by ÿletþ.  In other words,
ÿsymbol-macroletþ only substitutes for occurrences of SYMBOL that would
be in the scope of a lexical binding of SYMBOL surrounding the FORMS.

Examples:
.........

;;; The following is equivalent to
;;;   (list 'foo (let ((x 'bar)) x)),
;;; not
;;;   (list 'foo (let (('foo 'bar)) 'foo))
 (symbol-macrolet ((x 'foo))
   (list x (let ((x 'bar)) x)))
ý (foo bar)
notý (foo foo)

 (symbol-macrolet ((x '(foo x)))
   (list x))
ý ((FOO X))

Exceptional Situations:
.......................

If an attempt is made to bind a symbol that is defined as a global
variable, an error of type ÿprogram-errorþ is signaled.

If DECLARATION contains a ÿspecialþ declaration that names one of the
symbols being bound by ÿsymbol-macroletþ, an error of type
ÿprogram-errorþ is signaled.

See Also:
.........

*Note with-slots::, *Note macroexpand::

Notes:
......

The special form ÿsymbol-macroletþ is the basic mechanism that is used
to implement ÿwith-slotsþ.

If a ÿsymbol-macroletþ form is a top level form, the FORMS are also
processed as top level forms.  See *Note Section 3.2.3 (File
Compilation): File Compilation.


File: chris-ansicl.info,  Node: *macroexpand-hook*,  Next: proclaim,  Prev: symbol-macrolet,  Up: Evaluation and Compilation

*macroexpand-hook* (Variable)
=============================

Value Type:
...........

a designator for a function of three arguments: a macro function, a
macro form, and an environment object.

Initial Value:
..............

a designator for a function that is equivalent to the function
ÿfuncallþ, but that might have additional implementation-dependent
side-effects.

Description:
............

Used as the expansion interface hook by ÿmacroexpand-1þ to control the
macro expansion process.  When a macro form is to be expanded, this
function is called with three arguments: the macro function, the macro
form, and the environment in which the macro form is to be expanded.
The environment object has dynamic extent; the consequences are
undefined if the environment object is referred to outside the dynamic
extent of the macro expansion function.

Examples:
.........

 (defun hook (expander form env)
    (format t "Now expanding: ~S~%" form)
    (funcall expander form env)) ý HOOK
 (defmacro machook (x y) `(/ (+ ,x ,y) 2)) ý MACHOOK
 (macroexpand '(machook 1 2)) ý (/ (+ 1 2) 2), true
 (let ((*macroexpand-hook* #'hook)) (macroexpand '(machook 1 2)))
Ö Now expanding (MACHOOK 1 2)
ý (/ (+ 1 2) 2), true

See Also:
.........

*Note macroexpand::, *Note macroexpand-1::, *Note funcall::, *Note
Section 3.1 (Evaluation): Evaluation.

Notes:
......

The net effect of the chosen initial value is to just invoke the macro
function, giving it the macro form and environment as its two arguments.

Users or user programs can assign this variable to customize or trace
the macro expansion mechanism.  Note, however, that this variable is a
global resource, potentially shared by multiple programs; as such, if
any two programs depend for their correctness on the setting of this
variable, those programs may not be able to run in the same Lisp image.
For this reason, it is frequently best to confine its uses to debugging
situations.

Users who put their own function into ÿ*macroexpand-hook*þ should
consider saving the previous value of the hook, and calling that value
from their own.


File: chris-ansicl.info,  Node: proclaim,  Next: declaim,  Prev: *macroexpand-hook*,  Up: Evaluation and Compilation

proclaim (Function)
===================

Syntax:
.......

 -- Function: proclaim declaration-specifier ý implementation-dependent

Arguments and Values:
.....................

DECLARATION-SPECIFIER--a declaration specifier.

Description:
............

Establishes the declaration specified by DECLARATION-SPECIFIER in the
global environment.

Such a declaration, sometimes called a global declaration or a
proclamation, is always in force unless locally shadowed.

Names of variables and functions within DECLARATION-SPECIFIER refer to
dynamic variables and global function definitions, respectively.

The next figure shows a list of DECLARATION IDENTIFIERS that can be
used with ÿproclaimþ.

declaration   inline      optimize   type
ftype         notinline   special    

Figure 3.22: Global Declaration Specifiers

An implementation is free to support other (implementation-defined)
declaration identifiers as well.

Examples:
.........

 (defun declare-variable-types-globally (type vars)
   (proclaim `(type ,type ,@vars))
   type)

 ;; Once this form is executed, the dynamic variable *TOLERANCE*
 ;; must always contain a float.
 (declare-variable-types-globally 'float '(*tolerance*))
ý FLOAT

See Also:
.........

*Note declaim::, *Note declare::, *Note Section 3.2 (Compilation):
Compilation.

Notes:
......

Although the execution of a ÿproclaimþ form has effects that might
affect compilation, the compiler does not make any attempt to recognize
and specially process ÿproclaimþ forms.  A proclamation such as the
following, even if a top level form, does not have any effect until it
is executed:

(proclaim '(special *x*))

If compile time side effects are desired, ÿeval-whenþ may be useful.
For example:

 (eval-when (:execute :compile-toplevel :load-toplevel)
   (proclaim '(special *x*)))

In most such cases, however, it is preferrable to use ÿdeclaimþ for
this purpose.

Since ÿproclaimþ forms are ordinary function forms, macro forms can
expand into them.


File: chris-ansicl.info,  Node: declaim,  Next: declare,  Prev: proclaim,  Up: Evaluation and Compilation

declaim (Macro)
===============

Syntax:
.......

 -- Macro: declaim {declaration-specifier}* ý implementation-dependent

Arguments and Values:
.....................

DECLARATION-SPECIFIER--a declaration specifier; not evaluated.

Description:
............

Establishes the declarations specified by the DECLARATION-SPECIFIERS.

If a use of this macro appears as a top level form in a file being
processed by the file compiler, the proclamations are also made at
compile-time.  As with other defining macros, it is unspecified whether
or not the compile-time side-effects of a ÿdeclaimþ persist after the
file has been compiled.

Examples:
.........

See Also:
.........

*Note declare::, *Note proclaim::


File: chris-ansicl.info,  Node: declare,  Next: ignore; ignorable,  Prev: declaim,  Up: Evaluation and Compilation

declare (Symbol)
================

Syntax:
.......

 -- Special Form: declare {declaration-specifier}*

Arguments:
..........

DECLARATION-SPECIFIER--a declaration specifier; not evaluated.

Description:
............

A declare expression, sometimes called a declaration, can occur only at
the beginning of the bodies of certain forms; that is, it may be
preceded only by other declare expressions, or by a documentation
string if the context permits.

A declare expression can occur in a lambda expression or in any of the
forms listed in the next figure.

defgeneric                  do-external-symbols    prog
define-compiler-macro       do-symbols             prog*
define-method-combination   dolist                 restart-case
define-setf-expander        dotimes                symbol-macrolet
defmacro                    flet                   with-accessors
defmethod                   handler-case           with-hash-table-iterator
defsetf                     labels                 with-input-from-string
deftype                     let                    with-open-file
defun                       let*                   with-open-stream
destructuring-bind          locally                with-output-to-string
do                          macrolet               with-package-iterator
do*                         multiple-value-bind    with-slots
do-all-symbols              pprint-logical-block   

Figure 3.23: Standardized Forms In Which Declarations Can Occur

A declare expression can only occur where specified by the syntax of
these forms.  The consequences of attempting to evaluate a declare
expression are undefined.  In situations where such expressions can
appear, explicit checks are made for their presence and they are never
actually evaluated; it is for this reason that they are called
"declare expressions" rather than "declare forms."

Macro forms cannot expand into declarations; declare expressions must
appear as actual subexpressions of the form to which they refer.

The next figure shows a list of declaration identifiers that can be
used with declare.

dynamic-extent   ignore      optimize
ftype            inline      special
ignorable        notinline   type

Figure 3.24: Local Declaration Specifiers

An implementation is free to support other (implementation-defined)
declaration identifiers as well.

Examples:
.........

 (defun nonsense (k x z)
   (foo z x)                     ;First call to foo
   (let ((j (foo k x))           ;Second call to foo
         (x (* k k)))
     (declare (inline foo) (special x z))
     (foo x j z)))               ;Third call to foo

In this example, the ÿinlineþ declaration applies only to the third
call to ÿfooþ, but not to the first or second ones.  The ÿspecialþ
declaration of ÿxþ causes ÿletþ to make a dynamic binding for ÿxþ, and
causes the reference to ÿxþ in the body of ÿletþ to be a dynamic
reference.  The reference to ÿxþ in the second call to ÿfooþ is a local
reference to the second parameter of ÿnonsenseþ.  The reference to ÿxþ
in the first call to ÿfooþ is a local reference, not a ÿspecialþ one.
The ÿspecialþ declaration of ÿzþ causes the reference to ÿzþ in the
third call to ÿfooþ to be a dynamic reference; it does not refer to the
parameter to ÿnonsenseþ named ÿzþ, because that parameter binding has
not been declared to be ÿspecialþ.  (The ÿspecialþ declaration of ÿzþ
does not appear in the body of ÿdefunþ,  but in an inner form, and
therefore does not affect the binding of the parameter.)

Exceptional Situations:
.......................

The consequences  of trying to use a declare expression as a form to be
evaluated are undefined.

See Also:
.........

*Note proclaim::, *Note Section 4.2.3 (Type Specifiers): Type
Specifiers, *Note declaration::, *Note dynamic-extent::, *Note ftype::,
*Note ignorable::, *Note ignore::, *Note inline::, *Note notinline::,
*Note optimize::, *Note type::


File: chris-ansicl.info,  Node: ignore; ignorable,  Next: dynamic-extent,  Prev: declare,  Up: Evaluation and Compilation

ignore, ignorable (Declaration)
===============================

Syntax:
.......

ÿ(ignore {VAR | (function FN)}*)þ

ÿ(ignorable {VAR | (function FN)}*)þ

Arguments:
..........

VAR--a variable name.

FN--a function name.

Valid Context:
..............

declaration

Binding Types Affected:
.......................

variable, function

Description:
............

The ÿignoreþ and ÿignorableþ declarations refer to for-value references
to variable bindings for the VARS and to function bindings for the FNS.

An ÿignoreþ declaration specifies that for-value references to the
indicated bindings will not occur within the scope of the declaration.
Within the scope of such a declaration, it is desirable for a compiler
to issue a warning about the presence of either a for-value reference
to any VAR or FN, or a ÿspecialþ declaration for any VAR.

An ÿignorableþ declaration specifies that for-value references to the
indicated bindings might or might not occur within the scope of the
declaration.  Within the scope of such a declaration, it is not
desirable for a compiler to issue a warning about the presence or
absence of either a for-value reference to any VAR or FN, or a
ÿspecialþ declaration for any VAR.

When not within the scope of a ÿignoreþ or ÿignorableþ declaration, it
is desirable for a compiler to issue a warning about any VAR for which
there is neither a for-value reference nor a ÿspecialþ declaration, or
about any FN for which there is no for-value reference.

Any warning about a "used" or "unused" binding must be of type
ÿstyle-warningþ, and may not affect program semantics.

The stream variables established by ÿwith-open-fileþ,
ÿwith-open-streamþ, ÿwith-input-from-stringþ, and
ÿwith-output-to-stringþ, and all iteration variables are, by
definition, always "used".  Using ÿ(declare (ignore V))þ, for such a
variable V has unspecified consequences.

See Also:
.........

*Note declare::


File: chris-ansicl.info,  Node: dynamic-extent,  Next: type,  Prev: ignore; ignorable,  Up: Evaluation and Compilation

dynamic-extent (Declaration)
============================

Syntax:
.......

ÿ(dynamic-extent ù{var}* | (function FN)*ø)þ

Arguments:
..........

VAR--a variable name.

FN--a function name.

Valid Context:
..............

declaration

Binding Types Affected:
.......................

variable, function

Description:
............

In some containing form, F, this declaration asserts for each VAR_I
(which need not be bound by F), and for each value V_{IJ} that VAR_I
takes on, and for each object X_{IJK} that is an otherwise inaccessible
part of V_{IJ} at any time when V_{IJ} becomes the value of VAR_I, that
just after the execution of F terminates, X_{IJK} is either inaccessible
(if F established a binding for VAR_I) or still an otherwise
inaccessible part of the current value of VAR_I (if F did not establish
a binding for VAR_I).  The same relation holds for each FN_I, except
that the bindings are in the function namespace.

The compiler is permitted to use this information in any way that is
appropriate to the implementation and that does not conflict with the
semantics of Common Lisp.

ÿdynamic-extentþ declarations can be free declarations or bound
declarations.

The VARS and FNS named in a ÿdynamic-extentþ declaration must not refer
to symbol macro or macro bindings.

Examples:
.........

Since stack allocation of the initial value entails knowing at the
object's creation time that the object can be stack-allocated,  it is
not generally useful to make a ÿdynamic-extentþ declaration for
variables which have no lexically apparent initial value.  For example,
it is probably useful to write:

 (defun f ()
   (let ((x (list 1 2 3)))
     (declare (dynamic-extent x))
         ...))

This would permit those compilers that wish to do so to stack allocate
the list held by the local variable ÿxþ.  It is permissible, but in
practice probably not as useful, to write:

 (defun g (x) (declare (dynamic-extent x)) ...)
 (defun f () (g (list 1 2 3)))

Most compilers would probably not stack allocate the argument to ÿgþ in
ÿfþ because it would be a modularity violation for the compiler to
assume facts about ÿgþ from within ÿfþ.   Only an implementation that
was willing to be responsible for recompiling ÿfþ if the definition of
ÿgþ changed incompatibly could legitimately stack allocate the list
argument to ÿgþ in ÿfþ.

Here is another example:

 (declaim (inline g))
 (defun g (x) (declare (dynamic-extent x)) ...)
 (defun f () (g (list 1 2 3)))

 (defun f ()
   (flet ((g (x) (declare (dynamic-extent x)) ...))
     (g (list 1 2 3))))

In the previous example, some compilers might determine that
optimization was possible and others might not.

A variant of this is the so-called "stack allocated rest list" that can
be achieved (in implementations supporting the optimization) by:

 (defun f (&rest x)
   (declare (dynamic-extent x))
   ...)

Note that although the initial value of ÿxþ is not explicit, the ÿfþ
function is responsible for assembling the list ÿxþ from the passed
arguments, so the ÿfþ function can be optimized by the compiler to
construct a stack-allocated list instead of a heap-allocated list in
implementations that support such.

In the following example,

 (let ((x (list 'a1 'b1 'c1))
       (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))
   (declare (dynamic-extent x y))
   ...)

The otherwise inaccessible parts of ÿxþ are three conses,  and the
otherwise inaccessible parts of ÿyþ are three other conses.  None of
the symbols ÿa1þ,  ÿb1þ,  ÿc1þ,  ÿa2þ, ÿb2þ,  ÿc2þ,  or ÿnilþ is an
otherwise inaccessible part of ÿxþ or ÿyþ because each is interned and
hence accessible by the package (or packages) in which it is interned.
However, if a freshly allocated uninterned symbol had been used, it
would have been an otherwise inaccessible part of the list which
contained it.

;; In this example, the implementation is permitted to stack allocate
;; the list that is bound to X.
 (let ((x (list 1 2 3)))
   (declare (dynamic-extent x))
   (print x)
   :done)
Ö (1 2 3)
ý :DONE

;; In this example, the list to be bound to L can be stack-allocated.
 (defun zap (x y z)
   (do ((l (list x y z) (cdr l)))
       ((null l))
     (declare (dynamic-extent l))
     (prin1 (car l)))) ý ZAP
 (zap 1 2 3)
Ö 123
ý NIL

;; Some implementations might open-code LIST-ALL-PACKAGES in a way
;; that permits using stack allocation of the list to be bound to L.
 (do ((l (list-all-packages) (cdr l)))
     ((null l))
   (declare (dynamic-extent l))
   (let ((name (package-name (car l))))
     (when (string-search "COMMON-LISP" name) (print name))))
Ö "COMMON-LISP"
Ö "COMMON-LISP-USER"
ý NIL

;; Some implementations might have the ability to stack allocate
;; rest lists.  A declaration such as the following should be a cue
;; to such implementations that stack-allocation of the rest list
;; would be desirable.
 (defun add (&rest x)
   (declare (dynamic-extent x))
   (apply #'+ x)) ý ADD
 (add 1 2 3) ý 6

 (defun zap (n m)
   ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).
   ;; It may be slow, but with a good compiler at least it
   ;; doesn't waste much heap storage.  :-}
   (let ((a (make-array n)))
     (declare (dynamic-extent a))
     (dotimes (i n)
       (declare (dynamic-extent i))
       (setf (aref a i) (random (+ i 1))))
     (aref a m))) ý ZAP
 (< (zap 5 3) 3) ý true

The following are in error, since the value of ÿxþ is used outside of
its extent:

 (length (list (let ((x (list 1 2 3)))  ; Invalid
                (declare (dynamic-extent x))
                x)))

 (progn (let ((x (list 1 2 3)))  ; Invalid
          (declare (dynamic-extent x))
          x)
        nil)

See Also:
.........

*Note declare::

Notes:
......

The most common optimization is to stack allocate the initial value of
the objects named by the VARS.

It is permissible for an implementation to simply ignore this
declaration.


File: chris-ansicl.info,  Node: type,  Next: inline; notinline,  Prev: dynamic-extent,  Up: Evaluation and Compilation

type (Declaration)
==================

Syntax:
.......

ÿ(type TYPESPEC {var}*)þ

ÿ(TYPESPEC {var}*)þ

Arguments:
..........

TYPESPEC--a type specifier.

VAR--a variable name.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

variable

Description:
............

Affects only variable bindings and specifies that the VARS take on
values only of the specified TYPESPEC.  In particular, values assigned
to the variables by ÿsetqþ, as well as the initial values of the VARS
must be of the specified TYPESPEC.  ÿtypeþ declarations never apply to
function bindings (see ÿftypeþ).

A type declaration of a symbol defined by ÿsymbol-macroletþ is
equivalent to wrapping a ÿtheþ expression around the expansion of that
symbol, although the symbol's macro expansion is not actually affected.

The meaning of a type declaration is equivalent to changing each
reference to a variable (VAR) within the scope of the declaration to
ÿ(the TYPESPEC VAR)þ, changing each expression assigned to the variable
(NEW-VALUE) within the scope of the declaration to ÿ(the TYPESPEC
NEW-VALUE)þ, and executing ÿ(the TYPESPEC VAR)þ at the moment the scope
of the declaration is entered.

A type declaration is valid in all declarations. The interpretation of
a type declaration is as follows:

  1. During the execution of any reference to the declared variable
     within the scope of the declaration, the consequences are undefined
     if the value of the declared variable is not of the declared type.

  2. During the execution of any ÿsetqþ of the declared variable within
     the scope of the declaration, the consequences are undefined if
     the newly assigned value of the declared variable is not of the
     declared type.

  3. At the moment the scope of the declaration is entered, the
     consequences are undefined if the value of the declared variable
     is not of the declared type.

A type declaration affects only variable references within its scope.

If nested type declarations refer to the same variable, then the value
of the variable must be a member of the intersection of the declared
types.

If there is a local ÿtypeþ declaration for a dynamic variable, and
there is also a global ÿtypeþ proclamation for that same variable, then
the value of the variable within the scope of the local declaration
must be a member of the intersection of the two declared types.

ÿtypeþ declarations can  be free declarations or bound declarations.

A symbol cannot be both the name of a type and the name of a
declaration.  Defining a symbol as the name of a class, structure,
condition, or type, when the symbol has been declared as a declaration
name, or vice versa, signals an error.

Within the lexical scope of an ÿarrayþ type declaration, all references
to array elements are assumed to satisfy the expressed array element
type (as opposed to the upgraded array element type).  A compiler can
treat the code within the scope of the ÿarrayþ type declaration as if
each access of an array element were surrounded by an appropriate ÿtheþ
form.

Examples:
.........

 (defun f (x y)
   (declare (type fixnum x y))
   (let ((z (+ x y)))
     (declare (type fixnum z))
     z)) ý F
 (f 1 2) ý 3
 ;; The previous definition of F is equivalent to
 (defun f (x y)
   ;; This declaration is a shorthand form of the TYPE declaration
   (declare (fixnum x y))
   ;; To declare the type of a return value, it's not necessary to
   ;; create a named variable.  A THE special form can be used instead.
   (the fixnum (+ x y))) ý F
 (f 1 2) ý 3

 (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))
 (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))

 (defun frob (an-array)
   (declare (type (array (signed-byte 5) 1) an-array))
   (setf (aref an-array 1) 31)
   (setf (aref an-array 2) 127)
   (setf (aref an-array 3) (* 2 (aref an-array 3)))
   (let ((foo 0))
     (declare (type (signed-byte 5) foo))
     (setf foo (aref an-array 0))))

 (frob *one-array*)
 (frob *another-array*)

The above definition of ÿfrobþ is equivalent to:

 (defun frob (an-array)
   (setf (the (signed-byte 5) (aref an-array 1)) 31)
   (setf (the (signed-byte 5) (aref an-array 2)) 127)
   (setf (the (signed-byte 5) (aref an-array 3))
         (* 2 (the (signed-byte 5) (aref an-array 3))))
   (let ((foo 0))
     (declare (type (signed-byte 5) foo))
     (setf foo (the (signed-byte 5) (aref an-array 0)))))

Given an implementation in which fixnums are 29 bits but ÿfixnumþ arrays
are upgraded to signed 32-bit arrays, the following could be compiled
with all fixnum arithmetic:

 (defun bump-counters (counters)
   (declare (type (array fixnum *) bump-counters))
   (dotimes (i (length counters))
     (incf (aref counters i))))

See Also:
.........

*Note declare::, *Note declaim::, *Note proclaim::

Notes:
......

ÿ(TYPESPEC {var}*)þ is an abbreviation for ÿ(type TYPESPEC {var}*)þ.

A ÿtypeþ declaration for the arguments to a function does not
necessarily imply anything about the type of the result.  The following
function is not permitted to be compiled using implementation-dependent
fixnum-only arithmetic:

 (defun f (x y) (declare (fixnum x y)) (+ x y))

To see why, consider ÿ(f most-positive-fixnum 1)þ.  Common Lisp defines
that ÿFþ must return a bignum here, rather than signal an error or
produce a mathematically incorrect result.  If you have special
knowledge such "fixnum overflow" cases will not come up, you can
declare the result value to be in the fixnum range, enabling some
compilers to use more efficient arithmetic:

 (defun f (x y)
   (declare (fixnum x y))
   (the fixnum (+ x y)))

Note, however, that in the three-argument case, because of the
possibility of an implicit intermediate value growing too large, the
following will not cause implementation-dependent fixnum-only
arithmetic to be used:

 (defun f (x y)
   (declare (fixnum x y z))
   (the fixnum (+ x y z)))

To see why, consider ÿ(f most-positive-fixnum 1 -1).þ Although the
arguments and the result are all fixnums, an intermediate value is not
a fixnum.  If it is important that implementation-dependent fixnum-only
arithmetic be selected in implementations that provide it, consider
writing something like this instead:

 (defun f (x y)
   (declare (fixnum x y z))
   (the fixnum (+ (the fixnum (+ x y)) z)))


File: chris-ansicl.info,  Node: inline; notinline,  Next: ftype,  Prev: type,  Up: Evaluation and Compilation

inline, notinline (Declaration)
===============================

Syntax:
.......

ÿ(inline {function-name}*)þ

ÿ(notinline {function-name}*)þ

Arguments:
..........

FUNCTION-NAME--a function name.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

function

Description:
............

ÿinlineþ specifies that it is desirable for the compiler to produce
inline calls to the functions named by FUNCTION-NAMES; that is, the
code for a specified FUNCTION-NAME should be integrated into the
calling routine, appearing "in line" in place of a procedure call.  A
compiler is free to ignore this declaration.  ÿinlineþ declarations
never apply to variable bindings.

If one of the functions mentioned has a lexically apparent local
definition (as made by ÿfletþ or ÿlabelsþ), then the declaration
applies to that local definition and not to the global function
definition.

While no conforming implementation is required to perform inline
expansion of user-defined functions, those implementations that do
attempt to recognize the following paradigm:

To define a function ÿfþ that is not ÿinlineþ by default but for which
ÿ(declare (inline f))þ will make F be locally inlined, the proper
definition sequence is:

 (declaim (inline f))
 (defun f ...)
 (declaim (notinline f))

The ÿinlineþ proclamation preceding the ÿdefunþ form ensures that the
compiler has the opportunity save the information necessary for inline
expansion, and the ÿnotinlineþ proclamation following the ÿdefunþ form
prevents ÿfþ from being expanded inline everywhere.

ÿnotinlineþ specifies that it is undesirable to compile the functions
named by FUNCTION-NAMES in-line.  A compiler is not free to ignore this
declaration; calls to the specified functions must be implemented as
out-of-line subroutine calls.

If one of the functions mentioned has a lexically apparent local
definition (as made by ÿfletþ or ÿlabelsþ), then the declaration
applies to that local definition and not to the global function
definition.

In the presence of a compiler macro definition for FUNCTION-NAME, a
ÿnotinlineþ declaration prevents that compiler macro from being used.
An ÿinlineþ declaration may be used to encourage use of compiler macro
definitions.  ÿinlineþ and ÿnotinlineþ declarations otherwise have no
effect when the lexically visible definition of FUNCTION-NAME is a
macro definition.

ÿinlineþ and ÿnotinlineþ declarations can be free declarations or bound
declarations.  ÿinlineþ and ÿnotinlineþ declarations of functions that
appear before the body of a ÿfletþ or  ÿlabelsþ form that defines that
function are bound declarations.  Such declarations in other contexts
are free declarations.

Examples:
.........

 ;; The globally defined function DISPATCH should be open-coded,
 ;; if the implementation supports inlining, unless a NOTINLINE
 ;; declaration overrides this effect.
 (declaim (inline dispatch))
 (defun dispatch (x) (funcall (get (car x) 'dispatch) x))
 ;; Here is an example where inlining would be encouraged.
 (defun top-level-1 () (dispatch (read-command)))
 ;; Here is an example where inlining would be prohibited.
 (defun top-level-2 ()
   (declare (notinline dispatch))
   (dispatch (read-command)))
 ;; Here is an example where inlining would be prohibited.
 (declaim (notinline dispatch))
 (defun top-level-3 () (dispatch (read-command)))
 ;; Here is an example where inlining would be encouraged.
 (defun top-level-4 ()
   (declare (inline dispatch))
   (dispatch (read-command)))

See Also:
.........

*Note declare::, *Note declaim::, *Note proclaim::


File: chris-ansicl.info,  Node: ftype,  Next: declaration,  Prev: inline; notinline,  Up: Evaluation and Compilation

ftype (Declaration)
===================

Syntax:
.......

ÿ(ftype TYPE {function-name}*)þ

Arguments:
..........

FUNCTION-NAME--a function name.

TYPE--a type specifier.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

function

Description:
............

Specifies that the functions named by FUNCTION-NAMES are of the
functional type TYPE.  For example:

 (declare (ftype (function (integer list) t) ith)
          (ftype (function (number) float) sine cosine))

If one of the functions mentioned has a lexically apparent local
definition (as made by ÿfletþ or ÿlabelsþ), then the declaration
applies to that local definition and not to the global function
definition.  ÿftypeþ declarations never apply to variable bindings (see
ÿtypeþ).

The lexically apparent bindings of FUNCTION-NAMES must not be macro
definitions.  (This is because ÿftypeþ declares the functional
definition of each function name to be of a particular subtype of
ÿfunctionþ, and macros do not denote functions.)

ÿftypeþ declarations can be free declarations or bound declarations.
ÿftypeþ declarations of functions that appear before the body of a
ÿfletþ or ÿlabelsþ form that defines that function are bound
declarations.  Such declarations in other contexts are free
declarations.

See Also:
.........

*Note declare::, *Note declaim::, *Note proclaim::


File: chris-ansicl.info,  Node: declaration,  Next: optimize,  Prev: ftype,  Up: Evaluation and Compilation

declaration (Declaration)
=========================

Syntax:
.......

ÿ(declaration {name}*)þ

Arguments:
..........

NAME--a symbol.

Valid Context:
..............

proclamation only

Description:
............

Advises the compiler that each NAME is a valid but potentially
non-standard declaration name.  The purpose of this is to tell one
compiler not to issue warnings for declarations meant for another
compiler or other program processor.

Examples:
.........

 (declaim (declaration author target-language target-machine))
 (declaim (target-language ada))
 (declaim (target-machine IBM-650))
 (defun strangep (x)
   (declare (author "Harry Tweeker"))
   (member x '(strange weird odd peculiar)))

See Also:
.........

*Note declaim::, *Note proclaim::


File: chris-ansicl.info,  Node: optimize,  Next: special,  Prev: declaration,  Up: Evaluation and Compilation

optimize (Declaration)
======================

Syntax:
.......

ÿ(optimize {QUALITY | (QUALITY VALUE)}*)þ 

Arguments:
..........

QUALITY--an optimize quality.

VALUE--one of the integers ÿ0þ, ÿ1þ, ÿ2þ, or ÿ3þ.

Valid Context:
..............

declaration or proclamation

Description:
............

Advises the compiler that each QUALITY should be given attention
according to the specified corresponding VALUE.  Each QUALITY must be a
symbol naming an optimize quality; the names and meanings of the
standard OPTIMIZE QUALITIES are shown in the next figure.

Name                  Meaning
---------------------------------------------------------- 
ÿcompilation-speedþ   speed of the compilation process
ÿdebugþ               ease of debugging
ÿsafetyþ              run-time error checking
ÿspaceþ               both code size and run-time space
ÿspeedþ               speed of the object code

Figure 3.25: Optimize qualities

There may be other, implementation-defined optimize qualities.

A VALUE ÿ0þ means that the corresponding QUALITY is totally
unimportant, and ÿ3þ that the QUALITY is extremely important; ÿ1þ and
ÿ2þ are intermediate values, with ÿ1þ the neutral value.  ÿ(QUALITY 3)þ
can be abbreviated to QUALITY.

Note that code which has the optimization ÿ(safety 3)þ, or just
ÿsafetyþ, is called safe code.

The consequences are unspecified if a QUALITY appears more than once
with different VALUES.

Examples:
.........

 (defun often-used-subroutine (x y)
   (declare (optimize (safety 2)))
   (error-check x y)
   (hairy-setup x)
   (do ((i 0 (+ i 1))
        (z x (cdr z)))
       ((null z))
     ;; This inner loop really needs to burn.
     (declare (optimize speed))
     (declare (fixnum i))
     ))

See Also:
.........

*Note declare::, *Note declaim::, *Note proclaim::, *Note Section 3.3.4
(Declaration Scope): Declaration Scope.

Notes:
......

An ÿoptimizeþ declaration never applies to either a variable or a
function binding.  An ÿoptimizeþ declaration can only be a free
declaration.  For more information, see *Note Section 3.3.4
(Declaration Scope): Declaration Scope.


File: chris-ansicl.info,  Node: special,  Next: locally,  Prev: optimize,  Up: Evaluation and Compilation

special (Declaration)
=====================

Syntax:
.......

ÿ(special {var}*)þ

Arguments:
..........

VAR--a symbol.

Valid Context:
..............

declaration or proclamation

Binding Types Affected:
.......................

variable

Description:
............

Specifies that all of the VARS named are dynamic.  This specifier
affects variable bindings and affects references.  All variable
bindings affected are made to be dynamic bindings, and affected
variable references refer to the current dynamic binding.  For example:

 (defun hack (thing *mod*)    ;The binding of the parameter
   (declare (special *mod*))  ; *mod* is visible to hack1,
   (hack1 (car thing)))       ; but not that of thing.
 (defun hack1 (arg)
   (declare (special *mod*))  ;Declare references to *mod*
                              ;within hack1 to be special.
   (if (atom arg) *mod*
       (cons (hack1 (car arg)) (hack1 (cdr arg)))))

A ÿspecialþ declaration does not affect inner bindings of a VAR; the
inner bindings implicitly shadow a ÿspecialþ declaration and must be
explicitly re-declared to be ÿspecialþ.  ÿspecialþ declarations never
apply to function bindings.

ÿspecialþ declarations can be either bound declarations, affecting both
a binding and references, or free declarations, affecting only
references, depending on whether the declaration is attached to a
variable binding.

When used in a proclamation, a ÿspecialþ declaration specifier applies
to all bindings as well as to all references of the mentioned
variables.  For example, after

 (declaim (special x))

then in a function definition such as

 (defun example (x) ...)

the parameter ÿxþ is bound as a dynamic variable rather than as a
lexical variable.

Examples:
.........

(defun declare-eg (y)                 ;this y is special
 (declare (special y))
 (let ((y t))                         ;this y is lexical
      (list y
            (locally (declare (special y)) y)))) ;this y refers to the
                                                 ;special binding of y
ý DECLARE-EG
 (declare-eg nil) ý (T NIL)

(setf (symbol-value 'x) 6)
(defun foo (x)                         ;a lexical binding of x
  (print x)
  (let ((x (1+ x)))                    ;a special binding of x
    (declare (special x))              ;and a lexical reference
    (bar))
  (1+ x))
(defun bar ()
  (print (locally (declare (special x))
           x)))
(foo 10)
Ö 10
Ö 11
ý 11

(setf (symbol-value 'x) 6)
(defun bar (x y)            ;[1] 1st occurrence of x
  (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence
        (x y))              ;[3] 3rd occurrence of x
    (declare (special x))
    (list old-x x)))
(bar 'first 'second) ý (FIRST SECOND)

 (defun few (x &optional (y *foo*))
   (declare (special *foo*))
   ...)

The reference to ÿ*foo*þ in the first line of this example is not
ÿspecialþ even though there is a ÿspecialþ declaration in the second
line.

 (declaim (special prosp)) ý implementation-dependent
 (setq prosp 1 reg 1) ý 1
 (let ((prosp 2) (reg 2))         ;the binding of prosp is special
    (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,
    (list prosp reg))             ;whereas the variable reg is lexical
ý (3 2)
 (list prosp reg) ý (1 3)

 (declaim (special x))          ;x is always special.
 (defun example (x y)
   (declare (special y))
   (let ((y 3) (x (* x 2)))
     (print (+ y (locally (declare (special y)) y)))
     (let ((y 4)) (declare (special y)) (foo x)))) ý EXAMPLE

In the contorted code above, the outermost and innermost bindings of
ÿyþ are dynamic, but the middle binding is lexical. The two arguments
to ÿ+þ are different, one being the value, which is ÿ3þ, of the lexical
variable ÿyþ, and the other being the value of the dynamic variable
named ÿyþ (a binding of which happens, coincidentally, to lexically
surround it at an outer level).  All the bindings of ÿxþ and references
to ÿxþ are dynamic, however, because of the proclamation that ÿxþ is
always ÿspecialþ.

See Also:
.........

*Note defparameter::, *Note defvar::


File: chris-ansicl.info,  Node: locally,  Next: the,  Prev: special,  Up: Evaluation and Compilation

locally (Special Operator)
==========================

Syntax:
.......

 -- Special Form: locally {declaration}* {form}* ý {result}*

Arguments and Values:
.....................

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values of the FORMS.

Description:
............

Sequentially evaluates a body of FORMS in a lexical environment where
the given DECLARATIONS have effect.

Examples:
.........

 (defun sample-function (y)  ;this y is regarded as special
   (declare (special y))
   (let ((y t))              ;this y is regarded as lexical
     (list y
           (locally (declare (special y))
             ;; this next y is regarded as special
             y))))
ý SAMPLE-FUNCTION
 (sample-function nil) ý (T NIL)
 (setq x '(1 2 3) y '(4 . 5)) ý (4 . 5)

;;; The following declarations are not notably useful in specific.
;;; They just offer a sample of valid declaration syntax using LOCALLY.
 (locally (declare (inline floor) (notinline car cdr))
          (declare (optimize space))
    (floor (car x) (cdr y))) ý 0, 1

;;; This example shows a definition of a function that has a particular set
;;; of OPTIMIZE settings made locally to that definition.
 (locally (declare (optimize (safety 3) (space 3) (speed 0)))
   (defun frob (w x y &optional (z (foo x y)))
     (mumble x y z w)))
ý FROB

;;; This is like the previous example, except that the optimize settings
;;; remain in effect for subsequent definitions in the same compilation unit.
 (declaim (optimize (safety 3) (space 3) (speed 0)))
 (defun frob (w x y &optional (z (foo x y)))
   (mumble x y z w))
ý FROB

See Also:
.........

*Note declare::

Notes:
......

The ÿspecialþ declaration may be used with ÿlocallyþ to affect
references to, rather than bindings of, variables.

If a ÿlocallyþ form is a top level form, the body FORMS are also
processed as top level forms.  See *Note Section 3.2.3 (File
Compilation): File Compilation.


File: chris-ansicl.info,  Node: the,  Next: special-operator-p,  Prev: locally,  Up: Evaluation and Compilation

the (Special Operator)
======================

Syntax:
.......

 -- Special Form: the value-type form ý {result}*

Arguments and Values:
.....................

VALUE-TYPE--a type specifier; not evaluated.

FORM--a form; evaluated.

RESULTS--the values resulting from the evaluation of FORM.  These
values must conform to the type supplied by VALUE-TYPE; see below.

Description:
............

ÿtheþ specifies that the values[1a] returned by FORM are of the types
specified by VALUE-TYPE.  The consequences are undefined if any RESULT
is not of the declared type.

It is permissible for FORM to yield a different number of values than
are specified by VALUE-TYPE, provided that the values for which TYPES
are declared are indeed of those types.  Missing values are treated as
ÿnilþ for the purposes of checking their types.

Regardless of number of values declared by VALUE-TYPE, the number of
values returned by the ÿtheþ special form is the same as the number of
values returned by FORM.

Examples:
.........

 (the symbol (car (list (gensym)))) ý #:G9876
 (the fixnum (+ 5 7)) ý 12
 (the (values) (truncate 3.2 2)) ý 1, 1.2
 (the integer (truncate 3.2 2)) ý 1, 1.2
 (the (values integer) (truncate 3.2 2)) ý 1, 1.2
 (the (values integer float) (truncate 3.2 2))   ý 1, 1.2
 (the (values integer float symbol) (truncate 3.2 2)) ý 1, 1.2
 (the (values integer float symbol t null list)
      (truncate 3.2 2)) ý 1, 1.2
 (let ((i 100))
    (declare (fixnum i))
    (the fixnum (1+ i))) ý 101
 (let* ((x (list 'a 'b 'c))
        (y 5))
    (setf (the fixnum (car x)) y)
    x) ý (5 B C)

Exceptional Situations:
.......................

The consequences are undefined if the values yielded by the FORM are
not of the type specified by VALUE-TYPE.

See Also:
.........

*Note values (Type Specifier)::

Notes:
......

The ÿvaluesþ type specifier can be used to indicate the types of
multiple values:

 (the (values integer integer) (floor x y))
 (the (values string t)
      (gethash the-key the-string-table))

ÿsetfþ can be used with ÿtheþ type declarations.  In this case the
declaration is transferred to the form that specifies  the new value.
The resulting ÿsetfþ form is then analyzed.


File: chris-ansicl.info,  Node: special-operator-p,  Next: constantp,  Prev: the,  Up: Evaluation and Compilation

special-operator-p (Function)
=============================

Syntax:
.......

 -- Function: special-operator-p symbol ý generalized-boolean

Arguments and Values:
.....................

SYMBOL--a symbol.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if SYMBOL is a special operator; otherwise, returns false.

Examples:
.........

 (special-operator-p 'if) ý true
 (special-operator-p 'car) ý false
 (special-operator-p 'one) ý false

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if its argument is not a symbol.

Notes:
......

Historically, this function was called ÿspecial-form-pþ.  The name was
finally declared a misnomer and changed, since it returned true for
special operators, not special forms.


File: chris-ansicl.info,  Node: constantp,  Prev: special-operator-p,  Up: Evaluation and Compilation

constantp (Function)
====================

Syntax:
.......

 -- Function: constantp form &optional environment ý generalized-boolean

Arguments and Values:
.....................

FORM--a form.

ENVIRONMENT--an environment object.  The default is ÿnilþ.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if FORM can be determined by the implementation to be a
constant form in the indicated ENVIRONMENT; otherwise, it returns false
indicating either that the form is not a constant form or that it
cannot be determined whether or not form is a constant form.

The following kinds of forms are considered constant forms:

   * Self-evaluating objects (such as numbers, characters, and the
     various kinds of arrays) are always considered constant forms and
     must be recognized as such by ÿconstantpþ.

   * Constant variables, such as keywords, symbols defined by Common
     Lisp as constant (such as ÿnilþ, ÿtþ, and ÿpiþ), and symbols
     declared as constant by the user in the indicated ENVIRONMENT
     using ÿdefconstantþ are always considered constant forms and must
     be recognized as such by ÿconstantpþ.

   * ÿquoteþ forms are always considered constant forms and must be
     recognized as such by ÿconstantpþ.

   * An implementation is permitted, but not required, to detect
     additional constant forms.  If it does, it is also permitted, but
     not required, to make use of information in the ENVIRONMENT.
     Examples of constant forms for which ÿconstantpþ might or might
     not return true are: ÿ(sqrt pi)þ, ÿ(+ 3 2)þ, ÿ(length '(a b c))þ,
     and ÿ(let ((x 7)) (zerop x))þ.

If an implementation chooses to make use of the ENVIRONMENT
information, such actions as expanding macros or performing function
inlining are permitted to be used, but not required; however, expanding
compiler macros is not permitted.

Examples:
.........

 (constantp 1) ý true
 (constantp 'temp) ý false
 (constantp ''temp)) ý true
 (defconstant this-is-a-constant 'never-changing) ý THIS-IS-A-CONSTANT
 (constantp 'this-is-a-constant) ý true
 (constantp "temp") ý true
 (setq a 6) ý 6
 (constantp a) ý true
 (constantp '(sin pi)) ý implementation-dependent
 (constantp '(car '(x))) ý implementation-dependent
 (constantp '(eql x x)) ý implementation-dependent
 (constantp '(typep x 'nil)) ý implementation-dependent
 (constantp '(typep x 't)) ý implementation-dependent
 (constantp '(values this-is-a-constant)) ý implementation-dependent
 (constantp '(values 'x 'y)) ý implementation-dependent
 (constantp '(let ((a '(a b c))) (+ (length a) 6))) ý implementation-dependent

Affected By:
............

The state of the global environment (e.g., which symbols have been
declared to be the names of constant variables).

See Also:
.........

*Note defconstant::


File: chris-ansicl.info,  Node: Types and Classes,  Next: Data and Control Flow,  Prev: Evaluation and Compilation,  Up: Top

4 Types and Classes
*******************

* Menu:

* Introduction to Types and Classes::
* Types::
* Classes::

Dictionary

* nil (Type)::
* boolean::
* function (System Class)::
* compiled-function::
* generic-function::
* standard-generic-function::
* class::
* built-in-class::
* structure-class::
* standard-class::
* method::
* standard-method::
* structure-object::
* standard-object::
* method-combination::
* t (System Class)::
* satisfies::
* member (Type Specifier)::
* not (Type Specifier)::
* and (Type Specifier)::
* or (Type Specifier)::
* values (Type Specifier)::
* eql (Type Specifier)::
* coerce::
* deftype::
* subtypep::
* type-of::
* typep::
* type-error::
* type-error-datum; type-error-expected-type::
* simple-type-error::


File: chris-ansicl.info,  Node: Introduction to Types and Classes,  Next: Types,  Up: Types and Classes

4.1 Introduction to Types and Classes
=====================================

A type is a (possibly infinite) set of objects.  An object can belong
to more than one type.  Types are never explicitly represented as
objects by Common Lisp.  Instead, they are referred to indirectly by
the use of type specifiers, which are objects that denote types.

New types can be defined using ÿdeftypeþ, ÿdefstructþ, ÿdefclassþ, and
ÿdefine-conditionþ.

The function ÿtypepþ, a set membership test, is used to determine
whether a given object is of a given type.  The function ÿsubtypepþ, a
subset test, is used to determine whether a given type is a subtype of
another given type.  The function ÿtype-ofþ returns a particular type to
which a given object belongs, even though that object must belong to
one or more other types as well.  (For example, every object is of type
ÿtþ, but ÿtype-ofþ always returns a type specifier for a type more
specific than ÿtþ.)

Objects, not variables, have types.  Normally, any variable can have
any object as its value.  It is possible to declare that a variable
takes on only values of a given type by making an explicit type
declaration.  Types are arranged in a directed acyclic graph, except
for the presence of equivalences.

Declarations can be made about types using declare, ÿproclaimþ,
ÿdeclaimþ, or ÿtheþ.  For more information about declarations, see
*Note Section 3.3 (Declarations): Declarations.

Among the fundamental objects of the object system are classes.  A
class determines the structure and behavior of a set of other objects,
which are called its instances.  Every object is a direct instance of a
class.  The class of an object determines the set of operations that
can be performed on the object.  For more information, see *Note
Section 4.3 (Classes): Classes.

It is possible to write functions that have behavior specialized to the
class of the objects which are their arguments.  For more information,
see *Note Section 7.6 (Generic Functions and Methods): Generic
Functions and Methods.

The class of the class of an object is called its "metaclass".  For
more information about metaclasses, see *Note Section 7.4
(Meta-Objects): Meta-Objects.


File: chris-ansicl.info,  Node: Types,  Next: Classes,  Prev: Introduction to Types and Classes,  Up: Types and Classes

4.2 Types
=========

* Menu:

* Data Type Definition::
* Type Relationships::
* Type Specifiers::


File: chris-ansicl.info,  Node: Data Type Definition,  Next: Type Relationships,  Up: Types

4.2.1 Data Type Definition
--------------------------

Information about type usage is located in the sections specified in
*Note Figure 4.1: TypeInfoXrefs.  *Note Figure 4.7:
ObjectSystemClasses. lists some classes that are particularly relevant
to the object system.  *Note Figure 9.1:
StandardizedConditionTypes. lists the defined condition types.

Section                                                                     Data Type
*Note Section 4.3 (Classes): Classes.                                       Object System types
*Note Section 7.5 (Slots): Slots.                                           Object System types
*Note Chapter 7 (Objects): Objects.                                         Object System types
*Note Section 7.6 (Generic Functions and Methods): Generic Functions and    Object System types
Methods.                                                                    
*Note Section 9.1 (Condition System Concepts): Condition System Concepts.   Condition System types
*Note Chapter 4 (Types and Classes): Types and Classes.                     Miscellaneous types
*Note Chapter 2 (Syntax): Syntax.                                           All types--read and print syntax
*Note Section 22.1 (The Lisp Printer): The Lisp Printer.                    All types--print syntax
*Note Section 3.2 (Compilation): Compilation.                               All types--compilation issues

Figure 4.1: Cross-References to Data Type Information


File: chris-ansicl.info,  Node: Type Relationships,  Next: Type Specifiers,  Prev: Data Type Definition,  Up: Types

4.2.2 Type Relationships
------------------------

   * The types ÿconsþ, ÿsymbolþ, ÿarrayþ, ÿnumberþ, ÿcharacterþ,
     ÿhash-tableþ, ÿfunctionþ, ÿreadtableþ, ÿpackageþ, ÿpathnameþ,
     ÿstreamþ, ÿrandom-stateþ, ÿconditionþ, ÿrestartþ, and any single
     other type created by ÿdefstructþ, ÿdefine-conditionþ, or
     ÿdefclassþ are pairwise disjoint, except for type relations
     explicitly established by specifying superclasses in ÿdefclassþ or
     ÿdefine-conditionþ or the :include option of ÿdestructþ.

   * Any two types created by ÿdefstructþ are disjoint unless one is a
     supertype of the other by virtue of the ÿdefstructþ :include
     option.

   * Any two distinct classes created by ÿdefclassþ or
     ÿdefine-conditionþ are disjoint unless they have a common subclass
     or one class is a subclass of the other.

   * An implementation may be extended to add other subtype
     relationships between the specified types, as long as they do not
     violate the type relationships and disjointness requirements
     specified here.  An implementation may define additional types
     that are subtypes or supertypes of any specified types, as long as
     each additional type is a subtype of type ÿtþ and a supertype of
     type ÿnilþ and the disjointness requirements are not violated.

     At the discretion of the implementation, either ÿstandard-objectþ
     or ÿstructure-objectþ might appear in any class precedence list
     for a system class that does not already specify either
     ÿstandard-objectþ or ÿstructure-objectþ.  If it does, it must
     precede the class ÿtþ and follow all other standardized classes.


File: chris-ansicl.info,  Node: Type Specifiers,  Prev: Type Relationships,  Up: Types

4.2.3 Type Specifiers
---------------------

Type specifiers can be symbols, classes, or lists.  *Note Figure 4.2:
StandardizedAtomicTypeSpecs. lists symbols that are standardized atomic
type specifiers, and *Note Figure 4.3:
StandardizedCompoundTypeSpecNames. lists standardized compound type
specifier names.  For syntax information, see the dictionary entry for
the corresponding type specifier.  It is possible to define new type
specifiers using ÿdefclassþ, ÿdefine-conditionþ, ÿdefstructþ, or
ÿdeftypeþ.

arithmetic-error                   function             simple-condition
array                              generic-function     simple-error
atom                               hash-table           simple-string
base-char                          integer              simple-type-error
base-string                        keyword              simple-vector
bignum                             list                 simple-warning
bit                                logical-pathname     single-float
bit-vector                         long-float           standard-char
broadcast-stream                   method               standard-class
built-in-class                     method-combination   standard-generic-function
cell-error                         nil                  standard-method
character                          null                 standard-object
class                              number               storage-condition
compiled-function                  package              stream
complex                            package-error        stream-error
concatenated-stream                parse-error          string
condition                          pathname             string-stream
cons                               print-not-readable   structure-class
control-error                      program-error        structure-object
division-by-zero                   random-state         style-warning
double-float                       ratio                symbol
echo-stream                        rational             synonym-stream
end-of-file                        reader-error         t
error                              readtable            two-way-stream
extended-char                      real                 type-error
file-error                         restart              unbound-slot
file-stream                        sequence             unbound-variable
fixnum                             serious-condition    undefined-function
float                              short-float          unsigned-byte
floating-point-inexact             signed-byte          vector
floating-point-invalid-operation   simple-array         warning
floating-point-overflow            simple-base-string   
floating-point-underflow           simple-bit-vector    

Figure 4.2: Standardized Atomic Type Specifiers

If a type specifier is a list, the car of the list is a symbol, and the
rest of the list is subsidiary type information.  Such a type specifier
is called a "compound type specifier".  Except as explicitly stated
otherwise, the subsidiary items can be unspecified.  The unspecified
subsidiary items are indicated by writing ÿ*þ.  For example, to
completely specify a vector, the type of the elements and the length of
the vector must be present.

 (vector double-float 100)

The following leaves the length unspecified:

 (vector double-float *)

The following leaves the element type unspecified:

 (vector * 100)

Suppose that two type specifiers are the same except that the first has
a ÿ*þ where the second has a more explicit specification.  Then the
second denotes a subtype of the type denoted by the first.

If a list has one or more unspecified items at the end, those items can
be dropped.  If dropping all occurrences of ÿ*þ results in a singleton
list, then the parentheses can be dropped as well (the list can be
replaced by the symbol in its car).  For example, ÿ(vector double-float
*)þ can be abbreviated to ÿ(vector double-float)þ, and ÿ(vector * *)þ
can be abbreviated to ÿ(vector)þ and then to ÿvectorþ.

and            long-float     simple-base-string
array          member         simple-bit-vector
base-string    mod            simple-string
bit-vector     not            simple-vector
complex        or             single-float
cons           rational       string
double-float   real           unsigned-byte
eql            satisfies      values
float          short-float    vector
function       signed-byte    
integer        simple-array   

Figure 4.3: Standardized Compound Type Specifier Names

The next figure show the defined names that can be used as compound
type specifier names but that cannot be used as atomic type specifiers.

and      mod   satisfies
eql      not   values
member   or    

Figure 4.4: Standardized Compound-Only Type Specifier Names

New type specifiers can come into existence in two ways.

   * Defining a structure by using ÿdefstructþ without using the :type
     specifier or defining a class by using ÿdefclassþ or
     ÿdefine-conditionþ automatically causes the name of the structure
     or class to be a new type specifier symbol.

   * ÿdeftypeþ can be used to define "derived type specifiers", which
     act as `abbreviations' for other type specifiers.

A class object can be used as a type specifier.  When used this way, it
denotes the set of all members of that class.

The next figure shows some defined names relating to types and
declarations.

coerce             defstruct   subtypep
declaim            deftype     the
declare            ftype       type
defclass           locally     type-of
define-condition   proclaim    typep

Figure 4.5: Defined names relating to types and declarations.

The next figure shows all defined names that are type specifier names,
whether for atomic type specifiers or compound type specifiers; this
list is the union of the lists in *Note Figure 4.2:
StandardizedAtomicTypeSpecs.  and *Note Figure 4.3:
StandardizedCompoundTypeSpecNames.

and                                function             simple-array
arithmetic-error                   generic-function     simple-base-string
array                              hash-table           simple-bit-vector
atom                               integer              simple-condition
base-char                          keyword              simple-error
base-string                        list                 simple-string
bignum                             logical-pathname     simple-type-error
bit                                long-float           simple-vector
bit-vector                         member               simple-warning
broadcast-stream                   method               single-float
built-in-class                     method-combination   standard-char
cell-error                         mod                  standard-class
character                          nil                  standard-generic-function
class                              not                  standard-method
compiled-function                  null                 standard-object
complex                            number               storage-condition
concatenated-stream                or                   stream
condition                          package              stream-error
cons                               package-error        string
control-error                      parse-error          string-stream
division-by-zero                   pathname             structure-class
double-float                       print-not-readable   structure-object
echo-stream                        program-error        style-warning
end-of-file                        random-state         symbol
eql                                ratio                synonym-stream
error                              rational             t
extended-char                      reader-error         two-way-stream
file-error                         readtable            type-error
file-stream                        real                 unbound-slot
fixnum                             restart              unbound-variable
float                              satisfies            undefined-function
floating-point-inexact             sequence             unsigned-byte
floating-point-invalid-operation   serious-condition    values
floating-point-overflow            short-float          vector
floating-point-underflow           signed-byte          warning

Figure 4.6: Standardized Type Specifier Names


File: chris-ansicl.info,  Node: Classes,  Next: nil (Type),  Prev: Types,  Up: Types and Classes

4.3 Classes
===========

While the object system is general enough to describe all standardized
classes (including, for example, ÿnumberþ, ÿhash-tableþ, and ÿsymbolþ),
the next figure contains a list of classes that are especially relevant
to understanding the object system.

built-in-class     method-combination          standard-object
class              standard-class              structure-class
generic-function   standard-generic-function   structure-object
method             standard-method             

Figure 4.7: Object System Classes

* Menu:

* Introduction to Classes::
* Defining Classes::
* Creating Instances of Classes::
* Inheritance::
* Determining the Class Precedence List::
* Redefining Classes::
* Integrating Types and Classes::


File: chris-ansicl.info,  Node: Introduction to Classes,  Next: Defining Classes,  Up: Classes

4.3.1 Introduction to Classes
-----------------------------

A "class" is an object that determines the structure and behavior of a
set of other objects, which are called its "instances".

A class can inherit structure and behavior from other classes.  A class
whose definition refers to other classes for the purpose of inheriting
from them is said to be a subclass of each of those classes. The
classes that are designated for purposes of inheritance are said to be
superclasses of the inheriting class.

A class can have a name. The function ÿclass-nameþ takes a class object
and returns its name.  The name of an anonymous class is ÿnilþ.  A
symbol can name a class. The function ÿfind-classþ takes a symbol and
returns the class that the symbol names.  A class has a proper name if
the name is a symbol and if the name of the class names that class.
That is, a class C has the proper name S if S= ÿ(class-name C)þ and C=
ÿ(find-class S)þ.  Notice that it is possible for ÿ(find-class Sá)þ =
ÿ(find-class Sà)þ and Sáâ Sà.  If C= ÿ(find-class S)þ, we say that C is
the class named S.

A class Cá is a "direct superclass" of a class Cà if Cà explicitly
designates Cá as a superclass in its definition.  In this case Cà is a "direct
subclass" of Cá.  A class C_n is a "superclass" of a class Cá if there
exists a series of classes Cà,...,C_{n-1} such that C_{i+1} is a direct
superclass of C_i for 1 ó i<n.  In this case, Cá is a "subclass" of C_n.
A class is considered neither a superclass nor a subclass of itself.
That is, if Cá is a superclass of Cà, then Cá â Cà.  The set of classes
consisting of some given class C along with all of its superclasses is
called "C and its superclasses."

Each class has a "class precedence list", which is a total ordering on
the set of the given class and its superclasses.  The total ordering is
expressed as a list ordered from most specific to least specific.  The
class precedence list is used in several ways.  In general, more
specific classes can "shadow"á features that would otherwise be
inherited from less specific classes.  The method selection and
combination process uses the class precedence list to order methods
from most specific to least specific.

When a class is defined, the order in which its direct superclasses are
mentioned in the defining form is important.  Each class has a "local
precedence order", which is a list consisting of the class followed by
its direct superclasses in the order mentioned in the defining form.

A class precedence list is always consistent with the local precedence
order of each class in the list.  The classes in each local precedence
order appear within the class precedence list in the same order.  If
the local precedence orders are inconsistent with each other, no class
precedence list can be constructed, and an error is signaled.  The
class precedence list and its computation is discussed in *Note Section
4.3.5 (Determining the Class Precedence List): Determining the Class
Precedence List.

classes are organized into a directed acyclic graph.  There are two
distinguished classes, named ÿtþ and ÿstandard-objectþ.  The class
named ÿtþ has no superclasses.  It is a superclass of every class
except itself.  The class named ÿstandard-objectþ is an instance of the
class ÿstandard-classþ and is a superclass of every class that is an
instance of the class ÿstandard-classþ except itself.

There is a mapping from the object system class space into the type
space.  Many of the standard types specified in this document have a
corresponding class that has the same name as the type. Some types do
not have a corresponding class. The integration of the type and class
systems is discussed in *Note Section 4.3.7 (Integrating Types and
Classes): Integrating Types and Classes.

Classes are represented by objects that are themselves instances of
classes.  The class of the class of an object is termed the "metaclass"
of that object. When no misinterpretation is possible, the term
metaclass is used to refer to a class that has instances that are
themselves classes. The metaclass determines the form of inheritance
used by the classes that are its instances and the representation of
the instances of those classes.  The object system provides a default
metaclass, ÿstandard-classþ, that is appropriate for most programs.

Except where otherwise specified, all classes mentioned in this
standard are instances of the class ÿstandard-classþ, all generic
functions are instances of the class ÿstandard-generic-functionþ, and
all methods are instances of the class ÿstandard-methodþ.

4.3.1.1 Standard Metaclasses
............................

The object system provides a number of predefined metaclasses.  These
include the classes ÿstandard-classþ, ÿbuilt-in-classþ, and
ÿstructure-classþ:

   * The class ÿstandard-classþ is the default class of classes defined
     by ÿdefclassþ.

   * The class ÿbuilt-in-classþ is the class whose instances are
     classes that have special implementations with restricted
     capabilities.  Any class that corresponds to a standard type might
     be an instance of ÿbuilt-in-classþ.  The predefined type
     specifiers that are required to have corresponding classes are
     listed in *Note Figure 4.8: ClassTypeCorrespondence.  It is
     implementation-dependent whether each of these classes is
     implemented as a built-in class.

   * All classes defined by means of ÿdefstructþ are instances of the
     class ÿstructure-classþ.


File: chris-ansicl.info,  Node: Defining Classes,  Next: Creating Instances of Classes,  Prev: Introduction to Classes,  Up: Classes

4.3.2 Defining Classes
----------------------

The macro ÿdefclassþ is used to define a new named class.

The definition of a class includes:

   * The name of the new class.  For newly-defined classes this name is
     a proper name.

   * The list of the direct superclasses of the new class.

   * A set of "slot specifiers".  Each slot specifier includes the name
     of the slot and zero or more slot options.  A slot option pertains
     only to a single slot.  If a class definition contains two slot
     specifiers with the same name, an error is signaled.

   * A set of class options.  Each class option pertains to the class
     as a whole.

The slot options and class options of the ÿdefclassþ form provide
mechanisms for the following:

   * Supplying a default initial value form for a given slot.

   * Requesting that methods for generic functions be automatically
     generated for reading or writing slots.

   * Controlling whether a given slot is shared by all instances of the
     class or whether each instance of the class has its own slot.

   * Supplying a set of initialization arguments and initialization
     argument defaults to be used in instance creation.

   * Indicating that the metaclass is to be other than the default.
     The :metaclass option is reserved for future use; an
     implementation can be extended to make use of the :metaclass
     option.

   * Indicating the expected type for the value stored in the slot.

   * Indicating the documentation string for the slot.


File: chris-ansicl.info,  Node: Creating Instances of Classes,  Next: Inheritance,  Prev: Defining Classes,  Up: Classes

4.3.3 Creating Instances of Classes
-----------------------------------

The generic function ÿmake-instanceþ creates and returns a new instance
of a class.  The object system provides several mechanisms for
specifying how a new instance is to be initialized.  For example, it is
possible to specify the initial values for slots in newly created
instances either by giving arguments to ÿmake-instanceþ or by providing
default initial values.  Further initialization activities can be
performed by methods written for generic functions that are part of the
initialization protocol.  The complete initialization protocol is
described in *Note Section 7.1 (Object Creation and Initialization):
Object Creation and Initialization.


File: chris-ansicl.info,  Node: Inheritance,  Next: Determining the Class Precedence List,  Prev: Creating Instances of Classes,  Up: Classes

4.3.4 Inheritance
-----------------

A class can inherit methods, slots, and some ÿdefclassþ options from
its superclasses.  Other sections describe the inheritance of methods,
the inheritance of slots and slot options, and the inheritance of class
options.

4.3.4.1 Examples of Inheritance
...............................

 (defclass C1 ()
     ((S1 :initform 5.4 :type number)
      (S2 :allocation :class)))

 (defclass C2 (C1)
     ((S1 :initform 5 :type integer)
      (S2 :allocation :instance)
      (S3 :accessor C2-S3)))

Instances of the class ÿC1þ have a local slot named ÿS1þ, whose default
initial value is 5.4 and whose value should always be a number.  The
class ÿC1þ also has a shared slot named ÿS2þ.

There is a local slot named ÿS1þ in instances of ÿC2þ.  The default
initial value of ÿS1þ is 5.  The value of ÿS1þ should always be of type
ÿ(and integer number)þ.  There are also local slots named ÿS2þ and ÿS3þ
in instances of ÿC2þ.  The class ÿC2þ has a method for ÿC2-S3þ for
reading the value of slot ÿS3þ; there is also a method for ÿ(setf
C2-S3)þ that writes the value of ÿS3þ.

4.3.4.2 Inheritance of Class Options
....................................

The :default-initargs class option is inherited.  The set of defaulted
initialization arguments for a class is the union of the sets of
initialization arguments supplied in the :default-initargs class
options of the class and its superclasses.  When more than one default
initial value form is supplied for a given initialization argument, the
default initial value form that is used is the one supplied by the
class that is most specific according to the class precedence list.

If a given :default-initargs class option specifies an initialization
argument of the same name more than once, an error of type
ÿprogram-errorþ is signaled.


File: chris-ansicl.info,  Node: Determining the Class Precedence List,  Next: Redefining Classes,  Prev: Inheritance,  Up: Classes

4.3.5 Determining the Class Precedence List
-------------------------------------------

The ÿdefclassþ form for a class provides a total ordering on that class
and its direct superclasses.  This ordering is called the "local
precedence order".  It is an ordered list of the class and its direct
superclasses. The "class precedence list" for a class C is a total
ordering on C and its superclasses that is consistent with the local
precedence orders for each of C and its superclasses.

A class precedes its direct superclasses, and a direct superclass
precedes all other direct superclasses specified to its right in the
superclasses list of the ÿdefclassþ form.  For every class C, define

     R_C={(C,Cá),(Cá,Cà),...,(C_{n-1},C_n)}
 where Cá,...,C_n are the direct superclasses of C in the order in which
they are mentioned in the ÿdefclassþ form. These ordered pairs generate
the total ordering on the class C and its direct superclasses.

Let S_C be the set of C and its superclasses. Let R be

     R=õ_{c÷ S_C}R_c
.

The set R might or might not generate a partial ordering, depending on
whether the R_c, c÷ S_C, are consistent; it is assumed that they are
consistent and that R generates a partial ordering.  When the R_c are
not consistent, it is said that R is inconsistent.

To compute the class precedence list for C, topologically sort the
elements of S_C with respect to the partial ordering generated by R.
When the topological sort must select a class from a set of two or more
classes, none of which are preceded by other classes with respect to R,
the class selected is chosen deterministically, as described below.

If R is inconsistent, an error is signaled.

4.3.5.1 Topological Sorting
...........................

Topological sorting proceeds by finding a class C in S_C such that no
other class precedes that element according to the elements in R.  The
class C is placed first in the result.  Remove C from S_C, and remove
all pairs of the form (C,D), D÷ S_C, from R. Repeat the process, adding
classes with no predecessors to the end of the result.  Stop when no
element can be found that has no predecessor.

If S_C is not empty and the process has stopped, the set R is
inconsistent. If every class in the finite set of classes is preceded
by another, then R contains a loop. That is, there is a chain of
classes Cá,...,C_n such that C_i precedes C_{i+1}, 1ó i<n, and C_n
precedes Cá.

Sometimes there are several classes from S_C with no predecessors.  In
this case select the one that has a direct subclass rightmost in the
class precedence list computed so far.  (If there is no such candidate
class, R does not generate a partial ordering--the R_c, c÷ S_C, are
inconsistent.)

In more precise terms, let {Ná,...,N_m}, mö 2, be the classes from S_C
with no predecessors.  Let (Cá... C_n), nö 1, be the class precedence
list constructed so far.  Cá is the most specific class, and C_n is the
least specific.  Let 1ó jó n be the largest number such that there
exists an i where 1ó ió m and N_i is a direct superclass of C_j; N_i is
placed next.

The effect of this rule for selecting from a set of classes with no
predecessors is that the classes in a simple superclass chain are
adjacent in the class precedence list and that classes in each
relatively separated subgraph are adjacent in the class precedence list.
For example, let Tá and Tà be subgraphs whose only element in common is
the class J.  Suppose that no superclass of J appears in either Tá or
Tà, and that J is in the superclass chain of every class in both Tá and
Tà.  Let Cá be the bottom of Tá; and let Cà be the bottom of Tà.
Suppose C is a class whose direct superclasses are Cá and Cà in that
order, then the class precedence list for C starts with C and is
followed by all classes in Tá except J.  All the classes of Tà are next.
The class J and its superclasses appear last.

4.3.5.2 Examples of Class Precedence List Determination
.......................................................

This example determines a class precedence list for the class ÿpieþ.
The following classes are defined:

 (defclass pie (apple cinnamon) ())

 (defclass apple (fruit) ())

 (defclass cinnamon (spice) ())

 (defclass fruit (food) ())

 (defclass spice (food) ())

 (defclass food () ())

The set S_{pie} = {ÿpie, apple, cinnamon, fruit, spice, food,
standard-object, tþ}. The set R = {ÿ(pie, apple), (apple, cinnamon),
(apple, fruit), (cinnamon, spice),  (fruit, food), (spice, food),
(food, standard-object), (standard-object, t)þ}.

The class ÿpieþ is not preceded by anything, so it comes first; the
result so far is ÿ(pie)þ.  Remove ÿpieþ from S and pairs mentioning
ÿpieþ from R to get S = {ÿapple, cinnamon, fruit, spice, food,
standard-object, tþ} and R = {ÿ(apple, cinnamon), (apple, fruit),
(cinnamon, spice), (fruit, food), (spice, food), (food,
standard-object), (standard-object, t)þ}.

The class ÿappleþ is not preceded by anything, so it is next; the
result is ÿ(pie apple)þ. Removing ÿappleþ and the relevant pairs
results in S = {ÿcinnamon, fruit, spice, food, standard-object, tþ} and
R = {ÿ(cinnamon, spice), (fruit, food), (spice, food), (food,
standard-object), (standard-object, t)þ}.

The classes ÿcinnamonþ and ÿfruitþ are not preceded by anything, so the
one with a direct subclass rightmost in the class precedence list
computed so far goes next.  The class ÿappleþ is a direct subclass of
ÿfruitþ, and the class ÿpieþ is a direct subclass of ÿcinnamonþ.
Because ÿappleþ appears to the right of ÿpieþ in the class precedence
list, ÿfruitþ goes next, and the result so far is ÿ(pie apple fruit)þ.
S = {ÿcinnamon, spice, food, standard-object, tþ}; R = {ÿ(cinnamon,
spice), (spice, food), (food, standard-object), (standard-object, t)þ}.

The class ÿcinnamonþ is next, giving the result so far as ÿ(pie apple
fruit cinnamon)þ.  At this point S = {ÿspice, food, standard-object,
tþ}; R = {ÿ(spice, food), (food, standard-object), (standard-object,
t)þ}.

The classes ÿspiceþ, ÿfoodþ, ÿstandard-objectþ, and ÿtþ are added in
that order, and the class precedence list is ÿ(pie apple fruit cinnamon
spice food standard-object t)þ.

It is possible to write a set of class definitions that cannot be
ordered.   For example:

 (defclass new-class (fruit apple) ())

 (defclass apple (fruit) ())

The class ÿfruitþ must precede ÿappleþ because the local ordering of
superclasses must be preserved.  The class ÿappleþ must precede ÿfruitþ
because a class always precedes its own superclasses.  When this
situation occurs, an error is signaled, as happens here when the system
tries to compute the class precedence list of ÿnew-classþ.

The following might appear to be a conflicting set of definitions:

 (defclass pie (apple cinnamon) ())

 (defclass pastry (cinnamon apple) ())

 (defclass apple () ())

 (defclass cinnamon () ())

The class precedence list for ÿpieþ is ÿ(pie apple cinnamon
standard-object t)þ.

The class precedence list for ÿpastryþ is ÿ(pastry cinnamon apple
standard-object t)þ.

It is not a problem for ÿappleþ to precede ÿcinnamonþ in the ordering
of the superclasses of ÿpieþ but not in the ordering for ÿpastryþ.
However, it is not possible to build a new class that has both ÿpieþ
and ÿpastryþ as superclasses.


File: chris-ansicl.info,  Node: Redefining Classes,  Next: Integrating Types and Classes,  Prev: Determining the Class Precedence List,  Up: Classes

4.3.6 Redefining Classes
------------------------

A class that is a direct instance of ÿstandard-classþ can be redefined
if the new class is also a direct instance of ÿstandard-classþ.
Redefining a class modifies the existing class object to reflect the
new class definition; it does not create a new class object for the
class.  Any method object created by a :reader, :writer, or :accessor
option specified by the old ÿdefclassþ form is removed from the
corresponding generic function.  Methods specified by the new
ÿdefclassþ form are added.

When the class C is redefined, changes are propagated to its instances
and to instances of any of its subclasses.  Updating such an instance
occurs at an implementation-dependent time, but no later than the next
time a slot of that instance is read or written.  Updating an instance
does not change its identity as defined by the function ÿeqþ.  The
updating process may change the slots of that particular instance, but
it does not create a new instance.  Whether updating an instance
consumes storage is implementation-dependent.

Note that redefining a class may cause slots to be added or deleted.
If a class is redefined in a way that changes the set of local slots
accessible in instances, the instances are updated.  It is
implementation-dependent whether instances are updated if a class is
redefined in a way that does not change the set of local slots
accessible in instances.

The value of a slot that is specified as shared both in the old class
and in the new class is retained.  If such a shared slot was unbound in
the old class, it is unbound in the new class.  Slots that were local
in the old class and that are shared in the new class are initialized.
Newly added shared slots are initialized.

Each newly added shared slot is set to the result of evaluating the
captured initialization form for the slot that was specified in the
ÿdefclassþ form for the new class.  If there was no initialization
form, the slot is unbound.

If a class is redefined in such a way that the set of local slots
accessible in an instance of the class is changed, a two-step process
of updating the instances of the class takes place.  The process may be
explicitly started by invoking the generic function
ÿmake-instances-obsoleteþ.  This two-step process can happen in other
circumstances in some implementations.  For example, in some
implementations this two-step process is triggered if the order of
slots in storage is changed.

The first step modifies the structure of the instance by adding new
local slots and discarding local slots that are not defined in the new
version of the class.  The second step initializes the newly-added
local slots and performs any other user-defined actions. These two
steps are further specified in the next two sections.

4.3.6.1 Modifying the Structure of Instances
............................................

The first step modifies the structure of instances of the redefined
class to conform to its new class definition.  Local slots specified by
the new class definition that are not specified as either local or
shared by the old class are added, and slots not specified as either
local or shared by the new class definition that are specified as local
by the old class are discarded.  The names of these added and discarded
slots are passed as arguments to ÿupdate-instance-for-redefined-classþ
as described in the next section.

The values of local slots specified by both the new and old classes are
retained. If such a local slot was unbound, it remains unbound.

The value of a slot that is specified as shared in the old class and as
local in the new class is retained.  If such a shared slot was unbound,
the local slot is unbound.

4.3.6.2 Initializing Newly Added Local Slots
............................................

The second step initializes the newly added local slots and performs
any other user-defined actions.  This step is implemented by the generic
function ÿupdate-instance-for-redefined-classþ, which is called after
completion of the first step of modifying the structure of the instance.

The generic function ÿupdate-instance-for-redefined-classþ takes four
required arguments: the instance being updated after it has undergone
the first step, a list of the names of local slots that were added, a
list of the names of local slots that were discarded, and a property
list containing the slot names and values of slots that were discarded
and had values.  Included among the discarded slots are slots that were
local in the old class and that are shared in the new class.

The generic function ÿupdate-instance-for-redefined-classþ also takes
any number of initialization arguments.  When it is called by the
system to update an instance whose class has been redefined, no
initialization arguments are provided.

There is a system-supplied primary method for
ÿupdate-instance-for-redefined-classþ whose parameter specializer for
its instance argument is the class ÿstandard-objectþ.  First this
method checks the validity of initialization arguments and signals an
error if an initialization argument is supplied that is not declared as
valid.  (For more information, see *Note Section 7.1.2 (Declaring the
Validity of Initialization Arguments): Declaring the Validity of
Initialization Arguments.)  Then it calls the generic function
ÿshared-initializeþ with the following arguments: the instance, the
list of names of the newly added slots, and the initialization
arguments it received.

4.3.6.3 Customizing Class Redefinition
......................................

Methods for ÿupdate-instance-for-redefined-classþ may be defined to
specify actions to be taken when an instance is updated.  If only after
methods for ÿupdate-instance-for-redefined-classþ are defined, they
will be run after the system-supplied primary method for initialization
and therefore will not interfere with the default behavior of
ÿupdate-instance-for-redefined-classþ.  Because no initialization
arguments are passed to ÿupdate-instance-for-redefined-classþ when it
is called by the system, the initialization forms for slots that are
filled by before methods for ÿupdate-instance-for-redefined-classþ will
not be evaluated by ÿshared-initializeþ.

Methods for ÿshared-initializeþ may be defined to customize class
redefinition.  For more information, see *Note Section 7.1.5
(Shared-Initialize): Shared-Initialize.


File: chris-ansicl.info,  Node: Integrating Types and Classes,  Prev: Redefining Classes,  Up: Classes

4.3.7 Integrating Types and Classes
-----------------------------------

The object system maps the space of classes into the space of types.
Every class that has a proper name has a corresponding type with the
same name.

The proper name of every class is a valid type specifier.  In addition,
every class object is a valid type specifier.  Thus the expression
ÿ(typep OBJECT CLASS)þ evaluates to true if the class of OBJECT is
CLASS itself or a subclass of class.  The evaluation of the expression
ÿ(subtypep class1 class2)þ returns the values true and true if ÿclass1þ
is a subclass of ÿclass2þ or if they are the same class; otherwise it
returns the values false and true.  If  I is an instance of some class
C named S and C is an instance of ÿstandard-classþ, the evaluation of
the expression ÿ(type-of I)þ returns S if S is the proper name of C;
otherwise, it returns C.

Because the names of classes and class objects are type specifiers,
they may be used in the special form ÿtheþ and in type declarations.

Many but not all of the predefined type specifiers have a corresponding
class with the same proper name as the type.  These type specifiers are
listed in *Note Figure 4.8: ClassTypeCorrespondence.  For example, the
type ÿarrayþ has a corresponding class named ÿarrayþ.  No type
specifier that is a list, such as ÿ(vector double-float 100)þ, has a
corresponding class.  The operator ÿdeftypeþ does not create any
classes.

Each class that corresponds to a predefined type specifier can be
implemented in one of three ways, at the discretion of each
implementation.  It can be a standard class, a structure class, or a
system class.

A built-in class is one whose generalized instances have restricted
capabilities or special representations.  Attempting to use ÿdefclassþ
to define subclasses of a ÿbuilt-in-classþ signals an error.  Calling
ÿmake-instanceþ to create a generalized instance of a built-in class
signals an error.  Calling ÿslot-valueþ on a generalized instance of a
built-in class signals an error.  Redefining a built-in class or using
ÿchange-classþ to change the class of an object to or from a built-in
class signals an error.  However, built-in classes can be used as
parameter specializers in methods.

It is possible to determine whether a class is a built-in class by
checking the metaclass.  A standard class  is an instance of the class
ÿstandard-classþ, a built-in class  is an instance of the class
ÿbuilt-in-classþ, and a structure class is an instance of the class
ÿstructure-classþ.

Each structure type created by ÿdefstructþ without using the :type
option has a corresponding class.  This class is a generalized instance
of the class ÿstructure-classþ.  The :include option of ÿdefstructþ
creates a direct subclass of the class that corresponds to the included
structure type.

It is implementation-dependent whether slots are involved in the
operation of functions defined in this specification on instances of
classes defined in this specification, except when slots are explicitly
defined by this specification.

If in a particular implementation a class defined in this specification
has slots that are not defined by this specfication, the names of these
slots must not be external symbols of packages defined in this
specification nor otherwise accessible in the ÿCL-USERþ package.

The purpose of specifying that many of the standard type specifiers
have a corresponding class is to enable users to write methods that
discriminate on these types.  Method selection requires that a class
precedence list can be determined for each class.

The hierarchical relationships among the type specifiers are mirrored by
relationships among the classes corresponding to those types.

*Note Figure 4.8: ClassTypeCorrespondence. lists the set of classes
that correspond to predefined type specifiers.

arithmetic-error                   generic-function     simple-error
array                              hash-table           simple-type-error
bit-vector                         integer              simple-warning
broadcast-stream                   list                 standard-class
built-in-class                     logical-pathname     standard-generic-function
cell-error                         method               standard-method
character                          method-combination   standard-object
class                              null                 storage-condition
complex                            number               stream
concatenated-stream                package              stream-error
condition                          package-error        string
cons                               parse-error          string-stream
control-error                      pathname             structure-class
division-by-zero                   print-not-readable   structure-object
echo-stream                        program-error        style-warning
end-of-file                        random-state         symbol
error                              ratio                synonym-stream
file-error                         rational             t
file-stream                        reader-error         two-way-stream
float                              readtable            type-error
floating-point-inexact             real                 unbound-slot
floating-point-invalid-operation   restart              unbound-variable
floating-point-overflow            sequence             undefined-function
floating-point-underflow           serious-condition    vector
function                           simple-condition     warning

Figure 4.8: Classes that correspond to pre-defined type specifiers

The class precedence list information specified in the entries for each
of these classes are those that are required by the object system.

Individual implementations may be extended to define other type
specifiers to have a corresponding class.  Individual implementations
may be extended to add other subclass relationships and to add other
elements to the class precedence lists as long as they do not violate
the type relationships and disjointness requirements specified by this
standard.  A standard class defined with no direct superclasses is
guaranteed to be disjoint from all of the classes in the table, except
for the class named ÿtþ.


File: chris-ansicl.info,  Node: nil (Type),  Next: boolean,  Prev: Classes,  Up: Types and Classes

nil (Type)
==========

Supertypes:
...........

all types

Description:
............

The type ÿnilþ contains no objects and so is also called the empty type.
The type ÿnilþ is a subtype of every type.  No object is of type ÿnilþ.

Notes:
......

The type containing the object ÿnilþ is the type ÿnullþ, not the type
ÿnilþ.


File: chris-ansicl.info,  Node: boolean,  Next: function (System Class),  Prev: nil (Type),  Up: Types and Classes

boolean (Type)
==============

Supertypes:
...........

ÿbooleanþ, ÿsymbolþ, ÿtþ

Description:
............

The type ÿbooleanþ contains the symbols t and nil, which represent true
and false, respectively.

See Also:
.........

*Note t (Constant Variable)::, *Note nil (Constant Variable)::, *Note
if::, *Note not (Function)::, *Note complement::

Notes:
......

Conditional operations, such as ÿifþ, permit the use of generalized
booleans, not just booleans; any non-nil value, not just t, counts as
true for a generalized boolean.  However, as a matter of convention,
the symbol t is considered the canonical value to use even for a
generalized boolean when no better choice presents itself.


File: chris-ansicl.info,  Node: function (System Class),  Next: compiled-function,  Prev: boolean,  Up: Types and Classes

function (System Class)
=======================

Class Precedence List:
......................

ÿfunctionþ, ÿtþ

Description:
............

A function is an object that represents code to be executed when an
appropriate number of arguments is supplied.  A function is produced by
the ÿfunctionþ special form, the function ÿcoerceþ, or the function
ÿcompileþ.  A function can be directly invoked by using it as the first
argument to ÿfuncallþ, ÿapplyþ, or ÿmultiple-value-callþ.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(function [arg-typespec [value-typespec]])

ARG-TYPESPEC::=
     ({typespec}*
      [&optional {typespec}*]
      [&rest TYPESPEC]
      [&key {(keyword typespec)}*])

Compound Type Specifier Arguments:
..................................

TYPESPEC--a type specifier.

VALUE-TYPESPEC--a type specifier.

Compound Type Specifier Description:
....................................

The list form of the ÿfunctionþ type-specifier can be used only for
declaration and not for discrimination.  Every element of this type is
a function that accepts arguments of the types specified by the
ARGJ-TYPES and returns values that are members of the types specified
by VALUE-TYPE. The ÿ&optionalþ, ÿ&restþ, ÿ&keyþ, and ÿ&allow-other-keysþ
markers can appear in the list of argument types.  The type specifier
provided with ÿ&restþ is the type of each actual argument, not the type
of the corresponding variable.

The ÿ&keyþ parameters should be supplied as lists of the form ÿ(KEYWORD
TYPE)þ.  The KEYWORD must be a valid keyword-name symbol as must be
supplied in the actual arguments of a call.  This is usually a symbol
in the ÿKEYWORDþ package but can be any symbol.  When ÿ&keyþ is given
in a ÿfunctionþ type specifier lambda list, the keyword parameters given
are exhaustive unless ÿ&allow-other-keysþ is also present.
ÿ&allow-other-keysþ is an indication that other keyword arguments might
actually be supplied and, if supplied, can be used.  For example, the
type of the function ÿmake-listþ could be declared as follows:

 (function ((integer 0) &key (:initial-element t)) list)

The VALUE-TYPE can be a ÿvaluesþ type specifier in order to indicate the
types of multiple values.

Consider a declaration of the following form:

 (ftype (function (arg0-type arg1-type ...) val-type) f))

Any form ÿ(f arg0 arg1 ...)þ within the scope of that declaration is
equivalent to the following:

 (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))

That is, the consequences are undefined if any of the arguments are not
of the specified types or the result is not of the specified type. In
particular, if any argument is not of the correct type, the result is
not guaranteed to be of the specified type.

Thus, an ÿftypeþ declaration for a function describes calls to the
function, not the actual definition of the function.

Consider a declaration of the following form:

 (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)

This declaration has the interpretation that, within the scope of the
declaration, the consequences are unspecified if the value of
ÿfn-valued-variableþ is called with arguments not of the specified
types; the value resulting from a valid call will be of type ÿval-typeþ.

As with variable type declarations, nested declarations imply
intersections of types, as follows:

   * Consider the following two declarations of ÿftypeþ:

      (ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))

     and

      (ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))

     If both these declarations are in effect, then within the shared
     scope of the declarations, calls to ÿfþ can be treated as if ÿfþ
     were declared as follows:

      (ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)
                       (and val-type1 val-type2))
             f))

     It is permitted to ignore one or all of the ÿftypeþ declarations
     in force.

   * If two (or more) type declarations are in effect for a variable,
     and they are both ÿfunctionþ declarations, the declarations
     combine similarly.


File: chris-ansicl.info,  Node: compiled-function,  Next: generic-function,  Prev: function (System Class),  Up: Types and Classes

compiled-function (Type)
========================

Supertypes:
...........

ÿcompiled-functionþ, ÿfunctionþ, ÿtþ

Description:
............

Any function may be considered by an implementation to be a a compiled
function if it contains no references to macros that must be expanded
at run time, and it contains no unresolved references to load time
values.  See *Note Section 3.2.2 (Compilation Semantics): Compilation
Semantics.

Functions whose definitions appear lexically within a file that has
been compiled with ÿcompile-fileþ and then loaded with ÿloadþ are of
type ÿcompiled-functionþ.  Functions produced by the ÿcompileþ function
are of type ÿcompiled-functionþ.  Other functions might also be of type
ÿcompiled-functionþ.


File: chris-ansicl.info,  Node: generic-function,  Next: standard-generic-function,  Prev: compiled-function,  Up: Types and Classes

generic-function (System Class)
===============================

Class Precedence List:
......................

ÿgeneric-functionþ, ÿfunctionþ, ÿtþ

Description:
............

A "generic function" is a function whose behavior depends on the
classes or identities of the arguments supplied to it.  A generic
function object contains a set of methods, a lambda list, a method
combination type, and other information.  The methods define the
class-specific behavior and operations of the generic function; a
method is said to specialize a generic function.  When invoked, a
generic function executes a subset of its methods based on the classes
or identities of its arguments.

A generic function can be used in the same ways that an ordinary
function can be used; specifically, a generic function can be used as
an argument to ÿfuncallþ and ÿapplyþ, and can be given a global or a
local name.


File: chris-ansicl.info,  Node: standard-generic-function,  Next: class,  Prev: generic-function,  Up: Types and Classes

standard-generic-function (System Class)
========================================

Class Precedence List:
......................

ÿstandard-generic-functionþ, ÿgeneric-functionþ, ÿfunctionþ, ÿtþ

Description:
............

The class ÿstandard-generic-functionþ is the default class of generic
functions established by ÿdefmethodþ, ÿensure-generic-functionþ,
ÿdefgenericþ, and ÿdefclassþ forms.


File: chris-ansicl.info,  Node: class,  Next: built-in-class,  Prev: standard-generic-function,  Up: Types and Classes

class (System Class)
====================

Class Precedence List:
......................

ÿclassþ, ÿstandard-objectþ, ÿtþ

Description:
............

The type ÿclassþ represents objects that determine the structure and
behavior of their instances. Associated with an object of type ÿclassþ
is information describing its place in the directed acyclic graph of
classes, its slots, and its options.


File: chris-ansicl.info,  Node: built-in-class,  Next: structure-class,  Prev: class,  Up: Types and Classes

built-in-class (System Class)
=============================

Class Precedence List:
......................

ÿbuilt-in-classþ, ÿclassþ, ÿstandard-objectþ, ÿtþ

Description:
............

A built-in class is a class whose instances have restricted
capabilities or special representations.  Attempting to use ÿdefclassþ
to define subclasses of a built-in class signals an error of type
ÿerrorþ.  Calling ÿmake-instanceþ to create an instance of a built-in
class signals an error of type ÿerrorþ.  Calling ÿslot-valueþ on an
instance of a built-in class signals an error of type ÿerrorþ.
Redefining a built-in class or using ÿchange-classþ to change the class
of an instance to or from a built-in class signals an error of type
ÿerrorþ.  However, built-in classes can be used as parameter
specializers in methods.


File: chris-ansicl.info,  Node: structure-class,  Next: standard-class,  Prev: built-in-class,  Up: Types and Classes

structure-class (System Class)
==============================

Class Precedence List:
......................

ÿstructure-classþ, ÿclassþ, ÿstandard-objectþ, ÿtþ

Description:
............

All classes defined by means of ÿdefstructþ are instances of the class
ÿstructure-classþ.


File: chris-ansicl.info,  Node: standard-class,  Next: method,  Prev: structure-class,  Up: Types and Classes

standard-class (System Class)
=============================

Class Precedence List:
......................

ÿstandard-classþ, ÿclassþ, ÿstandard-objectþ, ÿtþ

Description:
............

The class ÿstandard-classþ is the default class of classes defined by
ÿdefclassþ.


File: chris-ansicl.info,  Node: method,  Next: standard-method,  Prev: standard-class,  Up: Types and Classes

method (System Class)
=====================

Class Precedence List:
......................

ÿmethodþ, ÿtþ

Description:
............

A method is an object that represents a modular part of the behavior of
a generic function.

A method contains code to implement the method's behavior, a sequence
of parameter specializers that specify when the given method is
applicable, and a sequence of qualifiers that is used by the method
combination facility to distinguish among methods.  Each required
parameter of each method has an associated parameter specializer, and
the method will be invoked only on arguments that satisfy its parameter
specializers.

The method combination facility controls the selection of methods, the
order in which they are run, and the values that are returned by the
generic function.  The object system offers a default method
combination type and provides a facility for declaring new types of
method combination.

See Also:
.........

*Note Section 7.6 (Generic Functions and Methods): Generic Functions
and Methods.


File: chris-ansicl.info,  Node: standard-method,  Next: structure-object,  Prev: method,  Up: Types and Classes

standard-method (System Class)
==============================

Class Precedence List:
......................

ÿstandard-methodþ, ÿmethodþ, ÿstandard-objectþ, ÿtþ

Description:
............

The class ÿstandard-methodþ is the default class of methods defined by
the ÿdefmethodþ and ÿdefgenericþ forms.


File: chris-ansicl.info,  Node: structure-object,  Next: standard-object,  Prev: standard-method,  Up: Types and Classes

structure-object (Class)
========================

Class Precedence List:
......................

ÿstructure-objectþ, ÿtþ

Description:
............

The class ÿstructure-objectþ is an instance of ÿstructure-classþ and is
a superclass of every class that is an instance of ÿstructure-classþ
except itself, and is a superclass of every class that is defined by
ÿdefstructþ.

See Also:
.........

*Note defstruct::, *Note Section 2.4.8.13 (Sharpsign S): SharpsignS,
*Note Section 22.1.3.12 (Printing Structures): PrintingStructures.


File: chris-ansicl.info,  Node: standard-object,  Next: method-combination,  Prev: structure-object,  Up: Types and Classes

standard-object (Class)
=======================

Class Precedence List:
......................

ÿstandard-objectþ, ÿtþ

Description:
............

The class ÿstandard-objectþ is an instance of ÿstandard-classþ and is a
superclass of every class that is an instance of ÿstandard-classþ
except itself.


File: chris-ansicl.info,  Node: method-combination,  Next: t (System Class),  Prev: standard-object,  Up: Types and Classes

method-combination (System Class)
=================================

Class Precedence List:
......................

ÿmethod-combinationþ, ÿtþ

Description:
............

Every method combination object is an indirect instance of the class
ÿmethod-combinationþ.  A method combination object represents the
information about the method combination being used by a generic
function.  A method combination object contains information about both
the type of method combination and the arguments being used with that
type.


File: chris-ansicl.info,  Node: t (System Class),  Next: satisfies,  Prev: method-combination,  Up: Types and Classes

t (System Class)
================

Class Precedence List:
......................

ÿtþ

Description:
............

The set of all objects.  The type ÿtþ is a supertype of every type,
including itself. Every object is of type ÿtþ.


File: chris-ansicl.info,  Node: satisfies,  Next: member (Type Specifier),  Prev: t (System Class),  Up: Types and Classes

satisfies (Type Specifier)
==========================

Compound Type Specifier Kind:
.............................

Predicating.

Compound Type Specifier Syntax:
...............................

(satisfies predicate-name)

Compound Type Specifier Arguments:
..................................

PREDICATE-NAME--a symbol.

Compound Type Specifier Description:
....................................

This denotes the set of all objects that satisfy the predicate
PREDICATE-NAME, which must be a symbol whose global function definition
is a one-argument predicate.  A name is required for PREDICATE-NAME;
lambda expressions are not allowed.  For example, the type specifier
ÿ(and integer (satisfies evenp))þ denotes the set of all even integers.
The form ÿ(typep X '(satisfies P))þ is equivalent to ÿ(if (P X) t nil)þ.

The argument is required.  The symbol * can be the argument, but it
denotes itself (the symbol *), and does not represent an unspecified
value.

The symbol ÿsatisfiesþ is not valid as a type specifier.


File: chris-ansicl.info,  Node: member (Type Specifier),  Next: not (Type Specifier),  Prev: satisfies,  Up: Types and Classes

member (Type Specifier)
=======================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(member {object}*)

Compound Type Specifier Arguments:
..................................

OBJECT--an object.

Compound Type Specifier Description:
....................................

This denotes the set containing the named OBJECTS. An object is of this
type if and only if it is ÿeqlþ to one of the specified OBJECTS.

The type specifiers ÿ(member)þ and ÿnilþ are equivalent.  * can be
among the OBJECTS, but if so it denotes itself (the symbol *) and does
not represent an unspecified value.  The symbol member is not valid as
a type specifier; and, specifically, it is not an abbreviation for
either ÿ(member)þ or ÿ(member *)þ.

See Also:
.........

the type ÿeqlþ


File: chris-ansicl.info,  Node: not (Type Specifier),  Next: and (Type Specifier),  Prev: member (Type Specifier),  Up: Types and Classes

not (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(not typespec)

Compound Type Specifier Arguments:
..................................

TYPESPEC--a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of all objects that are not of the type TYPESPEC.

The argument is required, and cannot be *.

The symbol ÿnotþ is not valid as a type specifier.


File: chris-ansicl.info,  Node: and (Type Specifier),  Next: or (Type Specifier),  Prev: not (Type Specifier),  Up: Types and Classes

and (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(and {typespec}*)

Compound Type Specifier Arguments:
..................................

TYPESPEC--a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of all objects of the type determined by the
intersection of the TYPESPECS.

* is not permitted as an argument.

The type specifiers ÿ(and)þ and ÿtþ are equivalent.  The symbol and is
not valid as a type specifier, and, specifically, it is not an
abbreviation for ÿ(and)þ.


File: chris-ansicl.info,  Node: or (Type Specifier),  Next: values (Type Specifier),  Prev: and (Type Specifier),  Up: Types and Classes

or (Type Specifier)
===================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(or {typespec}*)

Compound Type Specifier Arguments:
..................................

TYPESPEC--a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of all objects of the type determined by the union
of the TYPESPECS.  For example, the type ÿlistþ by definition is the
same as ÿ(or null cons)þ.  Also, the value returned by ÿpositionþ is an
object of type ÿ(or null (integer 0 *))þ; i.e., either ÿnilþ or a
non-negative integer.

* is not permitted as an argument.

The type specifiers ÿ(or)þ and ÿnilþ are equivalent.  The symbol ÿorþ
is not valid as a type specifier; and, specifically, it is not an
abbreviation for ÿ(or)þ.


File: chris-ansicl.info,  Node: values (Type Specifier),  Next: eql (Type Specifier),  Prev: or (Type Specifier),  Up: Types and Classes

values (Type Specifier)
=======================

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(values ûvalue-typespec)

VALUE-TYPESPEC::=
     {typespec}* [&optional {typespec}*] [&rest typespec]
     [ÿ&allow-other-keysþ]

Compound Type Specifier Arguments:
..................................

TYPESPEC--a type specifier.

Compound Type Specifier Description:
....................................

This type specifier can be used only as the VALUE-TYPE in a ÿfunctionþ
type specifier or a ÿtheþ special form.  It is used to specify
individual types when multiple values are involved.  The ÿ&optionalþ
and ÿ&restþ markers can appear in the VALUE-TYPE list; they indicate
the parameter list of a function that, when given to
ÿmultiple-value-callþ along with the values, would correctly receive
those values.

The symbol * may not be among the VALUE-TYPES.

The symbol values is not valid as a type specifier; and, specifically,
it is not an abbreviation for ÿ(values)þ.


File: chris-ansicl.info,  Node: eql (Type Specifier),  Next: coerce,  Prev: values (Type Specifier),  Up: Types and Classes

eql (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Combining.

Compound Type Specifier Syntax:
...............................

(eql object)

Compound Type Specifier Arguments:
..................................

OBJECT--an object.

Compound Type Specifier Description:
....................................

Represents the type of all X for which ÿ(eql OBJECT X)þ is true.

The argument OBJECT is required.  The OBJECT can be *, but if so it
denotes itself (the symbol *) and does not represent an unspecified
value.  The symbol eql is not valid as an atomic type specifier.


File: chris-ansicl.info,  Node: coerce,  Next: deftype,  Prev: eql (Type Specifier),  Up: Types and Classes

coerce (Function)
=================

Syntax:
.......

 -- Function: coerce object result-type ý result

Arguments and Values:
.....................

OBJECT--an object.

RESULT-TYPE--a type specifier.

RESULT--an object, of type RESULT-TYPE except in situations described
in *Note Section 12.1.5.3 (Rule of Canonical Representation for Complex
Rationals): RuleOfCanonRepForComplexRationals.

Description:
............

Coerces the OBJECT to type RESULT-TYPE.

If OBJECT is already of type RESULT-TYPE, the OBJECT itself is
returned, regardless of whether it would have been possible in general
to coerce an object of some other type to RESULT-TYPE.

Otherwise, the OBJECT is coerced to type RESULT-TYPE according to the
following rules:

ÿsequenceþ
     If the RESULT-TYPE is a recognizable subtype of ÿlistþ, and the
     object is a sequence, then the RESULT is a list that has the same
     elements as OBJECT.

     If the RESULT-TYPE is a recognizable subtype of ÿvectorþ, and the
     object is a sequence, then the RESULT is a vector that has the
     same elements as OBJECT.  If RESULT-TYPE is a specialized type,
     the RESULT has an actual array element type that is the result of
     upgrading the element type part of that specialized type.  If no
     element type is specified, the element type defaults to ÿtþ.  If
     the implementation cannot determine the element type, an error is
     signaled.

ÿcharacterþ
     If the RESULT-TYPE is ÿcharacterþ and the object is a character
     designator, the RESULT is the character it denotes.

ÿcomplexþ
     If the RESULT-TYPE is ÿcomplexþ and the object is a real, then the
     RESULT is obtained by constructing a complex whose real part is
     the object and whose imaginary part is the result of coercing an
     integer zero to the type of the object (using ÿcoerceþ).  (If the
     real part is a rational, however, then the result must be
     represented as a rational rather than a complex; see *Note Section
     12.1.5.3 (Rule of Canonical Representation for Complex Rationals):
     RuleOfCanonRepForComplexRationals.  So, for example, ÿ(coerce 3
     'complex)þ is permissible, but will return ÿ3þ, which is not a
     complex.)

ÿfloatþ
     If the RESULT-TYPE is any of ÿfloatþ, ÿshort-floatþ,
     ÿsingle-floatþ, ÿdouble-floatþ, ÿlong-floatþ, and the object is a
     real, then the RESULT is a float of type RESULT-TYPE which is
     equal in sign and magnitude to the object to whatever degree of
     representational precision is permitted by that float
     representation.  (If the RESULT-TYPE is ÿfloatþ and OBJECT is not
     already a float, then the RESULT is a single float.)

ÿfunctionþ
     If the RESULT-TYPE is ÿfunctionþ, and OBJECT is any function name
     that is fbound but that is globally defined neither as a macro
     name nor as a special operator, then the RESULT is the functional
     value of OBJECT.

     If the RESULT-TYPE is ÿfunctionþ, and OBJECT is a lambda
     expression, then the RESULT is a closure of OBJECT in the null
     lexical environment.

ÿtþ
     Any OBJECT can be coerced to an object of type ÿtþ.  In this case,
     the OBJECT is simply returned.

Examples:
.........

 (coerce '(a b c) 'vector) ý #(A B C)
 (coerce 'a 'character) ý #\A
 (coerce 4.56 'complex) ý #C(4.56 0.0)
 (coerce 4.5s0 'complex) ý #C(4.5s0 0.0s0)
 (coerce 7/2 'complex) ý 7/2
 (coerce 0 'short-float) ý 0.0s0
 (coerce 3.5L0 'float) ý 3.5L0
 (coerce 7/2 'float) ý 3.5
 (coerce (cons 1 2) t) ý (1 . 2)

All the following forms should signal an error:

 (coerce '(a b c) '(vector * 4))
 (coerce #(a b c) '(vector * 4))
 (coerce '(a b c) '(vector * 2))
 (coerce #(a b c) '(vector * 2))
 (coerce "foo" '(string 2))
 (coerce #(#\a #\b #\c) '(string 2))
 (coerce '(0 1) '(simple-bit-vector 3))

Exceptional Situations:
.......................

If a coercion is not possible, an error of type ÿtype-errorþ is
signaled.

ÿ(coerce x 'nil)þ always signals an error of type ÿtype-errorþ.

An error of type ÿerrorþ is signaled if the RESULT-TYPE is ÿfunctionþ
but OBJECT is a symbol that is not fbound or if the symbol names a
macro or a special operator.

An error of type ÿtype-errorþ should be signaled if RESULT-TYPE
specifies the number of elements and OBJECT is of a different length.

See Also:
.........

*Note rational::, *Note floor::, *Note char-code::, *Note char-int::

Notes:
......

Coercions from floats to rationals and from ratios to integers are not
provided because of rounding problems.

 (coerce x 't) Õ (identity x) Õ x


File: chris-ansicl.info,  Node: deftype,  Next: subtypep,  Prev: coerce,  Up: Types and Classes

deftype (Macro)
===============

Syntax:
.......

 -- Macro: deftype name lambda-list ù{declaration}* | documentationø
          {form}* ý name

Arguments and Values:
.....................

NAME--a symbol.

LAMBDA-LIST--a deftype lambda list.

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORM--a form.

Description:
............

ÿdeftypeþ defines a derived type specifier named NAME.

The meaning of the new type specifier is given in terms of a function
which expands the type specifier into another type specifier, which
itself will be expanded if it contains references to another derived
type specifier.

The newly defined type specifier may be referenced as a list of the
form ÿ(NAME ARG_1 ARG_2 ...)þ.  The number of arguments must be
appropriate to the LAMBDA-LIST.  If the new type specifier takes no
arguments, or if all of its arguments are optional, the type specifier
may be used as an atomic type specifier.

The argument expressions to the type specifier, ARG_1 ... ARG_N, are
not evaluated.  Instead, these literal objects become the objects to
which corresponding parameters become bound.

The body of the ÿdeftypeþ form (but not the LAMBDA-LIST) is implicitly
enclosed in a block named NAME, and is evaluated as an implicit progn,
returning a new type specifier.

The lexical environment of the body is the one which was current at the
time the ÿdeftypeþ form was evaluated, augmented by the variables in
the LAMBDA-LIST.

Recursive expansion of the type specifier returned as the expansion
must terminate, including the expansion of type specifiers which are
nested within the expansion.

The consequences are undefined if the result of fully expanding a type
specifier contains any circular structure, except within the objects
referred to by ÿmemberþ and ÿeqlþ type specifiers.

DOCUMENTATION is attached to NAME as a documentation string of kind
type.

If a ÿdeftypeþ form appears as a top level form, the compiler must
ensure that the NAME is recognized in subsequent type declarations.
The programmer must ensure that the body of a ÿdeftypeþ form can be
evaluated at compile time if the NAME is referenced in subsequent type
declarations.  If the expansion of a type specifier is not defined
fully at compile time (perhaps because it expands into an unknown type
specifier or a ÿsatisfiesþ of a named function that isn't defined in the
compile-time environment), an implementation may ignore any references
to this type in declarations and/or signal a warning.

Examples:
.........

 (defun equidimensional (a)
   (or (< (array-rank a) 2)
       (apply #'= (array-dimensions a)))) ý EQUIDIMENSIONAL
 (deftype square-matrix (&optional type size)
   `(and (array ,type (,size ,size))
         (satisfies equidimensional))) ý SQUARE-MATRIX

See Also:
.........

*Note declare::, *Note defmacro::, *Note documentation::, *Note Section
4.2.3 (Type Specifiers): Type Specifiers, *Note Section 3.4.11
(Syntactic Interaction of Documentation Strings and Declarations):
Syntactic Interaction of Documentation Strings and Declarations.


File: chris-ansicl.info,  Node: subtypep,  Next: type-of,  Prev: deftype,  Up: Types and Classes

subtypep (Function)
===================

Syntax:
.......

 -- Function: subtypep type-1 type-2 &optional environment ý subtype-p,
          valid-p

Arguments and Values:
.....................

TYPE-1--a type specifier.

TYPE-2--a type specifier.

ENVIRONMENT--an environment object.  The default is ÿnilþ, denoting the
null lexical environment and the current global environment.

SUBTYPE-P--a generalized boolean.

VALID-P--a generalized boolean.

Description:
............

If TYPE-1 is a recognizable subtype of TYPE-2, the first value is true.
Otherwise, the first value is false, indicating that either TYPE-1 is
not a subtype of TYPE-2, or else TYPE-1 is a subtype of TYPE-2 but is
not a recognizable subtype.

A second value is also returned indicating the `certainty' of the first
value.  If this value is true, then the first value is an accurate
indication of the subtype relationship.  (The second value is always
true when the first value is true.)

The next figure summarizes the possible combinations of values that
might result.

Value 1   Value 2   Meaning
--------------------------------------------------------------------------- 
true      true      TYPE-1 is definitely a subtype of TYPE-2.
false     true      TYPE-1 is definitely not a subtype of TYPE-2.
false     false     ÿsubtypepþ could not determine the relationship,
                    so TYPE-1 might or might not be a subtype of TYPE-2.

Figure 4.9: Result possibilities for subtypep

ÿsubtypepþ is permitted to return the values false and false only when
at least one argument involves one of these type specifiers: ÿandþ,
ÿeqlþ, the list form of ÿfunctionþ, ÿmemberþ, ÿnotþ, ÿorþ, ÿsatisfiesþ,
or ÿvaluesþ.  (A type specifier `involves' such a symbol if, after
being type expanded, it contains that symbol in a position that would
call for its meaning as a type specifier to be used.)  One consequence
of this is that if neither TYPE-1 nor TYPE-2 involves any of these type
specifiers, then ÿsubtypepþ is obliged to determine the relationship
accurately.  In particular, ÿsubtypepþ returns the values true and true
if the arguments are ÿequalþ and do not involve any of these type
specifiers.

ÿsubtypepþ never returns a second value of ÿnilþ when both TYPE-1 and
TYPE-2 involve only the names in *Note Figure 4.2:
StandardizedAtomicTypeSpecs, or names of types defined by ÿdefstructþ,
ÿdefine-conditionþ, or ÿdefclassþ, or derived types that expand into
only those names.  While type specifiers listed in *Note Figure 4.2:
StandardizedAtomicTypeSpecs. and names of ÿdefclassþ and ÿdefstructþ
can in some cases be implemented as derived types, ÿsubtypepþ regards
them as primitive.

The relationships between types reflected by ÿsubtypepþ are those
specific to the particular implementation.  For example, if an
implementation supports only a single type of floating-point numbers,
in that implementation ÿ(subtypep 'float 'long-float)þ returns the
values true and true (since the two types are identical).

For all T1 and T2 other than ÿ*þ, ÿ(array T1)þ and ÿ(array T2)þ are two
different type specifiers that always refer to the same sets of things
if and only if they refer to arrays of exactly the same specialized
representation, i.e., if ÿ(upgraded-array-element-type 'T1)þ  and
ÿ(upgraded-array-element-type 'T2)þ return two different type
specifiers that always refer to the same sets of objects.  This is
another way of saying that ÿ`(array TYPE-SPECIFIER)þ and ÿ`(array
,(upgraded-array-element-type 'TYPE-SPECIFIER))þ refer to the same set
of specialized array representations.  For all T1 and T2 other than ÿ*þ,
the intersection of ÿ(array T1)þ and ÿ(array T2)þ is the empty set if
and only if they refer to arrays of different, distinct specialized
representations.

Therefore,

 (subtypep '(array T1) '(array T2)) ý true

if and only if

 (upgraded-array-element-type 'T1)  and
 (upgraded-array-element-type 'T2)

return two different type specifiers that always refer to the same sets
of objects.

For all type-specifiers T1 and T2 other than ÿ*þ,

 (subtypep '(complex T1) '(complex T2)) ý true, true

if:

  1. ÿT1þ is a subtype of ÿT2þ, or

  2. ÿ(upgraded-complex-part-type 'T1)þ and
     ÿ(upgraded-complex-part-type 'T2)þ return two different type
     specifiers that always refer to the same sets of objects; in this
     case, ÿ(complex T1)þ and ÿ(complex T2)þ both refer to the same
     specialized representation.

The values are false and true otherwise.

The form

 (subtypep '(complex single-float) '(complex float))

must return true in all implementations, but

 (subtypep '(array single-float) '(array float))

returns true only in implementations that do not have a specialized
array representation for single floats distinct from that for other
floats.

Examples:
.........

 (subtypep 'compiled-function 'function) ý true, true
 (subtypep 'null 'list) ý true, true
 (subtypep 'null 'symbol) ý true, true
 (subtypep 'integer 'string) ý false, true
 (subtypep '(satisfies dummy) nil) ý false, implementation-dependent
 (subtypep '(integer 1 3) '(integer 1 4)) ý true, true
 (subtypep '(integer (0) (0)) 'nil) ý true, true
 (subtypep 'nil '(integer (0) (0))) ý true, true
 (subtypep '(integer (0) (0)) '(member)) ý true, true ;or false, false
 (subtypep '(member) 'nil) ý true, true ;or false, false
 (subtypep 'nil '(member)) ý true, true ;or false, false

Let ÿ<aet-x>þ and ÿ<aet-y>þ be two distinct type specifiers that do not
always refer to the same sets of objects in a given implementation, but
for which ÿmake-arrayþ, will return an object of the same array type.

Thus, in each case,

  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))
            (array-element-type (make-array 0 :element-type '<aet-y>)))
ý true, true

  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))
            (array-element-type (make-array 0 :element-type '<aet-x>)))
ý true, true

If  ÿ(array <aet-x>)þ and ÿ(array <aet-y>)þ are different names for
exactly the same set of objects, these names should always refer to the
same sets of objects.  That implies that the following set of tests are
also true:

 (subtypep '(array <aet-x>) '(array <aet-y>)) ý true, true
 (subtypep '(array <aet-y>) '(array <aet-x>)) ý true, true

See Also:
.........

*Note Section 4.2 (Types): Types.

Notes:
......

The small differences between the ÿsubtypepþ specification for the
ÿarrayþ and ÿcomplexþ types are necessary because there is no creation
function for complexes which allows the specification of the resultant
part type independently of the actual types of the parts.  Thus in the
case of the type ÿcomplexþ, the actual type of the parts is referred
to, although a number can be a member of more than one type.  For
example, ÿ17þ is of type ÿ(mod 18)þ as well as type ÿ(mod 256)þ and
type ÿintegerþ; and ÿ2.3f5þ is of type ÿsingle-floatþ as well as type
ÿfloatþ.


File: chris-ansicl.info,  Node: type-of,  Next: typep,  Prev: subtypep,  Up: Types and Classes

type-of (Function)
==================

Syntax:
.......

 -- Function: type-of object ý typespec

Arguments and Values:
.....................

OBJECT--an object.

TYPESPEC--a type specifier.

Description:
............

Returns a type specifier, TYPESPEC, for a type that has the OBJECT as
an element.  The TYPESPEC satisfies the following:

  1. For any OBJECT that is an element of some built-in type:

       a. the type returned is a recognizable subtype of that built-in
          type.

       b. the type returned does not involve ÿandþ, ÿeqlþ, ÿmemberþ,
          ÿnotþ, ÿorþ, ÿsatisfiesþ, or ÿvaluesþ.

  2. For all OBJECTS, ÿ(typep OBJECT (type-of OBJECT))þ returns true.
     Implicit in this is that type specifiers which are not valid for
     use with ÿtypepþ, such as the list form of the ÿfunctionþ type
     specifier, are never returned by ÿtype-ofþ.

  3. The type returned by ÿtype-ofþ is always a recognizable subtype of
     the class returned by ÿclass-ofþ.  That is,

      (subtypep (type-of OBJECT) (class-of OBJECT)) ý true, true

  4. For OBJECTS of metaclass ÿstructure-classþ or ÿstandard-classþ,
     and for conditions, ÿtype-ofþ returns the proper name of the class
     returned by ÿclass-ofþ if it has a proper name, and otherwise
     returns the class itself.  In particular, for OBJECTS created by
     the constructor function of a structure defined with ÿdefstructþ
     without a :type option, ÿtype-ofþ returns the structure name; and
     for OBJECTS created by ÿmake-conditionþ, the TYPESPEC is the name
     of the condition type.

  5. For each of the types ÿshort-floatþ, ÿsingle-floatþ,
     ÿdouble-floatþ, or ÿlong-floatþ of which the OBJECT is an element,
     the TYPESPEC is a recognizable subtype of that type.

Examples:
.........


 (type-of 'a) ý SYMBOL
 (type-of '(1 . 2))
ý CONS
orý (CONS FIXNUM FIXNUM)
 (type-of #c(0 1))
ý COMPLEX
orý (COMPLEX INTEGER)
 (defstruct temp-struct x y z) ý TEMP-STRUCT
 (type-of (make-temp-struct)) ý TEMP-STRUCT
 (type-of "abc")
ý STRING
orý (STRING 3)
 (subtypep (type-of "abc") 'string) ý true, true
 (type-of (expt 2 40))
ý BIGNUM
orý INTEGER
orý (INTEGER 1099511627776 1099511627776)
orý SYSTEM::TWO-WORD-BIGNUM
orý FIXNUM
 (subtypep (type-of 112312) 'integer) ý true, true
 (defvar *foo* (make-array 5 :element-type t)) ý *FOO*
 (class-name (class-of *foo*)) ý VECTOR
 (type-of *foo*)
ý VECTOR
orý (VECTOR T 5)

See Also:
.........

*Note array-element-type::, *Note class-of::, *Note defstruct::, *Note
typecase::, *Note typep::, *Note Section 4.2 (Types): Types.

Notes:
......

Implementors are encouraged to arrange for ÿtype-ofþ to return a
portable value.


File: chris-ansicl.info,  Node: typep,  Next: type-error,  Prev: type-of,  Up: Types and Classes

typep (Function)
================

Syntax:
.......

 -- Function: typep object type-specifier &optional environment ý
          generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

TYPE-SPECIFIER--any type specifier except values, or a type specifier
list whose first element is either function or values.

ENVIRONMENT--an environment object.  The default is ÿnilþ, denoting the
null lexical environment and the and current global environment.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of the type specified by TYPE-SPECIFIER;
otherwise, returns false.

A TYPE-SPECIFIER of the form ÿ(satisfies fn)þ is handled by applying
the function ÿfnþ to OBJECT.

ÿ(typep OBJECT '(array TYPE-SPECIFIER))þ, where TYPE-SPECIFIER is not
ÿ*þ, returns true if and only if OBJECT is an array that could be the
result of supplying TYPE-SPECIFIER as the :element-type argument to
ÿmake-arrayþ.  ÿ(array *)þ refers to all arrays regardless of element
type, while ÿ(array TYPE-SPECIFIER)þ refers only to those arrays that
can result from giving TYPE-SPECIFIER as the :element-type argument to
ÿmake-arrayþ.  A similar interpretation applies to ÿ(simple-array
TYPE-SPECIFIER)þ and ÿ(vector TYPE-SPECIFIER)þ.  See *Note Section
15.1.2.1 (Array Upgrading): ArrayUpgrading.

ÿ(typep OBJECT '(complex TYPE-SPECIFIER))þ returns true for all complex
numbers that can result from giving numbers of type TYPE-SPECIFIER to
the function ÿcomplexþ, plus all other complex numbers of the same
specialized representation.  Both the real and the imaginary parts of
any such complex number must satisfy:

 (typep realpart 'type-specifier)
 (typep imagpart 'type-specifier)

See the function *Note upgraded-complex-part-type::.

Examples:
.........

 (typep 12 'integer) ý true
 (typep (1+ most-positive-fixnum) 'fixnum) ý false
 (typep nil t) ý true
 (typep nil nil) ý false
 (typep 1 '(mod 2)) ý true
 (typep #c(1 1) '(complex (eql 1))) ý true
;; To understand this next example, you might need to refer to
;; *Note Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals): RuleOfCanonRepForComplexRationals.
 (typep #c(0 0) '(complex (eql 0))) ý false

Let ÿA_xþ and ÿA_yþ be two type specifiers that denote different types,
but for which

 (upgraded-array-element-type 'A_x)

and

 (upgraded-array-element-type 'A_y)

denote the same type.  Notice that

 (typep (make-array 0 :element-type 'A_x) '(array A_x)) ý true
 (typep (make-array 0 :element-type 'A_y) '(array A_y)) ý true
 (typep (make-array 0 :element-type 'A_x) '(array A_y)) ý true
 (typep (make-array 0 :element-type 'A_y) '(array A_x)) ý true

Exceptional Situations:
.......................

An error of type ÿerrorþ is signaled if TYPE-SPECIFIER is ÿvaluesþ, or
a type specifier list whose first element is either function or values.

The consequences are undefined if the TYPE-SPECIFIER is not a type
specifier.

See Also:
.........

*Note type-of::, *Note upgraded-array-element-type::, *Note
upgraded-complex-part-type::, *Note Section 4.2.3 (Type Specifiers):
Type Specifiers.

Notes:
......

Implementations are encouraged to recognize and optimize the case of
ÿ(typep X (the class Y))þ, since it does not involve any need for
expansion of ÿdeftypeþ information at runtime.



File: chris-ansicl.info,  Node: type-error,  Next: type-error-datum; type-error-expected-type,  Prev: typep,  Up: Types and Classes

type-error (Condition Type)
===========================

Class Precedence List:
......................

ÿtype-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿtype-errorþ represents a situation in which an object is not
of the expected type.  The "offending datum" and "expected type" are
initialized by the initialization arguments named :datum and
:expected-type to ÿmake-conditionþ, and are accessed by the functions
ÿtype-error-datumþ and ÿtype-error-expected-typeþ.

See Also:
.........

*Note type-error-datum::, *Note type-error-expected-type::


File: chris-ansicl.info,  Node: type-error-datum; type-error-expected-type,  Next: simple-type-error,  Prev: type-error,  Up: Types and Classes

type-error-datum, type-error-expected-type (Function)
=====================================================

Syntax:
.......

 -- Function: type-error-datum condition ý datum

 -- Function: type-error-expected-type condition ý expected-type

Arguments and Values:
.....................

CONDITION--a condition of type ÿtype-errorþ.

DATUM--an object.

EXPECTED-TYPE--a type specifier.

Description:
............

ÿtype-error-datumþ returns the offending datum in the situation
represented by the CONDITION.

ÿtype-error-expected-typeþ returns the expected type of the offending
datum in the situation represented by the CONDITION.

Examples:
.........

 (defun fix-digits (condition)
   (check-type condition type-error)
   (let* ((digits '(zero one two three four
                   five six seven eight nine))
         (val (position (type-error-datum condition) digits)))
     (if (and val (subtypep 'fixnum (type-error-expected-type condition)))
         (store-value 7))))

 (defun foo (x)
   (handler-bind ((type-error #'fix-digits))
     (check-type x number)
     (+ x 3)))

 (foo 'seven)
ý 10

See Also:
.........

*Note type-error::, *Note Chapter 9 (Conditions): Conditions.


File: chris-ansicl.info,  Node: simple-type-error,  Prev: type-error-datum; type-error-expected-type,  Up: Types and Classes

simple-type-error (Condition Type)
==================================

Class Precedence List:
......................

ÿsimple-type-errorþ, ÿsimple-conditionþ, ÿtype-errorþ, ÿerrorþ,
ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

Conditions of type ÿsimple-type-errorþ are like conditions of type
ÿtype-errorþ, except that they provide an alternate mechanism for
specifying how the condition is to be reported; see the type *Note
simple-condition::.

See Also:
.........

*Note simple-condition::, *Note simple-condition-format-control::,
*Note simple-condition-format-arguments::, *Note type-error-datum::,
*Note type-error-expected-type::


File: chris-ansicl.info,  Node: Data and Control Flow,  Next: Iteration,  Prev: Types and Classes,  Up: Top

5 Data and Control Flow
***********************

* Menu:

* Generalized Reference::
* Transfer of Control to an Exit Point::

Dictionary

* apply::
* defun::
* fdefinition::
* fboundp::
* fmakunbound::
* flet; labels; macrolet::
* funcall::
* function (Special Operator)::
* function-lambda-expression::
* functionp::
* compiled-function-p::
* call-arguments-limit::
* lambda-list-keywords::
* lambda-parameters-limit::
* defconstant::
* defparameter; defvar::
* destructuring-bind::
* let; let*::
* progv::
* setq::
* psetq::
* block::
* catch::
* go::
* return-from::
* return::
* tagbody::
* throw::
* unwind-protect::
* nil (Constant Variable)::
* not (Function)::
* t (Constant Variable)::
* eq::
* eql (Function)::
* equal::
* equalp::
* identity::
* complement::
* constantly::
* every; some; notevery; notany::
* and (Macro)::
* cond::
* if::
* or (Macro)::
* when; unless::
* case; ccase; ecase::
* typecase; ctypecase; etypecase::
* multiple-value-bind::
* multiple-value-call::
* multiple-value-list::
* multiple-value-prog1::
* multiple-value-setq::
* values (Accessor)::
* values-list::
* multiple-values-limit::
* nth-value::
* prog; prog*::
* prog1; prog2::
* progn::
* define-modify-macro::
* defsetf::
* define-setf-expander::
* get-setf-expansion::
* setf; psetf::
* shiftf::
* rotatef::
* control-error::
* program-error::
* undefined-function::


File: chris-ansicl.info,  Node: Generalized Reference,  Next: Transfer of Control to an Exit Point,  Up: Data and Control Flow

5.1 Generalized Reference
=========================

* Menu:

* Overview of Places and Generalized Reference::
* Kinds of Places::
* Treatment of Other Macros Based on SETF::


File: chris-ansicl.info,  Node: Overview of Places and Generalized Reference,  Next: Kinds of Places,  Up: Generalized Reference

5.1.1 Overview of Places and Generalized Reference
--------------------------------------------------

A "generalized reference" is the use of a form, sometimes called a "place",
as if it were a variable that could be read and written.  The value of
a place is the object to which the place form evaluates.  The value of
a place can be changed by using ÿsetfþ.  The concept of binding a place
is not defined in Common Lisp, but an implementation is permitted to
extend the language by defining this concept.

The next figure contains examples of the use of ÿsetfþ.  Note that the
values returned by evaluating the forms in column two are not
necessarily the same as those obtained by evaluating the forms in
column three.  In general, the exact macro expansion of a ÿsetfþ form
is not guaranteed and can even be implementation-dependent; all that is
guaranteed is that the expansion is an update form that works for that
particular implementation, that the left-to-right evaluation of
subforms is preserved, and that the ultimate result of evaluating
ÿsetfþ is the value or values being stored.

Access function      Update Function      Update using ÿsetfþ
---------------------------------------------------------------------------- 
ÿxþ                  ÿ(setq x datum)þ     ÿ(setf x datum)þ
ÿ(car x)þ            ÿ(rplaca x datum)þ   ÿ(setf (car x) datum)þ
ÿ(symbol-value x)þ   ÿ(set x datum)þ      ÿ(setf (symbol-value x) datum)þ

Figure 5.1: Examples of setf

The next figure shows operators relating to places and generalized
reference.

assert                 defsetf              push
ccase                  get-setf-expansion   remf
ctypecase              getf                 rotatef
decf                   incf                 setf
define-modify-macro    pop                  shiftf
define-setf-expander   psetf                

Figure 5.2: Operators relating to places and generalized reference.

Some of the operators above manipulate places and some manipulate setf
expanders.  A setf expansion can be derived from any place.  New setf
expanders can be defined by using ÿdefsetfþ and ÿdefine-setf-expanderþ.

5.1.1.1 Evaluation of Subforms to Places
........................................

The following rules apply to the evaluation of subforms in a place:

  1. The evaluation ordering of subforms within a place is determined
     by the order specified by the second value returned by
     ÿget-setf-expansionþ.  For all places defined by this specification
     (e.g., ÿgetfþ, ÿldbþ, ...), this order of evaluation is
     left-to-right.  When a place is derived from a macro expansion,
     this rule is applied after the macro is expanded to find the
     appropriate place.

     Places defined by using ÿdefmacroþ or ÿdefine-setf-expanderþ use
     the evaluation order defined by those definitions.  For example,
     consider the following:

      (defmacro wrong-order (x y) `(getf ,y ,x))

     This following form evaluates ÿplace2þ first and then ÿplace1þ
     because that is the order they are evaluated in the macro
     expansion:

      (push value (wrong-order place1 place2))

  2. For the macros that manipulate places (ÿpushþ, ÿpushnewþ, ÿremfþ,
     ÿincfþ, ÿdecfþ, ÿshiftfþ, ÿrotatefþ, ÿpsetfþ, ÿsetfþ, ÿpopþ, and
     those defined by ÿdefine-modify-macroþ) the subforms of the macro
     call are evaluated exactly once in left-to-right order, with the
     subforms of the places evaluated in the order specified in (1).

     ÿpushþ, ÿpushnewþ, ÿremfþ, ÿincfþ, ÿdecfþ, ÿshiftfþ, ÿrotatefþ,
     ÿpsetfþ, ÿpopþ evaluate all subforms before modifying any of the
     place locations.  ÿsetfþ (in the case when ÿsetfþ has more than
     two arguments) performs its operation on each pair in sequence.
     For example, in

      (setf place1 value1 place2 value2 ...)

     the subforms of ÿplace1þ and ÿvalue1þ are evaluated, the location
     specified by ÿplace1þ is modified to contain the value returned by
     ÿvalue1þ, and then the rest of the ÿsetfþ form is processed in a
     like manner.

  3. For ÿcheck-typeþ, ÿctypecaseþ, and ÿccaseþ, subforms of the place
     are evaluated once as in (1), but might be evaluated again if the
     type check fails in the case of ÿcheck-typeþ or none of the cases
     hold in ÿctypecaseþ and ÿccaseþ.

  4. For ÿassertþ, the order of evaluation of the generalized
     references is not specified.  

Rules 2, 3 and 4 cover all standardized macros that manipulate places.

5.1.1.1.1 Examples of Evaluation of Subforms to Places
......................................................

 (let ((ref2 (list '())))
   (push (progn (princ "1") 'ref-1)
         (car (progn (princ "2") ref2))))
Ö 12
ý (REF1)

 (let (x)
    (push (setq x (list 'a))
          (car (setq x (list 'b))))
     x)
ý (((A) . B))

ÿpushþ first evaluates ÿ(setq x (list 'a)) ý (a)þ, then evaluates
ÿ(setq x (list 'b)) ý (b)þ, then modifies the car of this latest value
to be ÿ((a) . b)þ.

5.1.1.2 Setf Expansions
.......................

Sometimes it is possible to avoid evaluating subforms of a place
multiple times or in the wrong order.  A setf expansion for a given
access form can be expressed as an ordered collection of five objects:

List of temporary variables
     a list of symbols naming temporary variables to be bound
     sequentially, as if by ÿlet*þ, to values resulting from value
     forms.

List of value forms
     a list of forms (typically, subforms of the place) which when
     evaluated yield the values to which the corresponding temporary
     variables should be bound.

List of store variables
     a list of symbols naming temporary store variables which are to
     hold the new values that will be assigned to the place.

Storing form
     a form which can reference both the temporary and the store
     variables, and which changes the value of the place and guarantees
     to return as its values the values of the store variables, which
     are the correct values for ÿsetfþ to return.

Accessing form
     a form which can reference the temporary variables, and which
     returns the value of the place.

The value returned by the accessing form is affected by execution of
the storing form, but either of these forms might be evaluated any
number of times.

It is possible to do more than one ÿsetfþ in parallel via ÿpsetfþ,
ÿshiftfþ, and ÿrotatefþ.  Because of this, the setf expander must
produce new temporary and store variable names every time.  For
examples of how to do this, see ÿgensymþ.

For each standardized accessor function F, unless it is explicitly
documented otherwise, it is implementation-dependent whether the
ability to use an F form as a ÿsetfþ place is implemented by a setf
expander or a setf function.  Also, it follows from this that it is
implementation-dependent whether the name ÿ(setf F)þ is fbound.

5.1.1.2.1 Examples of Setf Expansions
.....................................

Examples of the contents of the constituents of setf expansions follow.

For a variable X:

ÿ()þ               ;list of temporary variables
ÿ()þ               ;list of value forms
ÿ(g0001)þ          ;list of store variables
ÿ(setq X g0001)þ   ;storing form
X                  ;accessing form

Figure 5.3: Sample Setf Expansion of a Variable

For ÿ(car EXP)þ:

ÿ(g0002)þ                              ;list of temporary variables
ÿ(EXP)þ                                ;list of value forms
ÿ(g0003)þ                              ;list of store variables
ÿ(progn (rplaca g0002 g0003) g0003)þ   ;storing form
ÿ(car g0002)þ                          ;accessing form

Figure 5.4: Sample Setf Expansion of a CAR Form

For ÿ(subseq SEQ S E)þ:

ÿ(g0004 g0005 g0006)þ                           ;list of temporary variables
ÿ(SEQ S E)þ                                     ;list of value forms
ÿ(g0007)þ                                       ;list of store variables
ÿ(progn (replace g0004 g0007 :start1 g0005      
:end1 g0006) g0007)þ                            
                                                ;storing form
ÿ(subseq g0004 g0005 g0006)þ                    ; accessing form

Figure 5.5: Sample Setf Expansion of a SUBSEQ Form

In some cases, if a subform of a place is itself a place, it is
necessary to expand the subform in order to compute some of the values
in the expansion of the outer place.  For ÿ(ldb BS (car EXP))þ:

ÿ(g0001 g0002)þ                                 ;list of temporary variables
ÿ(BS EXP)þ                                      ;list of value forms
ÿ(g0003)þ                                       ;list of store variables
ÿ(progn (rplaca g0002 (dpb g0003 g0001 (car     
g0002))) g0003)þ                                
                                                ;storing form
ÿ(ldb g0001 (car g0002))þ                       ; accessing form

Figure 5.6: Sample Setf Expansion of a LDB Form


File: chris-ansicl.info,  Node: Kinds of Places,  Next: Treatment of Other Macros Based on SETF,  Prev: Overview of Places and Generalized Reference,  Up: Generalized Reference

5.1.2 Kinds of Places
---------------------

Several kinds of places are defined by Common Lisp; this section
enumerates them.  This set can be extended by implementations and by
programmer code.

5.1.2.1 Variable Names as Places
................................

The name of a lexical variable or dynamic variable can be used as a
place.

5.1.2.2 Function Call Forms as Places
.....................................

A function form can be used as a place if it falls into one of the
following categories:

   * A function call form whose first element is the name of any one of
     the functions in the next figure.

     aref     cdadr                     get
     bit      cdar                      gethash
     caaaar   cddaar                    logical-pathname-translations
     caaadr   cddadr                    macro-function
     caaar    cddar                     ninth
     caadar   cdddar                    nth
     caaddr   cddddr                    readtable-case
     caadr    cdddr                     rest
     caar     cddr                      row-major-aref
     cadaar   cdr                       sbit
     cadadr   char                      schar
     cadar    class-name                second
     caddar   compiler-macro-function   seventh
     cadddr   documentation             sixth
     caddr    eighth                    slot-value
     cadr     elt                       subseq
     car      fdefinition               svref
     cdaaar   fifth                     symbol-function
     cdaadr   fill-pointer              symbol-plist
     cdaar    find-class                symbol-value
     cdadar   first                     tenth
     cdaddr   fourth                    third

     Figure 5.7: Functions that setf can be used with--1

     In the case of ÿsubseqþ, the replacement value must be a sequence
     whose elements might be contained by the sequence argument to
     ÿsubseqþ, but does not have to be a sequence of the same type as
     the sequence of which the subsequence is specified.  If the length
     of the replacement value does not equal the length of the
     subsequence to be replaced, then the shorter length determines the
     number of elements to be stored, as for ÿreplaceþ.

   * A function call form whose first element is the name of a selector
     function constructed by ÿdefstructþ.  The function name must refer
     to the global function definition, rather than a locally defined
     function.

   * A function call form whose first element is the name of any one of
     the functions in the next figure, provided that the supplied
     argument to that function is in turn a place form; in this case
     the new place has stored back into it the result of applying the
     supplied "update" function.

     Function name  Argument that is a PLACE   Update function used
     --------------------------------------------------------------------- 
     ÿldbþ          second                     ÿdpbþ
     ÿmask-fieldþ   second                     ÿdeposit-fieldþ
     ÿgetfþ         first                      implementation-dependent

     Figure 5.8: Functions that setf can be used with--2

     During the ÿsetfþ expansion of these forms, it is necessary to call
     ÿget-setf-expansionþ in order to figure out how the inner, nested
     generalized variable must be treated.

     The information from ÿget-setf-expansionþ is used as follows.

    ÿldbþ
          In a form such as:

          ÿ(setf (ldb BYTE-SPEC PLACE-FORM) VALUE-FORM)þ

          the place referred to by the PLACE-FORM must always be both
          read and written;  note that the update is to the generalized
          variable specified by PLACE-FORM, not to any object of type
          ÿintegerþ.

          Thus this ÿsetfþ should generate code to do the following:

            1. Evaluate BYTE-SPEC (and bind it into a temporary
               variable).

            2. Bind the temporary variables for PLACE-FORM.

            3. Evaluate VALUE-FORM  (and bind its value or values into
               the store variable).

            4. Do the read from PLACE-FORM.

            5. Do the write into PLACE-FORM with the given bits of the
               integer fetched in step 4 replaced with the value from
               step 3.

          If the evaluation of VALUE-FORM in step 3 alters what is
          found in PLACE-FORM, such as setting different bits of
          integer, then the change of the bits denoted by BYTE-SPEC is
          to that altered integer, because step 4 is done after the
          VALUE-FORM evaluation.  Nevertheless, the evaluations
          required for binding the temporary variables are done in
          steps 1 and 2, and thus the expected left-to-right evaluation
          order is seen.  For example:

           (setq integer #x69) ý #x69
           (rotatef (ldb (byte 4 4) integer)
                    (ldb (byte 4 0) integer))
           integer ý #x96
          ;;; This example is trying to swap two independent bit fields
          ;;; in an integer.  Note that the generalized variable of
          ;;; interest here is just the (possibly local) program variable
          ;;; integer.

    ÿmask-fieldþ
          This case is the same as ÿldbþ in all essential aspects.

    ÿgetfþ
          In a form such as:

          ÿ(setf (getf PLACE-FORM IND-FORM) VALUE-FORM)þ

          the place referred to by PLACE-FORM must always be both read
          and written;  note that the update is to the generalized
          variable specified by PLACE-FORM, not necessarily to the
          particular list that is the property list in question.

          Thus this ÿsetfþ should generate code to do the following:

            1. Bind the temporary variables for PLACE-FORM.

            2. Evaluate IND-FORM (and bind it into a temporary
               variable).

            3. Evaluate VALUE-FORM (and bind its value or values into
               the store variable).

            4. Do the read from PLACE-FORM.

            5. Do the write into PLACE-FORM with a possibly-new
               property list obtained by combining the values from
               steps 2, 3, and 4.  (Note that the phrase "possibly-new
               property list" can mean that the former property list is
               somehow destructively re-used, or it can mean partial or
               full copying of it.  Since either copying or destructive
               re-use can occur, the treatment of the resultant value
               for the possibly-new property list must proceed as if it
               were a different copy needing to be stored back into the
               generalized variable.)

          If the evaluation of VALUE-FORM in step 3 alters what is
          found in PLACE-FORM, such as setting a different named
          property in the list, then the change of the property denoted
          by IND-FORM is to that altered list, because step 4 is done
          after the VALUE-FORM evaluation.  Nevertheless, the
          evaluations required for binding the temporary variables  are
          done in steps 1 and 2,  and thus the expected left-to-right
          evaluation order is seen.

          For example:

           (setq s (setq r (list (list 'a 1 'b 2 'c 3)))) ý ((a 1 b 2 c 3))
           (setf (getf (car r) 'b)
                 (progn (setq r nil) 6)) ý 6
           r ý NIL
           s ý ((A 1 B 6 C 3))
          ;;; Note that the (setq r nil) does not affect the actions of
          ;;; the SETF because the value of R had already been saved in
          ;;; a temporary variable as part of the step 1. Only the CAR
          ;;; of this value will be retrieved, and subsequently modified
          ;;; after the value computation.


5.1.2.3 VALUES Forms as Places
..............................

A ÿvaluesþ form can be used as a place, provided that each of its
subforms is also a place form.

A form such as

ÿ(setf (values PLACE-1 ... PLACE-N) VALUES-FORM)þ

does the following:

  1. The subforms of each nested PLACE are evaluated in left-to-right
     order.

  2. The VALUES-FORM is evaluated, and the first store variable from
     each PLACE is bound to its return values as if by
     ÿmultiple-value-bindþ.

  3. If the setf expansion for any PLACE involves more than one store
     variable, then the additional store variables are bound to ÿnilþ.

  4. The storing forms for each PLACE are evaluated in left-to-right
     order.

The storing form in the setf expansion of ÿvaluesþ returns as multiple
valuesà the values of the store variables in step 2.  That is, the
number of values returned is the same as the number of place forms.
This may be more or fewer values than are produced by the VALUES-FORM.

5.1.2.4 THE Forms as Places
...........................

A ÿtheþ form can be used as a place, in which case the declaration is
transferred to the NEWVALUE form, and the resulting ÿsetfþ is analyzed.
For example,

 (setf (the integer (cadr x)) (+ y 3))

is processed as if it were

 (setf (cadr x) (the integer (+ y 3)))

5.1.2.5 APPLY Forms as Places
.............................

The following situations involving ÿsetfþ of ÿapplyþ must be supported:

   * ÿ(setf (apply #'aref ARRAY {subscript}* MORE-SUBSCRIPTS)
     NEW-ELEMENT)þ

   * ÿ(setf (apply #'bit ARRAY {subscript}* MORE-SUBSCRIPTS)
     NEW-ELEMENT)þ

   * ÿ(setf (apply #'sbit ARRAY {subscript}* MORE-SUBSCRIPTS)
     NEW-ELEMENT)þ

In all three cases, the element of ARRAY designated by the
concatenation of SUBSCRIPTS and MORE-SUBSCRIPTS (i.e., the same element
which would be read by the call to apply if it were not part of a
ÿsetfþ form) is changed to have the value given by NEW-ELEMENT.  For
these usages, the function name (ÿarefþ, ÿbitþ, or ÿsbitþ) must refer
to the global function definition, rather than a locally defined
function.

No other standardized function is required to be supported, but an
implementation may define such support.  An implementation may also
define support for implementation-defined operators.

If a user-defined function is used in this context, the following
equivalence is true, except that care is taken to preserve proper
left-to-right evaluation of argument subforms:

 (setf (apply #'NAME {arg}*) VAL)
 Õ (apply #'(setf NAME) VAL {arg}*)

5.1.2.6 Setf Expansions and Places
..................................

Any compound form for which the operator has a setf expander defined
can be used as a place.  The operator must refer to the global function
definition, rather than a locally defined function or macro.

5.1.2.7 Macro Forms as Places
.............................

A macro form can be used as a place, in which case Common Lisp expands
the macro form as if by ÿmacroexpand-1þ and then uses the macro
expansion in place of the original place.  Such macro expansion is
attempted only after exhausting all other possibilities other than
expanding into a call to a function named ÿ(setf READER)þ.

5.1.2.8 Symbol Macros as Places
...............................

A reference to a symbol that has been established as a symbol macro can
be used as a place.  In this case, ÿsetfþ expands the reference and
then analyzes the resulting form.

5.1.2.9 Other Compound Forms as Places
......................................

For any other compound form for which the operator is a symbol F, the
ÿsetfþ form expands into a call to the function named ÿ(setf F)þ.  The
first argument in the newly constructed function form is NEWVALUE and
the remaining arguments are the remaining elements of PLACE.  This
expansion occurs regardless of whether F or ÿ(setf F)þ is defined as a
function locally, globally, or not at all.  For example,

ÿ(setf (F ARG1 ARG2 ...) NEW-VALUE)þ

expands into a form with the same effect and value as

 (let ((#:temp-1 arg1)          ;force correct order of evaluation
       (#:temp-2 arg2)
       ...
       (#:temp-0 NEW-VALUE))
   (funcall (function (setf F)) #:temp-0 #:temp-1 #:temp-2...))

A function named ÿ(setf F)þ must return its first argument as its only
value in order to preserve the semantics of ÿsetfþ.


File: chris-ansicl.info,  Node: Treatment of Other Macros Based on SETF,  Prev: Kinds of Places,  Up: Generalized Reference

5.1.3 Treatment of Other Macros Based on SETF
---------------------------------------------

For each of the "read-modify-write" operators in the next figure, and
for any additional macros defined by the programmer using
ÿdefine-modify-macroþ, an exception is made to the normal rule of
left-to-right evaluation of arguments.  Evaluation of argument forms
occurs in left-to-right order, with the exception that for the PLACE
argument, the actual read of the "old value" from that PLACE happens
after all of the argument form evaluations, and just before a "new
value" is computed and written back into the PLACE.

Specifically, each of these operators can be viewed as involving a form
with the following general syntax:

 (operator {preceding-form}* PLACE {following-form}*)

The evaluation of each such form proceeds like this:

  1. Evaluate each of the PRECEDING-FORMS, in left-to-right order.

  2. Evaluate the subforms of the PLACE, in the order specified by the
     second value of the setf expansion for that PLACE.

  3. Evaluate each of the FOLLOWING-FORMS, in left-to-right order.

  4. Read the old value from PLACE.

  5. Compute the new value.

  6. Store the new value into PLACE.

decf   pop    pushnew
incf   push   remf

Figure 5.9: Read-Modify-Write Macros


File: chris-ansicl.info,  Node: Transfer of Control to an Exit Point,  Next: apply,  Prev: Generalized Reference,  Up: Data and Control Flow

5.2 Transfer of Control to an Exit Point
========================================

When a transfer of control is initiated by ÿgoþ, ÿreturn-fromþ, or
ÿthrowþ the following events occur in order to accomplish the transfer
of control.  Note that for ÿgoþ, the exit point is the form within the
ÿtagbodyþ that is being executed at the time the ÿgoþ is performed; for
ÿreturn-fromþ, the exit point is the corresponding ÿblockþ form; and
for ÿthrowþ, the exit point is the corresponding ÿcatchþ form.

  1. Intervening exit points are "abandoned" (i.e., their extent ends
     and it is no longer valid to attempt to transfer control through
     them).

  2. The cleanup clauses of any intervening ÿunwind-protectþ clauses
     are evaluated.

  3. Intervening dynamic bindings of ÿspecialþ variables, catch tags,
     condition handlers, and restarts are undone.

  4. The extent of the exit point being invoked ends, and control is
     passed to the target.

The extent of an exit being "abandoned" because it is being passed over
ends as soon as the transfer of control is initiated. That is, event 1
occurs at the beginning of the initiation of the transfer of control.
The consequences are undefined if an attempt is made to transfer control
to an exit point whose dynamic extent has ended.

Events 2 and 3 are actually performed interleaved, in the order
corresponding to the reverse order in which they were established.  The
effect of this is that the cleanup clauses of an ÿunwind-protectþ see
the same dynamic bindings of variables and catch tags as were visible
when the ÿunwind-protectþ was entered.

Event 4 occurs at the end of the transfer of control.


File: chris-ansicl.info,  Node: apply,  Next: defun,  Prev: Transfer of Control to an Exit Point,  Up: Data and Control Flow

apply (Function)
================

Syntax:
.......

 -- Function: apply function &rest args+ ý {result}*

Arguments and Values:
.....................

FUNCTION--a function designator.

ARGS--a spreadable argument list designator.

RESULTS--the values returned by FUNCTION.

Description:
............

Applies the FUNCTION to the ARGS.

When the FUNCTION receives its arguments via ÿ&restþ, it is permissible
(but not required) for the implementation to bind the rest parameter to
an object that shares structure with the last argument to ÿapplyþ.
Because a function can neither detect whether it was called via ÿapplyþ
nor whether (if so) the last argument to ÿapplyþ was a constant,
conforming programs must neither rely on the list structure of a rest
list to be freshly consed, nor modify that list structure.

ÿsetfþ can be used with ÿapplyþ in certain circumstances; see *Note
Section 5.1.2.5 (APPLY Forms as Places): SETFofAPPLY.

Examples:
.........

 (setq f '+) ý +
 (apply f '(1 2)) ý 3
 (setq f #'-) ý #<FUNCTION ->
 (apply f '(1 2)) ý -1
 (apply #'max 3 5 '(2 7 3)) ý 7
 (apply 'cons '((+ 2 3) 4)) ý ((+ 2 3) . 4)
 (apply #'+ '()) ý 0

 (defparameter *some-list* '(a b c))
 (defun strange-test (&rest x) (eq x *some-list*))
 (apply #'strange-test *some-list*) ý implementation-dependent

 (defun bad-boy (&rest x) (rplacd x 'y))
 (bad-boy 'a 'b 'c) has undefined consequences.
 (apply #'bad-boy *some-list*) has undefined consequences.

 (defun foo (size &rest keys &key double &allow-other-keys)
   (let ((v (apply #'make-array size :allow-other-keys t keys)))
     (if double (concatenate (type-of v) v v) v)))
 (foo 4 :initial-contents '(a b c d) :double t)
    ý #(A B C D A B C D)

See Also:
.........

*Note funcall::, *Note fdefinition::, *Note function (Special
Operator)::, *Note Section 3.1 (Evaluation): Evaluation, *Note Section
5.1.2.5 (APPLY Forms as Places): SETFofAPPLY.


File: chris-ansicl.info,  Node: defun,  Next: fdefinition,  Prev: apply,  Up: Data and Control Flow

defun (Macro)
=============

Syntax:
.......

 -- Macro: defun function-name lambda-list ù{declaration}* |
          documentationø {form}* ý function-name

Arguments and Values:
.....................

FUNCTION-NAME--a function name.

LAMBDA-LIST--an ordinary lambda list.

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORMS--an implicit progn.

BLOCK-NAME--the function block name of the FUNCTION-NAME.

Description:
............

Defines a new function named FUNCTION-NAME in the global environment.
The body of the function defined by ÿdefunþ consists of FORMS; they are
executed as an implicit progn when the function is called.  ÿdefunþ can
be used to define a new function, to install a corrected version of an
incorrect definition, to redefine an already-defined function, or to
redefine a macro as a function.

ÿdefunþ implicitly puts a ÿblockþ named BLOCK-NAME around the body FORMS
(but not the forms in the LAMBDA-LIST) of the function defined.

DOCUMENTATION is attached as a documentation string to NAME (as kind
ÿfunctionþ) and to the function object.

Evaluating ÿdefunþ causes FUNCTION-NAME to be a global name for the
function specified by the lambda expression

 (lambda LAMBDA-LIST
   ù{declaration}* | documentationø
   (block BLOCK-NAME {form}*))

processed in the lexical environment in which ÿdefunþ was executed.

(None of the arguments are evaluated at macro expansion time.)

ÿdefunþ is not required to perform any compile-time side effects.  In
particular, ÿdefunþ does not make the function definition available at
compile time.  An implementation may choose to store information about
the function for the purposes of compile-time error-checking (such as
checking the number of arguments on calls), or to enable the function
to be expanded inline.

Examples:
.........

 (defun recur (x)
  (when (> x 0)
    (recur (1- x)))) ý RECUR
 (defun ex (a b &optional c (d 66) &rest keys &key test (start 0))
    (list a b c d keys test start)) ý EX
 (ex 1 2) ý (1 2 NIL 66 NIL NIL 0)
 (ex 1 2 3 4 :test 'equal :start 50)
ý (1 2 3 4 (:TEST EQUAL :START 50) EQUAL 50)
 (ex :test 1 :start 2) ý (:TEST 1 :START 2 NIL NIL 0)

 ;; This function assumes its callers have checked the types of the
 ;; arguments, and authorizes the compiler to build in that assumption.
 (defun discriminant (a b c)
   (declare (number a b c))
   "Compute the discriminant for a quadratic equation."
   (- (* b b) (* 4 a c))) ý DISCRIMINANT
 (discriminant 1 2/3 -2) ý 76/9

 ;; This function assumes its callers have not checked the types of the
 ;; arguments, and performs explicit type checks before making any assumptions.
 (defun careful-discriminant (a b c)
   "Compute the discriminant for a quadratic equation."
   (check-type a number)
   (check-type b number)
   (check-type c number)
   (locally (declare (number a b c))
     (- (* b b) (* 4 a c)))) ý CAREFUL-DISCRIMINANT
 (careful-discriminant 1 2/3 -2) ý 76/9

See Also:
.........

*Note flet::, *Note labels::, *Note block::, *Note return-from::, *Note
declare::, *Note documentation::, *Note Section 3.1 (Evaluation):
Evaluation, *Note Section 3.4.1 (Ordinary Lambda Lists): Ordinary
Lambda Lists, *Note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

ÿreturn-fromþ can be used to return prematurely from a function defined
by ÿdefunþ.

Additional side effects might take place when additional information
(typically debugging information) about the function definition is
recorded.


File: chris-ansicl.info,  Node: fdefinition,  Next: fboundp,  Prev: defun,  Up: Data and Control Flow

fdefinition (Accessor)
======================

Syntax:
.......

 -- Function: fdefinition function-name ý definition

(setf (fdefinition function-name) new-definition)

Arguments and Values:
.....................

FUNCTION-NAME--a function name.  In the non-ÿsetfþ case, the name must
be fbound in the global environment.

DEFINITION--Current global function definition named by FUNCTION-NAME.

NEW-DEFINITION--a function.

Description:
............

ÿfdefinitionþ accesses the current global function definition named by
FUNCTION-NAME.  The definition may be a function or may be an object
representing a special form or macro.  The value returned by
ÿfdefinitionþ when ÿfboundpþ returns true but the FUNCTION-NAME denotes
a macro or special form is not well-defined, but ÿfdefinitionþ does not
signal an error.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if FUNCTION-NAME is not a
function name.

An error of type ÿundefined-functionþ is signaled in the non-ÿsetfþ
case if FUNCTION-NAME is not fbound.

See Also:
.........

*Note fboundp::, *Note fmakunbound::, *Note macro-function::, *Note
special-operator-p::, *Note symbol-function::

Notes:
......

ÿfdefinitionþ cannot access the value of a lexical function name
produced by ÿfletþ or ÿlabelsþ; it can access only the global function
value.

ÿsetfþ can be used with ÿfdefinitionþ to replace a global function
definition when the FUNCTION-NAME's function definition does not
represent a special form.  ÿsetfþ of ÿfdefinitionþ requires a function
as the new value.  It is an error to set the ÿfdefinitionþ of a
FUNCTION-NAME to a symbol, a list, or the value returned by
ÿfdefinitionþ on the name of a macro or special form.


File: chris-ansicl.info,  Node: fboundp,  Next: fmakunbound,  Prev: fdefinition,  Up: Data and Control Flow

fboundp (Function)
==================

Syntax:
.......

 -- Function: fboundp name ý generalized-boolean

Pronunciation:
..............

[éefêba.undpæ]

Arguments and Values:
.....................

NAME--a function name.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if NAME is fbound; otherwise, returns false.

Examples:
.........

 (fboundp 'car) ý true
 (fboundp 'nth-value) ý false
 (fboundp 'with-open-file) ý true
 (fboundp 'unwind-protect) ý true
 (defun my-function (x) x) ý MY-FUNCTION
 (fboundp 'my-function) ý true
 (let ((saved-definition (symbol-function 'my-function)))
   (unwind-protect (progn (fmakunbound 'my-function)
                          (fboundp 'my-function))
     (setf (symbol-function 'my-function) saved-definition)))
ý false
 (fboundp 'my-function) ý true
 (defmacro my-macro (x) `',x) ý MY-MACRO
 (fboundp 'my-macro) ý true
 (fmakunbound 'my-function) ý MY-FUNCTION
 (fboundp 'my-function) ý false
 (flet ((my-function (x) x))
   (fboundp 'my-function)) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NAME is not a function
name.

See Also:
.........

*Note symbol-function::, *Note fmakunbound::, *Note fdefinition::

Notes:
......

It is permissible to call ÿsymbol-functionþ on any symbol that is
fbound.

ÿfboundpþ is sometimes used to "guard" an access to the function cell,
as in:
(if (fboundp x) (symbol-function x))

Defining a setf expander F does not cause the setf function ÿ(setf F)þ
to become defined.


File: chris-ansicl.info,  Node: fmakunbound,  Next: flet; labels; macrolet,  Prev: fboundp,  Up: Data and Control Flow

fmakunbound (Function)
======================

Syntax:
.......

 -- Function: fmakunbound name ý name

Pronunciation:
..............

[éefêmakè néba.und] or [éefêmç kè néba.und]

Arguments and Values:
.....................

NAME--a function name.

Description:
............

Removes the function or macro definition, if any, of NAME in the global
environment.

Examples:
.........

(defun add-some (x) (+ x 19)) ý ADD-SOME
 (fboundp 'add-some) ý true
 (flet ((add-some (x) (+ x 37)))
    (fmakunbound 'add-some)
    (add-some 1)) ý 38
 (fboundp 'add-some) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NAME is not a function
name.

The consequences are undefined if NAME is a special operator.

See Also:
.........

*Note fboundp::, *Note makunbound::


File: chris-ansicl.info,  Node: flet; labels; macrolet,  Next: funcall,  Prev: fmakunbound,  Up: Data and Control Flow

flet, labels, macrolet (Special Operator)
=========================================

Syntax:
.......

 -- Special Form: flet
          ({(FUNCTION-NAME  LAMBDA-LIST ù{local-declaration}* | local-documentationø {local-form}*)}*)
          {declaration}* {form}* ý {result}*

 -- Special Form: labels
          ({(FUNCTION-NAME  LAMBDA-LIST ù{local-declaration}* | local-documentationø {local-form}*)}*)
          {declaration}* {form}* ý {result}*

 -- Special Form: macrolet
          ({(NAME  LAMBDA-LIST ù{local-declaration}* | local-documentationø {local-form}*)}*)
          {declaration}* {form}* ý {result}*

Arguments and Values:
.....................

FUNCTION-NAME--a function name.

NAME--a symbol.

LAMBDA-LIST--a lambda list; for ÿfletþ and ÿlabelsþ, it is an ordinary
lambda list; for ÿmacroletþ, it is a macro lambda list.

LOCAL-DECLARATION--a declare expression; not evaluated.

DECLARATION--a declare expression; not evaluated.

LOCAL-DOCUMENTATION--a string; not evaluated.

LOCAL-FORMS, FORMS--an implicit progn.

RESULTS--the values of the FORMS.

Description:
............

ÿfletþ, ÿlabelsþ, and ÿmacroletþ define local functions and macros, and
execute FORMS using the local definitions.  FORMS are executed  in
order of occurrence.

The body forms (but not the lambda list) of each function created by
ÿfletþ and ÿlabelsþ and each macro created by ÿmacroletþ are enclosed
in an implicit block whose name is the function block name of the
FUNCTION-NAME or NAME, as appropriate.

The scope of the DECLARATIONS between the list of local function/macro
definitions and the body FORMS in ÿfletþ and ÿlabelsþ does not include
the bodies of the locally defined functions, except that for ÿlabelsþ,
any ÿinlineþ, ÿnotinlineþ, or ÿftypeþ declarations that refer to the
locally defined functions do apply to the local function bodies. That
is, their scope is the same as the function name that they affect.  The
scope of these DECLARATIONS does not include the bodies of the macro
expander functions defined by ÿmacroletþ.

flet
     ÿfletþ defines locally named functions and executes a series of
     FORMS with these definition bindings.  Any number of such local
     functions can be defined.

     The scope of the name binding encompasses only the body.  Within
     the body of ÿfletþ, FUNCTION-NAMES matching those defined by ÿfletþ
     refer to the locally defined functions rather than to the global
     function definitions of the same name.  Also, within the scope of
     ÿfletþ, global setf expander definitions of the FUNCTION-NAME
     defined by ÿfletþ do not apply.  Note that this applies to
     ÿ(defsetf f ...)þ, not ÿ(defmethod (setf f) ...)þ.

     The names of functions defined by ÿfletþ are in the lexical
     environment; they retain their local definitions only within the
     body of ÿfletþ.  The function definition bindings are visible only
     in the body of ÿfletþ, not the definitions themselves.  Within the
     function definitions, local function names that match those being
     defined refer to functions or macros defined outside the ÿfletþ.
     ÿfletþ can locally shadow a global function name, and the new
     definition can refer to the global definition.

     Any LOCAL-DOCUMENTATION is attached to the corresponding local
     FUNCTION (if one is actually created) as a documentation string.

labels
     ÿlabelsþ is equivalent to ÿfletþ except that the scope of the
     defined function names for ÿlabelsþ encompasses the function
     definitions themselves as well as the body.

macrolet
     ÿmacroletþ establishes local macro definitions, using the same
     format used by ÿdefmacroþ.

     Within the body of ÿmacroletþ, global setf expander definitions of
     the NAMES defined by the ÿmacroletþ do not apply; rather, ÿsetfþ
     expands the macro form and recursively process the resulting form.

     The macro-expansion functions defined by ÿmacroletþ are defined in
     the lexical environment in which the ÿmacroletþ form appears.
     Declarations and ÿmacroletþ and ÿsymbol-macroletþ definitions
     affect the local macro definitions in a ÿmacroletþ, but the
     consequences are undefined if the local macro definitions reference
     any local variable or function bindings that are visible in that
     lexical environment.

     Any LOCAL-DOCUMENTATION is attached to the corresponding local
     MACRO FUNCTION as a documentation string.

Examples:
.........

 (defun foo (x flag)
   (macrolet ((fudge (z)
                 ;The parameters x and flag are not accessible
                 ; at this point; a reference to flag would be to
                 ; the global variable of that name.
                 ` (if flag (* ,z ,z) ,z)))
    ;The parameters x and flag are accessible here.
     (+ x
        (fudge x)
        (fudge (+ x 1)))))
 Õ
 (defun foo (x flag)
   (+ x
      (if flag (* x x) x)
      (if flag (* (+ x 1) (+ x 1)) (+ x 1))))

after macro expansion.  The occurrences of ÿxþ and ÿflagþ legitimately
refer to the parameters of the function ÿfooþ because those parameters
are visible at the site of the macro call which produced the expansion.

 (flet ((flet1 (n) (+ n n)))
    (flet ((flet1 (n) (+ 2 (flet1 n))))
      (flet1 2))) ý 6

 (defun dummy-function () 'top-level) ý DUMMY-FUNCTION
 (funcall #'dummy-function) ý TOP-LEVEL
 (flet ((dummy-function () 'shadow))
      (funcall #'dummy-function)) ý SHADOW
 (eq (funcall #'dummy-function) (funcall 'dummy-function))
ý true
 (flet ((dummy-function () 'shadow))
   (eq (funcall #'dummy-function)
       (funcall 'dummy-function)))
ý false

 (defun recursive-times (k n)
   (labels ((temp (n)
              (if (zerop n) 0 (+ k (temp (1- n))))))
     (temp n))) ý RECURSIVE-TIMES
 (recursive-times 2 3) ý 6

 (defmacro mlets (x &environment env)
    (let ((form `(babbit ,x)))
      (macroexpand form env))) ý MLETS
 (macrolet ((babbit (z) `(+ ,z ,z))) (mlets 5)) ý 10

 (flet ((safesqrt (x) (sqrt (abs x))))
  ;; The safesqrt function is used in two places.
   (safesqrt (apply #'+ (map 'list #'safesqrt '(1 2 3 4 5 6)))))
ý 3.291173

 (defun integer-power (n k)
   (declare (integer n))
   (declare (type (integer 0 *) k))
   (labels ((expt0 (x k a)
              (declare (integer x a) (type (integer 0 *) k))
              (cond ((zerop k) a)
                    ((evenp k) (expt1 (* x x) (floor k 2) a))
                    (t (expt0 (* x x) (floor k 2) (* x a)))))
            (expt1 (x k a)
              (declare (integer x a) (type (integer 0 *) k))
              (cond ((evenp k) (expt1 (* x x) (floor k 2) a))
                    (t (expt0 (* x x) (floor k 2) (* x a))))))
    (expt0 n k 1))) ý INTEGER-POWER

 (defun example (y l)
   (flet ((attach (x)
            (setq l (append l (list x)))))
     (declare (inline attach))
     (dolist (x y)
       (unless (null (cdr x))
         (attach x)))
     l))

 (example '((a apple apricot) (b banana) (c cherry) (d) (e))
          '((1) (2) (3) (4 2) (5) (6 3 2)))
ý ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))

See Also:
.........

*Note declare::, *Note defmacro::, *Note defun::, *Note documentation::,
*Note let::, *Note Section 3.1 (Evaluation): Evaluation, *Note Section
3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations): Syntactic Interaction of Documentation Strings and
Declarations.

Notes:
......

It is not possible to define recursive functions with ÿfletþ.  ÿlabelsþ
can be used to define mutually recursive functions.

If a ÿmacroletþ form is a top level form, the body FORMS are also
processed as top level forms.  See *Note Section 3.2.3 (File
Compilation): File Compilation.


File: chris-ansicl.info,  Node: funcall,  Next: function (Special Operator),  Prev: flet; labels; macrolet,  Up: Data and Control Flow

funcall (Function)
==================

Syntax:
.......

 -- Function: funcall function &rest args ý {result}*

Arguments and Values:
.....................

FUNCTION--a function designator.

ARGS--arguments to the FUNCTION.

RESULTS--the values returned by the FUNCTION.

Description:
............

ÿfuncallþ applies FUNCTION to ARGS.  If FUNCTION is a symbol, it is
coerced to a function as if by finding its functional value in the
global environment.

Examples:
.........

 (funcall #'+ 1 2 3) ý 6
 (funcall 'car '(1 2 3)) ý 1
 (funcall 'position 1 '(1 2 3 2 1) :start 1) ý 4
 (cons 1 2) ý (1 . 2)
 (flet ((cons (x y) `(kons ,x ,y)))
   (let ((cons (symbol-function '+)))
     (funcall #'cons
              (funcall 'cons 1 2)
              (funcall cons 1 2))))
ý (KONS (1 . 2) 3)

Exceptional Situations:
.......................

An error of type ÿundefined-functionþ should be signaled if FUNCTION is
a symbol that does not have a global definition as a function or that
has a global definition as a macro or a special operator.

See Also:
.........

*Note apply::, *Note function (Special Operator)::, *Note Section 3.1
(Evaluation): Evaluation.

Notes:
......

 (funcall FUNCTION ARG1 ARG2 ...)
 Õ (apply FUNCTION ARG1 ARG2 ... nil)
 Õ (apply FUNCTION (list ARG1 ARG2 ...))

The difference between ÿfuncallþ and an ordinary function call is that
in the former case the FUNCTION is obtained by ordinary evaluation of a
form, and in the latter case it is obtained by the special
interpretation of the function position that normally occurs.


File: chris-ansicl.info,  Node: function (Special Operator),  Next: function-lambda-expression,  Prev: funcall,  Up: Data and Control Flow

function (Special Operator)
===========================

Syntax:
.......

 -- Special Form: function name ý function

Arguments and Values:
.....................

NAME--a function name or lambda expression.

FUNCTION--a function object.

Description:
............

The value of ÿfunctionþ is the functional value of NAME in the current
lexical environment.

If NAME is a function name, the functional definition of that name is
that established by the innermost lexically enclosing ÿfletþ, ÿlabelsþ,
or ÿmacroletþ form, if there is one.  Otherwise the global functional
definition of the function name is returned.

If NAME is a lambda expression, then a lexical closure is returned.  In
situations where a closure over the same set of bindings might be
produced more than once, the various resulting closures might or might
not be ÿeqþ.

It is an error to use ÿfunctionþ on a function name that does not
denote a function in the lexical environment in which the ÿfunctionþ
form appears.  Specifically, it is an error to use ÿfunctionþ on a
symbol that denotes a macro or special form.  An implementation may
choose not to signal this error for performance reasons, but
implementations are forbidden from defining the failure to signal an
error as a useful behavior.

Examples:
.........

 (defun adder (x) (function (lambda (y) (+ x y))))

The result of ÿ(adder 3)þ is a function that adds ÿ3þ to its argument:

 (setq add3 (adder 3))
 (funcall add3 5) ý 8

This works because ÿfunctionþ creates a closure of the lambda
expression that is able to refer to the value ÿ3þ of the variable ÿxþ
even after control has returned from the function ÿadderþ.

See Also:
.........

*Note defun::, *Note fdefinition::, *Note flet::, *Note labels::, *Note
symbol-function::, *Note Section 3.1.2.1.1 (Symbols as Forms):
SymbolsAsForms, *Note Section 2.4.8.2 (Sharpsign Single-Quote):
SharpsignQuote, *Note Section 22.1.3.13 (Printing Other Objects):
PrintingOtherObjects.

Notes:
......

The notation ÿ#'NAMEþ may be used as an abbreviation for ÿ(function
NAME)þ.


File: chris-ansicl.info,  Node: function-lambda-expression,  Next: functionp,  Prev: function (Special Operator),  Up: Data and Control Flow

function-lambda-expression (Function)
=====================================

Syntax:
.......

 -- Function: function-lambda-expression function ý lambda-expression,
          closure-p, name

Arguments and Values:
.....................

FUNCTION--a function.

LAMBDA-EXPRESSION--a lambda expression or ÿnilþ.

CLOSURE-P--a generalized boolean.

NAME--an object.

Description:
............

Returns information about FUNCTION as follows:

The primary value, LAMBDA-EXPRESSION, is FUNCTION's defining lambda
expression, or ÿnilþ if the information is not available.  The lambda
expression may have been pre-processed in some ways, but it should
remain a suitable argument to ÿcompileþ or ÿfunctionþ.  Any
implementation may legitimately return ÿnilþ  as the LAMBDA-EXPRESSION
of any FUNCTION.

The secondary value, CLOSURE-P, is ÿnilþ if FUNCTION's definition was
enclosed in the null lexical environment or something non-nil if
FUNCTION's definition might have been enclosed in some non-null lexical
environment.  Any implementation may legitimately return true as the
CLOSURE-P of any FUNCTION.

The tertiary value, NAME, is the "name" of FUNCTION.  The name is
intended for debugging only and is not necessarily one that would be
valid for use as a name in ÿdefunþ or ÿfunctionþ, for example.  By
convention, ÿnilþ is used to mean that FUNCTION has no name.  Any
implementation may legitimately return ÿnilþ  as the NAME of any
FUNCTION.

Examples:
.........

The following examples illustrate some possible return values, but are
not intended to be exhaustive:

 (function-lambda-expression #'(lambda (x) x))
ý NIL, false, NIL
orý NIL, true, NIL
orý (LAMBDA (X) X), true, NIL
orý (LAMBDA (X) X), false, NIL

 (function-lambda-expression
    (funcall #'(lambda () #'(lambda (x) x))))
ý NIL, false, NIL
orý NIL, true, NIL
orý (LAMBDA (X) X), true, NIL
orý (LAMBDA (X) X), false, NIL

 (function-lambda-expression
    (funcall #'(lambda (x) #'(lambda () x)) nil))
ý NIL, true, NIL
orý (LAMBDA () X), true, NIL
notý NIL, false, NIL
notý (LAMBDA () X), false, NIL

 (flet ((foo (x) x))
   (setf (symbol-function 'bar) #'foo)
   (function-lambda-expression #'bar))
ý NIL, false, NIL
orý NIL, true, NIL
orý (LAMBDA (X) (BLOCK FOO X)), true, NIL
orý (LAMBDA (X) (BLOCK FOO X)), false, FOO
orý (SI::BLOCK-LAMBDA FOO (X) X), false, FOO

 (defun foo ()
   (flet ((bar (x) x))
     #'bar))
 (function-lambda-expression (foo))
ý NIL, false, NIL
orý NIL, true, NIL
orý (LAMBDA (X) (BLOCK BAR X)), true, NIL
orý (LAMBDA (X) (BLOCK BAR X)), true, (:INTERNAL FOO 0 BAR)
orý (LAMBDA (X) (BLOCK BAR X)), false, "BAR in FOO"

Notes:
......

Although implementations are free to return "ÿnilþ, true, ÿnilþ" in all
cases, they are encouraged to return a lambda expression as the primary
value in the case where the argument was created by a call to ÿcompileþ
or ÿevalþ (as opposed to being created by loading a compiled file).


File: chris-ansicl.info,  Node: functionp,  Next: compiled-function-p,  Prev: function-lambda-expression,  Up: Data and Control Flow

functionp (Function)
====================

Syntax:
.......

 -- Function: functionp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿfunctionþ; otherwise, returns false.

Examples:
.........

 (functionp 'append) ý false
 (functionp #'append) ý true
 (functionp (symbol-function 'append)) ý true
 (flet ((f () 1)) (functionp #'f)) ý true
 (functionp (compile nil '(lambda () 259))) ý true
 (functionp nil) ý false
 (functionp 12) ý false
 (functionp '(lambda (x) (* x x))) ý false
 (functionp #'(lambda (x) (* x x))) ý true

Notes:
......

 (functionp OBJECT) Õ (typep OBJECT 'function)


File: chris-ansicl.info,  Node: compiled-function-p,  Next: call-arguments-limit,  Prev: functionp,  Up: Data and Control Flow

compiled-function-p (Function)
==============================

Syntax:
.......

 -- Function: compiled-function-p object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿcompiled-functionþ; otherwise,
returns false.

Examples:
.........

 (defun f (x) x) ý F
 (compiled-function-p #'f)
ý false
orý true
 (compiled-function-p 'f) ý false
 (compile 'f) ý F
 (compiled-function-p #'f) ý true
 (compiled-function-p 'f) ý false
 (compiled-function-p (compile nil '(lambda (x) x)))
ý true
 (compiled-function-p #'(lambda (x) x))
ý false
orý true
 (compiled-function-p '(lambda (x) x)) ý false

See Also:
.........

*Note compile::, *Note compile-file::, *Note compiled-function::

Notes:
......

 (compiled-function-p OBJECT) Õ (typep OBJECT 'compiled-function)


File: chris-ansicl.info,  Node: call-arguments-limit,  Next: lambda-list-keywords,  Prev: compiled-function-p,  Up: Data and Control Flow

call-arguments-limit (Constant Variable)
========================================

Constant Value:
...............

An integer not smaller than ÿ50þ and at least as great as the value of
ÿlambda-parameters-limitþ, the exact magnitude of which is
implementation-dependent.

Description:
............

The upper exclusive bound on the number of arguments that may be passed
to a function.

See Also:
.........

*Note lambda-parameters-limit::, *Note multiple-values-limit::


File: chris-ansicl.info,  Node: lambda-list-keywords,  Next: lambda-parameters-limit,  Prev: call-arguments-limit,  Up: Data and Control Flow

lambda-list-keywords (Constant Variable)
========================================

Constant Value:
...............

a list, the elements of which are implementation-dependent, but which
must contain at least the symbols ÿ&allow-other-keysþ, ÿ&auxþ, ÿ&bodyþ,
ÿ&environmentþ, ÿ&keyþ, ÿ&optionalþ, ÿ&restþ, and ÿ&wholeþ.

Description:
............

A list of all the lambda list keywords used in the implementation,
including the additional ones used only by macro definition forms.

See Also:
.........

*Note defun::, *Note flet::, *Note defmacro::, *Note macrolet::, *Note
Section 3.1.2 (The Evaluation Model): The Evaluation Model.


File: chris-ansicl.info,  Node: lambda-parameters-limit,  Next: defconstant,  Prev: lambda-list-keywords,  Up: Data and Control Flow

lambda-parameters-limit (Constant Variable)
===========================================

Constant Value:
...............

implementation-dependent, but not smaller than ÿ50þ.

Description:
............

A positive integer that is the upper exclusive bound on the number of
parameter names that can appear in a single lambda list.

See Also:
.........

*Note call-arguments-limit::

Notes:
......

Implementors are encouraged to make the value of
ÿlambda-parameters-limitþ as large as possible.


File: chris-ansicl.info,  Node: defconstant,  Next: defparameter; defvar,  Prev: lambda-parameters-limit,  Up: Data and Control Flow

defconstant (Macro)
===================

Syntax:
.......

 -- Macro: defconstant name initial-value [documentation] ý name

Arguments and Values:
.....................

NAME--a symbol; not evaluated.

INITIAL-VALUE--a form; evaluated.

DOCUMENTATION--a string; not evaluated.

Description:
............

ÿdefconstantþ causes the global variable named by NAME to be given a
value that is the result of evaluating INITIAL-VALUE.

A constant defined by ÿdefconstantþ can be redefined with ÿdefconstantþ.
However, the consequences are undefined if an attempt is made to assign
a value to the symbol using another operator, or to assign it to a
different value using a subsequent ÿdefconstantþ.

If DOCUMENTATION is supplied, it is attached to NAME as a documentation
string of kind variable.

ÿdefconstantþ normally appears as a top level form, but it is meaningful
for it to appear as a non-top-level form.  However, the compile-time
side effects described below only take place when ÿdefconstantþ appears
as a top level form.

The consequences are undefined if there are any bindings of the
variable named by NAME at the time ÿdefconstantþ is executed or if the
value is not ÿeqlþ to the value of INITIAL-VALUE.

The consequences are undefined when constant symbols are rebound as
either lexical or dynamic variables.  In other words, a reference to a
symbol declared with ÿdefconstantþ always refers to its global value.

The side effects of the execution of ÿdefconstantþ must be equivalent
to at least the side effects of the execution of the following code:

 (setf (symbol-value 'name) initial-value)
 (setf (documentation 'name 'variable) 'documentation)

If a ÿdefconstantþ form appears as a top level form, the compiler must
recognize that NAME names a constant variable.  An implementation may
choose to evaluate the value-form at compile time, load time, or both.
Therefore, users must ensure that the INITIAL-VALUE can be evaluated at
compile time (regardless of whether or not references to NAME appear in
the file) and that it always evaluates to the same value.

Examples:
.........

 (defconstant this-is-a-constant 'never-changing "for a test") ý THIS-IS-A-CONSTANT
this-is-a-constant ý NEVER-CHANGING
 (documentation 'this-is-a-constant 'variable) ý "for a test"
 (constantp 'this-is-a-constant) ý true

See Also:
.........

*Note declaim::, *Note defparameter::, *Note defvar::, *Note
documentation::, *Note proclaim::, *Note Section 3.1.2.1.1.3 (Constant
Variables): ConstantVars, *Note Section 3.2 (Compilation): Compilation.


File: chris-ansicl.info,  Node: defparameter; defvar,  Next: destructuring-bind,  Prev: defconstant,  Up: Data and Control Flow

defparameter, defvar (Macro)
============================

Syntax:
.......

 -- Macro: defparameter name initial-value [documentation] ý name

 -- Macro: defvar name [initial-value [documentation]] ý name

Arguments and Values:
.....................

NAME--a symbol; not evaluated.

INITIAL-VALUE--a form; for ÿdefparameterþ, it is always evaluated, but
for ÿdefvarþ it is evaluated only if NAME is not already bound.

DOCUMENTATION--a STRING; not evaluated.

Description:
............

ÿdefparameterþ and ÿdefvarþ establish NAME as a dynamic variable.

ÿdefparameterþ unconditionally assigns the INITIAL-VALUE to the dynamic
variable named NAME.  ÿdefvarþ, by contrast, assigns INITIAL-VALUE (if
supplied) to the dynamic variable named NAME only if NAME is not
already bound.

If no INITIAL-VALUE is supplied, ÿdefvarþ leaves the value cell of the
dynamic variable named NAME undisturbed; if NAME was previously bound,
its old value persists, and if it was previously unbound, it remains
unbound.

If DOCUMENTATION is supplied, it is attached to NAME as a documentation
string of kind variable.

ÿdefparameterþ and ÿdefvarþ normally appear as a top level form, but it
is meaningful for them to appear as non-top-level forms.  However, the
compile-time side effects described below only take place when they
appear as top level forms.

Examples:
.........

 (defparameter *p* 1) ý *P*
 *p* ý 1
 (constantp '*p*) ý false
 (setq *p* 2) ý 2
 (defparameter *p* 3) ý *P*
 *p* ý 3

 (defvar *v* 1) ý *V*
 *v* ý 1
 (constantp '*v*) ý false
 (setq *v* 2) ý 2
 (defvar *v* 3) ý *V*
 *v* ý 2

 (defun foo ()
   (let ((*p* 'p) (*v* 'v))
     (bar))) ý FOO
 (defun bar () (list *p* *v*)) ý BAR
 (foo) ý (P V)

The principal operational distinction between ÿdefparameterþ and
ÿdefvarþ is that ÿdefparameterþ makes an unconditional assignment to
NAME, while ÿdefvarþ makes a conditional one.  In practice, this means
that ÿdefparameterþ is useful in situations where loading or reloading
the definition would want to pick up a new value of the variable, while
ÿdefvarþ is used in situations where the old value would want to be
retained if the file were loaded or reloaded.  For example, one might
create a file which contained:

 (defvar *the-interesting-numbers* '())
 (defmacro define-interesting-number (name n)
   `(progn (defvar ,name ,n)
           (pushnew ,name *the-interesting-numbers*)
           ',name))
 (define-interesting-number *my-height* 168) ;cm
 (define-interesting-number *my-weight* 13)  ;stones

Here the initial value, ÿ()þ, for the variable
ÿ*the-interesting-numbers*þ is just a seed that we are never likely to
want to reset to something else once something has been grown from it.
As such, we have used ÿdefvarþ to avoid having the
ÿ*interesting-numbers*þ information reset if the file is loaded a
second time.  It is true that the two calls to
ÿdefine-interesting-numberþ here would be reprocessed, but if there
were additional calls in another file, they would not be and that
information would be lost.  On the other hand, consider the following
code:

 (defparameter *default-beep-count* 3)
 (defun beep (&optional (n *default-beep-count*))
   (dotimes (i n) (si:%beep 1000. 100000.) (sleep 0.1)))

Here we could easily imagine editing the code to change the initial
value of ÿ*default-beep-count*þ, and then reloading the file to pick up
the new value.  In order to make value updating easy, we have used
ÿdefparameterþ.

On the other hand, there is potential value to using ÿdefvarþ in this
situation.  For example, suppose that someone had predefined an
alternate value for ÿ*default-beep-count*þ, or had loaded the file and
then manually changed the value.  In both cases, if we had used
ÿdefvarþ instead of ÿdefparameterþ, those user preferences would not be
overridden by (re)loading the file.

The choice of whether to use ÿdefparameterþ or ÿdefvarþ has visible
consequences to programs, but is nevertheless often made for subjective
reasons.

Side Effects:
.............

If a ÿdefvarþ or ÿdefparameterþ form appears as a top level form, the
compiler must recognize that the NAME has been proclaimed ÿspecialþ.
However, it must neither evaluate the INITIAL-VALUE form nor assign the
dynamic variable named NAME at compile time.

There may be additional (implementation-defined) compile-time or
run-time side effects, as long as such effects do not interfere with the
correct operation of conforming programs.

Affected By:
............

ÿdefvarþ is affected by whether NAME is already bound.

See Also:
.........

*Note declaim::, *Note defconstant::, *Note documentation::, *Note
Section 3.2 (Compilation): Compilation.

Notes:
......

It is customary to name dynamic variables with an asterisk at the
beginning and end of the name.  e.g., ÿ*foo*þ is a good name for a
dynamic variable, but not for a lexical variable; ÿfooþ is a good name
for a lexical variable, but not for a dynamic variable.  This naming
convention is observed for all defined names in Common Lisp; however,
neither conforming programs nor conforming implementations are obliged
to adhere to this convention.

The intent of the permission for additional side effects is to allow
implementations to do normal "bookkeeping" that accompanies
definitions.  For example, the macro expansion of a ÿdefvarþ or
ÿdefparameterþ form might include code that arranges to record the name
of the source file in which the definition occurs.

ÿdefparameterþ and ÿdefvarþ might be defined as follows:

 (defmacro defparameter (name initial-value
                         &optional (documentation nil documentation-p))
   `(progn (declaim (special ,name))
           (setf (symbol-value ',name) ,initial-value)
           ,(when documentation-p
              `(setf (documentation ',name 'variable) ',documentation))
           ',name))
 (defmacro defvar (name &optional
                        (initial-value nil initial-value-p)
                        (documentation nil documentation-p))
   `(progn (declaim (special ,name))
           ,(when initial-value-p
              `(unless (boundp ',name)
                 (setf (symbol-value ',name) ,initial-value)))
           ,(when documentation-p
              `(setf (documentation ',name 'variable) ',documentation))
           ',name))


File: chris-ansicl.info,  Node: destructuring-bind,  Next: let; let*,  Prev: defparameter; defvar,  Up: Data and Control Flow

destructuring-bind (Macro)
==========================

Syntax:
.......

 -- Macro: destructuring-bind lambda-list expression {declaration}*
          {form}* ý {result}*

Arguments and Values:
.....................

LAMBDA-LIST--a destructuring lambda list.

EXPRESSION--a form.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the forms.

Description:
............

ÿdestructuring-bindþ binds the variables specified in LAMBDA-LIST to
the corresponding values in the tree structure resulting from the
evaluation of EXPRESSION; then ÿdestructuring-bindþ evaluates FORMS.

The LAMBDA-LIST supports destructuring as described in *Note Section
3.4.5 (Destructuring Lambda Lists): Destructuring Lambda Lists.

Examples:
.........

 (defun iota (n) (loop for i from 1 to n collect i))       ;helper
 (destructuring-bind ((a &optional (b 'bee)) one two three)
     `((alpha) ,@(iota 3))
   (list a b three two one)) ý (ALPHA BEE 3 2 1)

Exceptional Situations:
.......................

If the result of evaluating the EXPRESSION does not match the
destructuring pattern, an error of type ÿerrorþ should be signaled.

See Also:
.........

*Note macrolet::, *Note defmacro::


File: chris-ansicl.info,  Node: let; let*,  Next: progv,  Prev: destructuring-bind,  Up: Data and Control Flow

let, let* (Special Operator)
============================

Syntax:
.......

 -- Special Form: let ({var | (var [init-form])}*) {declaration}*
          {form}* ý {result}*

 -- Special Form: let* ({var | (var [init-form])}*) {declaration}*
          {form}* ý {result}*

Arguments and Values:
.....................

VAR--a symbol.

INIT-FORM--a form.

DECLARATION--a declare expression; not evaluated.

FORM--a form.

RESULTS--the values returned by the forms.

Description:
............

ÿletþ and ÿlet*þ create new variable bindings and execute a series of
FORMS that use these bindings.  ÿletþ performs the bindings in parallel
and ÿlet*þ does them sequentially.

The form

 (let ((VAR1 INIT-FORM-1)
       (VAR2 INIT-FORM-2)
       ...
       (VARM INIT-FORM-M))
   DECLARATION1
   DECLARATION2
   ...
   DECLARATIONP
   FORM1
   FORM2
   ...
   FORMN)

first evaluates the expressions INIT-FORM-1, INIT-FORM-2, and so on, in
that order, saving the resulting values.  Then all of the variables
VARJ are bound to the corresponding values; each binding is lexical
unless there is a ÿspecialþ declaration to the contrary.  The
expressions FORMK are then evaluated in order; the values of all but
the last are discarded (that is, the body of a ÿletþ is an implicit
progn).

ÿlet*þ is similar to ÿletþ, but the bindings of variables are performed
sequentially rather than in parallel.  The expression for the INIT-FORM
of a VAR can refer to VARS previously bound in the ÿlet*þ.

The form

 (let* ((VAR1 INIT-FORM-1)
        (VAR2 INIT-FORM-2)
        ...
        (VARM INIT-FORM-M))
   DECLARATION1
   DECLARATION2
   ...
   DECLARATIONP
   FORM1
   FORM2
   ...
   FORMN)

first evaluates the expression INIT-FORM-1, then binds the variable
VAR1 to that value; then it evaluates INIT-FORM-2 and binds VAR2, and
so on.  The expressions FORMJ are then evaluated in order; the values
of all but the last are discarded (that is, the body of ÿlet*þ is an
implicit ÿprognþ).

For both ÿletþ and ÿlet*þ, if there is not an INIT-FORM associated with
a VAR, VAR is initialized to ÿnilþ.

The special form ÿletþ has the property that the scope of the name
binding does not include any initial value form.  For ÿlet*þ, a
variable's scope also includes the remaining initial value forms for
subsequent variable bindings.

Examples:
.........

 (setq a 'top) ý TOP
 (defun dummy-function () a) ý DUMMY-FUNCTION
 (let ((a 'inside) (b a))
    (format nil "~S ~S ~S" a b (dummy-function))) ý "INSIDE TOP TOP"
 (let* ((a 'inside) (b a))
    (format nil "~S ~S ~S" a b (dummy-function))) ý "INSIDE INSIDE TOP"
 (let ((a 'inside) (b a))
    (declare (special a))
    (format nil "~S ~S ~S" a b (dummy-function))) ý "INSIDE TOP INSIDE"

The code

 (let (x)
   (declare (integer x))
   (setq x (gcd y z))
   ...)

is incorrect; although ÿxþ is indeed set before it is used, and is set
to a value of the declared type integer, nevertheless ÿxþ initially
takes on the value ÿnilþ in violation of the type declaration.

See Also:
.........

*Note progv::


File: chris-ansicl.info,  Node: progv,  Next: setq,  Prev: let; let*,  Up: Data and Control Flow

progv (Special Operator)
========================

Syntax:
.......

 -- Special Form: progv SYMBOLS VALUES {form}* ý {result}*

Arguments and Values:
.....................

SYMBOLS--a list of symbols; evaluated.

VALUES--a list of objects; evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the forms.

Description:
............

ÿprogvþ creates new dynamic variable bindings and executes each FORM
using those bindings.  Each FORM is evaluated in  order.

ÿprogvþ allows binding one or more dynamic variables whose names may be
determined at run time.  Each FORM is evaluated in order with the
dynamic variables whose names are in SYMBOLS bound to corresponding
VALUES.  If too few VALUES are supplied, the remaining symbols are
bound and then made to have no value. If too many VALUES are supplied,
the excess values are ignored.  The bindings of the dynamic variables
are undone on exit from ÿprogvþ.

Examples:
.........

 (setq *x* 1) ý 1
 (progv '(*x*) '(2) *x*) ý 2
 *x* ý 1

Assuming *x* is not globally special,

 (let ((*x* 3))
    (progv '(*x*) '(4)
      (list *x* (symbol-value '*x*)))) ý (3 4)

See Also:
.........

*Note let::, *Note Section 3.1 (Evaluation): Evaluation.

Notes:
......

Among other things, ÿprogvþ is useful when writing interpreters for
languages embedded in Lisp; it provides a handle on the mechanism for
binding dynamic variables.


File: chris-ansicl.info,  Node: setq,  Next: psetq,  Prev: progv,  Up: Data and Control Flow

setq (Special Form)
===================

Syntax:
.......

 -- Special Form: setq {ûpair}* ý result

PAIR::=
     var form

Pronunciation:
..............

[êsetékyü]

Arguments and Values:
.....................

VAR--a symbol naming a variable other than a constant variable.

FORM--a form.

RESULT--the primary value of the last FORM, or ÿnilþ if no PAIRS were
supplied.

Description:
............

Assigns values to variables.

ÿ(setq var1 form1 var2 form2 ...)þ is the simple variable assignment
statement of Lisp.  First FORM1 is evaluated and the result is stored
in the variable VAR1, then FORM2 is evaluated and the result stored in
VAR2, and so forth.  ÿsetqþ may be used for assignment of both lexical
and dynamic variables.

If any VAR refers to a binding made by ÿsymbol-macroletþ, then that VAR
is treated as if ÿsetfþ (not ÿsetqþ) had been used.

Examples:
.........

 ;; A simple use of SETQ to establish values for variables.
 (setq a 1 b 2 c 3) ý 3
 a ý 1
 b ý 2
 c ý 3

 ;; Use of SETQ to update values by sequential assignment.
 (setq a (1+ b) b (1+ a) c (+ a b)) ý 7
 a ý 3
 b ý 4
 c ý 7

 ;; This illustrates the use of SETQ on a symbol macro.
 (let ((x (list 10 20 30)))
   (symbol-macrolet ((y (car x)) (z (cadr x)))
     (setq y (1+ z) z (1+ y))
     (list x y z)))
ý ((21 22 30) 21 22)

Side Effects:
.............

The primary value of each FORM is assigned to the corresponding VAR.

See Also:
.........

*Note psetq::, *Note set::, *Note setf::


File: chris-ansicl.info,  Node: psetq,  Next: block,  Prev: setq,  Up: Data and Control Flow

psetq (Macro)
=============

Syntax:
.......

 -- Macro: psetq {ûpair}* ý ÿnilþ

PAIR::=
     var form

Pronunciation:
..............

ÿpsetqþ: [äpæêsetékyü]

Arguments and Values:
.....................

VAR--a symbol naming a variable other than a constant variable.

FORM--a form.

Description:
............

Assigns values to variables.

This is just like ÿsetqþ, except that the assignments happen "in
parallel."  That is, first all of the forms are evaluated, and only
then are the variables set to the resulting values.  In this way, the
assignment to one variable does not affect the value computation of
another in the way that would occur with ÿsetqþ's sequential assignment.

If any VAR refers to a binding made by ÿsymbol-macroletþ, then that VAR
is treated as if ÿpsetfþ (not ÿpsetqþ) had been used.

Examples:
.........

 ;; A simple use of PSETQ to establish values for variables.
 ;; As a matter of style, many programmers would prefer SETQ
 ;; in a simple situation like this where parallel assignment
 ;; is not needed, but the two have equivalent effect.
 (psetq a 1 b 2 c 3) ý NIL
 a ý 1
 b ý 2
 c ý 3

 ;; Use of PSETQ to update values by parallel assignment.
 ;; The effect here is very different than if SETQ had been used.
 (psetq a (1+ b) b (1+ a) c (+ a b)) ý NIL
 a ý 3
 b ý 2
 c ý 3

 ;; Use of PSETQ on a symbol macro.
 (let ((x (list 10 20 30)))
   (symbol-macrolet ((y (car x)) (z (cadr x)))
     (psetq y (1+ z) z (1+ y))
     (list x y z)))
ý ((21 11 30) 21 11)

 ;; Use of parallel assignment to swap values of A and B.
 (let ((a 1) (b 2))
   (psetq a b  b a)
   (values a b))
ý 2, 1

Side Effects:
.............

The values of FORMS are assigned to VARS.

See Also:
.........

*Note psetf::, *Note setq::


File: chris-ansicl.info,  Node: block,  Next: catch,  Prev: psetq,  Up: Data and Control Flow

block (Special Operator)
========================

Syntax:
.......

 -- Special Form: block NAME FORM* ý {result}*

Arguments and Values:
.....................

NAME--a symbol.

FORM--a form.

RESULTS--the values of the forms if a normal return occurs, or else, if
an explicit return occurs, the values that were transferred.

Description:
............

ÿblockþ establishes a block named NAME and then evaluates FORMS as an
implicit progn.

The special operators ÿblockþ and ÿreturn-fromþ work together to
provide a structured, lexical, non-local exit facility.  At any point
lexically contained within forms, ÿreturn-fromþ can be used with the
given NAME to return control and values from the ÿblockþ form, except
when an intervening block with the same name has been established, in
which case the outer block is shadowed by the inner one.

The block named name has lexical scope and dynamic extent.

Once established, a block may only be exited once, whether by normal
return or explicit return.

Examples:
.........

 (block empty) ý NIL
 (block whocares (values 1 2) (values 3 4)) ý 3, 4
 (let ((x 1))
   (block stop (setq x 2) (return-from stop) (setq x 3))
   x) ý 2
 (block early (return-from early (values 1 2)) (values 3 4)) ý 1, 2
 (block outer (block inner (return-from outer 1)) 2) ý 1
 (block twin (block twin (return-from twin 1)) 2) ý 2
 ;; Contrast behavior of this example with corresponding example of CATCH.
 (block b
   (flet ((b1 () (return-from b 1)))
     (block b (b1) (print 'unreachable))
     2)) ý 1

See Also:
.........

*Note return::, *Note return-from::, *Note Section 3.1 (Evaluation):
Evaluation.

Notes:
......


File: chris-ansicl.info,  Node: catch,  Next: go,  Prev: block,  Up: Data and Control Flow

catch (Special Operator)
========================

Syntax:
.......

 -- Special Form: catch TAG {form}* ý {result}*

Arguments and Values:
.....................

TAG--a catch tag; evaluated.

FORMS--an implicit progn.

RESULTS--if the FORMS exit normally, the values returned by the FORMS;
if a throw occurs to the TAG, the values that are thrown.

Description:
............

ÿcatchþ is used as the destination of a non-local control transfer by
ÿthrowþ.  TAGS are used to find the ÿcatchþ to which a ÿthrowþ is
transferring control.  ÿ(catch 'foo form)þ catches a ÿ(throw 'foo
form)þ but not a ÿ(throw 'bar form)þ.

The order of execution of ÿcatchþ follows: 

  1. TAG is evaluated.  It serves as the name of the ÿcatchþ.

  2. FORMS are then evaluated as an implicit ÿprognþ, and the results
     of the last FORM are returned unless a ÿthrowþ occurs.

  3. If a ÿthrowþ occurs during the execution of one of the FORMS,
     control is transferred  to the ÿcatchþ form whose TAG is ÿeqþ to
     the tag argument of the ÿthrowþ and which is the most recently
     established ÿcatchþ with that TAG.  No further evaluation of FORMS
     occurs.

  4. The TAG established by ÿcatchþ is disestablished just before the
     results are returned.

If during the execution of one of the FORMS, a ÿthrowþ is executed
whose tag is ÿeqþ to the ÿcatchþ tag, then the values specified by the
ÿthrowþ are returned as the result of the dynamically most recently
established ÿcatchþ form with that tag.

The mechanism for ÿcatchþ and ÿthrowþ works even if ÿthrowþ is not
within the lexical scope of ÿcatchþ.  ÿthrowþ must occur within the
dynamic extent of the evaluation of the body of a ÿcatchþ with a
corresponding TAG.

Examples:
.........

 (catch 'dummy-tag 1 2 (throw 'dummy-tag 3) 4) ý 3
 (catch 'dummy-tag 1 2 3 4) ý 4
 (defun throw-back (tag) (throw tag t)) ý THROW-BACK
 (catch 'dummy-tag (throw-back 'dummy-tag) 2) ý T

 ;; Contrast behavior of this example with corresponding example of BLOCK.
 (catch 'c
   (flet ((c1 () (throw 'c 1)))
     (catch 'c (c1) (print 'unreachable))
     2)) ý 2

Exceptional Situations:
.......................

An error of type ÿcontrol-errorþ is signaled if ÿthrowþ is done when
there is no suitable ÿcatchþ TAG.

See Also:
.........

*Note throw::, *Note Section 3.1 (Evaluation): Evaluation.

Notes:
......

It is customary for symbols to be used as TAGS, but any object is
permitted.  However, numbers should not be used because the comparison
is done using ÿeqþ.

ÿcatchþ differs from ÿblockþ in that ÿcatchþ tags have dynamic scope
while ÿblockþ names have lexical scope.


File: chris-ansicl.info,  Node: go,  Next: return-from,  Prev: catch,  Up: Data and Control Flow

go (Special Operator)
=====================

Syntax:
.......

 -- Special Form: go tag ý|

Arguments and Values:
.....................

TAG--a go tag.

Description:
............

ÿgoþ transfers control to the point in the body of an enclosing
ÿtagbodyþ form labeled by a tag ÿeqlþ to TAG.  If there is no such TAG
in the body, the bodies of lexically containing ÿtagbodyþ forms (if
any) are examined as well.  If several tags are ÿeqlþ to TAG, control
is transferred to whichever matching TAG is contained in the innermost
ÿtagbodyþ form that contains the ÿgoþ.  The consequences are undefined
if there is no matching TAG lexically visible to the point of the ÿgoþ.

The transfer of control initiated by ÿgoþ is performed as described in
*Note Section 5.2 (Transfer of Control to an Exit Point): Transfer of
Control to an Exit Point.

Examples:
.........

 (tagbody
   (setq val 2)
   (go lp)
   (incf val 3)
   lp (incf val 4)) ý NIL
 val ý 6

The following is in error because there is a normal exit of the
ÿtagbodyþ before the ÿgoþ is executed.

 (let ((a nil))
   (tagbody t (setq a #'(lambda () (go t))))
   (funcall a))

The following is in error because the ÿtagbodyþ is passed over before
the ÿgoþ form is executed.

 (funcall (block nil
            (tagbody a (return #'(lambda () (go a))))))

See Also:
.........

*Note tagbody::


File: chris-ansicl.info,  Node: return-from,  Next: return,  Prev: go,  Up: Data and Control Flow

return-from (Special Operator)
==============================

Syntax:
.......

 -- Special Form: return-from NAME [RESULT] ý|

Arguments and Values:
.....................

NAME--a block tag; not evaluated.

RESULT--a form; evaluated.  The default is ÿnilþ.

Description:
............

Returns control and multiple valuesà from a lexically enclosing block.

A ÿblockþ form named NAME must lexically enclose the occurrence of
ÿreturn-fromþ;  any values yielded by the evaluation of RESULT are
immediately returned from the innermost such lexically enclosing block.

The transfer of control initiated by ÿreturn-fromþ is performed as
described in *Note Section 5.2 (Transfer of Control to an Exit Point):
Transfer of Control to an Exit Point.

Examples:
.........

 (block alpha (return-from alpha) 1) ý NIL
 (block alpha (return-from alpha 1) 2) ý 1
 (block alpha (return-from alpha (values 1 2)) 3) ý 1, 2
 (let ((a 0))
    (dotimes (i 10) (incf a) (when (oddp i) (return)))
    a) ý 2
 (defun temp (x)
    (if x (return-from temp 'dummy))
    44) ý TEMP
 (temp nil) ý 44
 (temp t) ý DUMMY
 (block out
   (flet ((exit (n) (return-from out n)))
     (block out (exit 1)))
   2) ý 1
 (block nil
   (unwind-protect (return-from nil 1)
     (return-from nil 2)))
ý 2
 (dolist (flag '(nil t))
   (block nil
     (let ((x 5))
       (declare (special x))
       (unwind-protect (return-from nil)
         (print x))))
   (print 'here))
Ö 5
Ö HERE
Ö 5
Ö HERE
ý NIL
 (dolist (flag '(nil t))
   (block nil
     (let ((x 5))
       (declare (special x))
       (unwind-protect
           (if flag (return-from nil))
         (print x))))
   (print 'here))
Ö 5
Ö HERE
Ö 5
Ö HERE
ý NIL

The following has undefined consequences because the ÿblockþ form exits
normally before the ÿreturn-fromþ form is attempted.

 (funcall (block nil #'(lambda () (return-from nil)))) is an error.

See Also:
.........

*Note block::, *Note return::, *Note Section 3.1 (Evaluation):
Evaluation.


File: chris-ansicl.info,  Node: return,  Next: tagbody,  Prev: return-from,  Up: Data and Control Flow

return (Macro)
==============

Syntax:
.......

 -- Macro: return [RESULT] ý|

Arguments and Values:
.....................

RESULT--a form; evaluated.  The default is ÿnilþ.

Description:
............

Returns, as if by ÿreturn-fromþ, from the block named ÿnilþ.

Examples:
.........

 (block nil (return) 1) ý NIL
 (block nil (return 1) 2) ý 1
 (block nil (return (values 1 2)) 3) ý 1, 2
 (block nil (block alpha (return 1) 2)) ý 1
 (block alpha (block nil (return 1)) 2) ý 2
 (block nil (block nil (return 1) 2)) ý 1

See Also:
.........

*Note block::, *Note return-from::, *Note Section 3.1 (Evaluation):
Evaluation.

Notes:
......

 (return) Õ (return-from nil)
 (return FORM) Õ (return-from nil FORM)

The implicit blocks established by macros such as ÿdoþ are often named
ÿnilþ, so that ÿreturnþ can be used to exit from such forms.


File: chris-ansicl.info,  Node: tagbody,  Next: throw,  Prev: return,  Up: Data and Control Flow

tagbody (Special Operator)
==========================

Syntax:
.......

 -- Special Form: tagbody {TAG | STATEMENT}* ý ÿnilþ

Arguments and Values:
.....................

TAG--a go tag; not evaluated.

STATEMENT--a compound form; evaluated as described below.

Description:
............

Executes zero or more statements in a lexical environment that provides
for control transfers to labels indicated by the TAGS.

The STATEMENTS in a ÿtagbodyþ are evaluated in order from left to
right, and their values are discarded.  If at any time there are no
remaining STATEMENTS, ÿtagbodyþ returns ÿnilþ.  However, if ÿ(go TAG)þ
is evaluated, control jumps to the part of the body labeled with the
TAG.  (Tags are compared with ÿeqlþ.)

A TAG established by ÿtagbodyþ has lexical scope and has dynamic
extent.  Once ÿtagbodyþ has been exited, it is no longer valid to ÿgoþ
to a TAG in its body.  It is permissible for ÿgoþ to jump to a
ÿtagbodyþ that is not the innermost ÿtagbodyþ containing that ÿgoþ; the
TAGS established by a ÿtagbodyþ only shadow other TAGS of like name.

The determination of which elements of the body are TAGS and which are
STATEMENTS is made prior to any macro expansion of that element.  If a
STATEMENT is a macro form and its macro expansion is an atom, that atom
is treated as a STATEMENT, not a TAG.

Examples:
.........

 (let (val)
    (tagbody
      (setq val 1)
      (go point-a)
      (incf val 16)
     point-c
      (incf val 04)
      (go point-b)
      (incf val 32)
     point-a
      (incf val 02)
      (go point-c)
      (incf val 64)
     point-b
      (incf val 08))
    val)
ý 15
 (defun f1 (flag)
   (let ((n 1))
     (tagbody
       (setq n (f2 flag #'(lambda () (go out))))
      out
       (prin1 n))))
ý F1
 (defun f2 (flag escape)
   (if flag (funcall escape) 2))
ý F2
 (f1 nil)
Ö 2
ý NIL
 (f1 t)
Ö 1
ý NIL

See Also:
.........

*Note go::

Notes:
......

The macros in the next figure have implicit tagbodies.

do               do-external-symbols   dotimes
do*              do-symbols            prog
do-all-symbols   dolist                prog*

Figure 5.10: Macros that have implicit tagbodies.


File: chris-ansicl.info,  Node: throw,  Next: unwind-protect,  Prev: tagbody,  Up: Data and Control Flow

throw (Special Operator)
========================

Syntax:
.......

 -- Special Form: throw tag result-form ý|

Arguments and Values:
.....................

TAG--a catch tag; evaluated.

RESULT-FORM--a form; evaluated as described below.

Description:
............

ÿthrowþ causes a non-local control transfer to a ÿcatchþ whose tag is
ÿeqþ to TAG.

TAG is evaluated first to produce an object called the throw tag; then
RESULT-FORM is evaluated, and its results are saved. If the RESULT-FORM
produces multiple values, then all the values are saved.  The most
recent outstanding ÿcatchþ whose TAG is ÿeqþ to the throw tag is
exited; the saved results are returned as the value or values of
ÿcatchþ.

The transfer of control initiated by ÿthrowþ is performed as described
in *Note Section 5.2 (Transfer of Control to an Exit Point): Transfer
of Control to an Exit Point.

Examples:
.........

 (catch 'result
    (setq i 0 j 0)
    (loop (incf j 3) (incf i)
          (if (= i 3) (throw 'result (values i j))))) ý 3, 9

 (catch nil
   (unwind-protect (throw nil 1)
     (throw nil 2))) ý 2

The consequences of the following are undefined because the ÿcatchþ of
ÿbþ is passed over by the first ÿthrowþ, hence portable programs must
assume that its dynamic extent is terminated.  The binding of the catch
tag is not yet disestablished and therefore it is the target of the
second ÿthrowþ.

 (catch 'a
   (catch 'b
     (unwind-protect (throw 'a 1)
       (throw 'b 2))))

The following prints "ÿThe inner catch returns :SECOND-THROWþ" and then
returns ÿ:outer-catchþ.

 (catch 'foo
         (format t "The inner catch returns ~s.~%"
                 (catch 'foo
                     (unwind-protect (throw 'foo :first-throw)
                         (throw 'foo :second-throw))))
         :outer-catch)
Ö The inner catch returns :SECOND-THROW
ý :OUTER-CATCH

Exceptional Situations:
.......................

If there is no outstanding catch tag that matches the throw tag, no
unwinding of the stack is performed, and an error of type
ÿcontrol-errorþ is signaled.  When the error is signaled, the dynamic
environment is that which was in force at the point of the ÿthrowþ.

See Also:
.........

*Note block::, *Note catch::, *Note return-from::, *Note
unwind-protect::, *Note Section 3.1 (Evaluation): Evaluation.

Notes:
......

ÿcatchþ and ÿthrowþ are normally used when the exit point must have
dynamic scope (e.g., the ÿthrowþ is not lexically enclosed by the
ÿcatchþ), while ÿblockþ and ÿreturnþ are used when lexical scope is
sufficient.


File: chris-ansicl.info,  Node: unwind-protect,  Next: nil (Constant Variable),  Prev: throw,  Up: Data and Control Flow

unwind-protect (Special Operator)
=================================

Syntax:
.......

 -- Special Form: unwind-protect PROTECTED-FORM {cleanup-form}* ý
          {result}*

Arguments and Values:
.....................

PROTECTED-FORM--a form.

CLEANUP-FORM--a form.

RESULTS--the values of the protected-form.

Description:
............

ÿunwind-protectþ evaluates PROTECTED-FORM and guarantees that
CLEANUP-FORMS are executed before ÿunwind-protectþ exits, whether it
terminates normally or is aborted by a control transfer of some kind.
ÿunwind-protectþ is intended to be used to make sure that certain side
effects take place after the evaluation of PROTECTED-FORM.

If a non-local exit occurs during execution of CLEANUP-FORMS, no
special action is taken.  The CLEANUP-FORMS of ÿunwind-protectþ are not
protected by that ÿunwind-protectþ.

ÿunwind-protectþ protects against all attempts to exit from
PROTECTED-FORM, including ÿgoþ, ÿhandler-caseþ, ÿignore-errorsþ,
ÿrestart-caseþ, ÿreturn-fromþ, ÿthrowþ, and ÿwith-simple-restartþ.

Undoing of handler and restart bindings during an exit happens in
parallel with the undoing of the bindings of dynamic variables and
ÿcatchþ tags, in the reverse order in which they were established.  The
effect of this is that CLEANUP-FORM sees the same handler and restart
bindings, as well as dynamic variable bindings and ÿcatchþ tags, as
were visible when the ÿunwind-protectþ was entered.

Examples:
.........

 (tagbody
   (let ((x 3))
     (unwind-protect
       (if (numberp x) (go out))
       (print x)))
  out
   ...)

When ÿgoþ is executed, the call to ÿprintþ is executed first, and then
the transfer of control to the tag ÿoutþ is completed.

 (defun dummy-function (x)
    (setq state 'running)
    (unless (numberp x) (throw 'abort 'not-a-number))
    (setq state (1+ x))) ý DUMMY-FUNCTION
 (catch 'abort (dummy-function 1)) ý 2
 state ý 2
 (catch 'abort (dummy-function 'trash)) ý NOT-A-NUMBER
 state ý RUNNING
 (catch 'abort (unwind-protect (dummy-function 'trash)
                  (setq state 'aborted))) ý NOT-A-NUMBER
 state ý ABORTED

The following code is not correct:

 (unwind-protect
   (progn (incf *access-count*)
          (perform-access))
   (decf *access-count*))

If an exit occurs before completion of ÿincfþ, the ÿdecfþ form is
executed anyway, resulting in an incorrect value for ÿ*access-count*þ.
The correct way to code this is as follows:

 (let ((old-count *access-count*))
   (unwind-protect
     (progn (incf *access-count*)
            (perform-access))
     (setq *access-count* old-count)))

;;; The following returns 2.
 (block nil
   (unwind-protect (return 1)
     (return 2)))

;;; The following has undefined consequences.
 (block a
   (block b
     (unwind-protect (return-from a 1)
       (return-from b 2))))

;;; The following returns 2.
 (catch nil
   (unwind-protect (throw nil 1)
     (throw nil 2)))

;;; The following has undefined consequences because the catch of B is
;;; passed over by the first THROW, hence portable programs must assume
;;; its dynamic extent is terminated.  The binding of the catch tag is not
;;; yet disestablished and therefore it is the target of the second throw.
 (catch 'a
   (catch 'b
     (unwind-protect (throw 'a 1)
       (throw 'b 2))))

;;; The following prints "The inner catch returns :SECOND-THROW"
;;; and then returns :OUTER-CATCH.
 (catch 'foo
         (format t "The inner catch returns ~s.~%"
                 (catch 'foo
                     (unwind-protect (throw 'foo :first-throw)
                         (throw 'foo :second-throw))))
         :outer-catch)


;;; The following returns 10. The inner CATCH of A is passed over, but
;;; because that CATCH is disestablished before the THROW to A is executed,
;;; it isn't seen.
 (catch 'a
   (catch 'b
     (unwind-protect (1+ (catch 'a (throw 'b 1)))
       (throw 'a 10))))


;;; The following has undefined consequences because the extent of
;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...)
;;; commences.
 (catch 'foo
   (catch 'bar
       (unwind-protect (throw 'foo 3)
         (throw 'bar 4)
         (print 'xxx))))


;;; The following returns 4; XXX is not printed.
;;; The (THROW 'FOO ...) has no effect on the scope of the BAR
;;; catch tag or the extent of the (CATCH 'BAR ...) exit.
 (catch 'bar
   (catch 'foo
       (unwind-protect (throw 'foo 3)
         (throw 'bar 4)
         (print 'xxx))))


;;; The following prints 5.
 (block nil
   (let ((x 5))
     (declare (special x))
     (unwind-protect (return)
       (print x))))

See Also:
.........

*Note catch::, *Note go::, *Note handler-case::, *Note restart-case::,
*Note return::, *Note return-from::, *Note throw::, *Note Section 3.1
(Evaluation): Evaluation.


File: chris-ansicl.info,  Node: nil (Constant Variable),  Next: not (Function),  Prev: unwind-protect,  Up: Data and Control Flow

nil (Constant Variable)
=======================

Constant Value:
...............

ÿnilþ.

Description:
............

ÿnilþ represents both boolean (and generalized boolean) false and the
empty list.

Examples:
.........

 nil ý NIL

See Also:
.........

*Note t (Constant Variable)::


File: chris-ansicl.info,  Node: not (Function),  Next: t (Constant Variable),  Prev: nil (Constant Variable),  Up: Data and Control Flow

not (Function)
==============

Syntax:
.......

 -- Function: not x ý boolean

Arguments and Values:
.....................

X--a generalized boolean (i.e., any object).

BOOLEAN--a boolean.

Description:
............

Returns ÿtþ if X is false; otherwise, returns ÿnilþ.

Examples:
.........

 (not nil) ý T
 (not '()) ý T
 (not (integerp 'sss)) ý T
 (not (integerp 1)) ý NIL
 (not 3.7) ý NIL
 (not 'apple) ý NIL

See Also:
.........

*Note null (Function)::

Notes:
......

ÿnotþ is intended to be used to invert the `truth value' of a boolean
(or generalized boolean) whereas ÿnullþ is intended to be used to test
for the empty list.  Operationally, ÿnotþ and ÿnullþ compute the same
result; which to use is a matter of style.


File: chris-ansicl.info,  Node: t (Constant Variable),  Next: eq,  Prev: not (Function),  Up: Data and Control Flow

t (Constant Variable)
=====================

Constant Value:
...............

t.

Description:
............

The boolean representing true, and the canonical generalized boolean
representing true.  Although any object other than ÿnilþ is considered
true, ÿtþ is generally used when there is no special reason to prefer
one such object over another.

The symbol ÿtþ is also sometimes used for other purposes as well.  For
example, as the name of a class, as a designator (e.g., a stream
designator) or as a special symbol for some syntactic reason (e.g., in
ÿcaseþ and ÿtypecaseþ to label the OTHERWISE-CLAUSE).

Examples:
.........

 t ý T
 (eq t 't) ý true
 (find-class 't) ý #<CLASS T 610703333>
 (case 'a (a 1) (t 2)) ý 1
 (case 'b (a 1) (t 2)) ý 2
 (prin1 'hello t)
Ö HELLO
ý HELLO

See Also:
.........

*Note nil (Constant Variable)::


File: chris-ansicl.info,  Node: eq,  Next: eql (Function),  Prev: t (Constant Variable),  Up: Data and Control Flow

eq (Function)
=============

Syntax:
.......

 -- Function: eq x y ý generalized-boolean

Arguments and Values:
.....................

X--an object.

Y--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if its arguments are the same, identical object;
otherwise, returns false.

Examples:
.........

 (eq 'a 'b) ý false
 (eq 'a 'a) ý true
 (eq 3 3)
ý true
orý false
 (eq 3 3.0) ý false
 (eq 3.0 3.0)
ý true
orý false
 (eq #c(3 -4) #c(3 -4))
ý true
orý false
 (eq #c(3 -4.0) #c(3 -4)) ý false
 (eq (cons 'a 'b) (cons 'a 'c)) ý false
 (eq (cons 'a 'b) (cons 'a 'b)) ý false
 (eq '(a . b) '(a . b))
ý true
orý false
 (progn (setq x (cons 'a 'b)) (eq x x)) ý true
 (progn (setq x '(a . b)) (eq x x)) ý true
 (eq #\A #\A)
ý true
orý false
 (let ((x "Foo")) (eq x x)) ý true
 (eq "Foo" "Foo")
ý true
orý false
 (eq "Foo" (copy-seq "Foo")) ý false
 (eq "FOO" "foo") ý false
 (eq "string-seq" (copy-seq "string-seq")) ý false
 (let ((x 5)) (eq x x))
ý true
orý false

See Also:
.........

*Note eql (Function)::, *Note equal::, *Note equalp::, *Note =::, *Note
Section 3.2 (Compilation): Compilation.

Notes:
......

Objects that appear the same when printed are not necessarily ÿeqþ to
each other.  Symbols that print the same usually are ÿeqþ to each other
because of the use of the ÿinternþ function.  However, numbers with the
same value need not be ÿeqþ, and two similar lists are usually not
identical.

An implementation is permitted to make "copies" of characters and
numbers at any time.  The effect is that Common Lisp makes no guarantee
that ÿeqþ is true even when both its arguments are "the same thing" if
that thing is a character or number.

Most Common Lisp operators use ÿeqlþ rather than ÿeqþ to compare
objects, or else they default to ÿeqlþ and only use ÿeqþ if
specifically requested to do so.  However, the following operators are
defined to use ÿeqþ rather than ÿeqlþ in a way that cannot be
overridden by the code which employs them:

catch            getf      throw
get              remf      
get-properties   remprop   

Figure 5.11: Operators that always prefer EQ over EQL


File: chris-ansicl.info,  Node: eql (Function),  Next: equal,  Prev: eq,  Up: Data and Control Flow

eql (Function)
==============

Syntax:
.......

 -- Function: eql x y ý generalized-boolean

Arguments and Values:
.....................

X--an object.

Y--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

The value of ÿeqlþ is true of two objects, X and Y, in the folowing
cases:

  1. If X and Y are ÿeqþ.

  2. If X and Y are both numbers of the same type and the same value.

  3. If they are both characters that represent the same character.

Otherwise the value of ÿeqlþ is false.

If an implementation supports positive and negative zeros as distinct
values, then ÿ(eql 0.0 -0.0)þ returns false.  Otherwise, when the
syntax ÿ-0.0þ is read it is interpreted as the value ÿ0.0þ, and so
ÿ(eql 0.0 -0.0)þ returns true.

Examples:
.........

 (eql 'a 'b) ý false
 (eql 'a 'a) ý true
 (eql 3 3) ý true
 (eql 3 3.0) ý false
 (eql 3.0 3.0) ý true
 (eql #c(3 -4) #c(3 -4)) ý true
 (eql #c(3 -4.0) #c(3 -4)) ý false
 (eql (cons 'a 'b) (cons 'a 'c)) ý false
 (eql (cons 'a 'b) (cons 'a 'b)) ý false
 (eql '(a . b) '(a . b))
ý true
orý false
 (progn (setq x (cons 'a 'b)) (eql x x)) ý true
 (progn (setq x '(a . b)) (eql x x)) ý true
 (eql #\A #\A) ý true
 (eql "Foo" "Foo")
ý true
orý false
 (eql "Foo" (copy-seq "Foo")) ý false
 (eql "FOO" "foo") ý false

Normally ÿ(eql 1.0s0 1.0d0)þ is false, under the assumption that
ÿ1.0s0þ and ÿ1.0d0þ are of distinct data types.  However,
implementations that do not provide four distinct floating-point
formats are permitted to "collapse" the four formats into some smaller
number of them; in such an implementation ÿ(eql 1.0s0 1.0d0)þ might be
true.

See Also:
.........

*Note eq::, *Note equal::, *Note equalp::, *Note =::, *Note char=::

Notes:
......

ÿeqlþ is the same as ÿeqþ, except that if the arguments are characters
or numbers of the same type then their values are compared.  Thus ÿeqlþ
tells whether two objects are conceptually the same, whereas ÿeqþ tells
whether two objects are implementationally identical.  It is for this
reason that ÿeqlþ, not ÿeqþ, is the default comparison predicate for
operators that take sequences as arguments.

ÿeqlþ may not be true of two floats even when they represent the same
value.  ÿ=þ is used to compare mathematical values.

Two complex numbers are considered to be ÿeqlþ if their real parts are
ÿeqlþ and their imaginary parts are ÿeqlþ.  For example, ÿ(eql #C(4 5)
#C(4 5))þ is true and ÿ(eql #C(4 5) #C(4.0 5.0))þ is false.  Note that
while ÿ(eql #C(5.0 0.0) 5.0)þ is false, ÿ(eql #C(5 0) 5)þ is true.  In
the case of ÿ(eql #C(5.0 0.0) 5.0)þ the two arguments are of different
types, and so cannot satisfy ÿeqlþ.  In the case of ÿ(eql #C(5 0) 5)þ,
ÿ#C(5 0)þ is not a complex number, but is automatically reduced to the
integer ÿ5þ.


File: chris-ansicl.info,  Node: equal,  Next: equalp,  Prev: eql (Function),  Up: Data and Control Flow

equal (Function)
================

Syntax:
.......

 -- Function: equal x y ý generalized-boolean

Arguments and Values:
.....................

X--an object.

Y--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if X and Y are structurally similar (isomorphic) objects.
Objects are treated as follows by ÿequalþ.

Symbols, Numbers, and Characters
     ÿequalþ is true of two objects if they are symbols that are ÿeqþ,
     if they are numbers that are ÿeqlþ, or if they are characters that
     are ÿeqlþ.

Conses
     For conses, ÿequalþ is defined recursively as the two cars being
     ÿequalþ and the two cdrs being ÿequalþ.

Arrays
     Two arrays are ÿequalþ only if they are ÿeqþ, with one exception:
     strings and bit vectors are compared element-by-element (using
     ÿeqlþ).  If either X or Y has a fill pointer, the fill pointer
     limits the number of elements examined by ÿequalþ.  Uppercase and
     lowercase letters in strings are considered by ÿequalþ to be
     different.

Pathnames
     Two pathnames are ÿequalþ if and only if all the corresponding
     components (host, device, and so on) are equivalent.  Whether or
     not uppercase and lowercase letters are considered equivalent in
     strings appearing in components is implementation-dependent.
     pathnames that are ÿequalþ should be functionally equivalent.

Other (Structures, hash-tables, instances, ...)
     Two other objects are ÿequalþ only if they are ÿeqþ.


ÿequalþ does not descend any objects other than the ones explicitly
specified above.  The next figure summarizes the information given in
the previous list.  In addition, the figure specifies the priority of
the behavior of ÿequalþ, with upper entries taking priority over lower
ones.

Type           Behavior
------------------------------------------- 
number         uses ÿeqlþ
character      uses ÿeqlþ
cons           descends
bit vector     descends
string         descends
pathname       "functionally equivalent"
structure      uses ÿeqþ
Other array    uses ÿeqþ
hash table     uses ÿeqþ
Other object   uses ÿeqþ

Figure 5.12: Summary and priorities of behavior of ÿequalþ

Any two objects that are ÿeqlþ are also ÿequalþ.

ÿequalþ may fail to terminate if X or Y is circular.

Examples:
.........

 (equal 'a 'b) ý false
 (equal 'a 'a) ý true
 (equal 3 3) ý true
 (equal 3 3.0) ý false
 (equal 3.0 3.0) ý true
 (equal #c(3 -4) #c(3 -4)) ý true
 (equal #c(3 -4.0) #c(3 -4)) ý false
 (equal (cons 'a 'b) (cons 'a 'c)) ý false
 (equal (cons 'a 'b) (cons 'a 'b)) ý true
 (equal #\A #\A) ý true
 (equal #\A #\a) ý false
 (equal "Foo" "Foo") ý true
 (equal "Foo" (copy-seq "Foo")) ý true
 (equal "FOO" "foo") ý false
 (equal "This-string" "This-string") ý true
 (equal "This-string" "this-string") ý false

See Also:
.........

*Note eq::, *Note eql (Function)::, *Note equalp::, *Note =::, *Note
string=::, *Note string-equal::, *Note char=::, *Note char-equal::,
*Note tree-equal::

Notes:
......

Object equality is not a concept for which there is a uniquely
determined correct algorithm. The appropriateness of an equality
predicate can be judged only in the context of the needs of some
particular program. Although these functions take any type of argument
and their names sound very generic, ÿequalþ and ÿequalpþ are not
appropriate for every application.

A rough rule of thumb is that two objects are ÿequalþ if and only if
their printed representations are the same.


File: chris-ansicl.info,  Node: equalp,  Next: identity,  Prev: equal,  Up: Data and Control Flow

equalp (Function)
=================

Syntax:
.......

 -- Function: equalp x y ý generalized-boolean

Arguments and Values:
.....................

X--an object.

Y--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if X and Y are ÿequalþ, or if they have components that
are of the same type as each other and if those components are ÿequalpþ;
specifically, ÿequalpþ returns true in the following cases:

Characters
     If two characters are ÿchar-equalþ.

Numbers
     If two numbers are the same under ÿ=þ.

Conses
     If the two cars in the conses are ÿequalpþ and the two cdrs in the
     conses are ÿequalpþ.

Arrays
     If two arrays have the same number of dimensions, the dimensions
     match, and the corresponding active elements are ÿequalpþ.  The
     types for which the arrays are specialized need not match; for
     example, a string and a general array that happens to contain the
     same characters are ÿequalpþ.  Because ÿequalpþ performs
     element-by-element comparisons of strings and ignores the case of
     characters, case distinctions are ignored when ÿequalpþ compares
     strings.

Structures
     If two structures Sá and Sà have the same class and the value of
     each slot in Sá is the same under ÿequalpþ as the value of the
     corresponding slot in Sà.

Hash Tables
     ÿequalpþ descends hash-tables by first comparing the count of
     entries and the :test function; if those are the same, it compares
     the keys of the tables using the :test function and then the values
     of the matching keys using ÿequalpþ recursively.

ÿequalpþ does not descend any objects other than the ones explicitly
specified above.  The next figure summarizes the information given in
the previous list.  In addition, the figure specifies the priority of
the behavior of ÿequalpþ, with upper entries taking priority over lower
ones.

Type           Behavior
---------------------------------------------- 
number         uses ÿ=þ
character      uses ÿchar-equalþ
cons           descends
bit vector     descends
string         descends
pathname       same as ÿequalþ
structure      descends, as described above
Other array    descends
hash table     descends, as described above
Other object   uses ÿeqþ

Figure 5.13: Summary and priorities of behavior of ÿequalpþ

Examples:
.........

 (equalp 'a 'b) ý false
 (equalp 'a 'a) ý true
 (equalp 3 3) ý true
 (equalp 3 3.0) ý true
 (equalp 3.0 3.0) ý true
 (equalp #c(3 -4) #c(3 -4)) ý true
 (equalp #c(3 -4.0) #c(3 -4)) ý true
 (equalp (cons 'a 'b) (cons 'a 'c)) ý false
 (equalp (cons 'a 'b) (cons 'a 'b)) ý true
 (equalp #\A #\A) ý true
 (equalp #\A #\a) ý true
 (equalp "Foo" "Foo") ý true
 (equalp "Foo" (copy-seq "Foo")) ý true
 (equalp "FOO" "foo") ý true

 (setq array1 (make-array 6 :element-type 'integer
                            :initial-contents '(1 1 1 3 5 7)))
ý #(1 1 1 3 5 7)
 (setq array2 (make-array 8 :element-type 'integer
                            :initial-contents '(1 1 1 3 5 7 2 6)
                            :fill-pointer 6))
ý #(1 1 1 3 5 7)
 (equalp array1 array2) ý true
 (setq vector1 (vector 1 1 1 3 5 7)) ý #(1 1 1 3 5 7)
 (equalp array1 vector1) ý true

See Also:
.........

*Note eq::, *Note eql (Function)::, *Note equal::, *Note =::, *Note
string=::, *Note string-equal::, *Note char=::, *Note char-equal::

Notes:
......

Object equality is not a concept for which there is a uniquely
determined correct algorithm. The appropriateness of an equality
predicate can be judged only in the context of the needs of some
particular program. Although these functions take any type of argument
and their names sound very generic, ÿequalþ and ÿequalpþ are not
appropriate for every application.


File: chris-ansicl.info,  Node: identity,  Next: complement,  Prev: equalp,  Up: Data and Control Flow

identity (Function)
===================

Syntax:
.......

 -- Function: identity object ý object

Arguments and Values:
.....................

OBJECT--an object.

Description:
............

Returns its argument OBJECT.

Examples:
.........

 (identity 101) ý 101
 (mapcan #'identity (list (list 1 2 3) '(4 5 6))) ý (1 2 3 4 5 6)

Notes:
......

ÿidentityþ is intended for use with functions that require a function
as an argument.

ÿ(eql x (identity x))þ returns true for all possible values of X, but
ÿ(eq x (identity x))þ might return false when X is a number or
character.

ÿidentityþ could be defined by

(defun identity (x) x)


File: chris-ansicl.info,  Node: complement,  Next: constantly,  Prev: identity,  Up: Data and Control Flow

complement (Function)
=====================

Syntax:
.......

 -- Function: complement function ý complement-function

Arguments and Values:
.....................

FUNCTION--a function.

COMPLEMENT-FUNCTION--a function.

Description:
............

Returns a function that takes the same arguments as FUNCTION, and has
the same side-effect behavior as FUNCTION, but returns only a single
value: a generalized boolean with the opposite truth value of that
which would be returned as the primary value of FUNCTION.  That is,
when the FUNCTION would have returned true as its primary value the
COMPLEMENT-FUNCTION returns false, and when the FUNCTION would have
returned false as its primary value the COMPLEMENT-FUNCTION returns
true.

Examples:
.........

 (funcall (complement #'zerop) 1) ý true
 (funcall (complement #'characterp) #\A) ý false
 (funcall (complement #'member) 'a '(a b c)) ý false
 (funcall (complement #'member) 'd '(a b c)) ý true

See Also:
.........

*Note not (Function)::

Notes:
......

 (complement x) Õ #'(lambda (&rest arguments) (not (apply x arguments)))

In Common Lisp, functions with names like "ÿxxx-if-notþ" are related to
functions with names like "ÿxxx-ifþ" in that

(xxx-if-not f . arguments) Õ (xxx-if (complement f) . arguments)

For example,

 (find-if-not #'zerop '(0 0 3)) Õ
 (find-if (complement #'zerop) '(0 0 3)) ý 3

Note that since the "ÿxxx-if-notþ" functions and the :test-not
arguments have been deprecated, uses of "ÿxxx-ifþ" functions or :test
arguments with ÿcomplementþ are preferred.


File: chris-ansicl.info,  Node: constantly,  Next: every; some; notevery; notany,  Prev: complement,  Up: Data and Control Flow

constantly (Function)
=====================

Syntax:
.......

 -- Function: constantly value ý function

Arguments and Values:
.....................

VALUE--an object.

FUNCTION--a function.

Description:
............

ÿconstantlyþ returns a function that accepts any number of arguments,
that has no side-effects, and that always returns VALUE.

Examples:
.........

 (mapcar (constantly 3) '(a b c d)) ý (3 3 3 3)
 (defmacro with-vars (vars &body forms)
   `((lambda ,vars ,@forms) ,@(mapcar (constantly nil) vars)))
ý WITH-VARS
 (macroexpand '(with-vars (a b) (setq a 3 b (* a a)) (list a b)))
ý ((LAMBDA (A B) (SETQ A 3 B (* A A)) (LIST A B)) NIL NIL), true

See Also:
.........

*Note identity::

Notes:
......

ÿconstantlyþ could be defined by:

 (defun constantly (object)
   #'(lambda (&rest arguments) object))


File: chris-ansicl.info,  Node: every; some; notevery; notany,  Next: and (Macro),  Prev: constantly,  Up: Data and Control Flow

every, some, notevery, notany (Function)
========================================

Syntax:
.......

 -- Function: every predicate &rest sequences+ ý generalized-boolean

 -- Function: some predicate &rest sequences+ ý result

 -- Function: notevery predicate &rest sequences+ ý generalized-boolean

 -- Function: notany predicate &rest sequences+ ý generalized-boolean

Arguments and Values:
.....................

PREDICATE--a designator for a function of as many arguments as there
are SEQUENCES.

SEQUENCE--a sequence.

RESULT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿeveryþ, ÿsomeþ, ÿnoteveryþ, and ÿnotanyþ test elements of SEQUENCES
for satisfaction of a given PREDICATE.  The first argument to PREDICATE
is an element of the first SEQUENCE; each succeeding argument is an
element of a succeeding SEQUENCE.

PREDICATE is first applied to the elements with index ÿ0þ in each of
the SEQUENCES, and possibly then to the elements with index ÿ1þ, and so
on, until a termination criterion is met or the end of the shortest of
the SEQUENCES is reached.

ÿeveryþ returns false as soon as any invocation of PREDICATE returns
false.  If the end of a SEQUENCE is reached, ÿeveryþ returns true.
Thus, ÿeveryþ returns true if and only if every invocation of PREDICATE
returns true.

ÿsomeþ returns the first non-nil value which is returned by an
invocation of PREDICATE.  If the end of a SEQUENCE is reached without
any invocation of the PREDICATE returning true, ÿsomeþ returns false.
Thus, ÿsomeþ returns true if and only if some invocation of PREDICATE
returns true.

ÿnotanyþ returns false as soon as any invocation of PREDICATE returns
true.  If the end of a SEQUENCE is reached, ÿnotanyþ returns true.
Thus, ÿnotanyþ returns true if and only if it is not the case that any
invocation of PREDICATE returns true.

ÿnoteveryþ returns true as soon as any invocation of PREDICATE returns
false.  If the end of a SEQUENCE is reached, ÿnoteveryþ returns false.
Thus, ÿnoteveryþ returns true if and only if it is not the case that
every invocation of PREDICATE returns true.

Examples:
.........

 (every #'characterp "abc") ý true
 (some #'= '(1 2 3 4 5) '(5 4 3 2 1)) ý true
 (notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) ý false
 (notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) ý true

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if its first argument is neither a symbol
nor a function or if any subsequent argument is not a proper sequence.

Other exceptional situations are possible, depending on the nature of
the PREDICATE.

See Also:
.........

*Note and (Macro)::, *Note or (Macro)::, *Note Section 3.6 (Traversal
Rules and Side Effects): Traversal Rules and Side Effects.

Notes:
......

 (notany PREDICATE {sequence}*) Õ (not (some PREDICATE {sequence}*))
 (notevery PREDICATE {sequence}*) Õ (not (every PREDICATE {sequence}*))


File: chris-ansicl.info,  Node: and (Macro),  Next: cond,  Prev: every; some; notevery; notany,  Up: Data and Control Flow

and (Macro)
===========

Syntax:
.......

 -- Macro: and {form}* ý {result}*

Arguments and Values:
.....................

FORM--a form.

RESULTS--the values resulting from the evaluation of the last FORM, or
the symbols ÿnilþ or ÿtþ.

Description:
............

The macro ÿandþ evaluates each FORM one at a time from left to right.
As soon as any FORM evaluates to ÿnilþ, ÿandþ returns ÿnilþ without
evaluating the remaining FORMS.  If all FORMS but the last evaluate to
true values, ÿandþ returns the results produced by evaluating the last
FORM.

If no FORMS are supplied, ÿ(and)þ returns ÿtþ.

ÿandþ passes back multiple values from the last subform but not from
subforms other than the last.

Examples:
.........

 (if (and (>= n 0)
          (< n (length a-simple-vector))
          (eq (elt a-simple-vector n) 'foo))
     (princ "Foo!"))

The above expression prints ÿFoo!þ if element ÿnþ of ÿa-simple-vectorþ
is the symbol ÿfooþ, provided also that ÿnþ is indeed a valid index for
ÿa-simple-vectorþ.  Because ÿandþ guarantees left-to-right testing of
its parts, ÿeltþ is not called if ÿnþ is out of range.

 (setq temp1 1 temp2 1 temp3 1) ý 1
 (and (incf temp1) (incf temp2) (incf temp3)) ý 2
 (and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) ý true
 (decf temp3) ý 1
 (and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) ý NIL
 (and (eql temp1 temp2) (eql temp2 temp3)) ý true
 (and) ý T

See Also:
.........

*Note cond::, *Note every::, *Note if::, *Note or (Macro)::, *Note
when::

Notes:
......

 (and FORM) Õ (let () FORM)
 (and FORM1 FORM2 ...) Õ (when FORM1 (and FORM2 ...))


File: chris-ansicl.info,  Node: cond,  Next: if,  Prev: and (Macro),  Up: Data and Control Flow

cond (Macro)
============

Syntax:
.......

 -- Macro: cond {ûclause}* ý {result}*

CLAUSE::=
     (test-form {form}*)

Arguments and Values:
.....................

TEST-FORM--a form.

FORMS--an implicit progn.

RESULTS--the values of the FORMS in the first CLAUSE whose TEST-FORM
yields true, or the primary value of the TEST-FORM if there are no
FORMS in that CLAUSE, or else ÿnilþ if no TEST-FORM yields true.

Description:
............

ÿcondþ allows the execution of FORMS to be dependent on TEST-FORM.

TEST-FORMS are evaluated one at a time in the order in which they are
given in the argument list until a TEST-FORM is found that evaluates to
true.

If there are no forms in that clause, the primary value of the
TEST-FORM is returned by the ÿcondþ form.  Otherwise, the FORMS
associated with this TEST-FORM are evaluated in order, left to right,
as an implicit progn, and the values returned by the last FORM are
returned by the ÿcondþ form.

Once one TEST-FORM has yielded true, no additional TEST-FORMS are
evaluated.  If no TEST-FORM yields true, ÿnilþ is returned.

Examples:
.........

 (defun select-options ()
   (cond ((= a 1) (setq a 2))
         ((= a 2) (setq a 3))
         ((and (= a 3) (floor a 2)))
         (t (floor a 3)))) ý SELECT-OPTIONS
 (setq a 1) ý 1
 (select-options) ý 2
 a ý 2
 (select-options) ý 3
 a ý 3
 (select-options) ý 1
 (setq a 5) ý 5
 (select-options) ý 1, 2

See Also:
.........

*Note if::, *Note case::.


File: chris-ansicl.info,  Node: if,  Next: or (Macro),  Prev: cond,  Up: Data and Control Flow

if (Special Operator)
=====================

Syntax:
.......

 -- Special Form: if TEST-FORM THEN-FORM [ELSE-FORM] ý {result}*

Arguments and Values:
.....................

TEST-FORM--a form.

THEN-FORM--a form.

ELSE-FORM--a form.  The default is ÿnilþ.

RESULTS--if the TEST-FORM yielded true, the values returned by the
THEN-FORM; otherwise, the values returned by the ELSE-FORM.

Description:
............

ÿifþ allows the execution of a form to be dependent on a single
TEST-FORM.

First TEST-FORM is evaluated.  If the result is true, then THEN-FORM is
selected; otherwise ELSE-FORM is selected.  Whichever form is selected
is then evaluated.

Examples:
.........

 (if t 1) ý 1
 (if nil 1 2) ý 2
 (defun test ()
   (dolist (truth-value '(t nil 1 (a b c)))
     (if truth-value (print 'true) (print 'false))
     (prin1 truth-value))) ý TEST
 (test)
Ö TRUE T
Ö FALSE NIL
Ö TRUE 1
Ö TRUE (A B C)
ý NIL

See Also:
.........

*Note cond::, *Note unless::, *Note when::

Notes:
......

 (if TEST-FORM THEN-FORM ELSE-FORM)
 Õ (cond (TEST-FORM THEN-FORM) (t ELSE-FORM))


File: chris-ansicl.info,  Node: or (Macro),  Next: when; unless,  Prev: if,  Up: Data and Control Flow

or (Macro)
==========

Syntax:
.......

 -- Macro: or {form}* ý {results}*

Arguments and Values:
.....................

FORM--a form.

RESULTS--the values or primary value (see below) resulting from the
evaluation of the last FORM executed or ÿnilþ.

Description:
............

ÿorþ evaluates each FORM, one at a time, from left to right.  The
evaluation of all FORMS terminates when a FORM evaluates to true (i.e.,
something other than ÿnilþ).

If the evaluation of any FORM other than the last returns a primary
value that is true, ÿorþ immediately returns that value (but no
additional values) without evaluating the remaining FORMS.  If every
FORM but the last returns false as its primary value, ÿorþ returns all
values returned by the last FORM.  If no FORMS are supplied, ÿorþ
returns ÿnilþ.

Examples:
.........

 (or) ý NIL
 (setq temp0 nil temp1 10 temp2 20 temp3 30) ý 30
 (or temp0 temp1 (setq temp2 37)) ý 10
 temp2 ý 20
 (or (incf temp1) (incf temp2) (incf temp3)) ý 11
 temp1 ý 11
 temp2 ý 20
 temp3 ý 30
 (or (values) temp1) ý 11
 (or (values temp1 temp2) temp3) ý 11
 (or temp0 (values temp1 temp2)) ý 11, 20
 (or (values temp0 temp1) (values temp2 temp3)) ý 20, 30

See Also:
.........

*Note and (Macro)::, *Note some::, *Note unless::


File: chris-ansicl.info,  Node: when; unless,  Next: case; ccase; ecase,  Prev: or (Macro),  Up: Data and Control Flow

when, unless (Macro)
====================

Syntax:
.......

 -- Macro: when test-form {form}* ý {result}*

 -- Macro: unless test-form {form}* ý {result}*

Arguments and Values:
.....................

TEST-FORM--a form.

FORMS--an implicit progn.

RESULTS--the values of the forms in a  ÿwhenþ   form if the TEST-FORM
yields true or in an ÿunlessþ form if the TEST-FORM yields false;
otherwise ÿnilþ.

Description:
............

ÿwhenþ and ÿunlessþ allow the execution of FORMS to be dependent on a
single TEST-FORM.

In a ÿwhenþ form, if the TEST-FORM yields true, the FORMS are evaluated
in order from left to right and the values returned by the FORMS are
returned from the ÿwhenþ form.  Otherwise, if the TEST-FORM yields
false, the FORMS are not evaluated, and the ÿwhenþ form returns ÿnilþ.

In an ÿunlessþ form, if the TEST-FORM yields false, the FORMS are
evaluated in order from left to right and the values returned by the
FORMS are returned from the ÿunlessþ form.  Otherwise, if the TEST-FORM
yields false, the FORMS are not evaluated, and the ÿunlessþ form
returns ÿnilþ.

Examples:
.........

 (when t 'hello) ý HELLO
 (unless t 'hello) ý NIL
 (when nil 'hello) ý NIL
 (unless nil 'hello) ý HELLO
 (when t) ý NIL
 (unless nil) ý NIL
 (when t (prin1 1) (prin1 2) (prin1 3))
Ö 123
ý 3
 (unless t (prin1 1) (prin1 2) (prin1 3)) ý NIL
 (when nil (prin1 1) (prin1 2) (prin1 3)) ý NIL
 (unless nil (prin1 1) (prin1 2) (prin1 3))
Ö 123
ý 3
 (let ((x 3))
   (list (when (oddp x) (incf x) (list x))
         (when (oddp x) (incf x) (list x))
         (unless (oddp x) (incf x) (list x))
         (unless (oddp x) (incf x) (list x))
         (if (oddp x) (incf x) (list x))
         (if (oddp x) (incf x) (list x))
         (if (not (oddp x)) (incf x) (list x))
         (if (not (oddp x)) (incf x) (list x))))
ý ((4) NIL (5) NIL 6 (6) 7 (7))

See Also:
.........

*Note and (Macro)::, *Note cond::, *Note if::, *Note or (Macro)::

Notes:
......

 (when TEST {FORM}+) Õ (and TEST (progn {FORM}+))
 (when TEST {FORM}+) Õ (cond (TEST {FORM}+))
 (when TEST {FORM}+) Õ (if TEST (progn {FORM}+) nil)
 (when TEST {FORM}+) Õ (unless (not TEST) {FORM}+)
 (unless TEST {FORM}+) Õ (cond ((not TEST) {FORM}+))
 (unless TEST {FORM}+) Õ (if TEST nil (progn {FORM}+))
 (unless TEST {FORM}+) Õ (when (not TEST) {FORM}+)


File: chris-ansicl.info,  Node: case; ccase; ecase,  Next: typecase; ctypecase; etypecase,  Prev: when; unless,  Up: Data and Control Flow

case, ccase, ecase (Macro)
==========================

Syntax:
.......

 -- Macro: case keyform {ûnormal-clause}* [ûotherwise-clause] ý
          {result}*

 -- Macro: ccase keyplace {ûnormal-clause}* ý {result}*

 -- Macro: ecase keyform {ûnormal-clause}* ý {result}*

NORMAL-CLAUSE::=
     (keys {form}*)

OTHERWISE-CLAUSE::=
     ({otherwise | t} {form}*)

CLAUSE::=
     normal-clause | otherwise-clause

Arguments and Values:
.....................

KEYFORM--a form; evaluated to produce a TEST-KEY.

KEYPLACE--a form; evaluated initially to produce a TEST-KEY.  Possibly
also used later as a place if no KEYS match.

TEST-KEY--an object produced by evaluating KEYFORM or KEYPLACE.

KEYS--a designator for a list of objects.  In the case of ÿcaseþ, the
symbols ÿtþ and otherwise may not be used as the KEYS designator.  To
refer to these symbols by themselves as KEYS, the designators ÿ(t)þ and
ÿ(otherwise)þ, respectively, must be used instead.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS in the matching CLAUSE.

Description:
............

These macros allow the conditional execution of a body of FORMS in a
CLAUSE that is selected by matching the TEST-KEY on the basis of its
identity.

The KEYFORM or KEYPLACE is evaluated to produce the TEST-KEY.

Each of the NORMAL-CLAUSES is then considered in turn.  If the TEST-KEY
is the same as any key for that CLAUSE, the FORMS in that CLAUSE are
EVALUATED as an implicit progn, and the values it returns are returned
as the value of the ÿcaseþ, ÿccaseþ, or ÿecaseþ form.

These macros differ only in their behavior when no NORMAL-CLAUSE
matches; specifically:

ÿcaseþ
     If no NORMAL-CLAUSE matches, and there is an OTHERWISE-CLAUSE,
     then that OTHERWISE-CLAUSE automatically matches; the FORMS in
     that CLAUSE are EVALUATED as an implicit progn, and the values it
     returns are returned as the value of the ÿcaseþ.

     If there is no OTHERWISE-CLAUSE, ÿcaseþ returns ÿnilþ.

ÿccaseþ
     If no NORMAL-CLAUSE matches, a correctable error of type
     ÿtype-errorþ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ÿ(member KEY1 KEY2 ...)þ.
     the ÿstore-valueþ restart can be used to correct the error.

     If the ÿstore-valueþ restart is invoked, its argument becomes the
     new TEST-KEY, and is stored in KEYPLACE as if by ÿ(setf KEYPLACE
     TEST-KEY)þ.  Then ÿccaseþ starts over, considering each CLAUSE
     anew.

     The subforms of KEYPLACE might be evaluated again if none of the
     cases holds.

ÿecaseþ
     If no NORMAL-CLAUSE matches, a non-correctable error of type
     ÿtype-errorþ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ÿ(member KEY1 KEY2 ...)þ.

     Note that in contrast with ÿccaseþ, the caller of ÿecaseþ may rely
     on the fact that ÿecaseþ does not return if a NORMAL-CLAUSE does
     not match.

Examples:
.........

 (dolist (k '(1 2 3 :four #\v () t 'other))
    (format t "~S "
       (case k ((1 2) 'clause1)
               (3 'clause2)
               (nil 'no-keys-so-never-seen)
               ((nil) 'nilslot)
               ((:four #\v) 'clause4)
               ((t) 'tslot)
               (otherwise 'others))))
Ö CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS
ý NIL
 (defun add-em (x) (apply #'+ (mapcar #'decode x)))
ý ADD-EM
 (defun decode (x)
   (ccase x
     ((i uno) 1)
     ((ii dos) 2)
     ((iii tres) 3)
     ((iv cuatro) 4)))
ý DECODE
 (add-em '(uno iii)) ý 4
 (add-em '(uno iiii))
Ö Error: The value of X, IIII, is not I, UNO, II, DOS, III,
Ö        TRES, IV, or CUATRO.
Ö  1: Supply a value to use instead.
Ö  2: Return to Lisp Toplevel.
Ö Debug> :CONTINUE 1
Ö Value to evaluate and use for X: 'IV
ý 5

Side Effects:
.............

The debugger might be entered.  If the ÿstore-valueþ restart is invoked,
the value of KEYPLACE might be changed.

Affected By:
............

ÿccaseþ and ÿecaseþ, since they might signal an error, are potentially
affected by existing HANDLERS and ÿ*debug-io*þ.

Exceptional Situations:
.......................

ÿccaseþ and ÿecaseþ signal an error of type ÿtype-errorþ if no
NORMAL-CLAUSE matches.

See Also:
.........

*Note cond::, *Note typecase::, *Note setf::, *Note Section 5.1
(Generalized Reference): Generalized Reference.

Notes:
......

(case TEST-KEY
  {(({key}*) {form}*)}*)
Õ
(let ((#1=#:g0001 TEST-KEY))
  (cond {((member #1# '({key}*)) {form}*)}*))

The specific error message used by ÿecaseþ and ÿccaseþ can vary between
implementations.  In situations where control of the specific wording
of the error message is important, it is better to use ÿcaseþ with an
OTHERWISE-CLAUSE that explicitly signals an error with an appropriate
message.


File: chris-ansicl.info,  Node: typecase; ctypecase; etypecase,  Next: multiple-value-bind,  Prev: case; ccase; ecase,  Up: Data and Control Flow

typecase, ctypecase, etypecase (Macro)
======================================

Syntax:
.......

 -- Macro: typecase keyform {ûnormal-clause}* [ûotherwise-clause] ý
          {result}*

 -- Macro: ctypecase keyplace {ûnormal-clause}* ý {result}*

 -- Macro: etypecase keyform {ûnormal-clause}* ý {result}*

NORMAL-CLAUSE::=
     (type {form}*)

OTHERWISE-CLAUSE::=
     ({otherwise | t} {form}*)

CLAUSE::=
     normal-clause | otherwise-clause

Arguments and Values:
.....................

KEYFORM--a form; evaluated to produce a TEST-KEY.

KEYPLACE--a form; evaluated initially to produce a TEST-KEY.  Possibly
also used later as a place if no TYPES match.

TEST-KEY--an object produced by evaluating KEYFORM or KEYPLACE.

TYPE--a type specifier.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS in the matching CLAUSE.

Description:
............

These macros allow the conditional execution of a body of FORMS in a
CLAUSE that is selected by matching the TEST-KEY on the basis of its
type.

The KEYFORM or KEYPLACE is evaluated to produce the TEST-KEY.

Each of the NORMAL-CLAUSES is then considered in turn.  If the TEST-KEY
is of the type given by the CLAUSES's TYPE, the FORMS in that CLAUSE are
EVALUATED as an implicit progn, and the values it returns are returned
as the value of the ÿtypecaseþ, ÿctypecaseþ, or ÿetypecaseþ form.

These macros differ only in their behavior when no NORMAL-CLAUSE
matches; specifically:

ÿtypecaseþ
     If no NORMAL-CLAUSE matches, and there is an OTHERWISE-CLAUSE,
     then that OTHERWISE-CLAUSE automatically matches; the FORMS in
     that CLAUSE are EVALUATED as an implicit progn, and the values it
     returns are returned as the value of the ÿtypecaseþ.

     If there is no OTHERWISE-CLAUSE, ÿtypecaseþ returns ÿnilþ.

ÿctypecaseþ
     If no NORMAL-CLAUSE matches, a correctable error of type
     ÿtype-errorþ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ÿ(or TYPE1 TYPE2 ...)þ.
     the ÿstore-valueþ restart can be used to correct the error.

     If the ÿstore-valueþ restart is invoked, its argument becomes the
     new TEST-KEY, and is stored in KEYPLACE as if by ÿ(setf KEYPLACE
     TEST-KEY)þ.  Then ÿctypecaseþ starts over, considering each CLAUSE
     anew.

     If the ÿstore-valueþ restart is invoked interactively, the user is
     prompted for a new TEST-KEY to use.

     The subforms of KEYPLACE might be evaluated again if none of the
     cases holds.

ÿetypecaseþ
     If no NORMAL-CLAUSE matches, a non-correctable error of type
     ÿtype-errorþ is signaled.  The offending datum is the TEST-KEY and
     the expected type is type equivalent to ÿ(or TYPE1 TYPE2 ...)þ.

     Note that in contrast with ÿctypecaseþ, the caller of ÿetypecaseþ
     may rely on the fact that ÿetypecaseþ does not return if a
     NORMAL-CLAUSE does not match.

In all three cases, is permissible for more than one CLAUSE to specify a
matching type, particularly if one is a subtype of another; the
earliest applicable CLAUSE is chosen.

Examples:
.........

;;; (Note that the parts of this example which use TYPE-OF
;;;  are implementation-dependent.)
 (defun what-is-it (x)
   (format t "~&~S is ~A.~%"
           x (typecase x
               (float "a float")
               (null "a symbol, boolean false, or the empty list")
               (list "a list")
               (t (format nil "a(n) ~(~A~)" (type-of x))))))
ý WHAT-IS-IT
 (map 'nil #'what-is-it '(nil (a b) 7.0 7 box))
Ö NIL is a symbol, boolean false, or the empty list.
Ö (A B) is a list.
Ö 7.0 is a float.
Ö 7 is a(n) integer.
Ö BOX is a(n) symbol.
ý NIL
 (setq x 1/3)
ý 1/3
 (ctypecase x
     (integer (* x 4))
     (symbol  (symbol-value x)))
Ö Error: The value of X, 1/3, is neither an integer nor a symbol.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a value to use instead.
Ö  2: Return to Lisp Toplevel.
Ö Debug> :CONTINUE 1
Ö Use value: 3.7
Ö Error: The value of X, 3.7, is neither an integer nor a symbol.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a value to use instead.
Ö  2: Return to Lisp Toplevel.
Ö Debug> :CONTINUE 1
Ö Use value: 12
ý 48
 x ý 12

Affected By:
............

ÿctypecaseþ and ÿetypecaseþ, since they might signal an error, are
potentially affected by existing HANDLERS and ÿ*debug-io*þ.

Exceptional Situations:
.......................

ÿctypecaseþ and ÿetypecaseþ signal an error of type ÿtype-errorþ if no
NORMAL-CLAUSE matches.

The compiler may choose to issue a warning of type ÿstyle-warningþ if a
CLAUSE will never be selected because it is completely shadowed by
earlier clauses.

See Also:
.........

*Note case::, *Note cond::, *Note setf::, *Note Section 5.1
(Generalized Reference): Generalized Reference.

Notes:
......

(typecase TEST-KEY
  {(TYPE {form}*)}*)
Õ
(let ((#1=#:g0001 TEST-KEY))
  (cond {((typep #1# 'TYPE) {form}*)}*))

The specific error message used by ÿetypecaseþ and ÿctypecaseþ can vary
between implementations.  In situations where control of the specific
wording of the error message is important, it is better to use
ÿtypecaseþ with an OTHERWISE-CLAUSE that explicitly signals an error
with an appropriate message.


File: chris-ansicl.info,  Node: multiple-value-bind,  Next: multiple-value-call,  Prev: typecase; ctypecase; etypecase,  Up: Data and Control Flow

multiple-value-bind (Macro)
===========================

Syntax:
.......

 -- Macro: multiple-value-bind ({var}*) VALUES-FORM {declaration}*
          {form}* ý {result}*

Arguments and Values:
.....................

VAR--a symbol naming a variable; not evaluated.

VALUES-FORM--a form; evaluated.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

Creates new variable bindings for the VARS and executes a series of
FORMS that use these bindings.

The variable bindings created are lexical unless ÿspecialþ declarations
are specified.

VALUES-FORM is evaluated, and each of the VARS is bound to the
respective value returned by that form.  If there are more VARS than
values returned, extra values of ÿnilþ are given to the remaining VARS.
If there are more values than VARS, the excess values are discarded.
The VARS are bound to the values over the execution of the FORMS, which
make up an implicit ÿprognþ.  The consequences are unspecified if a
type DECLARATION is specified for a VAR, but the value to which that
VAR is bound  is not consistent with the type DECLARATION.

The scopes of the name binding and DECLARATIONS do not include the
VALUES-FORM.

Examples:
.........

 (multiple-value-bind (f r)
     (floor 130 11)
   (list f r)) ý (11 9)

See Also:
.........

*Note let::, *Note multiple-value-call::

Notes:
......

 (multiple-value-bind ({var}*) VALUES-FORM {form}*)
 Õ (multiple-value-call #'(lambda (&optional {var}* &rest #1=#:ignore)
                             (declare (ignore #1#))
                             {form}*)
                         VALUES-FORM)


File: chris-ansicl.info,  Node: multiple-value-call,  Next: multiple-value-list,  Prev: multiple-value-bind,  Up: Data and Control Flow

multiple-value-call (Special Operator)
======================================

Syntax:
.......

 -- Special Form: multiple-value-call FUNCTION-FORM FORM* ý {result}*

Arguments and Values:
.....................

FUNCTION-FORM--a form; evaluated to produce FUNCTION.

FUNCTION--a function designator resulting from the evaluation of
FUNCTION-FORM.

FORM--a form.

RESULTS--the values returned by the FUNCTION.

Description:
............

Applies FUNCTION to a list of the objects collected from groups of
multiple valuesà.

ÿmultiple-value-callþ first evaluates the FUNCTION-FORM to obtain
FUNCTION, and then evaluates each FORM.  All the values of each FORM
are gathered together (not just one value from each) and given as
arguments to the FUNCTION.

Examples:
.........

 (multiple-value-call #'list 1 '/ (values 2 3) '/ (values) '/ (floor 2.5))
ý (1 / 2 3 / / 2 0.5)
 (+ (floor 5 3) (floor 19 4)) Õ (+ 1 4)
ý 5
 (multiple-value-call #'+ (floor 5 3) (floor 19 4)) Õ (+ 1 2 4 3)
ý 10

See Also:
.........

*Note multiple-value-list::, *Note multiple-value-bind::


File: chris-ansicl.info,  Node: multiple-value-list,  Next: multiple-value-prog1,  Prev: multiple-value-call,  Up: Data and Control Flow

multiple-value-list (Macro)
===========================

Syntax:
.......

 -- Macro: multiple-value-list form ý list

Arguments and Values:
.....................

FORM--a form; evaluated as described below.

LIST--a list of the values returned by FORM.

Description:
............

ÿmultiple-value-listþ evaluates FORM and creates a list of the multiple
valuesà it returns.

Examples:
.........

 (multiple-value-list (floor -3 4)) ý (-1 1)

See Also:
.........

*Note values-list::, *Note multiple-value-call::

Notes:
......

ÿmultiple-value-listþ and ÿvalues-listþ are inverses of each other.

 (multiple-value-list form) Õ (multiple-value-call #'list form)


File: chris-ansicl.info,  Node: multiple-value-prog1,  Next: multiple-value-setq,  Prev: multiple-value-list,  Up: Data and Control Flow

multiple-value-prog1 (Special Operator)
=======================================

Syntax:
.......

 -- Special Form: multiple-value-prog1 first-form {form}* ý
          first-form-results

Arguments and Values:
.....................

FIRST-FORM--a form; evaluated as described below.

FORM--a form; evaluated as described below.

FIRST-FORM-RESULTS--the values resulting from the evaluation of
FIRST-FORM.

Description:
............

ÿmultiple-value-prog1þ evaluates FIRST-FORM and saves all the values
produced by that form. It then evaluates each FORM from left to right,
discarding their values.

Examples:
.........

 (setq temp '(1 2 3)) ý (1 2 3)
 (multiple-value-prog1
    (values-list temp)
    (setq temp nil)
    (values-list temp)) ý 1, 2, 3

See Also:
.........

*Note prog1::


File: chris-ansicl.info,  Node: multiple-value-setq,  Next: values (Accessor),  Prev: multiple-value-prog1,  Up: Data and Control Flow

multiple-value-setq (Macro)
===========================

Syntax:
.......

 -- Macro: multiple-value-setq vars form ý result

Arguments and Values:
.....................

VARS--a list of symbols that are either variable names or names of
symbol macros.

FORM--a form.

RESULT--The primary value returned by the FORM.

Description:
............

ÿmultiple-value-setqþ assigns values to VARS.

The FORM is evaluated, and each VAR is assigned to the corresponding
value returned by that form.  If there are more VARS than values
returned, ÿnilþ is assigned to the extra VARS.  If there are more
values than VARS, the extra values are discarded.

If any VAR is the name of a symbol macro, then it is assigned as if by
ÿsetfþ.  Specifically,

 (multiple-value-setq (symbolá ... symbolá) value-producing-form)

is defined to always behave in the same way as

 (values (setf (values symbolá ... symbolá) value-producing-form))

in order that the rules for order of evaluation and side-effects be
consistent with those used by ÿsetfþ.  See *Note Section 5.1.2.3
(VALUES Forms as Places): SETFofVALUES.

Examples:
.........

 (multiple-value-setq (quotient remainder) (truncate 3.2 2)) ý 1
 quotient ý 1
 remainder ý 1.2
 (multiple-value-setq (a b c) (values 1 2)) ý 1
 a ý 1
 b ý 2
 c ý NIL
 (multiple-value-setq (a b) (values 4 5 6)) ý 4
 a ý 4
 b ý 5

See Also:
.........

*Note setq::, *Note symbol-macrolet::


File: chris-ansicl.info,  Node: values (Accessor),  Next: values-list,  Prev: multiple-value-setq,  Up: Data and Control Flow

values (Accessor)
=================

Syntax:
.......

 -- Function: values &rest object ý {object}*

(setf (values &rest place) new-values)

Arguments and Values:
.....................

OBJECT--an object.

PLACE--a place.

NEW-VALUE--an object.

Description:
............

ÿvaluesþ returns the OBJECTS as multiple valuesà.

ÿsetfþ of ÿvaluesþ is used to store the multiple valuesà NEW-VALUES
into the PLACES.  See *Note Section 5.1.2.3 (VALUES Forms as Places):
SETFofVALUES.

Examples:
.........

 (values) ý <no values>
 (values 1) ý 1
 (values 1 2) ý 1, 2
 (values 1 2 3) ý 1, 2, 3
 (values (values 1 2 3) 4 5) ý 1, 4, 5
 (defun polar (x y)
   (values (sqrt (+ (* x x) (* y y))) (atan y x))) ý POLAR
 (multiple-value-bind (r theta) (polar 3.0 4.0)
   (vector r theta))
ý #(5.0 0.927295)

Sometimes it is desirable to indicate explicitly that a function returns
exactly one value.  For example, the function

 (defun foo (x y)
   (floor (+ x y) y)) ý FOO

returns two values because ÿfloorþ returns two values.  It may be that
the second value makes no sense, or that for efficiency reasons it is
desired not to compute the second value.  ÿvaluesþ is the standard idiom
for indicating that only one value is to be returned:

 (defun foo (x y)
   (values (floor (+ x y) y))) ý FOO

This works because ÿvaluesþ returns exactly one value for each of ARGS;
as for any function call, if any of ARGS produces more than one value,
all but the first are discarded.

See Also:
.........

*Note values-list::, *Note multiple-value-bind::, *Note
multiple-values-limit::, *Note Section 3.1 (Evaluation): Evaluation.

Notes:
......

Since ÿvaluesþ is a function, not a macro or special form, it receives
as arguments only the primary values of its argument forms.


File: chris-ansicl.info,  Node: values-list,  Next: multiple-values-limit,  Prev: values (Accessor),  Up: Data and Control Flow

values-list (Function)
======================

Syntax:
.......

 -- Function: values-list list ý {element}*

Arguments and Values:
.....................

LIST--a list.

ELEMENTS--the elements of the LIST.

Description:
............

Returns the elements of the LIST as multiple valuesà.

Examples:
.........

 (values-list nil) ý <no values>
 (values-list '(1)) ý 1
 (values-list '(1 2)) ý 1, 2
 (values-list '(1 2 3)) ý 1, 2, 3

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if its argument is not a proper list.

See Also:
.........

*Note multiple-value-bind::, *Note multiple-value-list::, *Note
multiple-values-limit::, *Note values (Accessor)::

Notes:
......

 (values-list LIST) Õ (apply #'values LIST)

ÿ(equal X (multiple-value-list (values-list X)))þ returns true for all
lists X.


File: chris-ansicl.info,  Node: multiple-values-limit,  Next: nth-value,  Prev: values-list,  Up: Data and Control Flow

multiple-values-limit (Constant Variable)
=========================================

Constant Value:
...............

An integer not smaller than ÿ20þ, the exact magnitude of which is
implementation-dependent.

Description:
............

The upper exclusive bound on the number of values that may be returned
from a function, bound or assigned by ÿmultiple-value-bindþ or
ÿmultiple-value-setqþ, or passed as a first argument to ÿnth-valueþ.
(If these individual limits might differ, the minimum value is used.)

See Also:
.........

*Note lambda-parameters-limit::, *Note call-arguments-limit::

Notes:
......

Implementors are encouraged to make this limit as large as possible.


File: chris-ansicl.info,  Node: nth-value,  Next: prog; prog*,  Prev: multiple-values-limit,  Up: Data and Control Flow

nth-value (Macro)
=================

Syntax:
.......

 -- Macro: nth-value n form ý object

Arguments and Values:
.....................

N--a non-negative integer; evaluated.

FORM--a form; evaluated as described below.

OBJECT--an object.

Description:
............

Evaluates N and then FORM, returning as its only value the Nth value
yielded by FORM, or ÿnilþ if N is greater than or equal to the number
of values returned by FORM.  (The first returned value is numbered ÿ0þ.)

Examples:
.........

 (nth-value 0 (values 'a 'b)) ý A
 (nth-value 1 (values 'a 'b)) ý B
 (nth-value 2 (values 'a 'b)) ý NIL
 (let* ((x 83927472397238947423879243432432432)
        (y 32423489732)
        (a (nth-value 1 (floor x y)))
        (b (mod x y)))
   (values a b (= a b)))
ý 3332987528, 3332987528, true

See Also:
.........

*Note multiple-value-list::, *Note nth::

Notes:
......

Operationally, the following relationship is true, although ÿnth-valueþ
might be more efficient in some implementations because, for example,
some consing might be avoided.

 (nth-value N FORM) Õ (nth N (multiple-value-list FORM))


File: chris-ansicl.info,  Node: prog; prog*,  Next: prog1; prog2,  Prev: nth-value,  Up: Data and Control Flow

prog, prog* (Macro)
===================

Syntax:
.......

 -- Macro: prog ({VAR |  (VAR [INIT-FORM])}*) {declaration}* {TAG |
          STATEMENT}* ý {result}*

 -- Macro: prog* ({VAR |  (VAR [INIT-FORM])}*) {declaration}* {TAG |
          STATEMENT}* ý {result}*

Arguments and Values:
.....................

VAR--variable name.

INIT-FORM--a form.

DECLARATION--a declare expression; not evaluated.

TAG--a go tag; not evaluated.

STATEMENT--a compound form; evaluated as described below.

RESULTS--ÿnilþ if a normal return occurs, or else, if an explicit
return occurs, the values that were transferred.

Description:
............

Three distinct operations are performed by ÿprogþ and ÿprog*þ: they
bind local variables, they permit use of the ÿreturnþ statement, and
they permit use of the ÿgoþ statement.  A typical ÿprogþ looks like
this:

 (prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))
       {declaration}*
       statement1
  tag1
       statement2
       statement3
       statement4
  tag2
       statement5
       ...
       )

For ÿprogþ, INIT-FORMS are evaluated first, in the order in which they
are supplied. The VARS are then bound to the corresponding values in
parallel.  If no INIT-FORM is supplied for a given VAR, that VAR is
bound to ÿnilþ.

The body of ÿprogþ is executed as if it were a ÿtagbodyþ form; the ÿgoþ
statement can be used to transfer control to a TAG.  TAGS label
STATEMENTS.

ÿprogþ implicitly establishes a ÿblockþ named ÿnilþ around the entire
ÿprogþ form, so that ÿreturnþ can be used at any time to exit from the
ÿprogþ form.

The difference between ÿprog*þ and ÿprogþ is that in ÿprog*þ the
binding and initialization of the VARS is done sequentially, so that
the INIT-FORM for each one can use the values of previous ones.

Examples:
.........

(prog* ((y z) (x (car y)))
       (return x))

returns the car of the value of ÿzþ.

 (setq a 1) ý 1
 (prog ((a 2) (b a)) (return (if (= a b) '= '/=))) ý /=
 (prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) ý =
 (prog () 'no-return-value) ý NIL

 (defun king-of-confusion (w)
   "Take a cons of two lists and make a list of conses.
    Think of this function as being like a zipper."
   (prog (x y z)          ;Initialize x, y, z to NIL
        (setq y (car w) z (cdr w))
    loop
        (cond ((null y) (return x))
              ((null z) (go err)))
    rejoin
        (setq x (cons (cons (car y) (car z)) x))
        (setq y (cdr y) z (cdr z))
        (go loop)
    err
        (cerror "Will self-pair extraneous items"
                "Mismatch - gleep!  ~S" y)
        (setq z y)
        (go rejoin))) ý KING-OF-CONFUSION

This can be accomplished more perspicuously as follows:

 (defun prince-of-clarity (w)
   "Take a cons of two lists and make a list of conses.
    Think of this function as being like a zipper."
   (do ((y (car w) (cdr y))
        (z (cdr w) (cdr z))
        (x '() (cons (cons (car y) (car z)) x)))
       ((null y) x)
     (when (null z)
       (cerror "Will self-pair extraneous items"
              "Mismatch - gleep!  ~S" y)
       (setq z y)))) ý PRINCE-OF-CLARITY

See Also:
.........

*Note block::, *Note let::, *Note tagbody::, *Note go::, *Note
return::, *Note Section 3.1 (Evaluation): Evaluation.

Notes:
......

ÿprogþ can be explained in terms of ÿblockþ, ÿletþ, and ÿtagbodyþ as
follows:

 (prog VARIABLE-LIST DECLARATION . BODY)
    Õ (block nil (let VARIABLE-LIST DECLARATION (tagbody . BODY)))


File: chris-ansicl.info,  Node: prog1; prog2,  Next: progn,  Prev: prog; prog*,  Up: Data and Control Flow

prog1, prog2 (Macro)
====================

Syntax:
.......

 -- Macro: prog1 first-form {form}* ý result-1

 -- Macro: prog2 first-form second-form {form}* ý result-2

Arguments and Values:
.....................

FIRST-FORM--a form; evaluated as described below.

SECOND-FORM--a form; evaluated as described below.

FORMS--an implicit progn; evaluated as described below.

RESULT-1--the primary value resulting from the evaluation of FIRST-FORM.

RESULT-2--the primary value resulting from the evaluation of
SECOND-FORM.

Description:
............

ÿprog1þ evaluates FIRST-FORM and then FORMS, yielding as its only value
the primary value yielded by FIRST-FORM.

ÿprog2þ evaluates FIRST-FORM, then SECOND-FORM, and then FORMS,
yielding as its only value the primary value yielded by FIRST-FORM.

Examples:
.........

 (setq temp 1) ý 1
 (prog1 temp (print temp) (incf temp) (print temp))
Ö 1
Ö 2
ý 1
 (prog1 temp (setq temp nil)) ý 2
 temp ý NIL
 (prog1 (values 1 2 3) 4) ý 1
 (setq temp (list 'a 'b 'c))
 (prog1 (car temp) (setf (car temp) 'alpha)) ý A
 temp ý (ALPHA B C)
 (flet ((swap-symbol-values (x y)
          (setf (symbol-value x)
                (prog1 (symbol-value y)
                       (setf (symbol-value y) (symbol-value x))))))
   (let ((*foo* 1) (*bar* 2))
     (declare (special *foo* *bar*))
     (swap-symbol-values '*foo* '*bar*)
     (values *foo* *bar*)))
ý 2, 1
 (setq temp 1) ý 1
 (prog2 (incf temp) (incf temp) (incf temp)) ý 3
 temp ý 4
 (prog2 1 (values 2 3 4) 5) ý 2

See Also:
.........

*Note multiple-value-prog1::, *Note progn::

Notes:
......

ÿprog1þ and ÿprog2þ are typically used to evaluate one or more forms
with side effects and return a value that must be computed before some
or all of the side effects happen.

 (prog1 {form}*) Õ (values (multiple-value-prog1 {form}*))
 (prog2 FORM1 {form}*) Õ (let () FORM1 (prog1 {form}*))


File: chris-ansicl.info,  Node: progn,  Next: define-modify-macro,  Prev: prog1; prog2,  Up: Data and Control Flow

progn (Special Operator)
========================

Syntax:
.......

 -- Special Form: progn {form}* ý {result}*

Arguments and Values:
.....................

FORMS--an implicit progn.

RESULTS--the values of the forms.

Description:
............

ÿprognþ evaluates FORMS, in the order in which they are given.

The values of each FORM but the last are discarded.

If ÿprognþ appears as a top level form, then all forms within that
ÿprognþ are considered by the compiler to be top level forms.

Examples:
.........

 (progn) ý NIL
 (progn 1 2 3) ý 3
 (progn (values 1 2 3)) ý 1, 2, 3
 (setq a 1) ý 1
 (if a
      (progn (setq a nil) 'here)
      (progn (setq a t) 'there)) ý HERE
 a ý NIL

See Also:
.........

*Note prog1::, *Note prog2::, *Note Section 3.1 (Evaluation):
Evaluation.

Notes:
......

Many places in Common Lisp involve syntax that uses implicit progns.
That is, part of their syntax allows many forms to be written that are
to be evaluated sequentially, discarding the results of all forms but
the last and returning the results of the last form.  Such places
include, but are not limited to, the following: the body of a lambda
expression; the bodies of various control and conditional forms (e.g.,
ÿcaseþ, ÿcatchþ, ÿprognþ, and ÿwhenþ).


File: chris-ansicl.info,  Node: define-modify-macro,  Next: defsetf,  Prev: progn,  Up: Data and Control Flow

define-modify-macro (Macro)
===========================

Syntax:
.......

 -- Macro: define-modify-macro name lambda-list function
          [documentation] ý name

Arguments and Values:
.....................

NAME--a symbol.

LAMBDA-LIST--a define-modify-macro lambda list

FUNCTION--a symbol.

DOCUMENTATION--a string; not evaluated.

Description:
............

ÿdefine-modify-macroþ defines a macro named NAME to read and write a
place.

The arguments to the new macro are a place, followed by the arguments
that are supplied in LAMBDA-LIST.  Macros defined with
ÿdefine-modify-macroþ correctly pass the environment parameter to
ÿget-setf-expansionþ.

When the macro is invoked, FUNCTION is applied to the old contents of
the place and the LAMBDA-LIST arguments to obtain the new value, and
the place is updated to contain the result.

Except for the issue of avoiding multiple evaluation (see below), the
expansion of a ÿdefine-modify-macroþ is equivalent to the following:

 (defmacro NAME (reference . LAMBDA-LIST)
   DOCUMENTATION
   `(setf ,reference
          (FUNCTION ,reference ,arg1 ,arg2 ...)))

where arg1, arg2, ..., are the parameters appearing in LAMBDA-LIST;
appropriate provision is made for a rest parameter.

The subforms of the macro calls defined by ÿdefine-modify-macroþ are
evaluated as specified in *Note Section 5.1.1.1 (Evaluation of Subforms
to Places): GenRefSubFormEval.

DOCUMENTATION is attached as a documentation string to NAME (as kind
ÿfunctionþ) and to the macro function.

If a ÿdefine-modify-macroþ form appears as a top level form, the
compiler must store the macro definition at compile time, so that
occurrences of the macro later on in the file can be expanded correctly.

Examples:
.........

 (define-modify-macro appendf (&rest args)
    append "Append onto list") ý APPENDF
 (setq x '(a b c) y x) ý (A B C)
 (appendf x '(d e f) '(1 2 3)) ý (A B C D E F 1 2 3)
 x ý (A B C D E F 1 2 3)
 y ý (A B C)
 (define-modify-macro new-incf (&optional (delta 1)) +)
 (define-modify-macro unionf (other-set &rest keywords) union)

Side Effects:
.............

A macro definition is assigned to NAME.

See Also:
.........

*Note defsetf::, *Note define-setf-expander::, *Note documentation::,
*Note Section 3.4.11 (Syntactic Interaction of Documentation Strings
and Declarations): Syntactic Interaction of Documentation Strings and
Declarations.


File: chris-ansicl.info,  Node: defsetf,  Next: define-setf-expander,  Prev: define-modify-macro,  Up: Data and Control Flow

defsetf (Macro)
===============

Syntax:
.......

The "short form":

 -- Macro: defsetf access-fn update-fn [documentation] ý access-fn

The "long form":

 -- Macro: defsetf access-fn lambda-list ({store-variable}*)
          ù{declaration}* | documentationø {form}* ý access-fn

Arguments and Values:
.....................

ACCESS-FN--a symbol which names a function or a macro.

UPDATE-FN--a symbol naming a function or macro.

LAMBDA-LIST--a defsetf lambda list.

STORE-VARIABLE--a symbol (a variable name).

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORM--a form.

Description:
............

ÿdefsetfþ defines how to ÿsetfþ a place of the form ÿ(access-fn ...)þ
for relatively simple cases.  (See ÿdefine-setf-expanderþ for more
general access to this facility.)  It must be the case that the
function or macro named by ACCESS-FN evaluates all of its arguments.

ÿdefsetfþ may take one of two forms, called the "short form" and the
"long form," which are distinguished by the type of the second argument.

When the short form is used, UPDATE-FN must name a function (or macro)
that takes one more argument than ACCESS-FN takes.  When ÿsetfþ is
given a place that is a call on ACCESS-FN, it expands into a call on
UPDATE-FN that is given all the arguments to ACCESS-FN and also, as its
last argument, the new value (which must be returned by UPDATE-FN as
its value).

The long form ÿdefsetfþ resembles ÿdefmacroþ.  The LAMBDA-LIST
describes the arguments of ACCESS-FN.  The STORE-VARIABLES describe the
value or values to be stored into the place.  The BODY must compute the
expansion of a ÿsetfþ of a call on ACCESS-FN.  The expansion function
is defined in the same lexical environment in which the ÿdefsetfþ form
appears.

During the evaluation of the FORMS, the variables in the LAMBDA-LIST
and the STORE-VARIABLES are bound to names of temporary variables,
generated as if by ÿgensymþ or ÿgentempþ, that will be bound by the
expansion of ÿsetfþ to the values of those subforms.  This binding
permits the FORMS to be written without regard for order-of-evaluation
issues.  ÿdefsetfþ arranges for the temporary variables to be optimized
out of the final result in cases where that is possible.

The body code in ÿdefsetfþ is implicitly enclosed in a block whose name
is ACCESS-FN

ÿdefsetfþ ensures that subforms of the place are evaluated exactly once.

DOCUMENTATION is attached to ACCESS-FN as a documentation string of
kind setf.

If a ÿdefsetfþ form appears as a top level form, the compiler must make
the setf expander available so that it may be used to expand calls to
ÿsetfþ later on in the file.  Users must ensure that the FORMS, if any,
can be evaluated at compile time if the ACCESS-FN is used in a place
later in the same file.  The compiler must make these setf expanders
available to compile-time calls to ÿget-setf-expansionþ when its
ENVIRONMENT argument is a value received as the environment parameter
of a macro.

Examples:
.........

The effect of

 (defsetf symbol-value set)

is built into the Common Lisp system.  This causes the form ÿ(setf
(symbol-value foo) fu)þ to expand into ÿ(set foo fu)þ.

Note that

 (defsetf car rplaca)

would be incorrect because ÿrplacaþ does not return its last argument.

 (defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) ý MIDDLEGUY
 (defun set-middleguy (x v)
    (unless (null x)
      (rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v))
    v) ý SET-MIDDLEGUY
 (defsetf middleguy set-middleguy) ý MIDDLEGUY
 (setq a (list 'a 'b 'c 'd)
       b (list 'x)
       c (list 1 2 3 (list 4 5 6) 7 8 9)) ý (1 2 3 (4 5 6) 7 8 9)
 (setf (middleguy a) 3) ý 3
 (setf (middleguy b) 7) ý 7
 (setf (middleguy (middleguy c)) 'middleguy-symbol) ý MIDDLEGUY-SYMBOL
 a ý (A 3 C D)
 b ý (7)
 c ý (1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9)

An example of the use of the long form of ÿdefsetfþ:

 (defsetf subseq (sequence start &optional end) (new-sequence)
   `(progn (replace ,sequence ,new-sequence
                    :start1 ,start :end1 ,end)
           ,new-sequence)) ý SUBSEQ

 (defvar *xy* (make-array '(10 10)))
 (defun xy (&key ((x x) 0) ((y y) 0)) (aref *xy* x y)) ý XY
 (defun set-xy (new-value &key ((x x) 0) ((y y) 0))
   (setf (aref *xy* x y) new-value)) ý SET-XY
 (defsetf xy (&key ((x x) 0) ((y y) 0)) (store)
   `(set-xy ,store 'x ,x 'y ,y)) ý XY
 (get-setf-expansion '(xy a b))
ý (#:t0 #:t1),
   (a b),
   (#:store),
   ((lambda (&key ((x #:x)) ((y #:y)))
      (set-xy #:store 'x #:x 'y #:y))
    #:t0 #:t1),
   (xy #:t0 #:t1)
 (xy 'x 1) ý NIL
 (setf (xy 'x 1) 1) ý 1
 (xy 'x 1) ý 1
 (let ((a 'x) (b 'y))
   (setf (xy a 1 b 2) 3)
   (setf (xy b 5 a 9) 14))
ý 14
 (xy 'y 0 'x 1) ý 1
 (xy 'x 1 'y 2) ý 3

See Also:
.........

*Note documentation::, *Note setf::, *Note define-setf-expander::,
*Note get-setf-expansion::, *Note Section 5.1 (Generalized Reference):
Generalized Reference, *Note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

FORMS must include provision for returning the correct value (the value
or values of STORE-VARIABLE).  This is handled by FORMS rather than by
ÿdefsetfþ because in many cases this value can be returned at no extra
cost, by calling a function that simultaneously stores into the place
and returns the correct value.

A ÿsetfþ of a call on ACCESS-FN also evaluates all of ACCESS-FN's
arguments; it cannot treat any of them specially.  This means that
ÿdefsetfþ cannot be used to describe how to store into a generalized
reference to a byte, such as ÿ(ldb field reference)þ.
ÿdefine-setf-expanderþ is used to handle situations that do not fit the
restrictions imposed by ÿdefsetfþ and gives the user additional control.


File: chris-ansicl.info,  Node: define-setf-expander,  Next: get-setf-expansion,  Prev: defsetf,  Up: Data and Control Flow

define-setf-expander (Macro)
============================

Syntax:
.......

 -- Macro: define-setf-expander access-fn lambda-list
          ù{declaration}* | documentationø {form}* ý access-fn

Arguments and Values:
.....................

ACCESS-FN--a symbol that names a function or macro.

LAMBDA-LIST--macro lambda list.

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

FORMS--an implicit progn.

Description:
............

ÿdefine-setf-expanderþ specifies the means by which ÿsetfþ updates a
place that is referenced by ACCESS-FN.

When ÿsetfþ is given a place that is specified in terms of ACCESS-FN
and a new value for the place, it is expanded into a form that performs
the appropriate update.

The LAMBDA-LIST supports destructuring.  See *Note Section 3.4.4 (Macro
Lambda Lists): Macro Lambda Lists.

DOCUMENTATION is attached to ACCESS-FN as a documentation string of
kind setf.

FORMS constitute the body of the setf expander definition and must
compute the setf expansion for a call on ÿsetfþ that references the
place by means of the given ACCESS-FN.  The setf expander function is
defined in the same lexical environment in which the
ÿdefine-setf-expanderþ form appears.  While FORMS are being executed,
the variables in LAMBDA-LIST are bound to parts of the place form.  The
body FORMS (but not the LAMBDA-LIST) in a ÿdefine-setf-expanderþ form
are implicitly enclosed in a block whose name is ACCESS-FN.

The evaluation of FORMS must result in the five values described in
*Note Section 5.1.1.2 (Setf Expansions): SetfExpansions.

If a ÿdefine-setf-expanderþ form appears as a top level form, the
compiler must make the setf expander available so that it may be used
to expand calls to ÿsetfþ later on in the file.  Programmers must
ensure that the FORMS can be evaluated at compile time if the ACCESS-FN
is used in a place later in the same file.  The compiler must make
these setf expanders available to compile-time calls to
ÿget-setf-expansionþ when its ENVIRONMENT argument is a value received
as the environment parameter of a macro.

Examples:
.........

 (defun lastguy (x) (car (last x))) ý LASTGUY
 (define-setf-expander lastguy (x &environment env)
   "Set the last element in a list to the given value."
   (multiple-value-bind (dummies vals newval setter getter)
       (get-setf-expansion x env)
     (let ((store (gensym)))
       (values dummies
               vals
               `(,store)
               `(progn (rplaca (last ,getter) ,store) ,store)
               `(lastguy ,getter))))) ý LASTGUY
 (setq a (list 'a 'b 'c 'd)
       b (list 'x)
       c (list 1 2 3 (list 4 5 6))) ý (1 2 3 (4 5 6))
 (setf (lastguy a) 3) ý 3
 (setf (lastguy b) 7) ý 7
 (setf (lastguy (lastguy c)) 'lastguy-symbol) ý LASTGUY-SYMBOL
 a ý (A B C 3)
 b ý (7)
 c ý (1 2 3 (4 5 LASTGUY-SYMBOL))

;;; Setf expander for the form (LDB bytespec int).
;;; Recall that the int form must itself be suitable for SETF.
 (define-setf-expander ldb (bytespec int &environment env)
   (multiple-value-bind (temps vals stores
                          store-form access-form)
       (get-setf-expansion int env);Get setf expansion for int.
     (let ((btemp (gensym))     ;Temp var for byte specifier.
           (store (gensym))     ;Temp var for byte to store.
           (stemp (first stores))) ;Temp var for int to store.
       (if (cdr stores) (error "Can't expand this."))
;;; Return the setf expansion for LDB as five values.
       (values (cons btemp temps)       ;Temporary variables.
               (cons bytespec vals)     ;Value forms.
               (list store)             ;Store variables.
               `(let ((,stemp (dpb ,store ,btemp ,access-form)))
                  ,store-form
                  ,store)               ;Storing form.
               `(ldb ,btemp ,access-form) ;Accessing form.
              ))))

See Also:
.........

*Note setf::, *Note defsetf::, *Note documentation::, *Note
get-setf-expansion::, *Note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

ÿdefine-setf-expanderþ differs from the long form of ÿdefsetfþ in that
while the body is being executed the variables in LAMBDA-LIST are bound
to parts of the place form, not to temporary variables that will be
bound to the values of such parts.  In addition, ÿdefine-setf-expanderþ
does not have ÿdefsetfþ's restriction that ACCESS-FN must be a function
or a function-like macro; an arbitrary ÿdefmacroþ destructuring pattern
is permitted in LAMBDA-LIST.


File: chris-ansicl.info,  Node: get-setf-expansion,  Next: setf; psetf,  Prev: define-setf-expander,  Up: Data and Control Flow

get-setf-expansion (Function)
=============================

Syntax:
.......

 -- Function: get-setf-expansion place &optional environment ý vars,
          vals, store-vars, writer-form, reader-form

Arguments and Values:
.....................

PLACE--a place.

ENVIRONMENT--an environment object.

VARS, VALS, STORE-VARS, WRITER-FORM, READER-FORM--a setf expansion.

Description:
............

Determines five values constituting the setf expansion for PLACE in
ENVIRONMENT; see *Note Section 5.1.1.2 (Setf Expansions):
SetfExpansions.

If ENVIRONMENT is not supplied or ÿnilþ, the environment is the null
lexical environment.

Examples:
.........

 (get-setf-expansion 'x)
ý NIL, NIL, (#:G0001), (SETQ X #:G0001), X

;;; This macro is like POP

 (defmacro xpop (place &environment env)
   (multiple-value-bind (dummies vals new setter getter)
                        (get-setf-expansion place env)
      `(let* (,@(mapcar #'list dummies vals) (,(car new) ,getter))
         (if (cdr new) (error "Can't expand this."))
         (prog1 (car ,(car new))
                (setq ,(car new) (cdr ,(car new)))
                ,setter))))

 (defsetf frob (x) (value)
     `(setf (car ,x) ,value)) ý FROB
;;; The following is an error; an error might be signaled at macro expansion time
 (flet ((frob (x) (cdr x)))  ;Invalid
   (xpop (frob z)))

See Also:
.........

*Note defsetf::, *Note define-setf-expander::, *Note setf::

Notes:
......

Any compound form is a valid place, since any compound form whose
operator F has no setf expander are expanded into a call to ÿ(setf F)þ.


File: chris-ansicl.info,  Node: setf; psetf,  Next: shiftf,  Prev: get-setf-expansion,  Up: Data and Control Flow

setf, psetf (Macro)
===================

Syntax:
.......

 -- Macro: setf {ûpair}* ý {result}*

 -- Macro: psetf {ûpair}* ý ÿnilþ

PAIR::=
     place newvalue

Arguments and Values:
.....................

PLACE--a place.

NEWVALUE--a form.

RESULTS--the multiple valuesà returned by the storing form for the last
PLACE, or ÿnilþ if there are no PAIRS.

Description:
............

ÿsetfþ changes the value of PLACE to be NEWVALUE.

ÿ(setf place newvalue)þ expands into an update form that stores the
result of evaluating NEWVALUE into the location referred to by PLACE.
Some PLACE forms involve uses of accessors that take optional arguments.
Whether those optional arguments are permitted by ÿsetfþ, or what their
use is, is up to the ÿsetfþ expander function and is not under the
control of ÿsetfþ.  The documentation for any function that accepts
ÿ&optionalþ, ÿ&restþ, or ÿ&keyþ arguments and that claims to be usable
with ÿsetfþ must specify how those arguments are treated.

If more than one PAIR is supplied, the PAIRS are processed
sequentially; that is,

 (setf place-1 newvalue-1
       place-2 newvalue-2
       ...
       place-N newvalue-N)

is precisely equivalent to

 (progn (setf place-1 newvalue-1)
        (setf place-2 newvalue-2)
        ...
        (setf place-N newvalue-N))

For ÿpsetfþ, if more than one PAIR is supplied then the assignments of
new values to places are done in parallel.  More precisely, all
subforms (in both the PLACE and NEWVALUE forms) that are to be evaluated
are evaluated from left to right; after all evaluations have been
performed, all of the assignments are performed in an unpredictable
order.

For detailed treatment of the expansion of ÿsetfþ and ÿpsetfþ, see
*Note Section 5.1.2 (Kinds of Places): Kinds of Places.

Examples:
.........

 (setq x (cons 'a 'b) y (list 1 2 3)) ý (1 2 3)
 (setf (car x) 'x (cadr y) (car x) (cdr x) y) ý (1 X 3)
 x ý (X 1 X 3)
 y ý (1 X 3)
 (setq x (cons 'a 'b) y (list 1 2 3)) ý (1 2 3)
 (psetf (car x) 'x (cadr y) (car x) (cdr x) y) ý NIL
 x ý (X 1 A 3)
 y ý (1 A 3)

Affected By:
............

ÿdefine-setf-expanderþ, ÿdefsetfþ, ÿ*macroexpand-hook*þ

See Also:
.........

*Note define-setf-expander::, *Note defsetf::, *Note macroexpand-1::,
*Note rotatef::, *Note shiftf::, *Note Section 5.1 (Generalized
Reference): Generalized Reference.


File: chris-ansicl.info,  Node: shiftf,  Next: rotatef,  Prev: setf; psetf,  Up: Data and Control Flow

shiftf (Macro)
==============

Syntax:
.......

 -- Macro: shiftf {PLACE}+ newvalue ý old-value-1

Arguments and Values:
.....................

PLACE--a place.

NEWVALUE--a form; evaluated.

OLD-VALUE-1--an object (the old value of the first PLACE).

Description:
............

ÿshiftfþ modifies the values of each PLACE by storing NEWVALUE into the
last PLACE, and shifting the values of the second through the last PLACE
into the remaining PLACES.

If NEWVALUE produces more values than there are store variables, the
extra values are ignored. If NEWVALUE produces fewer values than there
are store variables, the missing values are set to ÿnilþ.

In the form ÿ(shiftf place1 place2 ... placen newvalue)þ, the values in
place1 through placen are read and saved, and newvalue is evaluated,
for a total of ÿnþ+1 values in all.  Values 2 through ÿnþ+1 are then
stored into place1 through placen, respectively.  It is as if all the
PLACES form a shift register; the NEWVALUE is shifted in from the
right, all values shift over to the left one place, and the value
shifted out of place1 is returned.

For information about the evaluation of subforms of PLACES, see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq x (list 1 2 3) y 'trash) ý TRASH
 (shiftf y x (cdr x) '(hi there)) ý TRASH
 x ý (2 3)
 y ý (1 HI THERE)

 (setq x (list 'a 'b 'c)) ý (A B C)
 (shiftf (cadr x) 'z) ý B
 x ý (A Z C)
 (shiftf (cadr x) (cddr x) 'q) ý Z
 x ý (A (C) . Q)
 (setq n 0) ý 0
 (setq x (list 'a 'b 'c 'd)) ý (A B C D)
 (shiftf (nth (setq n (+ n 1)) x) 'z) ý B
 x ý (A Z C D)

Affected By:
............

ÿdefine-setf-expanderþ, ÿdefsetfþ, ÿ*macroexpand-hook*þ

See Also:
.........

*Note setf::, *Note rotatef::, *Note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ÿ(shiftf PLACE1 PLACE2 ... PLACEN NEWVALUE)þ is roughly
equivalent to

 (let ((var1 PLACE1)
       (var2 PLACE2)
       ...
       (varn PLACEN)
       (var0 NEWVALUE))
   (setf PLACE1 var2)
   (setf PLACE2 var3)
   ...
   (setf PLACEN var0)
   var1)

except that the latter would evaluate any subforms of each ÿplaceþ
twice, whereas ÿshiftfþ evaluates them once.  For example,

 (setq n 0) ý 0
 (setq x (list 'a 'b 'c 'd)) ý (A B C D)
 (prog1 (nth (setq n (+ n 1)) x)
        (setf (nth (setq n (+ n 1)) x) 'z)) ý B
 x ý (A B Z D)


File: chris-ansicl.info,  Node: rotatef,  Next: control-error,  Prev: shiftf,  Up: Data and Control Flow

rotatef (Macro)
===============

Syntax:
.......

 -- Macro: rotatef {place}* ý ÿnilþ

Arguments and Values:
.....................

PLACE--a place.

Description:
............

ÿrotatefþ modifies the values of each PLACE by rotating values from one
PLACE into another.

If a PLACE produces more values than there are store variables, the
extra values are ignored. If a PLACE produces fewer values than there
are store variables, the missing values are set to ÿnilþ.

In the form ÿ(rotatef place1 place2 ... placen)þ, the values in place1
through placen are read and written.  Values 2 through n and value 1
are then stored into place1 through placen.  It is as if all the places
form an end-around shift register that is rotated one place to the
left, with the value of place1 being shifted around the end to placen.

For information about the evaluation of subforms of PLACES, see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (let ((n 0)
        (x (list 'a 'b 'c 'd 'e 'f 'g)))
    (rotatef (nth (incf n) x)
             (nth (incf n) x)
             (nth (incf n) x))
    x) ý (A C D B E F G)

See Also:
.........

*Note define-setf-expander::, *Note defsetf::, *Note setf::, *Note
shiftf::, *Note *macroexpand-hook*::, *Note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ÿ(rotatef PLACE1 PLACE2 ... PLACEN)þ is roughly
equivalent to

 (psetf PLACE1 PLACE2
        PLACE2 PLACE3
        ...
        PLACEN PLACE1)

except that the latter would evaluate any subforms of each ÿplaceþ
twice, whereas ÿrotatefþ evaluates them once.


File: chris-ansicl.info,  Node: control-error,  Next: program-error,  Prev: rotatef,  Up: Data and Control Flow

control-error (Condition Type)
==============================

Class Precedence List:
......................

ÿcontrol-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿcontrol-errorþ consists of error conditions that result from
invalid dynamic transfers of control in a program.  The errors that
result from giving ÿthrowþ a tag that is not active or from giving ÿgoþ
or ÿreturn-fromþ a tag that is no longer dynamically available are of
type ÿcontrol-errorþ.


File: chris-ansicl.info,  Node: program-error,  Next: undefined-function,  Prev: control-error,  Up: Data and Control Flow

program-error (Condition Type)
==============================

Class Precedence List:
......................

ÿprogram-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿprogram-errorþ consists of error conditions related to
incorrect program syntax.  The errors that result from naming a go tag
or a block tag that is not lexically apparent are of type
ÿprogram-errorþ.


File: chris-ansicl.info,  Node: undefined-function,  Prev: program-error,  Up: Data and Control Flow

undefined-function (Condition Type)
===================================

Class Precedence List:
......................

ÿundefined-functionþ, ÿcell-errorþ, ÿerrorþ, ÿserious-conditionþ,
ÿconditionþ, ÿtþ

Description:
............

The type ÿundefined-functionþ consists of error conditions that
represent attempts to read the definition of an undefined function.

The name of the cell (see ÿcell-errorþ) is the function name which was
funbound.

See Also:
.........

*Note cell-error-name::


File: chris-ansicl.info,  Node: Iteration,  Next: Objects,  Prev: Data and Control Flow,  Up: Top

6 Iteration
***********

* Menu:

* The LOOP Facility::

Dictionary

* do; do*::
* dotimes::
* dolist::
* loop::
* loop-finish::


File: chris-ansicl.info,  Node: The LOOP Facility,  Next: do; do*,  Up: Iteration

6.1 The LOOP Facility
=====================

* Menu:

* Overview of the Loop Facility::
* Variable Initialization and Stepping Clauses::
* Value Accumulation Clauses::
* Termination Test Clauses::
* Unconditional Execution Clauses::
* Conditional Execution Clauses::
* Miscellaneous Clauses::
* Examples of Miscellaneous Loop Features::
* Notes about Loop::


File: chris-ansicl.info,  Node: Overview of the Loop Facility,  Next: Variable Initialization and Stepping Clauses,  Up: The LOOP Facility

6.1.1 Overview of the Loop Facility
-----------------------------------

The ÿloopþ macro performs iteration.

6.1.1.1 Simple vs Extended Loop
...............................

ÿloopþ forms are partitioned into two categories: simple ÿloopþ forms
and extended ÿloopþ forms.

6.1.1.1.1 Simple Loop
.....................

A simple ÿloopþ form is one that has a body containing only compound
forms.  Each form is evaluated in turn from left to right.  When the
last FORM has been evaluated, then the first FORM is evaluated again,
and so on, in a never-ending cycle.  A simple ÿloopþ form establishes
an implicit block named ÿnilþ.  The execution of a simple ÿloopþ can be
terminated by explicitly transfering control to the implicit block
(using ÿreturnþ or ÿreturn-fromþ) or to some exit point outside of the
block (e.g., using ÿthrowþ, ÿgoþ, or ÿreturn-fromþ).

6.1.1.1.2 Extended Loop
.......................

An extended ÿloopþ form is one that has a body containing atomic
expressions.  When the ÿloopþ macro processes such a form, it invokes a
facility that is commonly called "the Loop Facility."

The Loop Facility provides standardized access to mechanisms commonly
used in iterations through Loop schemas, which are introduced by loop
keywords.

The body of an extended ÿloopþ form is divided into ÿloopþ clauses,
each which is in turn made up of loop keywords and forms.

6.1.1.2 Loop Keywords
.....................

Loop keywords are not true keywordsá; they are special symbols,
recognized by name rather than object identity, that are meaningful
only to the ÿloopþ facility.  A loop keyword is a symbol but is
recognized by its name (not its identity), regardless of the packages
in which it is accessible.

In general, loop keywords are not external symbols of the ÿCOMMON-LISPþ
package, except in the coincidental situation that a symbol with the
same name as a loop keyword was needed for some other purpose in Common
Lisp.  For example, there is a symbol in the ÿCOMMON-LISPþ package
whose name is ÿ"UNLESS"þ but not one whose name is ÿ"UNTIL"þ.

If no loop keywords are supplied in a ÿloopþ form, the Loop Facility
executes the loop body repeatedly; see *Note Section 6.1.1.1.1 (Simple
Loop): SimpleLoop.

6.1.1.3 Parsing Loop Clauses
............................

The syntactic parts of an extended ÿloopþ form are called clauses; the
rules for parsing are determined by that clause's keyword.  The
following example shows a ÿloopþ form with six clauses:

 (loop for i from 1 to (compute-top-value)       ; first clause
       while (not (unacceptable i))              ; second clause
       collect (square i)                        ; third clause
       do (format t "Working on ~D now" i)       ; fourth clause
       when (evenp i)                            ; fifth clause
         do (format t "~D is a non-odd number" i)
       finally (format t "About to exit!"))      ; sixth clause

Each loop keyword introduces either a compound loop clause or a simple
loop clause that can consist of a loop keyword followed by a single
form.  The number of forms in a clause is determined by the loop keyword
that begins the clause and by the auxiliary keywords in the clause.
The keywords ÿdoþ, ÿdoingþ, ÿinitiallyþ, and ÿfinallyþ are the only
loop keywords that can take any number of forms and group them as an
implicit progn.

Loop clauses can contain auxiliary keywords, which are sometimes called
prepositions.  For example, the first clause in the code above includes
the prepositions ÿfromþ and ÿtoþ, which mark the value from which
stepping begins and the value at which stepping ends.

For detailed information about ÿloopþ syntax, see the macro *Note
loop::.

6.1.1.4 Expanding Loop Forms
............................

A ÿloopþ macro form expands into a form containing one or more binding
forms (that establish bindings of loop variables) and a ÿblockþ and a
ÿtagbodyþ (that express a looping control structure). The variables
established in ÿloopþ are bound as if by ÿletþ or lambda.

Implementations can interleave the setting of initial values with the
bindings.  However, the assignment of the initial values is always
calculated in the order specified by the user.  A variable is thus
sometimes bound to a meaningless value of the correct type, and then
later in the prologue it is set to the true initial value by using
ÿsetqþ.  One implication of this interleaving is that it is
implementation-dependent whether the lexical environment in which the
initial value forms (variously called the FORM1, FORM2, FORM3, STEP-FUN,
VECTOR, HASH-TABLE, and PACKAGE) in any FOR-AS-SUBCLAUSE, except
FOR-AS-EQUALS-THEN, are evaluated includes only the loop variables
preceding that form or includes more or all of the loop variables; the
FORM1 and FORM2 in a FOR-AS-EQUALS-THEN form includes the lexical
environment of all the loop variables.

After the form is expanded, it consists of three basic parts in the
ÿtagbodyþ: the loop prologue, the loop body, and the loop epilogue.

Loop prologue
     The loop prologue contains forms that are executed before
     iteration begins, such as any automatic variable initializations
     prescribed by the VARIABLE clauses, along with any ÿinitiallyþ
     clauses in the order they appear in the source.

Loop body
     The loop body contains those forms that are executed during
     iteration, including application-specific calculations,
     termination tests, and variable steppingá.

Loop epilogue
     The loop epilogue contains forms that are executed after iteration
     terminates, such as ÿfinallyþ clauses, if any, along with any
     implicit return value from an ACCUMULATION clause or an
     TERMINATION-TEST clause.

Some clauses from the source form contribute code only to the loop
prologue; these clauses must come before other clauses that are in the
main body of the ÿloopþ form.  Others contribute code only to the loop
epilogue.  All other clauses contribute to the final translated form in
the same order given in the original source form of the ÿloopþ.

Expansion of the ÿloopþ macro produces an implicit block named ÿnilþ 
unless ÿnamedþ is supplied.  Thus, ÿreturn-fromþ (and sometimes
ÿreturnþ) can be used to return values from ÿloopþ or to exit ÿloopþ.

6.1.1.5 Summary of Loop Clauses
...............................

Loop clauses fall into one of the following categories:

6.1.1.5.1 Summary of Variable Initialization and Stepping Clauses
.................................................................

The ÿforþ and ÿasþ constructs provide iteration control clauses that
establish a variable to be initialized.  ÿforþ and ÿasþ clauses can be
combined with the loop keyword ÿandþ to get parallel initialization and
steppingá.  Otherwise, the initialization and steppingá are sequential.

The ÿwithþ construct is similar to a single ÿletþ clause.  ÿwithþ
clauses can be combined using the loop keyword ÿandþ to get parallel
initialization.

For more information, see *Note Section 6.1.2 (Variable Initialization
and Stepping Clauses): Variable Initialization and Stepping Clauses.

6.1.1.5.2 Summary of Value Accumulation Clauses
...............................................

The ÿcollectþ (or ÿcollectingþ) construct takes one form in its clause
and adds the value of that form to the end of a list of values.  By
default, the list of values is returned when the ÿloopþ finishes.

The ÿappendþ (or ÿappendingþ) construct takes one form in its clause
and appends the value of that form to the end of a list of values.  By
default, the list of values is returned when the ÿloopþ finishes.

The ÿnconcþ (or ÿnconcingþ) construct is similar to the ÿappendþ
construct, but its list values are concatenated as if by the function
ÿnconcþ.  By default, the list of values is returned when the ÿloopþ
finishes.

The ÿsumþ (or ÿsummingþ) construct takes one form in its clause that
must evaluate to a number and accumulates the sum of all these numbers.
By default, the cumulative sum is returned when the ÿloopþ finishes.

The ÿcountþ (or ÿcountingþ) construct takes one form in its clause and
counts the number of times that the form evaluates to true.  By
default, the count is returned when the ÿloopþ finishes.

The ÿminimizeþ (or ÿminimizingþ) construct takes one form in its clause
and determines the minimum value obtained by evaluating that form.  By
default, the minimum value is returned when the ÿloopþ finishes.

The ÿmaximizeþ (or ÿmaximizingþ) construct takes one form in its clause
and determines the maximum value obtained by evaluating that form.  By
default, the maximum value is returned when the ÿloopþ finishes.

For more information, see *Note Section 6.1.3 (Value Accumulation
Clauses): Value Accumulation Clauses.

6.1.1.5.3 Summary of Termination Test Clauses
.............................................

The ÿforþ and ÿasþ constructs provide a termination test that is
determined by the iteration control clause.

The ÿrepeatþ construct causes termination after a specified number of
iterations.  (It uses an internal variable to keep track of the number
of iterations.)

The ÿwhileþ construct takes one form, a TEST, and terminates the
iteration if the TEST evaluates to false.  A ÿwhileþ clause is
equivalent to the expression ÿ(if (not TEST) (loop-finish))þ.

The ÿuntilþ construct is the inverse of ÿwhileþ; it terminates the
iteration if the TEST evaluates to any non-nil value.  An ÿuntilþ
clause is equivalent to the expression ÿ(if TEST (loop-finish))þ.

The ÿalwaysþ construct takes one form and terminates the ÿloopþ if the
form ever evaluates to false; in this case, the ÿloopþ form returns
ÿnilþ.  Otherwise, it provides a default return value of ÿtþ.

The ÿneverþ construct takes one form and terminates the ÿloopþ if the
form ever evaluates to true; in this case, the ÿloopþ form returns
ÿnilþ.  Otherwise, it provides a default return value of ÿtþ.

The ÿthereisþ construct takes one form and terminates the ÿloopþ if the
form ever evaluates to a non-nil object; in this case, the ÿloopþ form
returns that object.  Otherwise, it provides a default return value of
ÿnilþ.

If multiple termination test clauses are specified, the ÿloopþ form
terminates if any are satisfied.

For more information, see *Note Section 6.1.4 (Termination Test
Clauses): Termination Test Clauses.

6.1.1.5.4 Summary of Unconditional Execution Clauses
....................................................

The ÿdoþ (or ÿdoingþ) construct evaluates all forms in its clause.

The ÿreturnþ construct takes one form. Any values returned by the form
are immediately returned by the ÿloopþ form.  It is equivalent to the
clause ÿdo (return-from block-name value)þ, where block-name is the
name specified in a ÿnamedþ clause, or ÿnilþ if there is no ÿnamedþ
clause.

For more information, see *Note Section 6.1.5 (Unconditional Execution
Clauses): Unconditional Execution Clauses.

6.1.1.5.5 Summary of Conditional Execution Clauses
..................................................

The ÿifþ and ÿwhenþ constructs take one form as a test and a clause
that is executed when the test yields true.  The clause can be a value
accumulation, unconditional, or another conditional clause; it can also
be any combination of such clauses connected by the ÿloopþ ÿandþ
keyword.

The ÿloopþ ÿunlessþ construct is similar to the ÿloopþ ÿwhenþ construct
except that it complements the test result.

The ÿloopþ ÿelseþ construct provides an optional component of ÿifþ,
ÿwhenþ, and ÿunlessþ clauses that is executed when an ÿifþ or ÿwhenþ
test yields false or when an ÿunlessþ test yields true.  The component
is one of the clauses described under ÿifþ.

The ÿloopþ ÿendþ construct provides an optional component to mark the
end of a conditional clause.

For more information, see *Note Section 6.1.6 (Conditional Execution
Clauses): Conditional Execution Clauses.

6.1.1.5.6 Summary of Miscellaneous Clauses
..........................................

The ÿloopþ ÿnamedþ construct gives a name for the block of the loop.

The ÿloopþ ÿinitiallyþ construct causes its forms to be evaluated in
the loop prologue, which precedes all ÿloopþ code except for initial
settings supplied by the constructs ÿwithþ, ÿforþ, or ÿasþ.

The ÿloopþ ÿfinallyþ construct causes its forms to be evaluated in the
loop epilogue after normal iteration terminates.

For more information, see *Note Section 6.1.7 (Miscellaneous Clauses):
Miscellaneous Clauses.

6.1.1.6 Order of Execution
..........................

With the exceptions listed below, clauses are executed in the loop body
in the order in which they appear in the source.  Execution is repeated
until a clause terminates the ÿloopþ or until a ÿreturnþ, ÿgoþ, or
ÿthrowþ form is encountered which transfers control to a point outside
of the loop.  The following actions are exceptions to the linear order
of execution:

   * All variables are initialized first, regardless of where the
     establishing clauses appear in the source.  The order of
     initialization follows the order of these clauses.

   * The code for any ÿinitiallyþ clauses is collected into one ÿprognþ
     in the order in which the clauses appear in the source.  The
     collected code is executed once in the loop prologue after any
     implicit variable initializations.

   * The code for any ÿfinallyþ clauses is collected into one ÿprognþ
     in the order in which the clauses appear in the source.  The
     collected code is executed once in the loop epilogue before any
     implicit values from the accumulation clauses are returned.
     Explicit returns anywhere in the source, however, will exit the
     ÿloopþ without executing the epilogue code.

   * A ÿwithþ clause introduces a variable binding and an optional
     initial value.  The initial values are calculated in the order in
     which the ÿwithþ clauses occur.

   * Iteration control clauses implicitly perform the following actions:

        - initialize variables;

        - step variables, generally between each execution of the loop
          body;

        - perform termination tests, generally just before the
          execution of the loop body.

6.1.1.7 Destructuring
.....................

The D-TYPE-SPEC argument is used for destructuring.  If the D-TYPE-SPEC
argument consists solely of the type ÿfixnumþ, ÿfloatþ, ÿtþ, or ÿnilþ,
the ÿof-typeþ keyword is optional.  The ÿof-typeþ construct is optional
in these cases to provide backwards compatibility; thus, the following
two expressions are the same:

;;; This expression uses the old syntax for type specifiers.
 (loop for i fixnum upfrom 3 ...)

;;; This expression uses the new syntax for type specifiers.
 (loop for i of-type fixnum upfrom 3 ...)

;; Declare X and Y to be of type VECTOR and FIXNUM respectively.
 (loop for (x y) of-type (vector fixnum)
       in l do ...)

A type specifier for a destructuring pattern is a tree of type
specifiers with the same shape as the tree of variable names, with the
following exceptions:

   * When aligning the trees, an atom in the tree of type specifiers
     that matches a cons in the variable tree declares the same type
     for each variable in the subtree rooted at the cons.

   * A cons in the tree of type specifiers that matches an atom in the
     tree of variable names is a compound type specifer.

Destructuring allows binding of a set of variables to a corresponding
set of values anywhere that a value can normally be bound to a single
variable.  During ÿloopþ expansion, each variable in the variable list
is matched with the values in the values list.  If there are more
variables in the variable list than there are values in the values
list, the remaining variables are given a value of ÿnilþ.  If there are
more values than variables listed, the extra values are discarded.

To assign values from a list to the variables ÿaþ, ÿbþ, and ÿcþ, the
ÿforþ clause could be used to bind the variable ÿnumlistþ to the car of
the supplied FORM, and then another ÿforþ clause could be used to bind
the variables ÿaþ, ÿbþ, and ÿcþ sequentially.

;; Collect values by using FOR constructs.
 (loop for numlist in '((1 2 4.0) (5 6 8.3) (8 9 10.4))
       for a of-type integer = (first numlist)
       and b of-type integer = (second numlist)
       and c of-type float = (third numlist)
       collect (list c b a))
ý ((4.0 2 1) (8.3 6 5) (10.4 9 8))

Destructuring makes this process easier by allowing the variables to be
bound in each loop iteration.  Types can be declared by using a list of
TYPE-SPEC arguments.  If all the types are the same, a shorthand
destructuring syntax can be used, as the second example illustrates.

;; Destructuring simplifies the process.
 (loop for (a b c) of-type (integer integer float) in
       '((1 2 4.0) (5 6 8.3) (8 9 10.4))
       collect (list c b a))
ý ((4.0 2 1) (8.3 6 5) (10.4 9 8))


;; If all the types are the same, this way is even simpler.
 (loop for (a b c) of-type float in
       '((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))
       collect (list c b a))
ý ((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))

If destructuring is used to declare or initialize a number of groups of
variables into types, the loop keyword ÿandþ can be used to simplify
the process further.
;; Initialize and declare variables in parallel by using the AND construct.
 (loop with (a b) of-type float = '(1.0 2.0)
       and (c d) of-type integer = '(3 4)
       and (e f)
       return (list a b c d e f))
ý (1.0 2.0 3 4 NIL NIL)

If ÿnilþ is used in a destructuring list, no variable is provided for
its place.

 (loop for (a nil b) = '(1 2 3)
       do (return (list a b)))
ý (1 3)

Note that dotted lists can specify destructuring.

 (loop for (x . y) = '(1 . 2)
       do (return y))
ý 2
 (loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in
       '(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))
       collect (list a b c d))
ý ((1.2 2.4 3 4) (3.4 4.6 5 6))

An error of type ÿprogram-errorþ is signaled (at macro expansion time)
if the same variable is bound twice in any variable-binding clause of a
single ÿloopþ expression.  Such variables include local variables,
iteration control variables, and variables found by destructuring.

6.1.1.8 Restrictions on Side-Effects
....................................

See *Note Section 3.6 (Traversal Rules and Side Effects): Traversal
Rules and Side Effects.


File: chris-ansicl.info,  Node: Variable Initialization and Stepping Clauses,  Next: Value Accumulation Clauses,  Prev: Overview of the Loop Facility,  Up: The LOOP Facility

6.1.2 Variable Initialization and Stepping Clauses
--------------------------------------------------

6.1.2.1 Iteration Control
.........................

Iteration control clauses allow direction of ÿloopþ iteration.  The
loop keywords ÿforþ and ÿasþ designate iteration control clauses.
Iteration control clauses differ with respect to the specification of
termination tests and to the initialization and steppingá of loop
variables.  Iteration clauses by themselves do not cause the Loop
Facility to return values, but they can be used in conjunction with
value-accumulation clauses to return values.

All variables are initialized in the loop prologue.  A variable binding
has lexical scope unless it is proclaimed ÿspecialþ; thus, by default,
the variable can be accessed only by forms that lie textually within
the ÿloopþ.  Stepping assignments are made in the loop body before any
other forms are evaluated in the body.

The variable argument in iteration control clauses can be a
destructuring list.  A destructuring list is a tree whose non-nil atoms
are variable names.  See *Note Section 6.1.1.7 (Destructuring):
DestructuringLOOPVars.

The iteration control clauses ÿforþ, ÿasþ,  and ÿrepeatþ must precede
any other loop clauses, except ÿinitiallyþ, ÿwithþ, and ÿnamedþ, since
they establish variable bindings.  When iteration control clauses are
used in a ÿloopþ, the corresponding termination tests in the loop body
are evaluated before any other loop body code is executed.

If multiple iteration clauses are used to control iteration, variable
initialization and steppingá occur sequentially by default.  The ÿandþ
construct can be used to connect two or more iteration clauses when
sequential binding and steppingá are not necessary.  The iteration
behavior of clauses joined by ÿandþ is analogous to the behavior of the
macro ÿdoþ with respect to ÿdo*þ.

The ÿforþ and ÿasþ clauses iterate by using one or more local loop
variables that are initialized to some value and that can be modified
or steppedá after each iteration.  For these clauses, iteration
terminates when a local variable reaches some supplied value or when
some other loop clause terminates iteration.  At each iteration,
variables can be steppedá by an increment or a decrement or can be
assigned a new value by the evaluation of a form).  Destructuring can
be used to assign values to variables during iteration.

The ÿforþ and ÿasþ keywords are synonyms; they can be used
interchangeably.  There are seven syntactic formats for these
constructs.  In each syntactic format, the type of VAR can be supplied
by the optional TYPE-SPEC argument.  If VAR is a destructuring list,
the type supplied by the TYPE-SPEC argument must appropriately match
the elements of the list.  By convention, ÿforþ introduces new
iterations and ÿasþ introduces iterations that depend on a previous
iteration specification.

6.1.2.1.1 The for-as-arithmetic subclause
.........................................

In the for-as-arithmetic subclause, the ÿforþ or ÿasþ construct
iterates from the value supplied by FORM1 to the value supplied by
FORM2 in increments or decrements denoted by FORM3. Each expression is
evaluated only once and must evaluate to a number.  The variable VAR is
bound to the value of FORM1 in the first iteration and is steppedá by
the value of FORM3 in each succeeding iteration, or by 1 if FORM3 is
not provided.  The following loop keywords serve as valid prepositions
within this syntax.  At least one of the prepositions must be used; and
at most one from each line may be used in a single subclause.

ÿfrom | downfrom | upfromþ

ÿto | downto | upto | below | aboveþ

ÿbyþ

The prepositional phrases in each subclause may appear in any order.
For example, either "ÿfrom x by yþ" or "ÿby y from xþ" is permitted.
However, because left-to-right order of evaluation is preserved, the
effects will be different in the case of side effects.  Consider:

(let ((x 1)) (loop for i from x by (incf x) to 10 collect i))
ý (1 3 5 7 9)
(let ((x 1)) (loop for i by (incf x) from x to 10 collect i))
ý (2 4 6 8 10)

The descriptions of the prepositions follow:

ÿfromþ
     The loop keyword ÿfromþ specifies the value from which steppingá
     begins, as supplied by FORM1.  Steppingá is incremental by
     default.  If decremental steppingá is desired, the preposition
     ÿdowntoþ or ÿaboveþ must be used with FORM2.  For incremental
     steppingá, the default ÿfromþ value is 0.

ÿdownfrom, upfromþ
     The loop keyword ÿdownfromþ indicates that the variable VAR is
     decreased in decrements supplied by FORM3; the loop keyword
     ÿupfromþ indicates that VAR is increased in increments supplied by
     FORM3.

ÿtoþ
     The loop keyword ÿtoþ marks the end value for steppingá supplied
     in FORM2.  Steppingá is incremental by default.  If decremental
     steppingá is desired, the preposition ÿdownfromþ must be used with
     FORM1, or else the preposition ÿdowntoþ or ÿaboveþ should be used
     instead of ÿtoþ with FORM2.

ÿdownto, uptoþ
     The loop keyword ÿdowntoþ specifies decremental stepping; the loop
     keyword ÿuptoþ specifies incremental stepping.  In both cases, the
     amount of change on each step is specified by FORM3, and the
     ÿloopþ terminates when the variable VAR passes the value of FORM2.
     Since there is no default for FORM1 in decremental steppingá, a
     FORM1 value must be supplied (using ÿfromþ or ÿdownfromþ) when
     ÿdowntoþ is supplied.

ÿbelow, aboveþ
     The loop keywords ÿbelowþ and ÿaboveþ are analogous to ÿuptoþ and
     ÿdowntoþ respectively.  These keywords stop iteration just before
     the value of the variable VAR reaches the value supplied by FORM2;
     the end value of FORM2 is not included.  Since there is no default
     for FORM1 in decremental steppingá, a FORM1 value must be supplied
     (using ÿfromþ or ÿdownfromþ) when ÿaboveþ is supplied.

ÿbyþ
     The loop keyword ÿbyþ marks the increment or decrement supplied by
     FORM3.  The value of FORM3 can be any positive number.  The
     default value is 1.

In an iteration control clause, the ÿforþ or ÿasþ construct causes
termination when the supplied limit is reached.  That is, iteration
continues until the value VAR is stepped to the exclusive or inclusive
limit supplied by FORM2.  The range is exclusive if FORM3 increases or
decreases VAR to the value of FORM2 without reaching that value; the
loop keywords ÿbelowþ and ÿaboveþ provide exclusive limits.  An
inclusive limit allows VAR to attain the value of FORM2; ÿtoþ,
ÿdowntoþ, and ÿuptoþ provide inclusive limits.

6.1.2.1.1.1 Examples of for-as-arithmetic subclause
...................................................

;; Print some numbers.
 (loop for i from 1 to 3
       do (print i))
Ö 1
Ö 2
Ö 3
ý NIL

;; Print every third number.
 (loop for i from 10 downto 1 by 3
       do (print i))
Ö 10
Ö 7
Ö 4
Ö 1
ý NIL

;; Step incrementally from the default starting value.
 (loop for i below 3
       do (print i))
Ö 0
Ö 1
Ö 2
ý NIL

6.1.2.1.2 The for-as-in-list subclause
......................................

In the for-as-in-list subclause, the ÿforþ or ÿasþ construct iterates
over the contents of a list.  It checks for the end of the list as if
by using ÿendpþ.  The variable VAR is bound to the successive elements
of the list in FORM1 before each iteration.  At the end of each
iteration, the function STEP-FUN is applied to the list; the default
value for STEP-FUN is ÿcdrþ.  The loop keywords ÿinþ and ÿbyþ serve as
valid prepositions in this syntax.  The ÿforþ or ÿasþ construct causes
termination when the end of the list is reached.

6.1.2.1.2.1 Examples of for-as-in-list subclause
................................................

;; Print every item in a list.
 (loop for item in '(1 2 3) do (print item))
Ö 1
Ö 2
Ö 3
ý NIL

;; Print every other item in a list.
 (loop for item in '(1 2 3 4 5) by #'cddr
       do (print item))
Ö 1
Ö 3
Ö 5
ý NIL

;; Destructure a list, and sum the x values using fixnum arithmetic.
 (loop for (item . x) of-type (t . fixnum) in '((A . 1) (B . 2) (C . 3))
       unless (eq item 'B) sum x)
ý 4

6.1.2.1.3 The for-as-on-list subclause
......................................

In the for-as-on-list subclause, the ÿforþ or ÿasþ construct iterates
over a list. It checks for the end of the list as if by using ÿatomþ.
The variable VAR is bound to the successive tails of the list in FORM1.
At the end of each iteration, the function STEP-FUN is applied to the
list; the default value for STEP-FUN is ÿcdrþ.  The loop keywords ÿonþ
and ÿbyþ serve as valid prepositions in this syntax.  The ÿforþ or ÿasþ
construct causes termination when the end of the list is reached.

6.1.2.1.3.1 Examples of for-as-on-list subclause
................................................

;; Collect successive tails of a list.
 (loop for sublist on '(a b c d)
       collect sublist)
ý ((A B C D) (B C D) (C D) (D))

;; Print a list by using destructuring with the loop keyword ON.
 (loop for (item) on '(1 2 3)
       do (print item))
Ö 1
Ö 2
Ö 3
ý NIL

6.1.2.1.4 The for-as-equals-then subclause
..........................................

In the for-as-equals-then subclause the ÿforþ or ÿasþ construct
initializes the variable VAR by setting it to the result of evaluating
FORM1 on the first iteration, then setting it to the result of
evaluating FORM2 on the second and subsequent iterations.  If FORM2 is
omitted, the construct uses FORM1 on the second and subsequent
iterations.  The loop keywords = and ÿthenþ serve as valid prepositions
in this syntax.  This construct does not provide any termination tests.

6.1.2.1.4.1 Examples of for-as-equals-then subclause
....................................................

;; Collect some numbers.
 (loop for item = 1 then (+ item 10)
       for iteration from 1 to 5
       collect item)
ý (1 11 21 31 41)

6.1.2.1.5 The for-as-across subclause
.....................................

In the for-as-across subclause the ÿforþ or ÿasþ construct binds the
variable VAR to the value of each element in the array VECTOR.  The
loop keyword ÿacrossþ marks the array VECTOR; ÿacrossþ is used as a
preposition in this syntax.  Iteration stops when there are no more
elements in the supplied array that can be referenced.  Some
implementations might recognize a ÿtheþ special form in the VECTOR form
to produce more efficient code.

6.1.2.1.5.1 Examples of for-as-across subclause
...............................................

 (loop for char across (the simple-string (find-message channel))
       do (write-char char stream))

6.1.2.1.6 The for-as-hash subclause
...................................

In the for-as-hash subclause the ÿforþ or ÿasþ construct iterates over
the elements, keys, and values of a hash-table.  In this syntax, a
compound preposition is used to designate access to a hash table.  The
variable VAR takes on the value of each hash key or hash value in the
supplied HASH-TABLE.  The following loop keywords serve as valid
prepositions within this syntax:

ÿbeingþ
     The keyword ÿbeingþ introduces either the Loop schema ÿhash-keyþ
     or ÿhash-valueþ.

ÿeachþ, ÿtheþ
     The loop keyword ÿeachþ follows the loop keyword ÿbeingþ when
     ÿhash-keyþ or ÿhash-valueþ is used.  The loop keyword ÿtheþ is
     used with ÿhash-keysþ and ÿhash-valuesþ only for ease of reading.
     This agreement isn't required.

ÿhash-keyþ, ÿhash-keysþ
     These loop keywords access each key entry of the hash table.  If
     the name ÿhash-valueþ is supplied in a ÿusingþ construct with one
     of these Loop schemas, the iteration can optionally access the
     keyed value. The order in which the keys are accessed is
     undefined; empty slots in the hash table are ignored.

ÿhash-valueþ, ÿhash-valuesþ
     These loop keywords access each value entry of a hash table.  If
     the name ÿhash-keyþ is supplied in a ÿusingþ construct with one of
     these Loop schemas, the iteration can optionally access the key
     that corresponds to the value.  The order in which the keys are
     accessed is undefined; empty slots in the hash table are ignored.

ÿusingþ
     The loop keyword ÿusingþ introduces the optional key or the keyed
     value to be accessed.  It allows access to the hash key if
     iteration is over the hash values, and the hash value if iteration
     is over the hash keys.

ÿinþ, ÿofþ
     These loop prepositions introduce HASH-TABLE.

In effect

ÿbeingþ {ÿeachþ | ÿtheþ} {ÿhash-valueþ  | ÿhash-valuesþ | ÿhash-keyþ
| ÿhash-keysþ} {ÿinþ | ÿofþ}

is a compound preposition.

Iteration stops when there are no more hash keys or hash values to be
referenced in the supplied HASH-TABLE.

6.1.2.1.7 The for-as-package subclause
......................................

In the for-as-package subclause the ÿforþ or ÿasþ construct iterates
over the symbols in a package.  In this syntax, a compound preposition
is used to designate access to a package.  The variable VAR takes on
the value of each symbol in the supplied package.  The following loop
keywords serve as valid prepositions within this syntax:

ÿbeingþ
     The keyword ÿbeingþ introduces either the Loop schema ÿsymbolþ,
     ÿpresent-symbolþ,  or ÿexternal-symbolþ.

ÿeachþ, ÿtheþ
     The loop keyword ÿeachþ follows the loop keyword ÿbeingþ when
     ÿsymbolþ, ÿpresent-symbolþ, or ÿexternal-symbolþ is used.  The
     loop keyword ÿtheþ is used with ÿsymbolsþ, ÿpresent-symbolsþ, and
     ÿexternal-symbolsþ only for ease of reading.  This agreement isn't
     required.

ÿpresent-symbolþ, ÿpresent-symbolsþ
     These Loop schemas iterate over the symbols that are present in a
     package.  The PACKAGE to be iterated over is supplied in the same
     way that package arguments to ÿfind-packageþ are supplied.  If the
     PACKAGE for the iteration is not supplied, the current package is
     used.  If a PACKAGE that does not exist is supplied, an error of
     type ÿpackage-errorþ is signaled.

ÿsymbolþ, ÿsymbolsþ
     These Loop schemas iterate over symbols that are accessible in a
     given PACKAGE.  The PACKAGE to be iterated over is supplied in the
     same way that package arguments to ÿfind-packageþ are supplied.
     If the PACKAGE for the iteration is not supplied, the current
     package is used.  If a PACKAGE that does not exist is supplied, an
     error of type ÿpackage-errorþ is signaled.

ÿexternal-symbolþ, ÿexternal-symbolsþ
     These Loop schemas iterate over the external symbols of a PACKAGE.
     The PACKAGE to be iterated over is supplied in the same way that
     package arguments to ÿfind-packageþ are supplied.  If the PACKAGE
     for the iteration is not supplied, the current package is used.
     If a PACKAGE that does not exist is supplied, an error of type
     ÿpackage-errorþ is signaled.

ÿinþ, ÿofþ
     These loop prepositions introduce PACKAGE.

In effect

ÿbeingþ {ÿeachþ | ÿtheþ} {ÿsymbolþ          | ÿsymbolsþ         |
ÿpresent-symbolþ  | ÿpresent-symbolsþ | ÿexternal-symbolþ |
ÿexternal-symbolsþ} {ÿinþ | ÿofþ}

is a compound preposition.

Iteration stops when there are no more symbols to be referenced in the
supplied PACKAGE.

6.1.2.1.7.1 Examples of for-as-package subclause
................................................

 (let ((*package* (make-package "TEST-PACKAGE-1")))
   ;; For effect, intern some symbols
   (read-from-string "(THIS IS A TEST)")
   (export (intern "THIS"))
   (loop for x being each present-symbol of *package*
          do (print x)))
Ö A
Ö TEST
Ö THIS
Ö IS
ý NIL

6.1.2.2 Local Variable Initializations
......................................

When a ÿloopþ form is executed, the local variables are bound and are
initialized to some value.  These local variables exist until ÿloopþ
iteration terminates, at which point they cease to exist.  Implicit
variables are also established by iteration control clauses and the
ÿintoþ preposition of accumulation clauses.

The ÿwithþ construct initializes variables that are local to a loop.
The variables are initialized one time only.  If the optional TYPE-SPEC
argument is supplied for the variable VAR, but there is no related
expression to be evaluated, VAR is initialized to an appropriate
default value for its type.  For example, for the types ÿtþ, ÿnumberþ,
and ÿfloatþ, the default values are ÿnilþ, ÿ0þ, and ÿ0.0þ respectively.
The consequences are undefined if a TYPE-SPEC argument is supplied for
VAR if the related expression returns a value that is not of the
supplied type.  By default, the ÿwithþ construct initializes variables
sequentially; that is, one variable is assigned a value before the next
expression is evaluated.  However, by using the loop keyword ÿandþ to
join several ÿwithþ clauses, initializations can be forced to occur in
parallel; that is, all of the supplied FORMS are evaluated, and the
results are bound to the respective variables simultaneously.

Sequential binding is used when it is desireable for the initialization
of some variables to depend on the values of previously bound variables.
For example, suppose the variables ÿaþ, ÿbþ, and ÿcþ are to be bound in
sequence:

 (loop with a = 1
       with b = (+ a 2)
       with c = (+ b 3)
       return (list a b c))
ý (1 3 6)

The execution of the above ÿloopþ is equivalent to the execution of the
following code:

 (block nil
   (let* ((a 1)
          (b (+ a 2))
          (c (+ b 3)))
     (tagbody
         (next-loop (return (list a b c))
                    (go next-loop)
                    end-loop))))

If the values of previously bound variables are not needed for the
initialization of other local variables, an ÿandþ clause can be used to
specify that the bindings are to occur in parallel:

 (loop with a = 1
       and b = 2
       and c = 3
       return (list a b c))
ý (1 2 3)

The execution of the above loop is equivalent to the execution of the
following code:

 (block nil
   (let ((a 1)
         (b 2)
         (c 3))
     (tagbody
         (next-loop (return (list a b c))
                    (go next-loop)
                    end-loop))))

6.1.2.2.1 Examples of WITH clause
.................................

;; These bindings occur in sequence.
 (loop with a = 1
       with b = (+ a 2)
       with c = (+ b 3)
       return (list a b c))
ý (1 3 6)

;; These bindings occur in parallel.
 (setq a 5 b 10)
ý 10
 (loop with a = 1
       and b = (+ a 2)
       and c = (+ b 3)
       return (list a b c))
ý (1 7 13)

;; This example shows a shorthand way to declare local variables
;; that are of different types.
 (loop with (a b c) of-type (float integer float)
       return (format nil "~A ~A ~A" a b c))
ý "0.0 0 0.0"

;; This example shows a shorthand way to declare local variables
;; that are the same type.
 (loop with (a b c) of-type float
       return (format nil "~A ~A ~A" a b c))
ý "0.0 0.0 0.0"


File: chris-ansicl.info,  Node: Value Accumulation Clauses,  Next: Termination Test Clauses,  Prev: Variable Initialization and Stepping Clauses,  Up: The LOOP Facility

6.1.3 Value Accumulation Clauses
--------------------------------

The constructs ÿcollectþ, ÿcollectingþ, ÿappendþ, ÿappendingþ, ÿnconcþ,
ÿnconcingþ, ÿcountþ, ÿcountingþ, ÿmaximizeþ, ÿmaximizingþ, ÿminimizeþ,
ÿminimizingþ, ÿsumþ, and ÿsummingþ, allow values to be accumulated in a
ÿloopþ.

The constructs ÿcollectþ, ÿcollectingþ, ÿappendþ, ÿappendingþ, ÿnconcþ,
and ÿnconcingþ, designate clauses that accumulate values in lists and
return them.  The constructs ÿcountþ, ÿcountingþ, ÿmaximizeþ,
ÿmaximizingþ, ÿminimizeþ, ÿminimizingþ, ÿsumþ, and ÿsummingþ designate
clauses that accumulate and return numerical values.

During each iteration,  the constructs ÿcollectþ and ÿcollectingþ
collect the value of the supplied FORM into a list.  When iteration
terminates, the list is returned.  The argument VAR is set to the list
of collected values; if VAR is supplied, the ÿloopþ does not return the
final list automatically.  If VAR is not supplied, it is equivalent to
supplying an internal name for VAR and returning its value in a
ÿfinallyþ clause.  The VAR argument is bound as if by the construct
ÿwithþ.  No mechanism is provided for declaring the type of VAR; it
must be of type ÿlistþ.

The constructs ÿappendþ, ÿappendingþ, ÿnconcþ, and  ÿnconcingþ are
similar to ÿcollectþ except that the values of the supplied FORM must
be lists.

   * The ÿappendþ keyword causes its list values to be concatenated
     into a single list, as if they were arguments to the function
     ÿappendþ.

   * The ÿnconcþ keyword causes its list values to be concatenated into
     a single list, as if they were arguments to the function ÿnconcþ.

The argument VAR is set to the list of concatenated values; if VAR is
supplied, ÿloopþ does not return the final list automatically.  The VAR
argument is bound as if by the construct ÿwithþ.  A type cannot be
supplied for VAR; it must be of type ÿlistþ.  The construct ÿnconcþ
destructively modifies its argument lists.

The ÿcountþ construct counts the number of times that the supplied FORM
returns true.  The argument VAR accumulates the number of occurrences;
if VAR is supplied, ÿloopþ does not return the final count
automatically.  The VAR argument is bound as if by the construct ÿwithþ
to a zero of the appropriate type.  Subsequent values (including any
necessary coercions) are computed as if by the function ÿ1+þ.  If
ÿintoþ VAR is used, a type can be supplied  for VAR with the TYPE-SPEC
argument; the consequences are unspecified if a nonnumeric type is
supplied.  If there is no ÿintoþ variable, the optional TYPE-SPEC
argument applies to the internal variable that is keeping the count.
The default type is implementation-dependent; but it must be a
supertype of type ÿfixnumþ.

The ÿmaximizeþ and ÿminimizeþ constructs compare the value of the
supplied FORM obtained during the first iteration with values obtained
in successive iterations.  The maximum (for ÿmaximizeþ) or minimum (for
ÿminimizeþ) value encountered is determined (as if by the function
ÿmaxþ for ÿmaximizeþ and as if by the function ÿminþ for ÿminimizeþ)
and returned.  If the ÿmaximizeþ or ÿminimizeþ clause is never
executed, the accumulated value is unspecified.  The argument VAR
accumulates the maximum or minimum value; if VAR is supplied, ÿloopþ
does not return the maximum or minimum automatically.  The VAR argument
is bound as if by the construct ÿwithþ.  If ÿintoþ VAR is used, a type
can be supplied for VAR with the TYPE-SPEC argument; the consequences
are unspecified if a nonnumeric type is supplied.  If there is no
ÿintoþ variable, the optional TYPE-SPEC argument applies to the
internal variable that is keeping the maximum or minimum value.  The
default type is implementation-dependent; but it must be a supertype of
type ÿrealþ.

The ÿsumþ construct forms a cumulative sum of the successive primary
values of the supplied FORM at each iteration.  The argument VAR is
used to accumulate the sum; if VAR is supplied, ÿloopþ does not return
the final sum automatically.  The VAR argument is bound as if by the
construct ÿwithþ to a zero of the appropriate type.  Subsequent values
(including any necessary coercions) are computed as if by the function
ÿ+þ.  If ÿintoþ VAR is used, a type can be supplied for VAR with the
TYPE-SPEC argument; the consequences are unspecified if a nonnumeric
type is supplied.  If there is no ÿintoþ variable, the optional
TYPE-SPEC argument applies to the internal variable that is keeping the
sum.  The default type is implementation-dependent; but it must be a
supertype of type ÿnumberþ.

If ÿintoþ is used, the construct does not provide a default return
value; however, the variable is available for use in any ÿfinallyþ
clause.

Certain kinds of accumulation clauses can be combined in a ÿloopþ if
their destination is the same (the result of ÿloopþ or an ÿintoþ VAR)
because they are considered to accumulate conceptually compatible
quantities.  In particular, any elements of following sets of
accumulation clauses can be mixed with other elements of the same set
for the same destination in a ÿloopþ form:

   * ÿcollectþ, ÿappendþ, ÿnconcþ

   * ÿsumþ, ÿcountþ

   * ÿmaximizeþ, ÿminimizeþ

;; Collect every name and the kids in one list by using
;; COLLECT and APPEND.
 (loop for name in '(fred sue alice joe june)
       for kids in '((bob ken) () () (kris sunshine) ())
       collect name
       append kids)
ý (FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)

Any two clauses that do not accumulate the same type of object can
coexist in a ÿloopþ only if each clause accumulates its values into a
different variable.

6.1.3.1 Examples of COLLECT clause
..................................

;; Collect all the symbols in a list.
 (loop for i in '(bird 3 4 turtle (1 . 4) horse cat)
       when (symbolp i) collect i)
ý (BIRD TURTLE HORSE CAT)

;; Collect and return odd numbers.
 (loop for i from 1 to 10
       if (oddp i) collect i)
ý (1 3 5 7 9)

;; Collect items into local variable, but don't return them.
 (loop for i in '(a b c d) by #'cddr
       collect i into my-list
       finally (print my-list))
Ö (A C)
ý NIL

6.1.3.2 Examples of APPEND and NCONC clauses
............................................

;; Use APPEND to concatenate some sublists.
  (loop for x in '((a) (b) ((c)))
        append x)
ý (A B (C))

;; NCONC some sublists together.  Note that only lists made by the
;; call to LIST are modified.
  (loop for i upfrom 0
        as x in '(a b (c))
        nconc (if (evenp i) (list x) nil))
ý (A (C))

6.1.3.3 Examples of COUNT clause
................................

 (loop for i in '(a b nil c nil d e)
       count i)
ý 5

6.1.3.4 Examples of MAXIMIZE and MINIMIZE clauses
.................................................

 (loop for i in '(2 1 5 3 4)
       maximize i)
ý 5
 (loop for i in '(2 1 5 3 4)
       minimize i)
ý 1

;; In this example, FIXNUM applies to the internal variable that holds
;; the maximum value.
 (setq series '(1.2 4.3 5.7))
ý (1.2 4.3 5.7)
 (loop for v in series
       maximize (round v) of-type fixnum)
ý 6

;; In this example, FIXNUM applies to the variable RESULT.
 (loop for v of-type float in series
       minimize (round v) into result of-type fixnum
       finally (return result))
ý 1

6.1.3.5 Examples of SUM clause
..............................

 (loop for i of-type fixnum in '(1 2 3 4 5)
       sum i)
ý 15
 (setq series '(1.2 4.3 5.7))
ý (1.2 4.3 5.7)
 (loop for v in series
       sum (* 2.0 v))
ý 22.4


File: chris-ansicl.info,  Node: Termination Test Clauses,  Next: Unconditional Execution Clauses,  Prev: Value Accumulation Clauses,  Up: The LOOP Facility

6.1.4 Termination Test Clauses
------------------------------

The ÿrepeatþ construct causes iteration to terminate after a specified
number of times.  The loop body executes n times, where n is the value
of the expression FORM.  The FORM argument is evaluated one time in the
loop prologue.  If the expression evaluates to 0 or to a negative
number, the loop body is not evaluated.

The constructs ÿalwaysþ, ÿneverþ, ÿthereisþ, ÿwhileþ, ÿuntilþ, and the
macro ÿloop-finishþ allow conditional termination of iteration within a
ÿloopþ.

The constructs ÿalwaysþ, ÿneverþ, and ÿthereisþ provide specific values
to be returned when a ÿloopþ terminates.  Using ÿalwaysþ, ÿneverþ, or
ÿthereisþ in a loop with value accumulation clauses that are not ÿintoþ
causes an error of type ÿprogram-errorþ to be signaled (at macro
expansion time).  Since ÿalwaysþ, ÿneverþ, and ÿthereisþ use the
ÿreturn-fromþ special operator to terminate iteration, any ÿfinallyþ
clause that is supplied is not evaluated when exit occurs due to any of
these constructs.  In all other respects these constructs behave like
the ÿwhileþ and ÿuntilþ constructs.

The ÿalwaysþ construct takes one form and terminates the ÿloopþ if the
form ever evaluates to ÿnilþ; in this case, it returns ÿnilþ.
Otherwise, it provides a default return value of ÿtþ.  If the value of
the supplied form is never ÿnilþ, some other construct can terminate
the iteration.

The ÿneverþ construct terminates iteration the first time that the
value of the supplied FORM is non-nil; the ÿloopþ returns ÿnilþ.  If
the value of the supplied FORM is always  ÿnilþ, some other construct
can terminate the iteration.  Unless some other clause contributes a
return value, the default value returned is ÿtþ.

The ÿthereisþ construct terminates iteration the first time that the
value of the supplied FORM is non-nil; the ÿloopþ returns the value of
the supplied FORM.  If the value of the supplied FORM is always  ÿnilþ,
some other construct can terminate the iteration.  Unless some other
clause contributes a return value, the default value returned is ÿnilþ.

There are two differences between the ÿthereisþ and ÿuntilþ constructs:

   * The ÿuntilþ construct does not return a value or ÿnilþ based on
     the value of the supplied FORM.

   * The ÿuntilþ construct executes any ÿfinallyþ clause.  Since
     ÿthereisþ uses the ÿreturn-fromþ special operator to terminate
     iteration, any ÿfinallyþ clause that is supplied is not evaluated
     when exit occurs due to ÿthereisþ.

The ÿwhileþ construct allows iteration to continue until the supplied
FORM evaluates to false.  The supplied FORM is reevaluated at the
location of the ÿwhileþ clause.

The ÿuntilþ construct is equivalent to ÿwhile (not FORM)...þ.  If the
value of the supplied FORM is non-nil, iteration terminates.

Termination-test control constructs can be used anywhere within the
loop body.  The termination tests are used in the order in which they
appear.  If an ÿuntilþ or ÿwhileþ clause causes termination, any
clauses that precede it in the source are still evaluated.  If the
ÿuntilþ and ÿwhileþ constructs cause termination, control is passed to
the loop epilogue, where any ÿfinallyþ clauses will be executed.

There are two differences between the ÿneverþ and ÿuntilþ constructs:

   * The ÿuntilþ construct does not return ÿtþ or ÿnilþ based on the
     value of the supplied FORM.

   * The ÿuntilþ construct does not bypass any ÿfinallyþ clauses.
     Since ÿneverþ uses the ÿreturn-fromþ special operator to terminate
     iteration, any ÿfinallyþ clause that is supplied is not evaluated
     when exit occurs due to ÿneverþ.

In most cases it is not necessary to use ÿloop-finishþ because other
loop control clauses terminate the ÿloopþ.  The macro ÿloop-finishþ is
used to provide a normal exit from a nested conditional inside a ÿloopþ.
Since ÿloop-finishþ transfers control to the loop epilogue, using
ÿloop-finishþ within a ÿfinallyþ expression can cause infinite looping.

6.1.4.1 Examples of REPEAT clause
.................................

 (loop repeat 3
       do (format t "~&What I say three times is true.~%"))
Ö What I say three times is true.
Ö What I say three times is true.
Ö What I say three times is true.
ý NIL
 (loop repeat -15
   do (format t "What you see is what you expect~%"))
ý NIL

6.1.4.2 Examples of ALWAYS, NEVER, and THEREIS clauses
......................................................

;; Make sure I is always less than 11 (two ways).
;; The FOR construct terminates these loops.
 (loop for i from 0 to 10
       always (< i 11))
ý T
 (loop for i from 0 to 10
       never (> i 11))
ý T

;; If I exceeds 10 return I; otherwise, return NIL.
;; The THEREIS construct terminates this loop.
 (loop for i from 0
       thereis (when (> i 10) i) )
ý 11

;;; The FINALLY clause is not evaluated in these examples.
 (loop for i from 0 to 10
       always (< i 9)
       finally (print "you won't see this"))
ý NIL
 (loop never t
       finally (print "you won't see this"))
ý NIL
 (loop thereis "Here is my value"
       finally (print "you won't see this"))
ý "Here is my value"

;; The FOR construct terminates this loop, so the FINALLY clause
;; is evaluated.
 (loop for i from 1 to 10
       thereis (> i 11)
       finally (prin1 'got-here))
Ö GOT-HERE
ý NIL

;; If this code could be used to find a counterexample to Fermat's
;; last theorem, it would still not return the value of the
;; counterexample because all of the THEREIS clauses in this example
;; only return T.  But if Fermat is right, that won't matter
;; because this won't terminate.

 (loop for z upfrom 2
       thereis
         (loop for n upfrom 3 below (log z 2)
               thereis
                 (loop for x below z
                       thereis
                         (loop for y below z
                               thereis (= (+ (expt x n) (expt y n))
                                          (expt z n))))))

6.1.4.3 Examples of WHILE and UNTIL clauses
...........................................

 (loop while (hungry-p) do (eat))

;; UNTIL NOT is equivalent to WHILE.
 (loop until (not (hungry-p)) do (eat))

;; Collect the length and the items of STACK.
 (let ((stack '(a b c d e f)))
   (loop for item = (length stack) then (pop stack)
         collect item
         while stack))
ý (6 A B C D E F)

;; Use WHILE to terminate a loop that otherwise wouldn't terminate.
;; Note that WHILE occurs after the WHEN.
 (loop for i fixnum from 3
       when (oddp i) collect i
       while (< i 5))
ý (3 5)


File: chris-ansicl.info,  Node: Unconditional Execution Clauses,  Next: Conditional Execution Clauses,  Prev: Termination Test Clauses,  Up: The LOOP Facility

6.1.5 Unconditional Execution Clauses
-------------------------------------

The ÿdoþ and ÿdoingþ constructs evaluate the supplied FORMS wherever
they occur in the expanded form of ÿloopþ.  The FORM argument can be
any compound form.  Each FORM is evaluated in every iteration.  Because
every loop clause must begin with a loop keyword, the keyword ÿdoþ is
used when no control action other than execution is required.

The ÿreturnþ construct takes one form.  Any values returned by the form
are immediately returned by the ÿloopþ form.  It is equivalent to the
clause ÿdo (return-from block-name value)þ, where block-name is the
name specified in a ÿnamedþ clause, or ÿnilþ if there is no ÿnamedþ
clause.

6.1.5.1 Examples of unconditional execution
...........................................

;; Print numbers and their squares.
;; The DO construct applies to multiple forms.
 (loop for i from 1 to 3
       do (print i)
          (print (* i i)))
Ö 1
Ö 1
Ö 2
Ö 4
Ö 3
Ö 9
ý NIL


File: chris-ansicl.info,  Node: Conditional Execution Clauses,  Next: Miscellaneous Clauses,  Prev: Unconditional Execution Clauses,  Up: The LOOP Facility

6.1.6 Conditional Execution Clauses
-----------------------------------

The ÿifþ, ÿwhenþ, and ÿunlessþ constructs establish conditional control
in a ÿloopþ. If the test passes, the succeeding loop clause is
executed. If the test does not pass, the succeeding clause is skipped,
and program control moves to the clause that follows the loop keyword
ÿelseþ. If the test does not pass and no ÿelseþ clause is supplied,
control is transferred to the clause or construct following the entire
conditional clause.

If conditional clauses are nested, each ÿelseþ is paired with the
closest preceding conditional clause that has no associated ÿelseþ or
ÿendþ.

In the ÿifþ and ÿwhenþ clauses, which are synonymous, the test passes
if the value of FORM is true.

In the ÿunlessþ clause, the test passes if the value of FORM is false.

Clauses that follow the test expression can be grouped by using the
loop keyword ÿandþ to produce a conditional block consisting of a
compound clause.

The loop keyword ÿitþ can be used to refer to the result of the test
expression in a clause.  Use the loop keyword ÿitþ in place of the form
in a ÿreturnþ clause or an accumulation clause that is inside a
conditional execution clause.  If multiple clauses are connected with
ÿandþ, the ÿitþ construct must be in the first clause in the block.

The optional loop keyword ÿendþ marks the end of the clause.  If this
keyword is not supplied, the next loop keyword marks the end.  The
construct ÿendþ can be used to distinguish the scoping of compound
clauses.

6.1.6.1 Examples of WHEN clause
...............................

;; Signal an exceptional condition.
 (loop for item in '(1 2 3 a 4 5)
       when (not (numberp item))
        return (cerror "enter new value" "non-numeric value: ~s" item))
Error: non-numeric value: A

;; The previous example is equivalent to the following one.
 (loop for item in '(1 2 3 a 4 5)
       when (not (numberp item))
        do (return
            (cerror "Enter new value" "non-numeric value: ~s" item)))
Error: non-numeric value: A

;; This example parses a simple printed string representation from
;; BUFFER (which is itself a string) and returns the index of the
;; closing double-quote character.
 (let ((buffer "\"a\" \"b\""))
   (loop initially (unless (char= (char buffer 0) #\")
                     (loop-finish))
         for i of-type fixnum from 1 below (length (the string buffer))
         when (char= (char buffer i) #\")
          return i))
ý 2

;; The collected value is returned.
 (loop for i from 1 to 10
       when (> i 5)
         collect i
       finally (prin1 'got-here))
Ö GOT-HERE
ý (6 7 8 9 10)

;; Return both the count of collected numbers and the numbers.
 (loop for i from 1 to 10
       when (> i 5)
         collect i into number-list
         and count i into number-count
       finally (return (values number-count number-list)))
ý 5, (6 7 8 9 10)


File: chris-ansicl.info,  Node: Miscellaneous Clauses,  Next: Examples of Miscellaneous Loop Features,  Prev: Conditional Execution Clauses,  Up: The LOOP Facility

6.1.7 Miscellaneous Clauses
---------------------------

6.1.7.1 Control Transfer Clauses
................................

The ÿnamedþ construct establishes a name for an implicit block
surrounding the entire ÿloopþ so that the ÿreturn-fromþ special
operator can be used to return values from or to exit ÿloopþ.  Only one
name per ÿloopþ form can be assigned.  If used, the ÿnamedþ construct
must be the first clause in the loop expression.

The ÿreturnþ construct takes one form.  Any values returned by the form
are immediately returned by the ÿloopþ form.  This construct is similar
to the ÿreturn-fromþ special operator and the ÿreturnþ macro.  The
ÿreturnþ construct does not execute any ÿfinallyþ clause that the
ÿloopþ form is given.

6.1.7.1.1 Examples of NAMED clause
..................................

;; Just name and return.
 (loop named max
       for i from 1 to 10
       do (print i)
       do (return-from max 'done))
Ö 1
ý DONE

6.1.7.2 Initial and Final Execution
...................................

The ÿinitiallyþ and ÿfinallyþ constructs evaluate forms that occur
before and after the loop body.

The ÿinitiallyþ construct causes the supplied COMPOUND-FORMS to be
evaluated in the loop prologue, which precedes all loop code except for
initial settings supplied by constructs ÿwithþ, ÿforþ, or ÿasþ.  The
code for any ÿinitiallyþ clauses is executed in the order in which the
clauses appeared in the ÿloopþ.

The ÿfinallyþ construct causes the supplied COMPOUND-FORMS to be
evaluated in the loop epilogue after normal iteration terminates.  The
code for any ÿfinallyþ clauses is executed in the order in which the
clauses appeared in the ÿloopþ.  The collected code is executed once in
the loop epilogue before any implicit values are returned from the
accumulation clauses.  An explicit transfer of control (e.g., by
ÿreturnþ, ÿgoþ, or ÿthrowþ) from the loop body, however, will exit the
ÿloopþ without executing the epilogue code.

Clauses such as ÿreturnþ, ÿalwaysþ, ÿneverþ, and ÿthereisþ can bypass
the ÿfinallyþ clause.  ÿreturnþ (or ÿreturn-fromþ, if the ÿnamedþ
option was supplied) can be used after ÿfinallyþ to return values from
a ÿloopþ.  Such an explicit return inside the ÿfinallyþ clause takes
precedence over returning the accumulation from clauses supplied by
such keywords as ÿcollectþ, ÿnconcþ, ÿappendþ, ÿsumþ, ÿcountþ,
ÿmaximizeþ, and ÿminimizeþ; the accumulation values for these preempted
clauses are not returned by ÿloopþ if ÿreturnþ or ÿreturn-fromþ is used.


File: chris-ansicl.info,  Node: Examples of Miscellaneous Loop Features,  Next: Notes about Loop,  Prev: Miscellaneous Clauses,  Up: The LOOP Facility

6.1.8 Examples of Miscellaneous Loop Features
---------------------------------------------

 (let ((i 0))                     ; no loop keywords are used
    (loop (incf i) (if (= i 3) (return i)))) ý 3
 (let ((i 0)(j 0))
    (tagbody
      (loop (incf j 3) (incf i) (if (= i 3) (go exit)))
      exit)
    j) ý 9

In the following example, the variable ÿxþ is stepped before ÿyþ is
stepped; thus, the value of ÿyþ reflects the updated value of ÿxþ:

 (loop for x from 1 to 10
       for y = nil then x
       collect (list x y))
ý ((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9) (10 10))

In this example, ÿxþ and ÿyþ are stepped in parallel:

 (loop for x from 1 to 10
       and y = nil then x
       collect (list x y))
ý ((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8) (10 9))

6.1.8.1 Examples of clause grouping
...................................

;; Group conditional clauses.
 (loop for i in '(1 324 2345 323 2 4 235 252)
       when (oddp i)
         do (print i)
         and collect i into odd-numbers
         and do (terpri)
       else                              ; I is even.
         collect i into even-numbers
       finally
         (return (values odd-numbers even-numbers)))
Ö 1
Ö
Ö 2345
Ö
Ö 323
Ö
Ö 235
ý (1 2345 323 235), (324 2 4 252)

;; Collect numbers larger than 3.
 (loop for i in '(1 2 3 4 5 6)
       when (and (> i 3) i)
       collect it)                      ; IT refers to (and (> i 3) i).
ý (4 5 6)

;; Find a number in a list.
 (loop for i in '(1 2 3 4 5 6)
       when (and (> i 3) i)
       return it)
ý 4

;; The above example is similar to the following one.
 (loop for i in '(1 2 3 4 5 6)
       thereis (and (> i 3) i))
ý 4



;; Nest conditional clauses.
 (let ((list '(0 3.0 apple 4 5 9.8 orange banana)))
   (loop for i in list
         when (numberp i)
           when (floatp i)
             collect i into float-numbers
           else                                  ; Not (floatp i)
             collect i into other-numbers
         else                                    ; Not (numberp i)
           when (symbolp i)
             collect i into symbol-list
           else                                  ; Not (symbolp i)
             do (error "found a funny value in list ~S, value ~S~%" list i)
         finally (return (values float-numbers other-numbers symbol-list))))
ý (3.0 9.8), (0 4 5), (APPLE ORANGE BANANA)

;; Without the END preposition, the last AND would apply to the
;; inner IF rather than the outer one.
 (loop for x from 0 to 3
       do (print x)
       if (zerop (mod x 2))
         do (princ " a")
          and if (zerop (floor x 2))
                do (princ " b")
                end
          and do (princ " c"))
Ö 0  a b c
Ö 1
Ö 2  a c
Ö 3
ý NIL


File: chris-ansicl.info,  Node: Notes about Loop,  Prev: Examples of Miscellaneous Loop Features,  Up: The LOOP Facility

6.1.9 Notes about Loop
----------------------

Types can be supplied for loop variables.  It is not necessary to
supply a type for any variable, but supplying the type can ensure that
the variable has a correctly typed initial value, and it can also
enable compiler optimizations (depending on the implementation).

The clause ÿrepeatþ n ... is roughly equivalent to a clause such as

 (loop for internal-variable downfrom (- n 1) to 0 ...)

but in some implementations, the ÿrepeatþ construct might be more
efficient.

Within the executable parts of the loop clauses and around the entire
ÿloopþ form, variables can be bound by using ÿletþ.

Use caution when using a variable named ÿITþ (in any package) in
connection with ÿloopþ, since ÿitþ is a loop keyword that can be used
in place of a form in certain contexts.

There is no standardized mechanism for users to add extensions to
ÿloopþ.


File: chris-ansicl.info,  Node: do; do*,  Next: dotimes,  Prev: The LOOP Facility,  Up: Iteration

do, do* (Macro)
===============

Syntax:
.......

 -- Macro: do ({VAR | (var [init-form [step-form]])}*)
          (end-test-form {result-form}*)
          {declaration}* {tag | statement}* ý {result}*

 -- Macro: do* ({VAR | (var [init-form [step-form]])}*)
          (end-test-form {result-form}*)
          {declaration}* {tag | statement}* ý {result}*

Arguments and Values:
.....................

VAR--a symbol.

INIT-FORM--a form.

STEP-FORM--a form.

END-TEST-FORM--a form.

RESULT-FORMS--an implicit progn.

DECLARATION--a declare expression; not evaluated.

TAG--a go tag; not evaluated.

STATEMENT--a compound form; evaluated as described below.

RESULTS--if a ÿreturnþ or ÿreturn-fromþ form is executed, the values
passed from that form; otherwise, the values returned by the
RESULT-FORMS.

Description:
............

ÿdoþ iterates over a group of STATEMENTS while a test condition holds.
ÿdoþ accepts an arbitrary number of iteration VARS which are bound
within the iteration and stepped in parallel.  An initial value may be
supplied for each iteration variable by use of an INIT-FORM.
STEP-FORMS may be used to specify how the VARS should be updated on
succeeding iterations through the loop.  STEP-FORMS may be used both to
generate successive values or to accumulate results.  If the
END-TEST-FORM condition is met prior to an execution of the body, the
iteration terminates.  TAGS label STATEMENTS.

ÿdo*þ is exactly like ÿdoþ except that the bindings and steppings of
the VARS are performed sequentially rather than in parallel.

Before the first iteration, all the INIT-FORMS are evaluated, and each
VAR is bound to the value of its respective INIT-FORM, if supplied.
This is a binding, not an assignment; when the loop terminates, the old
values of those variables will be restored.  For ÿdoþ, all of the
INIT-FORMS are evaluated before any VAR is bound. The INIT-FORMS can
refer to the bindings of the VARS visible before beginning execution of
ÿdoþ.  For ÿdo*þ, the first INIT-FORM is evaluated, then the first VAR
is bound to that value, then the second INIT-FORM is evaluated, then
the second VAR is bound, and so on; in general, the kth INIT-FORM can
refer to the new binding of the jth VAR if j < k, and otherwise to the
old binding of the jth VAR.

At the beginning of each iteration, after processing the variables, the
END-TEST-FORM is evaluated.  If the result is false, execution proceeds
with the body of the ÿdoþ (or ÿdo*þ) form.  If the result is true, the
RESULT-FORMS are evaluated in order as an implicit progn, and then ÿdoþ
or ÿdo*þ returns.

At the beginning of each iteration other than the first, VARS are
updated as follows.  All the STEP-FORMS, if supplied, are evaluated,
from left to right, and the resulting values are assigned to the
respective VARS.  Any VAR that has no associated STEP-FORM is not
assigned to.  For ÿdoþ, all the STEP-FORMS are evaluated before any VAR
is updated; the assignment of values to VARS is done in parallel, as if
by ÿpsetqþ.  Because all of the STEP-FORMS are evaluated before any of
the VARS are altered, a STEP-FORM when evaluated always has access to
the old values of all the VARS, even if other STEP-FORMS precede it.
For ÿdo*þ, the first STEP-FORM is evaluated, then the value is assigned
to the first VAR, then the second STEP-FORM is evaluated, then the
value is assigned to the second VAR, and so on; the assignment of
values to variables is done sequentially, as if by ÿsetqþ.  For either
ÿdoþ or ÿdo*þ, after the VARS have been updated, the END-TEST-FORM is
evaluated as described above, and the iteration continues.

The remainder of the ÿdoþ (or ÿdo*þ) form constitutes an implicit
tagbody.  TAGS may appear within the body of a ÿdoþ loop for use by
ÿgoþ statements appearing in the body (but such ÿgoþ statements may not
appear in the variable specifiers, the END-TEST-FORM, or the
RESULT-FORMS).  When the end of a ÿdoþ body is reached, the next
iteration cycle (beginning with the evaluation of STEP-FORMS) occurs.

An implicit block named ÿnilþ surrounds the entire ÿdoþ (or ÿdo*þ) form.
A ÿreturnþ statement may be used at any point to exit the loop
immediately.

INIT-FORM  is an initial value for the VAR with which it is associated.
If INIT-FORM is omitted, the initial value of VAR is ÿnilþ.  If a
DECLARATION is supplied for a VAR, INIT-FORM must be consistent with
the DECLARATION.

DECLARATIONS can appear at the beginning of a ÿdoþ (or ÿdo*þ) body.
They apply to code in the ÿdoþ (or ÿdo*þ) body, to the bindings of the
ÿdoþ (or ÿdo*þ) VARS, to the STEP-FORMS, to the END-TEST-FORM, and to
the RESULT-FORMS.

Examples:
.........

 (do ((temp-one 1 (1+ temp-one))
       (temp-two 0 (1- temp-two)))
      ((> (- temp-one temp-two) 5) temp-one)) ý 4

 (do ((temp-one 1 (1+ temp-one))
       (temp-two 0 (1+ temp-one)))
      ((= 3 temp-two) temp-one)) ý 3

 (do* ((temp-one 1 (1+ temp-one))
        (temp-two 0 (1+ temp-one)))
       ((= 3 temp-two) temp-one)) ý 2

 (do ((j 0 (+ j 1)))
     (nil)                       ;Do forever.
   (format t "~%Input ~D:" j)
   (let ((item (read)))
     (if (null item) (return)   ;Process items until NIL seen.
         (format t "~&Output ~D: ~S" j item))))
Ö Input 0: banana
Ö Output 0: BANANA
Ö Input 1: (57 boxes)
Ö Output 1: (57 BOXES)
Ö Input 2: NIL
ý NIL

 (setq a-vector (vector 1 nil 3 nil))
 (do ((i 0 (+ i 1))     ;Sets every null element of a-vector to zero.
      (n (array-dimension a-vector 0)))
     ((= i n))
   (when (null (aref a-vector i))
     (setf (aref a-vector i) 0))) ý NIL
a-vector ý #(1 0 3 0)

 (do ((x e (cdr x))
      (oldx x x))
     ((null x))
   body)

is an example of parallel assignment to index variables.  On the first
iteration, the value of ÿoldxþ is whatever value ÿxþ had before the
ÿdoþ was entered.  On succeeding iterations, ÿoldxþ contains the value
that ÿxþ had on the previous iteration.

 (do ((x foo (cdr x))
      (y bar (cdr y))
      (z '() (cons (f (car x) (car y)) z)))
     ((or (null x) (null y))
      (nreverse z)))

does the same thing as ÿ(mapcar #'f foo bar)þ.  The step computation
for ÿzþ is an example of the fact that variables are stepped in
parallel.  Also, the body of the loop is empty.

 (defun list-reverse (list)
        (do ((x list (cdr x))
             (y '() (cons (car x) y)))
            ((endp x) y)))

As an example of nested iterations, consider a data structure that is a
list of conses. The car of each cons is a list of symbols, and the cdr
of each cons is a list of equal length containing corresponding values.
Such a data structure is similar to an association list, but is
divided into "frames"; the overall structure resembles a rib-cage.  A
lookup function on such a data structure might be:

 (defun ribcage-lookup (sym ribcage)
        (do ((r ribcage (cdr r)))
            ((null r) nil)
          (do ((s (caar r) (cdr s))
               (v (cdar r) (cdr v)))
              ((null s))
            (when (eq (car s) sym)
              (return-from ribcage-lookup (car v)))))) ý RIBCAGE-LOOKUP

See Also:
.........

other iteration functions (*Note dolist::, *Note dotimes::, and *Note
loop::) and more primitive functionality (*Note tagbody::, *Note go::,
*Note block::, *Note return::, *Note let::, and *Note setq::)

Notes:
......

If END-TEST-FORM is ÿnilþ, the test will never succeed.  This provides
an idiom for "do forever": the body of the ÿdoþ or ÿdo*þ is executed
repeatedly.  The infinite loop can be terminated by the use of ÿreturnþ,
ÿreturn-fromþ, ÿgoþ to an outer level, or ÿthrowþ.

A ÿdoþ form may be explained in terms of the more primitive forms
ÿblockþ, ÿreturnþ, ÿletþ, ÿloopþ, ÿtagbodyþ, and ÿpsetqþ as follows:

 (block nil
   (let ((var1 init1)
         (var2 init2)
         ...
         (varn initn))
     declarations
     (loop (when end-test (return (progn . result)))
           (tagbody . tagbody)
           (psetq var1 step1
                  var2 step2
                  ...
                  varn stepn))))

ÿdo*þ is similar, except that ÿlet*þ and ÿsetqþ replace the ÿletþ and
ÿpsetqþ, respectively.


File: chris-ansicl.info,  Node: dotimes,  Next: dolist,  Prev: do; do*,  Up: Iteration

dotimes (Macro)
===============

Syntax:
.......

 -- Macro: dotimes (var count-form [result-form]) {declaration}* {tag |
          statement}* ý {result}*

Arguments and Values:
.....................

VAR--a symbol.

COUNT-FORM--a form.

RESULT-FORM--a form.

DECLARATION--a declare expression; not evaluated.

TAG--a go tag; not evaluated.

STATEMENT--a compound form; evaluated as described below.

RESULTS--if a ÿreturnþ or ÿreturn-fromþ form is executed, the values
passed from that form; otherwise, the values returned by the RESULT-FORM
or ÿnilþ if there is no RESULT-FORM.

Description:
............

ÿdotimesþ iterates over a series of integers.

ÿdotimesþ evaluates COUNT-FORM, which should produce an integer.  If
COUNT-FORM is zero or negative, the body is not executed.  ÿdotimesþ
then executes the body once for each integer from 0 up to but not
including the value of COUNT-FORM, in the order in which the TAGS and
STATEMENTS occur, with VAR bound to each integer.  Then RESULT-FORM is
evaluated.  At the time RESULT-FORM is processed, VAR is bound to the
number of times the body was executed.  TAGS label STATEMENTS.

An implicit block named ÿnilþ surrounds ÿdotimesþ.  ÿreturnþ may be
used to terminate the loop immediately without performing any further
iterations, returning zero or more values.

The body of the loop is an implicit tagbody; it may contain tags to
serve as the targets of ÿgoþ statements.  Declarations may appear
before the body of the loop.

The scope of the binding of VAR does not include the COUNT-FORM, but
the RESULT-FORM is included.

It is implementation-dependent whether ÿdotimesþ establishes a new
binding of VAR on each iteration or whether it establishes a binding
for VAR once at the beginning and then ASSIGNS it on any subsequent
iterations.

Examples:
.........

 (dotimes (temp-one 10 temp-one)) ý 10
 (setq temp-two 0) ý 0
 (dotimes (temp-one 10 t) (incf temp-two)) ý T
 temp-two ý 10

Here is an example of the use of ÿdotimesþ in processing strings:

;;; True if the specified subsequence of the string is a
;;; palindrome (reads the same forwards and backwards).
 (defun palindromep (string &optional
                           (start 0)
                           (end (length string)))
   (dotimes (k (floor (- end start) 2) t)
    (unless (char-equal (char string (+ start k))
                        (char string (- end k 1)))
      (return nil))))
 (palindromep "Able was I ere I saw Elba") ý T
 (palindromep "A man, a plan, a canal--Panama!") ý NIL
 (remove-if-not #'alpha-char-p          ;Remove punctuation.
               "A man, a plan, a canal--Panama!")
ý "AmanaplanacanalPanama"
 (palindromep
  (remove-if-not #'alpha-char-p
                "A man, a plan, a canal--Panama!")) ý T
 (palindromep
  (remove-if-not
   #'alpha-char-p
   "Unremarkable was I ere I saw Elba Kramer, nu?")) ý T
 (palindromep
  (remove-if-not
   #'alpha-char-p
   "A man, a plan, a cat, a ham, a yak,
                  a yam, a hat, a canal--Panama!")) ý T

See Also:
.........

*Note do::, *Note dolist::, *Note tagbody::

Notes:
......

ÿgoþ may be used within the body of ÿdotimesþ to transfer control to a
statement labeled by a TAG.


File: chris-ansicl.info,  Node: dolist,  Next: loop,  Prev: dotimes,  Up: Iteration

dolist (Macro)
==============

Syntax:
.......

 -- Macro: dolist (var list-form [result-form]) {declaration}* {tag |
          statement}* ý {result}*

Arguments and Values:
.....................

VAR--a symbol.

LIST-FORM--a form.

RESULT-FORM--a form.

DECLARATION--a declare expression; not evaluated.

TAG--a go tag; not evaluated.

STATEMENT--a compound form; evaluated as described below.

RESULTS--if a ÿreturnþ or ÿreturn-fromþ form is executed, the values
passed from that form; otherwise, the values returned by the RESULT-FORM
or ÿnilþ if there is no RESULT-FORM.

Description:
............

ÿdolistþ iterates over the elements of a list.  The body of ÿdolistþ is
like a ÿtagbodyþ.  It consists of a series of TAGS and STATEMENTS.

ÿdolistþ evaluates LIST-FORM, which should produce a list. It then
executes the body once for each element in the list, in the order in
which the TAGS and STATEMENTS occur, with VAR bound to the element.
Then RESULT-FORM is evaluated.  TAGS label STATEMENTS.

At the time RESULT-FORM is processed, VAR is bound to ÿnilþ.

An implicit block named ÿnilþ surrounds ÿdolistþ.  ÿreturnþ may be used
to terminate the loop immediately without performing any further
iterations, returning zero or more values.

The scope of the binding of VAR does not include the LIST-FORM, but the
RESULT-FORM is included.

It is implementation-dependent whether ÿdolistþ establishes a new
binding of VAR on each iteration or whether it establishes a binding
for VAR once at the beginning and then ASSIGNS it on any subsequent
iterations.

Examples:
.........

 (setq temp-two '()) ý NIL
 (dolist (temp-one '(1 2 3 4) temp-two) (push temp-one temp-two)) ý (4 3 2 1)

 (setq temp-two 0) ý 0
 (dolist (temp-one '(1 2 3 4)) (incf temp-two)) ý NIL
 temp-two ý 4

 (dolist (x '(a b c d)) (prin1 x) (princ " "))
Ö A B C D
ý NIL

See Also:
.........

*Note do::, *Note dotimes::, *Note tagbody::, *Note Section 3.6
(Traversal Rules and Side Effects): Traversal Rules and Side Effects.

Notes:
......

ÿgoþ may be used within the body of ÿdolistþ to transfer control to a
statement labeled by a TAG.


File: chris-ansicl.info,  Node: loop,  Next: loop-finish,  Prev: dolist,  Up: Iteration

loop (Macro)
============

Syntax:
.......

The "simple" ÿloopþ form:

 -- Macro: loop {compound-form}* ý {result}*

The "extended" ÿloopþ form:

 -- Macro: loop [ûname-clause] {ûvariable-clause}* {ûmain-clause}* ý
          {result}*

NAME-CLAUSE::=
     ÿnamedþ NAME

VARIABLE-CLAUSE::=
     ûwith-clause | ûinitial-final | ûfor-as-clause

WITH-CLAUSE::=
     ÿwithþ VAR1 [TYPE-SPEC] [= FORM1] {ÿandþ VAR2 [TYPE-SPEC] [=
     FORM2]}*

MAIN-CLAUSE::=
     ûunconditional | ûaccumulation | ûconditional | ûtermination-test
     | ûinitial-final

INITIAL-FINAL::=
     ÿinitiallyþ {COMPOUND-FORM}+ | ÿfinallyþ {COMPOUND-FORM}+

UNCONDITIONAL::=
     {ÿdoþ | ÿdoingþ} {COMPOUND-FORM}+ | ÿreturnþ {FORM | ÿitþ}

ACCUMULATION::=
     ûlist-accumulation | ûnumeric-accumulation

LIST-ACCUMULATION::=
     {ÿcollectþ | ÿcollectingþ | ÿappendþ | ÿappendingþ | ÿnconcþ |
     ÿnconcingþ} {FORM | ÿitþ}
     [ÿintoþ SIMPLE-VAR]

NUMERIC-ACCUMULATION::=
     {ÿcountþ | ÿcountingþ | ÿsumþ | ÿsummingþ |
     {ÿmaximizeþ | ÿmaximizingþ | ÿminimizeþ | ÿminimizingþ} {FORM |
     ÿitþ}
     [ÿintoþ SIMPLE-VAR] [TYPE-SPEC]

CONDITIONAL::=
     {ÿifþ | ÿwhenþ | ÿunlessþ} FORM ûselectable-clause {ÿandþ
     ûselectable-clause}*
     [ÿelseþ ûselectable-clause {ÿandþ ûselectable-clause}*]
     [ÿendþ]

SELECTABLE-CLAUSE::=
     ûunconditional | ûaccumulation | ûconditional

TERMINATION-TEST::=
     ÿwhileþ FORM | ÿuntilþ FORM | ÿrepeatþ FORM | ÿalwaysþ FORM |
     ÿneverþ FORM | ÿthereisþ FORM

FOR-AS-CLAUSE::=
     {ÿforþ | ÿasþ} ûfor-as-subclause {ÿandþ ûfor-as-subclause}*

FOR-AS-SUBCLAUSE::=
     ûfor-as-arithmetic | ûfor-as-in-list | ûfor-as-on-list |
     ûfor-as-equals-then |
     ûfor-as-across | ûfor-as-hash | ûfor-as-package

FOR-AS-ARITHMETIC::=
     VAR [TYPE-SPEC] ûfor-as-arithmetic-subclause

FOR-AS-ARITHMETIC-SUBCLAUSE::=
     ûarithmetic-up | ûarithmetic-downto | ûarithmetic-downfrom

ARITHMETIC-UP::=
     ù{ÿfromþ | ÿupfromþ} FORM1 | ù{ÿtoþ | ÿuptoþ | ÿbelowþ} FORM2 |
     ùÿbyþ FORM3øú

ARITHMETIC-DOWNTO::=
     ù{ÿfromþ FORM1}¹ | ù{{ÿdowntoþ | ÿaboveþ} FORM2}¹ | ùÿbyþ FORM3ø

ARITHMETIC-DOWNFROM::=
     ù{ÿdownfromþ FORM1}¹ | ù{ÿtoþ | ÿdowntoþ | ÿaboveþ} FORM2 | ùÿbyþ
     FORM3ø

FOR-AS-IN-LIST::=
     VAR [TYPE-SPEC] ÿinþ FORM1 [ÿbyþ STEP-FUN]

FOR-AS-ON-LIST::=
     VAR [TYPE-SPEC] ÿonþ FORM1 [ÿbyþ STEP-FUN]

FOR-AS-EQUALS-THEN::=
     VAR [TYPE-SPEC] = FORM1 [ÿthenþ FORM2]

FOR-AS-ACROSS::=
     VAR [TYPE-SPEC] ÿacrossþ VECTOR

FOR-AS-HASH::=
     VAR [TYPE-SPEC] ÿbeingþ {ÿeachþ | ÿtheþ}
     {{ÿhash-keyþ | ÿhash-keysþ} {ÿinþ | ÿofþ} HASH-TABLE
     {[ÿusingþ (ÿhash-valueþ OTHER-VAR)] |
     {{ÿhash-valueþ | ÿhash-valuesþ} {ÿinþ | ÿofþ} HASH-TABLE
     {[ÿusingþ (ÿhash-keyþ OTHER-VAR)]}

FOR-AS-PACKAGE::=
     VAR [TYPE-SPEC] ÿbeingþ {ÿeachþ | ÿtheþ}
     {ÿsymbolþ | ÿsymbolsþ |
     {ÿpresent-symbolþ | ÿpresent-symbolsþ |
     {ÿexternal-symbolþ | ÿexternal-symbolsþ}
     [{ÿinþ | ÿofþ} PACKAGE]

TYPE-SPEC::=
     ûsimple-type-spec | ûdestructured-type-spec

SIMPLE-TYPE-SPEC::=
     ÿfixnumþ | ÿfloatþ | ÿtþ | ÿnilþ

DESTRUCTURED-TYPE-SPEC::=
     ÿof-typeþ D-TYPE-SPEC

D-TYPE-SPEC::=
     TYPE-SPECIFIER | ÿ(D-TYPE-SPEC . D-TYPE-SPEC)þ

VAR::=
     ûd-var-spec

VAR1::=
     ûd-var-spec

VAR2::=
     ûd-var-spec

OTHER-VAR::=
     ûd-var-spec

D-VAR-SPEC::=
     SIMPLE-VAR | ÿnilþ | (ûd-var-spec ÿ.þ ûd-var-spec)

Arguments and Values:
.....................

COMPOUND-FORM--a compound form.

NAME--a symbol.

SIMPLE-VAR--a symbol (a variable name).

FORM, FORM1, FORM2, FORM3--a form.

STEP-FUN--a form that evaluates to a function of one argument.

VECTOR--a form that evaluates to a vector.

HASH-TABLE--a form that evaluates to a hash table.

PACKAGE--a form that evaluates to a package designator.

TYPE-SPECIFIER--a type specifier.  This might be either an atomic type
specifier or a compound type specifier, which introduces some
additional complications to proper parsing in the face of
destructuring; for further information, see *Note Section 6.1.1.7
(Destructuring): DestructuringLOOPVars.

RESULT--an object.

Description:
............

For details, see *Note Section 6.1 (The LOOP Facility): The LOOP
Facility.

Examples:
.........

;; An example of the simple form of LOOP.
 (defun sqrt-advisor ()
   (loop (format t "~&Number: ")
         (let ((n (parse-integer (read-line) :junk-allowed t)))
           (when (not n) (return))
           (format t "~&The square root of ~D is ~D.~%" n (sqrt n)))))
ý SQRT-ADVISOR
 (sqrt-advisor)
Ö Number: 5ô
Ö The square root of 5 is 2.236068.
Ö Number: 4ô
Ö The square root of 4 is 2.
Ö Number: doneô
ý NIL

;; An example of the extended form of LOOP.
 (defun square-advisor ()
   (loop as n = (progn (format t "~&Number: ")
                       (parse-integer (read-line) :junk-allowed t))
         while n
         do (format t "~&The square of ~D is ~D.~%" n (* n n))))
ý SQUARE-ADVISOR
 (square-advisor)
Ö Number: 4ô
Ö The square of 4 is 16.
Ö Number: 23ô
Ö The square of 23 is 529.
Ö Number: doneô
ý NIL

;; Another example of the extended form of LOOP.
 (loop for n from 1 to 10
       when (oddp n)
         collect n)
ý (1 3 5 7 9)

See Also:
.........

*Note do::, *Note dolist::, *Note dotimes::, *Note return::, *Note
go::, *Note throw::, *Note Section 6.1.1.7 (Destructuring):
DestructuringLOOPVars.

Notes:
......

Except that ÿloop-finishþ cannot be used within a simple ÿloopþ form, a
simple ÿloopþ form is related to an extended ÿloopþ form in the
following way:

 (loop {compound-form}*) Õ (loop do {compound-form}*)


File: chris-ansicl.info,  Node: loop-finish,  Prev: loop,  Up: Iteration

loop-finish (Local Macro)
=========================

Syntax:
.......

 -- Macro: loop-finish <no arguments> ý|

Description:
............

The ÿloop-finishþ macro can be used lexically within an extended ÿloopþ
form to terminate that form "normally."  That is, it transfers control
to the loop epilogue of the lexically innermost extended ÿloopþ form.
This permits execution of any ÿfinallyþ clause (for effect) and the
return of any accumulated result.

Examples:
.........

;; Terminate the loop, but return the accumulated count.
 (loop for i in '(1 2 3 stop-here 4 5 6)
       when (symbolp i) do (loop-finish)
       count i)
ý 3

;; The preceding loop is equivalent to:
 (loop for i in '(1 2 3 stop-here 4 5 6)
       until (symbolp i)
       count i)
ý 3

;; While LOOP-FINISH can be used can be used in a variety of
;; situations it is really most needed in a situation where a need
;; to exit is detected at other than the loop's `top level'
;; (where UNTIL or WHEN often work just as well), or where some
;; computation must occur between the point where a need to exit is
;; detected and the point where the exit actually occurs.  For example:
 (defun tokenize-sentence (string)
   (macrolet ((add-word (wvar svar)
                `(when ,wvar
                   (push (coerce (nreverse ,wvar) 'string) ,svar)
                   (setq ,wvar nil))))
     (loop with word = '() and sentence = '() and endpos = nil
           for i below (length string)
           do (let ((char (aref string i)))
                (case char
                  (#\Space (add-word word sentence))
                  (#\. (setq endpos (1+ i)) (loop-finish))
                  (otherwise (push char word))))
           finally (add-word word sentence)
                   (return (values (nreverse sentence) endpos)))))
ý TOKENIZE-SENTENCE

 (tokenize-sentence "this is a sentence. this is another sentence.")
ý ("this" "is" "a" "sentence"), 19

 (tokenize-sentence "this is a sentence")
ý ("this" "is" "a" "sentence"), NIL

Side Effects:
.............

Transfers control.

Exceptional Situations:
.......................

Whether or not ÿloop-finishþ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ÿloop-finishþ are the same as for symbols in the
ÿCOMMON-LISPþ package which are fbound in the global environment.  The
consequences of attempting to use ÿloop-finishþ outside of ÿloopþ are
undefined.

See Also:
.........

*Note loop::, *Note Section 6.1 (The LOOP Facility): The LOOP Facility.

Notes:
......


File: chris-ansicl.info,  Node: Objects,  Next: Structures,  Prev: Iteration,  Up: Top

7 Objects
*********

* Menu:

* Object Creation and Initialization::
* Changing the Class of an Instance::
* Reinitializing an Instance::
* Meta-Objects::
* Slots::
* Generic Functions and Methods::

Dictionary

* function-keywords::
* ensure-generic-function::
* allocate-instance::
* reinitialize-instance::
* shared-initialize (Standard Generic Function)::
* update-instance-for-different-class::
* update-instance-for-redefined-class::
* change-class::
* slot-boundp::
* slot-exists-p::
* slot-makunbound::
* slot-missing::
* slot-unbound::
* slot-value::
* method-qualifiers::
* no-applicable-method::
* no-next-method::
* remove-method::
* make-instance::
* make-instances-obsolete::
* make-load-form::
* make-load-form-saving-slots::
* with-accessors::
* with-slots::
* defclass::
* defgeneric::
* defmethod::
* find-class::
* next-method-p::
* call-method; make-method::
* call-next-method::
* compute-applicable-methods::
* define-method-combination::
* find-method::
* add-method::
* initialize-instance (Standard Generic Function)::
* class-name::
* setf class-name::
* class-of::
* unbound-slot::
* unbound-slot-instance::


File: chris-ansicl.info,  Node: Object Creation and Initialization,  Next: Changing the Class of an Instance,  Up: Objects

7.1 Object Creation and Initialization
======================================

The generic function ÿmake-instanceþ creates and returns a new instance
of a class.  The first argument is a class or the name of a class, and
the remaining arguments form an "initialization argument list".

The initialization of a new instance consists of several distinct
steps, including the following: combining the explicitly supplied
initialization arguments with default values for the unsupplied
initialization arguments, checking the validity of the initialization
arguments, allocating storage for the instance, filling slots with
values, and executing user-supplied methods that perform additional
initialization.  Each step of ÿmake-instanceþ is implemented by a
generic function to provide a mechanism for customizing that step.  In
addition, ÿmake-instanceþ is itself a generic function and thus also
can be customized.

The object system specifies system-supplied primary methods for each
step and thus specifies a well-defined standard behavior for the entire
initialization process.  The standard behavior provides four simple
mechanisms for controlling initialization:

   * Declaring a symbol to be an initialization argument for a slot.
     An initialization argument is declared by using the :initarg slot
     option to ÿdefclassþ.  This provides a mechanism for supplying a
     value for a slot in a call to ÿmake-instanceþ.

   * Supplying a default value form for an initialization argument.
     Default value forms for initialization arguments are defined by
     using the :default-initargs class option to ÿdefclassþ.  If an
     initialization argument is not explicitly provided as an argument
     to ÿmake-instanceþ, the default value form is evaluated in the
     lexical environment of the ÿdefclassþ form that defined it, and
     the resulting value is used as the value of the initialization
     argument.

   * Supplying a default initial value form for a slot.  A default
     initial value form for a slot is defined by using the :initform
     slot option to ÿdefclassþ.  If no initialization argument
     associated with that slot is given as an argument to
     ÿmake-instanceþ or is defaulted by :default-initargs, this default
     initial value form is evaluated in the lexical environment of the
     ÿdefclassþ form that defined it, and the resulting value is stored
     in the slot.  The :initform form for a local slot may be used when
     creating an instance, when updating an instance to conform to a
     redefined class, or when updating an instance to conform to the
     definition of a different class. The :initform form for a shared
     slot may be used when defining or re-defining the class.

   * Defining methods for ÿinitialize-instanceþ and
     ÿshared-initializeþ.  The slot-filling behavior described above is
     implemented by a system-supplied primary method for
     ÿinitialize-instanceþ which invokes ÿshared-initializeþ. The
     generic function ÿshared-initializeþ implements the parts of
     initialization shared by these four situations: when making an
     instance, when re-initializing an instance, when updating an
     instance to conform to a redefined class, and when updating an
     instance to conform to the definition of a different class. The
     system-supplied primary method for ÿshared-initializeþ directly
     implements the slot-filling behavior described above, and
     ÿinitialize-instanceþ simply invokes ÿshared-initializeþ.

* Menu:

* Initialization Arguments::
* Declaring the Validity of Initialization Arguments::
* Defaulting of Initialization Arguments::
* Rules for Initialization Arguments::
* Shared-Initialize::
* Initialize-Instance::
* Definitions of Make-Instance and Initialize-Instance::


File: chris-ansicl.info,  Node: Initialization Arguments,  Next: Declaring the Validity of Initialization Arguments,  Up: Object Creation and Initialization

7.1.1 Initialization Arguments
------------------------------

An initialization argument controls object creation and initialization.
It is often convenient to use keyword symbols to name initialization
arguments, but the name of an initialization argument can be any
symbol, including ÿnilþ.  An initialization argument can be used in two
ways: to fill a slot with a value or to provide an argument for an
initialization method.  A single initialization argument can be used
for both purposes.

An initialization argument list is a property list of initialization
argument names and values.  Its structure is identical to a property
list and also to the portion of an argument list processed for ÿ&keyþ
parameters.  As in those lists, if an initialization argument name
appears more than once in an initialization argument list, the leftmost
occurrence supplies the value and the remaining occurrences are
ignored.  The arguments to ÿmake-instanceþ (after the first argument)
form an initialization argument list.

An initialization argument can be associated with a slot.  If the
initialization argument has a value in the initialization argument
list, the value is stored into the slot of the newly created object,
overriding any :initform form associated with the slot.  A single
initialization argument can initialize more than one slot.  An
initialization argument that initializes a shared slot stores its value
into the shared slot, replacing any previous value.

An initialization argument can be associated with a method.  When an
object is created and a particular initialization argument is supplied,
the generic functions ÿinitialize-instanceþ, ÿshared-initializeþ, and
ÿallocate-instanceþ are called with that initialization argument's name
and value as a keyword argument pair.  If a value for the
initialization argument is not supplied in the initialization argument
list, the method's lambda list supplies a default value.

Initialization arguments are used in four situations: when making an
instance, when re-initializing an instance, when updating an instance
to conform to a redefined class, and when updating an instance to
conform to the definition of a different class.

Because initialization arguments are used to control the creation and
initialization of an instance of some particular class, we say that an
initialization argument is "an initialization argument for" that class.


File: chris-ansicl.info,  Node: Declaring the Validity of Initialization Arguments,  Next: Defaulting of Initialization Arguments,  Prev: Initialization Arguments,  Up: Object Creation and Initialization

7.1.2 Declaring the Validity of Initialization Arguments
--------------------------------------------------------

Initialization arguments are checked for validity in each of the four
situations that use them.  An initialization argument may be valid in
one situation and not another. For example, the system-supplied primary
method for ÿmake-instanceþ defined for the class ÿstandard-classþ
checks the validity of its initialization arguments and signals an
error if an initialization argument is supplied that is not declared as
valid in that situation.

There are two means for declaring initialization arguments valid.

   * Initialization arguments that fill slots are declared as valid by
     the :initarg slot option to ÿdefclassþ.  The :initarg slot option
     is inherited from superclasses.  Thus the set of valid
     initialization arguments that fill slots for a class is the union
     of the initialization arguments that fill slots declared as valid
     by that class and its superclasses.  Initialization arguments that
     fill slots are valid in all four contexts.

   * Initialization arguments that supply arguments to methods are
     declared as valid by defining those methods.  The keyword name of
     each keyword parameter specified in the method's lambda list
     becomes an initialization argument for all classes for which the
     method is applicable.  The presence of &allow-other-keys in the
     lambda list of an applicable method disables validity checking of
     initialization arguments.  Thus method inheritance controls the
     set of valid initialization arguments that supply arguments to
     methods.  The generic functions for which method definitions serve
     to declare initialization arguments valid are as follows:

        - Making an instance of a class: ÿallocate-instanceþ,
          ÿinitialize-instanceþ, and ÿshared-initializeþ.
          Initialization arguments declared as valid by these methods
          are valid when making an instance of a class.

        - Re-initializing an instance: ÿreinitialize-instanceþ and
          ÿshared-initializeþ.  Initialization arguments declared as
          valid by these methods are valid when re-initializing an
          instance.

        - Updating an instance to conform to a redefined class:
          ÿupdate-instance-for-redefined-classþ and ÿshared-initializeþ.
          Initialization arguments declared as valid by these methods
          are valid when updating an instance to conform to a redefined
          class.

        - Updating an instance to conform to the definition of a
          different class: ÿupdate-instance-for-different-classþ and
          ÿshared-initializeþ.  Initialization arguments declared as
          valid by these methods are valid when updating an instance to
          conform to the definition of a different class.

The set of valid initialization arguments for a class is the set of
valid initialization arguments that either fill slots or supply
arguments to methods, along with the predefined initialization argument
:allow-other-keys.  The default value for :allow-other-keys is ÿnilþ.
Validity checking of initialization arguments is disabled if the value
of the initialization argument :allow-other-keys is true.


File: chris-ansicl.info,  Node: Defaulting of Initialization Arguments,  Next: Rules for Initialization Arguments,  Prev: Declaring the Validity of Initialization Arguments,  Up: Object Creation and Initialization

7.1.3 Defaulting of Initialization Arguments
--------------------------------------------

A default value form can be supplied for an initialization argument by
using the :default-initargs class option.  If an initialization
argument is declared valid by some particular class, its default  value
form might be specified by a different class.  In this case
:default-initargs is used to supply a default value for an inherited
initialization argument.

The :default-initargs option is used only to provide default values for
initialization arguments; it does not declare a symbol as a valid
initialization argument name.  Furthermore, the :default-initargs
option is used only to provide default values for initialization
arguments when making an instance.

The argument to the :default-initargs class option is a list of
alternating initialization argument names and forms.  Each form is the
default  value form for the corresponding initialization argument.  The
default  value form of an initialization argument is used and evaluated
only if that initialization argument does not appear in the arguments
to ÿmake-instanceþ and is not defaulted by a more specific class.  The
default  value form is evaluated in the lexical environment of the
ÿdefclassþ form that supplied it; the resulting value is used as the
initialization argument's value.

The initialization arguments supplied to ÿmake-instanceþ are combined
with defaulted initialization arguments to produce a defaulted
initialization argument list. A defaulted initialization argument list
is a list of alternating initialization argument names and values in
which unsupplied initialization arguments are defaulted and in which
the explicitly supplied initialization arguments appear earlier in the
list than the defaulted initialization arguments.  Defaulted
initialization arguments are ordered according to the order in the
class precedence list of the classes that supplied the default values.

There is a distinction between the purposes of the :default-initargs
and the :initform options with respect to the initialization of slots.
The :default-initargs class option provides a mechanism for the user to
give a default  value form for an initialization argument without
knowing whether the initialization argument initializes a slot or is
passed to a method.  If that initialization argument is not explicitly
supplied in a call to ÿmake-instanceþ, the default  value form is used,
just as if it had been supplied in the call.  In contrast, the
:initform slot option provides a mechanism for the user to give a
default initial value form for a slot.  An :initform form is used to
initialize a slot only if no initialization argument associated with
that slot is given as an argument to ÿmake-instanceþ or is defaulted by
:default-initargs.

The order of evaluation of default value forms for initialization
arguments and the order of evaluation of :initform forms are undefined.
If the order of evaluation is important, ÿinitialize-instanceþ or
ÿshared-initializeþ methods should be used instead.


File: chris-ansicl.info,  Node: Rules for Initialization Arguments,  Next: Shared-Initialize,  Prev: Defaulting of Initialization Arguments,  Up: Object Creation and Initialization

7.1.4 Rules for Initialization Arguments
----------------------------------------

The :initarg slot option may be specified more than once for a given
slot.

The following rules specify when initialization arguments may be
multiply defined:

   * A given initialization argument can be used to initialize more
     than one slot if the same initialization argument name appears in
     more than one :initarg slot option.

   * A given initialization argument name can appear in the lambda list
     of more than one initialization method.

   * A given initialization argument name can appear both in an
     :initarg slot option and in the lambda list of an initialization
     method.

If two or more initialization arguments that initialize the same slot
are given in the arguments to ÿmake-instanceþ, the leftmost of these
initialization arguments in the initialization argument list supplies
the value, even if the initialization arguments have different names.

If two or more different initialization arguments that initialize the
same slot have default values and none is given explicitly in the
arguments to ÿmake-instanceþ, the initialization argument that appears
in a :default-initargs class option in the most specific of the classes
supplies the value. If a single :default-initargs class option
specifies two or more initialization arguments that initialize the same
slot and none is given explicitly in the arguments to ÿmake-instanceþ,
the leftmost in the :default-initargs class option supplies the value,
and the values of the remaining default value forms are ignored.

Initialization arguments given explicitly in the arguments to
ÿmake-instanceþ appear to the left of defaulted initialization
arguments. Suppose that the classes Cá and Cà supply the values of
defaulted initialization arguments for different slots, and suppose
that Cá is more specific than Cà; then the defaulted initialization
argument whose value is supplied by Cá is to the left of the defaulted
initialization argument whose value is supplied by Cà in the defaulted
initialization argument list.  If a single :default-initargs class
option supplies the values of initialization arguments for two
different slots, the initialization argument whose value is specified
farther to the left in the :default-initargs class option appears
farther to the left in the defaulted initialization argument list.

If a slot has both an :initform form and an :initarg slot option, and
the initialization argument is defaulted using :default-initargs or is
supplied to ÿmake-instanceþ, the captured :initform form is neither
used nor evaluated.

The following is an example of the above rules:

 (defclass q () ((x :initarg a)))
 (defclass r (q) ((x :initarg b))
   (:default-initargs a 1 b 2))

Form                             Defaulted              Contents
                                 Initialization         of Slot X
                                 Argument List          
-------------------------------------------------------------------- 
(make-instance 'r)               (a 1 b 2)              1
(make-instance 'r 'a 3)          (a 3 b 2)              3
(make-instance 'r 'b 4)          (b 4 a 1)              4
(make-instance 'r 'a 1 'a 2)     (a 1 a 2 b 2)          1


File: chris-ansicl.info,  Node: Shared-Initialize,  Next: Initialize-Instance,  Prev: Rules for Initialization Arguments,  Up: Object Creation and Initialization

7.1.5 Shared-Initialize
-----------------------

The generic function ÿshared-initializeþ is used to fill the slots of
an instance using initialization arguments and :initform forms when an
instance is created, when an instance is re-initialized, when an
instance is updated to conform to a redefined class, and when an
instance is updated to conform to a different class.  It uses standard
method combination. It takes the following arguments: the instance to
be initialized, a specification of a set of names of slots accessible
in that instance, and any number of initialization arguments.  The
arguments after the first two must form an initialization argument list.

The second argument to ÿshared-initializeþ may be one of the following:

   * It can be a (possibly empty) list of slot names, which specifies
     the set of those slot names.

   * It can be the symbol ÿtþ, which specifies the set of all of the
     slots.

There is a system-supplied primary method for ÿshared-initializeþ whose
first parameter specializer is the class ÿstandard-objectþ.  This
method behaves as follows on each slot, whether shared or local:

   * If an initialization argument in the initialization argument list
     specifies a value for that slot, that value is stored into the
     slot, even if a value has already been stored in the slot before
     the method is run.  The affected slots are independent of which
     slots are indicated by the second argument to ÿshared-initializeþ.

   * Any slots indicated by the second argument that are still unbound
     at this point are initialized according to their :initform forms.
     For any such slot that has an :initform form, that form is
     evaluated in the lexical environment of its defining ÿdefclassþ
     form and the result is stored into the slot.  For example, if a
     before method stores a value in the slot, the :initform form will
     not be used to supply a value for the slot.  If the second
     argument specifies a name that does not correspond to any slots
     accessible in the instance, the results are unspecified.

   * The rules mentioned in *Note Section 7.1.4 (Rules for
     Initialization Arguments): Rules for Initialization Arguments. are
     obeyed.

The generic function ÿshared-initializeþ is called by the
system-supplied primary methods for ÿreinitialize-instanceþ,
ÿupdate-instance-for-different-classþ,
ÿupdate-instance-for-redefined-classþ, and ÿinitialize-instanceþ.
Thus, methods can be written for ÿshared-initializeþ to specify actions
that should be taken in all of these contexts.


File: chris-ansicl.info,  Node: Initialize-Instance,  Next: Definitions of Make-Instance and Initialize-Instance,  Prev: Shared-Initialize,  Up: Object Creation and Initialization

7.1.6 Initialize-Instance
-------------------------

The generic function ÿinitialize-instanceþ is called by ÿmake-instanceþ
to initialize a newly created instance.  It uses standard method
combination.  Methods for ÿinitialize-instanceþ can be defined in order
to perform any initialization that cannot be achieved simply by
supplying initial values for slots.

During initialization, ÿinitialize-instanceþ is invoked after the
following actions have been taken:

   * The defaulted initialization argument list has been computed by
     combining the supplied initialization argument list with any
     default initialization arguments for the class.

   * The validity of the defaulted initialization argument list has
     been checked.  If any of the initialization arguments has not been
     declared as valid, an error is signaled.

   * A new instance whose slots are unbound has been created.

The generic function ÿinitialize-instanceþ is called with the new
instance and the defaulted initialization arguments.  There is a
system-supplied primary method for ÿinitialize-instanceþ whose
parameter specializer is the class ÿstandard-objectþ.  This method
calls the generic function ÿshared-initializeþ to fill in the slots
according to the initialization arguments and the :initform forms for
the slots; the generic function ÿshared-initializeþ is called with the
following arguments: the instance, ÿtþ, and the defaulted
initialization arguments.

Note that ÿinitialize-instanceþ provides the defaulted initialization
argument list in its call to ÿshared-initializeþ, so the first step
performed by the system-supplied primary method for ÿshared-initializeþ
takes into account both the initialization arguments provided in the
call to ÿmake-instanceþ and the defaulted initialization argument list.

Methods for ÿinitialize-instanceþ can be defined to specify actions to
be taken when an instance is initialized.  If only after methods for
ÿinitialize-instanceþ are defined, they will be run after the
system-supplied primary method for initialization and therefore will
not interfere with the default behavior of ÿinitialize-instanceþ.

The object system provides two functions that are useful in the bodies
of ÿinitialize-instanceþ methods.  The function ÿslot-boundpþ returns a
generic boolean value that indicates whether a specified slot has a
value; this provides a mechanism for writing after methods for
ÿinitialize-instanceþ that initialize slots only if they have not
already been initialized.  The function ÿslot-makunboundþ causes the
slot to have no value.


File: chris-ansicl.info,  Node: Definitions of Make-Instance and Initialize-Instance,  Prev: Initialize-Instance,  Up: Object Creation and Initialization

7.1.7 Definitions of Make-Instance and Initialize-Instance
----------------------------------------------------------

The generic function ÿmake-instanceþ behaves as if it were defined as
follows, except that certain optimizations are permitted:

 (defmethod make-instance ((class standard-class) &rest initargs)
   ...
   (let ((instance (apply #'allocate-instance class initargs)))
     (apply #'initialize-instance instance initargs)
     instance))

 (defmethod make-instance ((class-name symbol) &rest initargs)
   (apply #'make-instance (find-class class-name) initargs))

The elided code in the definition of ÿmake-instanceþ augments the
ÿinitargsþ with any defaulted initialization arguments and checks the
resulting initialization arguments to determine whether an
initialization argument was supplied that neither filled a slot nor
supplied an argument to an applicable method.

The generic function ÿinitialize-instanceþ behaves as if it were
defined as follows, except that certain optimizations are permitted:

 (defmethod initialize-instance ((instance standard-object) &rest initargs)
   (apply #'shared-initialize instance t initargs)))

These procedures can be customized.

Customizing at the Programmer Interface level includes using the
:initform, :initarg, and :default-initargs options to ÿdefclassþ, as
well as defining methods for ÿmake-instanceþ, ÿallocate-instanceþ, and
ÿinitialize-instanceþ.  It is also possible to define methods for
ÿshared-initializeþ, which would be invoked by the generic functions
ÿreinitialize-instanceþ, ÿupdate-instance-for-redefined-classþ,
ÿupdate-instance-for-different-classþ, and ÿinitialize-instanceþ.  The
meta-object level supports additional customization.

Implementations are permitted to make certain optimizations to
ÿinitialize-instanceþ and ÿshared-initializeþ.  The description of
ÿshared-initializeþ in Chapter 7 mentions the possible optimizations.


File: chris-ansicl.info,  Node: Changing the Class of an Instance,  Next: Reinitializing an Instance,  Prev: Object Creation and Initialization,  Up: Objects

7.2 Changing the Class of an Instance
=====================================

The function ÿchange-classþ can be used to change the class of an
instance from its current class, C_{from}, to a different class,
C_{to}; it changes the structure of the instance to conform to the
definition of the class C_{to}.

Note that changing the class of an instance may cause slots to be added
or deleted.  Changing the class of an instance does not change its
identity as defined by the ÿeqþ function.

When ÿchange-classþ is invoked on an instance, a two-step updating
process takes place.  The first step modifies the structure of the
instance by adding new local slots and discarding local slots that are
not specified in the new version of the instance.  The second step
initializes the newly added local slots and performs any other
user-defined actions. These two steps are further described in the two
following sections.

* Menu:

* Modifying the Structure of the Instance::
* Initializing Newly Added Local Slots::
* Customizing the Change of Class of an Instance::


File: chris-ansicl.info,  Node: Modifying the Structure of the Instance,  Next: Initializing Newly Added Local Slots,  Up: Changing the Class of an Instance

7.2.1 Modifying the Structure of the Instance
---------------------------------------------

In order to make the instance conform to the class C_{to}, local slots
specified by the class C_{to} that are not specified by the class
C_{from} are added, and local slots not specified by the class C_{to}
that are specified by the class C_{from} are discarded.

The values of local slots specified by both the class C_{to} and the
class C_{from} are retained. If such a local slot was unbound, it
remains unbound.

The values of slots specified as shared in the class C_{from} and as
local in the class C_{to} are retained.

This first step of the update does not affect the values of any shared
slots.


File: chris-ansicl.info,  Node: Initializing Newly Added Local Slots,  Next: Customizing the Change of Class of an Instance,  Prev: Modifying the Structure of the Instance,  Up: Changing the Class of an Instance

7.2.2 Initializing Newly Added Local Slots
------------------------------------------

The second step of the update initializes the newly added slots and
performs any other user-defined actions.  This step is implemented by
the generic function ÿupdate-instance-for-different-classþ.  The
generic function ÿupdate-instance-for-different-classþ is invoked by
ÿchange-classþ after the first step of the update has been completed.

The generic function ÿupdate-instance-for-different-classþ is invoked
on arguments computed by ÿchange-classþ.  The first argument passed is
a copy of the instance being updated and is an instance of the class
C_{from}; this copy has dynamic extent within the generic function
ÿchange-classþ.  The second argument is the instance as updated so far
by ÿchange-classþ and is an instance of the class C_{to}.  The
remaining arguments are an initialization argument list.

There is a system-supplied primary method for
ÿupdate-instance-for-different-classþ that has two parameter
specializers, each of which is the class ÿstandard-objectþ.  First this
method checks the validity of initialization arguments and signals an
error if an initialization argument is supplied that is not declared as
valid.  (For more information, see *Note Section 7.1.2 (Declaring the
Validity of Initialization Arguments): Declaring the Validity of
Initialization Arguments.)  Then it calls the generic function
ÿshared-initializeþ with the following arguments: the new instance, a
list of names of the newly added slots, and the initialization
arguments it received.


File: chris-ansicl.info,  Node: Customizing the Change of Class of an Instance,  Prev: Initializing Newly Added Local Slots,  Up: Changing the Class of an Instance

7.2.3 Customizing the Change of Class of an Instance
----------------------------------------------------

Methods for ÿupdate-instance-for-different-classþ may be defined to
specify actions to be taken when an instance is updated.  If only after
methods for ÿupdate-instance-for-different-classþ are defined, they
will be run after the system-supplied primary method for initialization
and will not interfere with the default behavior of
ÿupdate-instance-for-different-classþ.

Methods for ÿshared-initializeþ may be defined to customize class
redefinition.  For more information, see *Note Section 7.1.5
(Shared-Initialize): Shared-Initialize.


File: chris-ansicl.info,  Node: Reinitializing an Instance,  Next: Meta-Objects,  Prev: Changing the Class of an Instance,  Up: Objects

7.3 Reinitializing an Instance
==============================

The generic function ÿreinitialize-instanceþ may be used to change the
values of slots according to initialization arguments.

The process of reinitialization changes the values of some slots and
performs any user-defined actions.  It does not modify the structure of
an instance to add or delete slots, and it does not use any :initform
forms to initialize slots.

The generic function ÿreinitialize-instanceþ may be called directly.
It takes one required argument, the instance.  It also takes any number
of initialization arguments to be used by methods for
ÿreinitialize-instanceþ or for ÿshared-initializeþ. The arguments after
the required instance must form an initialization argument list.

There is a system-supplied primary method for ÿreinitialize-instanceþ
whose parameter specializer is the class ÿstandard-objectþ.  First this
method checks the validity of initialization arguments and signals an
error if an initialization argument is supplied that is not declared as
valid.  (For more information, see *Note Section 7.1.2 (Declaring the
Validity of Initialization Arguments): Declaring the Validity of
Initialization Arguments.)  Then it calls the generic function
ÿshared-initializeþ with the following arguments: the instance, ÿnilþ,
and the initialization arguments it received.

* Menu:

* Customizing Reinitialization::


File: chris-ansicl.info,  Node: Customizing Reinitialization,  Up: Reinitializing an Instance

7.3.1 Customizing Reinitialization
----------------------------------

Methods for ÿreinitialize-instanceþ may be defined to specify actions
to be taken when an instance is updated.  If only after methods for
ÿreinitialize-instanceþ are defined, they will be run after the
system-supplied primary method for initialization and therefore will
not interfere with the default behavior of ÿreinitialize-instanceþ.

Methods for ÿshared-initializeþ may be defined to customize class
redefinition.  For more information, see *Note Section 7.1.5
(Shared-Initialize): Shared-Initialize.


File: chris-ansicl.info,  Node: Meta-Objects,  Next: Slots,  Prev: Reinitializing an Instance,  Up: Objects

7.4 Meta-Objects
================

The implementation of the object system manipulates classes, methods,
and generic functions.  The object system contains a set of generic
functions defined by methods on classes; the behavior of those generic
functions defines the behavior of the object system.  The instances of
the classes on which those methods are defined are called meta-objects.

* Menu:

* Standard Meta-objects::


File: chris-ansicl.info,  Node: Standard Meta-objects,  Up: Meta-Objects

7.4.1 Standard Meta-objects
---------------------------

The object system supplies a set of meta-objects, called standard
meta-objects.  These include the class ÿstandard-objectþ and instances
of the classes ÿstandard-methodþ, ÿstandard-generic-functionþ, and
ÿmethod-combinationþ.

   * The class ÿstandard-methodþ is the default class of methods
     defined by the ÿdefmethodþ and ÿdefgenericþ forms.

   * The class ÿstandard-generic-functionþ is the default class of
     generic functions defined by the forms ÿdefmethodþ, ÿdefgenericþ,
     and ÿdefclassþ.

   * The class named ÿstandard-objectþ is an instance of the class
     ÿstandard-classþ and is a superclass of every class that is an
     instance of ÿstandard-classþ except itself and ÿstructure-classþ.

   * Every method combination object is an instance of a subclass of
     type ÿmethod-combinationþ.


File: chris-ansicl.info,  Node: Slots,  Next: Generic Functions and Methods,  Prev: Meta-Objects,  Up: Objects

7.5 Slots
=========

* Menu:

* Introduction to Slots::
* Accessing Slots::
* Inheritance of Slots and Slot Options::


File: chris-ansicl.info,  Node: Introduction to Slots,  Next: Accessing Slots,  Up: Slots

7.5.1 Introduction to Slots
---------------------------

An object of metaclass ÿstandard-classþ has zero or more named slots.
The slots of an object are determined by the class of the object.  Each
slot can hold one value.

The name of a slot is a symbol that is syntactically valid for use as a
variable name.

When a slot does not have a value, the slot is said to be unbound.
When an unbound slot is read,

the generic function ÿslot-unboundþ is invoked. The system-supplied
primary method for ÿslot-unboundþ on class ÿtþ signals an error.  If
ÿslot-unboundþ returns, its primary value is used that time as the
value of the slot.

The default initial value form for a slot is defined by the :initform
slot option.  When the :initform form is used to supply a value, it is
evaluated in the lexical environment in which the ÿdefclassþ form was
evaluated. The :initform along with the lexical environment in which
the ÿdefclassþ form was evaluated is called a captured initialization
form.  For more details, see *Note Section 7.1 (Object Creation and
Initialization): Object Creation and Initialization.

A local slot is defined to be a slot that is accessible to exactly one
instance, namely the one in which the slot is allocated.  A shared slot
is defined to be a slot that is visible to more than one instance of a
given class and its subclasses.

A class is said to define a slot with a given name when the ÿdefclassþ
form for that class contains a slot specifier with that name.  Defining
a local slot does not immediately create a slot; it causes a slot to be
created each time an instance of the class is created.  Defining a
shared slot immediately creates a slot.

The :allocation slot option to ÿdefclassþ controls the kind of slot
that is defined.  If the value of the :allocation slot option is
:instance, a local slot is created.  If the value of :allocation is
:class, a shared slot is created.

A slot is said to be accessible in an instance of a class if the slot
is defined by the class of the instance or is inherited from a
superclass of that class.  At most one slot of a given name can be
accessible in an instance.  A shared slot defined by a class is
accessible in all instances of that class.  A detailed explanation of
the inheritance of slots is given in *Note Section 7.5.3 (Inheritance
of Slots and Slot Options): Inheritance of Slots and Slot Options.


File: chris-ansicl.info,  Node: Accessing Slots,  Next: Inheritance of Slots and Slot Options,  Prev: Introduction to Slots,  Up: Slots

7.5.2 Accessing Slots
---------------------

Slots can be accessed in two ways: by use of the primitive function
ÿslot-valueþ and by use of generic functions generated by the
ÿdefclassþ form.

The function ÿslot-valueþ can be used with any of the slot names
specified in the ÿdefclassþ form to access a specific slot accessible
in an instance of the given class.

The macro ÿdefclassþ provides syntax for generating methods to read and
write slots.  If a reader method is requested, a method is
automatically generated for reading the value of the slot, but no
method for storing a value into it is generated.  If a writer method is
requested, a method is automatically generated for storing a value into
the slot, but no method for reading its value is generated.  If an
accessor method is requested, a method for reading the value of the
slot and a method for storing a value into the slot are automatically
generated.  Reader and writer methods are implemented using
ÿslot-valueþ.

When a reader or writer method is specified for a slot, the name of the
generic function to which the generated method belongs is directly
specified.  If the name specified for the writer method is the symbol
ÿnameþ, the name of the generic function for writing the slot is the
symbol ÿnameþ, and the generic function takes two arguments: the new
value and the instance, in that order.  If the name specified for the
accessor method is the symbol ÿnameþ, the name of the generic function
for reading the slot is the symbol ÿnameþ, and the name of the generic
function for writing the slot is the list ÿ(setf name)þ.

A generic function created or modified by supplying :reader, :writer,
or :accessor slot options can be treated exactly as an ordinary generic
function.

Note that ÿslot-valueþ can be used to read or write the value of a slot
whether or not reader or writer methods exist for that slot.  When
ÿslot-valueþ is used, no reader or writer methods are invoked.

The macro ÿwith-slotsþ can be used to establish a lexical environment
in which specified slots are lexically available as if they were
variables.  The macro ÿwith-slotsþ invokes the function ÿslot-valueþ to
access the specified slots.

The macro ÿwith-accessorsþ can be used to establish a lexical
environment in which specified slots are lexically available through
their accessors as if they were variables.  The macro ÿwith-accessorsþ
invokes the appropriate accessors to access the specified slots.


File: chris-ansicl.info,  Node: Inheritance of Slots and Slot Options,  Prev: Accessing Slots,  Up: Slots

7.5.3 Inheritance of Slots and Slot Options
-------------------------------------------

The set of the names of all slots accessible in an instance of a class
C is the union of the sets of names of slots defined by C and its
superclasses. The structure of an instance is the set of names of local
slots in that instance.

In the simplest case, only one class among C and its superclasses
defines a slot with a given slot name.  If a slot is defined by a
superclass of C, the slot is said to be inherited.  The characteristics
of the slot are determined by the slot specifier of the defining class.
Consider the defining class for a slot S.  If the value of the
:allocation slot option is :instance, then S is a local slot and each
instance of C has its own slot named S that stores its own value.  If
the value of the :allocation slot option is :class, then S is a shared
slot, the class that defined S stores the value, and all instances of C
can access that single slot.  If the :allocation slot option is
omitted, :instance is used.

In general, more than one class among C and its superclasses can define
a slot with a given name.  In such cases, only one slot with the given
name is accessible in an instance of C, and the characteristics of that
slot are a combination of the several slot specifiers, computed as
follows:

   * All the slot specifiers for a given slot name are ordered from
     most specific to least specific, according to the order in C's
     class precedence list of the classes that define them. All
     references to the specificity of slot specifiers immediately below
     refers to this ordering.

   * The allocation of a slot is controlled by the most specific slot
     specifier.  If the most specific slot specifier does not contain
     an :allocation slot option, :instance is used.  Less specific slot
     specifiers do not affect the allocation.

   * The default initial value form for a slot is the value of the
     :initform slot option in the most specific slot specifier that
     contains one.  If no slot specifier contains an :initform slot
     option, the slot has no default initial value form.

   * The contents of a slot will always be of type ÿ(and Tá ... T_n)þ
     where Tá... T_n are the values of the :type slot options contained
     in all of the slot specifiers.  If no slot specifier contains the
     :type slot option, the contents of the slot will always be of type
     ÿtþ. The consequences of attempting to store in a slot a value
     that does not satisfy the type of the slot are undefined.

   * The set of initialization arguments that initialize a given slot
     is the union of the initialization arguments declared in the
     :initarg slot options in all the slot specifiers.

   * The documentation string for a slot is the value of the
     :documentation slot option in the most specific slot specifier
     that contains one.  If no slot specifier contains a :documentation
     slot option, the slot has no documentation string.

A consequence of the allocation rule is that a shared slot can be
shadowed.  For example, if a class Cá defines a slot named S whose
value for the :allocation slot option is :class, that slot is accessible
in instances of Cá and all of its subclasses.  However, if Cà is a
subclass of Cá and also defines a slot named S, Cá's slot is not shared
by instances of Cà and its subclasses. When a class Cá defines a shared
slot, any subclass Cà of Cá will share this single slot unless the
ÿdefclassþ form for Cà specifies a slot of the same name or there is a
superclass of Cà that precedes Cá in the class precedence list of Cà
that defines a slot of the same name.

A consequence of the type rule is that the value of a slot satisfies
the type constraint of each slot specifier that contributes to that
slot.  Because the result of attempting to store in a slot a value that
does not satisfy the type constraint for the slot is undefined, the
value in a slot might fail to satisfy its type constraint.

The :reader, :writer, and :accessor slot options create methods rather
than define the characteristics of a slot.  Reader and writer methods
are inherited in the sense described in *Note Section 7.6.7
(Inheritance of Methods): Inheritance of Methods.

Methods that access slots use only the name of the slot and the type of
the slot's value.  Suppose a superclass provides a method that expects
to access a shared slot of a given name, and a subclass defines a local
slot with the same name.  If the method provided by the superclass is
used on an instance of the subclass, the method accesses the local slot.


File: chris-ansicl.info,  Node: Generic Functions and Methods,  Next: function-keywords,  Prev: Slots,  Up: Objects

7.6 Generic Functions and Methods
=================================

* Menu:

* Introduction to Generic Functions::
* Introduction to Methods::
* Agreement on Parameter Specializers and Qualifiers::
* Congruent Lambda-lists for all Methods of a Generic Function::
* Keyword Arguments in Generic Functions and Methods::
* Method Selection and Combination::
* Inheritance of Methods::


File: chris-ansicl.info,  Node: Introduction to Generic Functions,  Next: Introduction to Methods,  Up: Generic Functions and Methods

7.6.1 Introduction to Generic Functions
---------------------------------------

A "generic function" is a function whose behavior depends on the
classes or identities of the arguments supplied to it.  A generic
function object is associated with a set of methods, a lambda list, a
method combinationà, and other information.

Like an ordinary function, a generic function takes arguments, performs
a series of operations, and perhaps returns useful values.  An ordinary
function has a single body of code that is always executed when the
function is called.  A generic function has a set of bodies of code of
which a subset is selected for execution. The selected bodies of code
and the manner of their combination are determined by the classes or
identities of one or more of the arguments to the generic function and
by its method combination.

Ordinary functions and generic functions are called with identical
syntax.

Generic functions are true functions that can be passed as arguments
and used as the first argument to ÿfuncallþ and ÿapplyþ.

A binding of a function name to a generic function can be established
in one of several ways.  It can be established in the global
environment by ÿensure-generic-functionþ, ÿdefmethodþ (implicitly, due
to ÿensure-generic-functionþ) or ÿdefgenericþ (also implicitly, due to
ÿensure-generic-functionþ).  No standardized mechanism is provided for
establishing a binding of a function name to a generic function in the
lexical environment.

When a ÿdefgenericþ form is evaluated, one of three actions is taken
(due to ÿensure-generic-functionþ):

   * If a generic function of the given name already exists, the
     existing generic function object is modified.  Methods specified
     by the current ÿdefgenericþ form are added, and any methods in the
     existing generic function that were defined by a previous
     ÿdefgenericþ form are removed.  Methods added by the current
     ÿdefgenericþ form might replace methods defined by ÿdefmethodþ,
     ÿdefclassþ, ÿdefine-conditionþ, or ÿdefstructþ.  No other methods
     in the generic function are affected or replaced.

   * If the given name names an ordinary function, a  macro, or a
     special operator, an error is signaled.

   * Otherwise a generic function is created with the methods specified
     by the method definitions in the ÿdefgenericþ form.

Some operators permit specification of the options of a generic
function, such as the type of method combination it uses or its
argument precedence order.  These operators will be referred to as
"operators that specify generic function options."  The only
standardized operator in this category is ÿdefgenericþ.

Some operators define methods for a generic function.  These operators
will be referred to as "method-defining operators"; their associated
forms are called method-defining forms.  The standardized
method-defining operators are listed in the next figure.

defgeneric         defmethod   defclass
define-condition   defstruct   

Figure 7.1: Standardized Method-Defining Operators

Note that of the standardized method-defining operators only
ÿdefgenericþ can specify generic function options.  ÿdefgenericþ and
any implementation-defined operators that can specify generic function
options are also referred to as "operators that specify generic
function options."


File: chris-ansicl.info,  Node: Introduction to Methods,  Next: Agreement on Parameter Specializers and Qualifiers,  Prev: Introduction to Generic Functions,  Up: Generic Functions and Methods

7.6.2 Introduction to Methods
-----------------------------

Methods define the class-specific or identity-specific behavior and
operations of a generic function.

A method object is associated with code that implements the method's
behavior, a sequence of parameter specializers that specify when the
given method is applicable, a lambda list, and a sequence of qualifiers
that are used by the method combination facility to distinguish among
methods.

A method object is not a function and cannot be invoked as a function.
Various mechanisms in the object system take a method object and invoke
its method function, as is the case when a generic function is invoked.
When this occurs it is said that the method is invoked or called.

A method-defining form contains the code that is to be run when the
arguments to the generic function cause the method that it defines to
be invoked.  When a method-defining form is evaluated, a method object
is created and one of four actions is taken:

   * If a generic function of the given name already exists and if a
     method object already exists that agrees with the new one on
     parameter specializers and qualifiers, the new method object
     replaces the old one.  For a definition of one method agreeing
     with another on parameter specializers and qualifiers, see *Note
     Section 7.6.3 (Agreement on Parameter Specializers and
     Qualifiers): Agreement on Parameter Specializers and Qualifiers.

   * If a generic function of the given name already exists and if
     there is no method object that agrees with the new one on
     parameter specializers and qualifiers, the existing generic
     function object is modified to contain the new method object.

   * If the given name names an ordinary function, a macro, or a
     special operator, an error is signaled.

   * Otherwise a generic function is created with the method specified
     by the method-defining form.

If the lambda list of a new method is not congruent with the lambda
list of the generic function, an error is signaled.  If a
method-defining operator that cannot specify generic function options
creates a new generic function, a lambda list for that generic function
is derived from the lambda list of the method in the method-defining
form in such a way as to be congruent with it.  For a discussion of "congruence",
see *Note Section 7.6.4 (Congruent Lambda-lists for all Methods of a
Generic Function): Congruent Lambda-lists for all Methods of a Generic
Function.

Each method has a specialized lambda list, which determines when that
method can be applied.  A specialized lambda list is like an ordinary
lambda list except that a specialized parameter may occur instead of
the name of a required parameter.  A specialized parameter is a list
ÿ(variable-name parameter-specializer-name)þ, where
parameter-specializer-name is one of the following:

a symbol
     denotes a parameter specializer which is the class named by that
     symbol.

a class
     denotes a parameter specializer which is the class itself.

ÿ(eql form)þ
     denotes a parameter specializer which satisfies the type specifier
     ÿ(eql object)þ, where object is the result of evaluating form.
     The form form is evaluated in the lexical environment in which the
     method-defining form is evaluated.  Note that form is evaluated
     only once, at the time the method is defined, not each time the
     generic function is called.

Parameter specializer names are used in macros intended as the
user-level interface (ÿdefmethodþ), while parameter specializers are
used in the functional interface.

Only required parameters may be specialized, and there must be a
parameter specializer for each required parameter.  For notational
simplicity, if some required parameter in a specialized lambda list in
a method-defining form is simply a variable name, its parameter
specializer defaults to the class ÿtþ.

Given a generic function and a set of arguments, an applicable method
is a method for that generic function whose parameter specializers are
satisfied by their corresponding arguments.  The following definition
specifies what it means for a method to be applicable and for an
argument to satisfy a parameter specializer.

Let ò Aá, ..., A_nñ be the required arguments to a generic function in
order. Let ò Pá, ..., P_nñ be the parameter specializers corresponding
to the required parameters of the method M in order.  The method M is
applicable when each A_i is of the type specified by the type specifier
P_i.  Because every valid parameter specializer is also a valid type
specifier, the function ÿtypepþ can be used during method selection to
determine whether an argument satisfies a parameter specializer.

A method all of whose parameter specializers are the class ÿtþ is
called a "default method"; it is always applicable but may be shadowed
by a more specific method.

Methods can have qualifiers, which give the method combination
procedure a way to distinguish among methods.  A method that has one or
more qualifiers is called a qualified method.  A method with no
qualifiers is called an unqualified method.  A qualifier is any
non-list.  The qualifiers defined by the standardized method
combination types are symbols.

In this specification, the terms "primary method" and "auxiliary
method" are used to partition methods within a method combination type
according to their intended use.  In standard method combination,
primary methods are unqualified methods and auxiliary methods are
methods with a single qualifier that is one of :around, :before, or
:after.  Methods with these qualifiers are called around methods,
before methods, and after methods, respectively.  When a method
combination type is defined using the short form of
ÿdefine-method-combinationþ, primary methods are methods qualified with
the name of the type of method combination, and auxiliary methods have
the qualifier :around.  Thus the terms "primary method" and "auxiliary
method" have only a relative definition within a given method
combination type.


File: chris-ansicl.info,  Node: Agreement on Parameter Specializers and Qualifiers,  Next: Congruent Lambda-lists for all Methods of a Generic Function,  Prev: Introduction to Methods,  Up: Generic Functions and Methods

7.6.3 Agreement on Parameter Specializers and Qualifiers
--------------------------------------------------------

Two methods are said to agree with each other on parameter specializers
and qualifiers if the following conditions hold:

  1. Both methods have the same number of required parameters.  Suppose
     the parameter specializers of the two methods are P_{1,1}...
     P_{1,n} and P_{2,1}... P_{2,n}.

  2. For each 1ó ió n, P_{1,i} agrees with P_{2,i}.  The parameter
     specializer P_{1,i} agrees with P_{2,i} if P_{1,i} and P_{2,i} are
     the same class or if P_{1,i}=ÿ(eql þobjectá),
     P_{2,i}=ÿ(eql þobjectà), and ÿ(eql objectá objectà)þ.  Otherwise
     P_{1,i} and P_{2,i} do not agree.

  3. The two lists of qualifiers are the same under ÿequalþ.


File: chris-ansicl.info,  Node: Congruent Lambda-lists for all Methods of a Generic Function,  Next: Keyword Arguments in Generic Functions and Methods,  Prev: Agreement on Parameter Specializers and Qualifiers,  Up: Generic Functions and Methods

7.6.4 Congruent Lambda-lists for all Methods of a Generic Function
------------------------------------------------------------------

These rules define the congruence of a set of lambda lists, including
the lambda list of each method for a given generic function and the
lambda list specified for the generic function itself, if given.

  1. Each lambda list must have the same number of required parameters.

  2. Each lambda list must have the same number of optional parameters.
     Each method can supply its own default for an optional parameter.

  3. If any lambda list mentions ÿ&restþ or ÿ&keyþ, each lambda list
     must mention one or both of them.

  4. If the generic function lambda list mentions ÿ&keyþ, each method
     must accept all of the keyword names mentioned after ÿ&keyþ,
     either by accepting them explicitly, by specifying
     ÿ&allow-other-keysþ, or by specifying ÿ&restþ but not ÿ&keyþ.
     Each method can accept additional keyword arguments of its own.
     The checking of the validity of keyword names is done in the
     generic function, not in each method.  A method is invoked as if
     the keyword argument pair whose name is :allow-other-keys and
     whose value is true were supplied, though no such argument pair
     will be passed.

  5. The use of ÿ&allow-other-keysþ need not be consistent across
     lambda lists.  If ÿ&allow-other-keysþ is mentioned in the lambda
     list of any applicable method or of the generic function, any
     keyword arguments may be mentioned in the call to the generic
     function.

  6. The use of ÿ&auxþ need not be consistent across methods.

     If a method-defining operator that cannot specify generic function
     options creates a generic function, and if the lambda list for the
     method mentions keyword arguments, the lambda list of the generic
     function will mention ÿ&keyþ (but no keyword arguments).


File: chris-ansicl.info,  Node: Keyword Arguments in Generic Functions and Methods,  Next: Method Selection and Combination,  Prev: Congruent Lambda-lists for all Methods of a Generic Function,  Up: Generic Functions and Methods

7.6.5 Keyword Arguments in Generic Functions and Methods
--------------------------------------------------------

When a generic function or any of its methods mentions ÿ&keyþ in a
lambda list, the specific set of keyword arguments accepted by the
generic function varies according to the applicable methods.  The set
of keyword arguments accepted by the generic function for a particular
call is the union of the keyword arguments accepted by all applicable
methods and the keyword arguments mentioned after ÿ&keyþ in the generic
function definition, if any.  A method that has ÿ&restþ but not ÿ&keyþ
does not affect the set of acceptable keyword arguments.  If the lambda
list of any applicable method or of the generic function definition
contains ÿ&allow-other-keysþ, all keyword arguments are accepted by the
generic function.

The lambda list congruence rules require that each method accept all of
the keyword arguments mentioned after ÿ&keyþ in the generic function
definition, by accepting them explicitly, by specifying
ÿ&allow-other-keysþ, or by specifying ÿ&restþ but not ÿ&keyþ.  Each
method can accept additional keyword arguments of its own, in addition
to the keyword arguments mentioned in the generic function definition.

If a generic function is passed a keyword argument that no applicable
method accepts, an error should be signaled; see *Note Section 3.5
(Error Checking in Function Calls): Error Checking in Function Calls.

7.6.5.1 Examples of Keyword Arguments in Generic Functions and Methods
......................................................................

For example, suppose there are two methods defined for ÿwidthþ as
follows:

 (defmethod width ((c character-class) &key font) ...)

 (defmethod width ((p picture-class) &key pixel-size) ...)

Assume that there are no other methods and no generic function
definition for ÿwidthþ. The evaluation of the following form should
signal an error because the keyword argument :pixel-size is not
accepted by the applicable method.

 (width (make-instance `character-class :char #\Q)
        :font 'baskerville :pixel-size 10)

The evaluation of the following form should signal an error.

 (width (make-instance `picture-class :glyph (glyph #\Q))
        :font 'baskerville :pixel-size 10)

The evaluation of the following form will not signal an error if the
class named ÿcharacter-picture-classþ is a subclass of both
ÿpicture-classþ and ÿcharacter-classþ.

 (width (make-instance `character-picture-class :char #\Q)
        :font 'baskerville :pixel-size 10)


File: chris-ansicl.info,  Node: Method Selection and Combination,  Next: Inheritance of Methods,  Prev: Keyword Arguments in Generic Functions and Methods,  Up: Generic Functions and Methods

7.6.6 Method Selection and Combination
--------------------------------------

When a generic function is called with particular arguments, it must
determine the code to execute.  This code is called the "effective
method" for those arguments.  The effective method is a combination of
the applicable methods in the generic function that calls some or all
of the methods.

If a generic function is called and no methods are applicable, the
generic function ÿno-applicable-methodþ is invoked, with the results
from that call being used as the results of the call to the original
generic function.  Calling ÿno-applicable-methodþ takes precedence over
checking for acceptable keyword arguments; see *Note Section 7.6.5
(Keyword Arguments in Generic Functions and Methods): Keyword Arguments
in Generic Functions and Methods.

When the effective method has been determined, it is invoked with the
same arguments as were passed to the generic function.  Whatever values
it returns are returned as the values of the generic function.

7.6.6.1 Determining the Effective Method
........................................

The effective method is determined by the following three-step
procedure:

  1. Select the applicable methods.

  2. Sort the applicable methods by precedence order, putting the most
     specific method first.

  3. Apply method combination to the sorted list of applicable methods,
     producing the effective method.

7.6.6.1.1 Selecting the Applicable Methods
..........................................

This step is described in *Note Section 7.6.2 (Introduction to
Methods): Introduction to Methods.

7.6.6.1.2 Sorting the Applicable Methods by Precedence Order
............................................................

To compare the precedence of two methods, their parameter specializers
are examined in order.  The default examination order is from left to
right, but an alternative order may be specified by the
:argument-precedence-order option to ÿdefgenericþ or to any of the
other operators that specify generic function options.

The corresponding parameter specializers from each method are compared.
When a pair of parameter specializers agree, the next pair are
compared for agreement.  If all corresponding parameter specializers
agree, the two methods must have different qualifiers; in this case,
either method can be selected to precede the other.  For information
about agreement, see *Note Section 7.6.3 (Agreement on Parameter
Specializers and Qualifiers): Agreement on Parameter Specializers and
Qualifiers.

If some corresponding parameter specializers do not agree, the first
pair of parameter specializers that do not agree determines the
precedence.  If both parameter specializers are classes, the more
specific of the two methods is the method whose parameter specializer
appears earlier in the class precedence list of the corresponding
argument.  Because of the way in which the set of applicable methods is
chosen, the parameter specializers are guaranteed to be present in the
class precedence list of the class of the argument.

If just one of a pair of corresponding parameter specializers is ÿ(eql
object)þ, the method with that parameter specializer precedes the other
method.  If both parameter specializers are ÿeqlþ expressions, the
specializers must agree (otherwise the two methods would not both have
been applicable to this argument).

The resulting list of applicable methods has the most specific method
first and the least specific method last.

7.6.6.1.3 Applying method combination to the sorted list of applicable methods
..............................................................................

In the simple case--if standard method combination is used and all
applicable methods are primary methods--the effective method is the
most specific method.  That method can call the next most specific
method by using the function ÿcall-next-methodþ.  The method that
ÿcall-next-methodþ will call is referred to as the "next method".  The
predicate ÿnext-method-pþ tests whether a next method exists.  If
ÿcall-next-methodþ is called and there is no next most specific method,
the generic function ÿno-next-methodþ is invoked.

In general, the effective method is some combination of the applicable
methods.  It is described by a form that contains calls to some or all
of the applicable methods, returns the value or values that will be
returned as the value or values of the generic function, and optionally
makes some of the methods accessible by means of ÿcall-next-methodþ.

The role of each method in the effective method is determined by its
qualifiers and the specificity of the method.  A qualifier serves to
mark a method, and the meaning of a qualifier is determined by the way
that these marks are used by this step of the procedure.  If an
applicable method has an unrecognized qualifier, this step signals an
error and does not include that method in the effective method.

When standard method combination is used together with qualified
methods, the effective method is produced as described in *Note Section
7.6.6.2 (Standard Method Combination): StdMethComb.

Another type of method combination can be specified by using the
:method-combination option of ÿdefgenericþ or of any of the other
operators that specify generic function options.  In this way this step
of the procedure can be customized.

New types of method combination can be defined by using the
ÿdefine-method-combinationþ macro.

7.6.6.2 Standard Method Combination
...................................

Standard method combination is supported by the class
ÿstandard-generic-functionþ.  It is used if no other type of method
combination is specified or if the built-in method combination type
standard is specified.

Primary methods define the main action of the effective method, while
auxiliary methods modify that action in one of three ways.  A primary
method has no method qualifiers.

An auxiliary method is a method whose qualifier is :before, :after, or
:around.  Standard method combination allows no more than one qualifier
per method; if a method definition specifies more than one qualifier
per method, an error is signaled.

   * A before method has the keyword :before as its only qualifier.  A
     before method specifies code that is to be run before any primary
     methods.

   * An after method has the keyword :after as its only qualifier.  An
     after method specifies code that is to be run after primary
     methods.

   * An around method has the keyword :around as its only qualifier.
     An around method specifies code that is to be run instead of other
     applicable methods, but which might contain explicit code which
     calls some of those shadowed methods (via ÿcall-next-methodþ).

The semantics of standard method combination is as follows:

   * If there are any around methods, the most specific around method
     is called.  It supplies the value or values of the generic
     function.

   * Inside the body of an around method, ÿcall-next-methodþ can be
     used to call the next method.  When the next method returns, the
     around method can execute more code, perhaps based on the returned
     value or values.  The generic function ÿno-next-methodþ is invoked
     if ÿcall-next-methodþ is used and there is no applicable method to
     call.  The function ÿnext-method-pþ may be used to determine
     whether a next method exists.

   * If an around method invokes ÿcall-next-methodþ, the next most
     specific around method is called, if one is applicable.  If there
     are no around methods or if ÿcall-next-methodþ is called by the
     least specific around method, the other methods are called as
     follows:

        - All the before methods are called, in most-specific-first
          order.  Their values are ignored.  An error is signaled if
          ÿcall-next-methodþ is used in a before method.

        - The most specific primary method is called.  Inside the body
          of a primary method, ÿcall-next-methodþ may be used to call
          the next most specific primary method.  When that method
          returns, the previous primary method can execute more code,
          perhaps based on the returned value or values.  The generic
          function ÿno-next-methodþ is invoked if ÿcall-next-methodþ is
          used and there are no more applicable primary methods.  The
          function ÿnext-method-pþ may be used to determine whether a
          next method exists.  If ÿcall-next-methodþ is not used, only
          the most specific primary method is called.

        - All the after methods are called in most-specific-last order.
          Their values are ignored.  An error is signaled if
          ÿcall-next-methodþ is used in an after method.

   * If no around methods were invoked, the most specific primary
     method supplies the value or values returned by the generic
     function.  The value or values returned by the invocation of
     ÿcall-next-methodþ in the least specific around method are those
     returned by the most specific primary method.

In standard method combination, if there is an applicable method but no
applicable primary method, an error is signaled.

The before methods are run in most-specific-first order while the after
methods are run in least-specific-first order.  The design rationale
for this difference can be illustrated with an example.  Suppose class
Cá modifies the behavior of its superclass, Cà, by adding before
methods and after methods.  Whether the behavior of the class Cà is
defined directly by methods on Cà or is inherited from its superclasses
does not affect the relative order of invocation of methods on
instances of the class Cá.  Class Cá's before method runs before all of
class Cà's methods.  Class Cá's after method runs after all of class
Cà's methods.

By contrast, all around methods run before any other methods run.  Thus
a less specific around method runs before a more specific primary
method.

If only primary methods are used and if ÿcall-next-methodþ is not used,
only the most specific method is invoked; that is, more specific
methods shadow more general ones.

7.6.6.3 Declarative Method Combination
......................................

The macro ÿdefine-method-combinationþ defines new forms of method
combination.  It provides a mechanism for customizing the production of
the effective method. The default procedure for producing an effective
method is described in *Note Section 7.6.6.1 (Determining the Effective
Method): DeterminingtheEffectiveMethod.  There are two forms of
ÿdefine-method-combinationþ.  The short form is a simple facility while
the long form is more powerful and more verbose.  The long form
resembles ÿdefmacroþ in that the body is an expression that computes a
Lisp form; it provides mechanisms for implementing arbitrary control
structures within method combination and for arbitrary processing of
method qualifiers.

7.6.6.4 Built-in Method Combination Types
.........................................

The object system provides a set of built-in method combination types.
To specify that a generic function is to use one of these method
combination types, the name of the method combination type is given as
the argument to the :method-combination option to ÿdefgenericþ or to
the :method-combination option to any of the other operators that
specify generic function options.

The names of the built-in  method combination types are listed in the
next figure.  

+     append   max   nconc   progn
and   list     min   or      standard

Figure 7.2: Built-in Method Combination Types

The semantics of the standard built-in method combination type is
described in *Note Section 7.6.6.2 (Standard Method Combination):
StdMethComb.  The other built-in method combination types are called
simple built-in method combination types.

The simple built-in method combination types act as though they were
defined by the short form of ÿdefine-method-combinationþ.  They
recognize two roles for methods:

   * An around method has the keyword symbol :around as its sole
     qualifier.  The meaning of :around methods is the same as in
     standard method combination.  Use of the functions
     ÿcall-next-methodþ and ÿnext-method-pþ is supported in around
     methods.

   * A primary method has the name of the method combination type as
     its sole qualifier.  For example, the built-in method combination
     type ÿandþ recognizes methods whose sole qualifier is ÿandþ; these
     are primary methods. Use of the functions ÿcall-next-methodþ and
     ÿnext-method-pþ is not supported in primary methods.

The semantics of the simple built-in method combination types is as
follows:

   * If there are any around methods, the most specific around method
     is called.   It supplies the value or values of the generic
     function.

   * Inside the body of an around method, the function
     ÿcall-next-methodþ can be used to call the next method.  The
     generic function ÿno-next-methodþ is invoked if ÿcall-next-methodþ
     is used and there is no applicable method to call.  The function
     ÿnext-method-pþ may be used to determine whether a next method
     exists. When the next method returns, the around method can
     execute more code, perhaps based on the returned value or values.

   * If an around method invokes ÿcall-next-methodþ, the next most
     specific around method is called, if one is applicable.  If there
     are no around methods or if ÿcall-next-methodþ is called by the
     least specific around method, a Lisp form derived from the name of
     the built-in method combination type and from the list of
     applicable primary methods is evaluated to produce the value of
     the generic function.  Suppose the name of the method combination
     type is operator and the call to the generic function is of the
     form

          (generic-function aá... a_n)

   * Let Má,...,M_k be the applicable primary methods in order; then
     the derived Lisp form is

          (operator ò Má  aá... a_nñ...ò M_k aá... a_nñ)

   * If the expression ò M_i aá... a_nñ is evaluated, the method M_i
     will be applied to the arguments aá... a_n.  For example, if
     operator is ÿorþ, the expression ò M_i aá... a_nñ is evaluated
     only if ò M_j aá... a_nñ, 1ó j<i, returned ÿnilþ.

   * The default order for the primary methods is :most-specific-first.
     However, the order can be reversed by supplying
     :most-specific-last as the second argument to the
     :method-combination option.

The simple built-in method combination types require exactly one
qualifier per method.  An error is signaled if there are applicable
methods with no qualifiers or with qualifiers that are not supported by
the method combination type. An error is signaled if there are
applicable around methods and no applicable primary methods.


File: chris-ansicl.info,  Node: Inheritance of Methods,  Prev: Method Selection and Combination,  Up: Generic Functions and Methods

7.6.7 Inheritance of Methods
----------------------------

A subclass inherits methods in the sense that any method applicable to
all instances of a class is also applicable to all instances of any
subclass of that class.

The inheritance of methods acts the same way regardless of which of the
method-defining operators created the methods.

The inheritance of methods is described in detail in *Note Section
7.6.6 (Method Selection and Combination): Method Selection and
Combination.


File: chris-ansicl.info,  Node: function-keywords,  Next: ensure-generic-function,  Prev: Generic Functions and Methods,  Up: Objects

function-keywords (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: function-keywords method ý keys,
          allow-other-keys-p

Method Signatures:
..................

function-keywords (METHOD ÿstandard-methodþ)

Arguments and Values:
.....................

METHOD--a method.

KEYS--a list.

ALLOW-OTHER-KEYS-P--a generalized boolean.

Description:
............

Returns the keyword parameter specifiers for a METHOD.

Two values are returned: a list of the explicitly named keywords and a
generalized boolean that states whether ÿ&allow-other-keysþ had been
specified in the METHOD definition.

Examples:
.........

 (defmethod gf1 ((a integer) &optional (b 2)
                 &key (c 3) ((:dee d) 4) e ((eff f)))
   (list a b c d e f))
ý #<STANDARD-METHOD GF1 (INTEGER) 36324653>
 (find-method #'gf1 '() (list (find-class 'integer)))
ý #<STANDARD-METHOD GF1 (INTEGER) 36324653>
 (function-keywords *)
ý (:C :DEE :E EFF), false
 (defmethod gf2 ((a integer))
   (list a b c d e f))
ý #<STANDARD-METHOD GF2 (INTEGER) 42701775>
 (function-keywords (find-method #'gf1 '() (list (find-class 'integer))))
ý (), false
 (defmethod gf3 ((a integer) &key b c d &allow-other-keys)
   (list a b c d e f))
 (function-keywords *)
ý (:B :C :D), true

Affected By:
............

ÿdefmethodþ

See Also:
.........

*Note defmethod::


File: chris-ansicl.info,  Node: ensure-generic-function,  Next: allocate-instance,  Prev: function-keywords,  Up: Objects

ensure-generic-function (Function)
==================================

Syntax:
.......

 -- Function: ensure-generic-function function-name &key
          argument-precedence-order declare documentation environment
          generic-function-class lambda-list
          method-class method-combination ý generic-function

Arguments and Values:
.....................

FUNCTION-NAME--a function name.

The keyword arguments correspond to the OPTION arguments of
ÿdefgenericþ, except that the :method-class and :generic-function-class
arguments can be class objects as well as names.

ÿMethod-combinationþ--method combination object.

ÿEnvironmentþ--the same as the ÿ&environmentþ argument to macro
expansion functions and is used to distinguish between compile-time and
run-time environments.

GENERIC-FUNCTION--a generic function object.

Description:
............

The function ÿensure-generic-functionþ is used to define a globally
named generic function with no methods or to specify or modify options
and declarations that pertain to a globally named generic function as a
whole.

If FUNCTION-NAME is not fbound in the global environment, a new generic
function is created.  If ÿ(fdefinition FUNCTION-NAME)þ is an ordinary
function, a macro, or a special operator, an error is signaled.

If FUNCTION-NAME is a list, it must be of the form ÿ(setf SYMBOL)þ.  If
FUNCTION-NAME specifies a generic function that has a different value
for any of the following arguments, the generic function is modified to
have the new value: :argument-precedence-order, :declare,
:documentation, :method-combination.

If FUNCTION-NAME specifies a generic function that has a different
value for the :lambda-list argument, and the new value is congruent
with the lambda lists of all existing methods or there are no methods,
the value is changed; otherwise an error is signaled.

If FUNCTION-NAME specifies a generic function that has a different
value for the :generic-function-class argument and if the new generic
function class is compatible with the old, ÿchange-classþ is called to
change the class of the generic function; otherwise an error is
signaled.

If FUNCTION-NAME specifies a generic function that has a different
value for the :method-class argument, the value is changed, but any
existing methods are not changed.

Affected By:
............

Existing function binding of FUNCTION-NAME.

Exceptional Situations:
.......................

If ÿ(fdefinition FUNCTION-NAME)þ is an ordinary function, a macro, or a
special operator, an error of type ÿerrorþ is signaled.

If FUNCTION-NAME specifies a generic function that has a different
value for the :lambda-list argument, and the new value is not congruent
with the lambda list of any existing method, an error of type ÿerrorþ
is signaled.

If FUNCTION-NAME specifies a generic function that has a different
value for the :generic-function-class argument and if the new generic
function class not is compatible with the old, an error of type ÿerrorþ
is signaled.

See Also:
.........

*Note defgeneric::


File: chris-ansicl.info,  Node: allocate-instance,  Next: reinitialize-instance,  Prev: ensure-generic-function,  Up: Objects

allocate-instance (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: allocate-instance class &rest initargs &key
          &allow-other-keys ý new-instance

Method Signatures:
..................

allocate-instance (CLASS ÿstandard-classþ) &rest initargs

allocate-instance (CLASS ÿstructure-classþ) &rest initargs

Arguments and Values:
.....................

CLASS--a class.

INITARGS--a list of keyword/value pairs (initialization argument names
and values).

NEW-INSTANCE--an object whose class is CLASS.

Description:
............

The generic function ÿallocate-instanceþ creates and returns a new
instance of the CLASS, without initializing it.  When the CLASS is a
standard class, this means that the slots are unbound; when the class
is a structure class, this means the slots' values are unspecified.

The caller of ÿallocate-instanceþ is expected to have already checked
the initialization arguments.

The generic function ÿallocate-instanceþ is called by ÿmake-instanceþ,
as described in *Note Section 7.1 (Object Creation and Initialization):
Object Creation and Initialization.

See Also:
.........

*Note defclass::, *Note make-instance::, *Note class-of::, *Note
Section 7.1 (Object Creation and Initialization): Object Creation and
Initialization.

Notes:
......

The consequences of adding methods to ÿallocate-instanceþ is
unspecified.  This capability might be added by the Metaobject Protocol.


File: chris-ansicl.info,  Node: reinitialize-instance,  Next: shared-initialize (Standard Generic Function),  Prev: allocate-instance,  Up: Objects

reinitialize-instance (Standard Generic Function)
=================================================

Syntax:
.......

 -- Generic Function: reinitialize-instance instance &rest initargs
          &key &allow-other-keys ý instance

Method Signatures:
..................

reinitialize-instance (INSTANCE ÿstandard-objectþ) &rest initargs

Arguments and Values:
.....................

INSTANCE--an object.

INITARGS--an initialization argument list.

Description:
............

The generic function ÿreinitialize-instanceþ can be used to change the
values of local slots of an INSTANCE according to INITARGS.  This
generic function can be called by users.

The system-supplied primary method for ÿreinitialize-instanceþ checks
the validity of INITARGS and signals an error if an INITARG is supplied
that is not declared as valid.  The method then calls the generic
function ÿshared-initializeþ with the following arguments:  the
INSTANCE, ÿnilþ (which means no slots should be initialized according
to their initforms), and the INITARGS it received.

Side Effects:
.............

The generic function ÿreinitialize-instanceþ changes the values of
local slots.

Exceptional Situations:
.......................

The system-supplied primary method for ÿreinitialize-instanceþ signals
an error if an INITARG is supplied that is not declared as valid.

See Also:
.........

*Note initialize-instance (Standard Generic Function)::, *Note
shared-initialize (Standard Generic Function)::, *Note
update-instance-for-redefined-class::, *Note
update-instance-for-different-class::, *Note slot-boundp::, *Note
slot-makunbound::, *Note Section 7.3 (Reinitializing an Instance):
Reinitializing an Instance, *Note Section 7.1.4 (Rules for
Initialization Arguments): Rules for Initialization Arguments, *Note
Section 7.1.2 (Declaring the Validity of Initialization Arguments):
Declaring the Validity of Initialization Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
ÿdefclassþ, or by defining methods for ÿreinitialize-instanceþ or
ÿshared-initializeþ.  The keyword name of each keyword parameter
specifier in the lambda list of any method defined on
ÿreinitialize-instanceþ or ÿshared-initializeþ is declared as a valid
initialization argument name for all classes for which that method is
applicable.


File: chris-ansicl.info,  Node: shared-initialize (Standard Generic Function),  Next: update-instance-for-different-class,  Prev: reinitialize-instance,  Up: Objects

shared-initialize (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: shared-initialize instance slot-names &rest
          initargs &key &allow-other-keys ý instance

Method Signatures:
..................

shared-initialize (INSTANCE ÿstandard-objectþ) slot-names &rest initargs

Arguments and Values:
.....................

INSTANCE--an object.

SLOT-NAMES--a list or ÿtþ.

INITARGS--a list of keyword/value pairs (of initialization argument
names and values).

Description:
............

The generic function ÿshared-initializeþ is used to fill the slots of
an INSTANCE using INITARGS and :initform forms.  It is called when an
instance is created, when an instance is re-initialized, when an
instance is updated to conform to a redefined class, and when an
instance is updated to conform to a different class. The generic
function ÿshared-initializeþ is called by the system-supplied primary
method for ÿinitialize-instanceþ, ÿreinitialize-instanceþ,
ÿupdate-instance-for-redefined-classþ, and
ÿupdate-instance-for-different-classþ.

The generic function ÿshared-initializeþ takes the following arguments:
the INSTANCE to be initialized, a specification of a set of SLOT-NAMES
accessible in that INSTANCE, and any number of INITARGS.  The arguments
after the first two must form an initialization argument list.  The
system-supplied primary method on ÿshared-initializeþ initializes the
slots with values according to the INITARGS and supplied :initform
forms.  SLOT-NAMES indicates which slots should be initialized according
to their :initform forms if no INITARGS are provided for those slots.

The system-supplied primary method behaves as follows, regardless of
whether the slots are local or shared:

   * If an INITARG in the initialization argument list specifies a
     value for that slot, that value is stored into the slot, even if a
     value has already been stored in the slot before the method is run.

   * Any slots indicated by SLOT-NAMES that are still unbound at this
     point are initialized according to their :initform forms.  For any
     such slot that has an :initform form, that form is evaluated in
     the lexical environment of its defining ÿdefclassþ form and the
     result is stored into the slot.  For example, if a before method
     stores a value in the slot, the :initform form will not be used to
     supply a value for the slot.

   * The rules mentioned in *Note Section 7.1.4 (Rules for
     Initialization Arguments): Rules for Initialization Arguments. are
     obeyed.

The SLOTS-NAMES argument specifies the slots that are to be initialized
according to their :initform forms if no initialization arguments
apply.  It can be a list of slot names, which specifies the set of
those slot names; or it can be the symbol ÿtþ, which specifies the set
of all of the slots.

See Also:
.........

*Note initialize-instance (Standard Generic Function)::, *Note
reinitialize-instance::, *Note update-instance-for-redefined-class::,
*Note update-instance-for-different-class::, *Note slot-boundp::, *Note
slot-makunbound::, *Note Section 7.1 (Object Creation and
Initialization): Object Creation and Initialization, *Note Section
7.1.4 (Rules for Initialization Arguments): Rules for Initialization
Arguments, *Note Section 7.1.2 (Declaring the Validity of
Initialization Arguments): Declaring the Validity of Initialization
Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
ÿdefclassþ, or by defining methods for ÿshared-initializeþ.  The
keyword name of each keyword parameter specifier in the lambda list of
any method defined on ÿshared-initializeþ is declared as a valid INITARG
name for all classes for which that method is applicable.

Implementations are permitted to optimize :initform forms that neither
produce nor depend on side effects, by evaluating these forms and
storing them into slots before running any ÿinitialize-instanceþ
methods, rather than by handling them in the primary
ÿinitialize-instanceþ method.  (This optimization might be implemented
by having the ÿallocate-instanceþ method copy a prototype instance.)

Implementations are permitted to optimize default initial value forms
for INITARGS associated with slots by not actually creating the
complete initialization argument list when the only method that would
receive the complete list is the method on ÿstandard-objectþ.  In this
case default initial value forms can be treated like :initform forms.
This optimization has no visible effects other than a performance
improvement.


File: chris-ansicl.info,  Node: update-instance-for-different-class,  Next: update-instance-for-redefined-class,  Prev: shared-initialize (Standard Generic Function),  Up: Objects

update-instance-for-different-class (Standard Generic Function)
===============================================================

Syntax:
.......

 -- Generic Function: update-instance-for-different-class previous
          current &rest initargs &key &allow-other-keys ý
          implementation-dependent

Method Signatures:
..................

update-instance-for-different-class (PREVIOUS ÿstandard-objectþ)
(CURRENT ÿstandard-objectþ) &rest initargs

Arguments and Values:
.....................

PREVIOUS--a copy of the original instance.

CURRENT--the original instance (altered).

INITARGS--an initialization argument list.

Description:
............

The generic function ÿupdate-instance-for-different-classþ is not
intended to be called by programmers.  Programmers may write methods
for it.  The function ÿupdate-instance-for-different-classþ is called
only by the function ÿchange-classþ.

The system-supplied primary method on
ÿupdate-instance-for-different-classþ checks the validity of INITARGS
and signals an error if an INITARG is supplied that is not declared as
valid.  This method then initializes slots with values according to the
INITARGS, and initializes the newly added slots with values according
to their :initform forms.  It does this by calling the generic function
ÿshared-initializeþ with the following arguments: the instance
(CURRENT), a list of names of the newly added slots, and the INITARGS
it received.  Newly added slots are those local slots for which no slot
of the same name exists in the PREVIOUS class.

Methods for ÿupdate-instance-for-different-classþ can be defined to
specify actions to be taken when an instance is updated.  If only after
methods for ÿupdate-instance-for-different-classþ are defined, they
will be run after the system-supplied primary method for initialization
and therefore will not interfere with the default behavior of
ÿupdate-instance-for-different-classþ.

Methods on ÿupdate-instance-for-different-classþ can be defined to
initialize slots differently from ÿchange-classþ.  The default behavior
of ÿchange-classþ is described in *Note Section 7.2 (Changing the Class
of an Instance): Changing the Class of an Instance.

The arguments to ÿupdate-instance-for-different-classþ are computed by
ÿchange-classþ.  When ÿchange-classþ is invoked on an instance, a copy
of that instance is made; ÿchange-classþ then destructively alters the
original instance. The first argument to
ÿupdate-instance-for-different-classþ, PREVIOUS, is that copy; it holds
the old slot values temporarily.  This argument has dynamic extent
within ÿchange-classþ; if it is referenced in any way once
ÿupdate-instance-for-different-classþ returns, the results are
undefined.  The second argument to
ÿupdate-instance-for-different-classþ, CURRENT, is the altered original
instance.  The intended use of PREVIOUS is to extract old slot values
by using ÿslot-valueþ or ÿwith-slotsþ or by invoking a reader generic
function, or to run other methods that were applicable to instances of
the original class.

Examples:
.........

See the example for the function ÿchange-classþ.

Exceptional Situations:
.......................

The system-supplied primary method on
ÿupdate-instance-for-different-classþ signals an error if an
initialization argument is supplied that is not declared as valid.

See Also:
.........

*Note change-class::, *Note shared-initialize (Standard Generic
Function)::, *Note Section 7.2 (Changing the Class of an Instance):
Changing the Class of an Instance, *Note Section 7.1.4 (Rules for
Initialization Arguments): Rules for Initialization Arguments, *Note
Section 7.1.2 (Declaring the Validity of Initialization Arguments):
Declaring the Validity of Initialization Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
ÿdefclassþ, or by defining methods for
ÿupdate-instance-for-different-classþ or ÿshared-initializeþ.  The
keyword name of each keyword parameter specifier in the lambda list of
any method defined on ÿupdate-instance-for-different-classþ or
ÿshared-initializeþ is declared as a valid INITARG name for all classes
for which that method is applicable.

The value returned by ÿupdate-instance-for-different-classþ is ignored
by ÿchange-classþ.


File: chris-ansicl.info,  Node: update-instance-for-redefined-class,  Next: change-class,  Prev: update-instance-for-different-class,  Up: Objects

update-instance-for-redefined-class (Standard Generic Function)
===============================================================

Syntax:
.......

 -- Generic Function: update-instance-for-redefined-class instance
          added-slots discarded-slots property-list
          &rest initargs &key &allow-other-keys ý {result}*

Method Signatures:
..................

update-instance-for-redefined-class (INSTANCE ÿstandard-objectþ)
added-slots discarded-slots property-list &rest initargs

Arguments and Values:
.....................

INSTANCE--an object.

ADDED-SLOTS--a list.

DISCARDED-SLOTS--a list.

PROPERTY-LIST--a list.

INITARGS--an initialization argument list.

RESULT--an object.

Description:
............

The generic function ÿupdate-instance-for-redefined-classþ is not
intended to be called by programmers. Programmers may write methods for
it.  The generic function ÿupdate-instance-for-redefined-classþ is
called by the mechanism activated by ÿmake-instances-obsoleteþ.

The system-supplied primary method on
ÿupdate-instance-for-redefined-classþ checks the validity of INITARGS
and signals an error if an INITARG is supplied that is not declared as
valid.  This method then initializes slots with values according to the
INITARGS, and initializes the newly ADDED-SLOTS with values according
to their :initform forms.  It does this by calling the generic function
ÿshared-initializeþ with the following arguments: the INSTANCE, a list
of names of the newly ADDED-SLOTS to INSTANCE, and the INITARGS it
received.  Newly ADDED-SLOTS are those local slots for which no slot of
the same name exists in the old version of the class.

When ÿmake-instances-obsoleteþ is invoked or when a class has been
redefined and an instance is being updated, a PROPERTY-LIST is created
that captures the slot names and values of all the DISCARDED-SLOTS with
values in the original INSTANCE.  The structure of the INSTANCE is
transformed so that it conforms to the current class definition.  The
arguments to ÿupdate-instance-for-redefined-classþ are this transformed
INSTANCE, a list of ADDED-SLOTS to the INSTANCE, a list DISCARDED-SLOTS
from the INSTANCE, and the PROPERTY-LIST containing the slot names and
values for slots that were discarded and had values.  Included in this
list of discarded slots are slots that were local in the old class and
are shared in the new class.

The value returned by ÿupdate-instance-for-redefined-classþ is ignored.

Examples:
.........


 (defclass position () ())

 (defclass x-y-position (position)
     ((x :initform 0 :accessor position-x)
      (y :initform 0 :accessor position-y)))

;;; It turns out polar coordinates are used more than Cartesian
;;; coordinates, so the representation is altered and some new
;;; accessor methods are added.

 (defmethod update-instance-for-redefined-class :before
    ((pos x-y-position) added deleted plist &key)
   ;; Transform the x-y coordinates to polar coordinates
   ;; and store into the new slots.
   (let ((x (getf plist 'x))
         (y (getf plist 'y)))
     (setf (position-rho pos) (sqrt (+ (* x x) (* y y)))
           (position-theta pos) (atan y x))))

 (defclass x-y-position (position)
     ((rho :initform 0 :accessor position-rho)
      (theta :initform 0 :accessor position-theta)))

;;; All instances of the old x-y-position class will be updated
;;; automatically.

;;; The new representation is given the look and feel of the old one.

 (defmethod position-x ((pos x-y-position))
    (with-slots (rho theta) pos (* rho (cos theta))))

 (defmethod (setf position-x) (new-x (pos x-y-position))
    (with-slots (rho theta) pos
      (let ((y (position-y pos)))
        (setq rho (sqrt (+ (* new-x new-x) (* y y)))
              theta (atan y new-x))
        new-x)))

 (defmethod position-y ((pos x-y-position))
    (with-slots (rho theta) pos (* rho (sin theta))))

 (defmethod (setf position-y) (new-y (pos x-y-position))
    (with-slots (rho theta) pos
      (let ((x (position-x pos)))
        (setq rho (sqrt (+ (* x x) (* new-y new-y)))
              theta (atan new-y x))
        new-y)))

Exceptional Situations:
.......................

The system-supplied primary method on
ÿupdate-instance-for-redefined-classþ signals an error if an INITARG is
supplied that is not declared as valid.

See Also:
.........

*Note make-instances-obsolete::, *Note shared-initialize (Standard
Generic Function)::, *Note Section 4.3.6 (Redefining Classes):
Redefining Classes, *Note Section 7.1.4 (Rules for Initialization
Arguments): Rules for Initialization Arguments, *Note Section 7.1.2
(Declaring the Validity of Initialization Arguments): Declaring the
Validity of Initialization Arguments.

Notes:
......

INITARGS are declared as valid by using the :initarg option to
ÿdefclassþ, or by defining methods for
ÿupdate-instance-for-redefined-classþ or ÿshared-initializeþ.  The
keyword name of each keyword parameter specifier in the lambda list of
any method defined on ÿupdate-instance-for-redefined-classþ or
ÿshared-initializeþ is declared as a valid INITARG name for all classes
for which that method is applicable.


File: chris-ansicl.info,  Node: change-class,  Next: slot-boundp,  Prev: update-instance-for-redefined-class,  Up: Objects

change-class (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: change-class instance new-class &key
          &allow-other-keys ý instance

Method Signatures:
..................

change-class (INSTANCE ÿstandard-objectþ) (NEW-CLASS ÿstandard-classþ)
&rest initargs

change-class (INSTANCE ÿtþ) (NEW-CLASS ÿsymbolþ) &rest initargs

Arguments and Values:
.....................

INSTANCE--an object.

NEW-CLASS--a class designator.

INITARGS--an initialization argument list.

Description:
............

The generic function ÿchange-classþ changes the class of an INSTANCE to
NEW-CLASS.  It destructively modifies and returns the INSTANCE.

If in the old class there is any slot of the same name as a local slot
in the NEW-CLASS, the value of that slot is retained.  This means that
if the slot has a value, the value returned by ÿslot-valueþ after
ÿchange-classþ is invoked is ÿeqlþ to the value returned by
ÿslot-valueþ before ÿchange-classþ is invoked.  Similarly, if the slot
was unbound, it remains unbound.  The other slots are initialized as
described in *Note Section 7.2 (Changing the Class of an Instance):
Changing the Class of an Instance.

After completing all other actions, ÿchange-classþ invokes
ÿupdate-instance-for-different-classþ.  The generic function
ÿupdate-instance-for-different-classþ can be used to assign values to
slots in the transformed instance.  See *Note Section 7.2.2
(Initializing Newly Added Local Slots): Initializing Newly Added Local
Slots.

If the second of the above methods is selected, that method invokes
ÿchange-classþ on INSTANCE, ÿ(find-class NEW-CLASS)þ, and the INITARGS.

Examples:
.........


 (defclass position () ())

 (defclass x-y-position (position)
     ((x :initform 0 :initarg :x)
      (y :initform 0 :initarg :y)))

 (defclass rho-theta-position (position)
     ((rho :initform 0)
      (theta :initform 0)))

 (defmethod update-instance-for-different-class :before ((old x-y-position)
                                                         (new rho-theta-position)
                                                         &key)
   ;; Copy the position information from old to new to make new
   ;; be a rho-theta-position at the same position as old.
   (let ((x (slot-value old 'x))
         (y (slot-value old 'y)))
     (setf (slot-value new 'rho) (sqrt (+ (* x x) (* y y)))
           (slot-value new 'theta) (atan y x))))

;;; At this point an instance of the class x-y-position can be
;;; changed to be an instance of the class rho-theta-position using
;;; change-class:

 (setq p1 (make-instance 'x-y-position :x 2 :y 0))

 (change-class p1 'rho-theta-position)

;;; The result is that the instance bound to p1 is now an instance of
;;; the class rho-theta-position.   The update-instance-for-different-class
;;; method performed the initialization of the rho and theta slots based
;;; on the value of the x and y slots, which were maintained by
;;; the old instance.

See Also:
.........

*Note update-instance-for-different-class::, *Note Section 7.2
(Changing the Class of an Instance): Changing the Class of an Instance.

Notes:
......

The generic function ÿchange-classþ has several semantic difficulties.
First, it performs a destructive operation that can be invoked within a
method on an instance that was used to select that method.  When
multiple methods are involved because methods are being combined, the
methods currently executing or about to be executed may no longer be
applicable.  Second, some implementations might use compiler
optimizations of slot access, and when the class of an instance is
changed the assumptions the compiler made might be violated.  This
implies that a programmer must not use ÿchange-classþ inside a method
if any methods for that generic function access any slots, or the
results are undefined.


File: chris-ansicl.info,  Node: slot-boundp,  Next: slot-exists-p,  Prev: change-class,  Up: Objects

slot-boundp (Function)
======================

Syntax:
.......

 -- Function: slot-boundp instance slot-name ý generalized-boolean

Arguments and Values:
.....................

INSTANCE--an object.

SLOT-NAME--a symbol naming a slot of INSTANCE.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if the slot named SLOT-NAME in INSTANCE is bound;
otherwise, returns false.

Exceptional Situations:
.......................

If no slot of the name SLOT-NAME exists in the INSTANCE, ÿslot-missingþ
is called as follows:

 (slot-missing (class-of instance)
               instance
               slot-name
               'slot-boundp)

(If ÿslot-missingþ is invoked and returns a value, a boolean equivalent
to its primary value is returned by ÿslot-boundpþ.)

The specific behavior depends on INSTANCE's metaclass.  An error is
never signaled if INSTANCE has metaclass ÿstandard-classþ.  An error is
always signaled if INSTANCE has metaclass ÿbuilt-in-classþ.  The
consequences are undefined if INSTANCE has any other metaclass--an error
might or might not be signaled in this situation.  Note in particular
that the behavior for conditions and structures is not specified.

See Also:
.........

*Note slot-makunbound::, *Note slot-missing::

Notes:
......

The function ÿslot-boundpþ allows for writing after methods on
ÿinitialize-instanceþ in order to initialize only those slots that have
not already been bound.

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ÿslot-boundpþ using the
function ÿslot-boundp-using-classþ described in the Metaobject Protocol.


File: chris-ansicl.info,  Node: slot-exists-p,  Next: slot-makunbound,  Prev: slot-boundp,  Up: Objects

slot-exists-p (Function)
========================

Syntax:
.......

 -- Function: slot-exists-p object slot-name ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

SLOT-NAME--a symbol.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if the OBJECT has a slot named SLOT-NAME.

Affected By:
............

ÿdefclassþ, ÿdefstructþ

See Also:
.........

*Note defclass::, *Note slot-missing::

Notes:
......

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ÿslot-exists-pþ using the
function ÿslot-exists-p-using-classþ described in the Metaobject
Protocol.


File: chris-ansicl.info,  Node: slot-makunbound,  Next: slot-missing,  Prev: slot-exists-p,  Up: Objects

slot-makunbound (Function)
==========================

Syntax:
.......

 -- Function: slot-makunbound instance slot-name ý instance

Arguments and Values:
.....................

INSTANCE--instance.

SLOT-NAME--a symbol.

Description:
............

The function ÿslot-makunboundþ restores a slot of the name SLOT-NAME in
an INSTANCE to the unbound state.

Exceptional Situations:
.......................

If no slot of the name SLOT-NAME exists in the INSTANCE, ÿslot-missingþ
is called as follows:

(slot-missing (class-of instance)
              instance
              slot-name
              'slot-makunbound)

(Any values returned by ÿslot-missingþ in this case are ignored by
ÿslot-makunboundþ.)

The specific behavior depends on INSTANCE's metaclass.  An error is
never signaled if INSTANCE has metaclass ÿstandard-classþ.  An error is
always signaled if INSTANCE has metaclass ÿbuilt-in-classþ.  The
consequences are undefined if INSTANCE has any other metaclass--an error
might or might not be signaled in this situation.  Note in particular
that the behavior for conditions and structures is not specified.

See Also:
.........

*Note slot-boundp::, *Note slot-missing::

Notes:
......

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ÿslot-makunboundþ using
the function ÿslot-makunbound-using-classþ described in the Metaobject
Protocol.


File: chris-ansicl.info,  Node: slot-missing,  Next: slot-unbound,  Prev: slot-makunbound,  Up: Objects

slot-missing (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: slot-missing class object slot-name operation
          &optional new-value ý {result}*

Method Signatures:
..................

slot-missing (CLASS ÿtþ) object slot-name operation &optional new-value

Arguments and Values:
.....................

CLASS--the class of OBJECT.

OBJECT--an object.

SLOT-NAME--a symbol (the name of a would-be slot).

OPERATION--one of the symbols ÿsetfþ, ÿslot-boundpþ, ÿslot-makunboundþ,
or ÿslot-valueþ.

NEW-VALUE--an object.

RESULT--an object.

Description:
............

The generic function ÿslot-missingþ is invoked when an attempt is made
to access a slot in an OBJECT whose metaclass is ÿstandard-classþ and
the slot of the name SLOT-NAME is not a name of a slot in that class.
The default method signals an error.

The generic function ÿslot-missingþ is not intended to be called by
programmers.  Programmers may write methods for it.

The generic function ÿslot-missingþ may be called during evaluation of
ÿslot-valueþ, ÿ(setf slot-value)þ, ÿslot-boundpþ, and
ÿslot-makunboundþ.  For each of these operations the corresponding
symbol for the OPERATION argument is slot-value, setf, slot-boundp, and
slot-makunbound respectively.

The optional NEW-VALUE argument to ÿslot-missingþ is used when the
operation is attempting to set the value of the slot.

If ÿslot-missingþ returns, its values will be treated as follows:

   * If the OPERATION is setf or slot-makunbound, any values will be
     ignored by the caller.

   * If the OPERATION is slot-value, only the primary value will be
     used by the caller, and all other values will be ignored.

   * If the OPERATION is slot-boundp, any boolean equivalent of the
     primary value of the method might be is used, and all other values
     will be ignored.

Exceptional Situations:
.......................

The default method on ÿslot-missingþ signals an error of type ÿerrorþ.

See Also:
.........

*Note defclass::, *Note slot-exists-p::, *Note slot-value::

Notes:
......

The set of arguments (including the class of the instance) facilitates
defining methods on the metaclass for ÿslot-missingþ.


File: chris-ansicl.info,  Node: slot-unbound,  Next: slot-value,  Prev: slot-missing,  Up: Objects

slot-unbound (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: slot-unbound class instance slot-name ý {result}*

Method Signatures:
..................

slot-unbound (CLASS ÿtþ) instance slot-name

Arguments and Values:
.....................

CLASS--the class of the INSTANCE.

INSTANCE--the INSTANCE in which an attempt was made to read the unbound
slot.

SLOT-NAME--the name of the unbound slot.

RESULT--an object.

Description:
............

The generic function ÿslot-unboundþ is called when an unbound slot is
read in an INSTANCE whose metaclass is ÿstandard-classþ.  The default
method signals an error of type ÿunbound-slotþ.  The name slot of the
ÿunbound-slotþ condition is initialized to the name of the offending
variable, and the instance slot of the ÿunbound-slotþ condition is
initialized to the offending instance.

The generic function ÿslot-unboundþ is not intended to be called by
programmers.  Programmers may write methods for it.  The function
ÿslot-unboundþ is called only indirectly by ÿslot-valueþ.

If ÿslot-unboundþ returns, only the primary value will be used by the
caller, and all other values will be ignored.

Exceptional Situations:
.......................

The default method on ÿslot-unboundþ signals an error of type
ÿunbound-slotþ.

See Also:
.........

*Note slot-makunbound::

Notes:
......

An unbound slot may occur if no :initform form was specified for the
slot and the slot value has not been set, or if ÿslot-makunboundþ has
been called on the slot.


File: chris-ansicl.info,  Node: slot-value,  Next: method-qualifiers,  Prev: slot-unbound,  Up: Objects

slot-value (Function)
=====================

Syntax:
.......

 -- Function: slot-value object slot-name ý value

Arguments and Values:
.....................

OBJECT--an object.

NAME--a symbol.

VALUE--an object.

Description:
............

The function ÿslot-valueþ returns the value of the slot named SLOT-NAME
in the OBJECT.  If there is no slot named SLOT-NAME, ÿslot-missingþ is
called.  If the slot is unbound, ÿslot-unboundþ is called.

The macro ÿsetfþ can be used with ÿslot-valueþ to change the value of a
slot.

Examples:
.........

 (defclass foo ()
   ((a :accessor foo-a :initarg :a :initform 1)
    (b :accessor foo-b :initarg :b)
    (c :accessor foo-c :initform 3)))
ý #<STANDARD-CLASS FOO 244020371>
 (setq foo1 (make-instance 'foo :a 'one :b 'two))
ý #<FOO 36325624>
 (slot-value foo1 'a) ý ONE
 (slot-value foo1 'b) ý TWO
 (slot-value foo1 'c) ý 3
 (setf (slot-value foo1 'a) 'uno) ý UNO
 (slot-value foo1 'a) ý UNO
 (defmethod foo-method ((x foo))
   (slot-value x 'a))
ý #<STANDARD-METHOD FOO-METHOD (FOO) 42720573>
 (foo-method foo1) ý UNO

Exceptional Situations:
.......................

If an attempt is made to read a slot and no slot of the name SLOT-NAME
exists in the OBJECT, ÿslot-missingþ is called as follows:

 (slot-missing (class-of instance)
               instance
               slot-name
               'slot-value)

(If ÿslot-missingþ is invoked, its primary value is returned by
ÿslot-valueþ.)

If an attempt is made to write a slot and no slot of the name SLOT-NAME
exists in the OBJECT, ÿslot-missingþ is called as follows:

 (slot-missing (class-of instance)
               instance
               slot-name
               'setf
               new-value)

(If ÿslot-missingþ returns in this case, any values are ignored.)

The specific behavior depends on OBJECT's metaclass.  An error is never
signaled if OBJECT has metaclass ÿstandard-classþ.  An error is always
signaled if OBJECT has metaclass ÿbuilt-in-classþ.  The consequences are
unspecified if OBJECT has any other metaclass--an error might or might
not be signaled in this situation.  Note in particular that the behavior
for conditions and structures is not specified.

See Also:
.........

*Note slot-missing::, *Note slot-unbound::, *Note with-slots::

Notes:
......

Although no implementation is required to do so, implementors are
strongly encouraged to implement the function ÿslot-valueþ using the
function ÿslot-value-using-classþ described in the Metaobject Protocol.

Implementations may optimize ÿslot-valueþ by compiling it inline.


File: chris-ansicl.info,  Node: method-qualifiers,  Next: no-applicable-method,  Prev: slot-value,  Up: Objects

method-qualifiers (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: method-qualifiers method ý qualifiers

Method Signatures:
..................

method-qualifiers (METHOD ÿstandard-methodþ)

Arguments and Values:
.....................

METHOD--a method.

QUALIFIERS--a proper list.

Description:
............

Returns a list of the qualifiers of the METHOD.

Examples:
.........

 (defmethod some-gf :before ((a integer)) a)
ý #<STANDARD-METHOD SOME-GF (:BEFORE) (INTEGER) 42736540>
 (method-qualifiers *) ý (:BEFORE)

See Also:
.........

*Note define-method-combination::


File: chris-ansicl.info,  Node: no-applicable-method,  Next: no-next-method,  Prev: method-qualifiers,  Up: Objects

no-applicable-method (Standard Generic Function)
================================================

Syntax:
.......

 -- Generic Function: no-applicable-method generic-function &rest
          function-arguments ý {result}*

Method Signatures:
..................

no-applicable-method (GENERIC-FUNCTION ÿtþ) &rest function-arguments

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function on which no applicable method was
found.

FUNCTION-ARGUMENTS--arguments to the GENERIC-FUNCTION.

RESULT--an object.

Description:
............

The generic function ÿno-applicable-methodþ is called when a generic
function is invoked and no method on that generic function is
applicable.  The default method signals an error.

The generic function ÿno-applicable-methodþ is not intended to be
called by programmers.  Programmers may write methods for it.

Exceptional Situations:
.......................

The default method signals an error of type ÿerrorþ.

See Also:
.........


File: chris-ansicl.info,  Node: no-next-method,  Next: remove-method,  Prev: no-applicable-method,  Up: Objects

no-next-method (Standard Generic Function)
==========================================

Syntax:
.......

 -- Generic Function: no-next-method generic-function method &rest args
          ý {result}*

Method Signatures:
..................

no-next-method (GENERIC-FUNCTION ÿstandard-generic-functionþ)
(METHOD ÿstandard-methodþ) &rest args

Arguments and Values:
.....................

GENERIC-FUNCTION--generic function to which METHOD belongs.

METHOD--method that contained the call to ÿcall-next-methodþ for which
there is no next method.

ARGS--arguments to ÿcall-next-methodþ.

RESULT--an object.

Description:
............

The generic function ÿno-next-methodþ is called by ÿcall-next-methodþ
when there is no next method.

The generic function ÿno-next-methodþ is not intended to be called by
programmers.  Programmers may write methods for it.

Exceptional Situations:
.......................

The system-supplied method on ÿno-next-methodþ signals an error of type
ÿerrorþ.

See Also:
.........

*Note call-next-method::


File: chris-ansicl.info,  Node: remove-method,  Next: make-instance,  Prev: no-next-method,  Up: Objects

remove-method (Standard Generic Function)
=========================================

Syntax:
.......

 -- Generic Function: remove-method generic-function method ý
          generic-function

Method Signatures:
..................

remove-method (GENERIC-FUNCTION ÿstandard-generic-functionþ) method

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function.

METHOD--a method.

Description:
............

The generic function ÿremove-methodþ removes a method from
GENERIC-FUNCTION by modifying the GENERIC-FUNCTION (if necessary).

ÿremove-methodþ must not signal an error if the method is not one of
the methods on the GENERIC-FUNCTION.

See Also:
.........

*Note find-method::


File: chris-ansicl.info,  Node: make-instance,  Next: make-instances-obsolete,  Prev: remove-method,  Up: Objects

make-instance (Standard Generic Function)
=========================================

Syntax:
.......

 -- Generic Function: make-instance class &rest initargs &key
          &allow-other-keys ý instance

Method Signatures:
..................

make-instance (CLASS ÿstandard-classþ) &rest initargs

make-instance (CLASS ÿsymbolþ) &rest initargs

Arguments and Values:
.....................

CLASS--a class, or a symbol that names a class.

INITARGS--an initialization argument list.

INSTANCE--a fresh instance of class CLASS.

Description:
............

The generic function ÿmake-instanceþ creates and returns a new instance
of the given CLASS.

If the second of the above methods is selected, that method invokes
ÿmake-instanceþ on the arguments ÿ(find-class CLASS)þ and INITARGS.

The initialization arguments are checked within ÿmake-instanceþ.

The generic function ÿmake-instanceþ may be used as described in *Note
Section 7.1 (Object Creation and Initialization): Object Creation and
Initialization.

Exceptional Situations:
.......................

If any of the initialization arguments has not been declared as valid,
an error of type ÿerrorþ is signaled.

See Also:
.........

*Note defclass::, *Note class-of::, *Note allocate-instance::, *Note
initialize-instance (Standard Generic Function)::, *Note Section 7.1
(Object Creation and Initialization): Object Creation and
Initialization.


File: chris-ansicl.info,  Node: make-instances-obsolete,  Next: make-load-form,  Prev: make-instance,  Up: Objects

make-instances-obsolete (Standard Generic Function)
===================================================

Syntax:
.......

 -- Generic Function: make-instances-obsolete class ý class

Method Signatures:
..................

make-instances-obsolete (CLASS ÿstandard-classþ)

make-instances-obsolete (CLASS ÿsymbolþ)

Arguments and Values:
.....................

CLASS--a class designator.

Description:
............

The function ÿmake-instances-obsoleteþ has the effect of initiating the
process of updating the instances of the class. During updating, the
generic function ÿupdate-instance-for-redefined-classþ will be invoked.

The generic function ÿmake-instances-obsoleteþ is invoked automatically
by the system when ÿdefclassþ has been used to redefine an existing
standard class and the set of local slots accessible in an instance is
changed or the order of slots in storage is changed.  It can also be
explicitly invoked by the user.

If the second of the above methods is selected, that method invokes
ÿmake-instances-obsoleteþ on ÿ(find-class CLASS)þ.

Examples:
.........

See Also:
.........

*Note update-instance-for-redefined-class::, *Note Section 4.3.6
(Redefining Classes): Redefining Classes.


File: chris-ansicl.info,  Node: make-load-form,  Next: make-load-form-saving-slots,  Prev: make-instances-obsolete,  Up: Objects

make-load-form (Standard Generic Function)
==========================================

Syntax:
.......

 -- Generic Function: make-load-form object &optional environment ý
          creation-form[, initialization-form]

Method Signatures:
..................

make-load-form (OBJECT ÿstandard-objectþ)  &optional environment
make-load-form (OBJECT ÿstructure-objectþ) &optional environment
make-load-form (OBJECT ÿconditionþ)        &optional environment
make-load-form (OBJECT ÿclassþ)            &optional environment

Arguments and Values:
.....................

OBJECT--an object.

ENVIRONMENT--an environment object.

CREATION-FORM--a form.

INITIALIZATION-FORM--a form.

Description:
............

The generic function ÿmake-load-formþ creates and returns one or two
forms, a CREATION-FORM and an INITIALIZATION-FORM, that enable ÿloadþ
to construct an object equivalent to OBJECT.  ENVIRONMENT is an
environment object corresponding to the lexical environment in which
the forms will be processed.

The file compiler calls ÿmake-load-formþ to process certain classes of
literal objects; see *Note Section 3.2.4.4 (Additional Constraints on
Externalizable Objects): CallingMakeLoadForm.

Conforming programs may call ÿmake-load-formþ directly, providing
OBJECT is a generalized instance of ÿstandard-objectþ,
ÿstructure-objectþ, or ÿconditionþ.

The creation form is a form that, when evaluated at ÿloadþ time, should
return an object that is equivalent to OBJECT.  The exact meaning of
equivalent depends on the type of object and is up to the programmer
who defines a method for ÿmake-load-formþ; see *Note Section 3.2.4
(Literal Objects in Compiled Files): Literal Objects in Compiled Files.

The initialization form is a form that, when evaluated at ÿloadþ time,
should perform further initialization of the object.  The value
returned by the initialization form is ignored.  If ÿmake-load-formþ
returns only one value, the initialization form is ÿnilþ, which has no
effect.  If OBJECT appears as a constant in the initialization form, at
ÿloadþ time it will be replaced by the equivalent object constructed by
the creation form; this is how the further initialization gains access
to the object.

Both the CREATION-FORM and the INITIALIZATION-FORM may contain
references to any externalizable object.  However, there must not be
any circular dependencies in creation forms.  An example of a circular
dependency is when the creation form for the object ÿXþ contains a
reference to the object ÿYþ, and the creation form for the object ÿYþ
contains a reference to the object ÿXþ.  Initialization forms are not
subject to any restriction against circular dependencies, which is the
reason that initialization forms exist; see the example of circular
data structures below.

The creation form for an object is always evaluated before the
initialization form for that object.  When either the creation form or
the initialization form references other objects that have not been
referenced earlier in the file being compiled, the compiler ensures
that all of the referenced objects have been created before evaluating
the referencing form.  When the referenced object is of a type which
the file compiler processes using ÿmake-load-formþ, this involves
evaluating the creation form returned for it.  (This is the reason for
the prohibition against circular references among creation forms).

Each initialization form is evaluated as soon as possible after its
associated creation form, as determined by data flow.  If the
initialization form for an object does not reference any other objects
not referenced earlier in the file and processed by the file compiler
using ÿmake-load-formþ, the initialization form is evaluated
immediately after the creation form.  If a creation or initialization
form F does contain references to such objects, the creation forms for
those other objects are evaluated before F, and the initialization
forms for those other objects are also evaluated before F whenever they
do not depend on the object created or initialized by F.  Where these
rules do not uniquely determine an order of evaluation between two
creation/initialization forms, the order of evaluation is unspecified.

While these creation and initialization forms are being evaluated, the
objects are possibly in an uninitialized state, analogous to the state
of an object between the time it has been created by ÿallocate-instanceþ
and it has been processed fully by ÿinitialize-instanceþ.  Programmers
writing methods for ÿmake-load-formþ must take care in manipulating
objects not to depend on slots that have not yet been initialized.

It is implementation-dependent whether ÿloadþ calls ÿevalþ on the forms
or does some other operation that has an equivalent effect.  For
example, the forms might be translated into different but equivalent
forms and then evaluated, they might be compiled and the resulting
functions called by ÿloadþ, or they might be interpreted by a
special-purpose function different from ÿevalþ.  All that is required
is that the effect be equivalent to evaluating the forms.

The method specialized on ÿclassþ returns a creation form using the
name of the class if the class has a proper name in ENVIRONMENT,
signaling an error of type ÿerrorþ if it does not have a proper name.
Evaluation of the creation form uses the name to find the class with
that name, as if by calling ÿfind-classþ.  If a class with that name
has not been defined, then a class may be computed in an
implementation-defined manner.  If a class cannot be returned as the
result of evaluating the creation form, then an error of type ÿerrorþ
is signaled.

Both conforming implementations and conforming programs may further
specialize ÿmake-load-formþ.

Examples:
.........

 (defclass obj ()
    ((x :initarg :x :reader obj-x)
     (y :initarg :y :reader obj-y)
     (dist :accessor obj-dist)))
ý #<STANDARD-CLASS OBJ 250020030>
 (defmethod shared-initialize :after ((self obj) slot-names &rest keys)
   (declare (ignore slot-names keys))
   (unless (slot-boundp self 'dist)
     (setf (obj-dist self)
           (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))
ý #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>
 (defmethod make-load-form ((self obj) &optional environment)
   (declare (ignore environment))
   ;; Note that this definition only works because X and Y do not
   ;; contain information which refers back to the object itself.
   ;; For a more general solution to this problem, see revised example below.
   `(make-instance ',(class-of self)
                   :x ',(obj-x self) :y ',(obj-y self)))
ý #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>
 (setq obj1 (make-instance 'obj :x 3.0 :y 4.0)) ý #<OBJ 26274136>
 (obj-dist obj1) ý 5.0
 (make-load-form obj1) ý (MAKE-INSTANCE 'OBJ :X '3.0 :Y '4.0)

In the above example, an equivalent instance of ÿobjþ is reconstructed
by using the values of two of its slots.  The value of the third slot
is derived from those two values.

Another way to write the ÿmake-load-formþ method in that example is to
use ÿmake-load-form-saving-slotsþ.  The code it generates might yield a
slightly different result from the ÿmake-load-formþ method shown above,
but the operational effect will be the same.  For example:

 ;; Redefine method defined above.
 (defmethod make-load-form ((self obj) &optional environment)
    (make-load-form-saving-slots self
                                 :slot-names '(x y)
                                 :environment environment))
ý #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>
 ;; Try MAKE-LOAD-FORM on object created above.
 (make-load-form obj1)
ý (ALLOCATE-INSTANCE '#<STANDARD-CLASS OBJ 250020030>),
    (PROGN
      (SETF (SLOT-VALUE '#<OBJ 26274136> 'X) '3.0)
      (SETF (SLOT-VALUE '#<OBJ 26274136> 'Y) '4.0)
      (INITIALIZE-INSTANCE '#<OBJ 26274136>))

In the following example, instances of ÿmy-frobþ are "interned" in some
way.  An equivalent instance is reconstructed by using the value of the
name slot as a key for searching existing objects.  In this case the
programmer has chosen to create a new object if no existing object is
found; alternatively an error could have been signaled in that case.

 (defclass my-frob ()
    ((name :initarg :name :reader my-name)))
 (defmethod make-load-form ((self my-frob) &optional environment)
   (declare (ignore environment))
   `(find-my-frob ',(my-name self) :if-does-not-exist :create))

In the following example, the data structure to be dumped is circular,
because each parent has a list of its children and each child has a
reference back to its parent.  If ÿmake-load-formþ is called on one
object in such a structure,  the creation form creates an equivalent
object and fills in the children slot, which forces creation of
equivalent objects for all of its children, grandchildren, etc.  At
this point none of the parent slots have been filled in.  The
initialization form fills in the parent slot, which forces creation of
an equivalent object for the parent if it was not already created.
Thus the entire tree is recreated at ÿloadþ time.  At compile time,
ÿmake-load-formþ is called once for each object in the tree.  All of
the creation forms are evaluated, in implementation-dependent order,
and then all of the initialization forms are evaluated, also in
implementation-dependent order.

 (defclass tree-with-parent () ((parent :accessor tree-parent)
                                (children :initarg :children)))
 (defmethod make-load-form ((x tree-with-parent) &optional environment)
   (declare (ignore environment))
   (values
     ;; creation form
     `(make-instance ',(class-of x) :children ',(slot-value x 'children))
     ;; initialization form
     `(setf (tree-parent ',x) ',(slot-value x 'parent))))

In the following example, the data structure to be dumped has no special
properties and an equivalent structure can be reconstructed simply by
reconstructing the slots' contents.

 (defstruct my-struct a b c)
 (defmethod make-load-form ((s my-struct) &optional environment)
    (make-load-form-saving-slots s :environment environment))

Exceptional Situations:
.......................

The methods specialized on ÿstandard-objectþ, ÿstructure-objectþ, and
ÿconditionþ all signal an error of type ÿerrorþ.

It is implementation-dependent whether calling ÿmake-load-formþ on a
generalized instance of a system class signals an error or returns
creation and initialization forms.

See Also:
.........

*Note compile-file::, *Note make-load-form-saving-slots::, *Note
Section 3.2.4.4 (Additional Constraints on Externalizable Objects):
CallingMakeLoadForm.  *Note Section 3.1 (Evaluation): Evaluation, *Note
Section 3.2 (Compilation): Compilation.

Notes:
......

The file compiler calls ÿmake-load-formþ in specific circumstances
detailed in *Note Section 3.2.4.4 (Additional Constraints on
Externalizable Objects): CallingMakeLoadForm.

Some implementations may provide facilities for defining new subclasses
of classes which are specified as system classes.  (Some likely
candidates include ÿgeneric-functionþ, ÿmethodþ, and ÿstreamþ).  Such
implementations should document how the file compiler processes
instances of such classes when encountered as literal objects, and
should document any relevant methods for ÿmake-load-formþ.


File: chris-ansicl.info,  Node: make-load-form-saving-slots,  Next: with-accessors,  Prev: make-load-form,  Up: Objects

make-load-form-saving-slots (Function)
======================================

Syntax:
.......

 -- Function: make-load-form-saving-slots object &key slot-names
          environment ý creation-form, initialization-form

Arguments and Values:
.....................

OBJECT--an object.

SLOT-NAMES--a list.

ENVIRONMENT--an environment object.

CREATION-FORM--a form.

INITIALIZATION-FORM--a form.

Description:
............

Returns forms that, when evaluated, will construct an object equivalent
to OBJECT, without executing initialization forms.  The slots in the
new object that correspond to initialized slots in OBJECT are
initialized using the values from OBJECT.  Uninitialized slots in
OBJECT are not initialized in the new object.
ÿmake-load-form-saving-slotsþ works for any instance of
ÿstandard-objectþ or ÿstructure-objectþ.

SLOT-NAMES is a list of the names of the slots to preserve. If
SLOT-NAMES is not supplied, its value is all of the local slots.

ÿmake-load-form-saving-slotsþ returns two values, thus it can deal with
circular structures.  Whether the result is useful in an application
depends on whether the OBJECT's type and slot contents fully capture
the application's idea of the OBJECT's state.

ENVIRONMENT is the environment in which the forms will be processed.

See Also:
.........

*Note make-load-form::, *Note make-instance::, *Note setf::, *Note
slot-value::, *Note slot-makunbound::

Notes:
......

ÿmake-load-form-saving-slotsþ can be useful in user-written
ÿmake-load-formþ methods.

When the object is an instance of ÿstandard-objectþ,
ÿmake-load-form-saving-slotsþ could return a creation form that calls
ÿallocate-instanceþ and an initialization form that contains calls to
ÿsetfþ of ÿslot-valueþ and ÿslot-makunboundþ, though other functions of
similar effect might actually be used.


File: chris-ansicl.info,  Node: with-accessors,  Next: with-slots,  Prev: make-load-form-saving-slots,  Up: Objects

with-accessors (Macro)
======================

Syntax:
.......

 -- Macro: with-accessors ({slot-entry}*) instance-form {declaration}*
          {form}* ý {result}*

SLOT-ENTRY::=
     (variable-name accessor-name)

Arguments and Values:
.....................

VARIABLE-NAME--a variable name; not evaluated.

ACCESSOR-NAME--a function name; not evaluated.

INSTANCE-FORM--a form; evaluated.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

Creates a lexical environment in which the slots specified by
SLOT-ENTRY are lexically available through their accessors as if they
were variables.  The macro ÿwith-accessorsþ invokes the appropriate
accessors to ACCESS the slots specified by SLOT-ENTRY.  Both ÿsetfþ and
ÿsetqþ can be used to set the value of the slot.

Examples:
.........

 (defclass thing ()
           ((x :initarg :x :accessor thing-x)
            (y :initarg :y :accessor thing-y)))
ý #<STANDARD-CLASS THING 250020173>
 (defmethod (setf thing-x) :before (new-x (thing thing))
   (format t "~&Changing X from ~D to ~D in ~S.~%"
           (thing-x thing) new-x thing))
 (setq thing1 (make-instance 'thing :x 1 :y 2)) ý #<THING 43135676>
 (setq thing2 (make-instance 'thing :x 7 :y 8)) ý #<THING 43147374>
 (with-accessors ((x1 thing-x) (y1 thing-y))
                 thing1
   (with-accessors ((x2 thing-x) (y2 thing-y))
                   thing2
     (list (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2))
           (setq x1 (+ y1 x2))
           (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2))
           (setf (thing-x thing2) (list x1))
           (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2)))))
Ö Changing X from 1 to 9 in #<THING 43135676>.
Ö Changing X from 7 to (9) in #<THING 43147374>.
ý ((1 1 2 2 7 7 8 8)
     9
     (9 9 2 2 7 7 8 8)
     (9)
     (9 9 2 2 (9) (9) 8 8))

Affected By:
............

ÿdefclassþ

Exceptional Situations:
.......................

The consequences are undefined if any ACCESSOR-NAME is not the name of
an accessor for the INSTANCE.

See Also:
.........

*Note with-slots::, *Note symbol-macrolet::

Notes:
......

A ÿwith-accessorsþ expression of the form:

(with-accessors (SLOT-ENTRYá, ... SLOT-ENTRY_n)
INSTANCE-FORM FORMá ... FORM_k)

expands into the equivalent of

(let ((in INSTANCE-FORM))
(symbol-macrolet (Qá ... Q_n) FORMá ... FORM_k))

where Q_i is

(VARIABLE-NAME_i () (ACCESSOR-NAME_i in))


File: chris-ansicl.info,  Node: with-slots,  Next: defclass,  Prev: with-accessors,  Up: Objects

with-slots (Macro)
==================

Syntax:
.......

 -- Macro: with-slots ({slot-entry}*) instance-form {declaration}*
          {form}* ý {result}*

SLOT-ENTRY::=
     slot-name | (variable-name slot-name)

Arguments and Values:
.....................

SLOT-NAME--a slot name; not evaluated.

VARIABLE-NAME--a variable name; not evaluated.

INSTANCE-FORM--a form; evaluted to produce INSTANCE.

INSTANCE--an object.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

The macro ÿwith-slotsþ establishes a lexical environment for referring
to the slots in the INSTANCE named by the given SLOT-NAMES as though
they were variables.  Within such a context the value of the slot can
be specified by using its slot name, as if it were a lexically bound
variable.  Both ÿsetfþ and ÿsetqþ can be used to set the value of the
slot.

The macro ÿwith-slotsþ translates an appearance of the slot name as a
variable into a call to ÿslot-valueþ.

Examples:
.........

 (defclass thing ()
           ((x :initarg :x :accessor thing-x)
            (y :initarg :y :accessor thing-y)))
ý #<STANDARD-CLASS THING 250020173>
 (defmethod (setf thing-x) :before (new-x (thing thing))
   (format t "~&Changing X from ~D to ~D in ~S.~%"
           (thing-x thing) new-x thing))
 (setq thing (make-instance 'thing :x 0 :y 1)) ý #<THING 62310540>
 (with-slots (x y) thing (incf x) (incf y)) ý 2
 (values (thing-x thing) (thing-y thing)) ý 1, 2
 (setq thing1 (make-instance 'thing :x 1 :y 2)) ý #<THING 43135676>
 (setq thing2 (make-instance 'thing :x 7 :y 8)) ý #<THING 43147374>
 (with-slots ((x1 x) (y1 y))
             thing1
   (with-slots ((x2 x) (y2 y))
               thing2
     (list (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2))
           (setq x1 (+ y1 x2))
           (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2))
           (setf (thing-x thing2) (list x1))
           (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2)))))
Ö Changing X from 7 to (9) in #<THING 43147374>.
ý ((1 1 2 2 7 7 8 8)
     9
     (9 9 2 2 7 7 8 8)
     (9)
     (9 9 2 2 (9) (9) 8 8))

Affected By:
............

ÿdefclassþ

Exceptional Situations:
.......................

The consequences are undefined if any SLOT-NAME is not the name of a
slot in the INSTANCE.

See Also:
.........

*Note with-accessors::, *Note slot-value::, *Note symbol-macrolet::

Notes:
......

A ÿwith-slotsþ expression of the form:

(with-accessors (SLOT-ENTRYá, ... SLOT-ENTRY_n)
INSTANCE-FORM FORMá ... FORM_k)

expands into the equivalent of

(let ((in INSTANCE-FORM))
(symbol-macrolet (Qá ... Q_n) FORMá ... FORM_k))

where Q_i is

(SLOT-ENTRY_i () (slot-value in 'SLOT-ENTRY_i))

if SLOT-ENTRY_i is a symbol and is

(VARIABLE-NAME_i () (slot-value in 'SLOT-NAME_i))

if SLOT-ENTRY_i is of the form

(VARIABLE-NAME_i SLOT-NAME_i)


File: chris-ansicl.info,  Node: defclass,  Next: defgeneric,  Prev: with-slots,  Up: Objects

defclass (Macro)
================

Syntax:
.......

 -- Macro: defclass CLASS-NAME ({SUPERCLASS-NAME}*) ({slot-specifier}*)
          [[ðclass-option]] ý new-class

slot-specifier::=
     slot-name | (slot-name ùðslot-optionø)

slot-name::= symbol

slot-option::=
     {:reader reader-function-name}* |
     {:writer writer-function-name}* |
     {:accessor reader-function-name}* |
     {:allocation allocation-type} |
     {:initarg initarg-name}* |
     {:initform form} |
     {:type type-specifier} |
     {:documentation string}

function-name::= {symbol | (setf symbol)}

class-option::=
     (:default-initargs . initarg-list) |
     (:documentation string) |
     (:metaclass class-name)

Arguments and Values:
.....................

CLASS-NAME--a non-nil symbol.

SUPERCLASS-NAME--a non-nil symbol.

SLOT-NAME--a symbol.  The SLOT-NAME argument is a symbol that is
syntactically valid for use as a variable name.

READER-FUNCTION-NAME--a non-nil symbol.  :reader can be supplied more
than once for a given slot.

WRITER-FUNCTION-NAME--a generic function name.  :writer can be supplied
more than once for a given slot.

READER-FUNCTION-NAME--a non-nil symbol.  :accessor can be supplied more
than once for a given slot.

ALLOCATION-TYPE--(member :instance :class).  :allocation can be
supplied once at most for a given slot.

INITARG-NAME--a symbol.  :initarg can be supplied more than once for a
given slot.

FORM--a form.  :init-form can be supplied once at most for a given slot.

TYPE-SPECIFIER--a type specifier.  :type can be supplied once at most
for a given slot.

CLASS-OPTION-- refers to the class as a whole or to all class slots.

INITARG-LIST--a list of alternating initialization argument names and
default initial value forms.  :default-initargs can be supplied at most
once.

CLASS-NAME--a non-nil symbol.  :metaclass can be supplied once at most.

NEW-CLASS--the new class object.

Description:
............

The macro ÿdefclassþ defines a new named class.  It returns the new
class object as its result.

The syntax of ÿdefclassþ provides options for specifying initialization
arguments for slots, for specifying default initialization values for
slots, and for requesting that methods on specified generic functions
be automatically generated for reading and writing the values of slots.
No reader or writer functions are defined by default; their generation
must be explicitly requested.  However, slots can always be accessed
using ÿslot-valueþ.

Defining a new class also causes a type of the same name to be defined.
The predicate ÿ(typep OBJECT CLASS-NAME)þ returns true if the class of
the given OBJECT is the class named by CLASS-NAME itself or a subclass
of the class CLASS-NAME.  A class object can be used as a type
specifier.  Thus ÿ(typep OBJECT CLASS)þ returns true if the class of
the OBJECT is CLASS itself or a subclass of CLASS.

The CLASS-NAME argument specifies the proper name of the new class.  If
a class with the same proper name already exists and that class is an
instance of ÿstandard-classþ, and if the ÿdefclassþ form for the
definition of the new class specifies a class of class ÿstandard-classþ,
the existing class is redefined, and instances of it (and its
subclasses) are updated to the new definition at the time that they are
next accessed.  For details, see *Note Section 4.3.6 (Redefining
Classes): Redefining Classes.

Each SUPERCLASS-NAME argument specifies a direct superclass of the new
class.  If the superclass list is empty, then the superclass defaults
depending on the metaclass, with ÿstandard-objectþ being the default
for ÿstandard-classþ.

The new class will inherit slots and methods from each of its direct
superclasses, from their direct superclasses, and so on.  For a
discussion of how slots and methods are inherited, see *Note Section
4.3.4 (Inheritance): Inheritance.

The following slot options are available:

   * The :reader slot option specifies that an unqualified method is to
     be defined on the generic function named READER-FUNCTION-NAME to
     read the value of the given slot.

   * The :writer slot option specifies that an unqualified method is to
     be defined on the generic function named WRITER-FUNCTION-NAME to
     write the value of the slot.

   * The :accessor slot option specifies that an unqualified method is
     to be defined on the generic function named READER-FUNCTION-NAME
     to read the value of the given slot and that an unqualified method
     is to be defined on the generic function named ÿ(setf
     READER-FUNCTION-NAME)þ to be used with ÿsetfþ to modify the value
     of the slot.

   * The :allocation slot option is used to specify where storage is to
     be allocated for the given slot.  Storage for a slot can be located
     in each instance or in the class object itself.  The value of the
     ALLOCATION-TYPE argument can be either the keyword :instance or
     the keyword :class.    If the :allocation slot option is not
     specified, the effect is the same as specifying ÿ:allocation
     :instanceþ.

        - If ALLOCATION-TYPE is :instance, a local slot of the name
          SLOT-NAME is allocated in each instance of the class.

        - If ALLOCATION-TYPE is :class, a shared slot of the given name
          is allocated in the class object created by this ÿdefclassþ
          form.  The value of the slot is shared by all instances of
          the class.  If a class Cá defines such a shared slot, any
          subclass Cà of Cá will share this single slot unless the
          ÿdefclassþ form for Cà specifies a slot of the same name or
          there is a superclass of Cà that precedes Cá in the class
          precedence list of Cà and that defines a slot of the same
          name.

   * The :initform slot option is used to provide a default initial
     value form to be used in the initialization of the slot.  This
     form is evaluated every time it is used to initialize the slot.
     The lexical environment in which this form is evaluated is the
     lexical environment in which the ÿdefclassþ form was evaluated.
     Note that the lexical environment refers both to variables and to
     functions.  For local slots, the dynamic environment is the dynamic
     environment in which ÿmake-instanceþ is called; for shared slots,
     the dynamic environment is the dynamic environment in which the
     ÿdefclassþ form was evaluated.  See *Note Section 7.1 (Object
     Creation and Initialization): Object Creation and Initialization.

     No implementation is permitted to extend the syntax of ÿdefclassþ
     to allow ÿ(SLOT-NAME FORM)þ as an abbreviation for ÿ(SLOT-NAME
     :initform FORM)þ.

   * The :initarg slot option declares an initialization argument named
     INITARG-NAME and specifies that this initialization argument
     initializes the given slot.  If the initialization argument has a
     value in the call to ÿinitialize-instanceþ, the value will be
     stored into the given slot, and the slot's :initform slot option,
     if any, is not evaluated.  If none of the initialization arguments
     specified for a given slot has a value, the slot is initialized
     according to the :initform slot option, if specified.

   * The :type slot option specifies that the contents of the slot will
     always be of the specified data type.  It effectively declares the
     result type of the reader generic function when applied to an
     object of this class.  The consequences of attempting to store in a
     slot a value that does not satisfy the type of the slot are
     undefined.  The :type slot option is further discussed in *Note
     Section 7.5.3 (Inheritance of Slots and Slot Options): Inheritance
     of Slots and Slot Options.

   * The :documentation slot option provides a documentation string for
     the slot.  :documentation can be supplied once at most for a given
     slot.

Each class option is an option that refers to the class as a whole.
The following class options are available:

   * The :default-initargs class option is followed by a list of
     alternating initialization argument names and default initial value
     forms.  If any of these initialization arguments does not appear in
     the initialization argument list supplied to ÿmake-instanceþ, the
     corresponding default initial value form is evaluated, and the
     initialization argument name and the form's value are added to the
     end of the initialization argument list before the instance is
     created; see *Note Section 7.1 (Object Creation and
     Initialization): Object Creation and Initialization.  The default
     initial value form is evaluated each time it is used.  The lexical
     environment in which this form is evaluated is the lexical
     environment in which the ÿdefclassþ form was evaluated.  The
     dynamic environment is the dynamic environment in which
     ÿmake-instanceþ was called.  If an initialization argument name
     appears more than once in a :default-initargs class option, an
     error is signaled.

   * The :documentation class option causes a documentation string to
     be attached with the class object, and attached with kind type to
     the CLASS-NAME.  :documentation can be supplied once at most.

   * The :metaclass class option is used to specify that instances of
     the class being defined are to have a different metaclass than the
     default provided by the system (the class ÿstandard-classþ).

Note the following rules of ÿdefclassþ for standard classes:

   * It is not required that the superclasses of a class be defined
     before the ÿdefclassþ form for that class is evaluated.

   * All the superclasses of a class must be defined before an instance
     of the class can be made.

   * A class must be defined before it can be used as a parameter
     specializer in a ÿdefmethodþ form.

The object system can be extended to cover situations where these rules
are not obeyed.

Some slot options are inherited by a class from its superclasses, and
some can be shadowed or altered by providing a local slot description.
No class options except :default-initargs are inherited.  For a
detailed description of how slots and slot options are inherited, see
*Note Section 7.5.3 (Inheritance of Slots and Slot Options):
Inheritance of Slots and Slot Options.

The options to ÿdefclassþ can be extended.  It is required that all
implementations signal an error if they observe a class option or a
slot option that is not implemented locally.

It is valid to specify more than one reader, writer, accessor, or
initialization argument for a slot.  No other slot option can appear
more than once in a single slot description, or an error is signaled.

If no reader, writer, or accessor is specified for a slot, the slot can
only be accessed by the function ÿslot-valueþ.

If a ÿdefclassþ form appears as a top level form, the compiler must
make the class name be recognized as a valid type name in subsequent
declarations (as for ÿdeftypeþ) and be recognized as a valid class name
for ÿdefmethodþ parameter specializers and for use as the :metaclass
option of a subsequent ÿdefclassþ.  The compiler must make the class
definition available to be returned by ÿfind-classþ when its ENVIRONMENT
argument is a value received as the environment parameter of a macro.

Exceptional Situations:
.......................

If there are any duplicate slot names, an error of type ÿprogram-errorþ
is signaled.

If an initialization argument name appears more than once in
:default-initargs class option, an error of type ÿprogram-errorþ is
signaled.

If any of the following slot options appears more than once in a single
slot description, an error of type ÿprogram-errorþ is signaled:
:allocation, :initform, :type, :documentation.

It is required that all implementations signal an error of type
ÿprogram-errorþ if they observe a class option or a slot option that is
not implemented locally.

See Also:
.........

*Note documentation::, *Note initialize-instance (Standard Generic
Function)::, *Note make-instance::, *Note slot-value::, *Note Section
4.3 (Classes): Classes, *Note Section 4.3.4 (Inheritance): Inheritance,
*Note Section 4.3.6 (Redefining Classes): Redefining Classes, *Note
Section 4.3.5 (Determining the Class Precedence List): Determining the
Class Precedence List, *Note Section 7.1 (Object Creation and
Initialization): Object Creation and Initialization.


File: chris-ansicl.info,  Node: defgeneric,  Next: defmethod,  Prev: defclass,  Up: Objects

defgeneric (Macro)
==================

Syntax:
.......

 -- Macro: defgeneric function-name gf-lambda-list ùûoption |
          {ûmethod-description}*ø ý new-generic

OPTION::=
     (:argument-precedence-order {PARAMETER-NAME}+) |
     (declare {GF-DECLARATION}+) |
     (:documentation GF-DOCUMENTATION) |
     (:method-combination METHOD-COMBINATION
     {method-combination-argument}*) |
     (:generic-function-class GENERIC-FUNCTION-CLASS) |
     (:method-class METHOD-CLASS)

METHOD-DESCRIPTION::=
     (:method {method-qualifier}* SPECIALIZED-LAMBDA-LIST
     ù{declaration}* | documentationø {form}*)

Arguments and Values:
.....................

FUNCTION-NAME--a function name.

GENERIC-FUNCTION-CLASS--a non-nil symbol naming a class.

GF-DECLARATION--an ÿoptimizeþ declaration specifier; other declaration
specifiers are not permitted.

GF-DOCUMENTATION--a string; not evaluated.

GF-LAMBDA-LIST--a generic function lambda list.

METHOD-CLASS--a non-nil symbol naming a class.

METHOD-COMBINATION-ARGUMENT--an object.

METHOD-COMBINATION-NAME--a symbol naming a method combination type.

METHOD-QUALIFIERS, SPECIALIZED-LAMBDA-LIST, DECLARATIONS, DOCUMENTATION,
FORMS--as per ÿdefmethodþ.

NEW-GENERIC--the generic function object.

PARAMETER-NAME--a symbol that names a required parameter in the
LAMBDA-LIST.  (If the :argument-precedence-order option is specified,
each required parameter in the LAMBDA-LIST must be used exactly once as
a PARAMETER-NAME.)

Description:
............

The macro ÿdefgenericþ is used to define a generic function or to
specify options and declarations that pertain to a generic function as
a whole.

If FUNCTION-NAME is a list it must be of the form ÿ(setf symbol)þ.  If
ÿ(fboundp FUNCTION-NAME)þ is false, a new generic function is created.
If ÿ(fdefinition FUNCTION-NAME)þ is a generic function, that generic
function is modified.  If FUNCTION-NAME names an ordinary function, a
macro, or a special operator, an error is signaled.

The effect of the ÿdefgenericþ macro is as if the following three steps
were performed: first, methods defined by previous ÿdefgenericþ forms
are removed;

second, ÿensure-generic-functionþ is called; and finally, methods
specified by the current ÿdefgenericþ form are added to the generic
function.

Each METHOD-DESCRIPTION defines a method on the generic function.  The
lambda list of each method must be congruent with the lambda list
specified by the GF-LAMBDA-LIST option.  If no method descriptions are
specified and a generic function of the same name does not already
exist, a generic function with no methods is created.

The GF-LAMBDA-LIST argument of ÿdefgenericþ specifies the shape of
lambda lists for the methods on this generic function.  All methods on
the resulting generic function must have lambda lists that are
congruent with this shape.  If a ÿdefgenericþ form is evaluated and some
methods for that generic function have lambda lists that are not
congruent with that given in the ÿdefgenericþ form, an error is
signaled.  For further details on method congruence, see *Note Section
7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function.

The generic function passes to the method all the argument values
passed to it, and only those; default values are not supported.  Note
that optional and keyword arguments in method definitions, however, can
have default initial value forms and can use supplied-p parameters.

The following options are provided.  Except as otherwise noted, a given
option may occur only once.

   * The :argument-precedence-order option is used to specify the order
     in which the required arguments in a call to the generic function
     are tested for specificity when selecting a particular method.
     Each required argument, as specified in the GF-LAMBDA-LIST
     argument, must be included exactly once as a PARAMETER-NAME so
     that the full and unambiguous precedence order is supplied.  If
     this condition is not met, an error is signaled.

   * The declare option is used to specify declarations that pertain to
     the generic function.

     An ÿoptimizeþ declaration specifier is allowed.  It specifies
     whether method selection should be optimized for speed or space,
     but it has no effect on methods.  To control how a method is
     optimized, an ÿoptimizeþ declaration must be placed directly in
     the ÿdefmethodþ form or method description.  The optimization
     qualities speed and space are the only qualities this standard
     requires, but an implementation can extend the object system to
     recognize other qualities.  A simple implementation that has only
     one method selection technique and ignores ÿoptimizeþ declaration
     specifiers is valid.

     The ÿspecialþ, ÿftypeþ, ÿfunctionþ, ÿinlineþ, ÿnotinlineþ, and
     ÿdeclarationþ declarations are not permitted.  Individual
     implementations can extend the declare option to support
     additional declarations.

     If an implementation notices a declaration specifier that it does
     not support and that has not been proclaimed as a non-standard
     declaration identifier name in a ÿdeclarationþ proclamation, it
     should issue a warning.

     The declare option may be specified more than once.  The effect is
     the same as if the lists of declaration specifiers had been
     appended together into a single list and specified as a single
     declare option.

   * The :documentation argument is a documentation string to be
     attached to the generic function object, and to be attached with
     kind function to the FUNCTION-NAME.

   * The :generic-function-class option may be used to specify that the
     generic function is to have a different class than the default
     provided by the system (the class ÿstandard-generic-functionþ).
     The CLASS-NAME argument is the name of a class that can be the
     class of a generic function.  If FUNCTION-NAME specifies an
     existing generic function that has a different value for the
     :generic-function-class argument and the new generic function
     class is compatible with the old, ÿchange-classþ is called to
     change the class of the generic function; otherwise an error is
     signaled.

   * The :method-class option is used to specify that all methods on
     this generic function are to have a different class from the
     default provided by the system (the class ÿstandard-methodþ).  The
     CLASS-NAME argument is the name of a class that is capable of
     being the class of a method.

   * The :method-combination option is followed by a symbol that names
     a type of method combination.  The arguments (if any) that follow
     that symbol depend on the type of method combination.  Note that
     the standard method combination type does not support any
     arguments.  However, all types of method combination defined by the
     short form of ÿdefine-method-combinationþ accept an optional
     argument named ORDER, defaulting to :most-specific-first, where a
     value of :most-specific-last reverses the order of the primary
     methods without affecting the order of the auxiliary methods.

The METHOD-DESCRIPTION arguments define methods that will be associated
with the generic function.  The METHOD-QUALIFIER and
SPECIALIZED-LAMBDA-LIST arguments in a method description are the same
as for ÿdefmethodþ.

The FORM arguments specify the method body.  The body of the method is
enclosed in an implicit block.  If FUNCTION-NAME is a symbol, this
block bears the same name as the generic function.  If FUNCTION-NAME is
a list of the form ÿ(setf SYMBOL)þ, the name of the block is SYMBOL.

Implementations can extend ÿdefgenericþ to include other options.  It
is required that an implementation signal an error if it observes an
option that is not implemented locally.

ÿdefgenericþ is not required to perform any compile-time side effects.
In particular, the methods are not installed for invocation during
compilation.  An implementation may choose to store information about
the generic function for the purposes of compile-time error-checking
(such as checking the number of arguments on calls, or noting that a
definition for the function name has been seen).

Examples:
.........

Exceptional Situations:
.......................

If FUNCTION-NAME names an ordinary function, a macro, or a special
operator, an error of type ÿprogram-errorþ is signaled.

Each required argument, as specified in the GF-LAMBDA-LIST argument,
must be included exactly once as a PARAMETER-NAME, or an error of type
ÿprogram-errorþ is signaled.

The lambda list of each method specified by a METHOD-DESCRIPTION must
be congruent with the lambda list specified by the GF-LAMBDA-LIST
option, or an error of type ÿerrorþ is signaled.

If a ÿdefgenericþ form is evaluated and some methods for that generic
function have lambda lists that are not congruent with that given in
the ÿdefgenericþ form, an error of type ÿerrorþ is signaled.

A given OPTION may occur only once, or an error of type ÿprogram-errorþ
is signaled.

If FUNCTION-NAME specifies an existing generic function that has a
different value for the :generic-function-class argument and the new
generic function class is compatible with the old, ÿchange-classþ is
called to change the class of the generic function; otherwise an error
of type ÿerrorþ is signaled.

Implementations can extend ÿdefgenericþ to include other options.  It
is required that an implementation signal an error of type
ÿprogram-errorþ if it observes an option that is not implemented
locally.

See Also:
.........

*Note defmethod::, *Note documentation::, *Note
ensure-generic-function::, *Note generic-function::, *Note Section
7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function.


File: chris-ansicl.info,  Node: defmethod,  Next: find-class,  Prev: defgeneric,  Up: Objects

defmethod (Macro)
=================

Syntax:
.......

 -- Macro: defmethod
          function-name {method-qualifier}* specialized-lambda-list
          ù{declaration}* | documentationø {form}* ý new-method

function-name::= {symbol | (setf symbol)}

method-qualifier::= non-list

specialized-lambda-list::=
     ({var | (var parameter-specializer-name)}*
     [&optional {var | (var [initform [supplied-p-parameter]])}*]
     [&rest var]
     [&key { var | (var [initfom [supplied-p-parameter]])}*
     [ÿ&allow-other-keysþ]]
     [&aux {var |
     (var [initform])}*])

parameter-specializer-name::=
     symbol | (eql eql-specializer-form)

Arguments and Values:
.....................

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

VAR--a variable name.

EQL-SPECIALIZER-FORM--a form.

FORM--a form.

INITFORM--a form.

SUPPLIED-P-PARAMETER--variable name.

NEW-METHOD--the new method object.

Description:
............

The macro ÿdefmethodþ defines a method on a generic function.

If ÿ(fboundp function-name)þ is ÿnilþ, a generic function is created
with default values for the argument precedence order (each argument is
more specific than the arguments to its right in the argument list),
for the generic function class (the class ÿstandard-generic-functionþ),
for the method class (the class ÿstandard-methodþ), and for the method
combination type (the standard method combination type).  The lambda
list of the generic function is congruent with the lambda list of the
method being defined; if the ÿdefmethodþ form mentions keyword
arguments, the lambda list of the generic function will mention ÿ&keyþ
(but no keyword arguments).  If function-name names an ordinary
function, a macro, or a special operator, an error is signaled.

If a generic function is currently named by function-name, the lambda
list of the method must be congruent with the lambda list of the
generic function.  If this condition does not hold, an error is
signaled.  For a definition of congruence in this context, see *Note
Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic
Function): Congruent Lambda-lists for all Methods of a Generic Function.

Each method-qualifier argument is an object that is used by method
combination to identify the given method.  The method combination type
might further restrict what a method qualifier can be.  The standard
method combination type allows for unqualified methods and methods
whose sole qualifier is one of the keywords :before, :after, or :around.

The specialized-lambda-list argument is like an ordinary lambda list
except that the names of required parameters can be replaced by
specialized parameters.  A specialized parameter is a list of the form
ÿ(VAR parameter-specializer-name)þ.  Only required parameters can be
specialized.  If parameter-specializer-name is a symbol it names a
class; if it is a list, it is of the form ÿ(eql EQL-SPECIALIZER-FORM)þ.
The parameter specializer name ÿ(eql EQL-SPECIALIZER-FORM)þ indicates
that the corresponding argument must be ÿeqlþ to the object that is the
value of EQL-SPECIALIZER-FORM for the method to be applicable.  The
EQL-SPECIALIZER-FORM is evaluated at the time that the expansion of the
ÿdefmethodþ macro is evaluated.  If no parameter specializer name is
specified for a given required parameter, the parameter specializer
defaults to the class ÿtþ.  For further discussion, see *Note Section
7.6.2 (Introduction to Methods): Introduction to Methods.

The FORM arguments specify the method body.  The body of the method is
enclosed in an implicit block.  If function-name is a symbol, this
block bears the same name as the generic function.  If function-name is
a list of the form ÿ(setf symbol)þ, the name of the block is symbol.

The class of the method object that is created is that given by the
method class option of the generic function on which the method is
defined.

If the generic function already has a method that agrees with the
method being defined on parameter specializers and qualifiers,
ÿdefmethodþ replaces the existing method with the one now being defined.
For a definition of agreement in this context.  see *Note Section 7.6.3
(Agreement on Parameter Specializers and Qualifiers): Agreement on
Parameter Specializers and Qualifiers.

The parameter specializers are derived from the parameter specializer
names as described in *Note Section 7.6.2 (Introduction to Methods):
Introduction to Methods.

The expansion of the ÿdefmethodþ macro "refers to" each specialized
parameter (see the description of ÿignoreþ within the description of
declare).  This includes parameters that have an explicit parameter
specializer name of ÿtþ.  This means that a compiler warning does not
occur if the body of the method does not refer to a specialized
parameter, while a warning might occur if the body of the method does
not refer to an unspecialized parameter.  For this reason, a parameter
that specializes on ÿtþ is not quite synonymous with an unspecialized
parameter in this context.

Declarations at the head of the method body that apply to the method's
lambda variables are treated as bound declarations whose scope is the
same as the corresponding bindings.

Declarations at the head of the method body that apply to the
functional bindings of ÿcall-next-methodþ or ÿnext-method-pþ apply to
references to those functions within the method body FORMS.  Any outer
bindings of the function names ÿcall-next-methodþ and ÿnext-method-pþ,
and declarations associated with such bindings are shadowedà within the
method body FORMS.

The scope of free declarations at the head of the method body is the
entire method body, which includes any implicit local function
definitions but excludes initialization forms for the lambda variables.

ÿdefmethodþ is not required to perform any compile-time side effects.
In particular, the methods are not installed for invocation during
compilation.  An implementation may choose to store information about
the generic function for the purposes of compile-time error-checking
(such as checking the number of arguments on calls, or noting that a
definition for the function name has been seen).

DOCUMENTATION is attached as a documentation string to the method
object.

Affected By:
............

The definition of the referenced generic function.

Exceptional Situations:
.......................

If function-name names an ordinary function, a macro, or a special
operator, an error of type ÿerrorþ is signaled.

If a generic function is currently named by function-name, the lambda
list of the method must be congruent with the lambda list of the
generic function, or an error of type ÿerrorþ is signaled.

See Also:
.........

*Note defgeneric::, *Note documentation::, *Note Section 7.6.2
(Introduction to Methods): Introduction to Methods, *Note Section 7.6.4
(Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function, *Note
Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers):
Agreement on Parameter Specializers and Qualifiers, *Note Section
3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations): Syntactic Interaction of Documentation Strings and
Declarations.


File: chris-ansicl.info,  Node: find-class,  Next: next-method-p,  Prev: defmethod,  Up: Objects

find-class (Accessor)
=====================

Syntax:
.......

 -- Function: find-class symbol &optional errorp environment ý class

(setf (find-class symbol &optional errorp environment) new-class)

Arguments and Values:
.....................

SYMBOL--a symbol.

ERRORP--a generalized boolean.  The default is true.

ENVIRONMENT--same as the ÿ&environmentþ argument to macro expansion
functions and is used to distinguish between compile-time and run-time
environments.  The ÿ&environmentþ argument has dynamic extent; the
consequences are undefined if the ÿ&environmentþ argument is referred
to outside the dynamic extent of the macro expansion function.

CLASS--a class object, or ÿnilþ.

Description:
............

Returns the class object named by the SYMBOL in the ENVIRONMENT.  If
there is no such class, ÿnilþ is returned if ERRORP is false; otherwise,
if ERRORP is true, an error is signaled.

The class associated with a particular symbol can be changed by using
ÿsetfþ with ÿfind-classþ; or, if the new class given to ÿsetfþ is ÿnilþ,
the class association is removed (but the class object itself is not
affected).  The results are undefined if the user attempts to change or
remove the class associated with a symbol that is defined as a type
specifier in this standard.  See *Note Section 4.3.7 (Integrating Types
and Classes): Integrating Types and Classes.

When using ÿsetfþ of ÿfind-classþ, any errorp argument is evaluated for
effect, but any values it returns are ignored; the ERRORP parameter is
permitted primarily so that the ENVIRONMENT parameter can be used.

The ENVIRONMENT might be used to distinguish between a compile-time and
a run-time environment.

Exceptional Situations:
.......................

If there is no such class and ERRORP is true, ÿfind-classþ signals an
error of type ÿerrorþ.

See Also:
.........

*Note defmacro::, *Note Section 4.3.7 (Integrating Types and Classes):
Integrating Types and Classes.


File: chris-ansicl.info,  Node: next-method-p,  Next: call-method; make-method,  Prev: find-class,  Up: Objects

next-method-p (Local Function)
==============================

Syntax:
.......

 -- Function: next-method-p <no arguments> ý generalized-boolean

Arguments and Values:
.....................

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

The locally defined function ÿnext-method-pþ can be used within the
body forms (but not the lambda list) defined by a method-defining form
to determine whether a next method exists.

The function ÿnext-method-pþ has lexical scope and indefinite extent.

Whether or not ÿnext-method-pþ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ÿnext-method-pþ are the same as for symbols in the
ÿCOMMON-LISPþ package which are fbound in the global environment.  The
consequences of attempting to use ÿnext-method-pþ outside of a
method-defining form are undefined.

See Also:
.........

*Note call-next-method::, *Note defmethod::, *Note call-method::


File: chris-ansicl.info,  Node: call-method; make-method,  Next: call-next-method,  Prev: next-method-p,  Up: Objects

call-method, make-method (Local Macro)
======================================

Syntax:
.......

 -- Macro: call-method method &optional next-method-list ý {result}*

 -- Macro: make-method form ý method-object

Arguments and Values:
.....................

METHOD--a method object, or a list (see below); not evaluated.

METHOD-OBJECT--a method object.

NEXT-METHOD-LIST--a list of METHOD objects; not evaluated.

RESULTS--the values returned by the method invocation.

Description:
............

The macro ÿcall-methodþ is used in method combination.  It hides the
implementation-dependent details of how methods are called. The macro
ÿcall-methodþ has lexical scope and can only be used within an
effective method form.

Whether or not ÿcall-methodþ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ÿcall-methodþ are the same as for symbols in the
ÿCOMMON-LISPþ package which are fbound in the global environment.  The
consequences of attempting to use ÿcall-methodþ outside of an effective
method form are undefined.

The macro ÿcall-methodþ invokes the specified method, supplying it with
arguments and with definitions for ÿcall-next-methodþ and for
ÿnext-method-pþ.  If the invocation of ÿcall-methodþ is lexically inside
of a ÿmake-methodþ, the arguments are those that were supplied to that
method.  Otherwise the arguments are those that were supplied to the
generic function.  The definitions of ÿcall-next-methodþ and
ÿnext-method-pþ rely on the specified NEXT-METHOD-LIST.

If METHOD is a list, the first element of the list must be the symbol
ÿmake-methodþ and the second element must be a form.  Such a list
specifies a method object whose method function has a body that is the
given form.

NEXT-METHOD-LIST can contain method objects or lists, the first element
of which must be the symbol ÿmake-methodþ and the second element of
which must be a form.

Those are the only two places where ÿmake-methodþ can be used.  The
form used with ÿmake-methodþ is evaluated in the null lexical
environment augmented with a local macro definition for ÿcall-methodþ
and with bindings named by symbols not accessible from the
ÿCOMMON-LISP-USERþ package.

The ÿcall-next-methodþ function available to METHOD will call the first
method in NEXT-METHOD-LIST.  The ÿcall-next-methodþ function available
in that method, in turn, will call the second method in
NEXT-METHOD-LIST, and so on, until the list of next methods is
exhausted.

If NEXT-METHOD-LIST is not supplied, the ÿcall-next-methodþ function
available to METHOD signals an error of type ÿcontrol-errorþ and the
ÿnext-method-pþ function available to METHOD returns ÿnilþ.

Examples:
.........

See Also:
.........

*Note call-next-method::, *Note define-method-combination::, *Note
next-method-p::


File: chris-ansicl.info,  Node: call-next-method,  Next: compute-applicable-methods,  Prev: call-method; make-method,  Up: Objects

call-next-method (Local Function)
=================================

Syntax:
.......

 -- Function: call-next-method &rest args ý {result}*

Arguments and Values:
.....................

ARG--an object.

RESULTS--the values returned by the method it calls.

Description:
............

The function ÿcall-next-methodþ can be used within the body forms (but
not the lambda list) of a method defined by a method-defining form to
call the next method.

If there is no next method, the generic function ÿno-next-methodþ is
called.

The type of method combination used determines which methods can invoke
ÿcall-next-methodþ.  The standard method combination type allows
ÿcall-next-methodþ to be used within primary methods and around methods.
For generic functions using a type of method combination defined by the
short form of ÿdefine-method-combinationþ, ÿcall-next-methodþ can be
used in around methods only.

When ÿcall-next-methodþ is called with no arguments, it passes the
current method's original arguments to the next method.  Neither
argument defaulting, nor using ÿsetqþ, nor rebinding variables with the
same names as parameters of the method affects the values
ÿcall-next-methodþ passes to the method it calls.

When ÿcall-next-methodþ is called with arguments, the next method is
called with those arguments.

If ÿcall-next-methodþ is called with arguments but omits optional
arguments, the next method called defaults those arguments.

The function ÿcall-next-methodþ returns any values that are returned by
the next method.

The function ÿcall-next-methodþ has lexical scope and indefinite extent
and can only be used within the body of a method defined by a
method-defining form.

Whether or not ÿcall-next-methodþ is fbound in the global environment
is implementation-dependent; however, the restrictions on redefinition
and shadowing of ÿcall-next-methodþ are the same as for symbols in the
ÿCOMMON-LISPþ package which are fbound in the global environment.  The
consequences of attempting to use ÿcall-next-methodþ outside of a
method-defining form are undefined.

Affected By:
............

ÿdefmethodþ, ÿcall-methodþ, ÿdefine-method-combinationþ.

Exceptional Situations:
.......................

When providing arguments to ÿcall-next-methodþ, the following rule must
be satisfied or an error of type ÿerrorþ should be signaled: the
ordered set of applicable methods for a changed set of arguments for
ÿcall-next-methodþ must be the same as the ordered set of applicable
methods for the original arguments to the generic function.
Optimizations of the error checking are possible, but they must not
change the semantics of ÿcall-next-methodþ.

See Also:
.........

*Note define-method-combination::, *Note defmethod::, *Note
next-method-p::, *Note no-next-method::, *Note call-method::, *Note
Section 7.6.6 (Method Selection and Combination): Method Selection and
Combination, *Note Section 7.6.6.2 (Standard Method Combination):
StdMethComb, *Note Section 7.6.6.4 (Built-in Method Combination Types):
BuiltInMethCombTypes.


File: chris-ansicl.info,  Node: compute-applicable-methods,  Next: define-method-combination,  Prev: call-next-method,  Up: Objects

compute-applicable-methods (Standard Generic Function)
======================================================

Syntax:
.......

 -- Generic Function: compute-applicable-methods generic-function
          function-arguments ý methods

Method Signatures:
..................

compute-applicable-methods (GENERIC-FUNCTION
ÿstandard-generic-functionþ)

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function.

FUNCTION-ARGUMENTS--a list of arguments for the GENERIC-FUNCTION.

METHODS--a list of method objects.

Description:
............

Given a GENERIC-FUNCTION and a set of FUNCTION-ARGUMENTS, the function
ÿcompute-applicable-methodsþ returns the set of methods that are
applicable for those arguments sorted according to precedence order.
See *Note Section 7.6.6 (Method Selection and Combination): Method
Selection and Combination.

Affected By:
............

ÿdefmethodþ

See Also:
.........

*Note Section 7.6.6 (Method Selection and Combination): Method
Selection and Combination.


File: chris-ansicl.info,  Node: define-method-combination,  Next: find-method,  Prev: compute-applicable-methods,  Up: Objects

define-method-combination (Macro)
=================================

Syntax:
.......

 -- Macro: define-method-combination name ùûshort-form-optionø ý name

 -- Macro: define-method-combination name lambda-list
          ({method-group-specifier}*) [(:arguments . args-lambda-list)]
          [(:generic-function  generic-function-symbol)]
          ù{declaration}* | documentationø {form}* ý name

SHORT-FORM-OPTION::=
     :documentation DOCUMENTATION |
     :identity-with-one-argument IDENTITY-WITH-ONE-ARGUMENT |
     :operator OPERATOR

METHOD-GROUP-SPECIFIER::=
     (name {{QUALIFIER-PATTERN}+ | predicate} ùûlong-form-optionø)

LONG-FORM-OPTION::=
     :description DESCRIPTION |
     :order ORDER |
     :required REQUIRED-P

Arguments and Values:
.....................

ARGS-LAMBDA-LIST-- a define-method-combination arguments lambda list.

DECLARATION--a declare expression; not evaluated.

DESCRIPTION--a format control.

DOCUMENTATION--a string; not evaluated.

FORMS--an implicit progn that must compute and return the form that
specifies how the methods are combined, that is, the effective method.

GENERIC-FUNCTION-SYMBOL--a symbol.

IDENTITY-WITH-ONE-ARGUMENT--a generalized boolean.

LAMBDA-LIST--ordinary lambda list.

NAME--a symbol.  Non-keyword, non-nil symbols are usually used.

OPERATOR--an operator.  NAME and OPERATOR are often the same symbol.
This is the default, but it is not required.

ORDER--:most-specific-first or :most-specific-last; evaluated.

PREDICATE--a symbol that names a function of one argument that returns
a generalized boolean.

QUALIFIER-PATTERN--a list, or the symbol *.

REQUIRED-P--a generalized boolean.

Description:
............

The macro ÿdefine-method-combinationþ is used to define new types of
method combination.

There are two forms of ÿdefine-method-combinationþ.  The short form is
a simple facility for the cases that are expected to be most commonly
needed.  The long form is more powerful but more verbose.  It resembles
ÿdefmacroþ in that the body is an expression, usually using backquote,
that computes a form.  Thus arbitrary control structures can be
implemented.  The long form also allows arbitrary processing of method
qualifiers.

Short Form
     The short form syntax of ÿdefine-method-combinationþ is recognized
     when the second subform is a non-nil symbol or is not present.
     When the short form is used, NAME is defined as a type of method
     combination that produces a Lisp form ÿ(OPERATOR METHOD-CALL
     METHOD-CALL ...)þ.  The OPERATOR is a symbol that can be the name
     of a function, macro, or special operator.  The OPERATOR can be
     supplied by a keyword option; it defaults to NAME.

     Keyword options for the short form are the following:

        * The :documentation option is used to document the
          method-combination type; see description of long form below.

        * The :identity-with-one-argument option enables an optimization
          when its value is true (the default is false).  If there is
          exactly one applicable method and it is a primary method,
          that method serves as the effective method and OPERATOR is
          not called.  This optimization avoids the need to create a
          new effective method and avoids the overhead of a function
          call.  This option is designed to be used with operators such
          as ÿprognþ, ÿandþ, ÿ+þ, and ÿmaxþ.

        * The :operator option specifies the name of the operator.  The
          OPERATOR argument is a symbol that can be the name of a
          function, macro, or special form.

     These types of method combination require exactly one qualifier per
     method.  An error is signaled if there are applicable methods with
     no qualifiers or with qualifiers that are not supported by the
     method combination type.

     A method combination procedure defined in this way recognizes two
     roles for methods.  A method whose one qualifier is the symbol
     naming this type of method combination is defined to be a primary
     method.  At least one primary method must be applicable or an
     error is signaled.  A method with :around as its one qualifier is
     an auxiliary method that behaves the same as an around method in
     standard method combination.  The function ÿcall-next-methodþ can
     only be used in around methods; it cannot be used in primary
     methods defined by the short form of the
     ÿdefine-method-combinationþ macro.

     A method combination procedure defined in this way accepts an
     optional argument named ORDER, which defaults to
     :most-specific-first.  A value of :most-specific-last reverses the
     order of the primary methods without affecting the order of the
     auxiliary methods.

     The short form automatically includes error checking and support
     for around methods.

     For a discussion of built-in method combination types, see *Note
     Section 7.6.6.4 (Built-in Method Combination Types):
     BuiltInMethCombTypes.

Long Form
     The long form syntax of ÿdefine-method-combinationþ is recognized
     when the second subform is a list.

     The LAMBDA-LIST receives any arguments provided after the name of
     the method combination type in the :method-combination option to
     ÿdefgenericþ.

     A list of method group specifiers follows.  Each specifier selects
     a subset of the applicable methods to play a particular role,
     either by matching their qualifiers against some patterns or by
     testing their qualifiers with a PREDICATE.  These method group
     specifiers define all method qualifiers that can be used with this
     type of method combination.

     The car of each METHOD-GROUP-SPECIFIER is a symbol which names a
     variable.  During the execution of the forms in the body of
     ÿdefine-method-combinationþ, this variable is bound to a list of
     the methods in the method group.  The methods in this list occur
     in the order specified by the :order option.

     If QUALIFIER-PATTERN is a symbol it must be *.  A method matches a
     QUALIFIER-PATTERN if the method's list of qualifiers is ÿequalþ to
     the QUALIFIER-PATTERN (except that the symbol * in a
     QUALIFIER-PATTERN matches anything).  Thus a QUALIFIER-PATTERN can
     be one of the following: the empty list, which matches unqualified
     methods; the symbol *, which matches all methods; a true list,
     which matches methods with the same number of qualifiers as the
     length of the list when each qualifier matches the corresponding
     list element; or a dotted list that ends in the symbol * (the *
     matches any number of additional qualifiers).

     Each applicable method is tested against the QUALIFIER-PATTERNS and
     PREDICATES in left-to-right order.  As soon as a QUALIFIER-PATTERN
     matches or a PREDICATE returns true, the method becomes a member
     of the corresponding method group and no further tests are made.
     Thus if a method could be a member of more than one method group,
     it joins only the first such group.  If a method group has more
     than one QUALIFIER-PATTERN, a method need only satisfy one of the
     QUALIFIER-PATTERNS to be a member of the group.

     The name of a PREDICATE function can appear instead of
     QUALIFIER-PATTERNS in a method group specifier.  The PREDICATE is
     called for each method that has not been assigned to an earlier
     method group; it is called with one argument, the method's
     qualifier list.  The PREDICATE should return true if the method is
     to be a member of the method group.  A PREDICATE can be
     distinguished from a QUALIFIER-PATTERN because it is a symbol
     other than ÿnilþ or *.

     If there is an applicable method that does not fall into any
     method group, the function ÿinvalid-method-errorþ is called.

     Method group specifiers can have keyword options following the
     qualifier patterns or predicate.  Keyword options can be
     distinguished from additional qualifier patterns because they are
     neither lists nor the symbol *.  The keyword options are as
     follows:

        * The :description option is used to provide a description of
          the role of methods in the method group.  Programming
          environment tools use ÿ(apply #'format stream FORMAT-CONTROL
          (method-qualifiers METHOD))þ to print this description, which
          is expected to be concise.  This keyword option allows the
          description of a method qualifier to be defined in the same
          module that defines the meaning of the method qualifier.  In
          most cases, FORMAT-CONTROL will not contain any ÿformatþ
          directives, but they are available for generality.  If
          :description is not supplied, a default description is
          generated based on the variable name and the qualifier
          patterns and on whether this method group includes the
          unqualified methods.

        * The :order option specifies the order of methods.  The ORDER
          argument is a form that evaluates to :most-specific-first or
          :most-specific-last.  If it evaluates to any other value, an
          error is signaled.  If :order is not supplied, it defaults to
          :most-specific-first.

        * The :required option specifies whether at least one method in
          this method group is required.  If its value is true and the
          method group is empty (that is, no applicable methods match
          the qualifier patterns or satisfy the predicate), an error is
          signaled.  If :required is not supplied, it defaults to ÿnilþ.

     The use of method group specifiers provides a convenient syntax to
     select methods, to divide them among the possible roles, and to
     perform the necessary error checking.  It is possible to perform
     further filtering of methods in the body forms by using normal
     list-processing operations and the functions ÿmethod-qualifiersþ
     and ÿinvalid-method-errorþ.  It is permissible to use ÿsetqþ on the
     variables named in the method group specifiers and to bind
     additional variables.  It is also possible to bypass the method
     group specifier mechanism and do everything in the body forms.
     This is accomplished by writing a single method group with * as
     its only QUALIFIER-PATTERN; the variable is then bound to a list
     of all of the applicable methods, in most-specific-first order.

     The body FORMS compute and return the form that specifies how the
     methods are combined, that is, the effective method.  The
     effective method is evaluated in the null lexical environment
     augmented with a local macro definition for ÿcall-methodþ and with
     bindings named by symbols not accessible from the
     ÿCOMMON-LISP-USERþ package.  Given a method object in one of the
     lists produced by the method group specifiers and a list of next
     methods, ÿcall-methodþ will invoke the method such that
     ÿcall-next-methodþ has available the next methods.

     When an effective method has no effect other than to call a single
     method, some implementations employ an optimization that uses the
     single method directly as the effective method, thus avoiding the
     need to create a new effective method.  This optimization is
     active when the effective method form consists entirely of an
     invocation of the ÿcall-methodþ macro whose first subform is a
     method object and whose second subform is ÿnilþ or unsupplied.
     Each ÿdefine-method-combinationþ body is responsible for stripping
     off redundant invocations of ÿprognþ, ÿandþ,
     ÿmultiple-value-prog1þ, and the like, if this optimization is
     desired.

     The list ÿ(:arguments . LAMBDA-LIST)þ can appear before any
     declarations or documentation string.  This form is useful when
     the method combination type performs some specific behavior as
     part of the combined method and that behavior needs access to the
     arguments to the generic function.  Each parameter variable
     defined by LAMBDA-LIST is bound to a form that can be inserted
     into the effective method.  When this form is evaluated during
     execution of the effective method, its value is the corresponding
     argument to the generic function; the consequences of using such a
     form as the PLACE in a ÿsetfþ form are undefined.  Argument
     correspondence is computed by dividing the :arguments LAMBDA-LIST
     and the generic function LAMBDA-LIST into three sections: the
     required parameters, the optional parameters, and the keyword and
     rest parameters.  The arguments supplied to the generic function
     for a particular call are also divided into three sections; the
     required arguments section contains as many arguments as the
     generic function has required parameters, the optional arguments
     section contains as many arguments as the generic function has
     optional parameters, and the keyword/rest arguments section
     contains the remaining arguments.  Each parameter in the required
     and optional sections of the :arguments LAMBDA-LIST accesses the
     argument at the same position in the corresponding section of the
     arguments.  If the section of the :arguments LAMBDA-LIST is
     shorter, extra arguments are ignored.  If the section of the
     :arguments LAMBDA-LIST is longer, excess required parameters are
     bound to forms that evaluate to ÿnilþ  and excess optional
     parameters are bound to their initforms.  The keyword parameters
     and rest parameters in the :arguments LAMBDA-LIST access the
     keyword/rest section of the arguments.  If the :arguments
     LAMBDA-LIST contains ÿ&keyþ, it behaves as if it also contained
     ÿ&allow-other-keysþ.

     In addition, ÿ&wholeþ VAR can be placed first in the :arguments
     LAMBDA-LIST.  It causes VAR to be bound to a form that evaluates
     to a list of all of the arguments supplied to the generic
     function.  This is different from ÿ&restþ because it accesses all
     of the arguments, not just the keyword/rest arguments.

     Erroneous conditions detected by the body should be reported with
     ÿmethod-combination-errorþ or ÿinvalid-method-errorþ; these
     functions add any necessary contextual information to the error
     message and will signal the appropriate error.

     The body FORMS are evaluated inside of the bindings created by the
     lambda list and method group specifiers.

     Declarations at the head of the body are positioned directly
     inside of bindings created by the lambda list and outside of the
     bindings of the method group variables.  Thus method group
     variables cannot be declared in this way.  ÿlocallyþ may be used
     around the body, however.

     Within the body FORMS, GENERIC-FUNCTION-SYMBOL is bound to the
     generic function object.

     DOCUMENTATION is attached as a documentation string to NAME (as
     kind ÿmethod-combinationþ) and to the method combination object.

     Note that two methods with identical specializers, but with
     different qualifiers, are not ordered by the algorithm described
     in Step 2 of the method selection and combination process
     described in *Note Section 7.6.6 (Method Selection and
     Combination): Method Selection and Combination.  Normally the two
     methods play different roles in the effective method because they
     have different qualifiers, and no matter how they are ordered in
     the result of Step 2, the effective method is the same.  If the
     two methods play the same role and their order matters,

     an error is signaled.  This happens as part of the qualifier
     pattern matching in ÿdefine-method-combinationþ.

If a ÿdefine-method-combinationþ form appears as a top level form, the
compiler must make the method combination name be recognized as a valid
method combination name in subsequent ÿdefgenericþ forms.  However, the
method combination is executed no earlier than when the
ÿdefine-method-combinationþ form is executed, and possibly as late as
the time that generic functions that use the method combination are
executed.

Examples:
.........

Most examples of the long form of ÿdefine-method-combinationþ also
illustrate the use of the related functions that are provided as part
of the declarative method combination facility.

;;; Examples of the short form of define-method-combination

 (define-method-combination and :identity-with-one-argument t)

 (defmethod func and ((x class1) y) ...)

;;; The equivalent of this example in the long form is:

 (define-method-combination and
         (&optional (order :most-specific-first))
         ((around (:around))
          (primary (and) :order order :required t))
   (let ((form (if (rest primary)
                   `(and ,@(mapcar #'(lambda (method)
                                       `(call-method ,method))
                                   primary))
                   `(call-method ,(first primary)))))
     (if around
         `(call-method ,(first around)
                       (,@(rest around)
                        (make-method ,form)))
         form)))

;;; Examples of the long form of define-method-combination

;The default method-combination technique
 (define-method-combination standard ()
         ((around (:around))
          (before (:before))
          (primary () :required t)
          (after (:after)))
   (flet ((call-methods (methods)
            (mapcar #'(lambda (method)
                        `(call-method ,method))
                    methods)))
     (let ((form (if (or before after (rest primary))
                     `(multiple-value-prog1
                        (progn ,@(call-methods before)
                               (call-method ,(first primary)
                                            ,(rest primary)))
                        ,@(call-methods (reverse after)))
                     `(call-method ,(first primary)))))
       (if around
           `(call-method ,(first around)
                         (,@(rest around)
                          (make-method ,form)))
           form))))

;A simple way to try several methods until one returns non-nil
 (define-method-combination or ()
         ((methods (or)))
   `(or ,@(mapcar #'(lambda (method)
                      `(call-method ,method))
                  methods)))

;A more complete version of the preceding
 (define-method-combination or
         (&optional (order ':most-specific-first))
         ((around (:around))
          (primary (or)))
   ;; Process the order argument
   (case order
     (:most-specific-first)
     (:most-specific-last (setq primary (reverse primary)))
     (otherwise (method-combination-error "~S is an invalid order.~@
     :most-specific-first and :most-specific-last are the possible values."
                                          order)))
   ;; Must have a primary method
   (unless primary
     (method-combination-error "A primary method is required."))
   ;; Construct the form that calls the primary methods
   (let ((form (if (rest primary)
                   `(or ,@(mapcar #'(lambda (method)
                                      `(call-method ,method))
                                  primary))
                   `(call-method ,(first primary)))))
     ;; Wrap the around methods around that form
     (if around
         `(call-method ,(first around)
                       (,@(rest around)
                        (make-method ,form)))
         form)))

;The same thing, using the :order and :required keyword options
 (define-method-combination or
         (&optional (order ':most-specific-first))
         ((around (:around))
          (primary (or) :order order :required t))
   (let ((form (if (rest primary)
                   `(or ,@(mapcar #'(lambda (method)
                                      `(call-method ,method))
                                  primary))
                   `(call-method ,(first primary)))))
     (if around
         `(call-method ,(first around)
                       (,@(rest around)
                        (make-method ,form)))
         form)))

;This short-form call is behaviorally identical to the preceding
 (define-method-combination or :identity-with-one-argument t)

;Order methods by positive integer qualifiers
;:around methods are disallowed to keep the example small
 (define-method-combination example-method-combination ()
         ((methods positive-integer-qualifier-p))
   `(progn ,@(mapcar #'(lambda (method)
                         `(call-method ,method))
                     (stable-sort methods #'<
                       :key #'(lambda (method)
                                (first (method-qualifiers method)))))))

 (defun positive-integer-qualifier-p (method-qualifiers)
   (and (= (length method-qualifiers) 1)
        (typep (first method-qualifiers) '(integer 0 *))))

;;; Example of the use of :arguments
 (define-method-combination progn-with-lock ()
         ((methods ()))
   (:arguments object)
   `(unwind-protect
        (progn (lock (object-lock ,object))
               ,@(mapcar #'(lambda (method)
                             `(call-method ,method))
                         methods))
      (unlock (object-lock ,object))))

Side Effects:
.............

The compiler is not required to perform any compile-time side-effects.

Exceptional Situations:
.......................

Method combination types defined with the short form require exactly
one qualifier per method.  An error of type ÿerrorþ is signaled if
there are applicable methods with no qualifiers or with qualifiers that
are not supported by the method combination type.  At least one primary
method must be applicable or an error of type ÿerrorþ is signaled.

If an applicable method does not fall into any method group, the system
signals an error of type ÿerrorþ indicating that the method is invalid
for the kind of method combination in use.

If the value of the :required option is true and the method group is
empty (that is, no applicable methods match the qualifier patterns or
satisfy the predicate), an error of type ÿerrorþ is signaled.

If the :order option evaluates to a value other than
:most-specific-first or :most-specific-last, an error of type ÿerrorþ
is signaled.

See Also:
.........

*Note call-method::, *Note call-next-method::, *Note documentation::,
*Note method-qualifiers::, *Note method-combination-error::, *Note
invalid-method-error::, *Note defgeneric::, *Note Section 7.6.6 (Method
Selection and Combination): Method Selection and Combination, *Note
Section 7.6.6.4 (Built-in Method Combination Types):
BuiltInMethCombTypes, *Note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

The :method-combination option of ÿdefgenericþ is used to specify that
a generic function should use a particular method combination type.
The first argument to the :method-combination option is the name of a
method combination type and the remaining arguments are options for
that type.


File: chris-ansicl.info,  Node: find-method,  Next: add-method,  Prev: define-method-combination,  Up: Objects

find-method (Standard Generic Function)
=======================================

Syntax:
.......

 -- Generic Function: find-method generic-function method-qualifiers
          specializers &optional errorp ý method

Method Signatures:
..................

find-method (GENERIC-FUNCTION ÿstandard-generic-functionþ)
method-qualifiers specializers &optional errorp

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function.

METHOD-QUALIFIERS--a list.

SPECIALIZERS--a list.

ERRORP--a generalized boolean.  The default is true.

METHOD--a method object, or ÿnilþ.

Description:
............

The generic function ÿfind-methodþ takes a generic function and returns
the method object that agrees on qualifiers and parameter specializers
with the METHOD-QUALIFIERS and SPECIALIZERS arguments of ÿfind-methodþ.
METHOD-QUALIFIERS  contains the method qualifiers for the method.  The
order of the method qualifiers is significant.  For a definition of
agreement in this context, see *Note Section 7.6.3 (Agreement on
Parameter Specializers and Qualifiers): Agreement on Parameter
Specializers and Qualifiers.

The SPECIALIZERS argument contains the parameter specializers for the
method. It must correspond in length to the number of required
arguments of the generic function, or an error is signaled.  This means
that to obtain the default method on a given GENERIC-FUNCTION, a list
whose elements are the class ÿtþ must be given.

If there is no such method and ERRORP is true, ÿfind-methodþ signals an
error.  If there is no such method and ERRORP is false, ÿfind-methodþ
returns ÿnilþ.

Examples:
.........

 (defmethod some-operation ((a integer) (b float)) (list a b))
ý #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
 (find-method #'some-operation '() (mapcar #'find-class '(integer float)))
ý #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
 (find-method #'some-operation '() (mapcar #'find-class '(integer integer)))
Ö Error: No matching method
 (find-method #'some-operation '() (mapcar #'find-class '(integer integer)) nil)
ý NIL

Affected By:
............

ÿadd-methodþ, ÿdefclassþ, ÿdefgenericþ, ÿdefmethodþ

Exceptional Situations:
.......................

If the SPECIALIZERS argument does not correspond in length to the
number of required arguments of the GENERIC-FUNCTION, an an error of
type ÿerrorþ is signaled.

If there is no such method and ERRORP is true, ÿfind-methodþ signals an
error of type ÿerrorþ.

See Also:
.........

*Note Section 7.6.3 (Agreement on Parameter Specializers and
Qualifiers): Agreement on Parameter Specializers and Qualifiers.


File: chris-ansicl.info,  Node: add-method,  Next: initialize-instance (Standard Generic Function),  Prev: find-method,  Up: Objects

add-method (Standard Generic Function)
======================================

Syntax:
.......

 -- Generic Function: add-method generic-function method ý
          generic-function

Method Signatures:
..................

add-method (GENERIC-FUNCTION ÿstandard-generic-functionþ)
(METHOD ÿmethodþ)

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function object.

METHOD--a method object.

Description:
............

The generic function ÿadd-methodþ adds a method to a generic function.

If METHOD agrees with an existing method of GENERIC-FUNCTION on
parameter specializers and qualifiers, the existing method is replaced.

Exceptional Situations:
.......................

The lambda list of the method function of METHOD must be congruent with
the lambda list of GENERIC-FUNCTION, or an error of type ÿerrorþ is
signaled.

If METHOD is a method object of another generic function, an error of
type ÿerrorþ is signaled.

See Also:
.........

*Note defmethod::, *Note defgeneric::, *Note find-method::, *Note
remove-method::, *Note Section 7.6.3 (Agreement on Parameter
Specializers and Qualifiers): Agreement on Parameter Specializers and
Qualifiers.


File: chris-ansicl.info,  Node: initialize-instance (Standard Generic Function),  Next: class-name,  Prev: add-method,  Up: Objects

initialize-instance (Standard Generic Function)
===============================================

Syntax:
.......

 -- Generic Function: initialize-instance instance &rest initargs &key
          &allow-other-keys ý instance

Method Signatures:
..................

initialize-instance (INSTANCE ÿstandard-objectþ) &rest initargs

Arguments and Values:
.....................

INSTANCE--an object.

INITARGS--a defaulted initialization argument list.

Description:
............

Called by ÿmake-instanceþ to initialize a newly created instance.  The
generic function is called with the new INSTANCE and the defaulted
initialization argument list.

The system-supplied primary method on ÿinitialize-instanceþ initializes
the slots of the INSTANCE with values according to the INITARGS and the
:initform forms of the slots.  It does this by calling the generic
function ÿshared-initializeþ with the following arguments: the
INSTANCE, ÿtþ (this indicates that all slots for which no
initialization arguments are provided should be initialized according
to their :initform forms), and the INITARGS.

Programmers can define methods for ÿinitialize-instanceþ to specify
actions to be taken when an instance is initialized.  If only after
methods are defined, they will be run after the system-supplied primary
method for initialization and therefore will not interfere with the
default behavior of ÿinitialize-instanceþ.

See Also:
.........

*Note shared-initialize (Standard Generic Function)::, *Note
make-instance::, *Note slot-boundp::, *Note slot-makunbound::, *Note
Section 7.1 (Object Creation and Initialization): Object Creation and
Initialization, *Note Section 7.1.4 (Rules for Initialization
Arguments): Rules for Initialization Arguments, *Note Section 7.1.2
(Declaring the Validity of Initialization Arguments): Declaring the
Validity of Initialization Arguments.


File: chris-ansicl.info,  Node: class-name,  Next: setf class-name,  Prev: initialize-instance (Standard Generic Function),  Up: Objects

class-name (Standard Generic Function)
======================================

Syntax:
.......

 -- Generic Function: class-name class ý name

Method Signatures:
..................

class-name (CLASS ÿclassþ)

Arguments and Values:
.....................

CLASS--a class object.

NAME--a symbol.

Description:
............

Returns the name of the given CLASS.

See Also:
.........

*Note find-class::, *Note Section 4.3 (Classes): Classes.

Notes:
......

If S is a symbol such that S =ÿ(class-name C)þ and C =ÿ(find-class S)þ,
then S is the proper name of C.  For further discussion, see *Note
Section 4.3 (Classes): Classes.

The name of an anonymous class is ÿnilþ.


File: chris-ansicl.info,  Node: setf class-name,  Next: class-of,  Prev: class-name,  Up: Objects

(setf class-name) (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: (setf class-name) new-value class ý new-value

Method Signatures:
..................

(setf class-name) new-value (CLASS ÿclassþ)

Arguments and Values:
.....................

NEW-VALUE--a symbol.

CLASS--a class.

Description:
............

The generic function ÿ(setf class-name)þ sets the name of a CLASS
object.

See Also:
.........

*Note find-class::, proper name, *Note Section 4.3 (Classes): Classes.


File: chris-ansicl.info,  Node: class-of,  Next: unbound-slot,  Prev: setf class-name,  Up: Objects

class-of (Function)
===================

Syntax:
.......

 -- Function: class-of object ý class

Arguments and Values:
.....................

OBJECT--an object.

CLASS--a class object.

Description:
............

Returns the class of which the OBJECT is a direct instance.

Examples:
.........

 (class-of 'fred) ý #<BUILT-IN-CLASS SYMBOL 610327300>
 (class-of 2/3) ý #<BUILT-IN-CLASS RATIO 610326642>

 (defclass book () ()) ý #<STANDARD-CLASS BOOK 33424745>
 (class-of (make-instance 'book)) ý #<STANDARD-CLASS BOOK 33424745>

 (defclass novel (book) ()) ý #<STANDARD-CLASS NOVEL 33424764>
 (class-of (make-instance 'novel)) ý #<STANDARD-CLASS NOVEL 33424764>

 (defstruct kons kar kdr) ý KONS
 (class-of (make-kons :kar 3 :kdr 4)) ý #<STRUCTURE-CLASS KONS 250020317>

See Also:
.........

*Note make-instance::, *Note type-of::


File: chris-ansicl.info,  Node: unbound-slot,  Next: unbound-slot-instance,  Prev: class-of,  Up: Objects

unbound-slot (Condition Type)
=============================

Class Precedence List:
......................

ÿunbound-slotþ, ÿcell-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ,
ÿtþ

Description:
............

The object having the unbound slot is initialized by the :instance
initialization argument to ÿmake-conditionþ, and is accessed by the
function ÿunbound-slot-instanceþ.

The name of the cell (see ÿcell-errorþ) is the name of the slot.

See Also:
.........

*Note cell-error-name::, *Note unbound-slot-instance::, *Note Section
9.1 (Condition System Concepts): Condition System Concepts.


File: chris-ansicl.info,  Node: unbound-slot-instance,  Prev: unbound-slot,  Up: Objects

unbound-slot-instance (Function)
================================

Syntax:
.......

 -- Function: unbound-slot-instance condition ý instance

Arguments and Values:
.....................

CONDITION--a condition of type ÿunbound-slotþ.

INSTANCE--an object.

Description:
............

Returns the instance which had the unbound slot in the situation
represented by the CONDITION.

See Also:
.........

*Note cell-error-name::, *Note unbound-slot::, *Note Section 9.1
(Condition System Concepts): Condition System Concepts.


File: chris-ansicl.info,  Node: Structures,  Next: Conditions,  Prev: Objects,  Up: Top

8 Structures
************

* Menu:


Dictionary

* defstruct::
* copy-structure::


File: chris-ansicl.info,  Node: defstruct,  Next: copy-structure,  Up: Structures

defstruct (Macro)
=================

Syntax:
.......

 -- Macro: defstruct name-and-options [documentation]
          {ûslot-description}* ý structure-name

NAME-AND-OPTIONS::=
     structure-name | (structure-name ùûoptionsø)

OPTIONS::=
     ûconc-name-option |
     {ûconstructor-option}* |
     ûcopier-option |
     ûinclude-option |
     ûinitial-offset-option |
     ûnamed-option |
     ûpredicate-option |
     ûprinter-option |
     ûtype-option

CONC-NAME-OPTION::=
     :conc-name | (:conc-name) | (:conc-name CONC-NAME)

CONSTRUCTOR-OPTION::=
     :constructor |
     (:constructor) |
     (:constructor CONSTRUCTOR-NAME) |
     (:constructor CONSTRUCTOR-NAME CONSTRUCTOR-ARGLIST)

COPIER-OPTION::=
     :copier | (:copier) | (:copier COPIER-NAME)

PREDICATE-OPTION::=
     :predicate | (:predicate) | (:predicate PREDICATE-NAME)

INCLUDE-OPTION::=
     (:include INCLUDED-STRUCTURE-NAME {ûslot-description}*)

PRINTER-OPTION::=
     ûprint-object-option | ûprint-function-option

PRINT-OBJECT-OPTION::=
     (:print-object PRINTER-NAME) | (:print-object)

PRINT-FUNCTION-OPTION::=
     (:print-function PRINTER-NAME) | (:print-function)

TYPE-OPTION::=
     (:type TYPE)

NAMED-OPTION::=
     :named

INITIAL-OFFSET-OPTION::=
     (:initial-offset INITIAL-OFFSET)

SLOT-DESCRIPTION::=
     SLOT-NAME |
     (SLOT-NAME [SLOT-INITFORM ùûslot-optionø])

SLOT-OPTION::=
     :type SLOT-TYPE |
     :read-only SLOT-READ-ONLY-P

Arguments and Values:
.....................

CONC-NAME--a string designator.

CONSTRUCTOR-ARGLIST--a boa lambda list.

CONSTRUCTOR-NAME--a symbol.

COPIER-NAME--a symbol.

INCLUDED-STRUCTURE-NAME--an already-defined structure name.  Note that
a derived type is not permissible, even if it would expand into a
structure name.

INITIAL-OFFSET--a non-negative integer.

PREDICATE-NAME--a symbol.

PRINTER-NAME--a function name or a lambda expression.

SLOT-NAME--a symbol.

SLOT-INITFORM--a form.

SLOT-READ-ONLY-P--a generalized boolean.

STRUCTURE-NAME--a symbol.

TYPE--one of the type specifiers ÿlistþ, ÿvectorþ, or ÿ(vector SIZE)þ,
or some other type specifier defined by the implementation to be
appropriate.

DOCUMENTATION--a string; not evaluated.

Description:
............

ÿdefstructþ defines a structured type, named STRUCTURE-TYPE, with named
slots as specified by the SLOT-OPTIONS.

ÿdefstructþ defines readers for the slots and arranges for ÿsetfþ to
work properly on such reader functions.  Also, unless overridden, it
defines a predicate named ÿNAME-pþ, defines a constructor function
named ÿmake-CONSTRUCTOR-NAMEþ, and defines a copier function named
ÿcopy-CONSTRUCTOR-NAMEþ.  All names of automatically created functions
might automatically be declared ÿinlineþ (at the discretion of the
implementation).

If DOCUMENTATION is supplied, it is attached to STRUCTURE-NAME as a
documentation string of kind structure, and unless :type is used, the
DOCUMENTATION is also attached to STRUCTURE-NAME as a documentation
string of kind type and as a documentation string to the class object
for the class named STRUCTURE-NAME.

ÿdefstructþ defines a constructor function that is used to create
instances of the structure created by ÿdefstructþ.  The default name is
ÿmake-STRUCTURE-NAMEþ.  A different name can be supplied by giving the
name as the argument to the CONSTRUCTOR option.  ÿnilþ indicates that
no constructor function will be created.

After a new structure type has been defined, instances of that type
normally can be created by using the constructor function for the type.
A call to a constructor function is of the following form:

 (constructor-function-name
  slot-keyword1 form-1
  slot-keyword2 form-2
  ...)

The arguments to the constructor function are all keyword arguments.
Each slot keyword argument must  be a keyword whose name corresponds to
the name of a structure slot.  All the KEYWORDS and FORMS are evaluated.
If a slot is not initialized in this way, it is initialized by
evaluating SLOT-INITFORM in the slot description at the time the
constructor function is called.  If no SLOT-INITFORM is supplied, the
consequences are undefined if an attempt is later made to read the
slot's value before a value is explicitly assigned.

Each SLOT-INITFORM supplied for a ÿdefstructþ component, when used by
the constructor function for an otherwise unsupplied component, is
re-evaluated on every call to the constructor function.  The
SLOT-INITFORM is not evaluated unless it is needed in the creation of a
particular structure instance.  If it is never needed, there can be no
type-mismatch error, even if the type of the slot is specified; no
warning should be issued in this case.  For example, in the following
sequence, only the last call is an error.

 (defstruct person (name 007 :type string))
 (make-person :name "James")
 (make-person)

It is as if the SLOT-INITFORMS were used as initialization forms for
the keyword parameters of the constructor function.

The symbols which name the slots must not be used by the implementation
as the names for the lambda variables in the constructor function,
since one or more of those symbols might have been proclaimed ÿspecialþ
or might be defined as the name of a constant variable.  The slot
default init forms are evaluated in the lexical environment in which
the ÿdefstructþ form itself appears and in the dynamic environment in
which the call to the constructor function appears.

For example, if the form ÿ(gensym)þ were used as an initialization form,
either in the constructor-function call or as the default
initialization form in ÿdefstructþ, then every call to the constructor
function would call ÿgensymþ once to generate a new symbol.

Each SLOT-DESCRIPTION in ÿdefstructþ can specify zero or more
SLOT-OPTIONS.  A SLOT-OPTION consists of a pair of a keyword and a value
(which is not a form to be evaluated, but the value itself).  For
example:

 (defstruct ship
   (x-position 0.0 :type short-float)
   (y-position 0.0 :type short-float)
   (x-velocity 0.0 :type short-float)
   (y-velocity 0.0 :type short-float)
   (mass *default-ship-mass* :type short-float :read-only t))

This specifies that each slot always contains a short float, and that
the last slot cannot be altered once a ship is constructed.

The available slot-options are:

ÿ:type TYPEþ
     This specifies that the contents of the slot is always of type
     TYPE.  This is entirely analogous to the declaration of a variable
     or function; it effectively declares the result type of the reader
     function.  It is implementation-dependent whether the type is
     checked when initializing a slot or when assigning to it.  TYPE is
     not evaluated; it must be a valid type specifier.

ÿ:read-only Xþ
     When X is true, this specifies that this slot cannot be altered;
     it will always contain the value supplied at construction time.
     ÿsetfþ will not accept the reader function for this slot.  If X is
     false, this slot-option has no effect.  X is not evaluated.

     When this option is false or unsupplied, it is
     implementation-dependent whether the ability to write the slot is
     implemented by a setf function or a setf expander.

The following keyword options are available for use with ÿdefstructþ.
A ÿdefstructþ option can be either a keyword or a list of a keyword and
arguments for that keyword; specifying the keyword by itself is
equivalent to specifying a list consisting of the keyword and no
arguments.  The syntax for ÿdefstructþ options differs from the pair
syntax used for slot-options.  No part of any of these options is
evaluated.

:conc-name
     This provides for automatic prefixing of names of reader (or
     access) functions.  The default behavior is to begin the names of
     all the reader functions of a structure with the name of the
     structure followed by a hyphen.

     :conc-name supplies an alternate prefix to be used.  If a hyphen
     is to be used as a separator, it must be supplied as part of the
     prefix.  If :conc-name is ÿnilþ or no argument is supplied, then
     no prefix is used; then the names of the reader functions are the
     same as the slot names.  If a non-nil prefix is given, the name of
     the reader function for each slot is constructed by concatenating
     that prefix and the name of the slot, and interning the resulting
     symbol in the package that is current at the time the ÿdefstructþ
     form is expanded.

     Note that no matter what is supplied for :conc-name, slot keywords
     that match the slot names with no prefix attached are used with a
     constructor function.  The reader function name is used in
     conjunction with ÿsetfþ.  Here is an example:

      (defstruct (door (:conc-name dr-)) knob-color width material) ý DOOR
      (setq my-door (make-door :knob-color 'red :width 5.0))
     ý #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)
      (dr-width my-door) ý 5.0
      (setf (dr-width my-door) 43.7) ý 43.7
      (dr-width my-door) ý 43.7

     Whether or not the :conc-name option is explicitly supplied, the
     following rule governs name conflicts of generated reader (or
     accessor) names: For any structure type Sá having a reader
     function named R for a slot named Xá that is inherited by another
     structure type Sà that would have a reader function with the same
     name R for a slot named Xà, no definition for R is generated by
     the definition of Sà; instead, the definition of R is inherited
     from the definition of Sá.  (In such a case, if Xá and Xà are
     different slots, the implementation might signal a style warning.)

:constructor
     This option takes zero, one, or two arguments.  If at least one
     argument is supplied and the first argument is not ÿnilþ, then
     that argument is a symbol which specifies the name of the
     constructor function.  If the argument is not supplied (or if the
     option itself is not supplied), the name of the constructor is
     produced by concatenating the string ÿ"MAKE-"þ and the name of the
     structure, interning the name in whatever package is current at
     the time ÿdefstructþ is expanded.  If the argument is provided and
     is ÿnilþ, no constructor function is defined.

     If :constructor is given as ÿ(:constructor NAME ARGLIST)þ, then
     instead of making a keyword driven constructor function,
     ÿdefstructþ defines a "positional" constructor function, taking
     arguments whose meaning is determined by the argument's position
     and possibly by keywords.  ARGLIST is used to describe what the
     arguments to the constructor will be. In the simplest case
     something like ÿ(:constructor make-foo (a b c))þ defines
     ÿmake-fooþ to be a three-argument constructor function whose
     arguments are used to initialize the slots named ÿaþ, ÿbþ, and ÿcþ.

     Because a constructor of this type operates "By Order of
     Arguments," it is sometimes known as a "boa constructor."

     For information on how the ARGLIST for a "boa constructor" is
     processed, see *Note Section 3.4.6 (Boa Lambda Lists): Boa Lambda
     Lists.

     It is permissible to use the :constructor option more than once,
     so that you can define several different constructor functions,
     each taking different parameters.

     ÿdefstructþ creates the default-named keyword constructor function
     only if no explicit :constructor options are specified, or if the
     :constructor option is specified without a NAME argument.

     ÿ(:constructor nil)þ is meaningful only when there are no other
     :constructor options specified.  It prevents ÿdefstructþ from
     generating any constructors at all.

     Otherwise, ÿdefstructþ creates a constructor function corresponding
     to each supplied :constructor option.  It is permissible to specify
     multiple keyword constructor functions as well as multiple "boa
     constructors".

:copier
     This option takes one argument, a symbol, which specifies the name
     of the copier function.  If the argument is not provided or if the
     option itself is not provided, the name of the copier is produced
     by concatenating the string ÿ"COPY-"þ and the name of the
     structure, interning the name in whatever package is current at
     the time ÿdefstructþ is expanded.  If the argument is provided and
     is ÿnilþ, no copier function is defined.

     The automatically defined copier function is a function of one
     argument, which must be of the structure type being defined.  The
     copier function creates a fresh structure that has the same type
     as its argument, and that has the same component values as the
     original structure; that is, the component values are not copied
     recursively.  If the ÿdefstructþ :type option was not used, the
     following equivalence applies:

      (COPIER-NAME x) = (copy-structure (the STRUCTURE-NAME x))

:include
     This option is used for building a new structure definition as an
     extension of another structure definition.  For example:

      (defstruct person name age sex)

     To make a new structure to represent an astronaut that has the
     attributes of name, age, and sex, and functions that operate on
     ÿpersonþ structures, ÿastronautþ is defined with :include as
     follows:

      (defstruct (astronaut (:include person)
                            (:conc-name astro-))
         helmet-size
         (favorite-beverage 'tang))

     :include causes the structure being defined to have the same slots
     as the included structure.  This is done in such a way that the
     reader functions for the included structure also work on the
     structure being defined.  In this example, an ÿastronautþ
     therefore has five slots: the three defined in ÿpersonþ and the
     two defined in ÿastronautþ itself.  The reader functions defined
     by the ÿpersonþ structure can be applied to instances of the
     ÿastronautþ structure, and they work correctly.  Moreover,
     ÿastronautþ has its own reader functions for components defined by
     the ÿpersonþ structure.  The following examples illustrate the use
     of ÿastronautþ structures:

      (setq x (make-astronaut :name 'buzz
                              :age 45.
                              :sex t
                              :helmet-size 17.5))
      (person-name x) ý BUZZ
      (astro-name x) ý BUZZ
      (astro-favorite-beverage x) ý TANG

      (reduce #'+ astros :key #'person-age) ; obtains the total of the ages
                                            ; of the possibly empty
                                            ; sequence of astros

     The difference between the reader functions ÿperson-nameþ and
     ÿastro-nameþ is that ÿperson-nameþ can be correctly applied to any
     ÿpersonþ, including an ÿastronautþ, while ÿastro-nameþ can be
     correctly applied only to an ÿastronautþ.  An implementation might
     check for incorrect use of reader functions.

     At most one :include can be supplied in a single ÿdefstructþ.  The
     argument to :include is required and must be the name of some
     previously defined structure.  If the structure being defined has
     no :type option, then the included structure must also have had no
     :type option supplied for it.  If the structure being defined has
     a :type option, then the included structure must have been
     declared with a :type option specifying the same representation
     type.

     If no :type option is involved, then the structure name of the
     including structure definition becomes the name of a data type,
     and therefore a valid type specifier recognizable by ÿtypepþ; it
     becomes a subtype of the included structure.  In the above example,
     ÿastronautþ is a subtype of ÿpersonþ; hence

      (typep (make-astronaut) 'person) ý true

     indicating that all operations on persons also work on astronauts.

     The structure using :include can specify default values or
     slot-options for the included slots different from those the
     included structure specifies, by giving the :include option as:

      (:include INCLUDED-STRUCTURE-NAME {slot-description}*)

     Each SLOT-DESCRIPTION must have a SLOT-NAME that is the same as
     that of some slot in the included structure.  If a
     SLOT-DESCRIPTION has no SLOT-INITFORM, then in the new structure
     the slot has no initial value.  Otherwise its initial value form
     is replaced by the SLOT-INITFORM in the SLOT-DESCRIPTION.  A
     normally writable slot can be made read-only.  If a slot is
     read-only in the included structure, then it must also be so in
     the including structure.  If a type is supplied for a slot, it
     must be a subtype of the type specified in the included structure.

     For example, if the default age for an astronaut is ÿ45þ, then

      (defstruct (astronaut (:include person (age 45)))
         helmet-size
         (favorite-beverage 'tang))

     If :include is used with the :type option, then the effect is
     first to skip over as many representation elements as needed to
     represent the included structure, then to skip over any additional
     elements supplied by the :initial-offset option, and then to begin
     allocation of elements from that point.  For example:

      (defstruct (binop (:type list) :named (:initial-offset 2))
        (operator '? :type symbol)
        operand-1
        operand-2) ý BINOP
      (defstruct (annotated-binop (:type list)
                                  (:initial-offset 3)
                                  (:include binop))
       commutative associative identity) ý ANNOTATED-BINOP
      (make-annotated-binop :operator '*
                            :operand-1 'x
                            :operand-2 5
                            :commutative t
                            :associative t
                            :identity 1)
        ý (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)

     The first two ÿnilþ elements stem from the :initial-offset of ÿ2þ
     in the definition of ÿbinopþ.  The next four elements contain the
     structure name and three slots for ÿbinopþ.  The next three
     ÿnilþ elements stem from the :initial-offset of ÿ3þ in the
     definition of ÿannotated-binopþ.  The last three list elements
     contain the additional slots for an ÿannotated-binopþ.

:initial-offset
     :initial-offset instructs ÿdefstructþ to skip over a certain
     number of slots before it starts allocating the slots described in
     the body.  This option's argument is the number of slots
     ÿdefstructþ should skip.  :initial-offset can be used only if
     :type is also supplied.

     :initial-offset allows slots to be allocated beginning at a
     representational element other than the first.  For example, the
     form

      (defstruct (binop (:type list) (:initial-offset 2))
        (operator '? :type symbol)
        operand-1
        operand-2) ý BINOP

     would result in the following behavior for ÿmake-binopþ:

      (make-binop :operator '+ :operand-1 'x :operand-2 5)
     ý (NIL NIL + X 5)
      (make-binop :operand-2 4 :operator '*)
     ý (NIL NIL * NIL 4)

     The selector functions ÿbinop-operatorþ, ÿbinop-operand-1þ, and
     ÿbinop-operand-2þ would be essentially equivalent to ÿthirdþ,
     ÿfourthþ, and ÿfifthþ, respectively.  Similarly, the form

      (defstruct (binop (:type list) :named (:initial-offset 2))
        (operator '? :type symbol)
        operand-1
        operand-2) ý BINOP

     would result in the following behavior for ÿmake-binopþ:

      (make-binop :operator '+ :operand-1 'x :operand-2 5) ý (NIL NIL BINOP + X 5)
      (make-binop :operand-2 4 :operator '*) ý (NIL NIL BINOP * NIL 4)

     The first two ÿnilþ elements stem from the :initial-offset of ÿ2þ
     in the definition of ÿbinopþ.  The next four elements contain the
     structure name and three slots for ÿbinopþ.

:named
     :named specifies that the structure is named.  If no :type is
     supplied, then the structure is always named.

     For example:

      (defstruct (binop (:type list))
        (operator '? :type symbol)
        operand-1
        operand-2) ý BINOP

     This defines a constructor function ÿmake-binopþ and three
     selector functions, namely ÿbinop-operatorþ, ÿbinop-operand-1þ,
     and ÿbinop-operand-2þ.  (It does not, however, define a predicate
     ÿbinop-pþ, for reasons explained below.)

     The effect of ÿmake-binopþ is simply to construct a list of length
     three:

      (make-binop :operator '+ :operand-1 'x :operand-2 5) ý (+ X 5)
      (make-binop :operand-2 4 :operator '*) ý (* NIL 4)

     It is just like the function ÿlistþ except that it takes keyword
     arguments and performs slot defaulting appropriate to the ÿbinopþ
     conceptual data type.  Similarly, the selector functions
     ÿbinop-operatorþ, ÿbinop-operand-1þ, and ÿbinop-operand-2þ are
     essentially equivalent to ÿcarþ, ÿcadrþ, and ÿcaddrþ,
     respectively.  They might not be completely equivalent because,
     for example, an implementation would be justified in adding
     error-checking code to ensure that the argument to each selector
     function is a length-3 list.

     ÿbinopþ is a conceptual data type in that it is not made a part of
     the Common Lisp type system.  ÿtypepþ does not recognize ÿbinopþ as
     a type specifier, and ÿtype-ofþ returns ÿlistþ when given a
     ÿbinopþ structure.  There is no way to distinguish a data
     structure constructed by ÿmake-binopþ from any other list that
     happens to have the correct structure.

     There is not any way to recover the structure name ÿbinopþ from a
     structure created by ÿmake-binopþ.  This can only be done if the
     structure is named.  A named structure has the property that,
     given an instance of the structure, the structure name (that names
     the type) can be reliably recovered.  For structures defined with
     no :type option, the structure name actually becomes part of the
     Common Lisp data-type system.  ÿtype-ofþ, when applied to such a
     structure, returns the structure name as the type of the object;
     ÿtypepþ recognizes the structure name as a valid type specifier.

     For structures defined with a :type option, ÿtype-ofþ returns a
     type specifier such as ÿlistþ or ÿ(vector t)þ, depending on the
     type supplied to the :type option.  The structure name does not
     become a valid type specifier.  However, if the :named option is
     also supplied, then the first component of the structure (as
     created by a ÿdefstructþ constructor function) always contains the
     structure name.  This allows the structure name to be recovered
     from an instance of the structure and allows a reasonable
     predicate for the conceptual type to be defined: the automatically
     defined NAME-P predicate for the structure operates by first
     checking that its argument is of the proper type (ÿlistþ, ÿ(vector
     t)þ, or whatever) and then checking whether the first component
     contains the appropriate type name.

     Consider the ÿbinopþ example shown above, modified only to include
     the :named option:

      (defstruct (binop (:type list) :named)
        (operator '? :type symbol)
        operand-1
        operand-2) ý BINOP

     As before, this defines a constructor function ÿmake-binopþ and
     three selector functions ÿbinop-operatorþ, ÿbinop-operand-1þ, and
     ÿbinop-operand-2þ.  It also defines a predicate ÿbinop-pþ.  The
     effect of ÿmake-binopþ is now to construct a list of length four:

      (make-binop :operator '+ :operand-1 'x :operand-2 5) ý (BINOP + X 5)
      (make-binop :operand-2 4 :operator '*) ý (BINOP * NIL 4)

     The structure has the same layout as before except that the
     structure name ÿbinopþ is included as the first list element.  The
     selector functions ÿbinop-operatorþ, ÿbinop-operand-1þ, and
     ÿbinop-operand-2þ are essentially equivalent to ÿcadrþ, ÿcaddrþ,
     and ÿcadddrþ, respectively.  The predicate ÿbinop-pþ is more or
     less equivalent to this definition:

      (defun binop-p (x)
        (and (consp x) (eq (car x) 'binop))) ý BINOP-P

     The name ÿbinopþ is still not a valid type specifier recognizable
     to ÿtypepþ, but at least there is a way of distinguishing ÿbinopþ
     structures from other similarly defined structures.

:predicate
     This option takes one argument, which specifies the name of the
     type predicate.  If the argument is not supplied or if the option
     itself is not supplied, the name of the predicate is made by
     concatenating the name of the structure to the string ÿ"-P"þ,
     interning the name in whatever package is current at the time
     ÿdefstructþ is expanded.  If the argument is provided and is
     ÿnilþ, no predicate is defined.  A predicate can be defined only
     if the structure is named; if :type is supplied and :named is not
     supplied, then :predicate must either be unsupplied or have the
     value ÿnilþ.

:print-function, :print-object
     The :print-function and :print-object options specify that a
     ÿprint-objectþ method for structures of type STRUCTURE-NAME should
     be generated.  These options are not synonyms, but do perform a
     similar service; the choice of which option (:print-function or
     :print-object) is used affects how the function named PRINTER-NAME
     is called.  Only one of these options may be used, and these
     options may be used only if :type is not supplied.

     If the :print-function option is used, then when a structure of
     type STRUCTURE-NAME is to be printed, the designated printer
     function is called on three arguments:

        - the structure to be printed (a generalized instance of
          STRUCTURE-NAME).

        - a stream to print to.

        - an integer indicating the current depth.  The magnitude of
          this integer may vary between implementations; however, it
          can reliably be compared against ÿ*print-level*þ to determine
          whether depth abbreviation is appropriate.

     Specifying ÿ(:print-function PRINTER-NAME)þ is approximately
     equivalent to specifying:

      (defmethod print-object ((object STRUCTURE-NAME) stream)
        (funcall (function PRINTER-NAME) object stream «CURRENT-PRINT-DEPTH»))

     where the «CURRENT-PRINT-DEPTH» represents the printer's belief of
     how deep it is currently printing.  It is implementation-dependent
     whether «CURRENT-PRINT-DEPTH» is always 0 and *PRINT-LEVEL*, if
     non-nil, is re-bound to successively smaller values as printing
     descends recursively, or whether CURRENT-PRINT-DEPTH varies in
     value as printing descends recursively and *PRINT-LEVEL* remains
     constant during the same traversal.

     If the :print-object option is used, then when a structure of type
     STRUCTURE-NAME is to be printed, the designated printer function
     is called on two arguments:

        - the structure to be printed.

        - the stream to print to.

     Specifying ÿ(:print-object PRINTER-NAME)þ is equivalent to
     specifying:

      (defmethod print-object ((object STRUCTURE-NAME) stream)
        (funcall (function PRINTER-NAME) object stream))

     If no :type option is supplied, and if either a :print-function or
     a :print-object option is supplied, and if no PRINTER-NAME is
     supplied, then a ÿprint-objectþ method specialized for
     STRUCTURE-NAME is generated that calls a function that implements
     the default printing behavior for structures using ÿ#Sþ notation;
     see *Note Section 22.1.3.12 (Printing Structures):
     PrintingStructures.

     If neither a :print-function nor a :print-object option is
     supplied, then ÿdefstructþ does not generate a ÿprint-objectþ
     method specialized for STRUCTURE-NAME and some default behavior is
     inherited either from a structure named in an :include option or
     from the default behavior for printing structures; see the
     function *Note print-object:: and *Note Section 22.1.3.12
     (Printing Structures): PrintingStructures.

     When ÿ*print-circle*þ is true, a user-defined print function can
     print objects to the supplied stream using ÿwriteþ, ÿprin1þ,
     ÿprincþ, or ÿformatþ and expect circularities to be detected and
     printed using the ÿ#n#þ syntax.  This applies to methods on
     ÿprint-objectþ in addition to :print-function options.  If a
     user-defined print function prints to a stream other than the one
     that was supplied, then circularity detection starts over for that
     stream.  See the variable *Note *print-circle*::.

:type
     :type explicitly specifies the representation to be used for the
     structure.  Its argument must be one of these types:

    ÿvectorþ
          This produces the same result as specifying ÿ(vector t)þ.
          The structure is represented as a general vector, storing
          components as vector elements.  The first component is vector
          element 1 if the structure is :named, and element 0 otherwise.

    ÿ(vector ELEMENT-TYPE)þ
          The structure is represented as a (possibly specialized)
          vector, storing components as vector elements.  Every
          component must be of a type that can be stored in a vector of
          the type specified.  The first component is vector element 1
          if the structure is :named, and element 0 otherwise.  The
          structure can be :named only if the type ÿsymbolþ is a
          subtype of the supplied ELEMENT-TYPE.

    ÿlistþ
          The structure is represented as a list.  The first component
          is the cadr if the structure is :named, and the car if it is
          not :named.

     Specifying this option has the effect of forcing a specific
     representation and of forcing the components to be stored in the
     order specified in ÿdefstructþ in corresponding successive
     elements of the specified representation.  It also prevents the
     structure name from becoming a valid type specifier recognizable
     by ÿtypepþ.

     For example:

      (defstruct (quux (:type list) :named) x y)

     should make a constructor that builds a list exactly like the one
     that ÿlistþ produces, with ÿquuxþ as its car.

     If this type is defined:

      (deftype quux () '(satisfies quux-p))

     then this form

      (typep (make-quux) 'quux)

     should return precisely what this one does

      (typep (list 'quux nil nil) 'quux)

     If :type is not supplied, the structure is represented as an
     object of type ÿstructure-objectþ.

     ÿdefstructþ without a :type option defines a class with the
     structure name as its name. The metaclass of structure instances
     is ÿstructure-classþ.

The consequences of redefining a ÿdefstructþ structure are undefined.

In the case where no ÿdefstructþ options have been supplied, the
following functions are automatically defined to operate on instances
of the new structure:

Predicate
     A predicate with the name ÿSTRUCTURE-NAME-pþ is defined to test
     membership in the structure type.  The predicate
     ÿ(STRUCTURE-NAME-p OBJECT)þ is true if an OBJECT is of this type;
     otherwise it is false.  ÿtypepþ can also be used with the name of
     the new type to test whether an object belongs to the type.  Such
     a function call has the form ÿ(typep OBJECT 'STRUCTURE-NAME)þ.

Component reader functions
     Reader functions are defined to read the components of the
     structure.  For each slot name, there is a corresponding reader
     function with the name ÿSTRUCTURE-NAME-SLOT-NAMEþ.  This function
     reads the contents of that slot.  Each reader function takes one
     argument, which is an instance of the structure type.  ÿsetfþ can
     be used with any of these reader functions to alter the slot
     contents.

Constructor function
     A constructor function with the name ÿmake-STRUCTURE-NAMEþ is
     defined.  This function creates and returns new instances of the
     structure type.

Copier function
     A copier function with the name ÿcopy-STRUCTURE-NAMEþ is defined.
     The copier function takes an object of the structure type and
     creates a new object of the same  type that is a copy of the
     first.  The copier function creates a new structure with the same
     component entries as the original.  Corresponding components of
     the two structure instances are ÿeqlþ.

If a ÿdefstructþ form appears as a top level form, the compiler must
make the structure type name recognized as a valid type name in
subsequent declarations (as for ÿdeftypeþ) and make the structure slot
readers known to ÿsetfþ.  In addition, the compiler must save enough
information about the structure type so that further ÿdefstructþ
definitions can use :include in a subsequent ÿdeftypeþ in the same file
to refer to the structure type name.  The functions which ÿdefstructþ
generates are not defined in the compile time environment, although the
compiler may save enough information about the functions to code
subsequent calls inline.  The ÿ#Sþ reader macro might or might not
recognize the newly defined structure type name at compile time.

Examples:
.........

An example of a structure definition follows:

 (defstruct ship
   x-position
   y-position
   x-velocity
   y-velocity
   mass)

This declares that every ÿshipþ is an object with five named components.
The evaluation of this form does the following:

  1. It defines ÿship-x-positionþ to be a function of one argument, a
     ship, that returns the ÿx-positionþ of the ship; ÿship-y-positionþ
     and the other components are given similar function definitions.
     These functions are called the access functions, as they are used
     to access elements of the structure.

  2. ÿshipþ becomes the name of a type of which instances of ships are
     elements.  ÿshipþ becomes acceptable to ÿtypepþ, for example;
     ÿ(typep x 'ship)þ is true if ÿxþ is a ship and false if ÿxþ is any
     object other than a ship.

  3. A function named ÿship-pþ of one argument is defined; it is a
     predicate that is true if its argument is a ship and is false
     otherwise.

  4. A function called ÿmake-shipþ is defined that, when invoked,
     creates a data structure with five components, suitable for use
     with the access functions.  Thus executing

      (setq ship2 (make-ship))

     sets ÿship2þ to a newly created ÿshipþ object.  One can supply the
     initial values of any desired component in the call to ÿmake-shipþ
     by using keyword arguments in this way:

      (setq ship2 (make-ship :mass *default-ship-mass*
                             :x-position 0
                             :y-position 0))

     This constructs a new ship and initializes three of its components.
     This function is called the "constructor function" because it
     constructs a new structure.

  5. A function called ÿcopy-shipþ of one argument is defined that,
     when given a ÿshipþ object, creates a new ÿshipþ object that is a
     copy of the given one.  This function is called the "copier
     function."

ÿsetfþ can be used to alter the components of a ÿshipþ:

 (setf (ship-x-position ship2) 100)

This alters the ÿx-positionþ of ÿship2þ to be ÿ100þ.  This works
because ÿdefstructþ behaves as if it generates an appropriate ÿdefsetfþ
for each access function.

;;;
;;; Example 1
;;; define town structure type
;;; area, watertowers, firetrucks, population, elevation are its components
;;;
 (defstruct town
             area
             watertowers
             (firetrucks 1 :type fixnum)    ;an initialized slot
             population
             (elevation 5128 :read-only t)) ;a slot that can't be changed
ý TOWN
;create a town instance
 (setq town1 (make-town :area 0 :watertowers 0)) ý #S(TOWN...)
;town's predicate recognizes the new instance
 (town-p town1) ý true
;new town's area is as specified by make-town
 (town-area town1) ý 0
;new town's elevation has initial value
 (town-elevation town1) ý 5128
;setf recognizes reader function
 (setf (town-population town1) 99) ý 99
 (town-population town1) ý 99
;copier function makes a copy of town1
 (setq town2 (copy-town town1)) ý #S(TOWN...)
 (= (town-population town1) (town-population town2))  ý true
;since elevation is a read-only slot, its value can be set only
;when the structure is created
 (setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))
ý #S(TOWN...)
;;;
;;; Example 2
;;; define clown structure type
;;; this structure uses a nonstandard prefix
;;;
 (defstruct (clown (:conc-name bozo-))
             (nose-color 'red)
             frizzy-hair-p polkadots) ý CLOWN
 (setq funny-clown (make-clown)) ý #S(CLOWN)
;use non-default reader name
 (bozo-nose-color funny-clown) ý RED
 (defstruct (klown (:constructor make-up-klown) ;similar def using other
             (:copier clone-klown)              ;customizing keywords
             (:predicate is-a-bozo-p))
             nose-color frizzy-hair-p polkadots) ý klown
;custom constructor now exists
 (fboundp 'make-up-klown) ý true
;;;
;;; Example 3
;;; define a vehicle structure type
;;; then define a truck structure type that includes
;;; the vehicle structure
;;;
 (defstruct vehicle name year (diesel t :read-only t)) ý VEHICLE
 (defstruct (truck (:include vehicle (year 79)))
             load-limit
             (axles 6)) ý TRUCK
 (setq x (make-truck :name 'mac :diesel t :load-limit 17))
ý #S(TRUCK...)
;vehicle readers work on trucks
 (vehicle-name x)
ý MAC
;default taken from :include clause
 (vehicle-year x)
ý 79
 (defstruct (pickup (:include truck))     ;pickup type includes truck
             camper long-bed four-wheel-drive) ý PICKUP
 (setq x (make-pickup :name 'king :long-bed t)) ý #S(PICKUP...)
;:include default inherited
 (pickup-year x) ý 79
;;;
;;; Example 4
;;; use of BOA constructors
;;;
 (defstruct (dfs-boa                      ;BOA constructors
               (:constructor make-dfs-boa (a b c))
               (:constructor create-dfs-boa
                 (a &optional b (c 'cc) &rest d &aux e (f 'ff))))
             a b c d e f) ý DFS-BOA
;a, b, and c set by position, and the rest are uninitialized
 (setq x (make-dfs-boa 1 2 3)) ý #(DFS-BOA...)
 (dfs-boa-a x) ý 1
;a and b set, c and f defaulted
 (setq x (create-dfs-boa 1 2)) ý #(DFS-BOA...)
 (dfs-boa-b x) ý 2
 (eq (dfs-boa-c x) 'cc) ý true
;a, b, and c set, and the rest are collected into d
 (setq x (create-dfs-boa 1 2 3 4 5 6)) ý #(DFS-BOA...)
 (dfs-boa-d x) ý (4 5 6)

Exceptional Situations:
.......................

If any two slot names (whether present directly or inherited by the
:include option) are the same under ÿstring=þ, ÿdefstructþ should
signal an error of type ÿprogram-errorþ.

The consequences are undefined if the INCLUDED-STRUCTURE-NAME does not
name a structure type.

See Also:
.........

*Note documentation::, *Note print-object::, *Note setf::, *Note
subtypep::, *Note type-of::, *Note typep::, *Note Section 3.2
(Compilation): Compilation.

Notes:
......

The PRINTER-NAME should observe the values of such printer-control
variables as ÿ*print-escape*þ.

The restriction against issuing a warning for type mismatches between a
SLOT-INITFORM and the corresponding slot's :type option is necessary
because a SLOT-INITFORM must be specified in order to specify slot
options; in some cases, no suitable default may exist.

The mechanism by which ÿdefstructþ arranges for slot accessors to be
usable with ÿsetfþ is implementation-dependent; for example, it may use
setf functions, setf expanders, or some other implementation-dependent
mechanism known to that implementation's code for ÿsetfþ.


File: chris-ansicl.info,  Node: copy-structure,  Prev: defstruct,  Up: Structures

copy-structure (Function)
=========================

Syntax:
.......

 -- Function: copy-structure structure ý copy

Arguments and Values:
.....................

STRUCTURE--a structure.

COPY--a copy of the STRUCTURE.

Description:
............

Returns a copyÜ of the STRUCTURE.

Only the STRUCTURE itself is copied; not the values of the slots.

See Also:
.........

the :copier option to *Note defstruct::

Notes:
......

The COPY is the same as the given STRUCTURE under ÿequalpþ, but not
under ÿequalþ.


File: chris-ansicl.info,  Node: Conditions,  Next: Symbols,  Prev: Structures,  Up: Top

9 Conditions
************

* Menu:

* Condition System Concepts::

Dictionary

* condition::
* warning::
* style-warning::
* serious-condition::
* error (Condition Type)::
* cell-error::
* cell-error-name::
* parse-error::
* storage-condition::
* assert::
* error (Function)::
* cerror::
* check-type::
* simple-error::
* invalid-method-error::
* method-combination-error::
* signal::
* simple-condition::
* simple-condition-format-control; simple-condition-format-arguments::
* warn::
* simple-warning::
* invoke-debugger::
* break::
* *debugger-hook*::
* *break-on-signals*::
* handler-bind::
* handler-case::
* ignore-errors::
* define-condition::
* make-condition::
* restart::
* compute-restarts::
* find-restart::
* invoke-restart::
* invoke-restart-interactively::
* restart-bind::
* restart-case::
* restart-name::
* with-condition-restarts::
* with-simple-restart::
* abort (Restart)::
* continue (Restart)::
* muffle-warning (Restart)::
* store-value (Restart)::
* use-value (Restart)::
* abort; continue; muffle-warning; store-value; use-value::


File: chris-ansicl.info,  Node: Condition System Concepts,  Next: condition,  Up: Conditions

9.1 Condition System Concepts
=============================

Common Lisp constructs are described not only in terms of their
behavior in situations during which they are intended to be used (see
the "Description" part of each operator specification), but in all
other situations (see the "Exceptional Situations" part of each
operator specification).

A situation is the evaluation of an expression in a specific context.
A condition is an object that represents a specific situation that has
been detected.  Conditions are generalized instances of the class
ÿconditionþ.  A hierarchy of condition classes is defined in Common
Lisp.  A condition has slots that contain data relevant to the
situation that the condition represents.

An error is a situation in which normal program execution cannot
continue correctly without some form of intervention (either
interactively by the user or under program control).  Not all errors
are detected.  When an error goes undetected, the effects can be
implementation-dependent, implementation-defined, unspecified, or
undefined. See *Note Section 1.4 (Definitions): Definitions.  All
detected errors can be represented by conditions, but not all
conditions represent errors.

Signaling is the process by which a condition can alter the flow of
control in a program by raising the condition which can then be
handled.  The functions ÿerrorþ, ÿcerrorþ, ÿsignalþ, and ÿwarnþ are
used to signal conditions.

The process of signaling involves the selection and invocation of a
handler from a set of active handlers.  A handler is a function of one
argument (the condition) that is invoked to handle a condition.  Each
handler is associated with a condition type, and a handler will be
invoked only on a condition of the handler's associated type.

Active handlers are established dynamically (see ÿhandler-bindþ or
ÿhandler-caseþ).  Handlers are invoked in a dynamic environment
equivalent to that of the signaler, except that the set of active
handlers is bound in such a way as to include only those that were
active at the time the handler being invoked was established.
Signaling a condition has no side-effect on the condition, and there is
no dynamic state contained in a condition.

If a handler is invoked, it can address the situation in one of three
ways:

Decline
     It can decline to handle the condition.  It does this by simply
     returning rather than transferring control.  When this happens,
     any values returned by the handler are ignored and the next most
     recently established handler is invoked.  If there is no such
     handler and the signaling function is ÿerrorþ or ÿcerrorþ, the
     debugger is entered in the dynamic environment of the signaler. If
     there is no such handler and the signaling function is either
     ÿsignalþ or ÿwarnþ, the signaling function simply returns ÿnilþ.

Handle
     It can handle the condition by performing a non-local transfer of
     control.  This can be done either primitively by using ÿgoþ,
     ÿreturnþ, ÿthrowþ or more abstractly by using a function such as
     ÿabortþ or ÿinvoke-restartþ.

Defer
     It can put off a decision about whether to handle or decline, by
     any of a number of actions, but most commonly by signaling another
     condition, resignaling the same condition, or forcing entry into
     the debugger.

* Menu:

* Condition Types::
* Creating Conditions::
* Printing Conditions::
* Signaling and Handling Conditions::
* Assertions::
* Notes about the Condition System's Background::


File: chris-ansicl.info,  Node: Condition Types,  Next: Creating Conditions,  Up: Condition System Concepts

9.1.1 Condition Types
---------------------

The next figure lists the standardized condition types.  Additional
condition types can be defined by using ÿdefine-conditionþ.

arithmetic-error                   floating-point-overflow    simple-type-error
cell-error                         floating-point-underflow   simple-warning
condition                          package-error              storage-condition
control-error                      parse-error                stream-error
division-by-zero                   print-not-readable         style-warning
end-of-file                        program-error              type-error
error                              reader-error               unbound-slot
file-error                         serious-condition          unbound-variable
floating-point-inexact             simple-condition           undefined-function
floating-point-invalid-operation   simple-error               warning

Figure 9.1: Standardized Condition Types

All condition types are subtypes of type ÿconditionþ.  That is,

 (typep C 'condition) ý true

if and only if C is a condition.

Implementations must define all specified subtype relationships.
Except where noted, all subtype relationships indicated in this
document are not mutually exclusive.  A condition inherits the
structure of its supertypes.

The metaclass of the class ÿconditionþ is not specified.  Names of
condition types may be used to specify supertype relationships in
ÿdefine-conditionþ, but the consequences are not specified if an
attempt is made to use a condition type as a superclass in a ÿdefclassþ
form.

The next figure shows operators that define condition types and
creating conditions.

define-condition   make-condition   

Figure 9.2: Operators that define and create conditions.

The next figure shows operators that read the value of condition slots.

arithmetic-error-operands    simple-condition-format-arguments
arithmetic-error-operation   simple-condition-format-control
cell-error-name              stream-error-stream
file-error-pathname          type-error-datum
package-error-package        type-error-expected-type
print-not-readable-object    unbound-slot-instance

Figure 9.3: Operators that read condition slots.

9.1.1.1 Serious Conditions
..........................

A serious condition is a condition serious enough to require
interactive intervention if not handled.  Serious conditions are
typically signaled with ÿerrorþ or ÿcerrorþ; non-serious conditions are
typically signaled with ÿsignalþ or ÿwarnþ.


File: chris-ansicl.info,  Node: Creating Conditions,  Next: Printing Conditions,  Prev: Condition Types,  Up: Condition System Concepts

9.1.2 Creating Conditions
-------------------------

The function ÿmake-conditionþ can be used to construct a condition
object explicitly.  Functions such as ÿerrorþ, ÿcerrorþ, ÿsignalþ, and
ÿwarnþ operate on conditions and might create condition objects
implicitly.  Macros such as ÿccaseþ, ÿctypecaseþ, ÿecaseþ, ÿetypecaseþ,
ÿcheck-typeþ, and ÿassertþ might also implicitly create (and signal)
conditions.

9.1.2.1 Condition Designators
.............................

A number of the functions in the condition system take arguments which
are identified as "condition designators".  By convention, those
arguments are notated as

 DATUM &rest ARGUMENTS

Taken together, the DATUM and the ARGUMENTS are "designators for a
condition of default type DEFAULT-TYPE."  How the denoted condition is
computed depends on the type of the DATUM:

   * If the DATUM is a symbol naming a condition type ...

     The denoted condition is the result of

      (apply #'make-condition DATUM ARGUMENTS)

   * If the DATUM is a format control ...

     The denoted condition is the result of

      (make-condition DEFAULTED-TYPE
                      :format-control DATUM
                      :format-arguments ARGUMENTS)

     where the DEFAULTED-TYPE is a subtype of DEFAULT-TYPE.

   * If the DATUM is a condition ...

     The denoted condition is the DATUM itself.  In this case, unless
     otherwise specified by the description of the operator in
     question, the arguments must be null; that is, the consequences
     are undefined if any ARGUMENTS were supplied.

Note that the DEFAULT-TYPE gets used only in the case where the DATUM
string is supplied.  In the other situations, the resulting condition
is not necessarily of type DEFAULT-TYPE.

Here are some illustrations of how different condition designators can
denote equivalent condition objects:

(let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))
  (error c))
Õ (error 'arithmetic-error :operator '/ :operands '(7 0))

(error "Bad luck.")
Õ (error 'simple-error :format-control "Bad luck." :format-arguments '())


File: chris-ansicl.info,  Node: Printing Conditions,  Next: Signaling and Handling Conditions,  Prev: Creating Conditions,  Up: Condition System Concepts

9.1.3 Printing Conditions
-------------------------

If the :report argument to ÿdefine-conditionþ is used, a print function
is defined that is called whenever the defined condition is printed
while the value of ÿ*print-escape*þ is false.  This function is called
the "condition reporter"; the text which it outputs is called a "report
message".

When a condition is printed and ÿ*print-escape*þ is false, the
condition reporter for the condition is invoked.  Conditions are
printed automatically by functions such as ÿinvoke-debuggerþ, ÿbreakþ,
and ÿwarnþ.

When ÿ*print-escape*þ is true, the object should print in an
abbreviated fashion according to the style of the implementation (e.g.,
by ÿprint-unreadable-objectþ).  It is not required that a condition can
be recreated by reading its printed representation.

No function is provided for directly accessing or invoking condition
reporters.

9.1.3.1 Recommended Style in Condition Reporting
................................................

In order to ensure a properly aesthetic result when presenting report
messages to the user, certain stylistic conventions are recommended.

There are stylistic recommendations for the content of the messages
output by condition reporters, but there are no formal requirements on
those programs.  If a program violates the recommendations for some
message, the display of that message might be less aesthetic than if
the guideline had been observed, but the program is still considered a
conforming program.

The requirements on a program or implementation which invokes a
condition reporter are somewhat stronger.  A conforming program must be
permitted to assume that if these style guidelines are followed, proper
aesthetics will be maintained.  Where appropriate, any specific
requirements on such routines are explicitly mentioned below.

9.1.3.1.1 Capitalization and Punctuation in Condition Reports
.............................................................

It is recommended that a report message be a complete sentences, in the
proper case and correctly punctuated.  In English, for example, this
means the first letter should be uppercase, and there should be a
trailing period.

 (error "This is a message")  ; Not recommended
 (error "this is a message.") ; Not recommended

 (error "This is a message.") ; Recommended instead

9.1.3.1.2 Leading and Trailing Newlines in Condition Reports
............................................................

It is recommended that a report message not begin with any introductory
text, such as "ÿError: þ" or "ÿWarning: þ" or even just freshline or
newline.  Such text is added, if appropriate to the context, by the
routine invoking the condition reporter.

It is recommended that a report message not be followed by a trailing
freshline or newline.  Such text is added, if appropriate to the
context, by the routine invoking the condition reporter.

 (error "This is a message.~%")   ; Not recommended
 (error "~&This is a message.")   ; Not recommended
 (error "~&This is a message.~%") ; Not recommended

 (error "This is a message.")     ; Recommended instead

9.1.3.1.3 Embedded Newlines in Condition Reports
................................................

Especially if it is long, it is permissible and appropriate for a
report message to contain one or more embedded newlines.

If the calling routine conventionally inserts some additional prefix
(such as "ÿError: þ" or "ÿ;; Error: þ") on the first line of the
message, it must also assure that an appropriate prefix will be added
to each subsequent line of the output, so that the left edge of the
message output by the condition reporter will still be properly aligned.

 (defun test ()
   (error "This is an error message.~%It has two lines."))

 ;; Implementation A
 (test)
 This is an error message.
 It has two lines.

 ;; Implementation B
 (test)
 ;; Error: This is an error message.
 ;;        It has two lines.

 ;; Implementation C
 (test)
 >> Error: This is an error message.
           It has two lines.

9.1.3.1.4 Note about Tabs in Condition Reports
..............................................

Because the indentation of a report message might be shifted to the
right or left by an arbitrary amount, special care should be taken with
the semi-standard character <Tab>  (in those implementations that
support such a character).  Unless the implementation specifically
defines its behavior in this context, its use should be avoided.

9.1.3.1.5 Mentioning Containing Function in Condition Reports
.............................................................

The name of the containing function should generally not be mentioned in
report messages.  It is assumed that the debugger will make this
information accessible in situations where it is necessary and
appropriate.


File: chris-ansicl.info,  Node: Signaling and Handling Conditions,  Next: Assertions,  Prev: Printing Conditions,  Up: Condition System Concepts

9.1.4 Signaling and Handling Conditions
---------------------------------------

The operation of the condition system depends on the ordering of active
applicable handlers from most recent to least recent.

Each handler is associated with a type specifier that must designate a
subtype of type ÿconditionþ.  A handler is said to be applicable to a
condition if that condition is of the type designated by the associated
type specifier.

Active handlers are established by using ÿhandler-bindþ (or an
abstraction based on ÿhandler-bindþ, such as ÿhandler-caseþ or
ÿignore-errorsþ).

Active handlers can be established within the dynamic scope of other
active handlers.  At any point during program execution, there is a set
of active handlers.  When a condition is signaled, the most recent
active applicable handler for that condition is selected from this set.
Given a condition, the order of recentness of active applicable
handlers is defined by the following two rules:

  1. Each handler in a set of active handlers Há is more recent than
     every handler in a set Hà if the handlers in Hà were active when
     the handlers in Há were established.

  2. Let há and hà be two applicable active handlers established by the
     same form. Then há is more recent than hà if há was defined to the
     left of hà in the form that established them.

Once a handler in a handler binding form (such as ÿhandler-bindþ or
ÿhandler-caseþ) has been selected, all handlers in that form become
inactive for the remainder of the signaling process.  While the
selected handler runs, no other handler established by that form is
active. That is, if the handler declines, no other handler established
by that form will be considered for possible invocation.

The next figure shows operators relating to the handling of conditions.

handler-bind   handler-case   ignore-errors

Figure 9.4: Operators relating to handling conditions.

9.1.4.1 Signaling
.................

When a condition is signaled, the most recent applicable active handler
is invoked.  Sometimes a handler will decline by simply returning
without a transfer of control.  In such cases, the next most recent
applicable active handler is invoked.

If there are no applicable handlers for a condition that has been
signaled, or if all applicable handlers decline, the condition is
unhandled.

The functions ÿcerrorþ and ÿerrorþ invoke the interactive condition
handler (the debugger) rather than return if the condition being
signaled, regardless of its type, is unhandled.  In contrast, ÿsignalþ
returns ÿnilþ if the condition being signaled, regardless of its type,
is unhandled.

The variable ÿ*break-on-signals*þ can be used to cause the debugger to
be entered before the signaling process begins.

The next figure shows defined names relating to the signaling of
conditions.

*break-on-signals*   error    warn
cerror               signal   

Figure 9.5: Defined names relating to signaling conditions.

9.1.4.1.1 Resignaling a Condition
.................................

During the dynamic extent of the signaling process for a particular
condition object, ÿsignalingþ the same condition object again is
permitted if and only if the situation represented in both cases are
the same.

For example, a handler might legitimately signal the condition object
that is its argument in order to allow outer handlers first opportunity
to handle the condition.  (Such a handlers is sometimes called a
"default handler.")  This action is permitted because the situation
which the second signaling process is addressing is really the same
situation.

On the other hand, in an implementation that implemented asynchronous
keyboard events by interrupting the user process with a call to
ÿsignalþ, it would not be permissible for two distinct asynchronous
keyboard events to signal identical condition objects at the same time
for different situations.

9.1.4.2 Restarts
................

The interactive condition handler returns only through non-local
transfer of control to specially defined restarts that can be set up
either by the system or by user code.  Transferring control to a
restart is called "invoking" the restart.  Like handlers, active
restarts are established dynamically, and only active restarts can be
invoked.  An active restart can be invoked by the user from the
debugger or by a program by using ÿinvoke-restartþ.

A restart contains a function to be called when the restart is invoked,
an optional name that can be used to find or invoke the restart, and an
optional set of interaction information for the debugger to use to
enable the user to manually invoke a restart.

The name of a restart is used by ÿinvoke-restartþ. Restarts that can be
invoked only within the debugger do not need names.

Restarts can be established by using ÿrestart-bindþ, ÿrestart-caseþ,
and ÿwith-simple-restartþ.  A restart function can itself invoke any
other restart that was active at the time of establishment of the
restart of which the function is part.

The restarts established by a ÿrestart-bindþ form, a ÿrestart-caseþ
form, or a ÿwith-simple-restartþ form have dynamic extent which extends
for the duration of that form's execution.

Restarts of the same name can be ordered from least recent to most
recent according to the following two rules:

  1. Each restart in a set of active restarts Rá is more recent than
     every restart in a set Rà if the restarts in Rà were active when
     the  restarts in Rá were established.

  2. Let rá and rà be two active restarts with the same name
     established by the same form. Then rá is more recent than rà if rá
     was defined to the left of rà in the form that established them.

If a restart is invoked but does not transfer control, the values
resulting from the restart function are returned by the function that
invoked the restart, either ÿinvoke-restartþ or
ÿinvoke-restart-interactivelyþ.

9.1.4.2.1 Interactive Use of Restarts
.....................................

For interactive handling, two pieces of information are needed from a
restart: a report function and an interactive function.

The report function is used by a program such as the debugger to
present a description of the action the restart will take.  The report
function is specified and established by the :report-function keyword to
ÿrestart-bindþ or the :report keyword to ÿrestart-caseþ.

The interactive function, which can be specified using the
:interactive-function keyword to ÿrestart-bindþ or :interactive keyword
to ÿrestart-caseþ, is used when the restart is invoked interactively,
such as from the debugger, to produce a suitable list of arguments.

ÿinvoke-restartþ invokes the most recently established restart whose
name is the same as the first argument to ÿinvoke-restartþ.  If a
restart is invoked interactively by the debugger and  does not transfer
control but rather returns values, the precise action of the debugger
on those values is implementation-defined.

9.1.4.2.2 Interfaces to Restarts
................................

Some restarts have functional interfaces, such as ÿabortþ, ÿcontinueþ,
ÿmuffle-warningþ, ÿstore-valueþ, and ÿuse-valueþ.  They are ordinary
functions that use ÿfind-restartþ and ÿinvoke-restartþ internally, that
have the same name as the restarts they manipulate, and that are
provided simply for notational convenience.

The next figure shows defined names relating to restarts.

abort              invoke-restart-interactively   store-value
compute-restarts   muffle-warning                 use-value
continue           restart-bind                   with-simple-restart
find-restart       restart-case                   
invoke-restart     restart-name                   

Figure 9.6: Defined names relating to restarts.

9.1.4.2.3 Restart Tests
.......................

Each restart has an associated test, which is a function of one
argument (a condition or ÿnilþ) which returns true if the restart
should be visible in the current situation.  This test is created by
the :test-function option to ÿrestart-bindþ or the :test option to
ÿrestart-caseþ.

9.1.4.2.4 Associating a Restart with a Condition
................................................

A restart can be "associated with" a condition explicitly by
ÿwith-condition-restartsþ, or implicitly by ÿrestart-caseþ.  Such an
assocation has dynamic extent.

A single restart may be associated with several conditions at the same
time.  A single condition may have several associated restarts at the
same time.

Active restarts associated with a particular condition can be detected
by calling a function such as ÿfind-restartþ, supplying that condition
as the CONDITION argument.  Active restarts can also be detected
without regard to any associated condition by calling such a function
without a CONDITION argument, or by supplying a value of ÿnilþ for such
an argument.


File: chris-ansicl.info,  Node: Assertions,  Next: Notes about the Condition System's Background,  Prev: Signaling and Handling Conditions,  Up: Condition System Concepts

9.1.5 Assertions
----------------

Conditional signaling of conditions based on such things as key match,
form evaluation, and type are handled by assertion operators.  The next
figure shows operators relating to assertions.

assert   check-type   ecase
ccase    ctypecase    etypecase

Figure 9.7: Operators relating to assertions.


File: chris-ansicl.info,  Node: Notes about the Condition System's Background,  Prev: Assertions,  Up: Condition System Concepts

9.1.6 Notes about the Condition System's Background
---------------------------------------------------

For a background reference to the abstract concepts detailed in this
section, see `Exceptional Situations in Lisp'.  The details of that
paper are not binding on this document, but may be helpful in
establishing a conceptual basis for understanding this material.


File: chris-ansicl.info,  Node: condition,  Next: warning,  Prev: Condition System Concepts,  Up: Conditions

condition (Condition Type)
==========================

Class Precedence List:
......................

ÿconditionþ, ÿtþ

Description:
............

All types of conditions, whether error or non-error, must inherit from
this type.

No additional subtype relationships among the specified subtypes of
type ÿconditionþ are allowed, except when explicitly mentioned in the
text; however implementations are permitted to introduce additional
types and one of these types can be a subtype of any number of the
subtypes of type ÿconditionþ.

Whether a user-defined condition type has slots that are accessible by
with-slots is implementation-dependent.  Furthermore, even in an
implementation in which user-defined condition types would have slots,
it is implementation-dependent whether any condition types defined in
this document have such slots or, if they do, what their names might be;
only the reader functions documented by this specification may be relied
upon by portable code.

Conforming code must observe the following restrictions related to
conditions:

   * ÿdefine-conditionþ, not ÿdefclassþ, must be used to define new
     condition types.

   * ÿmake-conditionþ, not ÿmake-instanceþ, must be used to create
     condition objects explicitly.

   * The :report option of ÿdefine-conditionþ, not ÿdefmethodþ for
     ÿprint-objectþ, must be used to define a condition reporter.

   * ÿslot-valueþ, ÿslot-boundpþ, ÿslot-makunboundþ, and ÿwith-slotsþ
     must not be used on condition objects.  Instead, the appropriate
     accessor functions (defined by ÿdefine-conditionþ) should be used.


File: chris-ansicl.info,  Node: warning,  Next: style-warning,  Prev: condition,  Up: Conditions

warning (Condition Type)
========================

Class Precedence List:
......................

ÿwarningþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿwarningþ consists of all types of warnings.

See Also:
.........

*Note style-warning::


File: chris-ansicl.info,  Node: style-warning,  Next: serious-condition,  Prev: warning,  Up: Conditions

style-warning (Condition Type)
==============================

Class Precedence List:
......................

ÿstyle-warningþ, ÿwarningþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿstyle-warningþ includes those conditions that represent
situations involving code that is conforming code but that is
nevertheless considered to be faulty or substandard.

See Also:
.........

*Note muffle-warning::

Notes:
......

An implementation might signal such a condition if it encounters code
that uses deprecated features or that appears unaesthetic or
inefficient.

An `unused variable' warning must be of type ÿstyle-warningþ.

In general, the question of whether code is faulty or substandard is a
subjective decision to be made by the facility processing that code.
The intent is that whenever such a facility wishes to complain about
code on such subjective grounds, it should use this condition type so
that any clients who wish to redirect or muffle superfluous warnings
can do so without risking that they will be redirecting or muffling
other, more serious warnings.


File: chris-ansicl.info,  Node: serious-condition,  Next: error (Condition Type),  Prev: style-warning,  Up: Conditions

serious-condition (Condition Type)
==================================

Class Precedence List:
......................

ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

All conditions serious enough to require interactive intervention if
not handled should inherit from the type ÿserious-conditionþ.  This
condition type is provided primarily so that it may be included as a
superclass of other condition types; it is not intended to be signaled
directly.

Notes:
......

Signaling a serious condition does not itself force entry into the
debugger.   However, except in the unusual situation where the
programmer can assure that no harm will come from failing to handle a
serious condition, such a condition is usually signaled with ÿerrorþ
rather than ÿsignalþ in order to assure that the program does not
continue without handling the condition.  (And conversely, it is
conventional to use ÿsignalþ rather than ÿerrorþ to signal conditions
which are not serious conditions, since normally the failure to handle
a non-serious condition is not reason enough for the debugger to be
entered.)


File: chris-ansicl.info,  Node: error (Condition Type),  Next: cell-error,  Prev: serious-condition,  Up: Conditions

error (Condition Type)
======================

Class Precedence List:
......................

ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿerrorþ consists of all conditions that represent errors.


File: chris-ansicl.info,  Node: cell-error,  Next: cell-error-name,  Prev: error (Condition Type),  Up: Conditions

cell-error (Condition Type)
===========================

Class Precedence List:
......................

ÿcell-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿcell-errorþ consists of error conditions that occur during a
location access.   The name of the offending cell is initialized by the
:name initialization argument to ÿmake-conditionþ, and is accessed by
the function ÿcell-error-nameþ.

See Also:
.........

*Note cell-error-name::


File: chris-ansicl.info,  Node: cell-error-name,  Next: parse-error,  Prev: cell-error,  Up: Conditions

cell-error-name (Function)
==========================

Syntax:
.......

 -- Function: cell-error-name condition ý name

Arguments and Values:
.....................

CONDITION--a condition of type ÿcell-errorþ.

NAME--an object.

Description:
............

Returns the name of the offending cell involved in the situation
represented by CONDITION.

The nature of the result depends on the specific type of CONDITION.
For example, if the CONDITION is of type ÿunbound-variableþ, the result
is the name of the unbound variable which was being accessed, if the
CONDITION is of type ÿundefined-functionþ, this is the name of the
undefined function which was being accessed, and if the CONDITION is of
type ÿunbound-slotþ, this is the name of the slot which was being
accessed.

See Also:
.........

*Note cell-error::, *Note unbound-slot::, *Note unbound-variable::,
*Note undefined-function::, *Note Section 9.1 (Condition System
Concepts): Condition System Concepts.


File: chris-ansicl.info,  Node: parse-error,  Next: storage-condition,  Prev: cell-error-name,  Up: Conditions

parse-error (Condition Type)
============================

Class Precedence List:
......................

ÿparse-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿparse-errorþ consists of error conditions that are related to
parsing.

See Also:
.........

*Note parse-namestring::, *Note reader-error::


File: chris-ansicl.info,  Node: storage-condition,  Next: assert,  Prev: parse-error,  Up: Conditions

storage-condition (Condition Type)
==================================

Class Precedence List:
......................

ÿstorage-conditionþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿstorage-conditionþ consists of serious conditions that relate
to problems with memory management that are potentially due to
implementation-dependent limits rather than semantic errors in
conforming programs, and that typically warrant entry to the debugger
if not handled.  Depending on the details of the implementation, these
might include such problems as stack overflow, memory region overflow,
and storage exhausted.

Notes:
......

While some Common Lisp operations might signal storage-condition
because they are defined to create objects, it is unspecified whether
operations that are not defined to create objects create them anyway
and so might also signal ÿstorage-conditionþ.  Likewise, the evaluator
itself might create objects and so might signal ÿstorage-conditionþ.
(The natural assumption might be that such object creation is naturally
inefficient, but even that is implementation-dependent.)  In general,
the entire question of how storage allocation is done is
implementation-dependent, and so any operation might signal
ÿstorage-conditionþ at any time.  Because such a condition is
indicative of a limitation of the implementation or of the image rather
than an error in a program, objects of type ÿstorage-conditionþ are not
of type ÿerrorþ.


File: chris-ansicl.info,  Node: assert,  Next: error (Function),  Prev: storage-condition,  Up: Conditions

assert (Macro)
==============

Syntax:
.......

 -- Macro: assert test-form [({place}*) [datum-form {argument-form}*]]
          ý ÿnilþ

Arguments and Values:
.....................

TEST-FORM--a form; always evaluated.

PLACE--a place; evaluated if an error is signaled.

DATUM-FORM--a form that evaluates to a DATUM.  Evaluated each time an
error is to be signaled, or not at all if no error is to be signaled.

ARGUMENT-FORM--a form that evaluates to an ARGUMENT.  Evaluated each
time an error is to be signaled, or not at all if no error is to be
signaled.

DATUM, ARGUMENTS--designators for a condition of default type ÿerrorþ.
(These designators are the result of evaluating DATUM-FORM and each of
the ARGUMENT-FORMS.)

Description:
............

ÿassertþ assures that TEST-FORM evaluates to true.  If TEST-FORM
evaluates to false, ÿassertþ signals a correctable error (denoted by
DATUM and ARGUMENTS).  Continuing from this error using the ÿcontinueþ
restart makes it possible for the user to alter the values of the
PLACES before ÿassertþ evaluates TEST-FORM again.  If the value of
TEST-FORM is non-nil, ÿassertþ returns ÿnilþ.

The PLACES are generalized references to data upon which TEST-FORM
depends, whose values can be changed by the user in attempting to
correct the error.  Subforms of each PLACE are only evaluated if an
error is signaled, and might be re-evaluated if the error is
re-signaled (after continuing without actually fixing the problem).
The order of evaluation of the PLACES is not specified; see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.  If
a PLACE form is supplied that produces more values than there are store
variables, the extra values are ignored. If the supplied form produces
fewer values than there are store variables, the missing values are set
to ÿnilþ.

Examples:
.........

 (setq x (make-array '(3 5) :initial-element 3))
ý #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))
 (setq y (make-array '(3 5) :initial-element 7))
ý #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))
 (defun matrix-multiply (a b)
   (let ((*print-array* nil))
     (assert (and (= (array-rank a) (array-rank b) 2)
                  (= (array-dimension a 1) (array-dimension b 0)))
             (a b)
             "Cannot multiply ~S by ~S." a b)
            (really-matrix-multiply a b))) ý MATRIX-MULTIPLY
 (matrix-multiply x y)
Ö Correctable error in MATRIX-MULTIPLY:
Ö Cannot multiply #<ARRAY ...> by #<ARRAY ...>.
Ö Restart options:
Ö  1: You will be prompted for one or more new values.
Ö  2: Top level.
Ö Debug> :continue 1
Ö Value for A: x
Ö Value for B: (make-array '(5 3) :initial-element 6)
ý #2A((54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54))

 (defun double-safely (x) (assert (numberp x) (x)) (+ x x))
 (double-safely 4)
ý 8

 (double-safely t)
Ö Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.
Ö Restart options:
Ö  1: You will be prompted for one or more new values.
Ö  2: Top level.
Ö Debug> :continue 1
Ö Value for X: 7
ý 14

Affected By:
............

ÿ*break-on-signals*þ

The set of active condition handlers.

See Also:
.........

*Note check-type::, *Note error (Function)::, *Note Section 5.1
(Generalized Reference): Generalized Reference.

Notes:
......

The debugger need not include the TEST-FORM in the error message, and
the PLACES should not be included in the message, but they should be
made available for the user's perusal.  If the user gives the
"continue" command, the values of any of the references can be altered.
The details of this depend on the implementation's style of user
interface.


File: chris-ansicl.info,  Node: error (Function),  Next: cerror,  Prev: assert,  Up: Conditions

error (Function)
================

Syntax:
.......

 -- Function: error datum &rest arguments ý|

Arguments and Values:
.....................

DATUM, ARGUMENTS--designators for a condition of default type
ÿsimple-errorþ.

Description:
............

ÿerrorþ effectively invokes ÿsignalþ on the denoted condition.

If the condition is not handled, ÿ(invoke-debugger condition)þ is done.
As a consequence of calling ÿinvoke-debuggerþ, ÿerrorþ cannot directly
return; the only exit from ÿerrorþ can come by non-local transfer of
control in a handler or by use of an interactive debugging command.

Examples:
.........

 (defun factorial (x)
   (cond ((or (not (typep x 'integer)) (minusp x))
          (error "~S is not a valid argument to FACTORIAL." x))
         ((zerop x) 1)
         (t (* x (factorial (- x 1))))))
ý FACTORIAL
(factorial 20)
ý 2432902008176640000
(factorial -1)
Ö Error: -1 is not a valid argument to FACTORIAL.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Return to Lisp Toplevel.
Ö Debug>

 (setq a 'fred)
ý FRED
 (if (numberp a) (1+ a) (error "~S is not a number." A))
Ö Error: FRED is not a number.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Return to Lisp Toplevel.
Ö Debug> :Continue 1
Ö Return to Lisp Toplevel.

 (define-condition not-a-number (error)
                   ((argument :reader not-a-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a number."
                      (not-a-number-argument condition)))))
ý NOT-A-NUMBER

 (if (numberp a) (1+ a) (error 'not-a-number :argument a))
Ö Error: FRED is not a number.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Return to Lisp Toplevel.
Ö Debug> :Continue 1
Ö Return to Lisp Toplevel.

Side Effects:
.............

Handlers for the specified condition, if any, are invoked and might
have side effects.  Program execution might stop, and the debugger
might be entered.

Affected By:
............

Existing handler bindings.

ÿ*break-on-signals*þ

Signals an error of type ÿtype-errorþ if DATUM and ARGUMENTS are not
designators for a condition

See Also:
.........

*Note cerror::, *Note signal::, *Note format::, *Note ignore-errors::,
*Note *break-on-signals*::, *Note handler-bind::, *Note Section 9.1
(Condition System Concepts): Condition System Concepts.

Notes:
......

Some implementations may provide debugger commands for interactively
returning from individual stack frames.  However, it should be possible
for the programmer to feel confident about writing code like:

 (defun wargames:no-win-scenario ()
   (if (error "pushing the button would be stupid."))
   (push-the-button))

In this scenario, there should be no chance that ÿerrorþ will return
and the button will get pushed.

While the meaning of this program is clear and it might be proven `safe'
by a formal theorem prover, such a proof is no guarantee that the
program is safe to execute.  Compilers have been known to have bugs,
computers to have signal glitches, and human beings to manually
intervene in ways that are not always possible to predict.  Those kinds
of errors, while beyond the scope of the condition system to formally
model, are not beyond the scope of things that should seriously be
considered when writing code that could have the kinds of sweeping
effects hinted at by this example.


File: chris-ansicl.info,  Node: cerror,  Next: check-type,  Prev: error (Function),  Up: Conditions

cerror (Function)
=================

Syntax:
.......

 -- Function: cerror continue-format-control datum &rest arguments ý
          ÿnilþ

Arguments and Values:
.....................

CONTINUE-FORMAT-CONTROL--a format control.

DATUM, ARGUMENTS--designators for a condition of default type
ÿsimple-errorþ.

Description:
............

ÿcerrorþ effectively invokes ÿerrorþ on the condition named by DATUM.
As with any function that implicitly calls ÿerrorþ, if the condition is
not handled, ÿ(invoke-debugger condition)þ is executed.  While
signaling is going on, and while in the debugger if it is reached, it
is possible to continue code execution (i.e., to return from ÿcerrorþ)
using the ÿcontinueþ restart.

If DATUM is a condition, ARGUMENTS can be supplied, but are used only
in conjunction with the CONTINUE-FORMAT-CONTROL.

Examples:
.........

 (defun real-sqrt (n)
   (when (minusp n)
     (setq n (- n))
     (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
   (sqrt n))

 (real-sqrt 4)
ý 2.0

 (real-sqrt -9)
Ö Correctable error in REAL-SQRT: Tried to take sqrt(-9).
Ö Restart options:
Ö  1: Return sqrt(9) instead.
Ö  2: Top level.
Ö Debug> :continue 1
ý 3.0

 (define-condition not-a-number (error)
   ((argument :reader not-a-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a number."
                      (not-a-number-argument condition)))))

 (defun assure-number (n)
   (loop (when (numberp n) (return n))
         (cerror "Enter a number."
                 'not-a-number :argument n)
         (format t "~&Type a number: ")
         (setq n (read))
         (fresh-line)))

 (assure-number 'a)
Ö Correctable error in ASSURE-NUMBER: A is not a number.
Ö Restart options:
Ö  1: Enter a number.
Ö  2: Top level.
Ö Debug> :continue 1
Ö Type a number: 1/2
ý 1/2

 (defun assure-large-number (n)
   (loop (when (and (numberp n) (> n 73)) (return n))
         (cerror "Enter a number~:[~; a bit larger than ~D~]."
                 "~*~A is not a large number."
                 (numberp n) n)
         (format t "~&Type a large number: ")
         (setq n (read))
         (fresh-line)))

 (assure-large-number 10000)
ý 10000

 (assure-large-number 'a)
Ö Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
Ö Restart options:
Ö  1: Enter a number.
Ö  2: Top level.
Ö Debug> :continue 1
Ö Type a large number: 88
ý 88

 (assure-large-number 37)
Ö Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number.
Ö Restart options:
Ö  1: Enter a number a bit larger than 37.
Ö  2: Top level.
Ö Debug> :continue 1
Ö Type a large number: 259
ý 259

 (define-condition not-a-large-number (error)
   ((argument :reader not-a-large-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a large number."
                      (not-a-large-number-argument condition)))))

 (defun assure-large-number (n)
   (loop (when (and (numberp n) (> n 73)) (return n))
         (cerror "Enter a number~3*~:[~; a bit larger than ~*~D~]."
                 'not-a-large-number
                 :argument n
                 :ignore (numberp n)
                 :ignore n
                 :allow-other-keys t)
         (format t "~&Type a large number: ")
         (setq n (read))
         (fresh-line)))


 (assure-large-number 'a)
Ö Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
Ö Restart options:
Ö  1: Enter a number.
Ö  2: Top level.
Ö Debug> :continue 1
Ö Type a large number: 88
ý 88

 (assure-large-number 37)
Ö Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
Ö Restart options:
Ö  1: Enter a number a bit larger than 37.
Ö  2: Top level.
Ö Debug> :continue 1
Ö Type a large number: 259
ý 259

Affected By:
............

ÿ*break-on-signals*þ.

Existing handler bindings.

See Also:
.........

*Note error (Function)::, *Note format::, *Note handler-bind::, *Note
*break-on-signals*::, *Note simple-type-error::

Notes:
......

If DATUM is a condition type rather than a string, the ÿformatþ
directive ÿ~*þ may be especially useful in the CONTINUE-FORMAT-CONTROL
in order to ignore the keywords in the initialization argument list.
For example:

(cerror "enter a new value to replace ~*~s"
        'not-a-number
        :argument a)


File: chris-ansicl.info,  Node: check-type,  Next: simple-error,  Prev: cerror,  Up: Conditions

check-type (Macro)
==================

Syntax:
.......

 -- Macro: check-type place typespec [STRING] ý ÿnilþ

Arguments and Values:
.....................

PLACE--a place.

TYPESPEC--a type specifier.

STRING--a string; evaluated.

Description:
............

ÿcheck-typeþ signals a correctable error of type ÿtype-errorþ if the
contents of PLACE are not of the type TYPESPEC.

ÿcheck-typeþ can return only if the ÿstore-valueþ restart is invoked,
either explicitly from a handler or implicitly as one of the options
offered by the debugger.  If the ÿstore-valueþ restart is invoked,
ÿcheck-typeþ stores the new value that is the argument to the restart
invocation (or that is prompted for interactively by the debugger) in
PLACE and starts over, checking the type of the new value and signaling
another error if it is still not of the desired type.

The first time PLACE is evaluated, it is evaluated by normal evaluation
rules.  It is later evaluated as a place if the type check fails and
the ÿstore-valueþ restart is used; see *Note Section 5.1.1.1
(Evaluation of Subforms to Places): GenRefSubFormEval.

string should be an English description of the type, starting with an
indefinite article ("a" or "an").  If string is not supplied, it is
computed automatically from TYPESPEC.  The automatically generated
message mentions PLACE, its contents, and the desired type.  An
implementation may choose to generate a somewhat differently worded
error message if it recognizes that PLACE is of a particular form, such
as one of the arguments to the function that called ÿcheck-typeþ.
string is allowed because some applications of ÿcheck-typeþ may require
a more specific description of what is wanted than can be generated
automatically from TYPESPEC.

Examples:
.........

 (setq aardvarks '(sam harry fred))
ý (SAM HARRY FRED)
 (check-type aardvarks (array * (3)))
Ö Error: The value of AARDVARKS, (SAM HARRY FRED),
Ö        is not a 3-long array.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a value to use instead.
Ö  2: Return to Lisp Toplevel.
Ö Debug> :CONTINUE 1
Ö Use Value: #(SAM FRED HARRY)
ý NIL
 aardvarks
ý #<ARRAY-T-3 13571>
 (map 'list #'identity aardvarks)
ý (SAM FRED HARRY)
 (setq aardvark-count 'foo)
ý FOO
 (check-type aardvark-count (integer 0 *) "A positive integer")
Ö Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a value to use instead.
Ö  2: Top level.
Ö Debug> :CONTINUE 2

 (defmacro define-adder (name amount)
   (check-type name (and symbol (not null)) "a name for an adder function")
   (check-type amount integer)
   `(defun ,name (x) (+ x ,amount)))

 (macroexpand '(define-adder add3 3))
ý (defun add3 (x) (+ x 3))

 (macroexpand '(define-adder 7 7))
Ö Error: The value of NAME, 7, is not a name for an adder function.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a value to use instead.
Ö  2: Top level.
Ö Debug> :Continue 1
Ö Specify a value to use instead.
Ö Type a form to be evaluated and used instead: 'ADD7
ý (defun add7 (x) (+ x 7))

 (macroexpand '(define-adder add5 something))
Ö Error: The value of AMOUNT, SOMETHING, is not an integer.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a value to use instead.
Ö  2: Top level.
Ö Debug> :Continue 1
Ö Type a form to be evaluated and used instead: 5
ý (defun add5 (x) (+ x 5))

Control is transferred to a handler.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

ÿ*break-on-signals*þ

The implementation.

See Also:
.........

*Note Section 9.1 (Condition System Concepts): Condition System
Concepts.

Notes:
......

 (check-type PLACE TYPESPEC)
 Õ (assert (typep PLACE 'TYPESPEC) (PLACE)
            'type-error :datum PLACE :expected-type 'TYPESPEC)


File: chris-ansicl.info,  Node: simple-error,  Next: invalid-method-error,  Prev: check-type,  Up: Conditions

simple-error (Condition Type)
=============================

Class Precedence List:
......................

ÿsimple-errorþ, ÿsimple-conditionþ, ÿerrorþ, ÿserious-conditionþ,
ÿconditionþ, ÿtþ

Description:
............

The type ÿsimple-errorþ consists of conditions that are signaled by
ÿerrorþ or ÿcerrorþ when a format control is supplied as the function's
first argument.


File: chris-ansicl.info,  Node: invalid-method-error,  Next: method-combination-error,  Prev: simple-error,  Up: Conditions

invalid-method-error (Function)
===============================

Syntax:
.......

 -- Function: invalid-method-error method format-control &rest args ý
          implementation-dependent

Arguments and Values:
.....................

METHOD--a method.

FORMAT-CONTROL--a format control.

ARGS--format arguments for the FORMAT-CONTROL.

Description:
............

The function ÿinvalid-method-errorþ is used to signal an error of type
ÿerrorþ when there is an applicable method whose qualifiers are not
valid for the method combination type.  The error message is
constructed by using the FORMAT-CONTROL suitable for ÿformatþ and any
ARGS to it.  Because an implementation may need to add additional
contextual information to the error message, ÿinvalid-method-errorþ
should be called only within the dynamic extent of a method combination
function.

The function ÿinvalid-method-errorþ is called automatically when a
method fails to satisfy every qualifier pattern and predicate in a
ÿdefine-method-combinationþ form.  A method combination function that
imposes additional restrictions should call ÿinvalid-method-errorþ
explicitly if it encounters a method it cannot accept.

Whether ÿinvalid-method-errorþ returns to its caller or exits via
ÿthrowþ is implementation-dependent.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

ÿ*break-on-signals*þ

See Also:
.........

*Note define-method-combination::


File: chris-ansicl.info,  Node: method-combination-error,  Next: signal,  Prev: invalid-method-error,  Up: Conditions

method-combination-error (Function)
===================================

Syntax:
.......

 -- Function: method-combination-error format-control &rest args ý
          implementation-dependent

Arguments and Values:
.....................

FORMAT-CONTROL--a format control.

ARGS--format arguments for FORMAT-CONTROL.

Description:
............

The function ÿmethod-combination-errorþ is used to signal an error in
method combination.

The error message is constructed by using a FORMAT-CONTROL suitable for
ÿformatþ and any ARGS to it.  Because an implementation may need to add
additional contextual information to the error message,
ÿmethod-combination-errorþ should be called only within the dynamic
extent of a method combination function.

Whether ÿmethod-combination-errorþ returns to its caller or exits via
ÿthrowþ is implementation-dependent.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

ÿ*break-on-signals*þ

See Also:
.........

*Note define-method-combination::


File: chris-ansicl.info,  Node: signal,  Next: simple-condition,  Prev: method-combination-error,  Up: Conditions

signal (Function)
=================

Syntax:
.......

 -- Function: signal datum &rest arguments ý ÿnilþ

Arguments and Values:
.....................

DATUM, ARGUMENTS--designators for a condition of default type
ÿsimple-conditionþ.

Description:
............

Signals the condition denoted by the given DATUM and ARGUMENTS.  If the
condition is not handled, ÿsignalþ returns ÿnilþ.

Examples:
.........

 (defun handle-division-conditions (condition)
   (format t "Considering condition for division condition handling~%")
   (when (and (typep condition 'arithmetic-error)
              (eq '/ (arithmetic-error-operation condition)))
     (invoke-debugger condition)))
HANDLE-DIVISION-CONDITIONS
 (defun handle-other-arithmetic-errors (condition)
   (format t "Considering condition for arithmetic condition handling~%")
   (when (typep condition 'arithmetic-error)
     (abort)))
HANDLE-OTHER-ARITHMETIC-ERRORS
 (define-condition a-condition-with-no-handler (condition) ())
A-CONDITION-WITH-NO-HANDLER
 (signal 'a-condition-with-no-handler)
NIL
 (handler-bind ((condition #'handle-division-conditions)
                  (condition #'handle-other-arithmetic-errors))
   (signal 'a-condition-with-no-handler))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
NIL
 (handler-bind ((arithmetic-error #'handle-division-conditions)
                  (arithmetic-error #'handle-other-arithmetic-errors))
   (signal 'arithmetic-error :operation '* :operands '(1.2 b)))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
Back to Lisp Toplevel

Side Effects:
.............

The debugger might be entered due to ÿ*break-on-signals*þ.

Handlers for the condition being signaled might transfer control.

Affected By:
............

Existing handler bindings.

ÿ*break-on-signals*þ

See Also:
.........

*Note *break-on-signals*::, *Note error (Function)::, *Note
simple-condition::, *Note Section 9.1.4 (Signaling and Handling
Conditions): Signaling and Handling Conditions.

Notes:
......

If ÿ(typep DATUM *break-on-signals*)þ yields true, the debugger is
entered prior to beginning the signaling process.  the ÿcontinueþ
restart can be used to continue with the signaling process.  This is
also true for all other functions and macros that should, might, or
must signal conditions.


File: chris-ansicl.info,  Node: simple-condition,  Next: simple-condition-format-control; simple-condition-format-arguments,  Prev: signal,  Up: Conditions

simple-condition (Condition Type)
=================================

Class Precedence List:
......................

ÿsimple-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿsimple-conditionþ represents conditions that are signaled by
ÿsignalþ whenever a FORMAT-CONTROL is supplied as the function's first
argument.  The format control and format arguments are initialized with
the initialization arguments named :format-control and
:format-arguments to ÿmake-conditionþ, and are accessed by the functions
ÿsimple-condition-format-controlþ and
ÿsimple-condition-format-argumentsþ.  If format arguments are not
supplied to ÿmake-conditionþ, ÿnilþ is used as a default.

See Also:
.........

*Note simple-condition-format-control::, *Note
simple-condition-format-arguments::


File: chris-ansicl.info,  Node: simple-condition-format-control; simple-condition-format-arguments,  Next: warn,  Prev: simple-condition,  Up: Conditions

simple-condition-format-control, simple-condition-format-arguments (Function)
=============================================================================

Syntax:
.......

 -- Function: simple-condition-format-control condition ý format-control

 -- Function: simple-condition-format-arguments condition ý
          format-arguments

Arguments and Values:
.....................

CONDITION--a condition of type ÿsimple-conditionþ.

FORMAT-CONTROL--a format control.

FORMAT-ARGUMENTS--a list.

Description:
............

ÿsimple-condition-format-controlþ returns the format control needed to
process the CONDITION's format arguments.

ÿsimple-condition-format-argumentsþ returns a list of format arguments
needed to process the CONDITION's format control.

Examples:
.........

 (setq foo (make-condition 'simple-condition
                          :format-control "Hi ~S"
                          :format-arguments '(ho)))
ý #<SIMPLE-CONDITION 26223553>
 (apply #'format nil (simple-condition-format-control foo)
                     (simple-condition-format-arguments foo))
ý "Hi HO"

See Also:
.........

*Note simple-condition::, *Note Section 9.1 (Condition System
Concepts): Condition System Concepts.


File: chris-ansicl.info,  Node: warn,  Next: simple-warning,  Prev: simple-condition-format-control; simple-condition-format-arguments,  Up: Conditions

warn (Function)
===============

Syntax:
.......

 -- Function: warn datum &rest arguments ý ÿnilþ

Arguments and Values:
.....................

DATUM, ARGUMENTS--designators for a condition of default type
ÿsimple-warningþ.

Description:
............

Signals a condition of type ÿwarningþ.  If the condition is not handled,
reports the condition to error output.

The precise mechanism for warning is as follows:

The warning condition is signaled
     While the ÿwarningþ condition is being signaled, the
     ÿmuffle-warningþ restart is established for use by a handler.  If
     invoked, this restart bypasses further action by ÿwarnþ, which in
     turn causes ÿwarnþ to immediately return ÿnilþ.

If no handler for the warning condition is found
     If no handlers for the warning condition are found, or if all such
     handlers decline, then the condition is reported to error output
     by ÿwarnþ in an implementation-dependent format.

ÿnilþ is returned
     The value returned by ÿwarnþ if it returns is ÿnilþ.

Examples:
.........

  (defun foo (x)
    (let ((result (* x 2)))
      (if (not (typep result 'fixnum))
          (warn "You're using very big numbers."))
      result))
ý FOO

  (foo 3)
ý 6

  (foo most-positive-fixnum)
Ö Warning: You're using very big numbers.
ý 4294967294

  (setq *break-on-signals* t)
ý T

  (foo most-positive-fixnum)
Ö Break: Caveat emptor.
Ö To continue, type :CONTINUE followed by an option number.
Ö  1: Return from Break.
Ö  2: Abort to Lisp Toplevel.
Ö Debug> :continue 1
Ö Warning: You're using very big numbers.
ý 4294967294

Side Effects:
.............

A warning is issued.  The debugger might be entered.

Affected By:
............

Existing handler bindings.

ÿ*break-on-signals*þ, ÿ*error-output*þ.

Exceptional Situations:
.......................

If DATUM is a condition and if the condition is not of type ÿwarningþ,
or ARGUMENTS is non-nil, an error of type ÿtype-errorþ is signaled.

If DATUM is a condition type, the result of ÿ(apply #'make-condition
datum arguments)þ must be of type ÿwarningþ or an error of type
ÿtype-errorþ is signaled.

See Also:
.........

*Note *break-on-signals*::, *Note muffle-warning::, *Note signal::


File: chris-ansicl.info,  Node: simple-warning,  Next: invoke-debugger,  Prev: warn,  Up: Conditions

simple-warning (Condition Type)
===============================

Class Precedence List:
......................

ÿsimple-warningþ, ÿsimple-conditionþ, ÿwarningþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿsimple-warningþ represents conditions that are signaled by
ÿwarnþ whenever a format control is supplied as the function's first
argument.


File: chris-ansicl.info,  Node: invoke-debugger,  Next: break,  Prev: simple-warning,  Up: Conditions

invoke-debugger (Function)
==========================

Syntax:
.......

 -- Function: invoke-debugger condition ý|

Arguments and Values:
.....................

CONDITION--a condition object.

Description:
............

ÿinvoke-debuggerþ attempts to enter the debugger with CONDITION.

If ÿ*debugger-hook*þ is not ÿnilþ, it should be a function (or the name
of a function) to be called prior to entry to the standard debugger.
The function is called with ÿ*debugger-hook*þ bound to ÿnilþ, and the
function must accept two arguments: the CONDITION and the value of
ÿ*debugger-hook*þ prior to binding it to ÿnilþ.  If the function
returns normally, the standard debugger is entered.

The standard debugger never directly returns.  Return can occur only by
a non-local transfer of control, such as the use of a restart function.

Examples:
.........

 (ignore-errors ;Normally, this would suppress debugger entry
   (handler-bind ((error #'invoke-debugger)) ;But this forces debugger entry
     (error "Foo.")))
Debug: Foo.
To continue, type :CONTINUE followed by an option number:
 1: Return to Lisp Toplevel.
Debug>

Side Effects:
.............

ÿ*debugger-hook*þ is bound to ÿnilþ, program execution is discontinued,
and the debugger is entered.

Affected By:
............

ÿ*debug-io*þ and ÿ*debugger-hook*þ.

See Also:
.........

*Note error (Function)::, *Note break::


File: chris-ansicl.info,  Node: break,  Next: *debugger-hook*,  Prev: invoke-debugger,  Up: Conditions

break (Function)
================

Syntax:
.......

 -- Function: break &optional format-control &rest format-arguments ý
          ÿnilþ

Arguments and Values:
.....................

FORMAT-CONTROL--a format control.  The default is
implementation-dependent.

FORMAT-ARGUMENTS--format arguments for the FORMAT-CONTROL.

Description:
............

ÿbreakþ formats FORMAT-CONTROL and FORMAT-ARGUMENTS and then goes
directly into the debugger without allowing any possibility of
interception by programmed error-handling facilities.

If the ÿcontinueþ restart is used while in the debugger, ÿbreakþ
immediately returns ÿnilþ without taking any unusual recovery action.

ÿbreakþ binds ÿ*debugger-hook*þ to ÿnilþ  before attempting to enter
the debugger.

Examples:
.........

 (break "You got here with arguments: ~:S." '(FOO 37 A))
Ö BREAK: You got here with these arguments: FOO, 37, A.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Return from BREAK.
Ö  2: Top level.
Ö Debug> :CONTINUE 1
Ö Return from BREAK.
ý NIL

Side Effects:
.............

The debugger is entered.

Affected By:
............

ÿ*debug-io*þ.

See Also:
.........

*Note error (Function)::, *Note invoke-debugger::.

Notes:
......

ÿbreakþ is used as a way of inserting temporary debugging "breakpoints"
in a program, not as a way of signaling errors.  For this reason,
ÿbreakþ does not take the CONTINUE-FORMAT-CONTROL argument that
ÿcerrorþ takes.  This and the lack of any possibility of interception by
condition handling are the only program-visible differences between
ÿbreakþ and ÿcerrorþ.

The user interface aspects of ÿbreakþ and ÿcerrorþ are permitted to
vary more widely, in order to accomodate the interface needs of the
implementation. For example, it is permissible for a Lisp
read-eval-print loop to be entered by ÿbreakþ rather than the
conventional debugger.

ÿbreakþ could be defined by:

 (defun break (&optional (format-control "Break") &rest format-arguments)
   (with-simple-restart (continue "Return from BREAK.")
     (let ((*debugger-hook* nil))
       (invoke-debugger
           (make-condition 'simple-condition
                           :format-control format-control
                           :format-arguments format-arguments))))
   nil)


File: chris-ansicl.info,  Node: *debugger-hook*,  Next: *break-on-signals*,  Prev: break,  Up: Conditions

*debugger-hook* (Variable)
==========================

Value Type:
...........

a designator for a function of two arguments (a condition and the value
of ÿ*debugger-hook*þ at the time the debugger was entered), or ÿnilþ.

Initial Value:
..............

ÿnilþ.

Description:
............

When the value of ÿ*debugger-hook*þ is non-nil, it is called prior to
normal entry into the debugger, either due to a call to
ÿinvoke-debuggerþ or due to automatic entry into the debugger from a
call to ÿerrorþ or ÿcerrorþ with a condition that is not handled.  The
function may either handle the condition (transfer control) or return
normally (allowing the standard debugger to run).  To minimize
recursive errors while debugging, ÿ*debugger-hook*þ is bound to
ÿnilþ by ÿinvoke-debuggerþ prior to calling the function.

Examples:
.........

 (defun one-of (choices &optional (prompt "Choice"))
   (let ((n (length choices)) (i))
     (do ((c choices (cdr c)) (i 1 (+ i 1)))
         ((null c))
       (format t "~&[~D] ~A~%" i (car c)))
     (do () ((typep i `(integer 1 ,n)))
       (format t "~&~A: " prompt)
       (setq i (read))
       (fresh-line))
     (nth (- i 1) choices)))

 (defun my-debugger (condition me-or-my-encapsulation)
   (format t "~&Fooey: ~A" condition)
   (let ((restart (one-of (compute-restarts))))
     (if (not restart) (error "My debugger got an error."))
     (let ((*debugger-hook* me-or-my-encapsulation))
       (invoke-restart-interactively restart))))

 (let ((*debugger-hook* #'my-debugger))
   (+ 3 'a))
Ö Fooey: The argument to +, A, is not a number.
Ö  [1] Supply a replacement for A.
Ö  [2] Return to Cloe Toplevel.
Ö Choice: 1
Ö  Form to evaluate and use: (+ 5 'b)
Ö  Fooey: The argument to +, B, is not a number.
Ö  [1] Supply a replacement for B.
Ö  [2] Supply a replacement for A.
Ö  [3] Return to Cloe Toplevel.
Ö Choice: 1
Ö  Form to evaluate and use: 1
ý 9

Affected By:
............

ÿinvoke-debuggerþ

Notes:
......

When evaluating code typed in by the user interactively, it is sometimes
useful to have the hook function bind ÿ*debugger-hook*þ to the function
that was its second argument so that recursive errors can be handled
using the same interactive facility.


File: chris-ansicl.info,  Node: *break-on-signals*,  Next: handler-bind,  Prev: *debugger-hook*,  Up: Conditions

*break-on-signals* (Variable)
=============================

Value Type:
...........

a type specifier.

Initial Value:
..............

ÿnilþ.

Description:
............

When ÿ(typep condition *break-on-signals*)þ returns true, calls to
ÿsignalþ, and to other operators such as ÿerrorþ that implicitly call
ÿsignalþ, enter the debugger prior to signaling the condition.

the ÿcontinueþ restart can be used to continue with the normal
signaling process when a break occurs process due to
ÿ*break-on-signals*þ.

Examples:
.........

 *break-on-signals* ý NIL
 (ignore-errors (error 'simple-error :format-control "Fooey!"))
ý NIL, #<SIMPLE-ERROR 32207172>

 (let ((*break-on-signals* 'error))
   (ignore-errors (error 'simple-error :format-control "Fooey!")))
Ö Break: Fooey!
Ö BREAK entered because of *BREAK-ON-SIGNALS*.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Continue to signal.
Ö  2: Top level.
Ö Debug> :CONTINUE 1
Ö Continue to signal.
ý NIL, #<SIMPLE-ERROR 32212257>

 (let ((*break-on-signals* 'error))
   (error 'simple-error :format-control "Fooey!"))
Ö Break: Fooey!
Ö BREAK entered because of *BREAK-ON-SIGNALS*.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Continue to signal.
Ö  2: Top level.
Ö Debug> :CONTINUE 1
Ö Continue to signal.
Ö Error: Fooey!
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Top level.
Ö Debug> :CONTINUE 1
Ö Top level.

See Also:
.........

*Note break::, *Note signal::, *Note warn::, *Note error (Function)::,
*Note typep::, *Note Section 9.1 (Condition System Concepts): Condition
System Concepts.

Notes:
......

ÿ*break-on-signals*þ is intended primarily for use in debugging code
that does signaling.   When setting ÿ*break-on-signals*þ, the user is
encouraged to choose the most restrictive specification that suffices.
Setting ÿ*break-on-signals*þ effectively violates the modular handling
of condition signaling.  In practice, the complete effect of setting
ÿ*break-on-signals*þ might be unpredictable in some cases since the user
might not be aware of the variety or number of calls to ÿsignalþ that
are used in code called only incidentally.

ÿ*break-on-signals*þ enables an early entry to the debugger but such an
entry does not preclude an additional entry to the debugger in the case
of operations such as ÿerrorþ and ÿcerrorþ.


File: chris-ansicl.info,  Node: handler-bind,  Next: handler-case,  Prev: *break-on-signals*,  Up: Conditions

handler-bind (Macro)
====================

Syntax:
.......

 -- Macro: handler-bind ({ûbinding}*) {form}* ý {result}*

BINDING::=
     (type handler)

Arguments and Values:
.....................

TYPE--a type specifier.

HANDLER--a form; evaluated to produce a HANDLER-FUNCTION.

HANDLER-FUNCTION--a designator for a function of one argument.

FORMS--an implicit progn.

RESULTS--the values returned by the forms.

Description:
............

Executes FORMS in a dynamic environment where the indicated HANDLER
bindings are in effect.

Each HANDLER should evaluate to a handler-function, which is used to
handle conditions of the given TYPE during execution of the FORMS.
This function should take a single argument, the condition being
signaled.

If more than one HANDLER binding is supplied, the HANDLER bindings are
searched sequentially from top to bottom in search of a match (by
visual analogy with ÿtypecaseþ).  If an appropriate type is found, the
associated handler is run in a dynamic environment where none of these
HANDLER bindings are visible (to avoid recursive errors).  If the
handler declines, the search continues for another handler.

If no appropriate handler is found, other handlers are sought from
dynamically enclosing contours.  If no handler is found outside, then
ÿsignalþ returns or ÿerrorþ enters the debugger.

Examples:
.........

In the following code, if an unbound variable error is signaled in the
body (and not handled by an intervening handler), the first function is
called.

 (handler-bind ((unbound-variable #'(lambda ...))
                (error #'(lambda ...)))
   ...)

If any other kind of error is signaled, the second function is called.
In either case, neither handler is active while executing the code in
the associated function.

 (defun trap-error-handler (condition)
   (format *error-output* "~&~A~&" condition)
   (throw 'trap-errors nil))

 (defmacro trap-errors (&rest forms)
   `(catch 'trap-errors
      (handler-bind ((error #'trap-error-handler))
        ,@forms)))

 (list (trap-errors (signal "Foo.") 1)
       (trap-errors (error  "Bar.") 2)
       (+ 1 2))
Ö Bar.
ý (1 NIL 3)

Note that "Foo." is not printed because the condition made by ÿsignalþ
is a simple condition, which is not of type ÿerrorþ, so it doesn't
trigger the handler for ÿerrorþ set up by ÿtrap-errorsþ.

See Also:
.........

*Note handler-case::


File: chris-ansicl.info,  Node: handler-case,  Next: ignore-errors,  Prev: handler-bind,  Up: Conditions

handler-case (Macro)
====================

Syntax:
.......

 -- Macro: handler-case EXPRESSION ù{ûerror-clause}* |
          ûno-error-clauseø ý {result}*

CLAUSE::=
     ûerror-clause | ûno-error-clause

ERROR-CLAUSE::=
     (typespec ([var]) {declaration}* {form}*)

NO-ERROR-CLAUSE::=
     (:no-error LAMBDA-LIST {declaration}* {form}*)

Arguments and Values:
.....................

EXPRESSION--a form.

TYPESPEC--a type specifier.

VAR--a variable name.

LAMBDA-LIST--an ordinary lambda list.

DECLARATION--a declare expression; not evaluated.

FORM--a form.

RESULTS--In the normal situation, the values returned are those that
result from the evaluation of EXPRESSION; in the exceptional situation
when control is transferred to a CLAUSE, the value of the last FORM in
that CLAUSE is returned.

Description:
............

ÿhandler-caseþ executes EXPRESSION in a dynamic environment where
various handlers are active.  Each error-clause specifies how to handle
a condition matching the indicated TYPESPEC.  A no-error-clause allows
the specification of a particular action if control returns normally.

If a condition is signaled for which there is an appropriate
error-clause during the execution of EXPRESSION (i.e., one for which
ÿ(typep condition 'TYPESPEC)þ returns true) and if there is no
intervening handler for a condition of that type, then control is
transferred to the body of the relevant error-clause.  In this case, the
dynamic state is unwound appropriately (so that the handlers established
around the EXPRESSION are no longer active), and VAR is bound to the
condition that had been signaled.  If more than one case is provided,
those cases are made accessible in parallel.  That is, in

  (handler-case form
    (typespec1 (var1) form1)
    (typespec2 (var2) form2))

if the first clause (containing form1) has been selected, the handler
for the second is no longer visible (or vice versa).

The clauses are searched sequentially from top to bottom. If there is
type overlap between TYPESPECS, the earlier of the clauses is selected.

If VAR is not needed, it can be omitted. That is, a clause such as:

  (TYPESPEC (VAR) (declare (ignore VAR)) FORM)

can be written ÿ(TYPESPEC () FORM)þ.

If there are no FORMS in a selected clause, the case, and therefore
ÿhandler-caseþ, returns ÿnilþ.  If execution of EXPRESSION returns
normally and no no-error-clause exists, the values returned by
EXPRESSION are returned by ÿhandler-caseþ.  If execution of EXPRESSION
returns normally and a no-error-clause does exist, the values returned
are used as arguments to the function described by constructing
ÿ(lambda LAMBDA-LIST {form}*)þ from the no-error-clause, and the values
of that function call are returned by ÿhandler-caseþ.  The handlers
which were established around the EXPRESSION are no longer active at
the time of this call.

Examples:
.........

 (defun assess-condition (condition)
   (handler-case (signal condition)
     (warning () "Lots of smoke, but no fire.")
     ((or arithmetic-error control-error cell-error stream-error)
        (condition)
       (format nil "~S looks especially bad." condition))
     (serious-condition (condition)
       (format nil "~S looks serious." condition))
     (condition () "Hardly worth mentioning.")))
ý ASSESS-CONDITION
 (assess-condition (make-condition 'stream-error :stream *terminal-io*))
ý "#<STREAM-ERROR 12352256> looks especially bad."
 (define-condition random-condition (condition) ()
   (:report (lambda (condition stream)
              (declare (ignore condition))
              (princ "Yow" stream))))
ý RANDOM-CONDITION
 (assess-condition (make-condition 'random-condition))
ý "Hardly worth mentioning."

See Also:
.........

*Note handler-bind::, *Note ignore-errors::, *Note Section 9.1
(Condition System Concepts): Condition System Concepts.

Notes:
......

 (handler-case form
   (type1 (var1) . body1)
   (type2 (var2) . body2) ...)

is approximately equivalent to:

 (block #1=#:g0001
   (let ((#2=#:g0002 nil))
     (tagbody
       (handler-bind ((type1 #'(lambda (temp)
                                       (setq #1# temp)
                                       (go #3=#:g0003)))
                      (type2 #'(lambda (temp)
                                       (setq #2# temp)
                                       (go #4=#:g0004))) ...)
       (return-from #1# form))
         #3# (return-from #1# (let ((var1 #2#)) . body1))
         #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))

 (handler-case form
   (type1 (var1) . body1)
   ...
   (:no-error (varN-1 varN-2 ...) . bodyN))

is approximately equivalent to:


 (block #1=#:error-return
  (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)
     (block #2=#:normal-return
       (return-from #1#
         (handler-case (return-from #2# form)
           (type1 (var1) . body1) ...)))))


File: chris-ansicl.info,  Node: ignore-errors,  Next: define-condition,  Prev: handler-case,  Up: Conditions

ignore-errors (Macro)
=====================

Syntax:
.......

 -- Macro: ignore-errors {form}* ý {result}*

Arguments and Values:
.....................

FORMS--an implicit progn.

RESULTS--In the normal situation, the values of the forms are returned;
in the exceptional situation, two values are returned: ÿnilþ and the
condition.

Description:
............

ÿignore-errorsþ is used to prevent conditions of type ÿerrorþ from
causing entry into the debugger.

Specifically, ÿignore-errorsþ executes forms in a dynamic environment
where a handler for conditions of type ÿerrorþ has been established; if
invoked, it handles such conditions by returning two values, ÿnilþ and
the condition that was signaled, from the ÿignore-errorsþ form.

If a normal return from the forms occurs, any values returned are
returned by ÿignore-errorsþ.

Examples:
.........

 (defun load-init-file (program)
   (let ((win nil))
     (ignore-errors ;if this fails, don't enter debugger
       (load (merge-pathnames (make-pathname :name program :type :lisp)
                              (user-homedir-pathname)))
       (setq win t))
     (unless win (format t "~&Init file failed to load.~%"))
     win))

 (load-init-file "no-such-program")
Ö Init file failed to load.
NIL

See Also:
.........

*Note handler-case::, *Note Section 9.1 (Condition System Concepts):
Condition System Concepts.

Notes:
......

 (ignore-errors . forms)

is equivalent to:

 (handler-case (progn . forms)
   (error (condition) (values nil condition)))

Because the second return value is a condition in the exceptional case,
it is common (but not required) to arrange for the second return value
in the normal case to be missing or ÿnilþ so that the two situations
can be distinguished.


File: chris-ansicl.info,  Node: define-condition,  Next: make-condition,  Prev: ignore-errors,  Up: Conditions

define-condition (Macro)
========================

Syntax:
.......

 -- Macro: define-condition name ({parent-type}*) ({ûslot-spec}*)
          {option}* ý name

SLOT-SPEC::=
     slot-name | (slot-name ûslot-option)

SLOT-OPTION::=
     ù {:reader symbol}* |
     {:writer ûfunction-name}* |
     {:accessor symbol}* |
     {:allocation ûallocation-type} |
     {:initarg symbol}* |
     {:initform form} |
     {:type TYPE-SPECIFIER} ø

OPTION::=
     ù (:default-initargs ÿ.þ INITARG-LIST) |
     (:documentation string) |
     (:report report-name) ø

FUNCTION-NAME::=
     {symbol | ÿ(setf symbol)þ}

ALLOCATION-TYPE::=
     :instance | :class

REPORT-NAME::=
     string | symbol | lambda expression

Arguments and Values:
.....................

NAME--a symbol.

PARENT-TYPE--a symbol naming a condition type.  If no PARENT-TYPES are
supplied, the PARENT-TYPES default to ÿ(condition)þ.

DEFAULT-INITARGS--a list of keyword/value pairs.

SLOT-SPEC--the name of a slot or a list consisting of the SLOT-NAME
followed by zero or more SLOT-OPTIONS.

SLOT-NAME--a slot name (a symbol), the list of a slot name, or the list
of slot name/slot form pairs.

OPTION--Any of the following:

:reader
     :reader can be supplied more than once for a given slot and cannot
     be ÿnilþ.

:writer
     :writer can be supplied more than once for a given slot and must
     name a generic function.

:accessor
     :accessor can be supplied more than once for a given slot and
     cannot be ÿnilþ.

:allocation
     :allocation can be supplied once at most for a given slot.  The
     default if :allocation is not supplied is :instance.

:initarg
     :initarg can be supplied more than once for a given slot.

:initform
     :initform can be supplied once at most for a given slot.

:type
     :type can be supplied once at most for a given slot.

:documentation
     :documentation can be supplied once at most for a given slot.

:report
     :report can be supplied once at most.

Description:
............

ÿdefine-conditionþ defines a new condition type called NAME, which is a
subtype of the type or types named by PARENT-TYPE.  Each PARENT-TYPE
argument specifies a direct supertype of the new condition. The new
condition inherits slots and methods from each of its direct
supertypes, and so on.

If a slot name/slot form pair is supplied, the slot form is a form that
can be evaluated by ÿmake-conditionþ to produce a default value when an
explicit value is not provided.  If no slot form is supplied, the
contents of the SLOT is initialized in an implementation-dependent way.

If the type being defined and some other type from which it inherits
have a slot by the same name, only one slot is allocated in the
condition, but the supplied slot form overrides any slot form that
might otherwise have been inherited from a PARENT-TYPE.  If no slot
form is supplied, the inherited slot form (if any) is still visible.

Accessors are created according to the same rules as used by ÿdefclassþ.

A description of SLOT-OPTIONS follows:

:reader
     The :reader slot option specifies that an unqualified method is to
     be defined on the generic function named by the argument to
     :reader to read the value of the given slot.

*
     The :initform slot option is used to provide a default initial
     value form to be used in the initialization of the slot.  This
     form is evaluated every time it is used to initialize the slot.
     The lexical environment in which this form is evaluated is the
     lexical environment in which the ÿdefine-conditionþ form was
     evaluated.  Note that the lexical environment refers both to
     variables and to functions.  For local slots, the dynamic
     environment is the dynamic environment in which ÿmake-conditionþ
     was called; for shared slots, the dynamic environment is the
     dynamic environment in which the ÿdefine-conditionþ form was
     evaluated.

     No implementation is permitted to extend the syntax of
     ÿdefine-conditionþ to allow ÿ(SLOT-NAME FORM)þ as an abbreviation
     for ÿ(SLOT-NAME :initform FORM)þ.

:initarg
     The :initarg slot option declares an initialization argument named
     by its symbol argument and specifies that this initialization
     argument initializes the given slot.  If the initialization
     argument has a value in the call to ÿinitialize-instanceþ, the
     value is stored into the given slot, and the slot's :initform slot
     option, if any, is not evaluated.  If none of the initialization
     arguments specified for a given slot has a value, the slot is
     initialized according to the :initform slot option, if specified.

:type
     The :type slot option specifies that the contents of the slot is
     always of the specified type.  It effectively declares the result
     type of the reader generic function when applied to an object of
     this condition type.  The consequences of attempting to store in a
     slot a value that does not satisfy the type of the slot is
     undefined.

:default-initargs
     This option is treated the same as it would be ÿdefclassþ.

:documentation
     The :documentation slot option provides a documentation string for
     the slot.

:report
     Condition reporting is mediated through the ÿprint-objectþ method
     for the condition type in question, with ÿ*print-escape*þ always
     being ÿnilþ. Specifying ÿ(:report REPORT-NAME)þ in the definition
     of a condition type ÿCþ is equivalent to:

      (defmethod print-object ((x c) stream)
        (if *print-escape* (call-next-method) (REPORT-NAME x stream)))

     If the value supplied by the argument to :report (REPORT-NAME) is
     a symbol or a lambda expression, it must be acceptable to
     ÿfunctionþ. ÿ(function REPORT-NAME)þ is evaluated in the current
     lexical environment.  It should return a function of two
     arguments, a condition and a stream, that prints on the stream a
     description of the condition.  This function is called whenever the
     condition is printed while ÿ*print-escape*þ is ÿnilþ.

     If REPORT-NAME is a string, it is a shorthand for

      (lambda (condition stream)
        (declare (ignore condition))
        (write-string REPORT-NAME stream))

     This option is processed after the new condition type has been
     defined, so use of the SLOT accessors within the :report function
     is permitted.  If this option is not supplied, information about
     how to report this type of condition is inherited from the
     PARENT-TYPE.

The consequences are unspecifed if an attempt is made to read a SLOT
that has not been explicitly initialized and that has not been given a
default value.

The consequences are unspecified if an attempt is made to assign the
SLOTS by using ÿsetfþ.

If a ÿdefine-conditionþ form appears as a top level form, the compiler
must make NAME recognizable as a valid type name, and it must be
possible to reference the condition type as the PARENT-TYPE of another
condition type in a subsequent ÿdefine-conditionþ form in the file
being compiled.

Examples:
.........

The following form defines a condition of type ÿpeg/hole-mismatchþ
which inherits from a condition type called ÿblocks-world-errorþ:

(define-condition peg/hole-mismatch
                  (blocks-world-error)
                  ((peg-shape  :initarg :peg-shape
                               :reader peg/hole-mismatch-peg-shape)
                   (hole-shape :initarg :hole-shape
                               :reader peg/hole-mismatch-hole-shape))
  (:report (lambda (condition stream)
             (format stream "A ~A peg cannot go in a ~A hole."
                     (peg/hole-mismatch-peg-shape  condition)
                     (peg/hole-mismatch-hole-shape condition)))))

The new type has slots ÿpeg-shapeþ and ÿhole-shapeþ, so
ÿmake-conditionþ accepts ÿ:peg-shapeþ and ÿ:hole-shapeþ keywords.  The
readers ÿpeg/hole-mismatch-peg-shapeþ and ÿpeg/hole-mismatch-hole-shapeþ
apply to objects of this type, as illustrated in the :report
information.

The following form defines a condition type named ÿmachine-errorþ which
inherits from ÿerrorþ:

(define-condition machine-error
                  (error)
                  ((machine-name :initarg :machine-name
                                 :reader machine-error-machine-name))
  (:report (lambda (condition stream)
             (format stream "There is a problem with ~A."
                     (machine-error-machine-name condition)))))

Building on this definition, a new error condition can be defined which
is a subtype of ÿmachine-errorþ for use when machines are not available:

(define-condition machine-not-available-error (machine-error) ()
  (:report (lambda (condition stream)
             (format stream "The machine ~A is not available."
                     (machine-error-machine-name condition)))))

This defines a still more specific condition, built upon
ÿmachine-not-available-errorþ, which provides a slot initialization form
for ÿmachine-nameþ but which does not provide any new slots or report
information.  It just gives the ÿmachine-nameþ slot a default
initialization:

(define-condition my-favorite-machine-not-available-error
                  (machine-not-available-error)
  ((machine-name :initform "mc.lcs.mit.edu")))

Note that since no :report clause was given, the information inherited
from ÿmachine-not-available-errorþ is used to report this type of
condition.

 (define-condition ate-too-much (error)
     ((person :initarg :person :reader ate-too-much-person)
      (weight :initarg :weight :reader ate-too-much-weight)
      (kind-of-food :initarg :kind-of-food
                    :reader :ate-too-much-kind-of-food)))
ý ATE-TOO-MUCH
 (define-condition ate-too-much-ice-cream (ate-too-much)
   ((kind-of-food :initform 'ice-cream)
    (flavor       :initarg :flavor
                  :reader ate-too-much-ice-cream-flavor
                  :initform 'vanilla ))
   (:report (lambda (condition stream)
              (format stream "~A ate too much ~A ice-cream"
                      (ate-too-much-person condition)
                      (ate-too-much-ice-cream-flavor condition)))))
ý ATE-TOO-MUCH-ICE-CREAM
 (make-condition 'ate-too-much-ice-cream
                 :person 'fred
                 :weight 300
                 :flavor 'chocolate)
ý #<ATE-TOO-MUCH-ICE-CREAM 32236101>
 (format t "~A" *)
Ö FRED ate too much CHOCOLATE ice-cream
ý NIL

See Also:
.........

*Note make-condition::, *Note defclass::, *Note Section 9.1 (Condition
System Concepts): Condition System Concepts.


File: chris-ansicl.info,  Node: make-condition,  Next: restart,  Prev: define-condition,  Up: Conditions

make-condition (Function)
=========================

Syntax:
.......

 -- Function: make-condition type &rest slot-initializations ý condition

Arguments and Values:
.....................

TYPE--a type specifier (for a subtype of ÿconditionþ).

SLOT-INITIALIZATIONS--an initialization argument list.

CONDITION--a condition.

Description:
............

Constructs and returns a condition of type TYPE using
SLOT-INITIALIZATIONS for the initial values of the slots.  The newly
created condition is returned.

Examples:
.........

 (defvar *oops-count* 0)

 (setq a (make-condition 'simple-error
                         :format-control "This is your ~:R error."
                         :format-arguments (list (incf *oops-count*))))
ý #<SIMPLE-ERROR 32245104>

 (format t "~&~A~%" a)
Ö This is your first error.
ý NIL

 (error a)
Ö Error: This is your first error.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Return to Lisp Toplevel.
Ö Debug>

Affected By:
............

The set of defined condition types.

See Also:
.........

*Note define-condition::, *Note Section 9.1 (Condition System
Concepts): Condition System Concepts.


File: chris-ansicl.info,  Node: restart,  Next: compute-restarts,  Prev: make-condition,  Up: Conditions

restart (System Class)
======================

Class Precedence List:
......................

ÿrestartþ, ÿtþ

Description:
............

An object of type ÿrestartþ represents a function that can be called to
perform some form of recovery action, usually a transfer of control to
an outer point in the running program.

An implementation is free to implement a restart in whatever manner is
most convenient; a restart has only dynamic extent relative to the
scope of the binding form which establishes it.


File: chris-ansicl.info,  Node: compute-restarts,  Next: find-restart,  Prev: restart,  Up: Conditions

compute-restarts (Function)
===========================

Syntax:
.......

 -- Function: compute-restarts &optional condition ý restarts

Arguments and Values:
.....................

CONDITION--a condition object, or ÿnilþ.

RESTARTS--a list of restarts.

Description:
............

ÿcompute-restartsþ uses the dynamic state of the program to compute a
list of the restarts which are currently active.

The resulting list is ordered so that the innermost (more-recently
established) restarts are nearer the head of the list.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated
with any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ÿnilþ, all restarts are
considered.

ÿcompute-restartsþ returns all applicable restarts, including anonymous
ones, even if some of them have the same name as others and would
therefore not be found by ÿfind-restartþ when given a symbol argument.

Implementations are permitted, but not required, to return distinct
lists from repeated calls to ÿcompute-restartsþ while in the same
dynamic environment.  The consequences are undefined if the list
returned by ÿcompute-restartsþ is every modified.

Examples:
.........

 ;; One possible way in which an interactive debugger might present
 ;; restarts to the user.
 (defun invoke-a-restart ()
   (let ((restarts (compute-restarts)))
     (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))
       (format t "~&~D: ~A~%" i (car r)))
     (let ((n nil) (k (length restarts)))
       (loop (when (and (typep n 'integer) (>= n 0) (< n k))
               (return t))
             (format t "~&Option: ")
             (setq n (read))
             (fresh-line))
       (invoke-restart-interactively (nth n restarts)))))

 (restart-case (invoke-a-restart)
   (one () 1)
   (two () 2)
   (nil () :report "Who knows?" 'anonymous)
   (one () 'I)
   (two () 'II))
Ö 0: ONE
Ö 1: TWO
Ö 2: Who knows?
Ö 3: ONE
Ö 4: TWO
Ö 5: Return to Lisp Toplevel.
Ö Option: 4
ý II

 ;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS
 ;; also returns information about any system-supplied restarts, such as
 ;; the "Return to Lisp Toplevel" restart offered above.

Affected By:
............

Existing restarts.

See Also:
.........

*Note find-restart::, *Note invoke-restart::, *Note restart-bind::


File: chris-ansicl.info,  Node: find-restart,  Next: invoke-restart,  Prev: compute-restarts,  Up: Conditions

find-restart (Function)
=======================

Syntax:
.......

 -- Function: find-restart identifier &optional condition ý restart

Arguments and Values:
.....................

IDENTIFIER--a non-nil symbol, or a restart.

CONDITION--a condition object, or ÿnilþ.

RESTART--a restart or ÿnilþ.

Description:
............

ÿfind-restartþ searches for a particular restart in the current dynamic
environment.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated
with any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ÿnilþ, all restarts are
considered.

If IDENTIFIER is a symbol, then the innermost (most recently
established) applicable restart with that name is returned.  ÿnilþ is
returned if no such restart is found.

If IDENTIFIER is a currently active restart, then it is returned.
Otherwise, ÿnilþ is returned.

Examples:
.........

 (restart-case
     (let ((r (find-restart 'my-restart)))
       (format t "~S is named ~S" r (restart-name r)))
   (my-restart () nil))
Ö #<RESTART 32307325> is named MY-RESTART
ý NIL
 (find-restart 'my-restart)
ý NIL

Affected By:
............

Existing restarts.

ÿrestart-caseþ, ÿrestart-bindþ, ÿwith-condition-restartsþ.

See Also:
.........

*Note compute-restarts::

Notes:
......

 (find-restart IDENTIFIER)
 Õ (find IDENTIFIER (compute-restarts) :key :restart-name)

Although anonymous restarts have a name of ÿnilþ, the consequences are
unspecified if ÿnilþ is given as an IDENTIFIER.  Occasionally,
programmers lament that ÿnilþ is not permissible as an IDENTIFIER
argument.  In most such cases, ÿcompute-restartsþ can probably be used
to simulate the desired effect.


File: chris-ansicl.info,  Node: invoke-restart,  Next: invoke-restart-interactively,  Prev: find-restart,  Up: Conditions

invoke-restart (Function)
=========================

Syntax:
.......

 -- Function: invoke-restart restart &rest arguments ý {result}*

Arguments and Values:
.....................

RESTART--a restart designator.

ARGUMENT--an object.

RESULTS--the values returned by the function associated with RESTART,
if that function returns.

Description:
............

Calls the function associated with RESTART, passing ARGUMENTS to it.
RESTART must be valid in the current dynamic environment.

Examples:
.........

 (defun add3 (x) (check-type x number) (+ x 3))

 (foo 'seven)
Ö Error: The value SEVEN was not of type NUMBER.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a different value to use.
Ö  2: Return to Lisp Toplevel.
Ö Debug> (invoke-restart 'store-value 7)
ý 10

Side Effects:
.............

A non-local transfer of control might be done by the restart.

Affected By:
............

Existing restarts.

Exceptional Situations:
.......................

If RESTART is not valid, an error of type ÿcontrol-errorþ is signaled.

See Also:
.........

*Note find-restart::, *Note restart-bind::, *Note restart-case::, *Note
invoke-restart-interactively::

Notes:
......

The most common use for ÿinvoke-restartþ is in a handler.  It might be
used explicitly, or implicitly through ÿinvoke-restart-interactivelyþ
or a restart function.

Restart functions call ÿinvoke-restartþ, not vice versa.  That is,
invoke-restart provides primitive functionality, and restart functions
are non-essential "syntactic sugar."


File: chris-ansicl.info,  Node: invoke-restart-interactively,  Next: restart-bind,  Prev: invoke-restart,  Up: Conditions

invoke-restart-interactively (Function)
=======================================

Syntax:
.......

 -- Function: invoke-restart-interactively restart ý {result}*

Arguments and Values:
.....................

RESTART--a restart designator.

RESULTS--the values returned by the function associated with RESTART,
if that function returns.

Description:
............

ÿinvoke-restart-interactivelyþ calls the function associated with
RESTART, prompting for any necessary arguments.  If RESTART is a name,
it must be valid in the current dynamic environment.

ÿinvoke-restart-interactivelyþ prompts for arguments by executing the
code provided in the :interactive keyword to ÿrestart-caseþ or
:interactive-function keyword to ÿrestart-bindþ.

If no such options have been supplied in the corresponding
ÿrestart-bindþ or ÿrestart-caseþ, then the consequences are undefined
if the RESTART takes required arguments.  If the arguments are
optional, an argument list of ÿnilþ is used.

Once the arguments have been determined, ÿinvoke-restart-interactivelyþ
executes the following:

 (apply #'invoke-restart restart arguments)

Examples:
.........

 (defun add3 (x) (check-type x number) (+ x 3))

 (add3 'seven)
Ö Error: The value SEVEN was not of type NUMBER.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a different value to use.
Ö  2: Return to Lisp Toplevel.
Ö Debug> (invoke-restart-interactively 'store-value)
Ö Type a form to evaluate and use: 7
ý 10

Side Effects:
.............

If prompting for arguments is necesary, some typeout may occur (on
query I/O).

A non-local transfer of control might be done by the restart.

Affected By:
............

ÿ*query-io*þ, active restarts

Exceptional Situations:
.......................

If RESTART is not valid, an error of type ÿcontrol-errorþ is signaled.

See Also:
.........

*Note find-restart::, *Note invoke-restart::, *Note restart-case::,
*Note restart-bind::

Notes:
......

ÿinvoke-restart-interactivelyþ is used internally by the debugger and
may also be useful in implementing other portable, interactive debugging
tools.


File: chris-ansicl.info,  Node: restart-bind,  Next: restart-case,  Prev: invoke-restart-interactively,  Up: Conditions

restart-bind (Macro)
====================

Syntax:
.......

 -- Macro: restart-bind ({(name function {ûkey-val-pair}*)}) {form}* ý
          {result}*

KEY-VAL-PAIR::=
     :interactive-function interactive-function |
     :report-function report-function |
     :test-function test-function

Arguments and Values:
.....................

NAME--a symbol; not evaluated.

FUNCTION--a form; evaluated.

FORMS--an implicit progn.

INTERACTIVE-FUNCTION--a form; evaluated.

REPORT-FUNCTION--a form; evaluated.

TEST-FUNCTION--a form; evaluated.

RESULTS--the values returned by the forms.

Description:
............

ÿrestart-bindþ executes the body of FORMS in a dynamic environment
where restarts with the given NAMES are in effect.

If a NAME is ÿnilþ, it indicates an anonymous restart; if a NAME is a
non-nil symbol, it indicates a named restart.

The FUNCTION, INTERACTIVE-FUNCTION, and REPORT-FUNCTION are
unconditionally evaluated in the current lexical and dynamic environment
prior to evaluation of the body. Each of these forms must evaluate to a
function.

If ÿinvoke-restartþ is done on that restart, the function which
resulted from evaluating FUNCTION is called, in the dynamic environment
of the ÿinvoke-restartþ, with the arguments given to ÿinvoke-restartþ.
The function may either perform a non-local transfer of control or may
return normally.

If the restart is invoked interactively from the debugger (using
ÿinvoke-restart-interactivelyþ), the arguments are defaulted by calling
the function which resulted from evaluating INTERACTIVE-FUNCTION.  That
function may optionally prompt interactively on query I/O, and should
return a list of arguments to be used by ÿinvoke-restart-interactivelyþ
when invoking the restart.

If a restart is invoked interactively but no INTERACTIVE-FUNCTION is
used, then an argument list of ÿnilþ is used. In that case, the function
must be compatible with an empty argument list.

If the restart is presented interactively (e.g., by the debugger), the
presentation is done by calling the function which resulted from
evaluating REPORT-FUNCTION.  This function must be a function of one
argument, a stream.  It is expected to print a description of the
action that the restart takes to that stream.  This function is called
any time the restart is printed while ÿ*print-escape*þ is ÿnilþ.

In the case of interactive invocation, the result is dependent on the
value of :interactive-function as follows.

:interactive-function
     VALUE is evaluated in the current lexical environment and should
     return a function of no arguments which constructs a list of
     arguments to be used by ÿinvoke-restart-interactivelyþ when
     invoking this restart.  The function may prompt interactively
     using query I/O if necessary.

:report-function
     VALUE is evaluated in the current lexical environment and should
     return a function of one argument, a stream, which prints on the
     stream a summary of the action that this restart takes.  This
     function is called whenever the restart is reported (printed while
     ÿ*print-escape*þ is ÿnilþ).  If no :report-function option is
     provided, the manner in which the restart is reported is
     implementation-dependent.

:test-function
     VALUE is evaluated in the current lexical environment and should
     return a function of one argument, a condition, which returns true
     if the restart is to be considered visible.

Affected By:
............

ÿ*query-io*þ.

See Also:
.........

*Note restart-case::, *Note with-simple-restart::

Notes:
......

ÿrestart-bindþ is primarily intended to be used to implement
ÿrestart-caseþ and  might be useful in implementing other macros.
Programmers who are uncertain about whether to use ÿrestart-caseþ or
ÿrestart-bindþ should prefer ÿrestart-caseþ for the cases where it is
powerful enough, using ÿrestart-bindþ only in cases where its full
generality is really needed.


File: chris-ansicl.info,  Node: restart-case,  Next: restart-name,  Prev: restart-bind,  Up: Conditions

restart-case (Macro)
====================

Syntax:
.......

 -- Macro: restart-case restartable-form {ûclause} ý {result}*

CLAUSE::=
     ( case-name lambda-list
      ù:interactive interactive-expression | :report report-expression
     | :test test-expressionø
      {declaration}* {form}*)

Arguments and Values:
.....................

RESTARTABLE-FORM--a form.

CASE-NAME--a symbol or ÿnilþ.

LAMBDA-LIST--an ordinary lambda list.

INTERACTIVE-EXPRESSION--a symbol or a lambda expression.

REPORT-EXPRESSION--a string, a symbol, or a lambda expression.

TEST-EXPRESSION--a symbol or a lambda expression.

DECLARATION--a declare expression; not evaluated.

FORM--a form.

RESULTS--the values resulting from the evaluation of RESTARTABLE-FORM,
or the values returned by the last FORM executed in a chosen clause, or
ÿnilþ.

Description:
............

ÿrestart-caseþ evaluates RESTARTABLE-FORM in a dynamic environment
where the clauses have special meanings as points to which control may
be transferred.  If RESTARTABLE-FORM finishes executing and returns any
values, all values returned are returned by ÿrestart-caseþ and
processing has completed. While RESTARTABLE-FORM is executing, any code
may transfer control to one of the clauses (see ÿinvoke-restartþ).  If
a transfer occurs, the forms in the body of that clause is evaluated
and any values returned by the last such form are returned by
ÿrestart-caseþ.  In this case, the dynamic state is unwound
appropriately (so that the restarts established around the
RESTARTABLE-FORM are no longer active) prior to execution of the clause.

If there are no FORMS in a selected clause, ÿrestart-caseþ returns
ÿnilþ.

If CASE-NAME is a symbol, it names this restart.

It is possible to have more than one clause use the same CASE-NAME.  In
this case, the first clause with that name is found by ÿfind-restartþ.
The other clauses are accessible using ÿcompute-restartsþ.

Each ARGLIST is an ordinary lambda list to be bound during the
execution of its corresponding FORMS.  These parameters are used by the
ÿrestart-caseþ clause to receive any necessary data from a call to
ÿinvoke-restartþ.

By default, ÿinvoke-restart-interactivelyþ passes no arguments and all
arguments must be optional in order to accomodate interactive
restarting.  However, the arguments need not be optional if the
:interactive keyword has been used to inform
ÿinvoke-restart-interactivelyþ about how to compute a proper argument
list.

KEYWORD options have the following meaning.

:interactive
     The VALUE supplied by ÿ:interactive VALUEþ must be a suitable
     argument to ÿfunctionþ.  ÿ(function VALUE)þ is evaluated in the
     current lexical environment.  It should return a function of no
     arguments which returns arguments to be used by
     ÿinvoke-restart-interactivelyþ when it is invoked.
     ÿinvoke-restart-interactivelyþ is called in the dynamic
     environment available prior to any restart attempt, and uses query
     I/O for user interaction.

     If a restart is invoked interactively but no :interactive option
     was supplied, the argument list used in the invocation is the empty
     list.

:report
     If the VALUE supplied by ÿ:report VALUEþ is a lambda expression or
     a symbol, it must be acceptable to ÿfunctionþ.  ÿ(function VALUE)þ
     is evaluated in the current lexical environment.  It should return
     a function of one argument, a stream, which prints on the stream a
     description of the restart.  This function is called whenever the
     restart is printed while ÿ*print-escape*þ is ÿnilþ.

     If VALUE is a string, it is a shorthand for

      (lambda (stream) (write-string value stream))

     If a named restart is asked to report but no report information
     has been supplied, the name of the restart is used in generating
     default report text.

     When ÿ*print-escape*þ is ÿnilþ, the printer uses the report
     information for a restart.  For example, a debugger might announce
     the action of typing a "continue" command by:

      (format t "~&~S -- ~A~%" ':continue some-restart)

     which might then display as something like:

      :CONTINUE -- Return to command level

     The consequences are unspecified if an unnamed restart is specified
     but no :report option is provided.

:test
     The VALUE supplied by ÿ:test VALUEþ must be a suitable argument to
     ÿfunctionþ.  ÿ(function VALUE)þ is evaluated in the current lexical
     environment.  It should return a function of one argument, the
     condition, that returns true if the restart is to be considered
     visible.

     The default for this option is equivalent to ÿ(lambda (c) (declare
     (ignore c)) t)þ.

If the RESTARTABLE-FORM is a list whose car is any of the symbols
ÿsignalþ, ÿerrorþ, ÿcerrorþ, or ÿwarnþ (or is a macro form which
macroexpands into such a list), then ÿwith-condition-restartsþ is used
implicitly to associate the indicated restarts with the condition to be
signaled.

Examples:
.........

 (restart-case
     (handler-bind ((error #'(lambda (c)
                             (declare (ignore condition))
                             (invoke-restart 'my-restart 7))))
       (error "Foo."))
   (my-restart (&optional v) v))
ý 7

 (define-condition food-error (error) ())
ý FOOD-ERROR
 (define-condition bad-tasting-sundae (food-error)
   ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)
    (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)
    (topping :initarg :topping :reader bad-tasting-sundae-topping))
   (:report (lambda (condition stream)
              (format stream "Bad tasting sundae with ~S, ~S, and ~S"
                      (bad-tasting-sundae-ice-cream condition)
                      (bad-tasting-sundae-sauce condition)
                      (bad-tasting-sundae-topping condition)))))
ý BAD-TASTING-SUNDAE
 (defun all-start-with-same-letter (symbol1 symbol2 symbol3)
   (let ((first-letter (char (symbol-name symbol1) 0)))
     (and (eql first-letter (char (symbol-name symbol2) 0))
          (eql first-letter (char (symbol-name symbol3) 0)))))
ý ALL-START-WITH-SAME-LETTER
 (defun read-new-value ()
   (format t "Enter a new value: ")
   (multiple-value-list (eval (read))))
ý READ-NEW-VALUE
 (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)
   (do ()
      ((all-start-with-same-letter ice-cream sauce topping))
     (restart-case
       (error 'bad-tasting-sundae
              :ice-cream ice-cream
              :sauce sauce
              :topping topping)
       (use-new-ice-cream (new-ice-cream)
         :report "Use a new ice cream."
         :interactive read-new-value
         (setq ice-cream new-ice-cream))
       (use-new-sauce (new-sauce)
         :report "Use a new sauce."
         :interactive read-new-value
         (setq sauce new-sauce))
       (use-new-topping (new-topping)
         :report "Use a new topping."
         :interactive read-new-value
         (setq topping new-topping))))
   (values ice-cream sauce topping))
ý VERIFY-OR-FIX-PERFECT-SUNDAE
 (verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)
Ö Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Use a new ice cream.
Ö  2: Use a new sauce.
Ö  3: Use a new topping.
Ö  4: Return to Lisp Toplevel.
Ö Debug> :continue 1
Ö Use a new ice cream.
Ö Enter a new ice cream: 'chocolate
ý CHOCOLATE, CARAMEL, CHERRY

See Also:
.........

*Note restart-bind::, *Note with-simple-restart::.

Notes:
......

 (restart-case expression
    (name1 arglist1 ...options1... . body1)
    (name2 arglist2 ...options2... . body2))

is essentially equivalent to

 (block #1=#:g0001
   (let ((#2=#:g0002 nil))
        (tagbody
        (restart-bind ((name1 #'(lambda (&rest temp)
                                (setq #2# temp)
                                (go #3=#:g0003))
                          ...slightly-transformed-options1...)
                       (name2 #'(lambda (&rest temp)
                                (setq #2# temp)
                                (go #4=#:g0004))
                          ...slightly-transformed-options2...))
        (return-from #1# expression))
          #3# (return-from #1#
                  (apply #'(lambda arglist1 . body1) #2#))
          #4# (return-from #1#
                  (apply #'(lambda arglist2 . body2) #2#)))))

Unnamed restarts are generally only useful interactively and an
interactive option which has no description is of little value.
Implementations are encouraged to warn if an unnamed restart is used
and no report information is provided at compilation    time.  At
runtime, this error might be noticed when entering the debugger.  Since
signaling an error would probably cause recursive entry into the
debugger (causing yet another recursive error, etc.) it is suggested
that the debugger print some indication of such problems when they
occur but not actually signal errors.

 (restart-case (signal fred)
   (a ...)
   (b ...))
 Õ
 (restart-case
     (with-condition-restarts fred
                              (list (find-restart 'a)
                                    (find-restart 'b))
       (signal fred))
   (a ...)
   (b ...))


File: chris-ansicl.info,  Node: restart-name,  Next: with-condition-restarts,  Prev: restart-case,  Up: Conditions

restart-name (Function)
=======================

Syntax:
.......

 -- Function: restart-name restart ý name

Arguments and Values:
.....................

RESTART--a restart.

NAME--a symbol.

Description:
............

Returns the name of the RESTART, or ÿnilþ if the RESTART is not named.

Examples:
.........

 (restart-case
     (loop for restart in (compute-restarts)
               collect (restart-name restart))
   (case1 () :report "Return 1." 1)
   (nil   () :report "Return 2." 2)
   (case3 () :report "Return 3." 3)
   (case1 () :report "Return 4." 4))
ý (CASE1 NIL CASE3 CASE1 ABORT)
 ;; In the example above the restart named ABORT was not created
 ;; explicitly, but was implicitly supplied by the system.

See Also:
.........

*Note compute-restarts:: *Note find-restart::


File: chris-ansicl.info,  Node: with-condition-restarts,  Next: with-simple-restart,  Prev: restart-name,  Up: Conditions

with-condition-restarts (Macro)
===============================

Syntax:
.......

 -- Macro: with-condition-restarts condition-form restarts-form {form}*
          ý {result}*

Arguments and Values:
.....................

CONDITION-FORM--a form; evaluated to produce a CONDITION.

CONDITION--a condition object resulting from the evaluation of
CONDITION-FORM.

RESTART-FORM--a form; evaluated to produce a RESTART-LIST.

RESTART-LIST--a list of restart objects resulting from the evaluation
of RESTART-FORM.

FORMS--an implicit progn; evaluated.

RESULTS--the values returned by FORMS.

Description:
............

First, the CONDITION-FORM and RESTARTS-FORM are evaluated in normal
left-to-right order; the primary values yielded by these evaluations
are respectively called the CONDITION and the RESTART-LIST.

Next, the FORMS are evaluated in a dynamic environment in which each
restart in RESTART-LIST is associated with the CONDITION.  See *Note
Section 9.1.4.2.4 (Associating a Restart with a Condition):
AssocRestartWithCond.

See Also:
.........

*Note restart-case::

Notes:
......

Usually this macro is not used explicitly in code, since ÿrestart-caseþ
handles most of the common cases in a way that is syntactically more
concise.


File: chris-ansicl.info,  Node: with-simple-restart,  Next: abort (Restart),  Prev: with-condition-restarts,  Up: Conditions

with-simple-restart (Macro)
===========================

Syntax:
.......

 -- Macro: with-simple-restart (name format-control {format-argument}*)
          {form}* ý {result}*

Arguments and Values:
.....................

NAME--a symbol.

FORMAT-CONTROL--a format control.

FORMAT-ARGUMENT--an object (i.e., a format argument).

FORMS--an implicit progn.

RESULTS--in the normal situation, the values returned by the FORMS; in
the exceptional situation where the restart named NAME is invoked, two
values--ÿnilþ and ÿtþ.

Description:
............

ÿwith-simple-restartþ establishes a restart.

If the restart designated by NAME is not invoked while executing FORMS,
all values returned by the last of FORMS are returned.  If the restart
designated by NAME is invoked, control is transferred to
ÿwith-simple-restartþ, which returns two values, ÿnilþ and ÿtþ.

If NAME is ÿnilþ, an anonymous restart is established.

The FORMAT-CONTROL and FORMAT-ARGUMENTS are used report the restart.

Examples:
.........

 (defun read-eval-print-loop (level)
   (with-simple-restart (abort "Exit command level ~D." level)
     (loop
       (with-simple-restart (abort "Return to command level ~D." level)
         (let ((form (prog2 (fresh-line) (read) (fresh-line))))
           (prin1 (eval form)))))))
ý READ-EVAL-PRINT-LOOP
 (read-eval-print-loop 1)
 (+ 'a 3)
Ö Error: The argument, A, to the function + was of the wrong type.
Ö        The function expected a number.
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Specify a value to use this time.
Ö  2: Return to command level 1.
Ö  3: Exit command level 1.
Ö  4: Return to Lisp Toplevel.

 (defun compute-fixnum-power-of-2 (x)
   (with-simple-restart (nil "Give up on computing 2^~D." x)
     (let ((result 1))
       (dotimes (i x result)
         (setq result (* 2 result))
         (unless (fixnump result)
           (error "Power of 2 is too large."))))))
COMPUTE-FIXNUM-POWER-OF-2
 (defun compute-power-of-2 (x)
   (or (compute-fixnum-power-of-2 x) 'something big))
COMPUTE-POWER-OF-2
 (compute-power-of-2 10)
1024
 (compute-power-of-2 10000)
Ö Error: Power of 2 is too large.
Ö To continue, type :CONTINUE followed by an option number.
Ö  1: Give up on computing 2^10000.
Ö  2: Return to Lisp Toplevel
Ö Debug> :continue 1
ý SOMETHING-BIG

See Also:
.........

*Note restart-case::

Notes:
......

ÿwith-simple-restartþ is shorthand for one of the most common uses of
ÿrestart-caseþ.

ÿwith-simple-restartþ could be defined by:

 (defmacro with-simple-restart ((restart-name format-control
                                              &rest format-arguments)
                                &body forms)
   `(restart-case (progn ,@forms)
      (,restart-name ()
          :report (lambda (stream)
                    (format stream ,format-control ,@format-arguments))
         (values nil t))))

Because the second return value is ÿtþ in the exceptional case, it is
common (but not required) to arrange for the second return value in the
normal case to be missing or ÿnilþ so that the two situations can be
distinguished.


File: chris-ansicl.info,  Node: abort (Restart),  Next: continue (Restart),  Prev: with-simple-restart,  Up: Conditions

abort (Restart)
===============

Data Arguments Required:
........................

None.

Description:
............

The intent of the abort restart is to allow return to the innermost
"command level."  Implementors are encouraged to make sure that there
is always a restart named ÿabortþ around any user code so that user
code can call ÿabortþ at any time and expect something reasonable to
happen; exactly what the reasonable thing is may vary somewhat.
Typically, in an interactive listener, the invocation of ÿabortþ
returns to the Lisp reader phase of the Lisp read-eval-print loop,
though in some batch or multi-processing situations there may be
situations in which having it kill the running process is more
appropriate.

See Also:
.........

*Note Section 9.1.4.2 (Restarts): Restarts, *Note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *Note invoke-restart::,
*Note abort:: (function)


File: chris-ansicl.info,  Node: continue (Restart),  Next: muffle-warning (Restart),  Prev: abort (Restart),  Up: Conditions

continue (Restart)
==================

Data Arguments Required:
........................

None.

Description:
............

the ÿcontinueþ restart is generally part of protocols where there is a
single "obvious" way to continue, such as in ÿbreakþ and ÿcerrorþ.  Some
user-defined protocols may also wish to incorporate it for similar
reasons.  In general, however, it is more reliable to design a special
purpose restart with a name that more directly suits the particular
application.

Examples:
.........

 (let ((x 3))
   (handler-bind ((error #'(lambda (c)
                             (let ((r (find-restart 'continue c)))
                               (when r (invoke-restart r))))))
     (cond ((not (floatp x))
            (cerror "Try floating it." "~D is not a float." x)
            (float x))
           (t x)))) ý 3.0

See Also:
.........

*Note Section 9.1.4.2 (Restarts): Restarts, *Note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *Note invoke-restart::,
*Note continue:: (function), *Note assert::, *Note cerror::


File: chris-ansicl.info,  Node: muffle-warning (Restart),  Next: store-value (Restart),  Prev: continue (Restart),  Up: Conditions

muffle-warning (Restart)
========================

Data Arguments Required:
........................

None.

Description:
............

This restart is established by ÿwarnþ so that handlers of ÿwarningþ
conditions have a way to tell ÿwarnþ that a warning has already been
dealt with and that no further action is warranted.

Examples:
.........

 (defvar *all-quiet* nil) ý *ALL-QUIET*
 (defvar *saved-warnings* '()) ý *SAVED-WARNINGS*
 (defun quiet-warning-handler (c)
   (when *all-quiet*
     (let ((r (find-restart 'muffle-warning c)))
       (when r
         (push c *saved-warnings*)
         (invoke-restart r)))))
ý CUSTOM-WARNING-HANDLER
 (defmacro with-quiet-warnings (&body forms)
   `(let ((*all-quiet* t)
          (*saved-warnings* '()))
      (handler-bind ((warning #'quiet-warning-handler))
        ,@forms
        *saved-warnings*)))
ý WITH-QUIET-WARNINGS
 (setq saved
   (with-quiet-warnings
     (warn "Situation #1.")
     (let ((*all-quiet* nil))
       (warn "Situation #2."))
     (warn "Situation #3.")))
Ö Warning: Situation #2.
ý (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)
 (dolist (s saved) (format t "~&~A~%" s))
Ö Situation #3.
Ö Situation #1.
ý NIL

See Also:
.........

*Note Section 9.1.4.2 (Restarts): Restarts, *Note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *Note invoke-restart::,
*Note muffle-warning:: (function), *Note warn::


File: chris-ansicl.info,  Node: store-value (Restart),  Next: use-value (Restart),  Prev: muffle-warning (Restart),  Up: Conditions

store-value (Restart)
=====================

Data Arguments Required:
........................

a value to use instead (on an ongoing basis).

Description:
............

the ÿstore-valueþ restart is generally used by handlers trying to
recover from errors of types such as ÿcell-errorþ or ÿtype-errorþ,
which may wish to supply a replacement datum to be stored permanently.

Examples:
.........

 (defun type-error-auto-coerce (c)
   (when (typep c 'type-error)
     (let ((r (find-restart 'store-value c)))
       (handler-case (let ((v (coerce (type-error-datum c)
                                      (type-error-expected-type c))))
                       (invoke-restart r v))
         (error ()))))) ý TYPE-ERROR-AUTO-COERCE
 (let ((x 3))
   (handler-bind ((type-error #'type-error-auto-coerce))
     (check-type x float)
     x)) ý 3.0

See Also:
.........

*Note Section 9.1.4.2 (Restarts): Restarts, *Note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *Note invoke-restart::,
*Note store-value:: (function), *Note ccase::, *Note check-type::,
*Note ctypecase::, *Note use-value:: (function and restart)


File: chris-ansicl.info,  Node: use-value (Restart),  Next: abort; continue; muffle-warning; store-value; use-value,  Prev: store-value (Restart),  Up: Conditions

use-value (Restart)
===================

Data Arguments Required:
........................

a value to use instead (once).

Description:
............

the ÿuse-valueþ restart is generally used by handlers trying to recover
from errors of types such as ÿcell-errorþ, where the handler may wish
to supply a replacement datum for one-time use.

See Also:
.........

*Note Section 9.1.4.2 (Restarts): Restarts, *Note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *Note invoke-restart::,
*Note use-value:: (function), *Note store-value:: (function and restart)


File: chris-ansicl.info,  Node: abort; continue; muffle-warning; store-value; use-value,  Prev: use-value (Restart),  Up: Conditions

abort, continue, muffle-warning, store-value, use-value (Function)
==================================================================

Syntax:
.......

 -- Function: abort &optional condition ý|

 -- Function: continue &optional condition ý ÿnilþ

 -- Function: muffle-warning &optional condition ý|

 -- Function: store-value value &optional condition ý ÿnilþ

 -- Function: use-value value &optional condition ý ÿnilþ

Arguments and Values:
.....................

VALUE--an object.

CONDITION--a condition object, or ÿnilþ.

Description:
............

Transfers control to the most recently established applicable restart
having the same name as the function.  That is, the function ÿabortþ
searches for an applicable abort    restart, the function ÿcontinueþ
searches for an applicable continue restart, and so on.

If no such restart exists, the functions ÿcontinueþ, ÿstore-valueþ, and
ÿuse-valueþ return ÿnilþ, and the functions ÿabortþ and ÿmuffle-warningþ
signal an error of type ÿcontrol-errorþ.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated
with any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ÿnilþ, all restarts are
considered.

Examples:
.........

;;; Example of the ABORT retart

 (defmacro abort-on-error (&body forms)
   `(handler-bind ((error #'abort))
      ,@forms)) ý ABORT-ON-ERROR
 (abort-on-error (+ 3 5)) ý 8
 (abort-on-error (error "You lose."))
Ö Returned to Lisp Top Level.

;;; Example of the CONTINUE restart

 (defun real-sqrt (n)
   (when (minusp n)
     (setq n (- n))
     (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
   (sqrt n))

 (real-sqrt 4) ý 2
 (real-sqrt -9)
Ö Error: Tried to take sqrt(-9).
Ö To continue, type :CONTINUE followed by an option number:
Ö  1: Return sqrt(9) instead.
Ö  2: Return to Lisp Toplevel.
Ö Debug> (continue)
Ö Return sqrt(9) instead.
ý 3

 (handler-bind ((error #'(lambda (c) (continue))))
   (real-sqrt -9)) ý 3

;;; Example of the MUFFLE-WARNING restart

 (defun count-down (x)
   (do ((counter x (1- counter)))
       ((= counter 0) 'done)
     (when (= counter 1)
       (warn "Almost done"))
     (format t "~&~D~%" counter)))
ý COUNT-DOWN
 (count-down 3)
Ö 3
Ö 2
Ö Warning: Almost done
Ö 1
ý DONE
 (defun ignore-warnings-while-counting (x)
   (handler-bind ((warning #'ignore-warning))
     (count-down x)))
ý IGNORE-WARNINGS-WHILE-COUNTING
 (defun ignore-warning (condition)
   (declare (ignore condition))
   (muffle-warning))
ý IGNORE-WARNING
 (ignore-warnings-while-counting 3)
Ö 3
Ö 2
Ö 1
ý DONE

;;; Example of the STORE-VALUE and USE-VALUE restarts

 (defun careful-symbol-value (symbol)
   (check-type symbol symbol)
   (restart-case (if (boundp symbol)
                     (return-from careful-symbol-value
                                  (symbol-value symbol))
                     (error 'unbound-variable
                            :name symbol))
     (use-value (value)
       :report "Specify a value to use this time."
       value)
     (store-value (value)
       :report "Specify a value to store and use in the future."
       (setf (symbol-value symbol) value))))
 (setq a 1234) ý 1234
 (careful-symbol-value 'a) ý 1234
 (makunbound 'a) ý A
 (careful-symbol-value 'a)
Ö Error: A is not bound.
Ö To continue, type :CONTINUE followed by an option number.
Ö  1: Specify a value to use this time.
Ö  2: Specify a value to store and use in the future.
Ö  3: Return to Lisp Toplevel.
Ö Debug> (use-value 12)
ý 12
 (careful-symbol-value 'a)
Ö Error: A is not bound.
Ö To continue, type :CONTINUE followed by an option number.
Ö   1: Specify a value to use this time.
Ö   2: Specify a value to store and use in the future.
Ö   3: Return to Lisp Toplevel.
Ö Debug> (store-value 24)
ý 24
 (careful-symbol-value 'a)
ý 24

;;; Example of the USE-VALUE restart

 (defun add-symbols-with-default (default &rest symbols)
   (handler-bind ((sys:unbound-symbol
                    #'(lambda (c)
                        (declare (ignore c))
                        (use-value default))))
     (apply #'+ (mapcar #'careful-symbol-value symbols))))
ý ADD-SYMBOLS-WITH-DEFAULT
 (setq x 1 y 2) ý 2
 (add-symbols-with-default 3 'x 'y 'z) ý 6

Side Effects:
.............

A transfer of control may occur if an appropriate restart is available,
or (in the case of the function ÿabortþ or the function
ÿmuffle-warningþ) execution may be stopped.

Affected By:
............

Each of these functions can be affected by the presence of a restart
having the same name.

Exceptional Situations:
.......................

If an appropriate abort restart is not available for the function
ÿabortþ, or an appropriate muffle-warning restart is not available for
the function ÿmuffle-warningþ, an error of type ÿcontrol-errorþ is
signaled.

See Also:
.........

*Note invoke-restart::, *Note Section 9.1.4.2 (Restarts): Restarts,
*Note Section 9.1.4.2.2 (Interfaces to Restarts): InterfacesToRestarts,
*Note assert::, *Note ccase::, *Note cerror::, *Note check-type::,
*Note ctypecase::, *Note use-value::, *Note warn::

Notes:
......

 (abort condition) Õ (invoke-restart 'abort)
 (muffle-warning)  Õ (invoke-restart 'muffle-warning)
 (continue)        Õ (let ((r (find-restart 'continue))) (if r (invoke-restart r)))
 (use-value X) Õ (let ((r (find-restart 'use-value))) (if r (invoke-restart r X)))
 (store-value x) Õ (let ((r (find-restart 'store-value))) (if r (invoke-restart r X)))

No functions defined in this specification are required to provide a
use-value restart.


File: chris-ansicl.info,  Node: Symbols,  Next: Packages,  Prev: Conditions,  Up: Top

10 Symbols
**********

* Menu:

* Symbol Concepts::

Dictionary

* symbol::
* keyword::
* symbolp::
* keywordp::
* make-symbol::
* copy-symbol::
* gensym::
* *gensym-counter*::
* gentemp::
* symbol-function::
* symbol-name::
* symbol-package::
* symbol-plist::
* symbol-value::
* get::
* remprop::
* boundp::
* makunbound::
* set::
* unbound-variable::


File: chris-ansicl.info,  Node: Symbol Concepts,  Next: symbol,  Up: Symbols

10.1 Symbol Concepts
====================

The next figure lists some defined names that are applicable to the
property lists of symbols.

get   remprop   symbol-plist

Figure 10.1: Property list defined names

The next figure lists some defined names that are applicable to the
creation of and inquiry about symbols.

copy-symbol   keywordp      symbol-package
gensym        make-symbol   symbol-value
gentemp       symbol-name   

Figure 10.2: Symbol creation and inquiry defined names


File: chris-ansicl.info,  Node: symbol,  Next: keyword,  Prev: Symbol Concepts,  Up: Symbols

symbol (System Class)
=====================

Class Precedence List:
......................

ÿsymbolþ, ÿtþ

Description:
............

Symbols are used for their object identity to name various entities in
Common Lisp, including (but not limited to) linguistic entities such as
variables and functions.

Symbols can be collected together into packages.  A symbol is said to
be interned in a package if it is accessible in that package; the same
symbol can be interned in more than one package.  If a symbol is not
interned in any package, it is called uninterned.

An interned symbol is uniquely identifiable by its name from any
package in which it is accessible.

Symbols have the following attributes.  For historical reasons, these
are sometimes referred to as cells, although the actual internal
representation of symbols and their attributes is
implementation-dependent.

Name
     The name of a symbol is a string used to identify the symbol.
     Every symbol has a name, and the consequences are undefined if
     that name is altered.  The name is used as part of the external,
     printed representation of the symbol; see *Note Section 2.1
     (Character Syntax): Character Syntax.  The function ÿsymbol-nameþ
     returns the name of a given symbol.  A symbol may have any
     character in its name.

Package
     The object in this cell is called the home package of the symbol.
     If the home package is ÿnilþ, the symbol is sometimes said to have
     no home package.

     When a symbol is first created, it has no home package.  When it
     is first interned, the package in which it is initially interned
     becomes its home package.  The home package of a symbol can be
     accessed by using the function ÿsymbol-packageþ.

     If a symbol is uninterned from the package which is its home
     package, its home package is set to ÿnilþ.  Depending on whether
     there is another package in which the symbol is interned, the
     symbol might or might not really be an uninterned symbol.  A
     symbol with no home package is therefore called apparently
     uninterned.

     The consequences are undefined if an attempt is made to alter the
     home package of a symbol external in the ÿCOMMON-LISPþ package or
     the ÿKEYWORDþ package.

Property list
     The property list of a symbol provides a mechanism for associating
     named attributes with that symbol.  The operations for adding and
     removing entries are destructive to the property list.  Common
     Lisp provides operators both for direct manipulation of property
     list objects (e.g., see ÿgetfþ, ÿremfþ, and ÿsymbol-plistþ) and
     for implicit manipulation of a symbol's property list by reference
     to the symbol (e.g., see ÿgetþ and ÿrempropþ).  The property list
     associated with a fresh symbol is initially null.

Value
     If a symbol has a value attribute, it is said to be bound, and
     that fact can be detected by the function ÿboundpþ.  The object
     contained in the value cell of a bound symbol is the value of the
     global variable named by that symbol, and can be accessed by the
     function ÿsymbol-valueþ.  A symbol can be made to be unbound by
     the function ÿmakunboundþ.

     The consequences are undefined if an attempt is made to change the
     value of a symbol that names a constant variable, or to make such a
     symbol be unbound.

Function
     If a symbol has a function attribute, it is said to be fbound, and
     that fact can be detected by the function ÿfboundpþ.  If the
     symbol is the name of a function in the global environment, the
     function cell contains the function, and can be accessed by the
     function ÿsymbol-functionþ.  If the symbol is the name of either a
     macro in the global environment (see ÿmacro-functionþ) or a
     special operator (see ÿspecial-operator-pþ), the symbol is fbound,
     and can be accessed by the function ÿsymbol-functionþ, but the
     object which the function cell contains is of
     implementation-dependent type and purpose.  A symbol can be made
     to be funbound by the function ÿfmakunboundþ.

     The consequences are undefined if an attempt is made to change the
     functional value of a symbol that names a special form.

Operations on a symbol's value cell and function cell are sometimes
described in terms of their effect on the symbol itself, but the user
should keep in mind that there is an intimate relationship between the
contents of those cells and the global variable or global function
definition, respectively.

Symbols are used as identifiers for lexical variables and lexical
function definitions, but in that role, only their object identity is
significant.  Common Lisp provides no operation on a symbol that can
have any effect on a lexical variable or on a lexical function
definition.

See Also:
.........

*Note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens, *Note
Section 2.3.1.1 (Potential Numbers as Tokens): PotentialNumbersAsTokens,
*Note Section 22.1.3.3 (Printing Symbols): PrintingSymbols.


File: chris-ansicl.info,  Node: keyword,  Next: symbolp,  Prev: symbol,  Up: Symbols

keyword (Type)
==============

Supertypes:
...........

ÿkeywordþ, ÿsymbolþ, ÿtþ

Description:
............

The type ÿkeywordþ includes all symbols interned the ÿKEYWORDþ package.

Interning a symbol in the ÿKEYWORDþ package has three automatic effects:

  1. It causes the symbol to become bound to itself.

  2. It causes the symbol to become an external symbol of the ÿKEYWORDþ
     package.

  3. It causes the symbol to become a constant variable.

See Also:
.........

*Note keywordp::


File: chris-ansicl.info,  Node: symbolp,  Next: keywordp,  Prev: keyword,  Up: Symbols

symbolp (Function)
==================

Syntax:
.......

 -- Function: symbolp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿsymbolþ; otherwise, returns false.

Examples:
.........

 (symbolp 'elephant) ý true
 (symbolp 12) ý false
 (symbolp nil) ý true
 (symbolp '()) ý true
 (symbolp :test) ý true
 (symbolp "hello") ý false

See Also:
.........

*Note keywordp::, *Note symbol::, *Note typep::

Notes:
......

 (symbolp OBJECT) Õ (typep OBJECT 'symbol)


File: chris-ansicl.info,  Node: keywordp,  Next: make-symbol,  Prev: symbolp,  Up: Symbols

keywordp (Function)
===================

Syntax:
.......

 -- Function: keywordp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is a keywordá; otherwise, returns false.

Examples:
.........

 (keywordp 'elephant) ý false
 (keywordp 12) ý false
 (keywordp :test) ý true
 (keywordp ':test) ý true
 (keywordp nil) ý false
 (keywordp :nil) ý true
 (keywordp '(:test)) ý false
 (keywordp "hello") ý false
 (keywordp ":hello") ý false
 (keywordp '&optional) ý false

See Also:
.........

*Note constantp::, *Note keyword::, *Note symbolp::, *Note
symbol-package::


File: chris-ansicl.info,  Node: make-symbol,  Next: copy-symbol,  Prev: keywordp,  Up: Symbols

make-symbol (Function)
======================

Syntax:
.......

 -- Function: make-symbol name ý new-symbol

Arguments and Values:
.....................

NAME--a string.

NEW-SYMBOL--a fresh, uninterned symbol.

Description:
............

ÿmake-symbolþ creates and returns a fresh, uninterned symbol whose name
is the given NAME.  The NEW-SYMBOL is neither bound nor fbound and has
a null property list.

It is implementation-dependent whether the string that becomes the
NEW-SYMBOL's name is the given NAME or a copy of it.  Once a string has
been given as the NAME argument to make-symbol, the consequences are
undefined if a subsequent attempt is made to alter that string.

Examples:
.........

 (setq temp-string "temp") ý "temp"
 (setq temp-symbol (make-symbol temp-string)) ý #:|temp|
 (symbol-name temp-symbol) ý "temp"
 (eq (symbol-name temp-symbol) temp-string) ý implementation-dependent
 (find-symbol "temp") ý NIL, NIL
 (eq (make-symbol temp-string) (make-symbol temp-string)) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NAME is not a string.

See Also:
.........

*Note copy-symbol::

Notes:
......

No attempt is made by ÿmake-symbolþ to convert the case of the name to
uppercase.  The only case conversion which ever occurs for symbols is
done by the Lisp reader.  The program interface to symbol creation
retains case, and the program interface to interning symbols is
case-sensitive.


File: chris-ansicl.info,  Node: copy-symbol,  Next: gensym,  Prev: make-symbol,  Up: Symbols

copy-symbol (Function)
======================

Syntax:
.......

 -- Function: copy-symbol symbol &optional copy-properties ý new-symbol

Arguments and Values:
.....................

SYMBOL--a symbol.

COPY-PROPERTIES--a generalized boolean.  The default is false.

NEW-SYMBOL--a fresh, uninterned symbol.

Description:
............

ÿcopy-symbolþ returns a fresh, uninterned symbol, the name of which is
ÿstring=þ to and possibly the same as the name of the given SYMBOL.

If COPY-PROPERTIES is false, the NEW-SYMBOL is neither bound nor fbound
and has a null property list.  If COPY-PROPERTIES is true, then the
initial value of NEW-SYMBOL is the value of SYMBOL, the initial
function definition of NEW-SYMBOL is the functional value of SYMBOL,
and the property list of NEW-SYMBOL is a copyà of the property list of
SYMBOL.

Examples:
.........

 (setq fred 'fred-smith) ý FRED-SMITH
 (setf (symbol-value fred) 3) ý 3
 (setq fred-clone-1a (copy-symbol fred nil)) ý #:FRED-SMITH
 (setq fred-clone-1b (copy-symbol fred nil)) ý #:FRED-SMITH
 (setq fred-clone-2a (copy-symbol fred t))   ý #:FRED-SMITH
 (setq fred-clone-2b (copy-symbol fred t))   ý #:FRED-SMITH
 (eq fred fred-clone-1a) ý false
 (eq fred-clone-1a fred-clone-1b) ý false
 (eq fred-clone-2a fred-clone-2b) ý false
 (eq fred-clone-1a fred-clone-2a) ý false
 (symbol-value fred) ý 3
 (boundp fred-clone-1a) ý false
 (symbol-value fred-clone-2a) ý 3
 (setf (symbol-value fred-clone-2a) 4) ý 4
 (symbol-value fred) ý 3
 (symbol-value fred-clone-2a) ý 4
 (symbol-value fred-clone-2b) ý 3
 (boundp fred-clone-1a) ý false
 (setf (symbol-function fred) #'(lambda (x) x)) ý #<FUNCTION anonymous>
 (fboundp fred) ý true
 (fboundp fred-clone-1a) ý false
 (fboundp fred-clone-2a) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

See Also:
.........

*Note make-symbol::

Notes:
......

Implementors are encouraged not to copy the string which is the
symbol's name unnecessarily.  Unless there is a good reason to do so,
the normal implementation strategy is for the NEW-SYMBOL's name to be
identical to the given SYMBOL's name.


File: chris-ansicl.info,  Node: gensym,  Next: *gensym-counter*,  Prev: copy-symbol,  Up: Symbols

gensym (Function)
=================

Syntax:
.......

 -- Function: gensym &optional x ý new-symbol

Arguments and Values:
.....................

X--a string or a non-negative integer.  Complicated defaulting
behavior; see below.

NEW-SYMBOL--a fresh, uninterned symbol.

Description:
............

Creates and returns a fresh, uninterned symbol, as if by calling
ÿmake-symbolþ.  (The only difference between ÿgensymþ and ÿmake-symbolþ
is in how the NEW-SYMBOL's name is determined.)

The name of the NEW-SYMBOL is the concatenation of a prefix, which
defaults to ÿ"G"þ, and a suffix, which is the decimal representation of
a number that defaults to the value of ÿ*gensym-counter*þ.

If X is supplied, and is a string, then that string is used as a prefix
instead of ÿ"G"þ for this call to ÿgensymþ only.

If X is supplied, and is an integer, then that integer, instead of the
value of ÿ*gensym-counter*þ, is used as the suffix for this call to
ÿgensymþ only.

If and only if no explicit suffix is supplied, ÿ*gensym-counter*þ is
incremented after it is used.

Examples:
.........

 (setq sym1 (gensym)) ý #:G3142
 (symbol-package sym1) ý NIL
 (setq sym2 (gensym 100)) ý #:G100
 (setq sym3 (gensym 100)) ý #:G100
 (eq sym2 sym3) ý false
 (find-symbol "G100") ý NIL, NIL
 (gensym "T") ý #:T3143
 (gensym) ý #:G3144

Side Effects:
.............

Might increment ÿ*gensym-counter*þ.

Affected By:
............

ÿ*gensym-counter*þ

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if X is not a string or a
non-negative integer.

See Also:
.........

*Note gentemp::, *Note *gensym-counter*::

Notes:
......

The ability to pass a numeric argument to ÿgensymþ has been deprecated;
explicitly binding ÿ*gensym-counter*þ is now stylistically preferred.
(The somewhat baroque conventions for the optional argument are
historical in nature, and supported primarily for compatibility with
older dialects of Lisp.   In modern code, it is recommended that the
only kind of argument used be a string prefix.  In general, though, to
obtain more flexible control of the NEW-SYMBOL's name, consider using
ÿmake-symbolþ instead.)


File: chris-ansicl.info,  Node: *gensym-counter*,  Next: gentemp,  Prev: gensym,  Up: Symbols

*gensym-counter* (Variable)
===========================

Value Type:
...........

a non-negative integer.

Initial Value:
..............

implementation-dependent.

Description:
............

A number which will be used in constructing the name of the next symbol
generated by the function ÿgensymþ.

ÿ*gensym-counter*þ can be either assigned or bound at any time, but its
value must always be a non-negative integer.

Affected By:
............

ÿgensymþ.

See Also:
.........

*Note gensym::

Notes:
......

The ability to pass a numeric argument to ÿgensymþ has been deprecated;
explicitly binding ÿ*gensym-counter*þ is now stylistically preferred.


File: chris-ansicl.info,  Node: gentemp,  Next: symbol-function,  Prev: *gensym-counter*,  Up: Symbols

gentemp (Function)
==================

Syntax:
.......

 -- Function: gentemp &optional prefix package ý new-symbol

Arguments and Values:
.....................

PREFIX--a string.  The default is ÿ"T"þ.

PACKAGE--a package designator.  The default is the current package.

NEW-SYMBOL--a fresh, interned symbol.

Description:
............

ÿgentempþ creates and returns a fresh symbol, interned in the indicated
PACKAGE.  The symbol is guaranteed to be one that was not previously
accessible in PACKAGE.  It is neither bound nor fbound, and has a null
property list.

The name of the NEW-SYMBOL is the concatenation of the PREFIX and a
suffix, which is taken from an internal counter used only by ÿgentempþ.
(If a symbol by that name is already accessible in PACKAGE, the
counter is incremented as many times as is necessary to produce a name
that is not already the name of a symbol accessible in PACKAGE.)

Examples:
.........

 (gentemp) ý T1298
 (gentemp "FOO") ý FOO1299
 (find-symbol "FOO1300") ý NIL, NIL
 (gentemp "FOO") ý FOO1300
 (find-symbol "FOO1300") ý FOO1300, :INTERNAL
 (intern "FOO1301") ý FOO1301, :INTERNAL
 (gentemp "FOO") ý FOO1302
 (gentemp) ý T1303

Side Effects:
.............

Its internal counter is incremented one or more times.

Interns the NEW-SYMBOL in PACKAGE.

Affected By:
............

The current state of its internal counter, and the current state of the
PACKAGE.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if PREFIX is not a string.
Should signal an error of type ÿtype-errorþ if PACKAGE is not a package
designator.

See Also:
.........

*Note gensym::

Notes:
......

The function ÿgentempþ is deprecated.

If PACKAGE is the ÿKEYWORDþ package, the result is an external symbol
of PACKAGE.  Otherwise, the result is an internal symbol of PACKAGE.

The ÿgentempþ internal counter is independent of ÿ*gensym-counter*þ,
the counter used by ÿgensymþ.  There is no provision for accessing the
ÿgentempþ internal counter.

Just because ÿgentempþ creates a symbol which did not previously exist
does not mean that such a symbol might not be seen in the future (e.g.,
in a data file--perhaps even created by the same program in another
session).  As such, this symbol is not truly unique in the same sense
as a gensym would be.  In particular, programs which do automatic code
generation should be careful not to attach global attributes to such
generated symbols (e.g., ÿspecialþ declarations) and then write them
into a file because such global attributes might, in a different
session, end up applying to other symbols that were automatically
generated on another day for some other purpose.


File: chris-ansicl.info,  Node: symbol-function,  Next: symbol-name,  Prev: gentemp,  Up: Symbols

symbol-function (Accessor)
==========================

Syntax:
.......

 -- Function: symbol-function symbol ý contents

(setf (symbol-function symbol) new-contents)

Arguments and Values:
.....................

SYMBOL--a symbol.

CONTENTS-- If the SYMBOL is globally defined as a macro or a special
operator, an object of implementation-dependent nature and identity is
returned.  If the SYMBOL is not globally defined as either a macro or a
special operator, and if the SYMBOL is fbound, a function object is
returned.

NEW-CONTENTS--a function.

Description:
............

Accesses the symbol's function cell.

Examples:
.........

 (symbol-function 'car) ý #<FUNCTION CAR>
 (symbol-function 'twice) is an error   ;because TWICE isn't defined.
 (defun twice (n) (* n 2)) ý TWICE
 (symbol-function 'twice) ý #<FUNCTION TWICE>
 (list (twice 3)
       (funcall (function twice) 3)
       (funcall (symbol-function 'twice) 3))
ý (6 6 6)
 (flet ((twice (x) (list x x)))
   (list (twice 3)
         (funcall (function twice) 3)
         (funcall (symbol-function 'twice) 3)))
ý ((3 3) (3 3) 6)
 (setf (symbol-function 'twice) #'(lambda (x) (list x x)))
ý #<FUNCTION anonymous>
 (list (twice 3)
       (funcall (function twice) 3)
       (funcall (symbol-function 'twice) 3))
ý ((3 3) (3 3) (3 3))
 (fboundp 'defun) ý true
 (symbol-function 'defun)
ý implementation-dependent
 (functionp (symbol-function 'defun))
ý implementation-dependent
 (defun symbol-function-or-nil (symbol)
   (if (and (fboundp symbol)
            (not (macro-function symbol))
            (not (special-operator-p symbol)))
       (symbol-function symbol)
       nil)) ý SYMBOL-FUNCTION-OR-NIL
 (symbol-function-or-nil 'car) ý #<FUNCTION CAR>
 (symbol-function-or-nil 'defun) ý NIL

Affected By:
............

ÿdefunþ

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

Should signal ÿundefined-functionþ if SYMBOL is not fbound and an
attempt is made to read its definition.  (No such error is signaled on
an attempt to write its definition.)

See Also:
.........

*Note fboundp::, *Note fmakunbound::, *Note macro-function::, *Note
special-operator-p::

Notes:
......

ÿsymbol-functionþ cannot access the value of a lexical function name
produced by ÿfletþ or ÿlabelsþ; it can access only the global function
value.

ÿsetfþ may be used with ÿsymbol-functionþ to replace a global function
definition when the symbol's function definition does not represent a
special operator.

(symbol-function SYMBOL) Õ (fdefinition SYMBOL)

However, ÿfdefinitionþ accepts arguments other than just symbols.


File: chris-ansicl.info,  Node: symbol-name,  Next: symbol-package,  Prev: symbol-function,  Up: Symbols

symbol-name (Function)
======================

Syntax:
.......

 -- Function: symbol-name symbol ý name

Arguments and Values:
.....................

SYMBOL--a symbol.

NAME--a string.

Description:
............

ÿsymbol-nameþ returns the name of SYMBOL.  The consequences are
undefined if NAME is ever modified.

Examples:
.........

 (symbol-name 'temp) ý "TEMP"
 (symbol-name :start) ý "START"
 (symbol-name (gensym)) ý "G1234" ;for example

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.


File: chris-ansicl.info,  Node: symbol-package,  Next: symbol-plist,  Prev: symbol-name,  Up: Symbols

symbol-package (Function)
=========================

Syntax:
.......

 -- Function: symbol-package symbol ý contents

Arguments and Values:
.....................

SYMBOL--a symbol.

CONTENTS--a package object or ÿnilþ.

Description:
............

Returns the home package of SYMBOL.

Examples:
.........

 (in-package "CL-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (symbol-package 'car) ý #<PACKAGE "COMMON-LISP">
 (symbol-package 'bus) ý #<PACKAGE "COMMON-LISP-USER">
 (symbol-package :optional) ý #<PACKAGE "KEYWORD">
 ;; Gensyms are uninterned, so have no home package.
 (symbol-package (gensym)) ý NIL
 (make-package 'pk1) ý #<PACKAGE "PK1">
 (intern "SAMPLE1" "PK1") ý PK1::SAMPLE1, NIL
 (export (find-symbol "SAMPLE1" "PK1") "PK1") ý T
 (make-package 'pk2 :use '(pk1)) ý #<PACKAGE "PK2">
 (find-symbol "SAMPLE1" "PK2") ý PK1:SAMPLE1, :INHERITED
 (symbol-package 'pk1::sample1) ý #<PACKAGE "PK1">
 (symbol-package 'pk2::sample1) ý #<PACKAGE "PK1">
 (symbol-package 'pk1::sample2) ý #<PACKAGE "PK1">
 (symbol-package 'pk2::sample2) ý #<PACKAGE "PK2">
 ;; The next several forms create a scenario in which a symbol
 ;; is not really uninterned, but is "apparently uninterned",
 ;; and so SYMBOL-PACKAGE still returns NIL.
 (setq s3 'pk1::sample3) ý PK1::SAMPLE3
 (import s3 'pk2) ý T
 (unintern s3 'pk1) ý T
 (symbol-package s3) ý NIL
 (eq s3 'pk2::sample3) ý T

Affected By:
............

ÿimportþ, ÿinternþ, ÿuninternþ

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

See Also:
.........

*Note intern::


File: chris-ansicl.info,  Node: symbol-plist,  Next: symbol-value,  Prev: symbol-package,  Up: Symbols

symbol-plist (Accessor)
=======================

Syntax:
.......

 -- Function: symbol-plist symbol ý plist

(setf (symbol-plist symbol) new-plist)

Arguments and Values:
.....................

SYMBOL--a symbol.

PLIST, NEW-PLIST--a property list.

Description:
............

Accesses the property list of SYMBOL.

Examples:
.........

 (setq sym (gensym)) ý #:G9723
 (symbol-plist sym) ý ()
 (setf (get sym 'prop1) 'val1) ý VAL1
 (symbol-plist sym) ý (PROP1 VAL1)
 (setf (get sym 'prop2) 'val2) ý VAL2
 (symbol-plist sym) ý (PROP2 VAL2 PROP1 VAL1)
 (setf (symbol-plist sym) (list 'prop3 'val3)) ý (PROP3 VAL3)
 (symbol-plist sym) ý (PROP3 VAL3)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

See Also:
.........

*Note get::, *Note remprop::

Notes:
......

The use of ÿsetfþ should be avoided, since a symbol's property list is
a global resource that can contain information established and depended
upon by unrelated programs in the same Lisp image.


File: chris-ansicl.info,  Node: symbol-value,  Next: get,  Prev: symbol-plist,  Up: Symbols

symbol-value (Accessor)
=======================

Syntax:
.......

 -- Function: symbol-value symbol ý value

(setf (symbol-value symbol) new-value)

Arguments and Values:
.....................

SYMBOL--a symbol that must have a value.

VALUE, NEW-VALUE--an object.

Description:
............

Accesses the symbol's value cell.

Examples:
.........

 (setf (symbol-value 'a) 1) ý 1
 (symbol-value 'a) ý 1
 ;; SYMBOL-VALUE cannot see lexical variables.
 (let ((a 2)) (symbol-value 'a)) ý 1
 (let ((a 2)) (setq a 3) (symbol-value 'a)) ý 1
 ;; SYMBOL-VALUE can see dynamic variables.
 (let ((a 2))
   (declare (special a))
   (symbol-value 'a)) ý 2
 (let ((a 2))
   (declare (special a))
   (setq a 3)
   (symbol-value 'a)) ý 3
 (let ((a 2))
   (setf (symbol-value 'a) 3)
   a) ý 2
 a ý 3
 (symbol-value 'a) ý 3
 (let ((a 4))
   (declare (special a))
   (let ((b (symbol-value 'a)))
     (setf (symbol-value 'a) 5)
     (values a b))) ý 5, 4
 a ý 3
 (symbol-value :any-keyword) ý :ANY-KEYWORD
 (symbol-value 'nil) ý NIL
 (symbol-value '()) ý NIL
 ;; The precision of this next one is implementation-dependent.
 (symbol-value 'pi) ý 3.141592653589793d0

Affected By:
............

ÿmakunboundþ, ÿsetþ, ÿsetqþ

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

Should signal ÿunbound-variableþ if SYMBOL is unbound and an attempt is
made to read its value.  (No such error is signaled on an attempt to
write its value.)

See Also:
.........

*Note boundp::, *Note makunbound::, *Note set::, *Note setq::

Notes:
......

ÿsymbol-valueþ can be used to get the value of a constant variable.
ÿsymbol-valueþ cannot access the value of a lexical variable.


File: chris-ansicl.info,  Node: get,  Next: remprop,  Prev: symbol-value,  Up: Symbols

get (Accessor)
==============

Syntax:
.......

 -- Function: get symbol indicator &optional default ý value

(setf (get symbol indicator &optional default) new-value)

Arguments and Values:
.....................

SYMBOL--a symbol.

INDICATOR--an object.

DEFAULT--an object.  The default is ÿnilþ.

VALUE--if the indicated property exists, the object that is its value;
otherwise, the specified DEFAULT.

NEW-VALUE--an object.

Description:
............

ÿgetþ finds a property on the property listà of SYMBOL whose property
indicator is identical to INDICATOR, and returns its corresponding
property value.  If there are multiple propertiesá with that property
indicator, ÿgetþ uses the first such property.  If there is no property
with that property indicator, DEFAULT is returned.

ÿsetfþ of ÿgetþ may be used to associate a new object with an existing
indicator already on the SYMBOL's property list, or to create a new
assocation if none exists.  If there are multiple propertiesá with that
property indicator, ÿsetfþ of ÿgetþ associates the NEW-VALUE with the
first such property.  When a ÿgetþ form is used as a ÿsetfþ PLACE, any
DEFAULT which is supplied is evaluated according to normal
left-to-right evaluation rules, but its value is ignored.

Examples:
.........

 (defun make-person (first-name last-name)
   (let ((person (gensym "PERSON")))
     (setf (get person 'first-name) first-name)
     (setf (get person 'last-name) last-name)
     person)) ý MAKE-PERSON
 (defvar *john* (make-person "John" "Dow")) ý *JOHN*
 *john* ý #:PERSON4603
 (defvar *sally* (make-person "Sally" "Jones")) ý *SALLY*
 (get *john* 'first-name) ý "John"
 (get *sally* 'last-name) ý "Jones"
 (defun marry (man woman married-name)
   (setf (get man 'wife) woman)
   (setf (get woman 'husband) man)
   (setf (get man 'last-name) married-name)
   (setf (get woman 'last-name) married-name)
   married-name) ý MARRY
 (marry *john* *sally* "Dow-Jones") ý "Dow-Jones"
 (get *john* 'last-name) ý "Dow-Jones"
 (get (get *john* 'wife) 'first-name) ý "Sally"
 (symbol-plist *john*)
ý (WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John")
 (defmacro age (person &optional (default ''thirty-something))
   `(get ,person 'age ,default)) ý AGE
 (age *john*) ý THIRTY-SOMETHING
 (age *john* 20) ý 20
 (setf (age *john*) 25) ý 25
 (age *john*) ý 25
 (age *john* 20) ý 25

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

See Also:
.........

*Note getf::, *Note symbol-plist::, *Note remprop::

Notes:
......

 (get x y) Õ (getf (symbol-plist x) y)

Numbers and characters are not recommended for use as INDICATORS in
portable code since ÿgetþ tests with ÿeqþ rather than ÿeqlþ, and
consequently the effect of using such INDICATORS is
implementation-dependent.

There is no way using ÿgetþ to distinguish an absent property from one
whose value is DEFAULT.  However, see ÿget-propertiesþ.


File: chris-ansicl.info,  Node: remprop,  Next: boundp,  Prev: get,  Up: Symbols

remprop (Function)
==================

Syntax:
.......

 -- Function: remprop symbol indicator ý generalized-boolean

Arguments and Values:
.....................

SYMBOL--a symbol.

INDICATOR--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿrempropþ removes from the property listà of SYMBOL a propertyá with a
property indicator identical to INDICATOR.  If there are multiple
propertiesá with the identical key, ÿrempropþ only removes the first
such property.  ÿrempropþ returns false if no such property was found,
or true if a property was found.

The property indicator and the corresponding property value are removed
in an undefined order by destructively splicing the property list.  The
permissible side-effects correspond to those permitted for ÿremfþ, such
that:

 (remprop x y) Õ (remf (symbol-plist x) y)

Examples:
.........

 (setq test (make-symbol "PSEUDO-PI")) ý #:PSEUDO-PI
 (symbol-plist test) ý ()
 (setf (get test 'constant) t) ý T
 (setf (get test 'approximation) 3.14) ý 3.14
 (setf (get test 'error-range) 'noticeable) ý NOTICEABLE
 (symbol-plist test)
ý (ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)
 (setf (get test 'approximation) nil) ý NIL
 (symbol-plist test)
ý (ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)
 (get test 'approximation) ý NIL
 (remprop test 'approximation) ý true
 (get test 'approximation) ý NIL
 (symbol-plist test)
ý (ERROR-RANGE NOTICEABLE CONSTANT T)
 (remprop test 'approximation) ý NIL
 (symbol-plist test)
ý (ERROR-RANGE NOTICEABLE CONSTANT T)
 (remprop test 'error-range) ý true
 (setf (get test 'approximation) 3) ý 3
 (symbol-plist test)
ý (APPROXIMATION 3 CONSTANT T)

Side Effects:
.............

The property list of SYMBOL is modified.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

See Also:
.........

*Note remf::, *Note symbol-plist::

Notes:
......

Numbers and characters are not recommended for use as INDICATORS in
portable code since ÿrempropþ tests with ÿeqþ rather than ÿeqlþ, and
consequently the effect of using such INDICATORS is
implementation-dependent.  Of course, if you've gotten as far as
needing to remove such a property, you don't have much choice--the time
to have been thinking about this was when you used ÿsetfþ of ÿgetþ to
establish the property.


File: chris-ansicl.info,  Node: boundp,  Next: makunbound,  Prev: remprop,  Up: Symbols

boundp (Function)
=================

Syntax:
.......

 -- Function: boundp symbol ý generalized-boolean

Arguments and Values:
.....................

SYMBOL--a symbol.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if SYMBOL is bound; otherwise, returns false.

Examples:
.........

 (setq x 1) ý 1
 (boundp 'x) ý true
 (makunbound 'x) ý X
 (boundp 'x) ý false
 (let ((x 2)) (boundp 'x)) ý false
 (let ((x 2)) (declare (special x)) (boundp 'x)) ý true

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

See Also:
.........

*Note set::, *Note setq::, *Note symbol-value::, *Note makunbound::

Notes:
......

The function ÿboundþ determines only whether a symbol has a value in
the global environment; any lexical bindings are ignored.


File: chris-ansicl.info,  Node: makunbound,  Next: set,  Prev: boundp,  Up: Symbols

makunbound (Function)
=====================

Syntax:
.......

 -- Function: makunbound symbol ý symbol

Arguments and Values:
.....................

SYMBOL--a symbol

Description:
............

Makes the SYMBOL be unbound, regardless of whether it was previously
bound.

Examples:
.........

 (setf (symbol-value 'a) 1)
 (boundp 'a) ý true
 a ý 1
 (makunbound 'a) ý A
 (boundp 'a) ý false

Side Effects:
.............

The value cell of SYMBOL is modified.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SYMBOL is not a symbol.

See Also:
.........

*Note boundp::, *Note fmakunbound::


File: chris-ansicl.info,  Node: set,  Next: unbound-variable,  Prev: makunbound,  Up: Symbols

set (Function)
==============

Syntax:
.......

 -- Function: set symbol value ý value

Arguments and Values:
.....................

SYMBOL--a symbol.

VALUE--an object.

Description:
............

ÿsetþ changes the contents of the value cell of symbol to the given
value.

(set SYMBOL VALUE) Õ (setf (symbol-value SYMBOL) VALUE)

Examples:
.........

 (setf (symbol-value 'n) 1) ý 1
 (set 'n 2) ý 2
 (symbol-value 'n) ý 2
 (let ((n 3))
   (declare (special n))
   (setq n (+ n 1))
   (setf (symbol-value 'n) (* n 10))
   (set 'n (+ (symbol-value 'n) n))
   n) ý 80
 n ý 2
 (let ((n 3))
   (setq n (+ n 1))
   (setf (symbol-value 'n) (* n 10))
   (set 'n (+ (symbol-value 'n) n))
   n) ý 4
 n ý 44
 (defvar *n* 2)
 (let ((*n* 3))
   (setq *n* (+ *n* 1))
   (setf (symbol-value '*n*) (* *n* 10))
   (set '*n* (+ (symbol-value '*n*) *n*))
   *n*) ý 80
  *n* ý 2
 (defvar *even-count* 0) ý *EVEN-COUNT*
 (defvar *odd-count* 0) ý *ODD-COUNT*
 (defun tally-list (list)
   (dolist (element list)
     (set (if (evenp element) '*even-count* '*odd-count*)
          (+ element (if (evenp element) *even-count* *odd-count*)))))
 (tally-list '(1 9 4 3 2 7)) ý NIL
 *even-count* ý 6
 *odd-count* ý 20

Side Effects:
.............

The value of SYMBOL is changed.

See Also:
.........

*Note setq::, *Note progv::, *Note symbol-value::

Notes:
......

The function ÿsetþ is deprecated.

ÿsetþ cannot change the value of a lexical variable.


File: chris-ansicl.info,  Node: unbound-variable,  Prev: set,  Up: Symbols

unbound-variable (Condition Type)
=================================

Class Precedence List:
......................

ÿunbound-variableþ, ÿcell-errorþ, ÿerrorþ, ÿserious-conditionþ,
ÿconditionþ, ÿtþ

Description:
............

The type ÿunbound-variableþ consists of error conditions that represent
attempts to read the value of an unbound variable.

The name of the cell (see ÿcell-errorþ) is the name of the variable
that was unbound.

See Also:
.........

*Note cell-error-name::


File: chris-ansicl.info,  Node: Packages,  Next: Numbers,  Prev: Symbols,  Up: Top

11 Packages
***********

* Menu:

* Package Concepts::

Dictionary

* package::
* export::
* find-symbol::
* find-package::
* find-all-symbols::
* import::
* list-all-packages::
* rename-package::
* shadow::
* shadowing-import::
* delete-package::
* make-package::
* with-package-iterator::
* unexport::
* unintern::
* in-package::
* unuse-package::
* use-package::
* defpackage::
* do-symbols; do-external-symbols; do-all-symbols::
* intern::
* package-name::
* package-nicknames::
* package-shadowing-symbols::
* package-use-list::
* package-used-by-list::
* packagep::
* *package*::
* package-error::
* package-error-package::


File: chris-ansicl.info,  Node: Package Concepts,  Next: package,  Up: Packages

11.1 Package Concepts
=====================

* Menu:

* Introduction to Packages::
* Standardized Packages::


File: chris-ansicl.info,  Node: Introduction to Packages,  Next: Standardized Packages,  Up: Package Concepts

11.1.1 Introduction to Packages
-------------------------------

A "package" establishes a mapping from names to symbols.  At any given
time, one package is current.  The "current package" is the one that is
the value of ÿ*package*þ.  When using the Lisp reader, it is possible
to refer to symbols in packages other than the current one through the
use of package prefixes in the printed representation of the symbol.

The next figure lists some defined names that are applicable to
packages.  Where an operator takes an argument that is either a symbol
or a list of symbols, an argument of ÿnilþ is treated as an empty list
of symbols.  Any PACKAGE argument may be either a string, a symbol, or
a package.  If a symbol is supplied, its name will be used as the
package name.

*modules*             import                      provide
*package*             in-package                  rename-package
defpackage            intern                      require
do-all-symbols        list-all-packages           shadow
do-external-symbols   make-package                shadowing-import
do-symbols            package-name                unexport
export                package-nicknames           unintern
find-all-symbols      package-shadowing-symbols   unuse-package
find-package          package-use-list            use-package
find-symbol           package-used-by-list        

Figure 11.1: Some Defined Names related to Packages

11.1.1.1 Package Names and Nicknames
....................................

Each package has a name (a string) and perhaps some nicknames (also
strings).  These are assigned when the package is created and can be
changed later.

There is a single namespace for packages.  The function ÿfind-packageþ
translates a package name or nickname into the associated package.  The
function ÿpackage-nameþ returns the name of a package.  The function
ÿpackage-nicknamesþ returns a list of all nicknames for a package.
ÿrename-packageþ removes a package's current name and nicknames and
replaces them with new ones specified by the caller.

11.1.1.2 Symbols in a Package
.............................

11.1.1.2.1 Internal and External Symbols
........................................

The mappings in a package are divided into two classes, external and
internal.  The symbols targeted by these different mappings are called
external symbols and internal symbols of the package. Within a package,
a name refers to one symbol or to none; if it does refer to a symbol,
then it is either external or internal in that package, but not both.  "External
symbols" are part of the package's public interface to other packages.
Symbols become external symbols of a given package if they have been
exported from that package.

A symbol has the same name no matter what package it is present in, but
it might be an external symbol of some packages and an internal symbol
of others.

11.1.1.2.2 Package Inheritance
..............................

Packages can be built up in layers.  From one point of view, a package
is a single collection of mappings from strings into internal symbols
and external symbols.  However, some of these mappings might be
established within the package itself, while other mappings are
inherited from other packages via ÿuse-packageþ.  A symbol is said to
be "present" in a package if the mapping is in the package itself and is
not inherited from somewhere else.

There is no way to inherit the internal symbols of another package; to
refer to an internal symbol using the Lisp reader, a package containing
the symbol must be made to be the current package, a package prefix
must be used, or the symbol must be imported into the current package.

11.1.1.2.3 Accessibility of Symbols in a Package
................................................

A symbol becomes "accessible" in a package if that is its home package
when it is created, or if it is imported into that package, or by
inheritance via ÿuse-packageþ.

If a symbol is accessible in a package, it can be referred to when
using the Lisp reader without a package prefix when that package is the
current package, regardless of whether it is present or inherited.

Symbols from one package can be made accessible in another package in
two ways.

   - Any individual symbol can be added to a package by use of
     ÿimportþ.  After the call to ÿimportþ the symbol is present in the
     importing package.  The status of the symbol in the package it
     came from (if any) is unchanged, and the home package for this
     symbol is unchanged.  Once imported, a symbol is present in the
     importing package and can be removed only by calling ÿuninternþ.

     A symbol is shadowedß by another symbol in some package if the
     first symbol would be accessible by inheritance if not for the
     presence of the second symbol.  See ÿshadowing-importþ.

   - The second mechanism for making symbols from one package
     accessible in another is provided by ÿuse-packageþ.  All of the
     external symbols of the used package are inherited by the using
     package.  The function ÿunuse-packageþ undoes the effects of a
     previous ÿuse-packageþ.

11.1.1.2.4 Locating a Symbol in a Package
.........................................

When a symbol is to be located in a given package the following occurs:

   - The external symbols and internal symbols of the package are
     searched for the symbol.

   - The external symbols of the used packages are searched in some
     unspecified order.  The order does not matter; see the rules for
     handling name conflicts listed below.

11.1.1.2.5 Prevention of Name Conflicts in Packages
...................................................

Within one package, any particular name can refer to at most one
symbol.  A name conflict is said to occur when there would be more than
one candidate symbol.  Any time a name conflict is about to occur, a
correctable error is signaled.

The following rules apply to name conflicts:

   - Name conflicts are detected when they become possible, that is,
     when the package structure is altered.  Name conflicts are not
     checked during every name lookup.

   - If the same symbol is accessible to a package through more than
     one path, there is no name conflict.  A symbol cannot conflict
     with itself.  Name conflicts occur only between distinct symbols
     with the same name (under ÿstring=þ).

   - Every package has a list of shadowing symbols.  A shadowing symbol
     takes precedence over any other symbol of the same name that would
     otherwise be accessible in the package.  A name conflict involving
     a shadowing symbol is always resolved in favor of the shadowing
     symbol, without signaling an error (except for one exception
     involving ÿimportþ).  See ÿshadowþ and ÿshadowing-importþ.

   - The functions ÿuse-packageþ, ÿimportþ, and ÿexportþ check for name
     conflicts.

   - ÿshadowþ and ÿshadowing-importþ never signal a name-conflict error.

   - ÿunuse-packageþ and ÿunexportþ do not need to do any name-conflict
     checking.  ÿuninternþ does name-conflict checking only when a
     symbol being uninterned is a shadowing symbol .

   - Giving a shadowing symbol to ÿuninternþ can uncover a name
     conflict that had previously been resolved by the shadowing.

   - Package functions signal name-conflict errors of type
     ÿpackage-errorþ before making any change to the package structure.
     When multiple changes are to be made, it is permissible for the
     implementation to process each change separately.  For example,
     when ÿexportþ is given a list of symbols, aborting from a name
     conflict caused by the second symbol in the list might still
     export the first symbol in the list.  However, a name-conflict
     error caused by ÿexportþ of a single symbol will be signaled before
     that symbol's accessibility in any package is changed.

   - Continuing from a name-conflict error must offer the user a chance
     to resolve the name conflict in favor of either of the candidates.
     The package structure should be altered to reflect the resolution
     of the name conflict, via ÿshadowing-importþ, ÿuninternþ, or
     ÿunexportþ.

   - A name conflict in ÿuse-packageþ between a symbol present in the
     using package and an external symbol of the used package is
     resolved in favor of the first symbol by making it a shadowing
     symbol, or in favor of the second symbol by uninterning the first
     symbol from the using package.

   - A name conflict in ÿexportþ or ÿuninternþ due to a package's
     inheriting two distinct symbols with the same name (under
     ÿstring=þ) from two other packages can be resolved in favor of
     either symbol by importing it into the using package and making it
     a shadowing symbol , just as with ÿuse-packageþ.


File: chris-ansicl.info,  Node: Standardized Packages,  Prev: Introduction to Packages,  Up: Package Concepts

11.1.2 Standardized Packages
----------------------------

This section describes the packages that are available in every
conforming implementation.  A summary of the names and nicknames of
those standardized packages is given in the next figure.

Name                 Nicknames
--------------------------------- 
ÿCOMMON-LISPþ        ÿCLþ
ÿCOMMON-LISP-USERþ   ÿCL-USERþ
ÿKEYWORDþ            none

Figure 11.2: Standardized Package Names

11.1.2.1 The COMMON-LISP Package
................................

The ÿCOMMON-LISPþ package contains the primitives of the Common
Lisp system as defined by this specification.  Its external symbols
include all of the defined names (except for defined names in the
ÿKEYWORDþ package) that are present in the Common Lisp system, such as
ÿcarþ, ÿcdrþ,  ÿ*package*þ, etc.  The ÿCOMMON-LISPþ package has the
nickname ÿCLþ.

The ÿCOMMON-LISPþ package has as external symbols those symbols
enumerated in the figures in *Note Section 1.9 (Symbols in the
COMMON-LISP Package): Symbols in the COMMON-LISP Package, and no others.
These external symbols are present in the ÿCOMMON-LISPþ package but
their home package need not be the ÿCOMMON-LISPþ package.

For example, the symbol ÿHELPþ cannot be an external symbol of the
ÿCOMMON-LISPþ package because it is not mentioned in *Note Section 1.9
(Symbols in the COMMON-LISP Package): Symbols in the COMMON-LISP
Package.  In contrast, the symbol variable must be an external symbol
of the ÿCOMMON-LISPþ package even though it has no definition because
it is listed in that section (to support its use as a valid second
argument to the function ÿdocumentationþ).

The ÿCOMMON-LISPþ package can have additional internal symbols.

11.1.2.1.1 Constraints on the COMMON-LISP Package for Conforming Implementations
................................................................................

In a conforming implementation, an external symbol of the ÿCOMMON-LISPþ
package can have a function, macro, or special operator definition, a
global variable definition (or other status as a dynamic variable due
to a ÿspecialþ proclamation), or a type definition only if explicitly
permitted in this standard.  For example, ÿfboundpþ yields false for
any external symbol of the ÿCOMMON-LISPþ package that is not the name
of a standardized function, macro or special operator, and ÿboundpþ
returns false for any external symbol of the ÿCOMMON-LISPþ package that
is not the name of a standardized global variable.  It also follows that
conforming programs can use external symbols of the ÿCOMMON-LISPþ
package as the names of local lexical variables with confidence that
those names have not been proclaimed ÿspecialþ by the implementation
unless those symbols are names of standardized global variables.

A conforming implementation must not place any property on an external
symbol of the ÿCOMMON-LISPþ package using a property indicator that is
either an external symbol of any standardized package or a symbol that
is otherwise accessible in the ÿCOMMON-LISP-USERþ package.

11.1.2.1.2 Constraints on the COMMON-LISP Package for Conforming Programs
.........................................................................

Except where explicitly allowed, the consequences are undefined if any
of the following actions are performed on an external symbol of the
ÿCOMMON-LISPþ package:

  1. Binding or altering its value (lexically or dynamically).  (Some
     exceptions are noted below.)

  2. Defining, undefining, or binding it as a function.  (Some
     exceptions are noted below.)

  3. Defining, undefining, or binding it as a macro or compiler macro.
     (Some exceptions are noted below.)

  4. Defining it as a type specifier (via ÿdefstructþ, ÿdefclassþ,
     ÿdeftypeþ, ÿdefine-conditionþ).

  5. Defining it as a structure (via ÿdefstructþ).

  6. Defining it as a declaration with a ÿdeclarationþ proclamation.

  7. Defining it as a symbol macro.

  8. Altering its home package.

  9. Tracing it  (via ÿtraceþ).

 10. Declaring or proclaiming it ÿspecialþ (via declare, ÿdeclaimþ, or
     ÿproclaimþ).

 11. Declaring or proclaiming its ÿtypeþ or ÿftypeþ (via declare,
     ÿdeclaimþ, or ÿproclaimþ).  (Some exceptions are noted below.)

 12. Removing it from the ÿCOMMON-LISPþ package.

 13. Defining a setf expander for it (via ÿdefsetfþ or
     ÿdefine-setf-methodþ).

 14. Defining, undefining, or binding its setf function name.

 15. Defining it as a method combination type (via
     ÿdefine-method-combinationþ).

 16. Using it as the class-name argument to ÿsetfþ of ÿfind-classþ.

 17. Binding it as a catch tag.

 18. Binding it as a restart name.

 19. Defining a method for a standardized generic function which is
     applicable when all of the arguments are direct instances of
     standardized classes.


11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs
..............................................................................................

If an external symbol of the ÿCOMMON-LISPþ package is not globally
defined as a standardized dynamic variable or constant variable, it is
allowed to lexically bind it and to declare the ÿtypeþ of that binding,
and it is allowed to locally establish it as a symbol macro (e.g., with
ÿsymbol-macroletþ).

Unless explicitly specified otherwise, if an external symbol of the
ÿCOMMON-LISPþ package is globally defined as a standardized dynamic
variable, it is permitted to bind or assign that dynamic variable
provided that the "Value Type" constraints on the dynamic variable are
maintained, and that the new value of the variable is consistent with
the stated purpose of the variable.

If an external symbol of the ÿCOMMON-LISPþ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a function (e.g., with ÿfletþ), to declare the
ÿftypeþ of that binding, and (in implementations which provide the
ability to do so) to ÿtraceþ that binding.

If an external symbol of the ÿCOMMON-LISPþ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a macro (e.g., with ÿmacroletþ).

If an external symbol of the ÿCOMMON-LISPþ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind its setf function name as a function, and to declare the
ÿftypeþ of that binding.

11.1.2.2 The COMMON-LISP-USER Package
.....................................

The ÿCOMMON-LISP-USERþ package is the current package when a Common
Lisp system starts up.  This package uses the ÿCOMMON-LISPþ package.
The ÿCOMMON-LISP-USERþ package has the nickname ÿCL-USERþ.  The
ÿCOMMON-LISP-USERþ package can have additional symbols interned within
it; it can use other implementation-defined packages.

11.1.2.3 The KEYWORD Package
............................

The ÿKEYWORDþ package contains symbols, called keywordsá, that are
typically used as special markers in programs and their associated data
expressionsá.

Symbol tokens that start with a package marker are parsed by the Lisp
reader as symbols in the ÿKEYWORDþ package; see *Note Section 2.3.4
(Symbols as Tokens): Symbols as Tokens.  This makes it notationally
convenient to use keywords when communicating between programs in
different packages.  For example, the mechanism for passing keyword
parameters in a call uses keywordsá to name the corresponding arguments;
see *Note Section 3.4.1 (Ordinary Lambda Lists): Ordinary Lambda Lists.

Symbols in the ÿKEYWORDþ package are, by definition, of type ÿkeywordþ.

11.1.2.3.1 Interning a Symbol in the KEYWORD Package
....................................................

The ÿKEYWORDþ package is treated differently than other packages in
that special actions are taken when a symbol is interned in it.  In
particular, when a symbol is interned in the ÿKEYWORDþ package, it is
automatically made to be an external symbol and is automatically made
to be a constant variable with itself as a value.

11.1.2.3.2 Notes about The KEYWORD Package
..........................................

It is generally best to confine the use of keywords to situations in
which there are a finitely enumerable set of names to be selected
between.  For example, if there were two states of a light switch, they
might be called :on and :off.

In situations where the set of names is not finitely enumerable (i.e.,
where name conflicts might arise) it is frequently best to use symbols
in some package other than ÿKEYWORDþ so that conflicts will be
naturally avoided.  For example, it is generally not wise for a program
to use a keywordá as a property indicator, since if there were ever
another program that did the same thing, each would clobber the other's
data.

11.1.2.4 Implementation-Defined Packages
........................................

Other, implementation-defined packages might be present in the initial
Common Lisp environment.

It is recommended, but not required, that the documentation for a
conforming implementation contain a full list of all package names
initially present in that implementation but not specified in this
specification.  (See also the function ÿlist-all-packagesþ.)


File: chris-ansicl.info,  Node: package,  Next: export,  Prev: Package Concepts,  Up: Packages

package (System Class)
======================

Class Precedence List:
......................

ÿpackageþ, ÿtþ

Description:
............

A package is a namespace that maps symbol names to symbols; see *Note
Section 11.1 (Package Concepts): Package Concepts.

See Also:
.........

*Note Section 11.1 (Package Concepts): Package Concepts, *Note Section
22.1.3.13 (Printing Other Objects): PrintingOtherObjects, *Note Section
2.3.4 (Symbols as Tokens): Symbols as Tokens.


File: chris-ansicl.info,  Node: export,  Next: find-symbol,  Prev: package,  Up: Packages

export (Function)
=================

Syntax:
.......

 -- Function: export symbols &optional package ý ÿtþ

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE--a package designator.  The default is the current package.

Description:
............

ÿexportþ makes one or more SYMBOLS that are accessible in PACKAGE
(whether directly or by inheritance) be external symbols of that
PACKAGE.

If any of the SYMBOLS is already accessible as an external symbol of
PACKAGE, ÿexportþ has no effect on that symbol.  If the SYMBOL is
present in PACKAGE as an internal symbol, it is simply changed to
external status.  If it is accessible as an internal symbol via
ÿuse-packageþ, it is first imported into PACKAGE, then exported.  (The
SYMBOL is then present in the PACKAGE whether or not PACKAGE continues
to use the package through which the symbol was originally inherited.)

ÿexportþ makes each SYMBOL accessible to all the packages that use
PACKAGE.  All of these packages are checked for name conflicts:
ÿ(export s p)þ does ÿ(find-symbol (symbol-name s) q)þ for each package q
in ÿ(package-used-by-list p)þ.  Note that in the usual case of an
ÿexportþ during the initial definition of a package, the result of
ÿpackage-used-by-listþ is ÿnilþ and the name-conflict checking takes
negligible time.  When multiple changes are to be made, for example
when ÿexportþ is given a LIST of SYMBOLS, it is permissible for the
implementation to process each change separately, so that aborting from
a name conflict caused by any but the first SYMBOL in the list does not
unexport the first SYMBOL in the LIST.  However, aborting from a
name-conflict error caused by ÿexportþ of one of SYMBOLS does not leave
that symbol accessible to some packages and inaccessible to others;
with respect to each of SYMBOLS processed, ÿexportþ behaves as if it
were as an atomic operation.

A name conflict in ÿexportþ between one of SYMBOLS being exported and a
symbol already present in a package that would inherit the
newly-exported symbol may be resolved in favor of the exported symbol
by uninterning the other one, or in favor of the already-present symbol
by making it a shadowing symbol.

Examples:
.........

 (make-package 'temp :use nil) ý #<PACKAGE "TEMP">
 (use-package 'temp) ý T
 (intern "TEMP-SYM" 'temp) ý TEMP::TEMP-SYM, NIL
 (find-symbol "TEMP-SYM") ý NIL, NIL
 (export (find-symbol "TEMP-SYM" 'temp) 'temp) ý T
 (find-symbol "TEMP-SYM") ý TEMP-SYM, :INHERITED

Side Effects:
.............

The package system is modified.

Affected By:
............

Accessible symbols.

Exceptional Situations:
.......................

If any of the SYMBOLS is not accessible at all in PACKAGE, an error of
type ÿpackage-errorþ is signaled that is correctable by permitting the
user to interactively specify whether that symbol should be imported.

See Also:
.........

*Note import::, *Note unexport::, *Note Section 11.1 (Package
Concepts): Package Concepts.


File: chris-ansicl.info,  Node: find-symbol,  Next: find-package,  Prev: export,  Up: Packages

find-symbol (Function)
======================

Syntax:
.......

 -- Function: find-symbol string &optional package ý symbol, status

Arguments and Values:
.....................

STRING--a string.

PACKAGE--a package designator.  The default is the current package.

SYMBOL--a symbol accessible in the PACKAGE, or ÿnilþ.

STATUS--one of :inherited, :external, :internal, or ÿnilþ.

Description:
............

ÿfind-symbolþ locates a symbol whose name is STRING in a package.  If a
symbol named STRING is found in PACKAGE, directly or by inheritance,
the symbol found is returned as the first value; the second value is as
follows:

:internal
     If the symbol is present in PACKAGE as an internal symbol.

:external
     If the symbol is present in PACKAGE as an external symbol.

:inherited
     If the symbol is inherited by PACKAGE through ÿuse-packageþ, but
     is not present in PACKAGE.

If no such symbol is accessible in PACKAGE, both values are ÿnilþ.

Examples:
.........

 (find-symbol "NEVER-BEFORE-USED") ý NIL, NIL
 (find-symbol "NEVER-BEFORE-USED") ý NIL, NIL
 (intern "NEVER-BEFORE-USED") ý NEVER-BEFORE-USED, NIL
 (intern "NEVER-BEFORE-USED") ý NEVER-BEFORE-USED, :INTERNAL
 (find-symbol "NEVER-BEFORE-USED") ý NEVER-BEFORE-USED, :INTERNAL
 (find-symbol "never-before-used") ý NIL, NIL
 (find-symbol "CAR" 'common-lisp-user) ý CAR, :INHERITED
 (find-symbol "CAR" 'common-lisp) ý CAR, :EXTERNAL
 (find-symbol "NIL" 'common-lisp-user) ý NIL, :INHERITED
 (find-symbol "NIL" 'common-lisp) ý NIL, :EXTERNAL
 (find-symbol "NIL" (prog1 (make-package "JUST-TESTING" :use '())
                           (intern "NIL" "JUST-TESTING")))
ý JUST-TESTING::NIL, :INTERNAL
 (export 'just-testing::nil 'just-testing)
 (find-symbol "NIL" 'just-testing) ý JUST-TESTING:NIL, :EXTERNAL
 (find-symbol "NIL" "KEYWORD")
ý NIL, NIL
orý :NIL, :EXTERNAL
 (find-symbol (symbol-name :nil) "KEYWORD") ý :NIL, :EXTERNAL

Affected By:
............

ÿinternþ, ÿimportþ, ÿexportþ, ÿuse-packageþ, ÿuninternþ, ÿunexportþ,
ÿunuse-packageþ

See Also:
.........

*Note intern::, *Note find-all-symbols::

Notes:
......

ÿfind-symbolþ is operationally equivalent to ÿinternþ, except that it
never creates a new symbol.


File: chris-ansicl.info,  Node: find-package,  Next: find-all-symbols,  Prev: find-symbol,  Up: Packages

find-package (Function)
=======================

Syntax:
.......

 -- Function: find-package name ý package

Arguments and Values:
.....................

NAME--a string designator or a package object.

PACKAGE--a package object or ÿnilþ.

Description:
............

If NAME is a string designator, ÿfind-packageþ locates and returns the
package whose name or nickname is NAME.  This search is case sensitive.
If there is no such package, ÿfind-packageþ returns ÿnilþ.

If NAME is a package object, that package object is returned.

Examples:
.........

 (find-package 'common-lisp) ý #<PACKAGE "COMMON-LISP">
 (find-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (find-package 'not-there) ý NIL

Affected By:
............

The set of packages created by the implementation.

ÿdefpackageþ, ÿdelete-packageþ, ÿmake-packageþ, ÿrename-packageþ

See Also:
.........

*Note make-package::


File: chris-ansicl.info,  Node: find-all-symbols,  Next: import,  Prev: find-package,  Up: Packages

find-all-symbols (Function)
===========================

Syntax:
.......

 -- Function: find-all-symbols string ý symbols

Arguments and Values:
.....................

STRING--a string designator.

SYMBOLS--a list of symbols.

Description:
............

ÿfind-all-symbolsþ searches name that is the same (under ÿstring=þ) as
STRING.  A list of all such symbols is returned.  Whether or how the
list is ordered is implementation-dependent.

Examples:
.........

 (find-all-symbols 'car)
ý (CAR)
orý (CAR VEHICLES:CAR)
orý (VEHICLES:CAR CAR)
 (intern "CAR" (make-package 'temp :use nil)) ý TEMP::CAR, NIL
 (find-all-symbols 'car)
ý (TEMP::CAR CAR)
orý (CAR TEMP::CAR)
orý (TEMP::CAR CAR VEHICLES:CAR)
orý (CAR TEMP::CAR VEHICLES:CAR)

See Also:
.........

*Note find-symbol::


File: chris-ansicl.info,  Node: import,  Next: list-all-packages,  Prev: find-all-symbols,  Up: Packages

import (Function)
=================

Syntax:
.......

 -- Function: import symbols &optional package ý ÿtþ

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE--a package designator.  The default is the current package.

Description:
............

ÿimportþ adds SYMBOL or SYMBOLS to the internals of PACKAGE, checking
for name conflicts with existing symbols either present in PACKAGE or
accessible to it.  Once the SYMBOLS have been imported, they may be
referenced in the importing PACKAGE without the use of a package prefix
when using the Lisp reader.

A name conflict in ÿimportþ between the SYMBOL being imported and a
symbol inherited from some other package can be resolved in favor of the
SYMBOL being imported by making it a shadowing symbol, or in favor of
the symbol already accessible by not doing the ÿimportþ.  A name
conflict in ÿimportþ with a symbol already present in the PACKAGE may
be resolved by uninterning that symbol, or by not doing the ÿimportþ.

The imported symbol is not automatically exported from the current
package, but if it is already present and external, then the fact that
it is external is not changed.  If any symbol to be imported has no home
package (i.e., ÿ(symbol-package SYMBOL) ý nilþ), ÿimportþ sets the home
package of the SYMBOL to PACKAGE.

If the SYMBOL is already present in the importing PACKAGE, ÿimportþ has
no effect.

Examples:
.........

 (import 'common-lisp::car (make-package 'temp :use nil)) ý T
 (find-symbol "CAR" 'temp) ý CAR, :INTERNAL
 (find-symbol "CDR" 'temp) ý NIL, NIL

The form ÿ(import 'editor:buffer)þ takes the external symbol named
ÿbufferþ in the ÿEDITORþ package (this symbol was located when the form
was read by the Lisp reader) and adds it to the current package as an
internal symbol. The symbol ÿbufferþ is then present in the current
package.

Side Effects:
.............

The package system is modified.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

ÿimportþ signals a correctable error of type ÿpackage-errorþ if any of
the SYMBOLS to be imported has the same name (under ÿstring=þ) as some
distinct symbol (under ÿeqlþ) already accessible in the PACKAGE, even
if the conflict is with a shadowing symbol of the PACKAGE.

See Also:
.........

*Note shadow::, *Note export::


File: chris-ansicl.info,  Node: list-all-packages,  Next: rename-package,  Prev: import,  Up: Packages

list-all-packages (Function)
============================

Syntax:
.......

 -- Function: list-all-packages <no arguments> ý packages

Arguments and Values:
.....................

PACKAGES--a list of package objects.

Description:
............

ÿlist-all-packagesþ returns a fresh list of all registered packages.

Examples:
.........

 (let ((before (list-all-packages)))
    (make-package 'temp)
    (set-difference (list-all-packages) before)) ý (#<PACKAGE "TEMP">)

Affected By:
............

ÿdefpackageþ, ÿdelete-packageþ, ÿmake-packageþ


File: chris-ansicl.info,  Node: rename-package,  Next: shadow,  Prev: list-all-packages,  Up: Packages

rename-package (Function)
=========================

Syntax:
.......

 -- Function: rename-package package new-name &optional new-nicknames ý
          package-object

Arguments and Values:
.....................

PACKAGE--a package designator.

NEW-NAME--a package designator.

NEW-NICKNAMES--a list of string designators.  The default is the empty
list.

PACKAGE-OBJECT--the renamed PACKAGE object.

Description:
............

Replaces the name and nicknames of PACKAGE.  The old name and all of
the old nicknames of PACKAGE are eliminated and are replaced by
NEW-NAME and NEW-NICKNAMES.

The consequences are undefined if NEW-NAME or any NEW-NICKNAME
conflicts with any existing package names.

Examples:
.........

 (make-package 'temporary :nicknames '("TEMP")) ý #<PACKAGE "TEMPORARY">
 (rename-package 'temp 'ephemeral) ý #<PACKAGE "EPHEMERAL">
 (package-nicknames (find-package 'ephemeral)) ý ()
 (find-package 'temporary) ý NIL
 (rename-package 'ephemeral 'temporary '(temp fleeting))
ý #<PACKAGE "TEMPORARY">
 (package-nicknames (find-package 'temp)) ý ("TEMP" "FLEETING")

See Also:
.........

*Note make-package::


File: chris-ansicl.info,  Node: shadow,  Next: shadowing-import,  Prev: rename-package,  Up: Packages

shadow (Function)
=================

Syntax:
.......

 -- Function: shadow symbol-names &optional package ý ÿtþ

Arguments and Values:
.....................

SYMBOL-NAMES--a designator for a list of string designators.

PACKAGE--a package designator.  The default is the current package.

Description:
............

ÿshadowþ assures that symbols with names given by SYMBOL-NAMES are
present in the PACKAGE.

Specifically, PACKAGE is searched for symbols with the names supplied
by SYMBOL-NAMES.  For each such name, if a corresponding symbol is not
present in PACKAGE (directly, not by inheritance), then a corresponding
symbol is created with that name, and inserted into PACKAGE as an
internal symbol.  The corresponding symbol, whether pre-existing or
newly created, is then added, if not already present, to the shadowing
symbols list of PACKAGE.

Examples:
.........

 (package-shadowing-symbols (make-package 'temp)) ý NIL
 (find-symbol 'car 'temp) ý CAR, :INHERITED
 (shadow 'car 'temp) ý T
 (find-symbol 'car 'temp) ý TEMP::CAR, :INTERNAL
 (package-shadowing-symbols 'temp) ý (TEMP::CAR)

 (make-package 'test-1) ý #<PACKAGE "TEST-1">
 (intern "TEST" (find-package 'test-1)) ý TEST-1::TEST, NIL
 (shadow 'test-1::test (find-package 'test-1)) ý T
 (shadow 'TEST (find-package 'test-1)) ý T
 (assert (not (null (member 'test-1::test (package-shadowing-symbols
                                            (find-package 'test-1))))))

 (make-package 'test-2) ý #<PACKAGE "TEST-2">
 (intern "TEST" (find-package 'test-2)) ý TEST-2::TEST, NIL
 (export 'test-2::test (find-package 'test-2)) ý T
 (use-package 'test-2 (find-package 'test-1))    ;should not error

Side Effects:
.............

ÿshadowþ changes the state of the package system in such a way that the
package consistency rules do not hold across the change.

Affected By:
............

Current state of the package system.

See Also:
.........

*Note package-shadowing-symbols::, *Note Section 11.1 (Package
Concepts): Package Concepts.

Notes:
......

If a symbol with a name in SYMBOL-NAMES already exists in PACKAGE, but
by inheritance, the inherited symbol becomes shadowedß by a newly
created internal symbol.


File: chris-ansicl.info,  Node: shadowing-import,  Next: delete-package,  Prev: shadow,  Up: Packages

shadowing-import (Function)
===========================

Syntax:
.......

 -- Function: shadowing-import symbols &optional package ý ÿtþ

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE --a package designator.  The default is the current package.

Description:
............

ÿshadowing-importþ is like ÿimportþ, but it does not signal an error
even if the importation of a symbol would shadow some symbol already
accessible in PACKAGE.

ÿshadowing-importþ inserts each of SYMBOLS into PACKAGE as an internal
symbol, regardless of whether another symbol of the same name is
shadowed by this action.  If a different symbol of the same name is
already present in PACKAGE, that symbol is first uninterned from
PACKAGE.  The new symbol is added to PACKAGE's shadowing-symbols list.

ÿshadowing-importþ does name-conflict checking to the extent that it
checks whether a distinct existing symbol with the same name is
accessible; if so, it is shadowed by the new symbol, which implies that
it must be uninterned if it was present in PACKAGE.

Examples:
.........

 (in-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (setq sym (intern "CONFLICT")) ý CONFLICT
 (intern "CONFLICT" (make-package 'temp)) ý TEMP::CONFLICT, NIL
 (package-shadowing-symbols 'temp) ý NIL
 (shadowing-import sym 'temp) ý T
 (package-shadowing-symbols 'temp) ý (CONFLICT)

Side Effects:
.............

ÿshadowing-importþ changes the state of the package system in such a
way that the consistency rules do not hold across the change.

PACKAGE's shadowing-symbols list is modified.

Affected By:
............

Current state of the package system.

See Also:
.........

*Note import::, *Note unintern::, *Note package-shadowing-symbols::


File: chris-ansicl.info,  Node: delete-package,  Next: make-package,  Prev: shadowing-import,  Up: Packages

delete-package (Function)
=========================

Syntax:
.......

 -- Function: delete-package package ý generalized-boolean

Arguments and Values:
.....................

PACKAGE--a package designator.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿdelete-packageþ deletes PACKAGE from all package system data
structures.  If the operation is successful, ÿdelete-packageþ returns
true, otherwise ÿnilþ.  The effect of ÿdelete-packageþ is that the name
and nicknames of PACKAGE cease to be recognized package names.  The
package object is still a package (i.e., ÿpackagepþ is true of it) but
ÿpackage-nameþ returns ÿnilþ.  The consequences of deleting the
ÿCOMMON-LISPþ package or the ÿKEYWORDþ package are undefined.  The
consequences of invoking any other package operation on PACKAGE once it
has been deleted are unspecified.  In particular, the consequences of
invoking ÿfind-symbolþ, ÿinternþ and other functions that look for a
symbol name in a package are unspecified if they are called with
ÿ*package*þ bound to the deleted PACKAGE or with the deleted PACKAGE as
an argument.

If PACKAGE is a package object that has already been deleted,
ÿdelete-packageþ immediately returns ÿnilþ.

After this operation completes, the home package of any symbol whose
home package had previously been PACKAGE is implementation-dependent.
Except for this, symbols accessible in PACKAGE are not modified in any
other way; symbols whose home package is not PACKAGE remain unchanged.

Examples:
.........

 (setq *foo-package* (make-package "FOO" :use nil))
 (setq *foo-symbol*  (intern "FOO" *foo-package*))
 (export *foo-symbol* *foo-package*)

 (setq *bar-package* (make-package "BAR" :use '("FOO")))
 (setq *bar-symbol*  (intern "BAR" *bar-package*))
 (export *foo-symbol* *bar-package*)
 (export *bar-symbol* *bar-package*)

 (setq *baz-package* (make-package "BAZ" :use '("BAR")))

 (symbol-package *foo-symbol*) ý #<PACKAGE "FOO">
 (symbol-package *bar-symbol*) ý #<PACKAGE "BAR">

 (prin1-to-string *foo-symbol*) ý "FOO:FOO"
 (prin1-to-string *bar-symbol*) ý "BAR:BAR"

 (find-symbol "FOO" *bar-package*) ý FOO:FOO, :EXTERNAL

 (find-symbol "FOO" *baz-package*) ý FOO:FOO, :INHERITED
 (find-symbol "BAR" *baz-package*) ý BAR:BAR, :INHERITED

 (packagep *foo-package*) ý true
 (packagep *bar-package*) ý true
 (packagep *baz-package*) ý true

 (package-name *foo-package*) ý "FOO"
 (package-name *bar-package*) ý "BAR"
 (package-name *baz-package*) ý "BAZ"

 (package-use-list *foo-package*) ý ()
 (package-use-list *bar-package*) ý (#<PACKAGE "FOO">)
 (package-use-list *baz-package*) ý (#<PACKAGE "BAR">)

 (package-used-by-list *foo-package*) ý (#<PACKAGE "BAR">)
 (package-used-by-list *bar-package*) ý (#<PACKAGE "BAZ">)
 (package-used-by-list *baz-package*) ý ()

 (delete-package *bar-package*)
Ö Error: Package BAZ uses package BAR.
Ö If continued, BAZ will be made to unuse-package BAR,
Ö and then BAR will be deleted.
Ö Type :CONTINUE to continue.
Ö Debug> :CONTINUE
ý T

 (symbol-package *foo-symbol*) ý #<PACKAGE "FOO">
 (symbol-package *bar-symbol*) is unspecified

 (prin1-to-string *foo-symbol*) ý "FOO:FOO"
 (prin1-to-string *bar-symbol*) is unspecified

 (find-symbol "FOO" *bar-package*) is unspecified

 (find-symbol "FOO" *baz-package*) ý NIL, NIL
 (find-symbol "BAR" *baz-package*) ý NIL, NIL

 (packagep *foo-package*) ý T
 (packagep *bar-package*) ý T
 (packagep *baz-package*) ý T

 (package-name *foo-package*) ý "FOO"
 (package-name *bar-package*) ý NIL
 (package-name *baz-package*) ý "BAZ"

 (package-use-list *foo-package*) ý ()
 (package-use-list *bar-package*) is unspecified
 (package-use-list *baz-package*) ý ()

 (package-used-by-list *foo-package*) ý ()
 (package-used-by-list *bar-package*) is unspecified
 (package-used-by-list *baz-package*) ý ()

Exceptional Situations:
.......................

If the PACKAGE designator is a name that does not currently name a
package, a correctable error of type ÿpackage-errorþ is signaled.  If
correction is attempted, no deletion action is attempted; instead,
ÿdelete-packageþ immediately returns ÿnilþ.

If PACKAGE is used by other packages, a correctable error of type
ÿpackage-errorþ is signaled.  If correction is attempted,
ÿunuse-packageþ is effectively called to remove any dependencies,
causing PACKAGE's external symbols to cease being accessible to those
packages that use PACKAGE.  ÿdelete-packageþ then deletes PACKAGE just
as it would have had there been no packages that used it.

See Also:
.........

*Note unuse-package::


File: chris-ansicl.info,  Node: make-package,  Next: with-package-iterator,  Prev: delete-package,  Up: Packages

make-package (Function)
=======================

Syntax:
.......

 -- Function: make-package package-name &key nicknames use ý package

Arguments and Values:
.....................

PACKAGE-NAME--a string designator.

NICKNAMES--a list of string designators.  The default is the empty list.

USE-- a list of package designators.  The default is
implementation-defined.

PACKAGE--a package.

Description:
............

Creates a new package with the name PACKAGE-NAME.

NICKNAMES are additional names which may be used to refer to the new
package.

USE specifies zero or more packages the external symbols of which are
to be inherited by the new package.  See the function *Note
use-package::.

Examples:
.........

 (make-package 'temporary :nicknames '("TEMP" "temp")) ý #<PACKAGE "TEMPORARY">
 (make-package "OWNER" :use '("temp")) ý #<PACKAGE "OWNER">
 (package-used-by-list 'temp) ý (#<PACKAGE "OWNER">)
 (package-use-list 'owner) ý (#<PACKAGE "TEMPORARY">)

Affected By:
............

The existence of other packages in the system.

Exceptional Situations:
.......................

The consequences are unspecified if packages denoted by USE do not
exist.

A correctable error is signaled if the PACKAGE-NAME or any of the
NICKNAMES is already the name or nickname of an existing package.

See Also:
.........

*Note defpackage::, *Note use-package::

Notes:
......

In situations where the packages to be used contain symbols which would
conflict, it is necessary to first create the package with ÿ:use '()þ,
then to use ÿshadowþ or ÿshadowing-importþ to address the conflicts,
and then after that to use ÿuse-packageþ once the conflicts have been
addressed.

When packages are being created as part of the static definition of a
program rather than dynamically by the program, it is generally
considered more stylistically appropriate to use ÿdefpackageþ rather
than ÿmake-packageþ.


File: chris-ansicl.info,  Node: with-package-iterator,  Next: unexport,  Prev: make-package,  Up: Packages

with-package-iterator (Macro)
=============================

Syntax:
.......

 -- Macro: with-package-iterator (name package-list-form &rest
          symbol-types) {declaration}* {form}* ý {result}*

Arguments and Values:
.....................

NAME--a symbol.

PACKAGE-LIST-FORM--a form; evaluated once to produce a PACKAGE-LIST.

PACKAGE-LIST--a designator for a list of package designators.

SYMBOL-TYPE--one of the symbols :internal, :external, or :inherited.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values of the FORMS.

Description:
............

Within the lexical scope of the body FORMS, the NAME is defined via
ÿmacroletþ such that successive invocations of ÿ(NAME)þ will return the
symbols, one by one, from the packages in PACKAGE-LIST.

It is unspecified whether symbols inherited from multiple packages are
returned more than once.  The order of symbols returned does not
necessarily reflect the order of packages in PACKAGE-LIST.  When
PACKAGE-LIST has more than one element, it is unspecified whether
duplicate symbols are returned once or more than once.

SYMBOL-TYPES controls which symbols that are accessible in a package
are returned as follows:

:internal
     The symbols that are present in the package, but that are not
     exported.

:external
     The symbols that are present in the package and are exported.

:inherited
     The symbols that are exported by used packages and that are not
     shadowed.

When more than one argument is supplied for SYMBOL-TYPES, a symbol is
returned if its accessibility matches any one of the SYMBOL-TYPES
supplied.  Implementations may extend this syntax by recognizing
additional symbol accessibility types.

An invocation of ÿ(NAME)þ returns four values as follows:

  1. A flag that indicates whether a symbol is returned (true means
     that a symbol is returned).

  2. A symbol that is accessible in one the indicated packages.

  3. The accessibility type for that symbol; i.e., one of the symbols
     :internal, :external, or :inherited.

  4. The package from which the symbol was obtained.  The package is
     one of the packages present or named in PACKAGE-LIST.

After all symbols have been returned by successive invocations of
ÿ(NAME)þ, then only one value is returned, namely ÿnilþ.

The meaning of the second, third, and fourth values is that the returned
symbol is accessible in the returned package in the way indicated by
the second return value as follows:

:internal
     Means present and not exported.

:external
     Means present and exported.

:inherited
     Means not present (thus not shadowed) but inherited from some used
     package.

It is unspecified what happens if any of the implicit interior state of
an iteration is returned outside the dynamic extent of the
ÿwith-package-iteratorþ form such as by returning some closure over the
invocation form.

Any number of invocations of ÿwith-package-iteratorþ can be nested, and
the body of the innermost one can invoke all of the locally established
macros, provided all those macros have distinct names.

Examples:
.........

The following function should return ÿtþ on any package, and signal an
error if the usage of ÿwith-package-iteratorþ does not agree with the
corresponding usage of ÿdo-symbolsþ.

 (defun test-package-iterator (package)
   (unless (packagep package)
     (setq package (find-package package)))
   (let ((all-entries '())
         (generated-entries '()))
     (do-symbols (x package)
       (multiple-value-bind (symbol accessibility)
           (find-symbol (symbol-name x) package)
         (push (list symbol accessibility) all-entries)))
     (with-package-iterator (generator-fn package
                             :internal :external :inherited)
       (loop
         (multiple-value-bind (more? symbol accessibility pkg)
             (generator-fn)
           (unless more? (return))
           (let ((l (multiple-value-list (find-symbol (symbol-name symbol)
                                                      package))))
             (unless (equal l (list symbol accessibility))
               (error "Symbol ~S not found as ~S in package ~A [~S]"
                      symbol accessibility (package-name package) l))
             (push l generated-entries)))))
     (unless (and (subsetp all-entries generated-entries :test #'equal)
                  (subsetp generated-entries all-entries :test #'equal))
      (error "Generated entries and Do-Symbols entries don't correspond"))
     t))

The following function prints out every present symbol (possibly more
than once):

 (defun print-all-symbols ()
   (with-package-iterator (next-symbol (list-all-packages)
                           :internal :external)
     (loop
       (multiple-value-bind (more? symbol) (next-symbol)
         (if more?
            (print symbol)
            (return))))))

Exceptional Situations:
.......................

ÿwith-package-iteratorþ signals an error of type ÿprogram-errorþ if no
SYMBOL-TYPES are supplied or if a SYMBOL-TYPE is not recognized  by the
implementation is supplied.

The consequences are undefined if the local function named NAME
established by ÿwith-package-iteratorþ is called after it has returned
false as its primary value.

See Also:
.........

*Note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: chris-ansicl.info,  Node: unexport,  Next: unintern,  Prev: with-package-iterator,  Up: Packages

unexport (Function)
===================

Syntax:
.......

 -- Function: unexport symbols &optional package ý ÿtþ

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE--a package designator.  The default is the current package.

Description:
............

ÿunexportþ reverts external SYMBOLS in PACKAGE to internal status; it
undoes the effect of ÿexportþ.

ÿunexportþ works only on symbols present in PACKAGE, switching them
back to internal status.  If ÿunexportþ is given a symbol that is
already accessible as an internal symbol in PACKAGE, it does nothing.

Examples:
.........

 (in-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (export (intern "CONTRABAND" (make-package 'temp)) 'temp) ý T
 (find-symbol "CONTRABAND") ý NIL, NIL
 (use-package 'temp) ý T
 (find-symbol "CONTRABAND") ý CONTRABAND, :INHERITED
 (unexport 'contraband 'temp) ý T
 (find-symbol "CONTRABAND") ý NIL, NIL

Side Effects:
.............

Package system is modified.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

If ÿunexportþ is given a symbol not accessible in PACKAGE at all, an
error of type ÿpackage-errorþ is signaled.

The consequences are undefined if PACKAGE is the ÿKEYWORDþ package or
the ÿCOMMON-LISPþ package.

See Also:
.........

*Note export::, *Note Section 11.1 (Package Concepts): Package Concepts.


File: chris-ansicl.info,  Node: unintern,  Next: in-package,  Prev: unexport,  Up: Packages

unintern (Function)
===================

Syntax:
.......

 -- Function: unintern symbol &optional package ý generalized-boolean

Arguments and Values:
.....................

SYMBOL--a symbol.

PACKAGE--a package designator.  The default is the current package.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿuninternþ removes SYMBOL from PACKAGE.  If SYMBOL is present in
PACKAGE, it is removed from PACKAGE and also from PACKAGE's shadowing
symbols list if it is present there.  If PACKAGE is the home package
for SYMBOL, SYMBOL is made to have no home package.  SYMBOL may
continue to be accessible in PACKAGE by inheritance.

Use of ÿuninternþ can result in a symbol that has no recorded home
package, but that in fact is accessible in some package.  Common
Lisp does not check for this pathological case, and such symbols are
always printed preceded by ÿ#:þ.

ÿuninternþ returns true if it removes SYMBOL, and ÿnilþ otherwise.

Examples:
.........

 (in-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (setq temps-unpack (intern "UNPACK" (make-package 'temp))) ý TEMP::UNPACK
 (unintern temps-unpack 'temp) ý T
 (find-symbol "UNPACK" 'temp) ý NIL, NIL
 temps-unpack ý #:UNPACK

Side Effects:
.............

ÿuninternþ changes the state of the package system in such a way that
the consistency rules do not hold across the change.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

Giving a shadowing symbol to ÿuninternþ can uncover a name conflict
that had previously been resolved by the shadowing.  If package A uses
packages B and C, A contains a shadowing symbol ÿxþ, and B and C each
contain external symbols named ÿxþ, then removing the shadowing symbol
ÿxþ from A will reveal a name conflict between ÿb:xþ and ÿc:xþ if those
two symbols are distinct.  In this case ÿuninternþ will signal an error.

See Also:
.........

*Note Section 11.1 (Package Concepts): Package Concepts.


File: chris-ansicl.info,  Node: in-package,  Next: unuse-package,  Prev: unintern,  Up: Packages

in-package (Macro)
==================

Syntax:
.......

 -- Macro: in-package name ý package

Arguments and Values:
.....................

NAME--a string designator; not evaluated.

PACKAGE--the package named by NAME.

Description:
............

Causes the the package named by NAME to become the current
package--that is, the value of ÿ*package*þ.  If no such package already
exists, an error of type ÿpackage-errorþ is signaled.

Everything ÿin-packageþ does is also performed at compile time if the
call appears as a top level form.

Side Effects:
.............

The variable ÿ*package*þ is assigned.  If the ÿin-packageþ form is a
top level form, this assignment also occurs at compile time.

Exceptional Situations:
.......................

An error of type ÿpackage-errorþ is signaled if the specified package
does not exist.

See Also:
.........

*Note *package*::


File: chris-ansicl.info,  Node: unuse-package,  Next: use-package,  Prev: in-package,  Up: Packages

unuse-package (Function)
========================

Syntax:
.......

 -- Function: unuse-package packages-to-unuse &optional package ý ÿtþ

Arguments and Values:
.....................

PACKAGES-TO-UNUSE--a designator for a list of package designators.

PACKAGE--a package designator.  The default is the current package.

Description:
............

ÿunuse-packageþ causes PACKAGE to cease inheriting all the external
symbols of PACKAGES-TO-UNUSE; ÿunuse-packageþ undoes the effects of
ÿuse-packageþ.   The PACKAGES-TO-UNUSE are removed from the use list of
PACKAGE.

Any symbols that have been imported into PACKAGE continue to be present
in PACKAGE.

Examples:
.........

 (in-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (export (intern "SHOES" (make-package 'temp)) 'temp) ý T
 (find-symbol "SHOES") ý NIL, NIL
 (use-package 'temp) ý T
 (find-symbol "SHOES") ý SHOES, :INHERITED
 (find (find-package 'temp) (package-use-list 'common-lisp-user)) ý #<PACKAGE "TEMP">
 (unuse-package 'temp) ý T
 (find-symbol "SHOES") ý NIL, NIL

Side Effects:
.............

The use list of PACKAGE is modified.

Affected By:
............

Current state of the package system.

See Also:
.........

*Note use-package::, *Note package-use-list::


File: chris-ansicl.info,  Node: use-package,  Next: defpackage,  Prev: unuse-package,  Up: Packages

use-package (Function)
======================

Syntax:
.......

 -- Function: use-package packages-to-use &optional package ý ÿtþ

Arguments and Values:
.....................

PACKAGES-TO-USE--a designator for a list of package designators.  The
ÿKEYWORDþ package may not be supplied.

PACKAGE--a package designator.  The default is the current package.
The PACKAGE cannot be the ÿKEYWORDþ package.

Description:
............

ÿuse-packageþ causes PACKAGE to inherit all the external symbols of
PACKAGES-TO-USE.  The inherited symbols become accessible as internal
symbols of PACKAGE.

PACKAGES-TO-USE are added to the use list of PACKAGE if they are not
there already.  All external symbols in PACKAGES-TO-USE become
accessible in PACKAGE as internal symbols.  ÿuse-packageþ does not
cause any new symbols to be present in PACKAGE but only makes them
accessible by inheritance.

ÿuse-packageþ checks for name conflicts between the newly imported
symbols and those already accessible in PACKAGE.  A name conflict in
ÿuse-packageþ between two external symbols inherited by PACKAGE from
PACKAGES-TO-USE may be resolved in favor of either symbol by importing
one of them into PACKAGE and making it a shadowing symbol.

Examples:
.........

 (export (intern "LAND-FILL" (make-package 'trash)) 'trash) ý T
 (find-symbol "LAND-FILL" (make-package 'temp)) ý NIL, NIL
 (package-use-list 'temp) ý (#<PACKAGE "TEMP">)
 (use-package 'trash 'temp) ý T
 (package-use-list 'temp) ý (#<PACKAGE "TEMP"> #<PACKAGE "TRASH">)
 (find-symbol "LAND-FILL" 'temp) ý TRASH:LAND-FILL, :INHERITED

Side Effects:
.............

The use list of PACKAGE may be modified.

See Also:
.........

*Note unuse-package::, *Note package-use-list::, *Note Section 11.1
(Package Concepts): Package Concepts.

Notes:
......

It is permissible for a package Pá to use a package Pà even if Pà
already uses Pá.  The using of packages is not transitive, so no
problem results from the apparent circularity.


File: chris-ansicl.info,  Node: defpackage,  Next: do-symbols; do-external-symbols; do-all-symbols,  Prev: use-package,  Up: Packages

defpackage (Macro)
==================

Syntax:
.......

 -- Macro: defpackage defined-package-name ùûoptionø ý package

OPTION::=
     {(:nicknames {nickname}*)}* |
     (:documentation string) |
     {(:use {package-name}*)}* |
     {(:shadow {ûsymbol-name}*)}* |
     {(:shadowing-import-from PACKAGE-NAME {ûsymbol-name}*)}* |
     {(:import-from PACKAGE-NAME {ûsymbol-name}*)}* |
     {(:export {ûsymbol-name}*)}* |
     {(:intern {ûsymbol-name}*)}* |
     (:size integer)

Arguments and Values:
.....................

DEFINED-PACKAGE-NAME--a string designator.

PACKAGE-NAME--a package designator.

NICKNAME--a string designator.

SYMBOL-NAME--a string designator.

PACKAGE--the package named PACKAGE-NAME.

Description:
............

ÿdefpackageþ creates a package as specified and returns the package.

If DEFINED-PACKAGE-NAME already refers to an existing package, the
name-to-package mapping for that name is not changed.  If the new
definition is at variance with the current state of that package, the
consequences are undefined;  an implementation might choose to modify
the existing package to reflect the new definition.  If
DEFINED-PACKAGE-NAME is a symbol, its name is used.

The standard options are described below.

:nicknames
     The arguments to :nicknames set the package's nicknames to the
     supplied names.

:documentation
     The argument to :documentation specifies a documentation string;
     it is attached as a documentation string to the package.  At most
     one :documentation option can appear in a single ÿdefpackageþ form.

:use
     The arguments to :use set the packages that the package named by
     PACKAGE-NAME will inherit from. If :use is not supplied, it
     defaults to the same implementation-dependent value as the :use
     argument to ÿmake-packageþ.

:shadow
     The arguments to :shadow, SYMBOL-NAMES, name symbols that are to
     be created in the package being defined.  These symbols are added
     to the list of shadowing symbols effectively as if by ÿshadowþ.

:shadowing-import-from
     The symbols named by the argument SYMBOL-NAMES are found
     (involving a lookup as if by ÿfind-symbolþ) in the specified
     PACKAGE-NAME.  The resulting symbols are imported into the package
     being defined, and placed on the shadowing symbols list as if by
     ÿshadowing-importþ.  In no case are symbols created in any package
     other than the one being defined.

:import-from
     The symbols named by the argument SYMBOL-NAMES are found in the
     package named by PACKAGE-NAME and they are imported into the
     package being defined.  In no case are symbols created in any
     package other than the one being defined.

:export
     The symbols named by the argument SYMBOL-NAMES  are found or
     created in the package being defined and exported.  The :export
     option interacts with the :use option, since inherited symbols can
     be used rather than new ones created.  The :export option interacts
     with the :import-from and :shadowing-import-from options, since
     imported symbols can be used rather than new ones created.  If an
     argument to the :export option is accessible as an (inherited)
     internal symbol via ÿuse-packageþ, that the symbol named by
     SYMBOL-NAME is first imported into the package being defined, and
     is then exported from that package.

:intern
     The symbols named by the argument SYMBOL-NAMES are found or
     created in the package being defined.  The :intern option
     interacts with the :use option, since inherited symbols can be
     used rather than new ones created.

:size
     The argument to the :size option declares the approximate number
     of symbols expected in the package.  This is an efficiency hint
     only and might be ignored by an implementation.

The order in which the options appear in a ÿdefpackageþ form is
irrelevant.  The order in which they are executed is as follows:

  1. :shadow and :shadowing-import-from.

  2. :use.

  3. :import-from and :intern.

  4. :export.

Shadows are established first, since they might  be necessary to block
spurious name conflicts when the :use option is processed. The :use
option is executed next so that :intern and :export options can refer
to normally inherited symbols.  The :export option is executed last so
that it can refer to symbols created by any of the other options; in
particular, shadowing symbols and imported symbols can be made external.

If a defpackage form appears as a top level form, all of the actions
normally performed by this macro at load time must also be performed at
compile time.

Examples:
.........

 (defpackage "MY-PACKAGE"
   (:nicknames "MYPKG" "MY-PKG")
   (:use "COMMON-LISP")
   (:shadow "CAR" "CDR")
   (:shadowing-import-from "VENDOR-COMMON-LISP"  "CONS")
   (:import-from "VENDOR-COMMON-LISP"  "GC")
   (:export "EQ" "CONS" "FROBOLA")
   )


 (defpackage my-package
   (:nicknames mypkg :MY-PKG)  ; remember Common Lisp conventions for case
   (:use common-lisp)          ; conversion on symbols
   (:shadow CAR :cdr #:cons)
   (:export "CONS")            ; this is the shadowed one.
   )

Affected By:
............

Existing packages.

Exceptional Situations:
.......................

If one of the supplied :nicknames already refers to an existing package,
an error of type ÿpackage-errorþ is signaled.

An error of type ÿprogram-errorþ should be signaled if :size or
:documentation appears more than once.

Since implementations might allow extended options an error of type
ÿprogram-errorþ should be signaled if an option is present that is not
actually supported in the host implementation.

The collection of SYMBOL-NAME arguments given to the options :shadow,
:intern, :import-from, and :shadowing-import-from must all be disjoint;
additionally, the SYMBOL-NAME arguments given to :export and :intern
must be disjoint.  Disjoint in this context is defined as no two of the
SYMBOL-NAMES being ÿstring=þ with each other. If either condition is
violated, an error of type ÿprogram-errorþ should be signaled.

For the :shadowing-import-from and :import-from options, a correctable
error of type ÿpackage-errorþ is signaled if no symbol is accessible in
the package named by PACKAGE-NAME for one of the argument SYMBOL-NAMES.

Name conflict errors are handled by the underlying calls to
ÿmake-packageþ, ÿuse-packageþ, ÿimportþ, and ÿexportþ. See *Note
Section 11.1 (Package Concepts): Package Concepts.

See Also:
.........

*Note documentation::, *Note Section 11.1 (Package Concepts): Package
Concepts, *Note Section 3.2 (Compilation): Compilation.

Notes:
......

The :intern option is useful if an :import-from or a
:shadowing-import-from option in a subsequent call to ÿdefpackageþ (for
some other package) expects to find these symbols accessible but not
necessarily external.

It is recommended that the entire package definition is put in a single
place, and that all the package definitions of a program are in a
single file.  This file can be loaded before loading or compiling
anything else that depends on those packages. Such a file can be read
in the ÿCOMMON-LISP-USERþ package, avoiding any initial state issues.

ÿdefpackageþ cannot be used to create two "mutually recursive"
packages, such as:

 (defpackage my-package
   (:use common-lisp your-package)    ;requires your-package to exist first
   (:export "MY-FUN"))
 (defpackage your-package
   (:use common-lisp)
   (:import-from my-package "MY-FUN") ;requires my-package to exist first
   (:export "MY-FUN"))

However, nothing prevents the user from using the package-affecting
functions such as ÿuse-packageþ, ÿimportþ, and ÿexportþ to establish
such links after a more standard use of ÿdefpackageþ.

The macroexpansion of ÿdefpackageþ could usefully canonicalize the names
into strings, so that even if a source file has random symbols in the
ÿdefpackageþ form, the compiled file would only contain strings.

Frequently additional implementation-dependent options take the form of
a keyword standing by itself as an abbreviation for a list ÿ(keyword
T)þ; this syntax should be properly reported as an unrecognized option
in implementations that do not support it.


File: chris-ansicl.info,  Node: do-symbols; do-external-symbols; do-all-symbols,  Next: intern,  Prev: defpackage,  Up: Packages

do-symbols, do-external-symbols, do-all-symbols (Macro)
=======================================================

Syntax:
.......

 -- Macro: do-symbols (var [package [result-form]])
          {declaration}* {tag | statement}* ý {result}*

 -- Macro: do-external-symbols (var [package [result-form]])
          {declaration}* {tag | statement}* ý {result}*

 -- Macro: do-all-symbols (var [result-form])
          {declaration}* {tag | statement}* ý {result}*

Arguments and Values:
.....................

VAR--a variable name; not evaluated.

PACKAGE--a package designator; evaluated.  The defaults in ÿdo-symbolsþ
and ÿdo-external-symbolsþ is the current package.

RESULT-FORM--a form; evaluated as described below.  The default is
ÿnilþ.

DECLARATION--a declare expression; not evaluated.

TAG--a go tag; not evaluated.

STATEMENT--a compound form; evaluated as described below.

RESULTS--the values returned by the RESULT-FORM if a normal return
occurs, or else, if an explicit return occurs, the values that were
transferred.

Description:
............

ÿdo-symbolsþ, ÿdo-external-symbolsþ, and ÿdo-all-symbolsþ iterate over
the symbols of packages.  For each symbol in the set of packages chosen,
the VAR is bound to the symbol, and the STATEMENTS in the body are
executed.  When all the symbols have been processed, RESULT-FORM is
evaluated and returned as the value of the macro.

ÿdo-symbolsþ iterates over the symbols accessible in PACKAGE.
STATEMENTS may execute more than once for symbols that are inherited
from multiple packages.

ÿdo-all-symbolsþ iterates on every registered package.
ÿdo-all-symbolsþ will not process every symbol whatsoever, because a
symbol not accessible in any registered package will not be processed.
ÿdo-all-symbolsþ may cause a symbol that is present in several packages
to be processed more than once.

ÿdo-external-symbolsþ iterates on the external symbols of PACKAGE.

When RESULT-FORM is evaluated, VAR is bound and has the value ÿnilþ.

An implicit block named ÿnilþ surrounds the entire ÿdo-symbolsþ,
ÿdo-external-symbolsþ, or ÿdo-all-symbolsþ form.  ÿreturnþ or
ÿreturn-fromþ may be used to terminate the iteration prematurely.

If execution of the body affects which symbols are contained in the set
of packages over which iteration is occurring, other than to remove the
symbol currently the value of VAR by using ÿuninternþ, the consequences
are undefined.

For each of these macros, the scope of the name binding does not
include any initial value form, but the optional result forms are
included.

Any TAG in the body is treated as with ÿtagbodyþ.

Examples:
.........

 (make-package 'temp :use nil) ý #<PACKAGE "TEMP">
 (intern "SHY" 'temp) ý TEMP::SHY, NIL ;SHY will be an internal symbol
                                         ;in the package TEMP
 (export (intern "BOLD" 'temp) 'temp)  ý T  ;BOLD will be external
 (let ((lst ()))
   (do-symbols (s (find-package 'temp)) (push s lst))
   lst)
ý (TEMP::SHY TEMP:BOLD)
orý (TEMP:BOLD TEMP::SHY)
 (let ((lst ()))
   (do-external-symbols (s (find-package 'temp) lst) (push s lst))
   lst)
ý (TEMP:BOLD)
 (let ((lst ()))
   (do-all-symbols (s lst)
     (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))
   lst)
ý (TEMP::SHY TEMP:BOLD)
orý (TEMP:BOLD TEMP::SHY)

See Also:
.........

*Note intern::, *Note export::, *Note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.


File: chris-ansicl.info,  Node: intern,  Next: package-name,  Prev: do-symbols; do-external-symbols; do-all-symbols,  Up: Packages

intern (Function)
=================

Syntax:
.......

 -- Function: intern string &optional package ý symbol, status

Arguments and Values:
.....................

STRING--a string.

PACKAGE--a package designator.  The default is the current package.

SYMBOL--a symbol.

STATUS--one of :inherited, :external, :internal, or ÿnilþ.

Description:
............

ÿinternþ enters a symbol named STRING into PACKAGE.  If a symbol whose
name is the same as STRING is already accessible in PACKAGE, it is
returned.  If no such symbol is accessible in PACKAGE, a new symbol
with the given name is created and entered into PACKAGE as an internal
symbol, or as an external symbol if the PACKAGE is the ÿKEYWORDþ
package; PACKAGE becomes the home package of the created symbol.

The first value returned by ÿinternþ, SYMBOL, is the symbol that was
found or created.  The meaning of the secondary value, STATUS, is as
follows:

:internal
     The symbol was found and is present in PACKAGE as an internal
     symbol.

:external
     The symbol was found and is present as an external symbol.

:inherited
     The symbol was found and is inherited via ÿuse-packageþ (which
     implies that the symbol is internal).

ÿnilþ
     No pre-existing symbol was found, so one was created.

     It is implementation-dependent whether the string that becomes the
     new symbol's name is the given STRING or a copy of it.  Once a
     string has been given as the STRING argument to intern in this
     situation where a new symbol is created, the consequences are
     undefined if a subsequent attempt is made to alter that string.

Examples:
.........

 (in-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (intern "Never-Before") ý |Never-Before|, NIL
 (intern "Never-Before") ý |Never-Before|, :INTERNAL
 (intern "NEVER-BEFORE" "KEYWORD") ý :NEVER-BEFORE, NIL
 (intern "NEVER-BEFORE" "KEYWORD") ý :NEVER-BEFORE, :EXTERNAL

See Also:
.........

*Note find-symbol::, *Note read::, *Note symbol::, *Note unintern::,
*Note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens.

Notes:
......

ÿinternþ does not need to do any name conflict checking because it
never creates a new symbol if there is already an accessible symbol
with the name given.


File: chris-ansicl.info,  Node: package-name,  Next: package-nicknames,  Prev: intern,  Up: Packages

package-name (Function)
=======================

Syntax:
.......

 -- Function: package-name package ý name

Arguments and Values:
.....................

PACKAGE--a package designator.

NAME--a string or ÿnilþ.

Description:
............

ÿpackage-nameþ returns the string that names PACKAGE, or ÿnilþ if the
PACKAGE designator is a package object that has no name (see the
function *Note delete-package::).

Examples:
.........

 (in-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 (package-name *package*) ý "COMMON-LISP-USER"
 (package-name (symbol-package :test)) ý "KEYWORD"
 (package-name (find-package 'common-lisp)) ý "COMMON-LISP"

 (defvar *foo-package* (make-package "FOO"))
 (rename-package "FOO" "FOO0")
 (package-name *foo-package*) ý "FOO0"

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if PACKAGE is not a package
designator.


File: chris-ansicl.info,  Node: package-nicknames,  Next: package-shadowing-symbols,  Prev: package-name,  Up: Packages

package-nicknames (Function)
============================

Syntax:
.......

 -- Function: package-nicknames package ý nicknames

Arguments and Values:
.....................

PACKAGE--a package designator.

NICKNAMES--a list of strings.

Description:
............

Returns the list of nickname strings for PACKAGE, not including the
name of PACKAGE.

Examples:
.........

 (package-nicknames (make-package 'temporary
                                   :nicknames '("TEMP" "temp")))
ý ("temp" "TEMP")

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if PACKAGE is not a package
designator.


File: chris-ansicl.info,  Node: package-shadowing-symbols,  Next: package-use-list,  Prev: package-nicknames,  Up: Packages

package-shadowing-symbols (Function)
====================================

Syntax:
.......

 -- Function: package-shadowing-symbols package ý symbols

Arguments and Values:
.....................

PACKAGE--a package designator.

SYMBOLS--a list of symbols.

Description:
............

Returns a list of symbols that have been declared as shadowing symbols
in PACKAGE by ÿshadowþ or ÿshadowing-importþ (or the equivalent
ÿdefpackageþ options).  All symbols on this list are present in PACKAGE.

Examples:
.........

 (package-shadowing-symbols (make-package 'temp)) ý ()
 (shadow 'cdr 'temp) ý T
 (package-shadowing-symbols 'temp) ý (TEMP::CDR)
 (intern "PILL" 'temp) ý TEMP::PILL, NIL
 (shadowing-import 'pill 'temp) ý T
 (package-shadowing-symbols 'temp) ý (PILL TEMP::CDR)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if PACKAGE is not a package
designator.

See Also:
.........

*Note shadow::, *Note shadowing-import::

Notes:
......

Whether the list of SYMBOLS is fresh is implementation-dependent.


File: chris-ansicl.info,  Node: package-use-list,  Next: package-used-by-list,  Prev: package-shadowing-symbols,  Up: Packages

package-use-list (Function)
===========================

Syntax:
.......

 -- Function: package-use-list package ý use-list

Arguments and Values:
.....................

PACKAGE--a package designator.

USE-LIST--a list of package objects.

Description:
............

Returns a list of other packages used by PACKAGE.

Examples:
.........

 (package-use-list (make-package 'temp)) ý (#<PACKAGE "COMMON-LISP">)
 (use-package 'common-lisp-user 'temp) ý T
 (package-use-list 'temp) ý (#<PACKAGE "COMMON-LISP"> #<PACKAGE "COMMON-LISP-USER">)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if PACKAGE is not a package
designator.

See Also:
.........

*Note use-package::, *Note unuse-package::


File: chris-ansicl.info,  Node: package-used-by-list,  Next: packagep,  Prev: package-use-list,  Up: Packages

package-used-by-list (Function)
===============================

Syntax:
.......

 -- Function: package-used-by-list package ý used-by-list

Arguments and Values:
.....................

PACKAGE--a package designator.

USED-BY-LIST--a list of package objects.

Description:
............

ÿpackage-used-by-listþ returns a list of other packages that use
PACKAGE.

Examples:
.........

 (package-used-by-list (make-package 'temp)) ý ()
 (make-package 'trash :use '(temp)) ý #<PACKAGE "TRASH">
 (package-used-by-list 'temp) ý (#<PACKAGE "TRASH">)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if PACKAGE is not a package.

See Also:
.........

*Note use-package::, *Note unuse-package::


File: chris-ansicl.info,  Node: packagep,  Next: *package*,  Prev: package-used-by-list,  Up: Packages

packagep (Function)
===================

Syntax:
.......

 -- Function: packagep object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿpackageþ; otherwise, returns false.

Examples:
.........

 (packagep *package*) ý true
 (packagep 'common-lisp) ý false
 (packagep (find-package 'common-lisp)) ý true

Notes:
......

 (packagep OBJECT) Õ (typep OBJECT 'package)


File: chris-ansicl.info,  Node: *package*,  Next: package-error,  Prev: packagep,  Up: Packages

*package* (Variable)
====================

Value Type:
...........

a package object.

Initial Value:
..............

the ÿCOMMON-LISP-USERþ package.

Description:
............

Whatever package object is currently the value of ÿ*package*þ is
referred to as the current package.

Examples:
.........

 (in-package "COMMON-LISP-USER") ý #<PACKAGE "COMMON-LISP-USER">
 *package* ý #<PACKAGE "COMMON-LISP-USER">
 (make-package "SAMPLE-PACKAGE" :use '("COMMON-LISP"))
ý #<PACKAGE "SAMPLE-PACKAGE">
 (list
   (symbol-package
     (let ((*package* (find-package 'sample-package)))
       (setq *some-symbol* (read-from-string "just-testing"))))
   *package*)
ý (#<PACKAGE "SAMPLE-PACKAGE"> #<PACKAGE "COMMON-LISP-USER">)
 (list (symbol-package (read-from-string "just-testing"))
       *package*)
ý (#<PACKAGE "COMMON-LISP-USER"> #<PACKAGE "COMMON-LISP-USER">)
 (eq 'foo (intern "FOO")) ý true
 (eq 'foo (let ((*package* (find-package 'sample-package)))
            (intern "FOO")))
ý false

Affected By:
............

ÿloadþ, ÿcompile-fileþ, ÿin-packageþ

See Also:
.........

*Note compile-file::, *Note in-package::, *Note load::, *Note package::


File: chris-ansicl.info,  Node: package-error,  Next: package-error-package,  Prev: *package*,  Up: Packages

package-error (Condition Type)
==============================

Class Precedence List:
......................

ÿpackage-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿpackage-errorþ consists of error conditions related to
operations on packages.  The offending package (or package name) is
initialized by the :package initialization argument to ÿmake-conditionþ,
and is accessed by the function ÿpackage-error-packageþ.

See Also:
.........

*Note package-error-package::, *Note Chapter 9 (Conditions): Conditions.


File: chris-ansicl.info,  Node: package-error-package,  Prev: package-error,  Up: Packages

package-error-package (Function)
================================

Syntax:
.......

 -- Function: package-error-package condition ý package

Arguments and Values:
.....................

CONDITION--a condition of type ÿpackage-errorþ.

PACKAGE--a package designator.

Description:
............

Returns a designator for the offending package in the situation
represented by the CONDITION.

Examples:
.........

 (package-error-package
   (make-condition 'package-error
     :package (find-package "COMMON-LISP")))
ý #<Package "COMMON-LISP">

See Also:
.........

*Note package-error::


File: chris-ansicl.info,  Node: Numbers,  Next: Characters,  Prev: Packages,  Up: Top

12 Numbers
**********

* Menu:

* Number Concepts::

Dictionary

* number::
* complex (System Class)::
* real::
* float (System Class)::
* short-float; single-float; double-float; long-float::
* rational (System Class)::
* ratio::
* integer::
* signed-byte::
* unsigned-byte::
* mod (Type Specifier)::
* bit (Type)::
* fixnum::
* bignum::
* =; /=; <; >; <=; >=::
* max; min::
* minusp; plusp::
* zerop::
* floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround::
* sin; cos; tan::
* asin; acos; atan::
* pi::
* sinh; cosh; tanh; asinh; acosh; atanh::
* * (Function)::
* + (Function)::
* - (Function)::
* / (Function)::
* 1+; 1-::
* abs::
* evenp; oddp::
* exp; expt::
* gcd::
* incf; decf::
* lcm::
* log::
* mod; rem::
* signum::
* sqrt; isqrt::
* random-state::
* make-random-state::
* random::
* random-state-p::
* *random-state*::
* numberp::
* cis::
* complex (Function)::
* complexp::
* conjugate::
* phase::
* realpart; imagpart::
* upgraded-complex-part-type::
* realp::
* numerator; denominator::
* rational; rationalize::
* rationalp::
* ash::
* integer-length::
* integerp::
* parse-integer::
* boole::
* boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+::
* logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+::
* logbitp::
* logcount::
* logtest::
* byte; byte-size; byte-position::
* deposit-field::
* dpb::
* ldb::
* ldb-test::
* mask-field::
* most-positive-fixnum; most-negative-fixnum::
* decode-float; scale-float; float-radix; float-sign; float-digits; float+::
* float (Function)::
* floatp::
* most-positive-short-float; least-positive-short-float; least-positive-n+::
* short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+::
* arithmetic-error::
* arithmetic-error-operands; arithmetic-error-operation::
* division-by-zero::
* floating-point-invalid-operation::
* floating-point-inexact::
* floating-point-overflow::
* floating-point-underflow::


File: chris-ansicl.info,  Node: Number Concepts,  Next: number,  Up: Numbers

12.1 Number Concepts
====================

* Menu:

* Numeric Operations::
* Implementation-Dependent Numeric Constants::
* Rational Computations::
* Floating-point Computations::
* Complex Computations::
* Interval Designators::
* Random-State Operations::


File: chris-ansicl.info,  Node: Numeric Operations,  Next: Implementation-Dependent Numeric Constants,  Up: Number Concepts

12.1.1 Numeric Operations
-------------------------

Common Lisp provides a large variety of operations related to numbers.
This section provides an overview of those operations by grouping them
into categories that emphasize some of the relationships among them.

The next figure shows operators relating to arithmetic operations.

*   1+          gcd
+   1-          incf
-   conjugate   lcm
/   decf        

Figure 12.1: Operators relating to Arithmetic.

The next figure shows defined names relating to exponential,
logarithmic, and trigonometric operations.

abs     cos     signum
acos    cosh    sin
acosh   exp     sinh
asin    expt    sqrt
asinh   isqrt   tan
atan    log     tanh
atanh   phase   
cis     pi      

Figure 12.2: Defined names relating to Exponentials, Logarithms, and
Trigonometry.

The next figure shows operators relating to numeric comparison and
predication.

/=   >=       oddp
<    evenp    plusp
<=   max      zerop
=    min      
>    minusp   

Figure 12.3: Operators for numeric comparison and predication.

The next figure shows defined names relating to numeric type
manipulation and coercion.

ceiling           float-radix            rational
complex           float-sign             rationalize
decode-float      floor                  realpart
denominator       fround                 rem
fceiling          ftruncate              round
ffloor            imagpart               scale-float
float             integer-decode-float   truncate
float-digits      mod                    
float-precision   numerator              

Figure 12.4: Defined names relating to numeric type manipulation and
coercion.

12.1.1.1 Associativity and Commutativity in Numeric Operations
..............................................................

For functions that are mathematically associative (and possibly
commutative), a conforming implementation may process the arguments in
any manner consistent with associative (and possibly commutative)
rearrangement.  This does not affect the order in which the argument
forms are evaluated; for a discussion of evaluation order, see *Note
Section 3.1.2.1.2.3 (Function Forms): FunctionForms.  What is
unspecified is only the order in which the parameter values are
processed.  This implies that implementations may differ in which
automatic coercions are applied; see *Note Section 12.1.1.2 (Contagion
in Numeric Operations): NumericContagionRules.

A conforming program can control the order of processing explicitly by
separating the operations into separate (possibly nested) function
forms, or by writing explicit calls to functions that perform coercions.

12.1.1.1.1 Examples of Associativity and Commutativity in Numeric Operations
............................................................................

Consider the following expression, in which we assume that ÿ1.0þ and
ÿ1.0e-15þ both denote single floats:

 (+ 1/3 2/3 1.0d0 1.0 1.0e-15)

One conforming implementation might process the arguments from left to
right, first adding ÿ1/3þ and ÿ2/3þ to get ÿ1þ, then converting that to
a double float for combination with ÿ1.0d0þ, then successively
converting and adding ÿ1.0þ and ÿ1.0e-15þ.

Another conforming implementation might process the arguments from
right to left, first performing a single float addition of ÿ1.0þ and
ÿ1.0e-15þ (perhaps losing accuracy in the process), then converting the
sum to a double float and adding ÿ1.0d0þ, then converting ÿ2/3þ to a
double float and adding it, and then converting ÿ1/3þ and adding that.

A third conforming implementation might first scan all the arguments,
process all the rationals first to keep that part of the computation
exact, then find an argument of the largest floating-point format among
all the arguments and add that, and then add in all other arguments,
converting each in turn (all in a perhaps misguided attempt to make the
computation as accurate as possible).

In any case, all three strategies are legitimate.

A conforming program could control the order by writing, for example,

 (+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)

12.1.1.2 Contagion in Numeric Operations
........................................

For information about the contagion rules for implicit coercions of
arguments in numeric operations, see *Note Section 12.1.4.4 (Rule of
Float Precision Contagion): RuleOfFloatPrecisionContagion, *Note
Section 12.1.4.1 (Rule of Float and Rational Contagion):
RuleOfFloatAndRationalContagion, and *Note Section 12.1.5.2 (Rule of
Complex Contagion): RuleOfComplexContagion.

12.1.1.3 Viewing Integers as Bits and Bytes
...........................................

12.1.1.3.1 Logical Operations on Integers
.........................................

Logical operations require integers as arguments; an error of type
ÿtype-errorþ should be signaled if an argument is supplied that is not
an integer.  Integer arguments to logical operations are treated as if
they were represented in two's-complement notation.

The next figure shows defined names relating to logical operations on
numbers.

ash           boole-ior        logbitp
boole         boole-nand       logcount
boole-1       boole-nor        logeqv
boole-2       boole-orc1       logior
boole-and     boole-orc2       lognand
boole-andc1   boole-set        lognor
boole-andc2   boole-xor        lognot
boole-c1      integer-length   logorc1
boole-c2      logand           logorc2
boole-clr     logandc1         logtest
boole-eqv     logandc2         logxor

Figure 12.5: Defined names relating to logical operations on numbers.

12.1.1.3.2 Byte Operations on Integers
......................................

The byte-manipulation functions use objects called byte specifiers to
designate the size and position of a specific byte within an integer.
The representation of a byte specifier is implementation-dependent; it
might or might not be a number.  The function ÿbyteþ will construct a
byte specifier, which various other byte-manipulation functions will
accept.

The next figure shows defined names relating to manipulating bytes of
numbers.

byte            deposit-field   ldb-test
byte-position   dpb             mask-field
byte-size       ldb             

Figure 12.6: Defined names relating to byte manipulation.


File: chris-ansicl.info,  Node: Implementation-Dependent Numeric Constants,  Next: Rational Computations,  Prev: Numeric Operations,  Up: Number Concepts

12.1.2 Implementation-Dependent Numeric Constants
-------------------------------------------------

The next figure shows defined names relating to
implementation-dependent details about numbers.

double-float-epsilon            most-negative-fixnum
double-float-negative-epsilon   most-negative-long-float
least-negative-double-float     most-negative-short-float
least-negative-long-float       most-negative-single-float
least-negative-short-float      most-positive-double-float
least-negative-single-float     most-positive-fixnum
least-positive-double-float     most-positive-long-float
least-positive-long-float       most-positive-short-float
least-positive-short-float      most-positive-single-float
least-positive-single-float     short-float-epsilon
long-float-epsilon              short-float-negative-epsilon
long-float-negative-epsilon     single-float-epsilon
most-negative-double-float      single-float-negative-epsilon

Figure 12.7: Defined names relating to implementation-dependent details
about numbers.


File: chris-ansicl.info,  Node: Rational Computations,  Next: Floating-point Computations,  Prev: Implementation-Dependent Numeric Constants,  Up: Number Concepts

12.1.3 Rational Computations
----------------------------

The rules in this section apply to rational computations.

12.1.3.1 Rule of Unbounded Rational Precision
.............................................

Rational computations cannot overflow in the usual sense (though there
may not be enough storage to represent a result), since integers and
ratios may in principle be of any magnitude.

12.1.3.2 Rule of Canonical Representation for Rationals
.......................................................

If any computation produces a result that is a mathematical ratio of
two integers such that the denominator evenly divides the numerator,
then the result is converted to the equivalent integer.

If the denominator does not evenly divide the numerator, the canonical
representation of a rational number is as the ratio that numerator and
that denominator, where the greatest common divisor of the numerator
and denominator is one, and where the denominator is positive and
greater than one.

When used as input (in the default syntax), the notation ÿ-0þ always
denotes the integer ÿ0þ.  A conforming implementation must not have a
representation of "minus zero" for integers that is distinct from its
representation of zero for integers.  However, such a distinction is
possible for floats; see the type ÿfloatþ.

12.1.3.3 Rule of Float Substitutability
.......................................

When the arguments to an irrational mathematical function

are all rational and the true mathematical result is also
(mathematically) rational, then unless otherwise noted an
implementation is free to return either an accurate rational result or
a single float approximation.  If the arguments are all rational but
the result cannot be expressed as a rational number, then a single float
approximation is always returned.

If the arguments to an irrational mathematical function are all of type
ÿ(or rational (complex rational))þ and the true mathematical result is
(mathematically) a complex number with rational real and imaginary
parts, then unless otherwise noted an implementation is free to return
either an accurate result of type ÿ(or rational (complex rational))þ or
a single float (permissible only if the imaginary part of the true
mathematical result is zero) or ÿ(complex single-float)þ. If the
arguments are all of type ÿ(or rational (complex rational))þ but the
result cannot be expressed as a rational or complex rational, then the
returned value will be of type ÿsingle-floatþ (permissible only if the
imaginary part of the true mathematical result is zero) or ÿ(complex
single-float)þ.

Float substitutability applies neither to the rational functions ÿ+þ,
ÿ-þ, ÿ*þ, and ÿ/þ nor to the related operators ÿ1+þ, ÿ1-þ, ÿincfþ,
ÿdecfþ, and ÿconjugateþ.  For rational functions, if all arguments are
rational, then the result is rational; if all arguments are of type
ÿ(or rational (complex rational))þ, then the result is of type ÿ(or
rational (complex rational))þ.

Function   Sample Results
------------------------------------------------------------- 
ÿabsþ      ÿ(abs #c(3 4)) ý 5 or 5.0þ
ÿacosþ     ÿ(acos 1) ý 0 or 0.0þ
ÿacoshþ    ÿ(acosh 1) ý 0 or 0.0þ
ÿasinþ     ÿ(asin 0) ý 0 or 0.0þ
ÿasinhþ    ÿ(asinh 0) ý 0 or 0.0þ
ÿatanþ     ÿ(atan 0) ý 0 or 0.0þ
ÿatanhþ    ÿ(atanh 0) ý 0 or 0.0þ
ÿcisþ      ÿ(cis 0) ý 1 or #c(1.0 0.0)þ
ÿcosþ      ÿ(cos 0) ý 1 or 1.0þ
ÿcoshþ     ÿ(cosh 0) ý 1 or 1.0þ
ÿexpþ      ÿ(exp 0) ý 1 or 1.0þ
ÿexptþ     ÿ(expt 8 1/3) ý 2 or 2.0þ
ÿlogþ      ÿ(log 1) ý 0 or 0.0þ
           ÿ(log 8 2) ý 3 or 3.0þ
ÿphaseþ    ÿ(phase 7) ý 0 or 0.0þ
ÿsignumþ   ÿ(signum #c(3 4)) ý #c(3/5 4/5) or #c(0.6 0.8)þ
ÿsinþ      ÿ(sin 0) ý 0 or 0.0þ
ÿsinhþ     ÿ(sinh 0) ý 0 or 0.0þ
ÿsqrtþ     ÿ(sqrt 4) ý 2 or 2.0þ
           ÿ(sqrt 9/16) ý 3/4 or 0.75þ
ÿtanþ      ÿ(tan 0) ý 0 or 0.0þ
ÿtanhþ     ÿ(tanh 0) ý 0 or 0.0þ

Figure 12.8: Functions Affected by Rule of Float Substitutability


File: chris-ansicl.info,  Node: Floating-point Computations,  Next: Complex Computations,  Prev: Rational Computations,  Up: Number Concepts

12.1.4 Floating-point Computations
----------------------------------

The following rules apply to floating point computations.

12.1.4.1 Rule of Float and Rational Contagion
.............................................

When rationals and floats are combined by a numerical function, the
rational is first converted to a float of the same format.  For
functions such as ÿ+þ that take more than two arguments, it is
permitted that part of the operation be carried out exactly using
rationals and the rest be done using floating-point arithmetic.

When rationals and floats are compared by a numerical function, the
function ÿrationalþ is effectively called to convert the float to a
rational and then an exact comparison is performed. In the case of
complex numbers, the real and imaginary parts are effectively handled
individually.

12.1.4.1.1 Examples of Rule of Float and Rational Contagion
...........................................................

 ;;;; Combining rationals with floats.
 ;;; This example assumes an implementation in which
 ;;; (float-radix 0.5) is 2 (as in IEEE) or 16 (as in IBM/360),
 ;;; or else some other implementation in which 1/2 has an exact
 ;;;  representation in floating point.
 (+ 1/2 0.5) ý 1.0
 (- 1/2 0.5d0) ý 0.0d0
 (+ 0.5 -0.5 1/2) ý 0.5

 ;;;; Comparing rationals with floats.
 ;;; This example assumes an implementation in which the default float
 ;;; format is IEEE single-float, IEEE double-float, or some other format
 ;;; in which 5/7 is rounded upwards by FLOAT.
 (< 5/7 (float 5/7)) ý true
 (< 5/7 (rational (float 5/7))) ý true
 (< (float 5/7) (float 5/7)) ý false

12.1.4.2 Rule of Float Approximation
....................................

Computations with floats are only approximate, although they are
described as if the results were mathematically accurate.  Two
mathematically identical expressions may be computationally different
because of errors inherent in the floating-point approximation process.
The precision of a float is not necessarily correlated with the
accuracy of that number.  For instance, 3.142857142857142857 is a more
precise approximation to î than 3.14159, but the latter is more
accurate.  The precision refers to the number of bits retained in the
representation.  When an operation combines a short float with a long
float, the result will be a long float.  Common Lisp functions assume
that the accuracy of arguments to them does not exceed their precision.
Therefore when two small floats are combined, the result is a small
float.  Common Lisp functions never convert automatically from a larger
size to a smaller one.

12.1.4.3 Rule of Float Underflow and Overflow
.............................................

An error of type ÿfloating-point-overflowþ or
ÿfloating-point-underflowþ should be signaled if a floating-point
computation causes exponent overflow or underflow, respectively.

12.1.4.4 Rule of Float Precision Contagion
..........................................

The result of a numerical function is a float of the largest format
among all the floating-point arguments to the function.


File: chris-ansicl.info,  Node: Complex Computations,  Next: Interval Designators,  Prev: Floating-point Computations,  Up: Number Concepts

12.1.5 Complex Computations
---------------------------

The following rules apply to complex computations:

12.1.5.1 Rule of Complex Substitutability
.........................................

Except during the execution of irrational and transcendental functions,
no numerical function ever yields a complex unless one or more of its
arguments is a complex.

12.1.5.2 Rule of Complex Contagion
..................................

When a real and a complex are both part of a computation, the real is
first converted to a complex by providing an imaginary part of ÿ0þ.

12.1.5.3 Rule of Canonical Representation for Complex Rationals
...............................................................

If the result of any computation would be a complex number whose real
part is of type ÿrationalþ and whose imaginary part is zero, the result
is converted to the rational which is the real part.  This rule does
not apply to complex numbers whose parts are floats.  For example,
ÿ#C(5 0)þ and ÿ5þ are not different objects in Common Lisp (they are
always the same under ÿeqlþ); ÿ#C(5.0 0.0)þ and ÿ5.0þ are always
different objects in Common Lisp (they are never the same under ÿeqlþ,
although they are the same under ÿequalpþ and ÿ=þ).

12.1.5.3.1 Examples of Rule of Canonical Representation for Complex Rationals
.............................................................................

 #c(1.0 1.0) ý #C(1.0 1.0)
 #c(0.0 0.0) ý #C(0.0 0.0)
 #c(1.0 1) ý #C(1.0 1.0)
 #c(0.0 0) ý #C(0.0 0.0)
 #c(1 1) ý #C(1 1)
 #c(0 0) ý 0
 (typep #c(1 1) '(complex (eql 1))) ý true
 (typep #c(0 0) '(complex (eql 0))) ý false

12.1.5.4 Principal Values and Branch Cuts
.........................................

Many of the irrational and transcendental functions are multiply defined
in the complex domain; for example, there are in general an infinite
number of complex values for the logarithm function.  In each such
case, a principal value must be chosen for the function to return.  In
general, such values cannot be chosen so as to make the range
continuous; lines in the domain called branch cuts must be defined,
which in turn define the discontinuities in the range.  Common
Lisp defines the branch cuts, principal values, and boundary conditions
for the complex functions following "Principal Values and Branch Cuts
in Complex APL." The branch cut rules that apply to each function are
located with the description of that function.

The next figure lists the identities that are obeyed throughout the
applicable portion of the complex domain, even on the branch cuts:

sin i z = i sinh z   sinh i z = i sin z         arctan  i z = i arctanh z
cos i z = cosh z     cosh i z = cos z           arcsinh i z = i arcsin z
tan i z = i tanh z   arcsin i z = i arcsinh z   arctanh i z = i arctan z

Figure 12.9: Trigonometric Identities for Complex Domain

The quadrant numbers referred to in the discussions of branch cuts are
as illustrated in the next figure.

                               Positive
                            Imaginary Axis

                                   :
                               II  :  I
                                   :
    Negative Real Axis .......................  Positive Real Axis
                                   :
                              III  :  IV
                                   :

                               Negative
                            Imaginary Axis

Figure 12.10: Quadrant Numbering for Branch Cuts


File: chris-ansicl.info,  Node: Interval Designators,  Next: Random-State Operations,  Prev: Complex Computations,  Up: Number Concepts

12.1.6 Interval Designators
---------------------------

The compound type specifier form of the numeric type specifiers permit
the user to specify an interval on the real number line which describe
a subtype of the type which would be described by the corresponding
atomic type specifier.  A subtype of some type T is specified using an
ordered pair of objects called interval designators for type T.

The first of the two interval designators for type T can be any of the
following:

a number N of type T
     This denotes a lower inclusive bound of N.  That is, elements of
     the subtype of T will be greater than or equal to N.

a singleton list whose element is a number M of type T
     This denotes a lower exclusive bound of M.  That is, elements of
     the subtype of T will be greater than M.

the symbol *
     This denotes the absence of a lower bound on the interval.

The second of the two interval designators for type T can be any of the
following:

a number N of type T
     This denotes an upper inclusive bound of N.  That is, elements of
     the subtype of T will be less than or equal to N.

a singleton list whose element is a number M of type T
     This denotes an upper exclusive bound of M.  That is, elements of
     the subtype of T will be less than M.

the symbol *
     This denotes the absence of an upper bound on the interval.


File: chris-ansicl.info,  Node: Random-State Operations,  Prev: Interval Designators,  Up: Number Concepts

12.1.7 Random-State Operations
------------------------------

The next figure lists some defined names that are applicable to random
states.

*random-state*      random           
make-random-state   random-state-p   

Figure 12.11: Random-state defined names


File: chris-ansicl.info,  Node: number,  Next: complex (System Class),  Prev: Number Concepts,  Up: Numbers

number (System Class)
=====================

Class Precedence List:
......................

ÿnumberþ, ÿtþ

Description:
............

The type ÿnumberþ contains objects which represent mathematical numbers.
The types ÿrealþ and ÿcomplexþ are disjoint subtypes of ÿnumberþ.

The function ÿ=þ tests for numerical equality.  The function ÿeqlþ,
when its arguments are both numbers, tests that they have both the same
type and numerical value.  Two numbers that are the same under ÿeqlþ or
ÿ=þ are not necessarily the same under ÿeqþ.

Notes:
......

Common Lisp differs from mathematics on some naming issues.  In
mathematics, the set of real numbers is traditionally described as a
subset of the complex numbers, but in Common Lisp, the type ÿrealþ and
the type ÿcomplexþ are disjoint.  The Common Lisp type which includes
all mathematical complex numbers is called ÿnumberþ.  The reasons for
these differences include historical precedent, compatibility with most
other popular computer languages, and various issues of time and space
efficiency.


File: chris-ansicl.info,  Node: complex (System Class),  Next: real,  Prev: number,  Up: Numbers

complex (System Class)
======================

Class Precedence List:
......................

ÿcomplexþ, ÿnumberþ, ÿtþ

Description:
............

The type ÿcomplexþ includes all mathematical complex numbers other than
those included in the type ÿrationalþ.  Complexes are expressed in
Cartesian form with a real part and an imaginary part, each of which is
a real.  The real part and imaginary part are either both rational or
both of the same float type.  The imaginary part can be a float zero,
but can never be a rational zero, for such a number is always
represented by Common Lisp as a rational rather than a complex.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(complex [typespec | *])

Compound Type Specifier Arguments:
..................................

TYPESPEC--a type specifier that denotes a subtype of type ÿrealþ.

Compound Type Specifier Description:
....................................

Every element of this type is a complex whose real part and imaginary
part are each of type ÿ(upgraded-complex-part-type TYPESPEC)þ.  This
type encompasses those complexes that can result by giving numbers of
type TYPESPEC to ÿcomplexþ.

ÿ(complex TYPE-SPECIFIER)þ refers to all complexes that can result from
giving numbers of TYPE TYPE-SPECIFIER to the function ÿcomplexþ, plus
all other complexes of the same specialized representation.

See Also:
.........

*Note Section 12.1.5.3 (Rule of Canonical Representation for Complex
Rationals): RuleOfCanonRepForComplexRationals, *Note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*Note Section 22.1.3.1.4 (Printing Complexes): PrintingComplexes.

Notes:
......

The input syntax for a complex with real part r and imaginary part i is
ÿ#C(r i)þ.  For further details, see *Note Section 2.4 (Standard Macro
Characters): Standard Macro Characters.

For every float, n, there is a complex which represents the same
mathematical number and which can be obtained by ÿ(COERCE n 'COMPLEX)þ.


File: chris-ansicl.info,  Node: real,  Next: float (System Class),  Prev: complex (System Class),  Up: Numbers

real (System Class)
===================

Class Precedence List:
......................

ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

The type ÿrealþ includes all numbers that represent mathematical real
numbers, though there are mathematical real numbers (e.g., irrational
numbers) that do not have an exact representation in Common Lisp.  Only
reals can be ordered using the ÿ<þ, ÿ>þ, ÿ<=þ, and ÿ>=þ functions.

The types ÿrationalþ and ÿfloatþ are disjoint subtypes of type ÿrealþ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(real [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ÿrealþ.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ÿ*þ.

Compound Type Specifier Description:
....................................

This denotes the reals on the interval described by LOWER-LIMIT and
UPPER-LIMIT.


File: chris-ansicl.info,  Node: float (System Class),  Next: short-float; single-float; double-float; long-float,  Prev: real,  Up: Numbers

float (System Class)
====================

Class Precedence List:
......................

ÿfloatþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

A float is a mathematical rational (but not a Common Lisp rational) of
the form së fë b^e-p, where s is +1 or -1, the sign; b is an integer
greater than 1, the base or radix of the representation; p is a
positive integer, the precision (in base-b digits) of the float; f is a
positive integer between b^p-1 and b^p-1 (inclusive), the significand;
and e is an integer, the exponent.  The value of p and the range of e
depends on the implementation and on the type of float within that
implementation. In addition, there is a floating-point zero; depending
on the implementation, there can also be a "minus zero". If there is no
minus zero, then 0.0 and -0.0 are both interpreted as simply a
floating-point zero.  ÿ(= 0.0 -0.0)þ is always true.  If there is a
minus zero, ÿ(eql -0.0 0.0)þ is false, otherwise it is true.

The types ÿshort-floatþ, ÿsingle-floatþ, ÿdouble-floatþ, and
ÿlong-floatþ are subtypes of type ÿfloatþ.  Any two of them must be
either disjoint types or the same type; if the same type, then any
other types between them in the above ordering must also be the same
type.  For example, if the type ÿsingle-floatþ and the type
ÿlong-floatþ are the same type, then the type ÿdouble-floatþ must be
the same type also.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(float [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ÿfloatþ.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ÿ*þ.

Compound Type Specifier Description:
....................................

This denotes the floats on the interval described by LOWER-LIMIT and
UPPER-LIMIT.

See Also:
.........

*Note Figure 2.9: SyntaxForNumericTokens, *Note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*Note Section 22.1.3.1.3 (Printing Floats): PrintingFloats.

Notes:
......

Note that all mathematical integers are representable not only as
Common Lisp reals, but also as complex floats.  For example, possible
representations of the mathematical number 1 include the integer ÿ1þ,
the float ÿ1.0þ, or the complex ÿ#C(1.0 0.0)þ.


File: chris-ansicl.info,  Node: short-float; single-float; double-float; long-float,  Next: rational (System Class),  Prev: float (System Class),  Up: Numbers

short-float, single-float, double-float, long-float (Type)
==========================================================

Supertypes:
...........

ÿshort-floatþ: ÿshort-floatþ, ÿfloatþ, ÿrealþ, ÿnumberþ, ÿtþ

ÿsingle-floatþ: ÿsingle-floatþ, ÿfloatþ, ÿrealþ, ÿnumberþ, ÿtþ

ÿdouble-floatþ: ÿdouble-floatþ, ÿfloatþ, ÿrealþ, ÿnumberþ, ÿtþ

ÿlong-floatþ: ÿlong-floatþ, ÿfloatþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

For the four defined subtypes of type ÿfloatþ, it is true that
intermediate between the type ÿshort-floatþ and the type ÿlong-floatþ
are the type ÿsingle-floatþ and the type ÿdouble-floatþ.  The precise
definition of these categories is implementation-defined.  The
precision (measured in "bits", computed as plogàb) and the exponent
size (also measured in "bits," computed as logà(n+1), where n is the
maximum exponent value) is recommended to be at least as great as the
values in the next figure.  Each of the defined subtypes of type
ÿfloatþ might or might not have a minus zero.

Format   Minimum Precision   Minimum Exponent Size
Short    13 bits             5 bits
Single   24 bits             8 bits
Double   50 bits             8 bits
Long     50 bits             8 bits

Figure 12.12: Recommended Minimum Floating-Point Precision and Exponent
Size

There can be fewer than four internal representations for floats.  If
there are fewer distinct representations, the following rules apply:

   - If there is only one, it is the type ÿsingle-floatþ.  In this
     representation, an object is simultaneously of types
     ÿsingle-floatþ, ÿdouble-floatþ, ÿshort-floatþ, and ÿlong-floatþ.

   - Two internal representations can be arranged in either of the
     following ways:

        * Two types are provided: ÿsingle-floatþ and ÿshort-floatþ.  An
          object is simultaneously of types ÿsingle-floatþ,
          ÿdouble-floatþ, and ÿlong-floatþ.

        * Two types are provided: ÿsingle-floatþ and ÿdouble-floatþ. An
          object is simultaneously of types ÿsingle-floatþ and
          ÿshort-floatþ, or ÿdouble-floatþ and ÿlong-floatþ.

   - Three internal representations can be arranged in either of the
     following ways:

        * Three types are provided: ÿshort-floatþ, ÿsingle-floatþ, and
          ÿdouble-floatþ.  An object can simultaneously be of type
          ÿdouble-floatþ and ÿlong-floatþ.

        * Three types are provided: ÿsingle-floatþ, ÿdouble-floatþ, and
          ÿlong-floatþ. An object can simultaneously be of types
          ÿsingle-floatþ and ÿshort-floatþ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(short-float [short-lower-limit   [short-upper-limit]]) (single-float
[single-lower-limit [single-upper-limit]]) (double-float
[double-lower-limit [double-upper-limit]]) (long-float
[long-lower-limit     [long-upper-limit]])

Compound Type Specifier Arguments:
..................................

SHORT-LOWER-LIMIT, SHORT-UPPER-LIMIT--interval designators for type
ÿshort-floatþ.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT is
the symbol *.

SINGLE-LOWER-LIMIT, SINGLE-UPPER-LIMIT--interval designators for type
ÿsingle-floatþ.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT
is the symbol *.

DOUBLE-LOWER-LIMIT, DOUBLE-UPPER-LIMIT--interval designators for type
ÿdouble-floatþ.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT
is the symbol *.

LONG-LOWER-LIMIT, LONG-UPPER-LIMIT--interval designators for type
ÿlong-floatþ.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT is
the symbol *.

Compound Type Specifier Description:
....................................

Each of these denotes the set of floats of the indicated type that are
on the interval specified by the interval designators.


File: chris-ansicl.info,  Node: rational (System Class),  Next: ratio,  Prev: short-float; single-float; double-float; long-float,  Up: Numbers

rational (System Class)
=======================

Class Precedence List:
......................

ÿrationalþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

The canonical representation of a rational is as an integer if its
value is integral, and otherwise as a ratio.

The types ÿintegerþ and ÿratioþ are disjoint subtypes of type
ÿrationalþ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(rational [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ÿrationalþ.
The defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ÿ*þ.

Compound Type Specifier Description:
....................................

This denotes the rationals on the interval described by LOWER-LIMIT and
UPPER-LIMIT.


File: chris-ansicl.info,  Node: ratio,  Next: integer,  Prev: rational (System Class),  Up: Numbers

ratio (System Class)
====================

Class Precedence List:
......................

ÿratioþ, ÿrationalþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

A ratio is a number representing the mathematical ratio of two non-zero
integers, the numerator and denominator, whose greatest common divisor
is one, and of which the denominator is positive and greater than one.

See Also:
.........

*Note Figure 2.9: SyntaxForNumericTokens, *Note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*Note Section 22.1.3.1.2 (Printing Ratios): PrintingRatios.


File: chris-ansicl.info,  Node: integer,  Next: signed-byte,  Prev: ratio,  Up: Numbers

integer (System Class)
======================

Class Precedence List:
......................

ÿintegerþ, ÿrationalþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

An integer is a mathematical integer. There is no limit on the
magnitude of an integer.

The types ÿfixnumþ and ÿbignumþ form an exhaustive partition of type
ÿintegerþ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(integer [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ÿintegerþ.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ÿ*þ.

Compound Type Specifier Description:
....................................

This denotes the integers on the interval described by LOWER-LIMIT and
UPPER-LIMIT.

See Also:
.........

*Note Figure 2.9: SyntaxForNumericTokens, *Note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*Note Section 22.1.3.1.1 (Printing Integers): PrintingIntegers.

Notes:
......

The type ÿ(integer lower upper)þ, where lower and upper are
ÿmost-negative-fixnumþ and ÿmost-positive-fixnumþ, respectively, is
also called ÿfixnumþ.

The type ÿ(integer 0 1)þ is also called ÿbitþ.  The type ÿ(integer 0
*)þ is also called ÿunsigned-byteþ.


File: chris-ansicl.info,  Node: signed-byte,  Next: unsigned-byte,  Prev: integer,  Up: Numbers

signed-byte (Type)
==================

Supertypes:
...........

ÿsigned-byteþ, ÿintegerþ, ÿrationalþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

The atomic type specifier ÿsigned-byteþ denotes the same type as is
denoted by the type specifier ÿintegerþ; however, the list forms of
these two type specifiers have different semantics.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(signed-byte [s | *])

Compound Type Specifier Arguments:
..................................

S--a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of integers that can be represented in
two's-complement form in a byte of S bits.  This is equivalent to
ÿ(integer -2^s-1 2^s-1-1)þ.  The type ÿsigned-byteþ or the type
ÿ(signed-byte *)þ is the same as the type ÿintegerþ.


File: chris-ansicl.info,  Node: unsigned-byte,  Next: mod (Type Specifier),  Prev: signed-byte,  Up: Numbers

unsigned-byte (Type)
====================

Supertypes:
...........

ÿunsigned-byteþ, ÿsigned-byteþ, ÿintegerþ, ÿrationalþ, ÿrealþ, ÿnumberþ,
ÿtþ

Description:
............

The atomic type specifier ÿunsigned-byteþ denotes the same type as is
denoted by the type specifier ÿ(integer 0 *)þ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(unsigned-byte [S | *])

Compound Type Specifier Arguments:
..................................

S--a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of non-negative integers that can be represented
in a byte of size S (bits).  This is equivalent to ÿ(mod M)þ for M=2^s,
or to ÿ(integer 0 N)þ for N=2^s-1.  The type ÿunsigned-byteþ or the
type ÿ(unsigned-byte *)þ is the same as the type ÿ(integer 0 *)þ, the
set of non-negative integers.

Notes:
......

The type ÿ(unsigned-byte 1)þ is also called ÿbitþ.


File: chris-ansicl.info,  Node: mod (Type Specifier),  Next: bit (Type),  Prev: unsigned-byte,  Up: Numbers

mod (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(mod n)

Compound Type Specifier Arguments:
..................................

N--a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of non-negative integers less than N.  This is
equivalent to ÿ(integer 0 (N))þ or to ÿ(integer 0 M)þ, where M=N-1.

The argument is required, and cannot be *.

The symbol ÿmodþ is not valid as a type specifier.


File: chris-ansicl.info,  Node: bit (Type),  Next: fixnum,  Prev: mod (Type Specifier),  Up: Numbers

bit (Type)
==========

Supertypes:
...........

ÿbitþ, ÿunsigned-byteþ, ÿsigned-byteþ, ÿintegerþ, ÿrationalþ, ÿrealþ,
ÿnumberþ, ÿtþ

Description:
............

The type ÿbitþ is equivalent to the type ÿ(integer 0 1)þ and
ÿ(unsigned-byte 1)þ.


File: chris-ansicl.info,  Node: fixnum,  Next: bignum,  Prev: bit (Type),  Up: Numbers

fixnum (Type)
=============

Supertypes:
...........

ÿfixnumþ, ÿintegerþ, ÿrationalþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

A fixnum is an integer whose value is between ÿmost-negative-fixnumþ
and ÿmost-positive-fixnumþ inclusive.  Exactly which integers are
fixnums is implementation-defined.  The type ÿfixnumþ is required to be
a supertype of ÿ(signed-byte 16)þ.


File: chris-ansicl.info,  Node: bignum,  Next: =; /=; <; >; <=; >=,  Prev: fixnum,  Up: Numbers

bignum (Type)
=============

Supertypes:
...........

ÿbignumþ, ÿintegerþ, ÿrationalþ, ÿrealþ, ÿnumberþ, ÿtþ

Description:
............

The type ÿbignumþ is defined to be exactly ÿ(and integer (not fixnum))þ.


File: chris-ansicl.info,  Node: =; /=; <; >; <=; >=,  Next: max; min,  Prev: bignum,  Up: Numbers

=, /=, <, >, <=, >= (Function)
==============================

Syntax:
.......

 -- Function: = &rest numbers+ ý generalized-boolean

 -- Function: /= &rest numbers+ ý generalized-boolean

 -- Function: < &rest numbers+ ý generalized-boolean

 -- Function: > &rest numbers+ ý generalized-boolean

 -- Function: <= &rest numbers+ ý generalized-boolean

 -- Function: >= &rest numbers+ ý generalized-boolean

Arguments and Values:
.....................

NUMBER--for ÿ<þ, ÿ>þ, ÿ<=þ, ÿ>=þ: a real; for ÿ=þ, ÿ/=þ: a number.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿ=þ, ÿ/=þ, ÿ<þ, ÿ>þ, ÿ<=þ, and ÿ>=þ perform arithmetic comparisons on
their arguments as follows:

ÿ=þ
     The value of ÿ=þ is true if all NUMBERS are the same in value;
     otherwise it is false.  Two complexes are considered equal by ÿ=þ
     if their real and imaginary parts are equal according to ÿ=þ.

ÿ/=þ
     The value of ÿ/=þ is true if no two NUMBERS are the same in value;
     otherwise it is false.

ÿ<þ
     The value of ÿ<þ is true if the NUMBERS are in monotonically
     increasing order; otherwise it is false.

ÿ>þ
     The value of ÿ>þ is true if the NUMBERS are in monotonically
     decreasing order; otherwise it is false.

ÿ<=þ
     The value of ÿ<=þ is true if the NUMBERS are in monotonically
     nondecreasing order; otherwise it is false.

ÿ>=þ
     The value of ÿ>=þ is true if the NUMBERS are in monotonically
     nonincreasing order; otherwise it is false.

ÿ=þ, ÿ/=þ, ÿ<þ, ÿ>þ, ÿ<=þ, and ÿ>=þ perform necessary type conversions.

Examples:
.........

The uses of these functions are illustrated in the next figure.

ÿ(= 3 3)þ is true.               ÿ(/= 3 3)þ is false.
ÿ(= 3 5)þ is false.              ÿ(/= 3 5)þ is true.
ÿ(= 3 3 3 3)þ is true.           ÿ(/= 3 3 3 3)þ is false.
ÿ(= 3 3 5 3)þ is false.          ÿ(/= 3 3 5 3)þ is false.
ÿ(= 3 6 5 2)þ is false.          ÿ(/= 3 6 5 2)þ is true.
ÿ(= 3 2 3)þ is false.            ÿ(/= 3 2 3)þ is false.
ÿ(< 3 5)þ is true.               ÿ(<= 3 5)þ is true.
ÿ(< 3 -5)þ is false.             ÿ(<= 3 -5)þ is false.
ÿ(< 3 3)þ is false.              ÿ(<= 3 3)þ is true.
ÿ(< 0 3 4 6 7)þ is true.         ÿ(<= 0 3 4 6 7)þ is true.
ÿ(< 0 3 4 4 6)þ is false.        ÿ(<= 0 3 4 4 6)þ is true.
ÿ(> 4 3)þ is true.               ÿ(>= 4 3)þ is true.
ÿ(> 4 3 2 1 0)þ is true.         ÿ(>= 4 3 2 1 0)þ is true.
ÿ(> 4 3 3 2 0)þ is false.        ÿ(>= 4 3 3 2 0)þ is true.
ÿ(> 4 3 1 2 0)þ is false.        ÿ(>= 4 3 1 2 0)þ is false.
ÿ(= 3)þ is true.                 ÿ(/= 3)þ is true.
ÿ(< 3)þ is true.                 ÿ(<= 3)þ is true.
ÿ(= 3.0 #c(3.0 0.0))þ is true.   ÿ(/= 3.0 #c(3.0 1.0))þ is true.
ÿ(= 3 3.0)þ is true.             ÿ(= 3.0s0 3.0d0)þ is true.
ÿ(= 0.0 -0.0)þ is true.          ÿ(= 5/2 2.5)þ is true.
ÿ(> 0.0 -0.0)þ is false.         ÿ(= 0 -0.0)þ is true.

Figure 12.13: Uses of /=, =, <, >, <=, and >=

Exceptional Situations:
.......................

Might signal ÿtype-errorþ if some argument is not a real.  Might signal
ÿarithmetic-errorþ if otherwise unable to fulfill its contract.

Notes:
......

ÿ=þ differs from ÿeqlþ in that ÿ(= 0.0 -0.0)þ is always true, because
ÿ=þ compares the mathematical values of its operands, whereas ÿeqlþ
compares the representational values, so to speak.


File: chris-ansicl.info,  Node: max; min,  Next: minusp; plusp,  Prev: =; /=; <; >; <=; >=,  Up: Numbers

max, min (Function)
===================

Syntax:
.......

 -- Function: max &rest reals+ ý max-real

 -- Function: min &rest reals+ ý min-real

Arguments and Values:
.....................

REAL--a real.

MAX-REAL, MIN-REAL--a real.

Description:
............

ÿmaxþ returns the REAL that is greatest (closest to positive infinity).
ÿminþ returns the REAL that is least (closest to negative infinity).

For ÿmaxþ, the implementation has the choice of returning the largest
argument as is or applying the rules of floating-point contagion,
taking all the arguments into consideration for contagion purposes.
Also, if one or more of the arguments are ÿ=þ, then any one of them may
be chosen as the value to return.  For example, if the REALS are a
mixture of rationals and floats, and the largest argument is a rational,
then the implementation is free to produce either that rational or its
float approximation; if the largest argument is a float of a smaller
format than the largest format of any float argument, then the
implementation is free to return the argument in its given format or
expanded to the larger format.  Similar remarks apply to ÿminþ
(replacing "largest argument" by "smallest argument").

Examples:
.........

 (max 3) ý 3
 (min 3) ý 3
 (max 6 12) ý 12
 (min 6 12) ý 6
 (max -6 -12) ý -6
 (min -6 -12) ý -12
 (max 1 3 2 -7) ý 3
 (min 1 3 2 -7) ý -7
 (max -2 3 0 7) ý 7
 (min -2 3 0 7) ý -2
 (max 5.0 2) ý 5.0
 (min 5.0 2)
ý 2
orý 2.0
 (max 3.0 7 1)
ý 7
orý 7.0
 (min 3.0 7 1)
ý 1
orý 1.0
 (max 1.0s0 7.0d0) ý 7.0d0
 (min 1.0s0 7.0d0)
ý 1.0s0
orý 1.0d0
 (max 3 1 1.0s0 1.0d0)
ý 3
orý 3.0d0
 (min 3 1 1.0s0 1.0d0)
ý 1
orý 1.0s0
orý 1.0d0

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NUMBER is not a real.


File: chris-ansicl.info,  Node: minusp; plusp,  Next: zerop,  Prev: max; min,  Up: Numbers

minusp, plusp (Function)
========================

Syntax:
.......

 -- Function: minusp real ý generalized-boolean

 -- Function: plusp real ý generalized-boolean

Arguments and Values:
.....................

REAL--a real.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿminuspþ returns true if REAL is less than zero; otherwise, returns
false.

ÿpluspþ returns true if REAL is greater than zero; otherwise, returns
false.

Regardless of whether an implementation provides distinct
representations for positive and negative float zeros, ÿ(minusp -0.0)þ
always returns false.

Examples:
.........

 (minusp -1) ý true
 (plusp 0) ý false
 (plusp least-positive-single-float) ý true

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if REAL is not a real.


File: chris-ansicl.info,  Node: zerop,  Next: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Prev: minusp; plusp,  Up: Numbers

zerop (Function)
================

Syntax:
.......

 -- Function: zerop number ý generalized-boolean

Pronunciation:
..............

[êzæ(é)rå(é)pæ]

Arguments and Values:
.....................

NUMBER--a number.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if NUMBER is zero (integer, float, or complex); otherwise,
returns false.

Regardless of whether an implementation provides distinct
representations for positive and negative floating-point zeros, ÿ(zerop
-0.0)þ always returns true.

Examples:
.........

 (zerop 0) ý true
 (zerop 1) ý false
 (zerop -0.0) ý true
 (zerop 0/100) ý true
 (zerop #c(0 0.0)) ý true

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NUMBER is not a number.

Notes:
......

 (zerop NUMBER) Õ (= NUMBER 0)


File: chris-ansicl.info,  Node: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Next: sin; cos; tan,  Prev: zerop,  Up: Numbers

floor, ffloor, ceiling, fceiling, truncate, ftruncate, round, fround (Function)
===============================================================================

Syntax:
.......

 -- Function: floor number &optional divisor ý quotient, remainder

 -- Function: ffloor number &optional divisor ý quotient, remainder

 -- Function: ceiling number &optional divisor ý quotient, remainder

 -- Function: fceiling number &optional divisor ý quotient, remainder

 -- Function: truncate number &optional divisor ý quotient, remainder

 -- Function: ftruncate number &optional divisor ý quotient, remainder

 -- Function: round number &optional divisor ý quotient, remainder

 -- Function: fround number &optional divisor ý quotient, remainder

Arguments and Values:
.....................

NUMBER--a real.

DIVISOR--a non-zero real.  The default is the integer ÿ1þ.

QUOTIENT--for ÿfloorþ, ÿceilingþ, ÿtruncateþ, and ÿroundþ: an integer;
for ÿffloorþ, ÿfceilingþ, ÿftruncateþ, and ÿfroundþ: a float.

REMAINDER--a real.

Description:
............

These functions divide NUMBER by DIVISOR, returning a QUOTIENT and
REMAINDER, such that

QUOTIENTë DIVISOR+REMAINDER=NUMBER

The QUOTIENT always represents a mathematical integer.  When more than
one mathematical integer might be possible (i.e., when the remainder is
not zero), the kind of rounding or truncation depends on the operator:

ÿfloorþ, ÿffloorþ
     ÿfloorþ and ÿffloorþ produce a QUOTIENT that has been truncated
     toward negative infinity; that is, the QUOTIENT represents the
     largest mathematical integer that is not larger than the
     mathematical quotient.

ÿceilingþ, ÿfceilingþ
     ÿceilingþ and ÿfceilingþ produce a QUOTIENT that has been
     truncated toward positive infinity; that is, the QUOTIENT
     represents the smallest mathematical integer that is not smaller
     than the mathematical result.

ÿtruncateþ, ÿftruncateþ
     ÿtruncateþ and ÿftruncateþ produce a QUOTIENT that has been
     truncated towards zero; that is, the QUOTIENT represents the
     mathematical integer of the same sign as the mathematical
     quotient, and that has the greatest integral magnitude not greater
     than that of the mathematical quotient.

ÿroundþ, ÿfroundþ
     ÿroundþ and ÿfroundþ produce a QUOTIENT that has been rounded to
     the nearest mathematical integer; if the mathematical quotient is
     exactly halfway between two integers, (that is, it has the form
     integer+1/2), then the QUOTIENT has been rounded to the even
     (divisible by two) integer.

All of these functions perform type conversion operations on NUMBERS.

The REMAINDER is an integer  if both   ÿxþ and ÿyþ are integers, is a
rational if both   ÿxþ and ÿyþ are rationals, and is a  float    if
either ÿxþ or  ÿyþ is  a float.

ÿffloorþ, ÿfceilingþ, ÿftruncateþ, and ÿfroundþ handle arguments of
different types in the following way: If  NUMBER  is     a float, and
DIVISOR is not a float of longer format, then the first result is a
float of the same type as NUMBER.  Otherwise, the first result is of
the type determined by contagion rules; see *Note Section 12.1.1.2
(Contagion in Numeric Operations): NumericContagionRules.

Examples:
.........

 (floor 3/2) ý 1, 1/2
 (ceiling 3 2) ý 2, -1
 (ffloor 3 2) ý 1.0, 1
 (ffloor -4.7) ý -5.0, 0.3
 (ffloor 3.5d0) ý 3.0d0, 0.5d0
 (fceiling 3/2) ý 2.0, -1/2
 (truncate 1) ý 1, 0
 (truncate .5) ý 0, 0.5
 (round .5) ý 0, 0.5
 (ftruncate -7 2) ý -3.0, -1
 (fround -7 2) ý -4.0, 1
 (dolist (n '(2.6 2.5 2.4 0.7 0.3 -0.3 -0.7 -2.4 -2.5 -2.6))
   (format t "~&~4,1@F ~2,' D ~2,' D ~2,' D ~2,' D"
           n (floor n) (ceiling n) (truncate n) (round n)))
Ö +2.6  2  3  2  3
Ö +2.5  2  3  2  2
Ö +2.4  2  3  2  2
Ö +0.7  0  1  0  1
Ö +0.3  0  1  0  0
Ö -0.3 -1  0  0  0
Ö -0.7 -1  0  0 -1
Ö -2.4 -3 -2 -2 -2
Ö -2.5 -3 -2 -2 -2
Ö -2.6 -3 -2 -2 -3
ý NIL

Notes:
......

When only NUMBER is given, the two results are exact; the mathematical
sum of the two results is always equal to the mathematical value of
NUMBER.

ÿ(function NUMBER DIVISOR)þ and ÿ(function (/ NUMBER DIVISOR))þ (where
function is any of one of ÿfloorþ, ÿceilingþ, ÿffloorþ, ÿfceilingþ,
ÿtruncateþ, ÿroundþ, ÿftruncateþ, and ÿfroundþ) return the same first
value, but they return different remainders as the second value. For
example:

 (floor 5 2) ý 2, 1
 (floor (/ 5 2)) ý 2, 1/2

If an effect is desired that is similar to ÿroundþ, but that always
rounds up or down (rather than toward the nearest even integer) if the
mathematical quotient is exactly halfway between two integers, the
programmer should consider a construction such as ÿ(floor (+ x 1/2))þ
or ÿ(ceiling (- x 1/2))þ.


File: chris-ansicl.info,  Node: sin; cos; tan,  Next: asin; acos; atan,  Prev: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Up: Numbers

sin, cos, tan (Function)
========================

Syntax:
.......

 -- Function: sin radians ý number

 -- Function: cos radians ý number

 -- Function: tan radians ý number

Arguments and Values:
.....................

RADIANS--a number given in radians.

NUMBER--a number.

Description:
............

ÿsinþ, ÿcosþ, and ÿtanþ return the sine, cosine, and tangent,
respectively, of RADIANS.

Examples:
.........

 (sin 0) ý 0.0
 (cos 0.7853982) ý 0.707107
 (tan #c(0 1)) ý #C(0.0 0.761594)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if RADIANS is not a number.
Might signal ÿarithmetic-errorþ.

See Also:
.........

*Note asin::, *Note acos::, *Note atan::, *Note Section 12.1.3.3 (Rule
of Float Substitutability): FloatSubstitutability.


File: chris-ansicl.info,  Node: asin; acos; atan,  Next: pi,  Prev: sin; cos; tan,  Up: Numbers

asin, acos, atan (Function)
===========================

Syntax:
.......

 -- Function: asin number ý radians

 -- Function: acos number ý radians

 -- Function: atan number1 &optional number2 ý radians

Arguments and Values:
.....................

NUMBER--a number.

NUMBER1--a number if NUMBER2 is not supplied, or a real   if NUMBER2 is
   supplied.

NUMBER2--a real.

RADIANS--a number (of radians).

Description:
............

ÿasinþ, ÿacosþ, and ÿatanþ compute the arc sine, arc cosine, and arc
tangent respectively.

The arc sine, arc cosine, and arc tangent (with only NUMBER1 supplied)
functions can be defined mathematically for NUMBER or NUMBER1 specified
as x as in the next figure.

Function      Definition
-------------------------------------------------- 
Arc sine      -i log (ix+     sqrt(1-x^2)     )
Arc cosine    (î/2) - arcsin x
Arc tangent   -i log ((1+ix) sqrt(1/(1+x^2)) )

Figure 12.14: Mathematical definition of arc sine, arc cosine, and arc
tangent

These formulae are mathematically correct, assuming completely accurate
computation. They are not necessarily the simplest ones for real-valued
computations.

If both NUMBER1 and NUMBER2 are supplied for ÿatanþ, the result is the
arc tangent of NUMBER1/NUMBER2.  The value of ÿatanþ is always between
-î (exclusive) and î (inclusive) when minus zero is not supported.  The
range of the two-argument arc tangent when minus zero is supported
includes -î.

For a real NUMBER1, the result is a real and lies between -î/2 and î/2
(both exclusive).  NUMBER1 can be a complex if NUMBER2 is not supplied.
If both are supplied, NUMBER2 can be zero provided NUMBER1 is not zero.

The following definition for arc sine determines the range and branch
cuts:

     arcsin z = -i log (iz+sqrt(1-z^2))

The branch cut for the arc sine function is in two pieces: one along
the negative real axis to the left of -1 (inclusive), continuous with
quadrant II, and one along the positive real axis to the right of 1
(inclusive), continuous with quadrant IV.  The range is that strip of
the complex plane containing numbers whose real part is between -î/2
and î/2.  A number with real part equal to -î/2 is in the range if and
only if its imaginary part is non-negative; a number with real part
equal to î/2 is in the range if and only if its imaginary part is
non-positive.

The following definition for arc cosine determines the range and branch
cuts:

     arccos z = î/2- arcsin z

or, which are equivalent,

     arccos z = -i log (z+i sqrt(1-z^2))

     arccos z = 2 log (sqrt((1+z)/2) + i sqrt((1-z)/2))/(i)

The branch cut for the arc cosine function is in two pieces: one along
the negative real axis to the left of -1 (inclusive), continuous with
quadrant II, and one along the positive real axis to the right of 1
(inclusive), continuous with quadrant IV.  This is the same branch cut
as for arc sine.  The range is that strip of the complex plane
containing numbers whose real part is between 0 and î.  A number with
real part equal to 0 is in the range if and only if its imaginary part
is non-negative; a number with real part equal to î is in the range if
and only if its imaginary part is non-positive.

The following definition for (one-argument) arc tangent determines the
range and branch cuts:

     arctan z = (log (1+iz) - log (1-iz))/2i

Beware of simplifying this formula; "obvious" simplifications are likely
to alter the branch cuts or the values on the branch cuts incorrectly.
The branch cut for the arc tangent function is in two pieces: one along
the positive imaginary axis above i (exclusive), continuous with
quadrant II, and one along the negative imaginary axis below -i
(exclusive), continuous with quadrant IV.  The points i and -i are
excluded from the domain.  The range is that strip of the complex plane
containing numbers whose real part is between -î/2 and î/2.  A number
with real part equal to -î/2 is in the range if and only if its
imaginary part is strictly positive; a number with real part equal to
î/2 is in the range if and only if its imaginary part is strictly
negative.  Thus the range of arc tangent is identical to that of arc
sine with the points -î/2 and î/2 excluded.

For ÿatanþ, the signs of NUMBER1 (indicated as x) and NUMBER2
(indicated as y) are used to derive quadrant information. The next
figure details various special cases.  The asterisk (*) indicates that
the entry in the figure applies to implementations that support minus
zero.

 y Condition   x Condition   Cartesian locus   Range of result
-------------------------------------------------------------------- 
 y =  0        x >  0        Positive x-axis   0
*y = +0        x >  0        Positive x-axis   +0
*y = -0        x >  0        Positive x-axis   -0
 y >  0        x >  0        Quadrant I        0 < result < î/2
 y >  0        x =  0        Positive y-axis   î/2
 y >  0        x <  0        Quadrant II       î/2 < result < î
 y =  0        x <  0        Negative x-axis   î
*y = +0        x <  0        Negative x-axis   +î
*y = -0        x <  0        Negative x-axis   -î
 y <  0        x <  0        Quadrant III      -î < result < -î/2
 y <  0        x =  0        Negative y-axis   -î/2
 y <  0        x >  0        Quadrant IV       -î/2 < result < 0
 y =  0        x =  0        Origin            undefined
                                               consequences
*y = +0        x = +0        Origin            +0
*y = -0        x = +0        Origin            -0
*y = +0        x = -0        Origin            +î
*y = -0        x = -0        Origin            -î

Figure 12.15: Quadrant information for arc tangent

Examples:
.........

 (asin 0) ý 0.0
 (acos #c(0 1))  ý #C(1.5707963267948966 -0.8813735870195432)
 (/ (atan 1 (sqrt 3)) 6)  ý 0.087266
 (atan #c(0 2)) ý #C(-1.5707964 0.54930615)

Exceptional Situations:
.......................

ÿacosþ and ÿasinþ should signal an error of type ÿtype-errorþ if NUMBER
is not a number.  ÿatanþ should signal ÿtype-errorþ if one argument is
supplied and that argument is not a number, or if two arguments are
supplied and both of those arguments are not reals.

ÿacosþ, ÿasinþ, and ÿatanþ might signal ÿarithmetic-errorþ.

See Also:
.........

*Note log::, *Note sqrt::, *Note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

The result of either ÿasinþ or ÿacosþ can be a complex even if NUMBER
is not a complex; this occurs when the absolute value of NUMBER is
greater than one.


File: chris-ansicl.info,  Node: pi,  Next: sinh; cosh; tanh; asinh; acosh; atanh,  Prev: asin; acos; atan,  Up: Numbers

pi (Constant Variable)
======================

Value:
......

an implementation-dependent long float.

Description:
............

The best long float approximation to the mathematical constant î.

Examples:
.........

 ;; In each of the following computations, the precision depends
 ;; on the implementation.  Also, if `long float' is treated by
 ;; the implementation as equivalent to some other float format
 ;; (e.g., `double float') the exponent marker might be the marker
 ;; for that equivalent (e.g., `D' instead of `L').
 pi ý 3.141592653589793L0
 (cos pi) ý -1.0L0

 (defun sin-of-degrees (degrees)
   (let ((x (if (floatp degrees) degrees (float degrees pi))))
     (sin (* x (/ (float pi x) 180)))))

Notes:
......

An approximation to î in some other precision can be obtained by
writing ÿ(float pi x)þ, where ÿxþ is a float of the desired precision,
or by writing ÿ(coerce pi type)þ, where type is the desired type, such
as ÿshort-floatþ.


File: chris-ansicl.info,  Node: sinh; cosh; tanh; asinh; acosh; atanh,  Next: * (Function),  Prev: pi,  Up: Numbers

sinh, cosh, tanh, asinh, acosh, atanh (Function)
================================================

Syntax:
.......

 -- Function: sinh number ý result

 -- Function: cosh number ý result

 -- Function: tanh number ý result

 -- Function: asinh number ý result

 -- Function: acosh number ý result

 -- Function: atanh number ý result

Arguments and Values:
.....................

NUMBER--a number.

RESULT--a number.

Description:
............

These functions compute the hyperbolic sine, cosine, tangent, arc sine,
arc cosine, and arc tangent functions, which are mathematically defined
for an argument x as given in the next figure.

Function                 Definition
------------------------------------------------------------------ 
Hyperbolic sine          (e^x-e^-x)/2
Hyperbolic cosine        (e^x+e^-x)/2
Hyperbolic tangent       (e^x-e^-x)/(e^x+e^-x)
Hyperbolic arc sine      log (x+sqrt(1+x^2))
Hyperbolic arc cosine    2 log (sqrt((x+1)/2) + sqrt((x-1)/2))
Hyperbolic arc tangent   (log (1+x) - log(1-x))/2

Figure 12.16: Mathematical definitions for hyperbolic functions

The following definition for the inverse hyperbolic cosine determines
the range and branch cuts:

     arccosh z = 2 log (sqrt((z+1)/2) + sqrt((z-1)/2)).

The branch cut for the inverse hyperbolic cosine function lies along
the real axis to the left of 1 (inclusive), extending indefinitely
along the negative real axis, continuous with quadrant II and (between
0 and 1) with quadrant I.  The range is that half-strip of the complex
plane containing numbers whose real part is non-negative and whose
imaginary part is between -î (exclusive) and î (inclusive).  A number
with real part zero is in the range if its imaginary part is between
zero (inclusive) and î (inclusive).

The following definition for the inverse hyperbolic sine determines the
range and branch cuts:

     arcsinh z = log (z+sqrt(1+z^2)).

The branch cut for the inverse hyperbolic sine function is in two
pieces: one along the positive imaginary axis above i (inclusive),
continuous with quadrant I, and one along the negative imaginary axis
below -i (inclusive), continuous with quadrant III.  The range is that
strip of the complex plane containing numbers whose imaginary part is
between -î/2 and î/2.  A number with imaginary part equal to -î/2 is in
the range if and only if its real part is non-positive; a number with
imaginary part equal to î/2 is in the range if and only if its
imaginary part is non-negative.

The following definition for the inverse hyperbolic tangent determines
the range and branch cuts:

     arctanh z = (log (1+z) - log (1-z))/2.

Note that:

     i arctan z = arctanh iz.

The branch cut for the inverse hyperbolic tangent function is in two
pieces: one along the negative real axis to the left of -1 (inclusive),
continuous with quadrant III, and one along the positive real axis to
the right of 1 (inclusive), continuous with quadrant I.  The points -1
and 1 are excluded from the domain.  The range is that strip of the
complex plane containing numbers whose imaginary part is between -î/2
and î/2.  A number with imaginary part equal to -î/2 is in the range if
and only if its real part is strictly negative; a number with imaginary
part equal to î/2 is in the range if and only if its imaginary part is
strictly positive.  Thus the range of the inverse hyperbolic tangent
function is identical to that of the inverse hyperbolic sine function
with the points -î i/2 and î i/2 excluded.

Examples:
.........

 (sinh 0) ý 0.0
 (cosh (complex 0 -1)) ý #C(0.540302 -0.0)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NUMBER is not a number.
Might signal ÿarithmetic-errorþ.

See Also:
.........

*Note log::, *Note sqrt::, *Note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

The result of ÿacoshþ may be a complex even if NUMBER is not a complex;
this occurs when NUMBER is less than one.  Also, the result of ÿatanhþ
may be a complex even if NUMBER is not a complex; this occurs when the
absolute value of NUMBER is greater than one.

The branch cut formulae are mathematically correct, assuming completely
accurate computation.  Implementors should consult a good text on
numerical analysis.  The formulae given above are not necessarily the
simplest ones for real-valued computations; they are chosen to define
the branch cuts in desirable ways for the complex case.


File: chris-ansicl.info,  Node: * (Function),  Next: + (Function),  Prev: sinh; cosh; tanh; asinh; acosh; atanh,  Up: Numbers

* (Function)
============

Syntax:
.......

 -- Function: * &rest numbers ý product

Arguments and Values:
.....................

NUMBER--a number.

PRODUCT--a number.

Description:
............

Returns the product of NUMBERS, performing any necessary type
conversions in the process.  If no NUMBERS are supplied, ÿ1þ is
returned.

Examples:
.........

 (*) ý 1
 (* 3 5) ý 15
 (* 1.0 #c(22 33) 55/98) ý #C(12.346938775510203 18.520408163265305)

Exceptional Situations:
.......................

Might signal ÿtype-errorþ if some argument is not a number.  Might
signal ÿarithmetic-errorþ.

See Also:
.........

*Note Section 12.1.1 (Numeric Operations): Numeric Operations, *Note
Section 12.1.3 (Rational Computations): Rational Computations, *Note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *Note Section 12.1.5 (Complex Computations): Complex
Computations.


File: chris-ansicl.info,  Node: + (Function),  Next: - (Function),  Prev: * (Function),  Up: Numbers

+ (Function)
============

Syntax:
.......

 -- Function: + &rest numbers ý sum

Arguments and Values:
.....................

NUMBER--a number.

SUM--a number.

Description:
............

Returns the sum of NUMBERS, performing any necessary type conversions
in the process.  If no NUMBERS are supplied, ÿ0þ is returned.

Examples:
.........

 (+) ý 0
 (+ 1) ý 1
 (+ 31/100 69/100) ý 1
 (+ 1/5 0.8) ý 1.0

Exceptional Situations:
.......................

Might signal ÿtype-errorþ if some argument is not a number.  Might
signal ÿarithmetic-errorþ.

See Also:
.........

*Note Section 12.1.1 (Numeric Operations): Numeric Operations, *Note
Section 12.1.3 (Rational Computations): Rational Computations, *Note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *Note Section 12.1.5 (Complex Computations): Complex
Computations.


File: chris-ansicl.info,  Node: - (Function),  Next: / (Function),  Prev: + (Function),  Up: Numbers

- (Function)
============

Syntax:
.......

 -- Function: - number ý negation

 -- Function: - minuend &rest subtrahends+ ý difference

Arguments and Values:
.....................

NUMBER, MINUEND, SUBTRAHEND--a number.

NEGATION, DIFFERENCE--a number.

Description:
............

The function ÿ-þ performs arithmetic subtraction and negation.

If only one NUMBER is supplied, the negation of that NUMBER is returned.

If more than one argument is given, it subtracts all of the SUBTRAHENDS
from the MINUEND and returns the result.

The function ÿ-þ performs necessary type conversions.

Examples:
.........

 (- 55.55) ý -55.55
 (- #c(3 -5)) ý #C(-3 5)
 (- 0) ý 0
 (eql (- 0.0) -0.0) ý true
 (- #c(100 45) #c(0 45)) ý 100
 (- 10 1 2 3 4) ý 0

Exceptional Situations:
.......................

Might signal ÿtype-errorþ if some argument is not a number.  Might
signal ÿarithmetic-errorþ.

See Also:
.........

*Note Section 12.1.1 (Numeric Operations): Numeric Operations, *Note
Section 12.1.3 (Rational Computations): Rational Computations, *Note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *Note Section 12.1.5 (Complex Computations): Complex
Computations.


File: chris-ansicl.info,  Node: / (Function),  Next: 1+; 1-,  Prev: - (Function),  Up: Numbers

/ (Function)
============

Syntax:
.......

 -- Function: / number ý reciprocal

 -- Function: / numerator &rest denominators+ ý quotient

Arguments and Values:
.....................

NUMBER, DENOMINATOR--a non-zero number.

NUMERATOR, QUOTIENT, RECIPROCAL--a number.

Description:
............

The function ÿ/þ performs division or reciprocation.

If no DENOMINATORS are supplied, the function ÿ/þ returns the
reciprocal of NUMBER.

If at least one DENOMINATOR is supplied, the function ÿ/þ divides the
NUMERATOR by all of the DENOMINATORS and returns the resulting QUOTIENT.

If each argument is either an integer or a ratio, and the result is not
an integer, then it is a ratio.

The function ÿ/þ performs necessary type conversions.

If any ARGUMENT is a float then the rules of floating-point contagion
apply; see *Note Section 12.1.4 (Floating-point Computations):
Floating-point Computations.

Examples:
.........

 (/ 12 4) ý 3
 (/ 13 4) ý 13/4
 (/ -8) ý -1/8
 (/ 3 4 5) ý 3/20
 (/ 0.5) ý 2.0
 (/ 20 5) ý 4
 (/ 5 20) ý 1/4
 (/ 60 -2 3 5.0) ý -2.0
 (/ 2 #c(2 2)) ý #C(1/2 -1/2)

Exceptional Situations:
.......................

The consequences are unspecified if any argument other than the first
is zero.  If there is only one argument, the consequences are
unspecified if it is zero.

Might signal ÿtype-errorþ if some argument is not a number.  Might
signal ÿdivision-by-zeroþ if division by zero is attempted.  Might
signal ÿarithmetic-errorþ.

See Also:
.........

*Note floor::, *Note ceiling::, *Note truncate::, *Note round::


File: chris-ansicl.info,  Node: 1+; 1-,  Next: abs,  Prev: / (Function),  Up: Numbers

1+, 1- (Function)
=================

Syntax:
.......

 -- Function: 1+ number ý successor

 -- Function: 1- number ý predecessor

Arguments and Values:
.....................

NUMBER--a number.

SUCCESSOR, PREDECESSOR--a number.

Description:
............

ÿ1+þ returns a number that is one more than its argument NUMBER.  ÿ1-þ
returns a number that is one less than its argument NUMBER.

Examples:
.........

 (1+ 99) ý 100
 (1- 100) ý 99
 (1+ (complex 0.0)) ý #C(1.0 0.0)
 (1- 5/3) ý 2/3

Exceptional Situations:
.......................

Might signal ÿtype-errorþ if its argument is not a number.  Might
signal ÿarithmetic-errorþ.

See Also:
.........

*Note incf::, *Note decf::

Notes:
......

 (1+ NUMBER) Õ (+ NUMBER 1)
 (1- NUMBER) Õ (- NUMBER 1)

Implementors are encouraged to make the performance of both the previous
expressions be the same.


File: chris-ansicl.info,  Node: abs,  Next: evenp; oddp,  Prev: 1+; 1-,  Up: Numbers

abs (Function)
==============

Syntax:
.......

 -- Function: abs number ý absolute-value

Arguments and Values:
.....................

NUMBER--a number.

ABSOLUTE-VALUE--a non-negative real.

Description:
............

ÿabsþ returns the absolute value of NUMBER.

If NUMBER is a real, the result is  of the same type as NUMBER.

If NUMBER is a complex, the result is a positive real with the same
magnitude as NUMBER.  The result can be a float

even if NUMBER's components are rationals and an exact rational result
would have been possible.  Thus the result of ÿ(abs #c(3 4))þ can be
either ÿ5þ or ÿ5.0þ, depending on the implementation.

Examples:
.........

 (abs 0) ý 0
 (abs 12/13) ý 12/13
 (abs -1.09) ý 1.09
 (abs #c(5.0 -5.0)) ý 7.071068
 (abs #c(5 5)) ý 7.071068
 (abs #c(3/5 4/5)) ý 1 or approximately 1.0
 (eql (abs -0.0) -0.0) ý true

See Also:
.........

*Note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

If NUMBER is a complex, the result is equivalent to the following:

ÿ(sqrt (+ (expt (realpart NUMBER) 2)  (expt (imagpart NUMBER) 2)))þ

An implementation should not use this formula directly for all complexes
but should handle very large or very small components specially to
avoid intermediate overflow or underflow.


File: chris-ansicl.info,  Node: evenp; oddp,  Next: exp; expt,  Prev: abs,  Up: Numbers

evenp, oddp (Function)
======================

Syntax:
.......

 -- Function: evenp integer ý generalized-boolean

 -- Function: oddp integer ý generalized-boolean

Arguments and Values:
.....................

INTEGER--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿevenpþ returns true if INTEGER is even (divisible by two); otherwise,
returns false.

ÿoddpþ returns true if INTEGER is odd (not divisible by two);
otherwise, returns false.

Examples:
.........

 (evenp 0) ý true
 (oddp 10000000000000000000000) ý false
 (oddp -1) ý true

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INTEGER is not an
integer.

Notes:
......

 (evenp INTEGER) Õ (not (oddp INTEGER))
 (oddp INTEGER)  Õ (not (evenp INTEGER))


File: chris-ansicl.info,  Node: exp; expt,  Next: gcd,  Prev: evenp; oddp,  Up: Numbers

exp, expt (Function)
====================

Syntax:
.......

 -- Function: exp number ý result

 -- Function: expt base-number power-number ý result

Arguments and Values:
.....................

NUMBER--a number.

BASE-NUMBER--a number.

POWER-NUMBER--a number.

RESULT--a number.

Description:
............

ÿexpþ and ÿexptþ perform exponentiation.

ÿexpþ returns e raised to the power NUMBER, where e is the base of the
natural logarithms.  ÿexpþ has no branch cut.

ÿexptþ returns BASE-NUMBER raised to the power POWER-NUMBER.  If the
BASE-NUMBER is a rational and POWER-NUMBER is an integer, the
calculation is exact and the result will be of type ÿrationalþ;
otherwise a floating-point approximation might result.  For ÿexptþ of a
complex rational to an integer power, the calculation must be exact and
the result is of type ÿ(or rational (complex rational))þ.

The result of ÿexptþ can be a complex, even when neither argument is a
complex, if BASE-NUMBER is negative and POWER-NUMBER is not an integer.
The result is always the principal complex value.  For example, ÿ(expt
-8 1/3)þ is not permitted to return ÿ-2þ, even though ÿ-2þ is one of
the cube roots of ÿ-8þ.  The principal cube root is a complex
approximately equal to ÿ#C(1.0 1.73205)þ, not ÿ-2þ.

ÿexptþ is defined as b^x = e^x log b.  This defines the principal
values precisely.  The range of ÿexptþ is the entire complex plane.
Regarded as a function of x, with b fixed, there is no branch cut.
Regarded as a function of b, with x fixed, there is in general a branch
cut along the negative real axis, continuous with quadrant II.  The
domain excludes the origin.  By definition, 0^0=1.  If b=0 and the real
part of x is strictly positive, then b^x=0. For all other values of x,
0^x is an error.

When POWER-NUMBER is an integer ÿ0þ, then the result is always the
value one in the type of BASE-NUMBER, even if the BASE-NUMBER is zero
(of any type).  That is:

 (expt x 0) Õ (coerce 1 (type-of x))

If POWER-NUMBER is a zero of any other type, then the result is also
the value one, in the type of the arguments after the application of
the contagion rules in *Note Section 12.1.1.2 (Contagion in Numeric
Operations): NumericContagionRules, with one exception: the
consequences are undefined if BASE-NUMBER is zero when POWER-NUMBER is
zero and not of type ÿintegerþ.

Examples:
.........

 (exp 0) ý 1.0
 (exp 1) ý 2.718282
 (exp (log 5)) ý 5.0
 (expt 2 8) ý 256
 (expt 4 .5) ý 2.0
 (expt #c(0 1) 2) ý -1
 (expt #c(2 2) 3) ý #C(-16 16)
 (expt #c(2 2) 4) ý -64

See Also:
.........

*Note log::, *Note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

Implementations of ÿexptþ are permitted to use different algorithms for
the cases of a POWER-NUMBER of type ÿrationalþ and a POWER-NUMBER of
type ÿfloatþ.

Note that by the following logic, ÿ(sqrt (expt x 3))þ is not equivalent
to ÿ(expt x 3/2)þ.

 (setq x (exp (/ (* 2 pi #c(0 1)) 3)))         ;exp(2.pi.i/3)
 (expt x 3) ý 1 ;except for round-off error
 (sqrt (expt x 3)) ý 1 ;except for round-off error
 (expt x 3/2) ý -1 ;except for round-off error


File: chris-ansicl.info,  Node: gcd,  Next: incf; decf,  Prev: exp; expt,  Up: Numbers

gcd (Function)
==============

Syntax:
.......

 -- Function: gcd &rest integers ý greatest-common-denominator

Arguments and Values:
.....................

INTEGER--an integer.

GREATEST-COMMON-DENOMINATOR--a non-negative integer.

Description:
............

Returns the greatest common divisor of INTEGERS.  If only one INTEGER
is supplied, its absolute value is returned.  If no INTEGERS are given,
ÿgcdþ returns ÿ0þ, which is an identity for this operation.

Examples:
.........

 (gcd) ý 0
 (gcd 60 42) ý 6
 (gcd 3333 -33 101) ý 1
 (gcd 3333 -33 1002001) ý 11
 (gcd 91 -49) ý 7
 (gcd 63 -42 35) ý 7
 (gcd 5) ý 5
 (gcd -4) ý 4

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INTEGER is not an
integer.

See Also:
.........

*Note lcm::

Notes:
......

For three or more arguments,

 (gcd b c ... z) Õ (gcd (gcd a b) c ... z)


File: chris-ansicl.info,  Node: incf; decf,  Next: lcm,  Prev: gcd,  Up: Numbers

incf, decf (Macro)
==================

Syntax:
.......

 -- Macro: incf place [delta-form] ý new-value

 -- Macro: decf place [delta-form] ý new-value

Arguments and Values:
.....................

PLACE--a place.

DELTA-FORM--a form; evaluated to produce a DELTA.  The default is ÿ1þ.

DELTA--a number.

NEW-VALUE--a number.

Description:
............

ÿincfþ and ÿdecfþ are used for incrementing and decrementing the value
of PLACE, respectively.

The DELTA is added to        (in the case of ÿincfþ) or subtracted from
(in the case of ÿdecfþ) the number in PLACE and the result is stored in
PLACE.

Any necessary type conversions are performed automatically.

For information about the evaluation of subforms of PLACES, see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq n 0)
 (incf n) ý 1
 n ý 1
 (decf n 3) ý -2
 n ý -2
 (decf n -5) ý 3
 (decf n) ý 2
 (incf n 0.5) ý 2.5
 (decf n) ý 1.5
 n ý 1.5

Side Effects:
.............

PLACE is modified.

See Also:
.........

*Note + (Function)::, *Note - (Function)::, *Note 1+::, *Note 1-
(Function)::, *Note setf::


File: chris-ansicl.info,  Node: lcm,  Next: log,  Prev: incf; decf,  Up: Numbers

lcm (Function)
==============

Syntax:
.......

 -- Function: lcm &rest integers ý least-common-multiple

Arguments and Values:
.....................

INTEGER--an integer.

LEAST-COMMON-MULTIPLE--a non-negative integer.

Description:
............

ÿlcmþ returns the least common multiple of the INTEGERS.

If no INTEGER is supplied, the integer ÿ1þ is returned.

If only one INTEGER is supplied, the absolute value of that INTEGER is
returned.

For two arguments that are not both zero,

 (lcm a b) Õ (/ (abs (* a b)) (gcd a b))

If one or both arguments are zero,

 (lcm a 0) Õ (lcm 0 a) Õ 0

For three or more arguments,

 (lcm a b c ... z) Õ (lcm (lcm a b) c ... z)

Examples:
.........

 (lcm 10) ý 10
 (lcm 25 30) ý 150
 (lcm -24 18 10) ý 360
 (lcm 14 35) ý 70
 (lcm 0 5) ý 0
 (lcm 1 2 3 4 5 6) ý 60

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if any argument is not an integer.

See Also:
.........

*Note gcd::


File: chris-ansicl.info,  Node: log,  Next: mod; rem,  Prev: lcm,  Up: Numbers

log (Function)
==============

Syntax:
.......

 -- Function: log number &optional base ý logarithm

Arguments and Values:
.....................

NUMBER--a non-zero number.

BASE--a number.

LOGARITHM--a number.

Description:
............

ÿlogþ returns the logarithm of NUMBER in base BASE.  If BASE is not
supplied its value is e, the base of the natural logarithms.

ÿlogþ may return a complex when given a real negative NUMBER.

 (log -1.0) Õ (complex 0.0 (float pi 0.0))

If BASE is zero, ÿlogþ returns zero.

The result of ÿ(log 8 2)þ may be either ÿ3þ or ÿ3.0þ, depending on the
implementation. An implementation can use floating-point calculations
even if an exact integer result is possible.

The branch cut for the logarithm function of one argument (natural
logarithm) lies along the negative real axis, continuous with quadrant
II.  The domain excludes the origin.

The mathematical definition of a complex logarithm is as follows,
whether or not minus zero is supported by the implementation:

(log x) Õ (complex (log (abs x)) (phase x))

Therefore the range of the one-argument logarithm function is that strip
of the complex plane containing numbers with imaginary parts between -î
(exclusive) and î (inclusive) if minus zero is not supported, or -î
(inclusive) and î (inclusive) if minus zero is supported.

The two-argument logarithm function is defined as

 (log BASE NUMBER)
 Õ (/ (log NUMBER) (log BASE))

This defines the principal values precisely.  The range of the
two-argument logarithm function is the entire complex plane.

Examples:
.........

 (log 100 10)
ý 2.0
ý 2
 (log 100.0 10) ý 2.0
 (log #c(0 1) #c(0 -1))
ý #C(-1.0 0.0)
orý #C(-1 0)
 (log 8.0 2) ý 3.0

 (log #c(-16 16) #c(2 2)) ý 3 or approximately #c(3.0 0.0)
                               or approximately 3.0 (unlikely)

Affected By:
............

The implementation.

See Also:
.........

*Note exp::, *Note expt::, *Note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.


File: chris-ansicl.info,  Node: mod; rem,  Next: signum,  Prev: log,  Up: Numbers

mod, rem (Function)
===================

Syntax:
.......

 -- Function: mod number divisor ý modulus

 -- Function: rem number divisor ý remainder

Arguments and Values:
.....................

NUMBER--a real.

DIVISOR--a real.

MODULUS, REMAINDER--a real.

Description:
............

ÿmodþ and ÿremþ are generalizations of the modulus and remainder
functions respectively.

ÿmodþ performs the operation ÿfloorþ on NUMBER and DIVISOR and returns
the remainder of the ÿfloorþ operation.

ÿremþ performs the operation ÿtruncateþ on NUMBER and DIVISOR and
returns the remainder of the ÿtruncateþ operation.

ÿmodþ and ÿremþ are the modulus and remainder functions when NUMBER and
DIVISOR are integers.

Examples:
.........

 (rem -1 5) ý -1
 (mod -1 5) ý 4
 (mod 13 4) ý 1
 (rem 13 4) ý 1
 (mod -13 4) ý 3
 (rem -13 4) ý -1
 (mod 13 -4) ý -3
 (rem 13 -4) ý 1
 (mod -13 -4) ý -1
 (rem -13 -4) ý -1
 (mod 13.4 1) ý 0.4
 (rem 13.4 1) ý 0.4
 (mod -13.4 1) ý 0.6
 (rem -13.4 1) ý -0.4

See Also:
.........

*Note floor::, *Note truncate::

Notes:
......

The result of ÿmodþ is either zero or a real with the same sign as
DIVISOR.


File: chris-ansicl.info,  Node: signum,  Next: sqrt; isqrt,  Prev: mod; rem,  Up: Numbers

signum (Function)
=================

Syntax:
.......

 -- Function: signum number ý signed-prototype

Arguments and Values:
.....................

NUMBER--a number.

SIGNED-PROTOTYPE--a number.

Description:
............

ÿsignumþ determines a numerical value that indicates whether NUMBER is
negative, zero, or positive.

For a rational, ÿsignumþ returns one of ÿ-1þ, ÿ0þ, or ÿ1þ according to
whether NUMBER is negative, zero, or positive.  For a float, the result
is a float of the same format whose value is minus one, zero, or one.
For a complex number ÿzþ, ÿ(signum z)þ is a complex number of the same
phase but with unit magnitude, unless ÿzþ is a complex zero, in which
case the result is ÿzþ.

For rational arguments, ÿsignumþ is a rational function, but it may be
irrational for complex arguments.

If NUMBER is a float, the result is a float.  If NUMBER is a rational,
the result is a rational.  If NUMBER is a complex float, the result is
a complex float.  If NUMBER is a complex rational, the result is a
complex, but it is implementation-dependent whether that result is a
complex rational or a complex float.

Examples:
.........

 (signum 0) ý 0
 (signum 99) ý 1
 (signum 4/5) ý 1
 (signum -99/100) ý -1
 (signum 0.0) ý 0.0
 (signum #c(0 33)) ý #C(0.0 1.0)
 (signum #c(7.5 10.0)) ý #C(0.6 0.8)
 (signum #c(0.0 -14.7)) ý #C(0.0 -1.0)
 (eql (signum -0.0) -0.0) ý true

See Also:
.........

*Note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

 (signum x) Õ (if (zerop x) x (/ x (abs x)))


File: chris-ansicl.info,  Node: sqrt; isqrt,  Next: random-state,  Prev: signum,  Up: Numbers

sqrt, isqrt (Function)
======================

Syntax:
.......

 -- Function: sqrt number ý root

 -- Function: isqrt natural ý natural-root

Arguments and Values:
.....................

NUMBER, ROOT--a number.

NATURAL, NATURAL-ROOT--a non-negative integer.

Description:
............

ÿsqrtþ and ÿisqrtþ compute square roots.

ÿsqrtþ returns the principal square root of NUMBER.  If the NUMBER is
not a complex but is negative, then the result is a complex.

ÿisqrtþ returns the greatest integer less than or equal to the exact
positive square root of NATURAL.

If NUMBER is a positive rational, it is implementation-dependent
whether ROOT is a rational or a float.  If NUMBER is a negative
rational, it is implementation-dependent whether ROOT is a complex
rational or a complex float.

The mathematical definition of complex square root (whether or not
minus zero is supported) follows:

ÿ(sqrt x) = (exp (/ (log x) 2))þ

The branch cut for square root lies along the negative real axis,
continuous with quadrant II.  The range consists of the right
half-plane, including the non-negative imaginary axis and excluding the
negative imaginary axis.

Examples:
.........

 (sqrt 9.0) ý 3.0
 (sqrt -9.0) ý #C(0.0 3.0)
 (isqrt 9) ý 3
 (sqrt 12) ý 3.4641016
 (isqrt 12) ý 3
 (isqrt 300) ý 17
 (isqrt 325) ý 18
 (sqrt 25)
ý 5
orý 5.0
 (isqrt 25) ý 5
 (sqrt -1) ý #C(0.0 1.0)
 (sqrt #c(0 2)) ý #C(1.0 1.0)

Exceptional Situations:
.......................

The function ÿsqrtþ should signal ÿtype-errorþ if its argument is not a
number.

The function ÿisqrtþ should signal ÿtype-errorþ if its argument is not
a non-negative integer.

The functions ÿsqrtþ and ÿisqrtþ might signal ÿarithmetic-errorþ.

See Also:
.........

*Note exp::, *Note log::, *Note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

 (isqrt x) Õ (values (floor (sqrt x)))

but it is potentially more efficient.


File: chris-ansicl.info,  Node: random-state,  Next: make-random-state,  Prev: sqrt; isqrt,  Up: Numbers

random-state (System Class)
===========================

Class Precedence List:
......................

ÿrandom-stateþ, ÿtþ

Description:
............

A random state object contains state information used by the
pseudo-random number generator.  The nature of a random state object is
implementation-dependent.  It can be printed out and successfully read
back in by the same implementation, but might not function correctly as
a random state in another implementation.

Implementations are required to provide a read syntax for objects of
type ÿrandom-stateþ, but the specific nature of that syntax is
implementation-dependent.

See Also:
.........

*Note *random-state*::, *Note random::, *Note Section 22.1.3.10
(Printing Random States): PrintingRandomStates.


File: chris-ansicl.info,  Node: make-random-state,  Next: random,  Prev: random-state,  Up: Numbers

make-random-state (Function)
============================

Syntax:
.......

 -- Function: make-random-state &optional state ý new-state

Arguments and Values:
.....................

STATE--a random state, or ÿnilþ, or ÿtþ.  The default is ÿnilþ.

NEW-STATE--a random state object.

Description:
............

Creates a fresh object of type ÿrandom-stateþ suitable for use as the
value of ÿ*random-state*þ.

If STATE is a random state object, the NEW-STATE is a copyÝ of that
object.  If STATE is ÿnilþ, the NEW-STATE is a copyÝ of the current
random state.  If STATE is ÿtþ, the NEW-STATE is a fresh random state
object that has been randomly initialized by some means.

Examples:
.........

 (let* ((rs1 (make-random-state nil))
        (rs2 (make-random-state t))
        (rs3 (make-random-state rs2))
        (rs4 nil))
   (list (loop for i from 1 to 10
               collect (random 100)
               when (= i 5)
                do (setq rs4 (make-random-state)))
         (loop for i from 1 to 10 collect (random 100 rs1))
         (loop for i from 1 to 10 collect (random 100 rs2))
         (loop for i from 1 to 10 collect (random 100 rs3))
         (loop for i from 1 to 10 collect (random 100 rs4))))
ý ((29 25 72 57 55 68 24 35 54 65)
    (29 25 72 57 55 68 24 35 54 65)
    (93 85 53 99 58 62 2 23 23 59)
    (93 85 53 99 58 62 2 23 23 59)
    (68 24 35 54 65 54 55 50 59 49))

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STATE is not a random
state, or ÿnilþ, or ÿtþ.

See Also:
.........

*Note random::, *Note *random-state*::

Notes:
......

One important use of ÿmake-random-stateþ is to allow the same series of
pseudo-random numbers to be generated many times within a single
program.


File: chris-ansicl.info,  Node: random,  Next: random-state-p,  Prev: make-random-state,  Up: Numbers

random (Function)
=================

Syntax:
.......

 -- Function: random limit &optional random-state ý random-number

Arguments and Values:
.....................

LIMIT--a positive integer, or a positive float.

RANDOM-STATE--a random state.  The default is the current random state.

RANDOM-NUMBER--a non-negative number less than LIMIT and of the same
type as LIMIT.

Description:
............

Returns a pseudo-random number that is a non-negative number less than
LIMIT and of the same type as LIMIT.

The RANDOM-STATE, which is modified by this function, encodes the
internal state maintained by the random number generator.

An approximately uniform choice distribution is used.  If LIMIT is an
integer, each of the possible results occurs with (approximate)
probability 1/LIMIT.

Examples:
.........

 (<= 0 (random 1000) 1000) ý true
 (let ((state1 (make-random-state))
       (state2 (make-random-state)))
   (= (random 1000 state1) (random 1000 state2))) ý true

Side Effects:
.............

The RANDOM-STATE is modified.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if LIMIT is not a positive
integer or a positive real.

See Also:
.........

*Note make-random-state::, *Note *random-state*::

Notes:
......

See `Common Lisp: The Language' for information about generating random
numbers.


File: chris-ansicl.info,  Node: random-state-p,  Next: *random-state*,  Prev: random,  Up: Numbers

random-state-p (Function)
=========================

Syntax:
.......

 -- Function: random-state-p object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿrandom-stateþ; otherwise, returns
false.

Examples:
.........

 (random-state-p *random-state*) ý true
 (random-state-p (make-random-state)) ý true
 (random-state-p 'test-function) ý false

See Also:
.........

*Note make-random-state::, *Note *random-state*::

Notes:
......

 (random-state-p OBJECT) Õ (typep OBJECT 'random-state)


File: chris-ansicl.info,  Node: *random-state*,  Next: numberp,  Prev: random-state-p,  Up: Numbers

*random-state* (Variable)
=========================

Value Type:
...........

a random state.

Initial Value:
..............

implementation-dependent.

Description:
............

The current random state, which is used, for example, by the function
ÿrandomþ when a random state is not explicitly supplied.

Examples:
.........

 (random-state-p *random-state*) ý true
 (setq snap-shot (make-random-state))
 ;; The series from any given point is random,
 ;; but if you backtrack to that point, you get the same series.
 (list (loop for i from 1 to 10 collect (random))
       (let ((*random-state* snap-shot))
         (loop for i from 1 to 10 collect (random)))
       (loop for i from 1 to 10 collect (random))
       (let ((*random-state* snap-shot))
         (loop for i from 1 to 10 collect (random))))
ý ((19 16 44 19 96 15 76 96 13 61)
    (19 16 44 19 96 15 76 96 13 61)
    (16 67 0 43 70 79 58 5 63 50)
    (16 67 0 43 70 79 58 5 63 50))

Affected By:
............

The implementation.

ÿrandomþ.

See Also:
.........

*Note make-random-state::, *Note random::, *Note random-state::

Notes:
......

Binding ÿ*random-state*þ to a different random state object correctly
saves and restores the old random state object.


File: chris-ansicl.info,  Node: numberp,  Next: cis,  Prev: *random-state*,  Up: Numbers

numberp (Function)
==================

Syntax:
.......

 -- Function: numberp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿnumberþ; otherwise, returns false.

Examples:
.........

 (numberp 12) ý true
 (numberp (expt 2 130)) ý true
 (numberp #c(5/3 7.2)) ý true
 (numberp nil) ý false
 (numberp (cons 1 2)) ý false

Notes:
......

 (numberp OBJECT) Õ (typep OBJECT 'number)


File: chris-ansicl.info,  Node: cis,  Next: complex (Function),  Prev: numberp,  Up: Numbers

cis (Function)
==============

Syntax:
.......

 -- Function: cis radians ý number

Arguments and Values:
.....................

RADIANS--a real.

NUMBER--a complex.

Description:
............

ÿcisþ returns the value of e^ië radians, which is a complex in which the
real part is equal to the cosine of RADIANS, and the imaginary part is
equal to the sine of RADIANS.

Examples:
.........

 (cis 0) ý #C(1.0 0.0)

See Also:
.........

*Note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.


File: chris-ansicl.info,  Node: complex (Function),  Next: complexp,  Prev: cis,  Up: Numbers

complex (Function)
==================

Syntax:
.......

 -- Function: complex realpart &optional imagpart ý complex

Arguments and Values:
.....................

REALPART--a real.

IMAGPART--a real.

COMPLEX--a rational or a complex.

Description:
............

ÿcomplexþ returns a number whose real      part is REALPART and whose
imaginary part is IMAGPART.

If REALPART is a rational and IMAGPART is the rational number zero, the
result of ÿcomplexþ is REALPART, a rational.  Otherwise, the result is
a complex.

If either REALPART or IMAGPART is a float, the non-float is converted
to a float before the complex is created.  If IMAGPART is not supplied,
the imaginary part is a zero of the same type as REALPART; i.e.,
ÿ(coerce 0 (type-of REALPART))þ is effectively used.

Type upgrading implies a movement upwards in the type hierarchy lattice.
In the case of complexes, the TYPE-SPECIFIER

must be a subtype of ÿ(upgraded-complex-part-type TYPE-SPECIFIER)þ.  If
TYPE-SPECIFIER1 is a subtype of TYPE-SPECIFIER2, then
ÿ(upgraded-complex-element-type 'TYPE-SPECIFIER1)þ must also be a
subtype of ÿ(upgraded-complex-element-type 'TYPE-SPECIFIER2)þ.  Two
disjoint types can be upgraded into the same thing.

Examples:
.........

 (complex 0) ý 0
 (complex 0.0) ý #C(0.0 0.0)
 (complex 1 1/2) ý #C(1 1/2)
 (complex 1 .99) ý #C(1.0 0.99)
 (complex 3/2 0.0) ý #C(1.5 0.0)

See Also:
.........

*Note realpart::, *Note imagpart::, *Note Section 2.4.8.11 (Sharpsign
C): SharpsignC.


File: chris-ansicl.info,  Node: complexp,  Next: conjugate,  Prev: complex (Function),  Up: Numbers

complexp (Function)
===================

Syntax:
.......

 -- Function: complexp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿcomplexþ; otherwise, returns false.

Examples:
.........

 (complexp 1.2d2) ý false
 (complexp #c(5/3 7.2)) ý true

See Also:
.........

*Note complex (Function):: (function and type), *Note typep::

Notes:
......

 (complexp OBJECT) Õ (typep OBJECT 'complex)


File: chris-ansicl.info,  Node: conjugate,  Next: phase,  Prev: complexp,  Up: Numbers

conjugate (Function)
====================

Syntax:
.......

 -- Function: conjugate number ý conjugate

Arguments and Values:
.....................

NUMBER--a number.

CONJUGATE--a number.

Description:
............

Returns the complex conjugate of NUMBER.  The conjugate of a real
number is itself.

Examples:
.........

 (conjugate #c(0 -1)) ý #C(0 1)
 (conjugate #c(1 1)) ý #C(1 -1)
 (conjugate 1.5) ý 1.5
 (conjugate #C(3/5 4/5)) ý #C(3/5 -4/5)
 (conjugate #C(0.0D0 -1.0D0)) ý #C(0.0D0 1.0D0)
 (conjugate 3.7) ý 3.7

Notes:
......

For a complex number ÿzþ,

 (conjugate z) Õ (complex (realpart z) (- (imagpart z)))


File: chris-ansicl.info,  Node: phase,  Next: realpart; imagpart,  Prev: conjugate,  Up: Numbers

phase (Function)
================

Syntax:
.......

 -- Function: phase number ý phase

Arguments and Values:
.....................

NUMBER--a number.

PHASE--a number.

Description:
............

ÿphaseþ returns the phase of NUMBER (the angle part of its polar
representation) in radians, in the range -î (exclusive) if minus zero
is not supported, or -î (inclusive) if minus zero is supported, to î
(inclusive).  The phase of a positive real number is zero; that of a
negative real number is î.  The phase of zero is defined to be zero.

If NUMBER is a complex float, the result is a float of the same type as
the components of NUMBER.  If NUMBER is a float, the result is a float
of the same type.  If NUMBER is a rational or a complex rational, the
result is a single float.

The branch cut for ÿphaseþ lies along the negative real axis,
continuous with quadrant II.  The range consists of that portion of the
real axis between -î (exclusive) and î (inclusive).

The mathematical definition of ÿphaseþ is as follows:

ÿ(phase x) = (atan (imagpart x) (realpart x))þ

Examples:
.........

 (phase 1) ý 0.0s0
 (phase 0) ý 0.0s0
 (phase (cis 30)) ý -1.4159266
 (phase #c(0 1)) ý 1.5707964

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if its argument is not a number.  Might
signal ÿarithmetic-errorþ.

See Also:
.........

*Note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.


File: chris-ansicl.info,  Node: realpart; imagpart,  Next: upgraded-complex-part-type,  Prev: phase,  Up: Numbers

realpart, imagpart (Function)
=============================

Syntax:
.......

 -- Function: realpart number ý real

 -- Function: imagpart number ý real

Arguments and Values:
.....................

NUMBER--a number.

REAL--a real.

Description:
............

ÿrealpartþ and ÿimagpartþ return the real and imaginary parts of NUMBER
respectively.  If NUMBER is real, then ÿrealpartþ returns NUMBER and
ÿimagpartþ returns ÿ(* 0 NUMBER)þ, which has the effect that the
imaginary part of a rational is ÿ0þ and that of a float is a
floating-point zero of the same format.

Examples:
.........

 (realpart #c(23 41)) ý 23
 (imagpart #c(23 41.0)) ý 41.0
 (realpart #c(23 41.0)) ý 23.0
 (imagpart 23.0) ý 0.0

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NUMBER is not a number.

See Also:
.........

*Note complex (Function)::


File: chris-ansicl.info,  Node: upgraded-complex-part-type,  Next: realp,  Prev: realpart; imagpart,  Up: Numbers

upgraded-complex-part-type (Function)
=====================================

Syntax:
.......

 -- Function: upgraded-complex-part-type typespec &optional environment
          ý upgraded-typespec

Arguments and Values:
.....................

TYPESPEC--a type specifier.

ENVIRONMENT--an environment object.  The default is ÿnilþ, denoting the
null lexical environment and the and current global environment.

UPGRADED-TYPESPEC--a type specifier.

Description:
............

ÿupgraded-complex-part-typeþ returns the part type of the most
specialized complex number representation that can hold parts of type
typespec.

The TYPESPEC is a subtype of (and possibly type equivalent to) the
UPGRADED-TYPESPEC.

The purpose of ÿupgraded-complex-part-typeþ is to reveal how an
implementation does its upgrading.

See Also:
.........

*Note complex (Function):: (function and type)

Notes:
......


File: chris-ansicl.info,  Node: realp,  Next: numerator; denominator,  Prev: upgraded-complex-part-type,  Up: Numbers

realp (Function)
================

Syntax:
.......

 -- Function: realp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿrealþ; otherwise, returns false.

Examples:
.........

 (realp 12) ý true
 (realp #c(5/3 7.2)) ý false
 (realp nil) ý false
 (realp (cons 1 2)) ý false

Notes:
......

 (realp OBJECT) Õ (typep OBJECT 'real)


File: chris-ansicl.info,  Node: numerator; denominator,  Next: rational; rationalize,  Prev: realp,  Up: Numbers

numerator, denominator (Function)
=================================

Syntax:
.......

 -- Function: numerator rational ý numerator

 -- Function: denominator rational ý denominator

Arguments and Values:
.....................

RATIONAL--a rational.

NUMERATOR--an integer.

DENOMINATOR--a positive integer.

Description:
............

ÿnumeratorþ and ÿdenominatorþ reduce RATIONAL to canonical form and
compute the numerator or denominator of that number.

ÿnumeratorþ and ÿdenominatorþ return the numerator or denominator of
the canonical form of RATIONAL.

If RATIONAL is an integer, ÿnumeratorþ returns RATIONAL and
ÿdenominatorþ returns 1.

Examples:
.........

 (numerator 1/2) ý 1
 (denominator 12/36) ý 3
 (numerator -1) ý -1
 (denominator (/ -33)) ý 33
 (numerator (/ 8 -6)) ý -4
 (denominator (/ 8 -6)) ý 3

See Also:
.........

*Note / (Function)::

Notes:
......

 (gcd (numerator x) (denominator x)) ý 1


File: chris-ansicl.info,  Node: rational; rationalize,  Next: rationalp,  Prev: numerator; denominator,  Up: Numbers

rational, rationalize (Function)
================================

Syntax:
.......

 -- Function: rational number ý rational

 -- Function: rationalize number ý rational

Arguments and Values:
.....................

NUMBER--a real.

RATIONAL--a rational.

Description:
............

ÿrationalþ and ÿrationalizeþ convert reals to rationals.

If NUMBER is already rational, it is returned.

If NUMBER is a float, ÿrationalþ returns a rational that is
mathematically equal in value to the float.  ÿrationalizeþ returns a
rational that approximates the float to the accuracy of the underlying
floating-point representation.

ÿrationalþ assumes that the float is completely accurate.

ÿrationalizeþ assumes that the float is accurate only to the precision
of the floating-point representation.

Examples:
.........

 (rational 0) ý 0
 (rationalize -11/100) ý -11/100
 (rational .1) ý 13421773/134217728 ;implementation-dependent
 (rationalize .1) ý 1/10

Affected By:
............

The implementation.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NUMBER is not a real.
Might signal ÿarithmetic-errorþ.

Notes:
......

It is always the case that

 (float (rational x) x) Õ x

and

 (float (rationalize x) x) Õ x

That is, rationalizing a float by either method and then converting it
back to a float of the same format produces the original NUMBER.


File: chris-ansicl.info,  Node: rationalp,  Next: ash,  Prev: rational; rationalize,  Up: Numbers

rationalp (Function)
====================

Syntax:
.......

 -- Function: rationalp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿrationalþ; otherwise, returns false.

Examples:
.........

 (rationalp 12) ý true
 (rationalp 6/5) ý true
 (rationalp 1.212) ý false

See Also:
.........

*Note rational::

Notes:
......

 (rationalp OBJECT) Õ (typep OBJECT 'rational)


File: chris-ansicl.info,  Node: ash,  Next: integer-length,  Prev: rationalp,  Up: Numbers

ash (Function)
==============

Syntax:
.......

 -- Function: ash integer count ý shifted-integer

Arguments and Values:
.....................

INTEGER--an integer.

COUNT--an integer.

SHIFTED-INTEGER--an integer.

Description:
............

ÿashþ performs the arithmetic shift operation on the binary
representation of INTEGER, which is treated as if it were binary.

ÿashþ shifts INTEGER arithmetically left by COUNT bit positions if
COUNT is positive, or right COUNT bit positions if COUNT is negative.
The shifted value of the same sign as INTEGER is returned.

Mathematically speaking, ÿashþ performs the computation
ÿfloorþ(INTEGERë 2^COUNT).  Logically, ÿashþ moves all of the bits in
INTEGER to the left, adding zero-bits at the right, or moves them to
the right, discarding bits.

ÿashþ is defined to behave as if INTEGER were represented in two's
complement form, regardless of how integers are represented internally.

Examples:
.........

 (ash 16 1) ý 32
 (ash 16 0) ý 16
 (ash 16 -1) ý 8
 (ash -100000000000000000000000000000000 -100) ý -79

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INTEGER is not an
integer.  Should signal an error of type ÿtype-errorþ if COUNT is not
an integer.  Might signal ÿarithmetic-errorþ.

Notes:
......

 (logbitp J (ash N K))
 Õ (and (>= J K) (logbitp (- J K) N))


File: chris-ansicl.info,  Node: integer-length,  Next: integerp,  Prev: ash,  Up: Numbers

integer-length (Function)
=========================

Syntax:
.......

 -- Function: integer-length integer ý number-of-bits

Arguments and Values:
.....................

INTEGER--an integer.

NUMBER-OF-BITS--a non-negative integer.

Description:
............

Returns the number of bits needed to represent INTEGER in binary
two's-complement format.

Examples:
.........

 (integer-length 0) ý 0
 (integer-length 1) ý 1
 (integer-length 3) ý 2
 (integer-length 4) ý 3
 (integer-length 7) ý 3
 (integer-length -1) ý 0
 (integer-length -4) ý 2
 (integer-length -7) ý 3
 (integer-length -8) ý 3
 (integer-length (expt 2 9)) ý 10
 (integer-length (1- (expt 2 9))) ý 9
 (integer-length (- (expt 2 9))) ý 9
 (integer-length (- (1+ (expt 2 9)))) ý 10

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INTEGER is not an
integer.

Notes:
......

This function could have been defined by:

(defun integer-length (integer)
  (ceiling (log (if (minusp integer)
                    (- integer)
                    (1+ integer))
                2)))

If INTEGER is non-negative, then its value can be represented in
unsigned binary form in a field whose width in bits is no smaller than
ÿ(integer-length INTEGER)þ.  Regardless of the sign of INTEGER, its
value can be represented in signed binary two's-complement form in a
field whose width in bits is no smaller than ÿ(+ (integer-length
INTEGER) 1)þ.


File: chris-ansicl.info,  Node: integerp,  Next: parse-integer,  Prev: integer-length,  Up: Numbers

integerp (Function)
===================

Syntax:
.......

 -- Function: integerp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿintegerþ; otherwise, returns false.

Examples:
.........

 (integerp 1) ý true
 (integerp (expt 2 130)) ý true
 (integerp 6/5) ý false
 (integerp nil) ý false

Notes:
......

 (integerp OBJECT) Õ (typep OBJECT 'integer)


File: chris-ansicl.info,  Node: parse-integer,  Next: boole,  Prev: integerp,  Up: Numbers

parse-integer (Function)
========================

Syntax:
.......

 -- Function: parse-integer string &key start end radix junk-allowed ý
          integer, pos

Arguments and Values:
.....................

STRING--a string.

START, END--bounding index designators of STRING.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

RADIX--a radix.  The default is ÿ10þ.

JUNK-ALLOWED--a generalized boolean.  The default is false.

INTEGER--an integer or false.

POS--a bounding index of STRING.

Description:
............

ÿparse-integerþ parses an integer in the specified RADIX from the
substring of STRING delimited by START and END.

ÿparse-integerþ expects an optional sign (ÿ+þ or ÿ-þ) followed by a a
non-empty sequence of digits to be interpreted in the specified RADIX.
Optional leading and trailing whitespaceá is ignored.

ÿparse-integerþ does not recognize the syntactic radix-specifier
prefixes ÿ#Oþ, ÿ#Bþ, ÿ#Xþ, and ÿ#nRþ, nor does it recognize a trailing
decimal point.

If JUNK-ALLOWED is false, an error of type ÿparse-errorþ is signaled if
substring does not consist entirely of the representation of a signed
integer, possibly surrounded on either side by whitespaceá characters.

The first value returned is either the integer that was parsed, or else
ÿnilþ if no syntactically correct integer was seen but JUNK-ALLOWED was
true.

The second value is either the index into the string of the delimiter
that terminated the parse, or the upper bounding index of the substring
if the parse terminated at the end of the substring (as is always the
case if JUNK-ALLOWED is false).

Examples:
.........

 (parse-integer "123") ý 123, 3
 (parse-integer "123" :start 1 :radix 5) ý 13, 3
 (parse-integer "no-integer" :junk-allowed t) ý NIL, 0

Exceptional Situations:
.......................

If JUNK-ALLOWED is false, an error is signaled if substring does not
consist entirely of the representation of an integer, possibly
surrounded on either side by whitespaceá characters.


File: chris-ansicl.info,  Node: boole,  Next: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Prev: parse-integer,  Up: Numbers

boole (Function)
================

Syntax:
.......

 -- Function: boole op integer-1 integer-2 ý result-integer

Arguments and Values:
.....................

OP--a bit-wise logical operation specifier.

INTEGER-1--an integer.

INTEGER-2--an integer.

RESULT-INTEGER--an integer.

Description:
............

ÿbooleþ performs bit-wise logical operations on INTEGER-1 and
INTEGER-2, which are treated as if they were binary and in two's
complement representation.

The operation to be performed and the return value are determined by OP.

ÿbooleþ returns the values specified for any OP in the next figure.

Op              Result
------------------------------------------------------------- 
ÿboole-1þ       INTEGER-1
ÿboole-2þ       INTEGER-2
ÿboole-andc1þ   and complement of INTEGER-1 with INTEGER-2
ÿboole-andc2þ   and INTEGER-1 with complement of INTEGER-2
ÿboole-andþ     and
ÿboole-c1þ      complement of INTEGER-1
ÿboole-c2þ      complement of INTEGER-2
ÿboole-clrþ     always 0 (all zero bits)
ÿboole-eqvþ     equivalence (exclusive nor)
ÿboole-iorþ     inclusive or
ÿboole-nandþ    not-and
ÿboole-norþ     not-or
ÿboole-orc1þ    or complement of INTEGER-1 with INTEGER-2
ÿboole-orc2þ    or INTEGER-1 with complement of INTEGER-2
ÿboole-setþ     always -1 (all one bits)
ÿboole-xorþ     exclusive or

Figure 12.17: Bit-Wise Logical Operations

Examples:
.........

 (boole boole-ior 1 16) ý 17
 (boole boole-and -2 5) ý 4
 (boole boole-eqv 17 15) ý -31

;;; These examples illustrate the result of applying BOOLE and each
;;; of the possible values of OP to each possible combination of bits.
 (progn
   (format t "~&Results of (BOOLE <op> #b0011 #b0101) ...~
           ~%---Op-------Decimal-----Binary----Bits---~%")
   (dolist (symbol '(boole-1     boole-2    boole-and  boole-andc1
                     boole-andc2 boole-c1   boole-c2   boole-clr
                     boole-eqv   boole-ior  boole-nand boole-nor
                     boole-orc1  boole-orc2 boole-set  boole-xor))
     (let ((result (boole (symbol-value symbol) #b0011 #b0101)))
       (format t "~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~%"
               symbol result (logand result #b1111)))))
Ö Results of (BOOLE <op> #b0011 #b0101) ...
Ö ---Op-------Decimal-----Binary----Bits---
Ö  BOOLE-1       3          11    ...0011
Ö  BOOLE-2       5         101    ...0101
Ö  BOOLE-AND     1           1    ...0001
Ö  BOOLE-ANDC1   4         100    ...0100
Ö  BOOLE-ANDC2   2          10    ...0010
Ö  BOOLE-C1     -4        -100    ...1100
Ö  BOOLE-C2     -6        -110    ...1010
Ö  BOOLE-CLR     0           0    ...0000
Ö  BOOLE-EQV    -7        -111    ...1001
Ö  BOOLE-IOR     7         111    ...0111
Ö  BOOLE-NAND   -2         -10    ...1110
Ö  BOOLE-NOR    -8       -1000    ...1000
Ö  BOOLE-ORC1   -3         -11    ...1101
Ö  BOOLE-ORC2   -5        -101    ...1011
Ö  BOOLE-SET    -1          -1    ...1111
Ö  BOOLE-XOR     6         110    ...0110
ý NIL

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if its first argument is not a bit-wise
logical operation specifier or if any subsequent argument is not an
integer.

See Also:
.........

*Note logand::

Notes:
......

In general,

 (boole boole-and x y) Õ (logand x y)

Programmers who would prefer to use numeric indices rather than
bit-wise logical operation specifiers can get an equivalent effect by a
technique such as the following:

;; The order of the values in this `table' are such that
;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n
 (defconstant boole-n-vector
    (vector boole-clr   boole-and  boole-andc1 boole-2
            boole-andc2 boole-1    boole-xor   boole-ior
            boole-nor   boole-eqv  boole-c1    boole-orc1
            boole-c2    boole-orc2 boole-nand  boole-set))
ý BOOLE-N-VECTOR
 (proclaim '(inline boole-n))
ý implementation-dependent
 (defun boole-n (n integer &rest more-integers)
   (apply #'boole (elt boole-n-vector n) integer more-integers))
ý BOOLE-N
 (boole-n #b0111 5 3) ý 7
 (boole-n #b0001 5 3) ý 1
 (boole-n #b1101 5 3) ý -3
 (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))
ý (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)


File: chris-ansicl.info,  Node: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Next: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Prev: boole,  Up: Numbers

boole-1, boole-2, boole-and, boole-andc1, boole-andc2, boole-c1, boole-c2, boole-clr, boole-eqv, boole-ior, boole-nand, boole-nor, boole-orc1, boole-orc2, boole-set, boole-xor (Constant Variable)
===================================================================================================================================================================================================

Constant Value:
...............

The identity and nature of the values of each of these variables is
implementation-dependent, except that it must be distinct from each of
the values of the others, and it must be a valid first argument to the
function ÿbooleþ.

Description:
............

Each of these constants has a value which is one of the sixteen
possible bit-wise logical operation specifiers.

Examples:
.........

 (boole boole-ior 1 16) ý 17
 (boole boole-and -2 5) ý 4
 (boole boole-eqv 17 15) ý -31

See Also:
.........

*Note boole::


File: chris-ansicl.info,  Node: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Next: logbitp,  Prev: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Up: Numbers

logand, logandc1, logandc2, logeqv, logior, lognand, lognor, lognot, logorc1, logorc2, logxor (Function)
========================================================================================================

Syntax:
.......

 -- Function: logand &rest integers ý result-integer

 -- Function: logandc1 integer-1 integer-2 ý result-integer

 -- Function: logandc2 integer-1 integer-2 ý result-integer

 -- Function: logeqv &rest integers ý result-integer

 -- Function: logior &rest integers ý result-integer

 -- Function: lognand integer-1 integer-2 ý result-integer

 -- Function: lognor integer-1 integer-2 ý result-integer

 -- Function: lognot integer ý result-integer

 -- Function: logorc1 integer-1 integer-2 ý result-integer

 -- Function: logorc2 integer-1 integer-2 ý result-integer

 -- Function: logxor &rest integers ý result-integer

Arguments and Values:
.....................

INTEGERS--integers.

INTEGER--an integer.

INTEGER-1--an integer.

INTEGER-2--an integer.

RESULT-INTEGER--an integer.

Description:
............

The functions ÿlogandc1þ, ÿlogandc2þ, ÿlogandþ, ÿlogeqvþ, ÿlogiorþ,
ÿlognandþ, ÿlognorþ, ÿlognotþ, ÿlogorc1þ, ÿlogorc2þ, and ÿlogxorþ
perform bit-wise logical operations on their arguments, that are
treated as if they were binary.

The next figure lists the meaning of each of the functions.  Where an
`identity' is shown, it indicates the value yielded by the function
when no arguments are supplied.

Function     Identity   Operation performed
--------------------------------------------------------------------- 
ÿlogandc1þ   --         and complement of INTEGER-1 with INTEGER-2
ÿlogandc2þ   --         and INTEGER-1 with complement of INTEGER-2
ÿlogandþ     ÿ-1þ       and
ÿlogeqvþ     ÿ-1þ       equivalence (exclusive nor)
ÿlogiorþ     ÿ0þ        inclusive or
ÿlognandþ    --         complement of INTEGER-1 and INTEGER-2
ÿlognorþ     --         complement of INTEGER-1 or INTEGER-2
ÿlognotþ     --         complement
ÿlogorc1þ    --         or complement of INTEGER-1 with INTEGER-2
ÿlogorc2þ    --         or INTEGER-1 with complement of INTEGER-2
ÿlogxorþ     ÿ0þ        exclusive or

Figure 12.18: Bit-wise Logical Operations on Integers

Negative INTEGERS are treated as if they were in two's-complement
notation.

Examples:
.........

 (logior 1 2 4 8) ý 15
 (logxor 1 3 7 15) ý 10
 (logeqv) ý -1
 (logand 16 31) ý 16
 (lognot 0) ý -1
 (lognot 1) ý -2
 (lognot -1) ý 0
 (lognot (1+ (lognot 1000))) ý 999

;;; In the following example, m is a mask.  For each bit in
;;; the mask that is a 1, the corresponding bits in x and y are
;;; exchanged.  For each bit in the mask that is a 0, the
;;; corresponding bits of x and y are left unchanged.
 (flet ((show (m x y)
          (format t "~%m = #o~6,'0O~%x = #o~6,'0O~%y = #o~6,'0O~%"
                  m x y)))
   (let ((m #o007750)
         (x #o452576)
         (y #o317407))
     (show m x y)
     (let ((z (logand (logxor x y) m)))
       (setq x (logxor z x))
       (setq y (logxor z y))
       (show m x y))))
Ö m = #o007750
Ö x = #o452576
Ö y = #o317407
Ö
Ö m = #o007750
Ö x = #o457426
Ö y = #o312557
ý NIL

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if any argument is not an integer.

See Also:
.........

*Note boole::

Notes:
......

ÿ(logbitp K -1)þ returns true for all values of K.

Because the following functions are not associative, they take exactly
two arguments rather than any number of arguments.

 (lognand N1 N2) Õ (lognot (logand N1 N2))
 (lognor N1 N2) Õ (lognot (logior N1 N2))
 (logandc1 N1 N2) Õ (logand (lognot N1) N2)
 (logandc2 N1 N2) Õ (logand N1 (lognot N2))
 (logiorc1 N1 N2) Õ (logior (lognot N1) N2)
 (logiorc2 N1 N2) Õ (logior N1 (lognot N2))
 (logbitp J (lognot X)) Õ (not (logbitp J X))


File: chris-ansicl.info,  Node: logbitp,  Next: logcount,  Prev: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Up: Numbers

logbitp (Function)
==================

Syntax:
.......

 -- Function: logbitp index integer ý generalized-boolean

Arguments and Values:
.....................

INDEX--a non-negative integer.

INTEGER--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿlogbitpþ is used to test the value of a particular bit in INTEGER,
that is treated as if it were binary.  The value of ÿlogbitpþ is true
if the bit in INTEGER whose index is INDEX (that is, its weight is
2^index) is a one-bit; otherwise it is false.

Negative INTEGERS are treated as if they were in two's-complement
notation.

Examples:
.........

 (logbitp 1 1) ý false
 (logbitp 0 1) ý true
 (logbitp 3 10) ý true
 (logbitp 1000000 -1) ý true
 (logbitp 2 6) ý true
 (logbitp 0 6) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INDEX is not a
non-negative integer.  Should signal an error of type ÿtype-errorþ if
INTEGER is not an integer.

Notes:
......

 (logbitp K N) Õ (ldb-test (byte 1 K) N)


File: chris-ansicl.info,  Node: logcount,  Next: logtest,  Prev: logbitp,  Up: Numbers

logcount (Function)
===================

Syntax:
.......

 -- Function: logcount integer ý number-of-on-bits

Arguments and Values:
.....................

INTEGER--an integer.

NUMBER-OF-ON-BITS--a non-negative integer.

Description:
............

Computes and returns the number of bits in the two's-complement binary
representation of INTEGER that are `on' or `set'.  If INTEGER is
negative, the ÿ0þ bits are counted; otherwise, the ÿ1þ bits are counted.

Examples:
.........

 (logcount 0) ý 0
 (logcount -1) ý 0
 (logcount 7) ý 3
 (logcount  13) ý 3 ;Two's-complement binary: ...0001101
 (logcount -13) ý 2 ;Two's-complement binary: ...1110011
 (logcount  30) ý 4 ;Two's-complement binary: ...0011110
 (logcount -30) ý 4 ;Two's-complement binary: ...1100010
 (logcount (expt 2 100)) ý 1
 (logcount (- (expt 2 100))) ý 100
 (logcount (- (1+ (expt 2 100)))) ý 1

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if its argument is not an integer.

Notes:
......

Even if the implementation does not represent integers internally in
two's complement binary, ÿlogcountþ behaves as if it did.

The following identity always holds:

    (logcount X)
 Õ (logcount (- (+ X 1)))
 Õ (logcount (lognot X))


File: chris-ansicl.info,  Node: logtest,  Next: byte; byte-size; byte-position,  Prev: logcount,  Up: Numbers

logtest (Function)
==================

Syntax:
.......

 -- Function: logtest integer-1 integer-2 ý generalized-boolean

Arguments and Values:
.....................

INTEGER-1--an integer.

INTEGER-2--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if any of the bits designated by the 1's in INTEGER-1 is 1
in INTEGER-2; otherwise it is false.  INTEGER-1 and INTEGER-2 are
treated as if they were binary.

Negative INTEGER-1 and INTEGER-2 are treated as if they were
represented in two's-complement binary.

Examples:
.........

 (logtest 1 7) ý true
 (logtest 1 2) ý false
 (logtest -2 -1) ý true
 (logtest 0 -1) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INTEGER-1 is not an
integer.  Should signal an error of type ÿtype-errorþ if INTEGER-2 is
not an integer.

Notes:
......

 (logtest X Y) Õ (not (zerop (logand X Y)))


File: chris-ansicl.info,  Node: byte; byte-size; byte-position,  Next: deposit-field,  Prev: logtest,  Up: Numbers

byte, byte-size, byte-position (Function)
=========================================

Syntax:
.......

 -- Function: byte size position ý bytespec

 -- Function: byte-size bytespec ý size

 -- Function: byte-position bytespec ý position

Arguments and Values:
.....................

SIZE, POSITION--a non-negative integer.

BYTESPEC--a byte specifier.

Description:
............

ÿbyteþ returns a byte specifier that indicates a byte of width SIZE and
whose bits have weights 2^POSITION + SIZE - 1 through 2^POSITION, and
whose representation is implementation-dependent.

ÿbyte-sizeþ returns the number of bits specified by BYTESPEC.

ÿbyte-positionþ returns the position specified by BYTESPEC.

Examples:
.........

 (setq b (byte 100 200)) ý #<BYTE-SPECIFIER size 100 position 200>
 (byte-size b) ý 100
 (byte-position b) ý 200

See Also:
.........

*Note ldb::, *Note dpb::

Notes:
......

 (byte-size (byte J K)) Õ J
 (byte-position (byte J K)) Õ K

A byte of size of ÿ0þ is permissible; it refers to a byte of width
zero.  For example,

 (ldb (byte 0 3) #o7777) ý 0
 (dpb #o7777 (byte 0 3) 0) ý 0


File: chris-ansicl.info,  Node: deposit-field,  Next: dpb,  Prev: byte; byte-size; byte-position,  Up: Numbers

deposit-field (Function)
========================

Syntax:
.......

 -- Function: deposit-field newbyte bytespec integer ý result-integer

Arguments and Values:
.....................

NEWBYTE--an integer.

BYTESPEC--a byte specifier.

INTEGER--an integer.

RESULT-INTEGER--an integer.

Description:
............

Replaces a field of bits within INTEGER; specifically, returns an
integer that contains the bits of NEWBYTE within the byte specified by
BYTESPEC, and elsewhere contains the bits of INTEGER.

Examples:
.........

 (deposit-field 7 (byte 2 1) 0) ý 6
 (deposit-field -1 (byte 4 0) 0) ý 15
 (deposit-field 0 (byte 2 1) -3) ý -7

See Also:
.........

*Note byte::, *Note dpb::

Notes:
......

 (logbitp J (deposit-field M (byte S P) N))
 Õ (if (and (>= J P) (< J (+ P S)))
        (logbitp J M)
        (logbitp J N))

ÿdeposit-fieldþ is to ÿmask-fieldþ as ÿdpbþ           is to ÿldbþ.


File: chris-ansicl.info,  Node: dpb,  Next: ldb,  Prev: deposit-field,  Up: Numbers

dpb (Function)
==============

Syntax:
.......

 -- Function: dpb newbyte bytespec integer ý result-integer

Pronunciation:
..............

[édè êpib] or [édè êpè b] or [êdæêpæêbæ]

Arguments and Values:
.....................

NEWBYTE--an integer.

BYTESPEC--a byte specifier.

INTEGER--an integer.

RESULT-INTEGER--an integer.

Description:
............

ÿdpbþ (deposit byte) is used to replace a field of bits within INTEGER.
ÿdpbþ returns an integer that is the same as INTEGER except in the bits
specified by BYTESPEC.

Let ÿsþ be the size specified by BYTESPEC; then the low ÿsþ bits of
NEWBYTE appear in the result in the byte specified by BYTESPEC.
NEWBYTE is interpreted as being right-justified, as if it were the
result of ÿldbþ.

Examples:
.........

 (dpb 1 (byte 1 10) 0) ý 1024
 (dpb -2 (byte 2 10) 0) ý 2048
 (dpb 1 (byte 2 10) 2048) ý 1024

See Also:
.........

*Note byte::, *Note deposit-field::, *Note ldb::

Notes:
......

 (logbitp J (dpb M (byte S P) N))
 Õ (if (and (>= J P) (< J (+ P S)))
        (logbitp (- J P) M)
        (logbitp J N))

In general,

 (dpb X (byte 0 Y) Z) ý Z

for all valid values of X, Y, and Z.

Historically, the name "dpb" comes from a DEC PDP-10 assembly language
instruction meaning "deposit byte."


File: chris-ansicl.info,  Node: ldb,  Next: ldb-test,  Prev: dpb,  Up: Numbers

ldb (Accessor)
==============

Syntax:
.......

 -- Function: ldb bytespec integer ý byte

(setf (ldb bytespec place) new-byte)

Pronunciation:
..............

[êlidib] or [êlidè b] or [êelêdæêbæ]

Arguments and Values:
.....................

BYTESPEC--a byte specifier.

INTEGER--an integer.

BYTE, NEW-BYTE--a non-negative integer.

Description:
............

ÿldbþ extracts and returns the byte of INTEGER specified by BYTESPEC.

ÿldbþ returns an integer in which the bits with weights 2^(s-1) through
2^0 are the same as those in INTEGER with weights 2^(p+s-1) through
2^p, and all other bits zero; s is ÿ(byte-size BYTESPEC)þ and p is
ÿ(byte-position BYTESPEC)þ.

ÿsetfþ may be used with ÿldbþ to modify a byte within the INTEGER that
is stored in a given PLACE.  The order of evaluation, when an ÿldbþ
form is supplied to ÿsetfþ, is exactly left-to-right.  The effect is to
perform a ÿdpbþ operation and then store the result back into the PLACE.

Examples:
.........

 (ldb (byte 2 1) 10) ý 1
 (setq a (list 8)) ý (8)
 (setf (ldb (byte 2 1) (car a)) 1) ý 1
 a ý (10)

See Also:
.........

*Note byte::, *Note byte-position::, *Note byte-size::, *Note dpb::

Notes:
......

 (logbitp J (ldb (byte S P) N))
    Õ (and (< J S) (logbitp (+ J P) N))

In general,

 (ldb (byte 0 X) Y) ý 0

for all valid values of X and Y.

Historically, the name "ldb" comes from a DEC PDP-10 assembly language
instruction meaning "load byte."


File: chris-ansicl.info,  Node: ldb-test,  Next: mask-field,  Prev: ldb,  Up: Numbers

ldb-test (Function)
===================

Syntax:
.......

 -- Function: ldb-test bytespec integer ý generalized-boolean

Arguments and Values:
.....................

BYTESPEC--a byte specifier.

INTEGER--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if any of the bits of the byte in INTEGER specified by
BYTESPEC is non-zero; otherwise returns false.

Examples:
.........

 (ldb-test (byte 4 1) 16) ý true
 (ldb-test (byte 3 1) 16) ý false
 (ldb-test (byte 3 2) 16) ý true

See Also:
.........

*Note byte::, *Note ldb::, *Note zerop::

Notes:
......

 (ldb-test bytespec n) Õ
 (not (zerop (ldb bytespec n))) Õ
 (logtest (ldb bytespec -1) n)


File: chris-ansicl.info,  Node: mask-field,  Next: most-positive-fixnum; most-negative-fixnum,  Prev: ldb-test,  Up: Numbers

mask-field (Accessor)
=====================

Syntax:
.......

 -- Function: mask-field bytespec integer ý masked-integer

(setf (mask-field bytespec place) new-masked-integer)

Arguments and Values:
.....................

BYTESPEC--a byte specifier.

INTEGER--an integer.

MASKED-INTEGER, NEW-MASKED-INTEGER--a non-negative integer.

Description:
............

ÿmask-fieldþ performs a "mask" operation on INTEGER.  It returns an
integer that has the same bits as INTEGER in the byte specified by
BYTESPEC, but that has zero-bits everywhere else.

ÿsetfþ may be used with ÿmask-fieldþ to modify a byte within the
integer that is stored in a given PLACE.  The effect is to perform a
ÿdeposit-fieldþ operation and then store the result back into the PLACE.

Examples:
.........

 (mask-field (byte 1 5) -1) ý 32
 (setq a 15) ý 15
 (mask-field (byte 2 0) a) ý 3
 a ý 15
 (setf (mask-field (byte 2 0) a) 1) ý 1
 a ý 13

See Also:
.........

*Note byte::, *Note ldb::

Notes:
......

 (ldb BS (mask-field BS N)) Õ (ldb BS N)
 (logbitp J (mask-field (byte S P) N))
   Õ (and (>= J P) (< J S) (logbitp J N))
 (mask-field BS N) Õ (logand N (dpb -1 BS 0))


File: chris-ansicl.info,  Node: most-positive-fixnum; most-negative-fixnum,  Next: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Prev: mask-field,  Up: Numbers

most-positive-fixnum, most-negative-fixnum (Constant Variable)
==============================================================

Constant Value:
...............

implementation-dependent.

Description:
............

ÿmost-positive-fixnumþ is that fixnum closest in value to positive
infinity provided by the implementation, and greater than or equal to
both 2^15 - 1 and ÿarray-dimension-limitþ.

ÿmost-negative-fixnumþ is that fixnum closest in value to negative
infinity provided by the implementation, and less than or equal to
-2^15.


File: chris-ansicl.info,  Node: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Next: float (Function),  Prev: most-positive-fixnum; most-negative-fixnum,  Up: Numbers

decode-float, scale-float, float-radix, float-sign, float-digits, float-precision, integer-decode-float (Function)
==================================================================================================================

Syntax:
.......

 -- Function: decode-float float ý significand, exponent, sign

 -- Function: scale-float float integer ý scaled-float

 -- Function: float-radix float ý float-radix

 -- Function: float-sign float-1 &optional float-2 ý signed-float

 -- Function: float-digits float ý digits1

 -- Function: float-precision float ý digits2

 -- Function: integer-decode-float float ý significand, exponent,
          integer-sign

Arguments and Values:
.....................

DIGITS1--a non-negative integer.

DIGITS2--a non-negative integer.

EXPONENT--an integer.

FLOAT--a float.

FLOAT-1--a float.

FLOAT-2--a float.

FLOAT-RADIX--an integer.

INTEGER--a non-negative integer.

INTEGER-SIGN--the integer ÿ-1þ, or the integer ÿ1þ.

SCALED-FLOAT--a float.

SIGN--A float of the same type as FLOAT but numerically equal to ÿ1.0þ
or ÿ-1.0þ.

SIGNED-FLOAT--a float.

SIGNIFICAND--a float.

Description:
............

ÿdecode-floatþ computes three values that characterize FLOAT.  The
first value is of the same type as FLOAT and represents the significand.
The second value represents the exponent to which the radix (notated in
this description by b) must be raised to obtain the value that, when
multiplied with the first result, produces the absolute value of FLOAT.
If FLOAT is zero, any integer value may be returned, provided that the
identity shown for ÿscale-floatþ holds.  The third value is of the same
type as FLOAT and is 1.0 if FLOAT is greater than or equal to zero or
-1.0 otherwise.

ÿdecode-floatþ divides FLOAT by an integral power of b so as to bring
its value between 1/b (inclusive) and 1 (exclusive), and returns the
quotient as the first value.  If FLOAT is zero, however, the result
equals the absolute value of FLOAT (that is, if there is a negative
zero, its significand is considered to be a positive zero).

ÿscale-floatþ returns ÿ(* FLOAT (expt (float b FLOAT) INTEGER))þ, where
b is the radix of the floating-point representation. FLOAT is not
necessarily between 1/b and 1.

ÿfloat-radixþ returns the radix of FLOAT.

ÿfloat-signþ returns a number ÿzþ such that ÿzþ and FLOAT-1 have the
same sign and also such that ÿzþ and FLOAT-2 have the same absolute
value.  If FLOAT-2 is not supplied, its value is ÿ(float 1 FLOAT-1)þ.
If an implementation has distinct representations for negative zero and
positive zero, then ÿ(float-sign -0.0)þ ý ÿ-1.0þ.

ÿfloat-digitsþ returns the number of radix b digits used in the
representation of FLOAT (including any implicit digits, such as a
"hidden bit").

ÿfloat-precisionþ returns the number of significant radix b digits
present in FLOAT; if FLOAT is a float zero, then the result is an
integer zero.

For normalized floats, the results of ÿfloat-digitsþ and
ÿfloat-precisionþ are the same, but the precision is less than the
number of representation digits for a denormalized or zero number.

ÿinteger-decode-floatþ computes three values that characterize FLOAT -
the significand scaled so as to be an integer, and the same last two
values that are returned by ÿdecode-floatþ.  If FLOAT is zero,
ÿinteger-decode-floatþ returns zero as the first value.  The second
value bears the same relationship to the first value as for
ÿdecode-floatþ:

 (multiple-value-bind (signif expon sign)
                      (integer-decode-float f)
   (scale-float (float signif f) expon)) Õ (abs f)

Examples:
.........

 ;; Note that since the purpose of this functionality is to expose
 ;; details of the implementation, all of these examples are necessarily
 ;; very implementation-dependent.  Results may vary widely.
 ;; Values shown here are chosen consistently from one particular implementation.
 (decode-float .5) ý 0.5, 0, 1.0
 (decode-float 1.0) ý 0.5, 1, 1.0
 (scale-float 1.0 1) ý 2.0
 (scale-float 10.01 -2) ý 2.5025
 (scale-float 23.0 0) ý 23.0
 (float-radix 1.0) ý 2
 (float-sign 5.0) ý 1.0
 (float-sign -5.0) ý -1.0
 (float-sign 0.0) ý 1.0
 (float-sign 1.0 0.0) ý 0.0
 (float-sign 1.0 -10.0) ý 10.0
 (float-sign -1.0 10.0) ý -10.0
 (float-digits 1.0) ý 24
 (float-precision 1.0) ý 24
 (float-precision least-positive-single-float) ý 1
 (integer-decode-float 1.0) ý 8388608, -23, 1

Affected By:
............

The implementation's representation for floats.

Exceptional Situations:
.......................

The functions ÿdecode-floatþ, ÿfloat-radixþ, ÿfloat-digitsþ,
ÿfloat-precisionþ, and ÿinteger-decode-floatþ should signal an error if
their only argument is not a float.

The function ÿscale-floatþ should signal an error if its first argument
is not a float or if its second argument is not an integer.

The function ÿfloat-signþ should signal an error if its first argument
is not a float or if its second argument is supplied but is not a float.

Notes:
......

The product of the first result of ÿdecode-floatþ or
ÿinteger-decode-floatþ, of the radix raised to the power of the second
result, and of the third result is exactly equal to the value of FLOAT.

 (multiple-value-bind (signif expon sign)
                      (decode-float f)
   (scale-float signif expon))
Õ (abs f)

and

 (multiple-value-bind (signif expon sign)
                      (decode-float f)
   (* (scale-float signif expon) sign))
Õ f


File: chris-ansicl.info,  Node: float (Function),  Next: floatp,  Prev: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Up: Numbers

float (Function)
================

Syntax:
.......

 -- Function: float number &optional prototype ý float

Arguments and Values:
.....................

NUMBER--a real.

PROTOTYPE--a float.

FLOAT--a float.

Description:
............

ÿfloatþ converts a real number to a float.

If a PROTOTYPE is supplied, a float is returned that is mathematically
equal to NUMBER but has the same format as PROTOTYPE.

If PROTOTYPE is not supplied, then if the NUMBER is already a float, it
is returned; otherwise, a float is returned that is mathematically
equal to NUMBER but is a single float.

Examples:
.........

 (float 0) ý 0.0
 (float 1 .5) ý 1.0
 (float 1.0) ý 1.0
 (float 1/2) ý 0.5
ý 1.0d0
orý 1.0
 (eql (float 1.0 1.0d0) 1.0d0) ý true

See Also:
.........

*Note coerce::


File: chris-ansicl.info,  Node: floatp,  Next: most-positive-short-float; least-positive-short-float; least-positive-n+,  Prev: float (Function),  Up: Numbers

floatp (Function)
=================

Syntax:
.......

 -- Function: floatp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿfloatþ; otherwise, returns false.

Examples:
.........

 (floatp 1.2d2) ý true
 (floatp 1.212) ý true
 (floatp 1.2s2) ý true
 (floatp (expt 2 130)) ý false

Notes:
......

 (floatp OBJECT) Õ (typep OBJECT 'float)


File: chris-ansicl.info,  Node: most-positive-short-float; least-positive-short-float; least-positive-n+,  Next: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Prev: floatp,  Up: Numbers

most-positive-short-float, least-positive-short-float, least-positive-normalized-short-float, most-positive-double-float, least-positive-double-float, least-positive-normalized-double-float, most-positive-long-float, least-positive-long-float, least-positive-normalized-long-float, most-positive-single-float, least-positive-single-float, least-positive-normalized-single-float, most-negative-short-float, least-negative-short-float, least-negative-normalized-short-float, most-negative-single-float, least-negative-single-float, least-negative-normalized-single-float, most-negative-double-float, least-negative-double-float, least-negative-normalized-double-float, most-negative-long-float, least-negative-long-float, least-negative-normalized-long-float (Constant Variable)
========================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================

Constant Value:
...............

implementation-dependent.

Description:
............

These constant variables provide a way for programs to examine the
implementation-defined limits for the various float formats.

Of these variables, each which has "ÿ-normalizedþ" in its name must
have a value which is a normalized float, and each which does not have
"ÿ-normalizedþ" in its name may have a value which is either a
normalized float or a denormalized float, as appropriate.

Of these variables, each which has "ÿshort-floatþ" in its name must
have a value which is a short float, each which has "ÿsingle-floatþ" in
its name must have a value which is a single float, each which has
"ÿdouble-floatþ" in its name must have a value which is a double float,
and each which has "ÿlong-floatþ" in its name must have a value which
is a long float.

   * ÿmost-positive-short-floatþ, ÿmost-positive-single-floatþ,
     ÿmost-positive-double-floatþ, ÿmost-positive-long-floatþ

     Each of these constant variables has as its value the positive
     float of the largest magnitude (closest in value to, but not equal
     to, positive infinity) for the float format implied by its name.

   *
     ÿleast-positive-short-floatþ, ÿleast-positive-normalized-short-floatþ,
     ÿleast-positive-single-floatþ, ÿleast-positive-normalized-single-floatþ,
     ÿleast-positive-double-floatþ, ÿleast-positive-normalized-double-floatþ,
     ÿleast-positive-long-floatþ, ÿleast-positive-normalized-long-floatþ

     Each of these constant variables has as its value the smallest
     positive (nonzero) float for the float format implied by its name.

   *
     ÿleast-negative-short-floatþ, ÿleast-negative-normalized-short-floatþ,
     ÿleast-negative-single-floatþ, ÿleast-negative-normalized-single-floatþ,
     ÿleast-negative-double-floatþ, ÿleast-negative-normalized-double-floatþ,
     ÿleast-negative-long-floatþ, ÿleast-negative-normalized-long-floatþ

     Each of these constant variables has as its value the negative
     (nonzero) float of the smallest magnitude for the float format
     implied by its name.  (If an implementation supports minus zero as
     a different object from positive zero, this value must not be
     minus zero.)

   * ÿmost-negative-short-floatþ, ÿmost-negative-single-floatþ,
     ÿmost-negative-double-floatþ, ÿmost-negative-long-floatþ

     Each of these constant variables has as its value the negative
     float of the largest magnitude (closest in value to, but not equal
     to, negative infinity) for the float format implied by its name.

Notes:
......


File: chris-ansicl.info,  Node: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Next: arithmetic-error,  Prev: most-positive-short-float; least-positive-short-float; least-positive-n+,  Up: Numbers

short-float-epsilon, short-float-negative-epsilon, single-float-epsilon, single-float-negative-epsilon, double-float-epsilon, double-float-negative-epsilon, long-float-epsilon, long-float-negative-epsilon (Constant Variable)
================================================================================================================================================================================================================================

Constant Value:
...............

implementation-dependent.

Description:
............

The value of each of the constants ÿshort-float-epsilonþ,
ÿsingle-float-epsilonþ, ÿdouble-float-epsilonþ, and
ÿlong-float-epsilonþ is the smallest positive float í of the given
format, such that the following expression is true when evaluated:

ÿ(not (= (float 1 í) (+ (float 1 í) í)))þ

The value of each of the constants ÿshort-float-negative-epsilonþ,
ÿsingle-float-negative-epsilonþ, ÿdouble-float-negative-epsilonþ, and
ÿlong-float-negative-epsilonþ is the smallest positive float í of the
given format, such that the following expression is true when evaluated:

ÿ(not (= (float 1 í) (- (float 1 í) í)))þ


File: chris-ansicl.info,  Node: arithmetic-error,  Next: arithmetic-error-operands; arithmetic-error-operation,  Prev: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Up: Numbers

arithmetic-error (Condition Type)
=================================

Class Precedence List:
......................

ÿarithmetic-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿarithmetic-errorþ consists of error conditions that occur
during arithmetic operations.  The operation and operands are
initialized with the initialization arguments named :operation and
:operands to ÿmake-conditionþ, and are accessed by the functions
ÿarithmetic-error-operationþ and ÿarithmetic-error-operandsþ.

See Also:
.........

*Note arithmetic-error-operation::, *Note arithmetic-error-operands::


File: chris-ansicl.info,  Node: arithmetic-error-operands; arithmetic-error-operation,  Next: division-by-zero,  Prev: arithmetic-error,  Up: Numbers

arithmetic-error-operands, arithmetic-error-operation (Function)
================================================================

Syntax:
.......

 -- Function: arithmetic-error-operands condition ý operands

 -- Function: arithmetic-error-operation condition ý operation

Arguments and Values:
.....................

CONDITION--a condition of type ÿarithmetic-errorþ.

OPERANDS--a list.

OPERATION--a function designator.

Description:
............

ÿarithmetic-error-operandsþ returns a list of the operands which were
used in the offending call to the operation that signaled the CONDITION.

ÿarithmetic-error-operationþ returns a list of the offending operation
in the offending call that signaled the CONDITION.

See Also:
.........

*Note arithmetic-error::, *Note Chapter 9 (Conditions): Conditions.

Notes:
......


File: chris-ansicl.info,  Node: division-by-zero,  Next: floating-point-invalid-operation,  Prev: arithmetic-error-operands; arithmetic-error-operation,  Up: Numbers

division-by-zero (Condition Type)
=================================

Class Precedence List:
......................

ÿdivision-by-zeroþ, ÿarithmetic-errorþ, ÿerrorþ, ÿserious-conditionþ,
ÿconditionþ, ÿtþ

Description:
............

The type ÿdivision-by-zeroþ consists of error conditions that occur
because of division by zero.


File: chris-ansicl.info,  Node: floating-point-invalid-operation,  Next: floating-point-inexact,  Prev: division-by-zero,  Up: Numbers

floating-point-invalid-operation (Condition Type)
=================================================

Class Precedence List:
......................

ÿfloating-point-invalid-operationþ, ÿarithmetic-errorþ, ÿerrorþ,
ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿfloating-point-invalid-operationþ consists of error
conditions that occur because of certain floating point traps.

It is implementation-dependent whether floating point traps occur, and
whether or how they may be enabled or disabled.  Therefore, conforming
code may establish handlers for this condition, but must not depend on
its being signaled.


File: chris-ansicl.info,  Node: floating-point-inexact,  Next: floating-point-overflow,  Prev: floating-point-invalid-operation,  Up: Numbers

floating-point-inexact (Condition Type)
=======================================

Class Precedence List:
......................

ÿfloating-point-inexactþ, ÿarithmetic-errorþ, ÿerrorþ,
ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿfloating-point-inexactþ consists of error conditions that
occur because of certain floating point traps.

It is implementation-dependent whether floating point traps occur, and
whether or how they may be enabled or disabled.  Therefore, conforming
code may establish handlers for this condition, but must not depend on
its being signaled.


File: chris-ansicl.info,  Node: floating-point-overflow,  Next: floating-point-underflow,  Prev: floating-point-inexact,  Up: Numbers

floating-point-overflow (Condition Type)
========================================

Class Precedence List:
......................

ÿfloating-point-overflowþ, ÿarithmetic-errorþ, ÿerrorþ,
ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿfloating-point-overflowþ consists of error conditions that
occur because of floating-point overflow.


File: chris-ansicl.info,  Node: floating-point-underflow,  Prev: floating-point-overflow,  Up: Numbers

floating-point-underflow (Condition Type)
=========================================

Class Precedence List:
......................

ÿfloating-point-underflowþ, ÿarithmetic-errorþ, ÿerrorþ,
ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿfloating-point-underflowþ consists of error conditions that
occur because of floating-point underflow.


File: chris-ansicl.info,  Node: Characters,  Next: Conses,  Prev: Numbers,  Up: Top

13 Characters
*************

* Menu:

* Character Concepts::

Dictionary

* character (System Class)::
* base-char::
* standard-char::
* extended-char::
* char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+::
* character (Function)::
* characterp::
* alpha-char-p::
* alphanumericp::
* digit-char::
* digit-char-p::
* graphic-char-p::
* standard-char-p::
* char-upcase; char-downcase::
* upper-case-p; lower-case-p; both-case-p::
* char-code::
* char-int::
* code-char::
* char-code-limit::
* char-name::
* name-char::


File: chris-ansicl.info,  Node: Character Concepts,  Next: character (System Class),  Up: Characters

13.1 Character Concepts
=======================

* Menu:

* Introduction to Characters::
* Introduction to Scripts and Repertoires::
* Character Attributes::
* Character Categories::
* Identity of Characters::
* Ordering of Characters::
* Character Names::
* Treatment of Newline during Input and Output::
* Character Encodings::
* Documentation of Implementation-Defined Scripts::


File: chris-ansicl.info,  Node: Introduction to Characters,  Next: Introduction to Scripts and Repertoires,  Up: Character Concepts

13.1.1 Introduction to Characters
---------------------------------

A "character" is an object that represents a unitary token (e.g., a
letter, a special symbol, or a "control character") in an aggregate
quantity of text (e.g., a string or a text stream).

Common Lisp allows an implementation to provide support for
international language characters as well as characters used in
specialized arenas (e.g., mathematics).

The following figures contain lists of defined names applicable to
characters.

The next figure lists some defined names relating to character
attributes and character predicates.

alpha-char-p      char-not-equal      char>
alphanumericp     char-not-greaterp   char>=
both-case-p       char-not-lessp      digit-char-p
char-code-limit   char/=              graphic-char-p
char-equal        char<               lower-case-p
char-greaterp     char<=              standard-char-p
char-lessp        char=               upper-case-p

Figure 13.1: Character defined names - 1

The next figure lists some character construction and conversion
defined names.

char-code       char-name     code-char
char-downcase   char-upcase   digit-char
char-int        character     name-char

Figure 13.2: Character defined names - 2


File: chris-ansicl.info,  Node: Introduction to Scripts and Repertoires,  Next: Character Attributes,  Prev: Introduction to Characters,  Up: Character Concepts

13.1.2 Introduction to Scripts and Repertoires
----------------------------------------------

13.1.2.1 Character Scripts
..........................

A script is one of possibly several sets that form an exhaustive
partition of the type ÿcharacterþ.

The number of such sets and boundaries between them is
implementation-defined.  Common Lisp does not require these sets to be
types, but an implementation is permitted to define such types as an
extension.  Since no character from one script can ever be a member of
another script, it is generally more useful to speak about character
repertoires.

Although the term "script" is chosen for definitional compatibility
with ISO terminology, no conforming implementation is required to use
any particular scripts standardized by ISO or by any other standards
organization.

Whether and how the script or scripts used by any given implementation
are named is implementation-dependent.

13.1.2.2 Character Repertoires
..............................

A "repertoire" is a type specifier for a subtype of type ÿcharacterþ.
This term is generally used when describing a collection of characters
independent of their coding.  Characters in repertoires are only
identified by name, by glyph, or by character description.

A repertoire can contain characters from several scripts, and a
character can appear in more than one repertoire.

For some examples of repertoires, see the coded character standards ISO
8859/1, ISO 8859/2, and ISO 6937/2.  Note, however, that although the
term "repertoire" is chosen for definitional compatibility with ISO
terminology, no conforming implementation is required to use
repertoires standardized by ISO or any other standards organization.


File: chris-ansicl.info,  Node: Character Attributes,  Next: Character Categories,  Prev: Introduction to Scripts and Repertoires,  Up: Character Concepts

13.1.3 Character Attributes
---------------------------

Characters have only one standardized attribute: a code.  A character's
code is a non-negative integer.  This code is composed from a character
script and a character label in an implementation-dependent way.  See
the functions *Note char-code:: and ÿcode-charþ.

Additional, implementation-defined attributes of characters are also
permitted so that, for example, two characters with the same code may
differ in some other, implementation-defined way.

For any implementation-defined attribute there is a distinguished value
called the "null" value for that attribute.  A character for which each
implementation-defined attribute has the null value for that attribute
is called a simple character.  If the implementation has no
implementation-defined attributes, then all characters are simple
characters.


File: chris-ansicl.info,  Node: Character Categories,  Next: Identity of Characters,  Prev: Character Attributes,  Up: Character Concepts

13.1.4 Character Categories
---------------------------

There are several (overlapping) categories of characters that have no
formally associated type but that are nevertheless useful to name.
They include graphic characters, alphabeticá characters, characters
with case (uppercase and lowercase characters), numeric characters,
alphanumeric characters, and digits (in a given radix).

For each implementation-defined attribute of a character, the
documentation for that implementation must specify whether characters
that differ only in that attribute are permitted to differ in whether
are not they are members of one of the aforementioned categories.

Note that these terms are defined independently of any special syntax
which might have been enabled in the current readtable.

13.1.4.1 Graphic Characters
...........................

Characters that are classified as "graphic", or displayable, are each
associated with a glyph, a visual representation of the character.

A graphic character is one that has a standard textual representation
as a single glyph, such as ÿAþ or ÿ*þ or ÿ=þ.  Space, which effectively
has a blank glyph, is defined to be a graphic.

Of the standard characters, newline is non-graphic and all others are
graphic; see *Note Section 2.1.3 (Standard Characters): Standard
Characters.

Characters that are not graphic are called "non-graphic".  Non-graphic
characters are sometimes informally called "formatting characters" or
"control characters."

ÿ#\Backspaceþ, ÿ#\Tabþ, ÿ#\Ruboutþ, ÿ#\Linefeedþ, ÿ#\Returnþ, and
ÿ#\Pageþ, if they are supported by the implementation, are non-graphic.

13.1.4.2 Alphabetic Characters
..............................

The alphabeticá characters are a subset of the graphic characters.  Of
the standard characters, only these are the alphabeticá characters:

ÿA B C D E F G H I J K L M N O P Q R S T U V W X Y Zþ

ÿa b c d e f g h i j k l m n o p q r s t u v w x y zþ

Any implementation-defined character that has case must be alphabeticá.
For each implementation-defined graphic character that has no case, it
is implementation-defined whether that character is alphabeticá.

13.1.4.3 Characters With Case
.............................

The characters with case are a subset of the alphabeticá characters.  A
character with case has the property of being either uppercase or
lowercase.  Every character with case is in one-to-one correspondence
with some other character with the opposite case.

13.1.4.3.1 Uppercase Characters
...............................

An uppercase character is one that has a corresponding lowercase
character that is different (and can be obtained using ÿchar-downcaseþ).

Of the standard characters, only these are uppercase characters:

ÿA B C D E F G H I J K L M N O P Q R S T U V W X Y Zþ

13.1.4.3.2 Lowercase Characters
...............................

A lowercase character is one that has a corresponding uppercase
character that is different (and can be obtained using ÿchar-upcaseþ).

Of the standard characters, only these are lowercase characters:

ÿa b c d e f g h i j k l m n o p q r s t u v w x y zþ

13.1.4.3.3 Corresponding Characters in the Other Case
.....................................................

The uppercase standard characters ÿAþ through ÿZþ mentioned above
respectively correspond to the lowercase standard characters ÿaþ
through ÿzþ mentioned above.  For example, the uppercase character ÿEþ
corresponds to the lowercase character ÿeþ, and vice versa.

13.1.4.3.4 Case of Implementation-Defined Characters
....................................................

An implementation may define that other implementation-defined graphic
characters have case.  Such definitions must always be done in
pairs--one uppercase character in one-to-one correspondence with one
lowercase character.

13.1.4.4 Numeric Characters
...........................

The numeric characters are a subset of the graphic characters.  Of the
standard characters, only these are numeric characters:

ÿ0 1 2 3 4 5 6 7 8 9þ

For each implementation-defined graphic character that has no case, the
implementation must define whether or not it is a numeric character.

13.1.4.5 Alphanumeric Characters
................................

The set of alphanumeric characters is the union of the set of
alphabeticá characters and the set of numeric characters.

13.1.4.6 Digits in a Radix
..........................

What qualifies as a digit depends on the radix (an integer between ÿ2þ
and ÿ36þ, inclusive).  The potential digits are:

ÿ0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y
Zþ

Their respective weights are ÿ0þ, ÿ1þ, ÿ2þ, ... ÿ35þ.  In any given
radix n, only the first n potential digits are considered to be digits.
For example, the digits in radix ÿ2þ  are ÿ0þ and ÿ1þ, the digits in
radix ÿ10þ are ÿ0þ through ÿ9þ, and the digits in radix ÿ16þ are ÿ0þ
through ÿFþ.

Case is not significant in digits; for example, in radix ÿ16þ, both ÿFþ
and ÿfþ are digits with weight ÿ15þ.


File: chris-ansicl.info,  Node: Identity of Characters,  Next: Ordering of Characters,  Prev: Character Categories,  Up: Character Concepts

13.1.5 Identity of Characters
-----------------------------

Two characters that are ÿeqlþ, ÿchar=þ, or ÿchar-equalþ are not
necessarily ÿeqþ.


File: chris-ansicl.info,  Node: Ordering of Characters,  Next: Character Names,  Prev: Identity of Characters,  Up: Character Concepts

13.1.6 Ordering of Characters
-----------------------------

The total ordering on characters is guaranteed to have the following
properties:

   * If two characters have the same implementation-defined attributes,
     then their ordering by ÿchar<þ is consistent with the numerical
     ordering by the predicate ÿ<þ on their code attributes.

   * If two characters differ in any attribute, then they are not
     ÿchar=þ.

   * The total ordering is not necessarily the same as the total
     ordering on the integers produced by applying ÿchar-intþ to the
     characters.

   * While alphabeticá standard characters of a given case must obey a
     partial ordering, they need not be contiguous; it is permissible
     for uppercase and lowercase characters to be interleaved.  Thus
     ÿ(char<= #\a x #\z)þ is not a valid way of determining whether or
     not ÿxþ is a lowercase character.


Of the standard characters, those which are alphanumeric obey the
following partial ordering:

 A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z
 a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z
 0<1<2<3<4<5<6<7<8<9
 either 9<A or Z<0
 either 9<a or z<0

This implies that, for standard characters, alphabeticá ordering holds
within each case (uppercase and lowercase), and that the numeric
characters as a group are not interleaved with alphabetic characters.
However, the ordering or possible interleaving of uppercase characters
and lowercase characters is implementation-defined.


File: chris-ansicl.info,  Node: Character Names,  Next: Treatment of Newline during Input and Output,  Prev: Ordering of Characters,  Up: Character Concepts

13.1.7 Character Names
----------------------

The following character names must be present in all conforming
implementations:

ÿNewlineþ
     The character that represents the division between lines.  An
     implementation must translate between ÿ#\Newlineþ, a
     single-character representation, and whatever external
     representation(s) may be used.

ÿSpaceþ
     The space or blank character.

The following names are semi-standard; if an implementation supports
them, they should be used for the described characters and no others.

ÿRuboutþ
     The rubout or delete character.

ÿPageþ
     The form-feed or page-separator character.

ÿTabþ
     The tabulate character.

ÿBackspaceþ
     The backspace character.

ÿReturnþ
     The carriage return character.

ÿLinefeedþ
     The line-feed character.

In some implementations, one or more of these character names might
denote a standard character; for example, ÿ#\Linefeedþ and ÿ#\Newlineþ
might be the same character in some implementations.


File: chris-ansicl.info,  Node: Treatment of Newline during Input and Output,  Next: Character Encodings,  Prev: Character Names,  Up: Character Concepts

13.1.8 Treatment of Newline during Input and Output
---------------------------------------------------

When the character ÿ#\Newlineþ is written to an output file, the
implementation must take the appropriate action to produce a line
division.  This might involve writing out a record or translating
ÿ#\Newlineþ to a CR/LF sequence.  When reading, a corresponding reverse
transformation must take place.


File: chris-ansicl.info,  Node: Character Encodings,  Next: Documentation of Implementation-Defined Scripts,  Prev: Treatment of Newline during Input and Output,  Up: Character Concepts

13.1.9 Character Encodings
--------------------------

A character is sometimes represented merely by its code, and sometimes
by another integer value which is composed from the code and all
implementation-defined attributes (in an implementation-defined way
that might vary between Lisp images even in the same implementation).
This integer, returned by the function ÿchar-intþ, is called the
character's "encoding."  There is no corresponding function from a
character's encoding back to the character, since its primary intended
uses include things like hashing where an inverse operation is not
really called for.


File: chris-ansicl.info,  Node: Documentation of Implementation-Defined Scripts,  Prev: Character Encodings,  Up: Character Concepts

13.1.10 Documentation of Implementation-Defined Scripts
-------------------------------------------------------

An implementation must document the character scripts it supports. For
each character script supported, the documentation must describe at
least the following:

   * Character labels, glyphs, and descriptions.  Character labels must
     be uniquely named using only Latin capital letters A-Z, hyphen
     (-), and digits 0-9.

   * Reader canonicalization.  Any mechanisms by which ÿreadþ treats
     different characters as equivalent must be documented.

   * The impact on ÿchar-upcaseþ, ÿchar-downcaseþ, and the
     case-sensitive format directives.  In particular, for each
     character with case, whether it is uppercase or lowercase, and
     which character is its equivalent in the opposite case.

   * The behavior of the case-insensitive functions ÿchar-equalþ,
     ÿchar-not-equalþ, ÿchar-lesspþ, ÿchar-greaterpþ,
     ÿchar-not-greaterpþ, and ÿchar-not-lesspþ.

   * The behavior of any character predicates; in particular, the
     effects of ÿalpha-char-pþ, ÿlower-case-pþ, ÿupper-case-pþ,
     ÿboth-case-pþ, ÿgraphic-char-pþ, and ÿalphanumericpþ.

   * The interaction with file I/O, in particular, the supported coded
     character sets (for example, ISO8859/1-1987) and external encoding
     schemes supported are documented.


File: chris-ansicl.info,  Node: character (System Class),  Next: base-char,  Prev: Character Concepts,  Up: Characters

character (System Class)
========================

Class Precedence List:
......................

ÿcharacterþ, ÿtþ

Description:
............

A character is an object that represents a unitary token in an
aggregate quantity of text; see *Note Section 13.1 (Character
Concepts): Character Concepts.

The types ÿbase-charþ and ÿextended-charþ form an exhaustive partition
of the type ÿcharacterþ.

See Also:
.........

*Note Section 13.1 (Character Concepts): Character Concepts, *Note
Section 2.4.8.1 (Sharpsign Backslash): SharpsignBackslash, *Note
Section 22.1.3.2 (Printing Characters): PrintingCharacters.


File: chris-ansicl.info,  Node: base-char,  Next: standard-char,  Prev: character (System Class),  Up: Characters

base-char (Type)
================

Supertypes:
...........

ÿbase-charþ, ÿcharacterþ, ÿtþ

Description:
............

The type ÿbase-charþ is defined as the upgraded array element type of
ÿstandard-charþ.  An implementation can support additional subtypes of
type ÿcharacterþ (besides the ones listed in this standard) that might
or might not be supertypes of type ÿbase-charþ.  In addition, an
implementation can define ÿbase-charþ to be the same type as
ÿcharacterþ.

Base characters are distinguished in the following respects:

  1. The type ÿstandard-charþ is a subrepertoire of the type
     ÿbase-charþ.

  2. The selection of base characters that are not standard characters
     is implementation defined.

  3. Only objects of the type ÿbase-charþ can be elements of a base
     string.

  4. No upper bound is specified for the number of characters in the
     ÿbase-charþ repertoire; the size of that repertoire is
     implementation-defined.  The lower bound is 96, the number of
     standard characters.

Whether a character is a base character depends on the way that an
implementation represents strings, and not any other properties of the
implementation or the host operating system.  For example, one
implementation might encode all strings as characters having 16-bit
encodings, and another might have two kinds of strings: those with
characters having 8-bit encodings and those with characters having
16-bit encodings.  In the first implementation, the type ÿbase-charþ is
equivalent to the type ÿcharacterþ: there is only one kind of string.
In the second implementation, the base characters might be those
characters that could be stored in a string of characters having 8-bit
encodings.  In such an implementation, the type ÿbase-charþ is a proper
subtype of the type ÿcharacterþ.

The type ÿstandard-charþ is a subtype of type ÿbase-charþ.


File: chris-ansicl.info,  Node: standard-char,  Next: extended-char,  Prev: base-char,  Up: Characters

standard-char (Type)
====================

Supertypes:
...........

ÿstandard-charþ, ÿbase-charþ, ÿcharacterþ, ÿtþ

Description:
............

A fixed set of 96 characters required to be present in all conforming
implementations.  Standard characters are defined in *Note Section
2.1.3 (Standard Characters): Standard Characters.

Any character that is not simple is not a standard character.

See Also:
.........

*Note Section 2.1.3 (Standard Characters): Standard Characters.


File: chris-ansicl.info,  Node: extended-char,  Next: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Prev: standard-char,  Up: Characters

extended-char (Type)
====================

Supertypes:
...........

ÿextended-charþ, ÿcharacterþ, ÿtþ

Description:
............

The type ÿextended-charþ is equivalent to the type ÿ(and character (not
base-char))þ.

Notes:
......

The type ÿextended-charþ might have no elementsÞ in implementations in
which all characters are of type ÿbase-charþ.


File: chris-ansicl.info,  Node: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Next: character (Function),  Prev: extended-char,  Up: Characters

char=, char/=, char<, char>, char<=, char>=, char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, char-not-lessp (Function)
================================================================================================================================================

Syntax:
.......

 -- Function: char= &rest characters+ ý generalized-boolean

 -- Function: char/= &rest characters+ ý generalized-boolean

 -- Function: char< &rest characters+ ý generalized-boolean

 -- Function: char> &rest characters+ ý generalized-boolean

 -- Function: char<= &rest characters+ ý generalized-boolean

 -- Function: char>= &rest characters+ ý generalized-boolean

 -- Function: char-equal &rest characters+ ý generalized-boolean

 -- Function: char-not-equal &rest characters+ ý generalized-boolean

 -- Function: char-lessp &rest characters+ ý generalized-boolean

 -- Function: char-greaterp &rest characters+ ý generalized-boolean

 -- Function: char-not-greaterp &rest characters+ ý generalized-boolean

 -- Function: char-not-lessp &rest characters+ ý generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

These predicates compare characters.

ÿchar=þ returns true if all CHARACTERS are the same; otherwise, it
returns false.  If two CHARACTERS differ in any implementation-defined
attributes, then they are not ÿchar=þ.

ÿchar/=þ returns true if all CHARACTERS are different; otherwise, it
returns false.

ÿchar<þ returns true if the CHARACTERS are monotonically increasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ÿchar<þ is
consistent with the numerical ordering by the predicate ÿ<þ on their
codes.

ÿchar>þ returns true if the CHARACTERS are monotonically decreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ÿchar>þ is
consistent with the numerical ordering by the predicate ÿ>þ on their
codes.

ÿchar<=þ returns true if the CHARACTERS are monotonically nondecreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ÿchar<=þ is
consistent with the numerical ordering by the predicate ÿ<=þ on their
codes.

ÿchar>=þ returns true if the CHARACTERS are monotonically nonincreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ÿchar>=þ is
consistent with the numerical ordering by the predicate ÿ>=þ on their
codes.

ÿchar-equalþ, ÿchar-not-equalþ, ÿchar-lesspþ, ÿchar-greaterpþ,
ÿchar-not-greaterpþ, and ÿchar-not-lesspþ are similar to ÿchar=þ,
ÿchar/=þ, ÿchar<þ, ÿchar>þ, ÿchar<=þ, ÿchar>=þ, respectively, except
that they ignore differences in case and might have an
implementation-defined behavior for non-simple characters.  For
example, an implementation might define that ÿchar-equalþ, etc. ignore
certain implementation-defined attributes.  The effect, if any, of each
implementation-defined attribute upon these functions must be specified
as part of the definition of that attribute.

Examples:
.........

 (char= #\d #\d) ý true
 (char= #\A #\a) ý false
 (char= #\d #\x) ý false
 (char= #\d #\D) ý false
 (char/= #\d #\d) ý false
 (char/= #\d #\x) ý true
 (char/= #\d #\D) ý true
 (char= #\d #\d #\d #\d) ý true
 (char/= #\d #\d #\d #\d) ý false
 (char= #\d #\d #\x #\d) ý false
 (char/= #\d #\d #\x #\d) ý false
 (char= #\d #\y #\x #\c) ý false
 (char/= #\d #\y #\x #\c) ý true
 (char= #\d #\c #\d) ý false
 (char/= #\d #\c #\d) ý false
 (char< #\d #\x) ý true
 (char<= #\d #\x) ý true
 (char< #\d #\d) ý false
 (char<= #\d #\d) ý true
 (char< #\a #\e #\y #\z) ý true
 (char<= #\a #\e #\y #\z) ý true
 (char< #\a #\e #\e #\y) ý false
 (char<= #\a #\e #\e #\y) ý true
 (char> #\e #\d) ý true
 (char>= #\e #\d) ý true
 (char> #\d #\c #\b #\a) ý true
 (char>= #\d #\c #\b #\a) ý true
 (char> #\d #\d #\c #\a) ý false
 (char>= #\d #\d #\c #\a) ý true
 (char> #\e #\d #\b #\c #\a) ý false
 (char>= #\e #\d #\b #\c #\a) ý false
 (char> #\z #\A) ý implementation-dependent
 (char> #\Z #\a) ý implementation-dependent
 (char-equal #\A #\a) ý true
 (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char-lessp)
ý (#\A #\a #\b #\B #\c #\C)
 (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char<)
ý (#\A #\B #\C #\a #\b #\c) ;Implementation A
ý (#\a #\b #\c #\A #\B #\C) ;Implementation B
ý (#\a #\A #\b #\B #\c #\C) ;Implementation C
ý (#\A #\a #\B #\b #\C #\c) ;Implementation D
ý (#\A #\B #\a #\b #\C #\c) ;Implementation E

Exceptional Situations:
.......................

Should signal an error of type ÿprogram-errorþ if at least one
CHARACTER is not supplied.

See Also:
.........

*Note Section 2.1 (Character Syntax): Character Syntax, *Note Section
13.1.10 (Documentation of Implementation-Defined Scripts):
Documentation of Implementation-Defined Scripts.

Notes:
......

If characters differ in their code attribute or any
implementation-defined attribute, they are considered to be different
by ÿchar=þ.

There is no requirement that ÿ(eq c1 c2)þ be true merely because
ÿ(char= c1 c2)þ is true.  While ÿeqþ can distinguish two characters
that ÿchar=þ does not, it is distinguishing them not as characters, but
in some sense on the basis of a lower level implementation
characteristic.  If ÿ(eq c1 c2)þ is true, then ÿ(char= c1 c2)þ is also
true.  ÿeqlþ and ÿequalþ compare characters in the same way that
ÿchar=þ does.

The manner in which case is used by ÿchar-equalþ, ÿchar-not-equalþ,
ÿchar-lesspþ, ÿchar-greaterpþ, ÿchar-not-greaterpþ, and ÿchar-not-lesspþ
implies an ordering for standard characters such that ÿA=aþ, ÿB=bþ, and
so on, up to ÿZ=zþ, and furthermore either ÿ9<Aþ or ÿZ<0þ.


File: chris-ansicl.info,  Node: character (Function),  Next: characterp,  Prev: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Up: Characters

character (Function)
====================

Syntax:
.......

 -- Function: character character ý denoted-character

Arguments and Values:
.....................

CHARACTER--a character designator.

DENOTED-CHARACTER--a character.

Description:
............

Returns the character denoted by the CHARACTER designator.

Examples:
.........

 (character #\a) ý #\a
 (character "a") ý #\a
 (character 'a) ý #\A
 (character '\a) ý #\a
 (character 65.) is an error.
 (character 'apple) is an error.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if OBJECT is not a
character designator.

See Also:
.........

*Note coerce::

Notes:
......

 (character OBJECT) Õ (coerce OBJECT 'character)


File: chris-ansicl.info,  Node: characterp,  Next: alpha-char-p,  Prev: character (Function),  Up: Characters

characterp (Function)
=====================

Syntax:
.......

 -- Function: characterp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿcharacterþ; otherwise, returns false.

Examples:
.........

 (characterp #\a) ý true
 (characterp 'a) ý false
 (characterp "a") ý false
 (characterp 65.) ý false
 (characterp #\Newline) ý true
 ;; This next example presupposes an implementation
 ;; in which #\Rubout is an implementation-defined character.
 (characterp #\Rubout) ý true

See Also:
.........

*Note character (Function):: (type and function), *Note typep::

Notes:
......

 (characterp OBJECT) Õ (typep OBJECT 'character)


File: chris-ansicl.info,  Node: alpha-char-p,  Next: alphanumericp,  Prev: characterp,  Up: Characters

alpha-char-p (Function)
=======================

Syntax:
.......

 -- Function: alpha-char-p character ý generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is an alphabeticá character; otherwise,
returns false.

Examples:
.........

 (alpha-char-p #\a) ý true
 (alpha-char-p #\5) ý false
 (alpha-char-p #\Newline) ý false
 ;; This next example presupposes an implementation
 ;; in which #\ì is a defined character.
 (alpha-char-p #\ì) ý implementation-dependent

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.

See Also:
.........

*Note alphanumericp::, *Note Section 13.1.10 (Documentation of
Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.


File: chris-ansicl.info,  Node: alphanumericp,  Next: digit-char,  Prev: alpha-char-p,  Up: Characters

alphanumericp (Function)
========================

Syntax:
.......

 -- Function: alphanumericp character ý generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is an alphabeticá character  or a  numeric
character; otherwise, returns false.

Examples:
.........

 (alphanumericp #\Z) ý true
 (alphanumericp #\9) ý true
 (alphanumericp #\Newline) ý false
 (alphanumericp #\#) ý false

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.

See Also:
.........

*Note alpha-char-p::, *Note graphic-char-p::, *Note digit-char-p::

Notes:
......

Alphanumeric characters are graphic as defined by ÿgraphic-char-pþ.
The alphanumeric characters are a subset of the graphic characters.
The standard characters ÿAþ through ÿZþ, ÿaþ through ÿzþ, and ÿ0þ
through ÿ9þ are alphanumeric characters.

 (alphanumericp x)
   Õ (or (alpha-char-p x) (not (null (digit-char-p x))))


File: chris-ansicl.info,  Node: digit-char,  Next: digit-char-p,  Prev: alphanumericp,  Up: Characters

digit-char (Function)
=====================

Syntax:
.......

 -- Function: digit-char weight &optional radix ý char

Arguments and Values:
.....................

WEIGHT--a non-negative integer.

RADIX--a radix.  The default is ÿ10þ.

CHAR--a character or false.

Description:
............

If WEIGHT is less than RADIX, ÿdigit-charþ returns a character which
has that WEIGHT when considered as a digit in the specified radix.  If
the resulting character is to be an alphabeticá character, it will be
an uppercase character.

If WEIGHT is greater than or equal to RADIX, ÿdigit-charþ returns false.

Examples:
.........

 (digit-char 0) ý #\0
 (digit-char 10 11) ý #\A
 (digit-char 10 10) ý false
 (digit-char 7) ý #\7
 (digit-char 12) ý false
 (digit-char 12 16) ý #\C  ;not #\c
 (digit-char 6 2) ý false
 (digit-char 1 2) ý #\1

See Also:
.........

*Note digit-char-p::, *Note graphic-char-p::, *Note Section 2.1
(Character Syntax): Character Syntax.

Notes:
......


File: chris-ansicl.info,  Node: digit-char-p,  Next: graphic-char-p,  Prev: digit-char,  Up: Characters

digit-char-p (Function)
=======================

Syntax:
.......

 -- Function: digit-char-p char &optional radix ý weight

Arguments and Values:
.....................

CHAR--a character.

RADIX--a radix.  The default is ÿ10þ.

WEIGHT--either a non-negative integer less than RADIX, or false.

Description:
............

Tests whether CHAR is a digit in the specified RADIX (i.e., with a
weight less than RADIX).  If it is a digit in that RADIX, its weight is
returned as an integer; otherwise ÿnilþ is returned.

Examples:
.........

 (digit-char-p #\5)    ý 5
 (digit-char-p #\5 2)  ý false
 (digit-char-p #\A)    ý false
 (digit-char-p #\a)    ý false
 (digit-char-p #\A 11) ý 10
 (digit-char-p #\a 11) ý 10
 (mapcar #'(lambda (radix)
             (map 'list #'(lambda (x) (digit-char-p x radix))
                  "059AaFGZ"))
         '(2 8 10 16 36))
 ý ((0 NIL NIL NIL NIL NIL NIL NIL)
     (0 5 NIL NIL NIL NIL NIL NIL)
     (0 5 9 NIL NIL NIL NIL NIL)
     (0 5 9 10 10 15 NIL NIL)
     (0 5 9 10 10 15 16 35))

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

See Also:
.........

*Note alphanumericp::

Notes:
......

Digits are graphic characters.


File: chris-ansicl.info,  Node: graphic-char-p,  Next: standard-char-p,  Prev: digit-char-p,  Up: Characters

graphic-char-p (Function)
=========================

Syntax:
.......

 -- Function: graphic-char-p char ý generalized-boolean

Arguments and Values:
.....................

CHAR--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is a graphic character; otherwise, returns
false.

Examples:
.........

 (graphic-char-p #\G) ý true
 (graphic-char-p #\#) ý true
 (graphic-char-p #\Space) ý true
 (graphic-char-p #\Newline) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.

See Also:
.........

*Note read::, *Note Section 2.1 (Character Syntax): Character Syntax,
*Note Section 13.1.10 (Documentation of Implementation-Defined
Scripts): Documentation of Implementation-Defined Scripts.


File: chris-ansicl.info,  Node: standard-char-p,  Next: char-upcase; char-downcase,  Prev: graphic-char-p,  Up: Characters

standard-char-p (Function)
==========================

Syntax:
.......

 -- Function: standard-char-p character ý generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is of type ÿstandard-charþ; otherwise,
returns false.

Examples:
.........

 (standard-char-p #\Space) ý true
 (standard-char-p #\~) ý true
 ;; This next example presupposes an implementation
 ;; in which #\Bell is a defined character.
 (standard-char-p #\Bell) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.


File: chris-ansicl.info,  Node: char-upcase; char-downcase,  Next: upper-case-p; lower-case-p; both-case-p,  Prev: standard-char-p,  Up: Characters

char-upcase, char-downcase (Function)
=====================================

Syntax:
.......

 -- Function: char-upcase character ý corresponding-character

 -- Function: char-downcase character ý corresponding-character

Arguments and Values:
.....................

CHARACTER, CORRESPONDING-CHARACTER--a character.

Description:
............

If CHARACTER is a lowercase character, ÿchar-upcaseþ returns the
corresponding uppercase character.  Otherwise, ÿchar-upcaseþ just
returns the given CHARACTER.

If CHARACTER is an uppercase character, ÿchar-downcaseþ returns the
corresponding lowercase character.  Otherwise, ÿchar-downcaseþ just
returns the given CHARACTER.

The result only ever differs from CHARACTER in its code attribute; all
implementation-defined attributes are preserved.

Examples:
.........

 (char-upcase #\a) ý #\A
 (char-upcase #\A) ý #\A
 (char-downcase #\a) ý #\a
 (char-downcase #\A) ý #\a
 (char-upcase #\9) ý #\9
 (char-downcase #\9) ý #\9
 (char-upcase #\@) ý #\@
 (char-downcase #\@) ý #\@
 ;; Note that this next example might run for a very long time in
 ;; some implementations if CHAR-CODE-LIMIT happens to be very large
 ;; for that implementation.
 (dotimes (code char-code-limit)
   (let ((char (code-char code)))
     (when char
       (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))
                     ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))
                     (t (and (char= (char-upcase (char-downcase char)) char)
                             (char= (char-downcase (char-upcase char)) char))))
         (return char)))))
ý NIL

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.

See Also:
.........

*Note upper-case-p::, *Note alpha-char-p::, *Note Section 13.1.4.3
(Characters With Case): CharactersWithCase, *Note Section 13.1.10
(Documentation of Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.

Notes:
......

If the CORRESPONDING-CHAR is different than CHARACTER, then both the
CHARACTER and the CORRESPONDING-CHAR have case.

Since ÿchar-equalþ ignores the case of the characters it compares, the
CORRESPONDING-CHARACTER is always the same as CHARACTER under
ÿchar-equalþ.


File: chris-ansicl.info,  Node: upper-case-p; lower-case-p; both-case-p,  Next: char-code,  Prev: char-upcase; char-downcase,  Up: Characters

upper-case-p, lower-case-p, both-case-p (Function)
==================================================

Syntax:
.......

 -- Function: upper-case-p character ý generalized-boolean

 -- Function: lower-case-p character ý generalized-boolean

 -- Function: both-case-p character ý generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

These functions test the case of a given CHARACTER.

ÿupper-case-pþ returns true if CHARACTER is an uppercase character;
otherwise, returns false.

ÿlower-case-pþ returns true if CHARACTER is a lowercase character;
otherwise, returns false.

ÿboth-case-pþ returns true if CHARACTER is a character with case;
otherwise, returns false.

Examples:
.........

 (upper-case-p #\A) ý true
 (upper-case-p #\a) ý false
 (both-case-p #\a) ý true
 (both-case-p #\5) ý false
 (lower-case-p #\5) ý false
 (upper-case-p #\5) ý false
 ;; This next example presupposes an implementation
 ;; in which #\Bell is an implementation-defined character.
 (lower-case-p #\Bell) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.

See Also:
.........

*Note char-upcase::, *Note char-downcase::, *Note Section 13.1.4.3
(Characters With Case): CharactersWithCase, *Note Section 13.1.10
(Documentation of Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.


File: chris-ansicl.info,  Node: char-code,  Next: char-int,  Prev: upper-case-p; lower-case-p; both-case-p,  Up: Characters

char-code (Function)
====================

Syntax:
.......

 -- Function: char-code character ý code

Arguments and Values:
.....................

CHARACTER--a character.

CODE--a character code.

Description:
............

ÿchar-codeþ returns the code attribute of CHARACTER.

Examples:
.........

;; An implementation using ASCII character encoding
;; might return these values:
(char-code #\$) ý 36
(char-code #\a) ý 97

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.

See Also:
.........

*Note char-code-limit::


File: chris-ansicl.info,  Node: char-int,  Next: code-char,  Prev: char-code,  Up: Characters

char-int (Function)
===================

Syntax:
.......

 -- Function: char-int character ý integer

Arguments and Values:
.....................

CHARACTER--a character.

INTEGER--a non-negative integer.

Description:
............

Returns a non-negative integer encoding the CHARACTER object.  The
manner in which the integer is computed is implementation-dependent.
In contrast to ÿsxhashþ, the result is not guaranteed to be independent
of the particular Lisp image.

If CHARACTER has no implementation-defined attributes, the results of
ÿchar-intþ and ÿchar-codeþ are the same.

 (char= c1 c2) Õ (= (char-int c1) (char-int c2))

for characters c1 and c2.

Examples:
.........

 (char-int #\A) ý 65       ; implementation A
 (char-int #\A) ý 577      ; implementation B
 (char-int #\A) ý 262145   ; implementation C

See Also:
.........

*Note char-code::


File: chris-ansicl.info,  Node: code-char,  Next: char-code-limit,  Prev: char-int,  Up: Characters

code-char (Function)
====================

Syntax:
.......

 -- Function: code-char code ý char-p

Arguments and Values:
.....................

CODE--a character code.

CHAR-P--a character or ÿnilþ.

Description:
............

Returns a character with the code attribute given by CODE.  If no such
character exists and one cannot be created, ÿnilþ is returned.

Examples:
.........

(code-char 65.) ý #\A  ;in an implementation using ASCII codes
(code-char (char-code #\Space)) ý #\Space  ;in any implementation

Affected By:
............

The implementation's character encoding.

See Also:
.........

*Note char-code::

Notes:
......


File: chris-ansicl.info,  Node: char-code-limit,  Next: char-name,  Prev: code-char,  Up: Characters

char-code-limit (Constant Variable)
===================================

Constant Value:
...............

A non-negative integer, the exact magnitude of which is
implementation-dependent, but which is not less than ÿ96þ (the number
of standard characters).

Description:
............

The upper exclusive bound on the value returned by the function
ÿchar-codeþ.

See Also:
.........

*Note char-code::

Notes:
......

The value of ÿchar-code-limitþ might be larger than the actual number
of characters supported by the implementation.


File: chris-ansicl.info,  Node: char-name,  Next: name-char,  Prev: char-code-limit,  Up: Characters

char-name (Function)
====================

Syntax:
.......

 -- Function: char-name character ý name

Arguments and Values:
.....................

CHARACTER--a character.

NAME--a string or ÿnilþ.

Description:
............

Returns a string that is the name of the CHARACTER, or ÿnilþ if the
CHARACTER has no name.

All non-graphic characters are required to have names unless they have
some implementation-defined attribute which is not null.  Whether or
not other characters have names is implementation-dependent.

The standard characters <Newline> and <Space> have the respective names
ÿ"Newline"þ and ÿ"Space"þ.  The semi-standard characters <Tab>, <Page>,
<Rubout>, <Linefeed>, <Return>, and <Backspace>  (if they are supported
by the implementation) have the respective names ÿ"Tab"þ,  ÿ"Page"þ,
ÿ"Rubout"þ,  ÿ"Linefeed"þ,  ÿ"Return"þ, and ÿ"Backspace"þ (in the
indicated case, even though name lookup by "ÿ#\þ" and by the function
ÿname-charþ is not case sensitive).

Examples:
.........

 (char-name #\ ) ý "Space"
 (char-name #\Space) ý "Space"
 (char-name #\Page) ý "Page"

 (char-name #\a)
ý NIL
orý "LOWERCASE-a"
orý "Small-A"
orý "LA01"

 (char-name #\A)
ý NIL
orý "UPPERCASE-A"
orý "Capital-A"
orý "LA02"

 ;; Even though its CHAR-NAME can vary, #\A prints as #\A
 (prin1-to-string (read-from-string (format nil "#\\~A" (or (char-name #\A) "A"))))
ý "#\\A"

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if CHARACTER is not a
character.

See Also:
.........

*Note name-char::, *Note Section 22.1.3.2 (Printing Characters):
PrintingCharacters.

Notes:
......

Non-graphic characters having names are written by the Lisp printer as
"ÿ#\þ" followed by the their name; see *Note Section 22.1.3.2 (Printing
Characters): PrintingCharacters.


File: chris-ansicl.info,  Node: name-char,  Prev: char-name,  Up: Characters

name-char (Function)
====================

Syntax:
.......

 -- Function: name-char name ý char-p

Arguments and Values:
.....................

NAME--a string designator.

CHAR-P--a character or ÿnilþ.

Description:
............

Returns the character object whose name is NAME (as determined by
ÿstring-equalþ--i.e., lookup is not case sensitive).  If such a
character does not exist, ÿnilþ is returned.

Examples:
.........

(name-char 'space) ý #\Space
(name-char "space") ý #\Space
(name-char "Space") ý #\Space
(let ((x (char-name #\a)))
  (or (not x) (eql (name-char x) #\a))) ý true

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if NAME is not a string
designator.

See Also:
.........

*Note char-name::


File: chris-ansicl.info,  Node: Conses,  Next: Arrays,  Prev: Characters,  Up: Top

14 Conses
*********

* Menu:

* Cons Concepts::

Dictionary

* list (System Class)::
* null (System Class)::
* cons (System Class)::
* atom (Type)::
* cons (Function)::
* consp::
* atom (Function)::
* rplaca; rplacd::
* car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+::
* copy-tree::
* sublis; nsublis::
* subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not::
* tree-equal::
* copy-list::
* list; list*::
* list-length::
* listp::
* make-list::
* push::
* pop::
* first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+::
* nth::
* endp::
* null (Function)::
* nconc::
* append::
* revappend; nreconc::
* butlast; nbutlast::
* last::
* ldiff; tailp::
* nthcdr::
* rest::
* member; member-if; member-if-not::
* mapc; mapcar; mapcan; mapl; maplist; mapcon::
* acons::
* assoc; assoc-if; assoc-if-not::
* copy-alist::
* pairlis::
* rassoc; rassoc-if; rassoc-if-not::
* get-properties::
* getf::
* remf::
* intersection; nintersection::
* adjoin::
* pushnew::
* set-difference; nset-difference::
* set-exclusive-or; nset-exclusive-or::
* subsetp::
* union; nunion::


File: chris-ansicl.info,  Node: Cons Concepts,  Next: list (System Class),  Up: Conses

14.1 Cons Concepts
==================

A "cons" is a compound data object having two components called the car
and the cdr.

car   cons     rplacd
cdr   rplaca   

Figure 14.1: Some defined names relating to conses.

Depending on context, a group of connected conses can be viewed in a
variety of different ways.  A variety of operations is provided to
support each of these various views.

* Menu:

* Conses as Trees::
* Conses as Lists::


File: chris-ansicl.info,  Node: Conses as Trees,  Next: Conses as Lists,  Up: Cons Concepts

14.1.1 Conses as Trees
----------------------

A "tree" is a binary recursive data structure made up of conses and
atoms: the conses are themselves also trees (sometimes called
"subtrees" or "branches"), and the atoms are terminal nodes (sometimes
called "leaves").  Typically, the leaves represent data while the
branches establish some relationship among that data.

caaaar   caddar   cdar        nsubst
caaadr   cadddr   cddaar      nsubst-if
caaar    caddr    cddadr      nsubst-if-not
caadar   cadr     cddar       nthcdr
caaddr   cdaaar   cdddar      sublis
caadr    cdaadr   cddddr      subst
caar     cdaar    cdddr       subst-if
cadaar   cdadar   cddr        subst-if-not
cadadr   cdaddr   copy-tree   tree-equal
cadar    cdadr    nsublis     

Figure 14.2: Some defined names relating to trees.

14.1.1.1 General Restrictions on Parameters that must be Trees
..............................................................

Except as explicitly stated otherwise, for any standardized function
that takes a parameter that is required to be a tree, the consequences
are undefined if that tree is circular.


File: chris-ansicl.info,  Node: Conses as Lists,  Prev: Conses as Trees,  Up: Cons Concepts

14.1.2 Conses as Lists
----------------------

A "list" is a chain of conses in which the car of each cons is an
element of the list, and the cdr of each cons is either the next link
in the chain or a terminating atom.

A "proper list" is a list terminated by the empty list.  The empty list
is a proper list, but is not a cons.

An "improper list" is a list that is not a proper list; that is, it is
a circular list or a dotted list.

A "dotted list" is a list that has a terminating atom that is not the
empty list.  A non-nil atom by itself is not considered to be a list of
any kind--not even a dotted list.

A "circular list" is a chain of conses that has no termination because
some cons in the chain is the cdr of a later cons.

append       last            nbutlast   rest
butlast      ldiff           nconc      revappend
copy-alist   list            ninth      second
copy-list    list*           nreconc    seventh
eighth       list-length     nth        sixth
endp         make-list       nthcdr     tailp
fifth        member          pop        tenth
first        member-if       push       third
fourth       member-if-not   pushnew    

Figure 14.3: Some defined names relating to lists.

14.1.2.1 Lists as Association Lists
...................................

An "association list" is a list of conses representing an association
of keys with values, where the car of each cons is the key and the cdr
is the value associated with that key.

acons   assoc-if       pairlis   rassoc-if
assoc   assoc-if-not   rassoc    rassoc-if-not

Figure 14.4: Some defined names related to assocation lists.

14.1.2.2 Lists as Sets
......................

Lists are sometimes viewed as sets by considering their elements
unordered and by assuming there is no duplication of elements.

adjoin          nset-difference     set-difference     union
intersection    nset-exclusive-or   set-exclusive-or   
nintersection   nunion              subsetp            

Figure 14.5: Some defined names related to sets.

14.1.2.3 General Restrictions on Parameters that must be Lists
..............................................................

Except as explicitly specified otherwise, any standardized function
that takes a parameter that is required to be a list should be prepared
to signal an error of type ÿtype-errorþ if the value received is a
dotted list.

Except as explicitly specified otherwise, for any standardized function
that takes a parameter that is required to be a list, the consequences
are undefined if that list is circular.


File: chris-ansicl.info,  Node: list (System Class),  Next: null (System Class),  Prev: Cons Concepts,  Up: Conses

list (System Class)
===================

Class Precedence List:
......................

ÿlistþ, ÿsequenceþ, ÿtþ

Description:
............

A "list" is a chain of conses in which the car of each cons is an
element of the list, and the cdr of each cons is either the next link
in the chain or a terminating atom.

A "proper list" is a chain of conses terminated by the "empty list",
(), which is  itself a proper list.  A "dotted list" is a list which
has a terminating atom that is not the empty list.  A "circular list"
is a chain of conses that has no termination because some cons in the
chain is the cdr of a later cons.

Dotted lists and circular lists are also lists, but usually the
unqualified term "list" within this specification means proper list.
Nevertheless, the type ÿlistþ unambiguously includes dotted lists and
circular lists.

For each element of a list there is a cons.  The empty list has no
elements and is not a cons.

The types ÿconsþ and ÿnullþ form an exhaustive partition of the type
ÿlistþ.

See Also:
.........

*Note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *Note Section
22.1.3.5 (Printing Lists and Conses): PrintingListsAndConses.


File: chris-ansicl.info,  Node: null (System Class),  Next: cons (System Class),  Prev: list (System Class),  Up: Conses

null (System Class)
===================

Class Precedence List:
......................

ÿnullþ, ÿsymbolþ, ÿlistþ, ÿsequenceþ, ÿtþ

Description:
............

The only object of type ÿnullþ is ÿnilþ, which represents the empty
list and can also be notated ().

See Also:
.........

*Note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens, *Note
Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *Note Section
22.1.3.3 (Printing Symbols): PrintingSymbols.


File: chris-ansicl.info,  Node: cons (System Class),  Next: atom (Type),  Prev: null (System Class),  Up: Conses

cons (System Class)
===================

Class Precedence List:
......................

ÿconsþ, ÿlistþ, ÿsequenceþ, ÿtþ

Description:
............

A cons is a compound object having two components, called the car and
cdr. These form a dotted pair.  Each component can be any object.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(cons [car-typespec [cdr-typespec]])

Compound Type Specifier Arguments:
..................................

CAR-TYPESPEC--a type specifier, or the symbol *.  The default is the
symbol *.

CDR-TYPESPEC--a type specifier, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description:
....................................

This denotes the set of conses whose car is constrained to be of type
CAR-TYPESPEC and whose cdr is constrained to be of type CDR-TYPESPEC.
(If either CAR-TYPESPEC or CDR-TYPESPEC is *, it is as if the type ÿtþ
had been denoted.)

See Also:
.........

*Note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *Note Section
22.1.3.5 (Printing Lists and Conses): PrintingListsAndConses.


File: chris-ansicl.info,  Node: atom (Type),  Next: cons (Function),  Prev: cons (System Class),  Up: Conses

atom (Type)
===========

Supertypes:
...........

ÿatomþ, ÿtþ

Description:
............

It is equivalent to ÿ(not cons)þ.


File: chris-ansicl.info,  Node: cons (Function),  Next: consp,  Prev: atom (Type),  Up: Conses

cons (Function)
===============

Syntax:
.......

 -- Function: cons object-1 object-2 ý cons

Arguments and Values:
.....................

OBJECT-1--an object.

OBJECT-2--an object.

CONS--a cons.

Description:
............

Creates a fresh cons, the car of which is OBJECT-1 and the cdr of which
is OBJECT-2.

Examples:
.........

 (cons 1 2) ý (1 . 2)
 (cons 1 nil) ý (1)
 (cons nil 2) ý (NIL . 2)
 (cons nil nil) ý (NIL)
 (cons 1 (cons 2 (cons 3 (cons 4 nil)))) ý (1 2 3 4)
 (cons 'a 'b) ý (A . B)
 (cons 'a (cons 'b (cons 'c '()))) ý (A B C)
 (cons 'a '(b c d)) ý (A B C D)

See Also:
.........

*Note list::

Notes:
......

If OBJECT-2 is a list, ÿconsþ can be thought of as producing a new list
which is like it but has OBJECT-1 prepended.


File: chris-ansicl.info,  Node: consp,  Next: atom (Function),  Prev: cons (Function),  Up: Conses

consp (Function)
================

Syntax:
.......

 -- Function: consp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿconsþ; otherwise, returns false.

Examples:
.........

 (consp nil) ý false
 (consp (cons 1 2)) ý true

The empty list is not a cons, so

 (consp '()) Õ (consp 'nil) ý false

See Also:
.........

*Note listp::

Notes:
......

 (consp OBJECT) Õ (typep OBJECT 'cons) Õ (not (typep OBJECT 'atom)) Õ (typep OBJECT '(not atom))


File: chris-ansicl.info,  Node: atom (Function),  Next: rplaca; rplacd,  Prev: consp,  Up: Conses

atom (Function)
===============

Syntax:
.......

 -- Function: atom object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿatomþ; otherwise, returns false.

Examples:
.........

 (atom 'sss) ý true
 (atom (cons 1 2)) ý false
 (atom nil) ý true
 (atom '()) ý true
 (atom 3) ý true

Notes:
......

 (atom OBJECT) Õ (typep OBJECT 'atom) Õ (not (consp OBJECT))
 Õ (not (typep OBJECT 'cons)) Õ (typep OBJECT '(not cons))


File: chris-ansicl.info,  Node: rplaca; rplacd,  Next: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Prev: atom (Function),  Up: Conses

rplaca, rplacd (Function)
=========================

Syntax:
.......

 -- Function: rplaca cons object ý cons

 -- Function: rplacd cons object ý cons

Pronunciation:
..............

ÿrplacaþ: [éræêplakè] or [érèêplakè]

ÿrplacdþ: [éræêplakdè] or [érèêplakdè] or [éræêplakdæ] or [érèêplakdæ]

Arguments and Values:
.....................

CONS--a cons.

OBJECT--an object.

Description:
............

ÿrplacaþ replaces the car of the CONS with OBJECT.

ÿrplacdþ replaces the cdr of the CONS with OBJECT.

Examples:
.........

 (defparameter *some-list* (list* 'one 'two 'three 'four)) ý *some-list*
 *some-list* ý (ONE TWO THREE . FOUR)
 (rplaca *some-list* 'uno) ý (UNO TWO THREE . FOUR)
 *some-list* ý (UNO TWO THREE . FOUR)
 (rplacd (last *some-list*) (list 'IV)) ý (THREE IV)
 *some-list* ý (UNO TWO THREE IV)

Side Effects:
.............

The CONS is modified.

Should signal an error of type ÿtype-errorþ if CONS is not a cons.


File: chris-ansicl.info,  Node: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Next: copy-tree,  Prev: rplaca; rplacd,  Up: Conses

car, cdr, caar, cadr, cdar, cddr, caaar, caadr, cadar, caddr, cdaar, cdadr, cddar, cdddr, caaaar, caaadr, caadar, caaddr, cadaar, cadadr, caddar, cadddr, cdaaar, cdaadr, cdadar, cdaddr, cddaar, cddadr, cdddar, cddddr (Accessor)
===================================================================================================================================================================================================================================

Syntax:
.......

car x ý object  |  (setf (x object) new-object)
cdr x ý object  |  (setf (x object) new-object)
caar x ý object  |  (setf (x object) new-object)
cadr x ý object  |  (setf (x object) new-object)
cdar x ý object  |  (setf (x object) new-object)
cddr x ý object  |  (setf (x object) new-object)
caaar x ý object  |  (setf (x object) new-object)
caadr x ý object  |  (setf (x object) new-object)
cadar x ý object  |  (setf (x object) new-object)
caddr x ý object  |  (setf (x object) new-object)
cdaar x ý object  |  (setf (x object) new-object)
cdadr x ý object  |  (setf (x object) new-object)
cddar x ý object  |  (setf (x object) new-object)
cdddr x ý object  |  (setf (x object) new-object)
caaaar x ý object  |  (setf (x object) new-object)
caaadr x ý object  |  (setf (x object) new-object)
caadar x ý object  |  (setf (x object) new-object)
caaddr x ý object  |  (setf (x object) new-object)
cadaar x ý object  |  (setf (x object) new-object)
cadadr x ý object  |  (setf (x object) new-object)
caddar x ý object  |  (setf (x object) new-object)
cadddr x ý object  |  (setf (x object) new-object)
cdaaar x ý object  |  (setf (x object) new-object)
cdaadr x ý object  |  (setf (x object) new-object)
cdadar x ý object  |  (setf (x object) new-object)
cdaddr x ý object  |  (setf (x object) new-object)
cddaar x ý object  |  (setf (x object) new-object)
cddadr x ý object  |  (setf (x object) new-object)
cdddar x ý object  |  (setf (x object) new-object)
cddddr x ý object  |  (setf (x object) new-object)
Pronunciation:
..............

ÿcadrþ: [êkaédè r]

ÿcaddrþ: [êkadè édè r] or [êkaéd.udè r]

ÿcdrþ: [êk.uédè r]

ÿcddrþ: [êk.udè édè r] or [êkèéd.udè r]

Arguments and Values:
.....................

X--a list.

OBJECT--an object.

NEW-OBJECT--an object.

Description:
............

If X is a cons, ÿcarþ returns the car of that cons.  If X is ÿnilþ,
ÿcarþ returns ÿnilþ.

If X is a cons, ÿcdrþ returns the cdr of that cons.  If X is ÿnilþ,
ÿcdrþ returns ÿnilþ.

Functions are provided which perform compositions of up to four ÿcarþ
and ÿcdrþ operations.  Their names consist of a ÿCþ, followed by two,
three, or four occurrences of ÿAþ or ÿDþ, and finally an ÿRþ.  The
series of ÿAþ's and ÿDþ's in each function's name is chosen to identify
the series of ÿcarþ and ÿcdrþ operations that is performed by the
function.  The order in which the ÿAþ's and ÿDþ's appear is the inverse
of the order in which the corresponding operations are performed.  The
next figure  defines the relationships precisely.

This place ...   Is equivalent to this place ...
--------------------------------------------------- 
ÿ(caar X)þ       ÿ(car (car X))þ
ÿ(cadr X)þ       ÿ(car (cdr X))þ
ÿ(cdar X)þ       ÿ(cdr (car X))þ
ÿ(cddr X)þ       ÿ(cdr (cdr X))þ
ÿ(caaar X)þ      ÿ(car (car (car X)))þ
ÿ(caadr X)þ      ÿ(car (car (cdr X)))þ
ÿ(cadar X)þ      ÿ(car (cdr (car X)))þ
ÿ(caddr X)þ      ÿ(car (cdr (cdr X)))þ
ÿ(cdaar X)þ      ÿ(cdr (car (car X)))þ
ÿ(cdadr X)þ      ÿ(cdr (car (cdr X)))þ
ÿ(cddar X)þ      ÿ(cdr (cdr (car X)))þ
ÿ(cdddr X)þ      ÿ(cdr (cdr (cdr X)))þ
ÿ(caaaar X)þ     ÿ(car (car (car (car X))))þ
ÿ(caaadr X)þ     ÿ(car (car (car (cdr X))))þ
ÿ(caadar X)þ     ÿ(car (car (cdr (car X))))þ
ÿ(caaddr X)þ     ÿ(car (car (cdr (cdr X))))þ
ÿ(cadaar X)þ     ÿ(car (cdr (car (car X))))þ
ÿ(cadadr X)þ     ÿ(car (cdr (car (cdr X))))þ
ÿ(caddar X)þ     ÿ(car (cdr (cdr (car X))))þ
ÿ(cadddr X)þ     ÿ(car (cdr (cdr (cdr X))))þ
ÿ(cdaaar X)þ     ÿ(cdr (car (car (car X))))þ
ÿ(cdaadr X)þ     ÿ(cdr (car (car (cdr X))))þ
ÿ(cdadar X)þ     ÿ(cdr (car (cdr (car X))))þ
ÿ(cdaddr X)þ     ÿ(cdr (car (cdr (cdr X))))þ
ÿ(cddaar X)þ     ÿ(cdr (cdr (car (car X))))þ
ÿ(cddadr X)þ     ÿ(cdr (cdr (car (cdr X))))þ
ÿ(cdddar X)þ     ÿ(cdr (cdr (cdr (car X))))þ
ÿ(cddddr X)þ     ÿ(cdr (cdr (cdr (cdr X))))þ

Figure 14.6: CAR and CDR variants

ÿsetfþ can also be used with any of these functions to change an
existing component of X, but ÿsetfþ will not make new components.  So,
for example, the car of a cons can be assigned with ÿsetfþ of ÿcarþ,
but the car of ÿnilþ cannot be assigned with ÿsetfþ of ÿcarþ.
Similarly, the car of the car of a cons whose car is a cons can be
assigned with ÿsetfþ of ÿcaarþ, but neither ÿnilþ nor a cons whose car
is ÿnilþ can be assigned with ÿsetfþ of ÿcaarþ.

The argument X is permitted to be a dotted list or a circular list.

Examples:
.........

 (car nil) ý NIL
 (cdr '(1 . 2)) ý 2
 (cdr '(1 2)) ý (2)
 (cadr '(1 2)) ý 2
 (car '(a b c)) ý A
 (cdr '(a b c)) ý (B C)

Exceptional Situations:
.......................

The functions ÿcarþ and ÿcdrþ should signal ÿtype-errorþ if they
receive an argument which is not a list.  The other functions (ÿcaarþ,
ÿcadrþ, ... ÿcddddrþ) should behave for the purpose of error checking
as if defined by appropriate calls to ÿcarþ and ÿcdrþ.

See Also:
.........

*Note rplaca::, *Note first::, *Note rest::

Notes:
......

The car of a cons can also be altered by using ÿrplacaþ, and the cdr of
a cons can be altered by using ÿrplacdþ.

(car x)    Õ (first x)
(cadr x)   Õ (second x) Õ (car (cdr x))
(caddr x)  Õ (third x)  Õ (car (cdr (cdr x)))
(cadddr x) Õ (fourth x) Õ (car (cdr (cdr (cdr x))))


File: chris-ansicl.info,  Node: copy-tree,  Next: sublis; nsublis,  Prev: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Up: Conses

copy-tree (Function)
====================

Syntax:
.......

 -- Function: copy-tree tree ý new-tree

Arguments and Values:
.....................

TREE--a tree.

NEW-TREE--a tree.

Description:
............

Creates a copy of a tree of conses.

If TREE is not a cons, it is returned; otherwise, the result is a new
cons of the results of calling ÿcopy-treeþ on the car and cdr of TREE.
In other words, all conses in the tree represented by TREE are copied
recursively, stopping only when non-conses are encountered.

ÿcopy-treeþ does not preserve circularities and the sharing of
substructure.

Examples:
.........

 (setq object (list (cons 1 "one")
                    (cons 2 (list 'a 'b 'c))))
ý ((1 . "one") (2 A B C))
 (setq object-too object) ý ((1 . "one") (2 A B C))
 (setq copy-as-list (copy-list object))
 (setq copy-as-alist (copy-alist object))
 (setq copy-as-tree (copy-tree object))
 (eq object object-too) ý true
 (eq copy-as-tree object) ý false
 (eql copy-as-tree object) ý false
 (equal copy-as-tree object) ý true
 (setf (first (cdr (second object))) "a"
       (car (second object)) "two"
       (car object) '(one . 1)) ý (ONE . 1)
 object ý ((ONE . 1) ("two" "a" B C))
 object-too ý ((ONE . 1) ("two" "a" B C))
 copy-as-list ý ((1 . "one") ("two" "a" B C))
 copy-as-alist ý ((1 . "one") (2 "a" B C))
 copy-as-tree ý ((1 . "one") (2 A B C))

See Also:
.........

*Note tree-equal::


File: chris-ansicl.info,  Node: sublis; nsublis,  Next: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Prev: copy-tree,  Up: Conses

sublis, nsublis (Function)
==========================

Syntax:
.......

 -- Function: sublis alist tree &key key test test-not ý new-tree

 -- Function: nsublis alist tree &key key test test-not ý new-tree

Arguments and Values:
.....................

ALIST--an association list.

TREE--a tree.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

NEW-TREE--a tree.

Description:
............

ÿsublisþ makes substitutions for objects in TREE (a structure of
conses).  ÿnsublisþ is like ÿsublisþ but destructively modifies the
relevant parts of the TREE.

ÿsublisþ looks at all subtrees and leaves of TREE; if a subtree or leaf
appears as a key in ALIST (that is, the key and the subtree or leaf
satisfy the test), it is replaced by the object with which that key is
associated.  This operation is non-destructive.  In effect, ÿsublisþ can
perform several ÿsubstþ operations simultaneously.

If ÿsublisþ succeeds, a new copy of TREE is returned in which each
occurrence of such a subtree or leaf is replaced by the object with
which it is associated.   If no changes are made, the original tree is
returned.  The original TREE is left unchanged, but the result tree may
share cells with it.

ÿnsublisþ is permitted to modify TREE but otherwise returns the same
values as ÿsublisþ.

Examples:
.........

 (sublis '((x . 100) (z . zprime))
         '(plus x (minus g z x p) 4 . x))
ý (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)
 (sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))
         '(* (/ (+ x y) (+ x p)) (- x y))
         :test #'equal)
ý (* (/ (- X Y) (+ X P)) (+ X Y))
 (setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))
ý (1 (1 2) ((1 2 3)) (((1 2 3 4))))
 (sublis '((3 . "three")) tree1)
ý (1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))
 (sublis '((t . "string"))
          (sublis '((1 . "") (4 . 44)) tree1)
          :key #'stringp)
ý ("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))
 tree1 ý (1 (1 2) ((1 2 3)) (((1 2 3 4))))
 (setq tree2 '("one" ("one" "two") (("one" "Two" "three"))))
ý ("one" ("one" "two") (("one" "Two" "three")))
 (sublis '(("two" . 2)) tree2)
ý ("one" ("one" "two") (("one" "Two" "three")))
 tree2 ý ("one" ("one" "two") (("one" "Two" "three")))
 (sublis '(("two" . 2)) tree2 :test 'equal)
ý ("one" ("one" 2) (("one" "Two" "three")))

 (nsublis '((t . 'temp))
           tree1
           :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))
ý ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP)

Side Effects:
.............

ÿnsublisþ modifies TREE.

See Also:
.........

*Note subst::, *Note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Because the side-effecting variants (e.g., ÿnsublisþ) potentially
change the path that is being traversed, their effects in the presence
of shared or circular structure structure may vary in surprising ways
when compared to their non-side-effecting alternatives.  To see this,
consider the following side-effect behavior, which might be exhibited by
some implementations:

 (defun test-it (fn)
   (let* ((shared-piece (list 'a 'b))
          (data (list shared-piece shared-piece)))
     (funcall fn '((a . b) (b . a)) data)))
 (test-it #'sublis) ý ((B A) (B A))
 (test-it #'nsublis) ý ((A B) (A B))


File: chris-ansicl.info,  Node: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Next: tree-equal,  Prev: sublis; nsublis,  Up: Conses

subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not (Function)
==========================================================================

Syntax:
.......

 -- Function: subst new old tree &key key test test-not ý new-tree

 -- Function: subst-if new predicate tree &key key ý new-tree

 -- Function: subst-if-not new predicate tree &key key ý new-tree

 -- Function: nsubst new old tree &key key test test-not ý new-tree

 -- Function: nsubst-if new predicate tree &key key ý new-tree

 -- Function: nsubst-if-not new predicate tree &key key ý new-tree

Arguments and Values:
.....................

NEW--an object.

OLD--an object.

PREDICATE--a symbol that names a function, or a function of one argument
that returns a generalized boolean value.

TREE--a tree.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

NEW-TREE--a tree.

Description:
............

ÿsubstþ, ÿsubst-ifþ, and ÿsubst-if-notþ perform substitution operations
on TREE.  Each function searches TREE for occurrences of a particular
OLD item of an element or subexpression that satisfies the test.

ÿnsubstþ, ÿnsubst-ifþ, and ÿnsubst-if-notþ are like ÿsubstþ,
ÿsubst-ifþ, and ÿsubst-if-notþ respectively, except that the original
TREE is  modified.

ÿsubstþ makes a copy of TREE, substituting NEW for every subtree or
leaf of TREE (whether the subtree or leaf is a car or a cdr of its
parent) such that OLD and the subtree or leaf satisfy the test.

ÿnsubstþ is a destructive version of ÿsubstþ.  The list structure of
TREE is altered by destructively replacing with NEW each leaf of the
TREE such that OLD and the leaf satisfy the test.

For ÿsubstþ, ÿsubst-ifþ, and ÿsubst-if-notþ, if the functions succeed,
a new copy of the tree is returned in which each  occurrence of such an
element is replaced by the NEW element or subexpression.  If no changes
are made, the original TREE may be returned.  The original TREE is left
unchanged, but the result tree may share storage with it.

For ÿnsubstþ, ÿnsubst-ifþ, and ÿnsubst-if-notþ the original TREE is
modified and returned as the function result, but the result may not be
ÿeqþ to TREE.

Examples:
.........

 (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) ý (1 (1 2) (1 2 3) (1 2 3 4))
 (subst "two" 2 tree1) ý (1 (1 "two") (1 "two" 3) (1 "two" 3 4))
 (subst "five" 5 tree1) ý (1 (1 2) (1 2 3) (1 2 3 4))
 (eq tree1 (subst "five" 5 tree1)) ý implementation-dependent
 (subst 'tempest 'hurricane
        '(shakespeare wrote (the hurricane)))
ý (SHAKESPEARE WROTE (THE TEMPEST))
 (subst 'foo 'nil '(shakespeare wrote (twelfth night)))
ý (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)
 (subst '(a . cons) '(old . pair)
        '((old . spice) ((old . shoes) old . pair) (old . pair))
        :test #'equal)
ý ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))

 (subst-if 5 #'listp tree1) ý 5
 (subst-if-not '(x) #'consp tree1)
ý (1 X)

 tree1 ý (1 (1 2) (1 2 3) (1 2 3 4))
 (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y))))
ý (1 (1 2) X X)
 tree1 ý (1 (1 2) X X)

Side Effects:
.............

ÿnsubstþ, ÿnsubst-ifþ, and ÿnsubst-if-notþ might alter the tree
structure of TREE.

See Also:
.........

*Note substitute::, *Note nsubstitute::, *Note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *Note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The functions ÿsubst-if-notþ and ÿnsubst-if-notþ are deprecated.

One possible definition of ÿsubstþ:

 (defun subst (old new tree &rest x &key test test-not key)
   (cond ((satisfies-the-test old tree :test test
                              :test-not test-not :key key)
          new)
         ((atom tree) tree)
         (t (let ((a (apply #'subst old new (car tree) x))
                  (d (apply #'subst old new (cdr tree) x)))
              (if (and (eql a (car tree))
                       (eql d (cdr tree)))
                  tree
                  (cons a d))))))


File: chris-ansicl.info,  Node: tree-equal,  Next: copy-list,  Prev: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Up: Conses

tree-equal (Function)
=====================

Syntax:
.......

 -- Function: tree-equal tree-1 tree-2 &key test test-not ý
          generalized-boolean

Arguments and Values:
.....................

TREE-1--a tree.

TREE-2--a tree.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿtree-equalþ tests whether two trees are of the same shape and have the
same leaves.  ÿtree-equalþ returns true if TREE-1 and TREE-2  are both
atoms and satisfy the test, or if they are both conses and the car of
TREE-1 is ÿtree-equalþ to the car of TREE-2 and the cdr of TREE-1 is
ÿtree-equalþ to the cdr of TREE-2.  Otherwise, ÿtree-equalþ returns
false.

ÿtree-equalþ recursively compares conses but not any other objects that
have components.

The first argument to the :test or :test-not function is TREE-1 or a
car or cdr of TREE-1; the second argument is TREE-2 or a car or cdr of
TREE-2.

Examples:
.........

 (setq tree1 '(1 (1 2))
       tree2 '(1 (1 2))) ý (1 (1 2))
 (tree-equal tree1 tree2) ý true
 (eql tree1 tree2) ý false
 (setq tree1 '('a ('b 'c))
       tree2 '('a ('b 'c))) ý ('a ('b 'c))
ý ((QUOTE A) ((QUOTE B) (QUOTE C)))
 (tree-equal tree1 tree2 :test 'eq) ý true

Exceptional Situations:
.......................

The consequences are undefined if both TREE-1 and TREE-2 are circular.

See Also:
.........

*Note equal::, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: chris-ansicl.info,  Node: copy-list,  Next: list; list*,  Prev: tree-equal,  Up: Conses

copy-list (Function)
====================

Syntax:
.......

 -- Function: copy-list list ý copy

Arguments and Values:
.....................

LIST--a proper list or a dotted list.

COPY--a list.

Description:
............

Returns a copy of LIST.  If LIST is a dotted list, the resulting list
will also be a dotted list.

Only the list structure of LIST is copied; the elements of the
resulting list are the same as the corresponding elements of the given
LIST.

Examples:
.........

 (setq lst (list 1 (list 2 3))) ý (1 (2 3))
 (setq slst lst) ý (1 (2 3))
 (setq clst (copy-list lst)) ý (1 (2 3))
 (eq slst lst) ý true
 (eq clst lst) ý false
 (equal clst lst) ý true
 (rplaca lst "one") ý ("one" (2 3))
 slst ý ("one" (2 3))
 clst ý (1 (2 3))
 (setf (caadr lst) "two") ý "two"
 lst ý ("one" ("two" 3))
 slst ý ("one" ("two" 3))
 clst ý (1 ("two" 3))

Exceptional Situations:
.......................

The consequences are undefined if LIST is a circular list.

See Also:
.........

*Note copy-alist::, *Note copy-seq::, *Note copy-tree::

Notes:
......

The copy created is ÿequalþ to LIST, but not ÿeqþ.


File: chris-ansicl.info,  Node: list; list*,  Next: list-length,  Prev: copy-list,  Up: Conses

list, list* (Function)
======================

Syntax:
.......

 -- Function: list &rest objects ý list

 -- Function: list* &rest objects+ ý result

Arguments and Values:
.....................

OBJECT--an object.

LIST--a list.

RESULT--an object.

Description:
............

ÿlistþ returns a list containing the supplied OBJECTS.

ÿlist*þ is like ÿlistþ except that the last argument to ÿlistþ becomes
the car of the last cons constructed, while the last argument to
ÿlist*þ becomes the cdr of the last cons constructed.  Hence, any given
call to ÿlist*þ always produces one fewer conses than a call to ÿlistþ
with the same number of arguments.

If the last argument to ÿlist*þ is a list, the effect is to construct a
new list which is similar, but which has additional elements added to
the front corresponding to the preceding arguments of ÿlist*þ.

If ÿlist*þ receives only one OBJECT, that OBJECT is returned,
regardless of whether or not it is a list.

Examples:
.........

 (list 1) ý (1)
 (list* 1) ý 1
 (setq a 1) ý 1
 (list a 2) ý (1 2)
 '(a 2) ý (A 2)
 (list 'a 2) ý (A 2)
 (list* a 2) ý (1 . 2)
 (list) ý NIL ;i.e., ()
 (setq a '(1 2)) ý (1 2)
 (eq a (list* a)) ý true
 (list 3 4 'a (car '(b . c)) (+ 6 -2)) ý (3 4 A B 4)
 (list* 'a 'b 'c 'd) Õ (cons 'a (cons 'b (cons 'c 'd))) ý (A B C . D)
 (list* 'a 'b 'c '(d e f)) ý (A B C D E F)

See Also:
.........

*Note cons (Function)::

Notes:
......

 (list* X) Õ X


File: chris-ansicl.info,  Node: list-length,  Next: listp,  Prev: list; list*,  Up: Conses

list-length (Function)
======================

Syntax:
.......

 -- Function: list-length list ý length

Arguments and Values:
.....................

LIST--a proper list or a circular list.

LENGTH--a non-negative integer, or ÿnilþ.

Description:
............

Returns the length of LIST if LIST is a proper list.  Returns ÿnilþ if
LIST is a circular list.

Examples:
.........

 (list-length '(a b c d)) ý 4
 (list-length '(a (b c) d)) ý 3
 (list-length '()) ý 0
 (list-length nil) ý 0
 (defun circular-list (&rest elements)
   (let ((cycle (copy-list elements)))
     (nconc cycle cycle)))
 (list-length (circular-list 'a 'b)) ý NIL
 (list-length (circular-list 'a)) ý NIL
 (list-length (circular-list)) ý 0

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if LIST is not a proper
list or a circular list.

See Also:
.........

*Note length::

Notes:
......

ÿlist-lengthþ could be implemented as follows:

 (defun list-length (x)
   (do ((n 0 (+ n 2))           ;Counter.
        (fast x (cddr fast))    ;Fast pointer: leaps by 2.
        (slow x (cdr slow)))    ;Slow pointer: leaps by 1.
       (nil)
     ;; If fast pointer hits the end, return the count.
     (when (endp fast) (return n))
     (when (endp (cdr fast)) (return (+ n 1)))
     ;; If fast pointer eventually equals slow pointer,
     ;;  then we must be stuck in a circular list.
     ;; (A deeper property is the converse: if we are
     ;;  stuck in a circular list, then eventually the
     ;;  fast pointer will equal the slow pointer.
     ;;  That fact justifies this implementation.)
     (when (and (eq fast slow) (> n 0)) (return nil))))


File: chris-ansicl.info,  Node: listp,  Next: make-list,  Prev: list-length,  Up: Conses

listp (Function)
================

Syntax:
.......

 -- Function: listp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿlistþ; otherwise, returns false.

Examples:
.........

 (listp nil) ý true
 (listp (cons 1 2)) ý true
 (listp (make-array 6)) ý false
 (listp t) ý false

See Also:
.........

*Note consp::

Notes:
......

If OBJECT is a cons, ÿlistpþ does not check whether OBJECT is a proper
list; it returns true for any kind of list.

 (listp OBJECT) Õ (typep OBJECT 'list) Õ (typep OBJECT '(or cons null))


File: chris-ansicl.info,  Node: make-list,  Next: push,  Prev: listp,  Up: Conses

make-list (Function)
====================

Syntax:
.......

 -- Function: make-list size &key initial-element ý list

Arguments and Values:
.....................

SIZE--a non-negative integer.

INITIAL-ELEMENT--an object.  The default is ÿnilþ.

LIST--a list.

Description:
............

Returns a list of LENGTH given by size, each of the elements of which
is INITIAL-ELEMENT.

Examples:
.........

 (make-list 5) ý (NIL NIL NIL NIL NIL)
 (make-list 3 :initial-element 'rah) ý (RAH RAH RAH)
 (make-list 2 :initial-element '(1 2 3)) ý ((1 2 3) (1 2 3))
 (make-list 0) ý NIL ;i.e., ()
 (make-list 0 :initial-element 'new-element) ý NIL

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SIZE is not a
non-negative integer.

See Also:
.........

*Note cons (Function)::, *Note list::


File: chris-ansicl.info,  Node: push,  Next: pop,  Prev: make-list,  Up: Conses

push (Macro)
============

Syntax:
.......

 -- Macro: push item place ý new-place-value

Arguments and Values:
.....................

ITEM--an object.

PLACE--a place, the value of which may be any object.

NEW-PLACE-VALUE--a list (the new value of PLACE).

Description:
............

ÿpushþ prepends ITEM to the list that is stored in PLACE, stores the
resulting list in PLACE, and returns the list.

For information about the evaluation of subforms of PLACE, see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq llst '(nil)) ý (NIL)
 (push 1 (car llst)) ý (1)
 llst ý ((1))
 (push 1 (car llst)) ý (1 1)
 llst ý ((1 1))
 (setq x '(a (b c) d)) ý (A (B C) D)
 (push 5 (cadr x)) ý (5 B C)
 x ý (A (5 B C) D)

Side Effects:
.............

The contents of PLACE are modified.

See Also:
.........

*Note pop::, *Note pushnew::, *Note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ÿ(push item place)þ is equivalent to

 (setf place (cons item place))

except that the subforms of PLACE are evaluated only once, and ITEM is
evaluated before PLACE.


File: chris-ansicl.info,  Node: pop,  Next: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Prev: push,  Up: Conses

pop (Macro)
===========

Syntax:
.......

 -- Macro: pop place ý element

Arguments and Values:
.....................

PLACE--a place, the value of which is a list (possibly, but
necessarily, a dotted list or circular list).

ELEMENT--an object (the car of the contents of PLACE).

Description:
............

ÿpopþ reads the value of PLACE, remembers the car of the list which was
retrieved, writes the cdr of the list back into the PLACE, and finally
yields the car of the originally retrieved list.

For information about the evaluation of subforms of PLACE, see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq stack '(a b c)) ý (A B C)
 (pop stack) ý A
 stack ý (B C)
 (setq llst '((1 2 3 4))) ý ((1 2 3 4))
 (pop (car llst)) ý 1
 llst ý ((2 3 4))

Side Effects:
.............

The contents of PLACE are modified.

See Also:
.........

*Note push::, *Note pushnew::, *Note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ÿ(pop PLACE)þ is roughly equivalent to

 (prog1 (car PLACE) (setf PLACE (cdr PLACE)))

except that the latter would evaluate any subforms of PLACE three
times, while ÿpopþ evaluates them only once.


File: chris-ansicl.info,  Node: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Next: nth,  Prev: pop,  Up: Conses

first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth (Accessor)
====================================================================================

Syntax:
.......

first list ý object  |  (setf (list object) new-object)
second list ý object  |  (setf (list object) new-object)
third list ý object  |  (setf (list object) new-object)
fourth list ý object  |  (setf (list object) new-object)
fifth list ý object  |  (setf (list object) new-object)
sixth list ý object  |  (setf (list object) new-object)
seventh list ý object  |  (setf (list object) new-object)
eighth list ý object  |  (setf (list object) new-object)
ninth list ý object  |  (setf (list object) new-object)
tenth list ý object  |  (setf (list object) new-object)
Arguments and Values:
.....................

LIST--a list, which might be a dotted list or a circular list.

OBJECT, NEW-OBJECT--an OBJECT.

Description:
............

The functions ÿfirstþ, ÿsecondþ, ÿthirdþ, ÿfourthþ, ÿfifthþ, ÿsixthþ,
ÿseventhþ, ÿeighthþ, ÿninthþ, and ÿtenthþ ACCESS the first, second,
third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth elements
of LIST, respectively.  Specifically,

 (first LIST)    Õ  (car LIST)
 (second LIST)   Õ  (car (cdr LIST))
 (third LIST)    Õ  (car (cddr LIST))
 (fourth LIST)   Õ  (car (cdddr LIST))
 (fifth LIST)    Õ  (car (cddddr LIST))
 (sixth LIST)    Õ  (car (cdr (cddddr LIST)))
 (seventh LIST)  Õ  (car (cddr (cddddr LIST)))
 (eighth LIST)   Õ  (car (cdddr (cddddr LIST)))
 (ninth LIST)    Õ  (car (cddddr (cddddr LIST)))
 (tenth LIST)    Õ  (car (cdr (cddddr (cddddr LIST))))

ÿsetfþ can also be used with any of these functions to change an
existing component.  The same equivalences apply.  For example:

 (setf (fifth LIST) NEW-OBJECT) Õ (setf (car (cddddr LIST)) NEW-OBJECT)

Examples:
.........

 (setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10))
ý (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)
 (first lst) ý 1
 (tenth lst) ý 10
 (fifth lst) ý ((V))
 (second (fourth lst)) ý 5
 (sixth '(1 2 3)) ý NIL
 (setf (fourth lst) "four") ý "four"
 lst ý (1 2 3 "four" ((V)) VI 7 8 9 10)

See Also:
.........

*Note car::, *Note nth::

Notes:
......

ÿfirstþ  is functionally equivalent to ÿcarþ, ÿsecondþ is functionally
equivalent to ÿcadrþ, ÿthirdþ  is functionally equivalent to ÿcaddrþ,
and ÿfourthþ is functionally equivalent to ÿcadddrþ.

The ordinal numbering used here is one-origin, as opposed to the
zero-origin numbering used by ÿnthþ:

 (fifth x) Õ (nth 4 x)


File: chris-ansicl.info,  Node: nth,  Next: endp,  Prev: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Up: Conses

nth (Accessor)
==============

Syntax:
.......

 -- Function: nth n list ý object

(setf (nth n list) new-object)

Arguments and Values:
.....................

N--a non-negative integer.

LIST--a list, which might be a dotted list or a circular list.

OBJECT--an object.

NEW-OBJECT--an object.

Description:
............

ÿnthþ locates the Nth element of LIST, where the car of the LIST is the
"zeroth" element.  Specifically,

 (nth N LIST) Õ (car (nthcdr N LIST))

ÿnthþ may be used to specify a PLACE to ÿsetfþ.  Specifically,

 (setf (nth N LIST) NEW-OBJECT) Õ (setf (car (nthcdr N LIST)) NEW-OBJECT)

Examples:
.........

 (nth 0 '(foo bar baz)) ý FOO
 (nth 1 '(foo bar baz)) ý BAR
 (nth 3 '(foo bar baz)) ý NIL
 (setq 0-to-3 (list 0 1 2 3)) ý (0 1 2 3)
 (setf (nth 2 0-to-3) "two") ý "two"
 0-to-3 ý (0 1 "two" 3)

See Also:
.........

*Note elt::, *Note first::, *Note nthcdr::


File: chris-ansicl.info,  Node: endp,  Next: null (Function),  Prev: nth,  Up: Conses

endp (Function)
===============

Syntax:
.......

 -- Function: endp list ý generalized-boolean

Arguments and Values:
.....................

LIST--a list, which might be a dotted list or a circular list.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true  if LIST is the empty list.  Returns false if LIST is a
cons.

Examples:
.........

 (endp nil) ý true
 (endp '(1 2)) ý false
 (endp (cddr '(1 2))) ý true

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if LIST is not a list.

Notes:
......

The purpose of ÿendpþ is to test for the end of PROPER LIST.  Since
ÿendpþ does not descend into a cons, it is well-defined to pass it a
dotted list.  However, if shorter "lists" are iteratively produced by
calling ÿcdrþ on such a dotted list and those "lists" are tested with
ÿendpþ, a situation that has undefined consequences will eventually
result when the non-nil atom (which is not in fact a list) finally
becomes the argument to ÿendpþ.  Since this is the usual way in which
ÿendpþ is used, it is conservative programming style and consistent
with the intent of ÿendpþ to treat ÿendpþ as simply a function on
proper lists which happens not to enforce an argument type of proper
list except when the argument is atomic.


File: chris-ansicl.info,  Node: null (Function),  Next: nconc,  Prev: endp,  Up: Conses

null (Function)
===============

Syntax:
.......

 -- Function: null object ý boolean

Arguments and Values:
.....................

OBJECT--an object.

BOOLEAN--a boolean.

Description:
............

Returns ÿtþ if OBJECT is the empty list; otherwise, returns ÿnilþ.

Examples:
.........

 (null '()) ý T
 (null nil) ý T
 (null t) ý NIL
 (null 1) ý NIL

See Also:
.........

*Note not (Function)::

Notes:
......

ÿnullþ is intended to be used to test for the empty list whereas ÿnotþ
is intended to be used to invert a boolean (or generalized boolean).
Operationally, ÿnullþ and ÿnotþ compute the same result; which to use
is a matter of style.

 (null OBJECT) Õ (typep OBJECT 'null) Õ (eq OBJECT '())


File: chris-ansicl.info,  Node: nconc,  Next: append,  Prev: null (Function),  Up: Conses

nconc (Function)
================

Syntax:
.......

 -- Function: nconc &rest lists ý concatenated-list

Arguments and Values:
.....................

LIST--each but the last must be a list (which might be a DOTTED LIST
but must not be a circular list); the last LIST may be any object.

CONCATENATED-LIST--a list.

Description:
............

Returns a list that is the concatenation of LISTS.  If no LISTS are
supplied, ÿ(nconc)þ returns ÿnilþ.  ÿnconcþ is defined using the
following recursive relationship:

 (nconc) ý ()
 (nconc nil . LISTS) Õ (nconc . LISTS)
 (nconc LIST) ý LIST
 (nconc LIST-1 LIST-2) Õ (progn (rplacd (last LIST-1) LIST-2) LIST-1)
 (nconc LIST-1 LIST-2 . LISTS) Õ (nconc (nconc LIST-1 LIST-2) . LISTS)

Examples:
.........

 (nconc) ý NIL
 (setq x '(a b c)) ý (A B C)
 (setq y '(d e f)) ý (D E F)
 (nconc x y) ý (A B C D E F)
 x ý (A B C D E F)

Note, in the example, that the value of ÿxþ is now different, since its
last cons has been ÿrplacdþ'd to the value of ÿyþ.  If ÿ(nconc x y)þ
were evaluated again, it would yield a piece of a circular list, whose
printed representation would be ÿ(A B C D E F D E F D E F ...)þ,
repeating forever; if the ÿ*print-circle*þ switch were non-nil, it
would be printed as ÿ(A B C . #1=(D E F . #1#))þ.

 (setq foo (list 'a 'b 'c 'd 'e)
       bar (list 'f 'g 'h 'i 'j)
       baz (list 'k 'l 'm)) ý (K L M)
 (setq foo (nconc foo bar baz)) ý (A B C D E F G H I J K L M)
 foo ý (A B C D E F G H I J K L M)
 bar ý (F G H I J K L M)
 baz ý (K L M)

 (setq foo (list 'a 'b 'c 'd 'e)
       bar (list 'f 'g 'h 'i 'j)
       baz (list 'k 'l 'm)) ý (K L M)
 (setq foo (nconc nil foo bar nil baz)) ý (A B C D E F G H I J K L M)
 foo ý (A B C D E F G H I J K L M)
 bar ý (F G H I J K L M)
 baz ý (K L M)

Side Effects:
.............

The LISTS are modified rather than copied.

See Also:
.........

*Note append::, *Note concatenate::


File: chris-ansicl.info,  Node: append,  Next: revappend; nreconc,  Prev: nconc,  Up: Conses

append (Function)
=================

Syntax:
.......

 -- Function: append &rest lists ý result

Arguments and Values:
.....................

LIST--each must be a proper list except the last, which may be any
object.

RESULT--an object.  This will be a list unless the last LIST was not a
list and all preceding LISTS were null.

Description:
............

ÿappendþ returns a new LIST that is the concatenation of the copies.
LISTS are left unchanged; the list structure of each of LISTS except
the last is copied.  The last argument is not copied; it becomes the
cdr of the final dotted pair of the concatenation of the preceding
LISTS, or is returned directly if there are no preceding non-empty
LISTS.

Examples:
.........

 (append '(a b c) '(d e f) '() '(g)) ý (A B C D E F G)
 (append '(a b c) 'd) ý (A B C . D)
 (setq lst '(a b c)) ý (A B C)
 (append lst '(d)) ý (A B C D)
 lst ý (A B C)
 (append) ý NIL
 (append 'a) ý A

See Also:
.........

*Note nconc::, *Note concatenate::


File: chris-ansicl.info,  Node: revappend; nreconc,  Next: butlast; nbutlast,  Prev: append,  Up: Conses

revappend, nreconc (Function)
=============================

Syntax:
.......

 -- Function: revappend list tail ý result-list

 -- Function: nreconc list tail ý result-list

Arguments and Values:
.....................

LIST--a proper list.

TAIL--an object.

RESULT-LIST--an object.

Description:
............

ÿrevappendþ constructs a copyà of LIST, but with the elements in
reverse order.  It then appends (as if by ÿnconcþ) the TAIL to that
reversed list and returns the result.

ÿnreconcþ reverses the order of elements in LIST (as if by ÿnreverseþ).
It then appends (as if by ÿnconcþ) the TAIL to that reversed list and
returns the result.

The resulting list shares list structure with TAIL.

Examples:
.........

 (let ((list-1 (list 1 2 3))
       (list-2 (list 'a 'b 'c)))
   (print (revappend list-1 list-2))
   (print (equal list-1 '(1 2 3)))
   (print (equal list-2 '(a b c))))
Ö (3 2 1 A B C)
Ö T
Ö T
ý T

 (revappend '(1 2 3) '()) ý (3 2 1)
 (revappend '(1 2 3) '(a . b)) ý (3 2 1 A . B)
 (revappend '() '(a b c)) ý (A B C)
 (revappend '(1 2 3) 'a) ý (3 2 1 . A)
 (revappend '() 'a) ý A   ;degenerate case

 (let ((list-1 '(1 2 3))
       (list-2 '(a b c)))
   (print (nreconc list-1 list-2))
   (print (equal list-1 '(1 2 3)))
   (print (equal list-2 '(a b c))))
Ö (3 2 1 A B C)
Ö NIL
Ö T
ý T

Side Effects:
.............

ÿrevappendþ does not modify either of its arguments.  ÿnreconcþ is
permitted to modify LIST but not TAIL.

Although it might be implemented differently, ÿnreconcþ is constrained
to have side-effect behavior equivalent to:

 (nconc (nreverse LIST) TAIL)

See Also:
.........

*Note reverse::, *Note nreverse::, *Note nconc::

Notes:
......

The following functional equivalences are true, although good
implementations will typically use a faster algorithm for achieving the
same effect:

 (revappend LIST TAIL) Õ (nconc (reverse LIST) TAIL)
 (nreconc LIST TAIL) Õ (nconc (nreverse LIST) TAIL)


File: chris-ansicl.info,  Node: butlast; nbutlast,  Next: last,  Prev: revappend; nreconc,  Up: Conses

butlast, nbutlast (Function)
============================

Syntax:
.......

 -- Function: butlast list &optional n ý result-list

 -- Function: nbutlast list &optional n ý result-list

Arguments and Values:
.....................

LIST--a list, which might be a dotted list but must not be a circular
list.

N--a non-negative integer.

RESULT-LIST--a list.

Description:
............

ÿbutlastþ returns a copy of LIST from which the last N conses have been
omitted.  If N is not supplied, its value is 1.  If there are fewer
than N conses in LIST, ÿnilþ is returned and, in the case of ÿnbutlastþ,
LIST is not modified.

ÿnbutlastþ is like ÿbutlastþ, but ÿnbutlastþ may modify LIST.  It
changes the cdr of the cons N+1 from the end of the LIST to ÿnilþ.

Examples:
.........

 (setq lst '(1 2 3 4 5 6 7 8 9)) ý (1 2 3 4 5 6 7 8 9)
 (butlast lst) ý (1 2 3 4 5 6 7 8)
 (butlast lst 5) ý (1 2 3 4)
 (butlast lst (+ 5 5)) ý NIL
 lst ý (1 2 3 4 5 6 7 8 9)
 (nbutlast lst 3) ý (1 2 3 4 5 6)
 lst ý (1 2 3 4 5 6)
 (nbutlast lst 99) ý NIL
 lst ý (1 2 3 4 5 6)
 (butlast '(a b c d)) ý (A B C)
 (butlast '((a b) (c d))) ý ((A B))
 (butlast '(a)) ý NIL
 (butlast nil) ý NIL
 (setq foo (list 'a 'b 'c 'd)) ý (A B C D)
 (nbutlast foo) ý (A B C)
 foo ý (A B C)
 (nbutlast (list 'a)) ý NIL
 (nbutlast '()) ý NIL

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if LIST is not a proper
list or a dotted list.  Should signal an error of type ÿtype-errorþ if
N is not a non-negative integer.

Notes:
......

 (butlast LIST N) Õ (ldiff LIST (last LIST N))


File: chris-ansicl.info,  Node: last,  Next: ldiff; tailp,  Prev: butlast; nbutlast,  Up: Conses

last (Function)
===============

Syntax:
.......

 -- Function: last list &optional n ý tail

Arguments and Values:
.....................

LIST--a list, which might be a dotted list but must not be a circular
list.

N--a non-negative integer.  The default is ÿ1þ.

TAIL--an object.

Description:
............

ÿlastþ returns the last N conses (not the last N elements) of LIST).
If LIST is (), ÿlastþ returns ().

If N is zero, the atom that terminates LIST is returned.  If N is
greater than or equal to the number of cons cells in LIST, the result
is LIST.

Examples:
.........

 (last nil) ý NIL
 (last '(1 2 3)) ý (3)
 (last '(1 2 . 3)) ý (2 . 3)
 (setq x (list 'a 'b 'c 'd)) ý (A B C D)
 (last x) ý (D)
 (rplacd (last x) (list 'e 'f)) x ý (A B C D E F)
 (last x) ý (F)

 (last '(a b c))   ý (C)

 (last '(a b c) 0) ý ()
 (last '(a b c) 1) ý (C)
 (last '(a b c) 2) ý (B C)
 (last '(a b c) 3) ý (A B C)
 (last '(a b c) 4) ý (A B C)

 (last '(a . b) 0) ý B
 (last '(a . b) 1) ý (A . B)
 (last '(a . b) 2) ý (A . B)

Exceptional Situations:
.......................

The consequences are undefined if LIST is a circular list.  Should
signal an error of type ÿtype-errorþ if N is not a non-negative integer.

See Also:
.........

*Note butlast::, *Note nth::

Notes:
......

The following code could be used to define ÿlastþ.

 (defun last (list &optional (n 1))
   (check-type n (integer 0))
   (do ((l list (cdr l))
        (r list)
        (i 0 (+ i 1)))
       ((atom l) r)
     (if (>= i n) (pop r))))


File: chris-ansicl.info,  Node: ldiff; tailp,  Next: nthcdr,  Prev: last,  Up: Conses

ldiff, tailp (Function)
=======================

Syntax:
.......

 -- Function: ldiff list object ý result-list

 -- Function: tailp object list ý generalized-boolean

Arguments and Values:
.....................

LIST--a list, which might be a dotted list.

OBJECT--an object.

RESULT-LIST--a list.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

If OBJECT is the same as some tail of LIST, ÿtailpþ returns true;
otherwise, it returns false.

If OBJECT is the same as some tail of LIST, ÿldiffþ returns a fresh list
of the elements of list that precede ÿobjectþ in the list structure of
LIST; otherwise, it returns a copyà of LIST.

Examples:
.........

 (let ((lists '#((a b c) (a b c . d))))
   (dotimes (i (length lists)) ()
     (let ((list (aref lists i)))
       (format t "~2&list=~S ~21T(tailp object list)~
                  ~44T(ldiff list object)~%" list)
         (let ((objects (vector list (cddr list) (copy-list (cddr list))
                                '(f g h) '() 'd 'x)))
           (dotimes (j (length objects)) ()
             (let ((object (aref objects j)))
               (format t "~& object=~S ~21T~S ~44T~S"
                       object (tailp object list) (ldiff list object))))))))
Ö
Ö list=(A B C)         (tailp object list)    (ldiff list object)
Ö  object=(A B C)      T                      NIL
Ö  object=(C)          T                      (A B)
Ö  object=(C)          NIL                    (A B C)
Ö  object=(F G H)      NIL                    (A B C)
Ö  object=NIL          T                      (A B C)
Ö  object=D            NIL                    (A B C)
Ö  object=X            NIL                    (A B C)
Ö
Ö list=(A B C . D)     (tailp object list)    (ldiff list object)
Ö  object=(A B C . D)  T                      NIL
Ö  object=(C . D)      T                      (A B)
Ö  object=(C . D)      NIL                    (A B C . D)
Ö  object=(F G H)      NIL                    (A B C . D)
Ö  object=NIL          NIL                    (A B C . D)
Ö  object=D            T                      (A B C)
Ö  object=X            NIL                    (A B C . D)
ý NIL

Side Effects:
.............

Neither ÿldiffþ nor ÿtailpþ modifies either of its arguments.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST is
not a proper list or a dotted list.

See Also:
.........

*Note set-difference::

Notes:
......

If the LIST is a circular list, ÿtailpþ will reliably yield a value
only if the given OBJECT is in fact a tail of LIST.  Otherwise, the
consequences are unspecified: a given implementation which detects the
circularity must return false, but since an implementation is not
obliged to detect such a situation, ÿtailpþ might just loop
indefinitely without returning in that case.

ÿtailpþ could be defined as follows:

 (defun tailp (object list)
   (do ((list list (cdr list)))
       ((atom list) (eql list object))
      (if (eql object list)
          (return t))))

and ÿldiffþ could be defined by:

(defun ldiff (list object)
  (do ((list list (cdr list))
       (r '() (cons (car list) r)))
      ((atom list)
       (if (eql list object) (nreverse r) (nreconc r list)))
    (when (eql object list)
      (return (nreverse r)))))


File: chris-ansicl.info,  Node: nthcdr,  Next: rest,  Prev: ldiff; tailp,  Up: Conses

nthcdr (Function)
=================

Syntax:
.......

 -- Function: nthcdr n list ý tail

Arguments and Values:
.....................

N--a non-negative integer.

LIST--a list, which might be a dotted list or a circular list.

TAIL--an object.

Description:
............

Returns the tail of LIST that would be obtained by calling ÿcdrþ N
times in succession.

Examples:
.........

 (nthcdr 0 '()) ý NIL
 (nthcdr 3 '()) ý NIL
 (nthcdr 0 '(a b c)) ý (A B C)
 (nthcdr 2 '(a b c)) ý (C)
 (nthcdr 4 '(a b c)) ý ()
 (nthcdr 1 '(0 . 1)) ý 1

 (locally (declare (optimize (safety 3)))
   (nthcdr 3 '(0 . 1)))
 Error: Attempted to take CDR of 1.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if N is not a non-negative
integer.

For N being an integer greater than ÿ1þ, the error checking done by
ÿ(nthcdr N LIST)þ is the same as for ÿ(nthcdr (- N 1) (cdr LIST))þ; see
the function *Note cdr::.

See Also:
.........

*Note cdr::, *Note nth::, *Note rest::


File: chris-ansicl.info,  Node: rest,  Next: member; member-if; member-if-not,  Prev: nthcdr,  Up: Conses

rest (Accessor)
===============

Syntax:
.......

 -- Function: rest list ý tail

(setf (rest list) new-tail)

Arguments and Values:
.....................

LIST--a list, which might be a dotted list or a circular list.

TAIL--an object.

Description:
............

ÿrestþ performs the same operation as ÿcdrþ, but mnemonically
complements ÿfirstþ.  Specifically,

 (rest LIST) Õ (cdr LIST)
 (setf (rest LIST) NEW-TAIL) Õ (setf (cdr LIST) NEW-TAIL)

Examples:
.........

 (rest '(1 2)) ý (2)
 (rest '(1 . 2)) ý 2
 (rest '(1)) ý NIL
 (setq *cons* '(1 . 2)) ý (1 . 2)
 (setf (rest *cons*) "two") ý "two"
 *cons* ý (1 . "two")

See Also:
.........

*Note cdr::, *Note nthcdr::

Notes:
......

ÿrestþ is often preferred stylistically over ÿcdrþ when the argument is
to being subjectively viewed as a list rather than as a cons.


File: chris-ansicl.info,  Node: member; member-if; member-if-not,  Next: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Prev: rest,  Up: Conses

member, member-if, member-if-not (Function)
===========================================

Syntax:
.......

 -- Function: member item list &key key test test-not ý tail

 -- Function: member-if predicate list &key key ý tail

 -- Function: member-if-not predicate list &key key ý tail

Arguments and Values:
.....................

ITEM--an object.

LIST--a proper list.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

TAIL--a list.

Description:
............

ÿmemberþ, ÿmember-ifþ, and ÿmember-if-notþ each search LIST for ITEM or
for a top-level element that satisfies the test.  The argument to the
PREDICATE function is an element of LIST.

If some element satisfies the test, the tail of LIST beginning with
this element is returned; otherwise ÿnilþ is returned.

LIST is searched on the top level only.

Examples:
.........

 (member 2 '(1 2 3)) ý (2 3)
 (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) ý ((3 . 4))
 (member 'e '(a b c d)) ý NIL

 (member-if #'listp '(a b nil c d)) ý (NIL C D)
 (member-if #'numberp '(a #\Space 5/3 foo)) ý (5/3 FOO)
 (member-if-not #'zerop
                 '(3 6 9 11 . 12)
                 :key #'(lambda (x) (mod x 3))) ý (11 . 12)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST is
not a proper list.

See Also:
.........

*Note find::, *Note position::, *Note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ÿmember-if-notþ is deprecated.

In the following

 (member 'a '(g (a y) c a d e a f)) ý (A D E A F)

the value returned by ÿmemberþ is identical to the portion of the list
beginning with ÿaþ.  Thus ÿrplacaþ on the result of ÿmemberþ can be
used to alter the part of the list where ÿaþ was found (assuming a
check has been made that ÿmemberþ did not return ÿnilþ).


File: chris-ansicl.info,  Node: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Next: acons,  Prev: member; member-if; member-if-not,  Up: Conses

mapc, mapcar, mapcan, mapl, maplist, mapcon (Function)
======================================================

Syntax:
.......

 -- Function: mapc function &rest lists+ ý list-1

 -- Function: mapcar function &rest lists+ ý result-list

 -- Function: mapcan function &rest lists+ ý concatenated-results

 -- Function: mapl function &rest lists+ ý list-1

 -- Function: maplist function &rest lists+ ý result-list

 -- Function: mapcon function &rest lists+ ý concatenated-results

Arguments and Values:
.....................

FUNCTION--a designator for a function that must take as many arguments
as there are LISTS.

LIST--a proper list.

LIST-1--the first LIST (which must be a proper list).

RESULT-LIST--a list.

CONCATENATED-RESULTS--a list.

Description:
............

The mapping operation involves applying FUNCTION to successive sets of
arguments in which one argument is obtained from each sequence.  Except
for ÿmapcþ and ÿmaplþ, the result contains the results returned by
FUNCTION.  In the cases of ÿmapcþ and ÿmaplþ, the resulting sequence is
LIST.

FUNCTION is called first on all the elements with index ÿ0þ, then on
all those with index ÿ1þ, and so on.  RESULT-TYPE specifies the type of
the resulting sequence.  If FUNCTION is a symbol, it is ÿcoerceþd to a
function as if by ÿsymbol-functionþ.

ÿmapcarþ operates on successive elements of the LISTS.  FUNCTION is
applied to the first element of each LIST, then to the second element
of each LIST, and so on.  The iteration terminates when the shortest
LIST runs out, and excess elements in other lists are ignored.  The
value returned by ÿmapcarþ is a list of the results of successive calls
to FUNCTION.

ÿmapcþ is like ÿmapcarþ except that the results of applying FUNCTION
are not accumulated.  The LIST argument is returned.

ÿmaplistþ is like ÿmapcarþ except that FUNCTION is applied to
successive sublists of the LISTS.  FUNCTION is first applied to the
LISTS themselves, and then to the cdr of each LIST, and then to the cdr
of the cdr of each LIST, and so on.

ÿmaplþ is like ÿmaplistþ except that the results of applying FUNCTION
are not accumulated; LIST-1 is returned.

ÿmapcanþ and ÿmapconþ are like ÿmapcarþ and ÿmaplistþ respectively,
except that the results of applying FUNCTION are combined into a list
by the use of ÿnconcþ rather than ÿlistþ.  That is,

 (mapcon f x1 ... xn)
   Õ (apply #'nconc (maplist f x1 ... xn))

and similarly for the relationship between ÿmapcanþ and ÿmapcarþ.

Examples:
.........

 (mapcar #'car '((1 a) (2 b) (3 c))) ý (1 2 3)
 (mapcar #'abs '(3 -4 2 -5 -6)) ý (3 4 2 5 6)
 (mapcar #'cons '(a b c) '(1 2 3)) ý ((A . 1) (B . 2) (C . 3))

 (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3))
ý ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3))
 (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
ý ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
 (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))
ý (0 0 1 0 1 1 1)
;An entry is 1 if the corresponding element of the input
;  list was the last instance of that element in the input list.

 (setq dummy nil) ý NIL
 (mapc #'(lambda (&rest x) (setq dummy (append dummy x)))
        '(1 2 3 4)
        '(a b c d e)
        '(x y z)) ý (1 2 3 4)
 dummy ý (1 A X 2 B Y 3 C Z)

 (setq dummy nil) ý NIL
 (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) ý (1 2 3 4)
 dummy ý ((4) (3 4) (2 3 4) (1 2 3 4))

 (mapcan #'(lambda (x y) (if (null x) nil (list x y)))
          '(nil nil nil d e)
          '(1 2 3 4 5 6)) ý (D 4 E 5)
 (mapcan #'(lambda (x) (and (numberp x) (list x)))
          '(a 1 b c 3 4 d 5))
ý (1 3 4 5)

In this case the function serves as a filter; this is a standard
Lisp idiom using ÿmapcanþ.

 (mapcon #'list '(1 2 3 4)) ý ((1 2 3 4) (2 3 4) (3 4) (4))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if any LIST
is not a proper list.

See Also:
.........

*Note dolist::, *Note map::, *Note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.


File: chris-ansicl.info,  Node: acons,  Next: assoc; assoc-if; assoc-if-not,  Prev: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Up: Conses

acons (Function)
================

Syntax:
.......

 -- Function: acons key datum alist ý new-alist

Arguments and Values:
.....................

KEY--an object.

DATUM--an object.

ALIST--an association list.

NEW-ALIST--an association list.

Description:
............

Creates a fresh cons, the cdr of which is ALIST and the car of which is
another fresh cons, the car of which is KEY and the cdr of which is
DATUM.

Examples:
.........

 (setq alist '()) ý NIL
 (acons 1 "one" alist) ý ((1 . "one"))
 alist ý NIL
 (setq alist (acons 1 "one" (acons 2 "two" alist))) ý ((1 . "one") (2 . "two"))
 (assoc 1 alist) ý (1 . "one")
 (setq alist (acons 1 "uno" alist)) ý ((1 . "uno") (1 . "one") (2 . "two"))
 (assoc 1 alist) ý (1 . "uno")

See Also:
.........

*Note assoc::, *Note pairlis::

Notes:
......

(acons KEY DATUM ALIST) Õ (cons (cons KEY DATUM) ALIST)


File: chris-ansicl.info,  Node: assoc; assoc-if; assoc-if-not,  Next: copy-alist,  Prev: acons,  Up: Conses

assoc, assoc-if, assoc-if-not (Function)
========================================

Syntax:
.......

 -- Function: assoc item alist &key key test test-not ý entry

 -- Function: assoc-if predicate alist &key key ý entry

 -- Function: assoc-if-not predicate alist &key key ý entry

Arguments and Values:
.....................

ITEM--an object.

ALIST--an association list.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

ENTRY--a cons that is an element of ALIST, or ÿnilþ.

Description:
............

ÿassocþ, ÿassoc-ifþ, and ÿassoc-if-notþ return the first cons in ALIST
whose car satisfies the test, or ÿnilþ if no such cons is found.

For ÿassocþ, ÿassoc-ifþ, and ÿassoc-if-notþ, if ÿnilþ appears in ALIST
in place of a pair, it is ignored.

Examples:
.........

 (setq values '((x . 100) (y . 200) (z . 50))) ý ((X . 100) (Y . 200) (Z . 50))
 (assoc 'y values) ý (Y . 200)
 (rplacd (assoc 'y values) 201) ý (Y . 201)
 (assoc 'y values) ý (Y . 201)
 (setq alist '((1 . "one")(2 . "two")(3 . "three")))
ý ((1 . "one") (2 . "two") (3 . "three"))
 (assoc 2 alist) ý (2 . "two")
 (assoc-if #'evenp alist) ý (2 . "two")
 (assoc-if-not #'(lambda(x) (< x 3)) alist) ý (3 . "three")
 (setq alist '(("one" . 1)("two" . 2))) ý (("one" . 1) ("two" . 2))
 (assoc "one" alist) ý NIL
 (assoc "one" alist :test #'equalp) ý ("one" . 1)
 (assoc "two" alist :key #'(lambda(x) (char x 2))) ý NIL
 (assoc #\o alist :key #'(lambda(x) (char x 2))) ý ("two" . 2)
 (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) ý  (R . X)
 (assoc 'goo '((foo . bar) (zoo . goo))) ý NIL
 (assoc '2 '((1 a b c) (2 b c d) (-7 x y z))) ý (2 B C D)
 (setq alist '(("one" . 1) ("2" . 2) ("three" . 3)))
ý (("one" . 1) ("2" . 2) ("three" . 3))
 (assoc-if-not #'alpha-char-p alist
               :key #'(lambda (x) (char x 0))) ý ("2" . 2)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if ALIST is
not an association list.

See Also:
.........

*Note rassoc::, *Note find::, *Note member::, *Note position::, *Note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ÿassoc-if-notþ is deprecated.

It is possible to ÿrplacdþ the result of ÿassocþ, provided that it is
not ÿnilþ, in order to "update" ALIST.

The two expressions

 (assoc item list :test fn)

and

 (find item list :test fn :key #'car)

are equivalent in meaning with one exception: if ÿnilþ appears in ALIST
in place of a pair, and ITEM is ÿnilþ, ÿfindþ will compute the car of
the ÿnilþ in ALIST, find that it is equal to ITEM, and return ÿnilþ,
whereas ÿassocþ will ignore the ÿnilþ in ALIST and continue to search
for an actual cons whose car is ÿnilþ.


File: chris-ansicl.info,  Node: copy-alist,  Next: pairlis,  Prev: assoc; assoc-if; assoc-if-not,  Up: Conses

copy-alist (Function)
=====================

Syntax:
.......

 -- Function: copy-alist alist ý new-alist

Arguments and Values:
.....................

ALIST--an association list.

NEW-ALIST--an association list.

Description:
............

ÿcopy-alistþ returns a copy of ALIST.

The list structure of ALIST is copied, and the elements of ALIST which
are conses are also copied (as conses only).  Any other objects which
are referred to, whether directly or indirectly, by the ALIST continue
to be shared.

Examples:
.........

(defparameter *alist* (acons 1 "one" (acons 2 "two" '())))
*alist* ý ((1 . "one") (2 . "two"))
(defparameter *list-copy* (copy-list *alist*))
*list-copy* ý ((1 . "one") (2 . "two"))
(defparameter *alist-copy* (copy-alist *alist*))
*alist-copy* ý ((1 . "one") (2 . "two"))
(setf (cdr (assoc 2 *alist-copy*)) "deux") ý "deux"
*alist-copy* ý ((1 . "one") (2 . "deux"))
*alist* ý ((1 . "one") (2 . "two"))
(setf (cdr (assoc 1 *list-copy*)) "uno") ý "uno"
*list-copy* ý ((1 . "uno") (2 . "two"))
*alist* ý ((1 . "uno") (2 . "two"))

See Also:
.........

*Note copy-list::


File: chris-ansicl.info,  Node: pairlis,  Next: rassoc; rassoc-if; rassoc-if-not,  Prev: copy-alist,  Up: Conses

pairlis (Function)
==================

Syntax:
.......

 -- Function: pairlis keys data &optional alist ý new-alist

Arguments and Values:
.....................

KEYS--a proper list.

DATA--a proper list.

ALIST--an association list.  The default is the empty list.

NEW-ALIST--an association list.

Description:
............

Returns an association list that associates elements of KEYS to
corresponding elements of DATA.  The consequences are undefined if KEYS
and DATA are not of the same length.

If ALIST is supplied, ÿpairlisþ returns a modified ALIST with the new
pairs prepended to it.  The new pairs may appear in the resulting
association list in either forward or backward order.  The result of

 (pairlis '(one two) '(1 2) '((three . 3) (four . 19)))

might be

 ((one . 1) (two . 2) (three . 3) (four . 19))

or

 ((two . 2) (one . 1) (three . 3) (four . 19))

Examples:
.........

 (setq keys '(1 2 3)
        data '("one" "two" "three")
        alist '((4 . "four"))) ý ((4 . "four"))
 (pairlis keys data) ý ((3 . "three") (2 . "two") (1 . "one"))
 (pairlis keys data alist)
ý ((3 . "three") (2 . "two") (1 . "one") (4 . "four"))
 alist ý ((4 . "four"))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if KEYS AND
DATA are not proper lists.

See Also:
.........

*Note acons::


File: chris-ansicl.info,  Node: rassoc; rassoc-if; rassoc-if-not,  Next: get-properties,  Prev: pairlis,  Up: Conses

rassoc, rassoc-if, rassoc-if-not (Function)
===========================================

Syntax:
.......

 -- Function: rassoc item alist &key key test test-not ý entry

 -- Function: rassoc-if predicate alist &key key ý entry

 -- Function: rassoc-if-not predicate alist &key key ý entry

Arguments and Values:
.....................

ITEM--an object.

ALIST--an association list.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

ENTRY--a cons that is an element of the ALIST, or ÿnilþ.

Description:
............

ÿrassocþ, ÿrassoc-ifþ, and ÿrassoc-if-notþ return the first cons whose
cdr satisfies the test.  If no such cons is found, ÿnilþ is returned.

If ÿnilþ appears in ALIST in place of a pair, it is  ignored.

Examples:
.........

 (setq alist '((1 . "one") (2 . "two") (3 . 3)))
ý ((1 . "one") (2 . "two") (3 . 3))
 (rassoc 3 alist) ý (3 . 3)
 (rassoc "two" alist) ý NIL
 (rassoc "two" alist :test 'equal) ý (2 . "two")
 (rassoc 1 alist :key #'(lambda (x) (if (numberp x) (/ x 3)))) ý (3 . 3)
 (rassoc 'a '((a . b) (b . c) (c . a) (z . a))) ý (C . A)
 (rassoc-if #'stringp alist) ý (1 . "one")
 (rassoc-if-not #'vectorp alist) ý (3 . 3)

See Also:
.........

*Note assoc::, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ÿrassoc-if-notþ is deprecated.

It is possible to ÿrplacaþ the result of ÿrassocþ, provided that it is
not ÿnilþ, in order to "update" ALIST.

The expressions

 (rassoc item list :test fn)

and

 (find item list :test fn :key #'cdr)

are equivalent in meaning, except when the ÿitemþ is ÿnilþ and
ÿnilþ appears in place of a pair in the ALIST.  See the function *Note
assoc::.


File: chris-ansicl.info,  Node: get-properties,  Next: getf,  Prev: rassoc; rassoc-if; rassoc-if-not,  Up: Conses

get-properties (Function)
=========================

Syntax:
.......

 -- Function: get-properties plist indicator-list ý indicator, value,
          tail

Arguments and Values:
.....................

PLIST--a property list.

INDICATOR-LIST--a proper list (of indicators).

INDICATOR--an object that is an element of INDICATOR-LIST.

VALUE--an object.

TAIL--a list.

Description:
............

ÿget-propertiesþ is used to look up any of several property list
entries all at once.

It searches the PLIST for the first entry whose indicator is identical
to one of the objects in INDICATOR-LIST.  If such an entry is found,
the INDICATOR and VALUE returned are the property indicator and its
associated property value, and the TAIL returned is the tail of the
PLIST that begins with the found entry (i.e., whose car is the
INDICATOR).  If no such entry is found, the INDICATOR, VALUE, and TAIL
are all ÿnilþ.

Examples:
.........

 (setq x '()) ý NIL
 (setq *indicator-list* '(prop1 prop2)) ý (PROP1 PROP2)
 (getf x 'prop1) ý NIL
 (setf (getf x 'prop1) 'val1) ý VAL1
 (eq (getf x 'prop1) 'val1) ý true
 (get-properties x *indicator-list*) ý PROP1, VAL1, (PROP1 VAL1)
 x ý (PROP1 VAL1)

See Also:
.........

*Note get::, *Note getf::


File: chris-ansicl.info,  Node: getf,  Next: remf,  Prev: get-properties,  Up: Conses

getf (Accessor)
===============

Syntax:
.......

 -- Function: getf plist indicator &optional default ý value

(setf (getf place indicator &optional default) new-value)

Arguments and Values:
.....................

PLIST--a property list.

PLACE--a place, the value of which is a property list.

INDICATOR--an object.

DEFAULT--an object.  The default is ÿnilþ.

VALUE--an object.

NEW-VALUE--an object.

Description:
............

ÿgetfþ finds a property on the PLIST whose property indicator is
identical to INDICATOR, and returns its corresponding property value.
If there are multiple propertiesá with that property indicator, ÿgetfþ
uses the first such property.  If there is no property with that
property indicator, DEFAULT is returned.

ÿsetfþ of ÿgetfþ may be used to associate a new object with an existing
indicator in the property list held by PLACE, or to create a new
assocation if none exists.  If there are multiple propertiesá with that
property indicator, ÿsetfþ of ÿgetfþ associates the NEW-VALUE with the
first such property.  When a ÿgetfþ form is used as a ÿsetfþ PLACE, any
DEFAULT which is supplied is evaluated according to normal
left-to-right evaluation rules, but its value is ignored.

ÿsetfþ of ÿgetfþ is permitted to either write the value of PLACE itself,
or modify of any part, car or cdr, of the list structure held by PLACE.

Examples:
.........

 (setq x '()) ý NIL
 (getf x 'prop1) ý NIL
 (getf x 'prop1 7) ý 7
 (getf x 'prop1) ý NIL
 (setf (getf x 'prop1) 'val1) ý VAL1
 (eq (getf x 'prop1) 'val1) ý true
 (getf x 'prop1) ý VAL1
 (getf x 'prop1 7) ý VAL1
 x ý (PROP1 VAL1)

;; Examples of implementation variation permitted.
 (setq foo (list 'a 'b 'c 'd 'e 'f)) ý (A B C D E F)
 (setq bar (cddr foo)) ý (C D E F)
 (remf foo 'c) ý true
 foo ý (A B E F)
 bar
ý (C D E F)
orý (C)
orý (NIL)
orý (C NIL)
orý (C D)

See Also:
.........

*Note get::, *Note get-properties::, *Note setf::, *Note Section
5.1.2.2 (Function Call Forms as Places): FnFormsAsGenRefs.

Notes:
......

There is no way (using ÿgetfþ) to distinguish an absent property from
one whose value is DEFAULT; but see ÿget-propertiesþ.

Note that while supplying a default argument to ÿgetfþ in a ÿsetfþ
situation is sometimes not very interesting, it is still important
because some macros, such as ÿpushþ and ÿincfþ, require a PLACE
argument which data is both read from and written to.  In such a
context, if a default argument is to be supplied for the read
situation, it must be syntactically valid for the write situation as
well. For example,

 (let ((plist '()))
   (incf (getf plist 'count 0))
   plist) ý (COUNT 1)


File: chris-ansicl.info,  Node: remf,  Next: intersection; nintersection,  Prev: getf,  Up: Conses

remf (Macro)
============

Syntax:
.......

 -- Macro: remf place indicator ý generalized-boolean

Arguments and Values:
.....................

PLACE--a place.

INDICATOR--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿremfþ removes from the property list stored in PLACE a propertyá with
a property indicator identical to INDICATOR.  If there are multiple
propertiesá with the identical key, ÿremfþ only removes the first such
property.  ÿremfþ returns false if no such property was found, or true
if a property was found.

The property indicator and the corresponding property value are removed
in an undefined order by destructively splicing the property list.
ÿremfþ is permitted to either ÿsetfþ PLACE or to ÿsetfþ any part, ÿcarþ
or ÿcdrþ, of the list structure held by that PLACE.

For information about the evaluation of subforms of PLACE, see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq x (cons () ())) ý (NIL)
 (setf (getf (car x) 'prop1) 'val1) ý VAL1
 (remf (car x) 'prop1) ý true
 (remf (car x) 'prop1) ý false

Side Effects:
.............

The property list stored in PLACE is modified.

See Also:
.........

*Note remprop::, *Note getf::


File: chris-ansicl.info,  Node: intersection; nintersection,  Next: adjoin,  Prev: remf,  Up: Conses

intersection, nintersection (Function)
======================================

Syntax:
.......

 -- Function: intersection list-1 list-2 &key key test test-not ý
          result-list

 -- Function: nintersection list-1 list-2 &key key test test-not ý
          result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-LIST--a list.

Description:
............

ÿintersectionþ and ÿnintersectionþ return a list that contains every
element that occurs in both LIST-1 and LIST-2.

ÿnintersectionþ is the destructive version of ÿintersectionþ.  It
performs the same operation, but may destroy LIST-1 using its cells to
construct the result.  LIST-2 is not destroyed.

The intersection operation is described as follows.  For all possible
ordered pairs consisting of one element from LIST-1 and one element
from LIST-2, :test or :test-not are used to determine whether they
satisfy the test.  The first argument to the :test or :test-not
function is an element of LIST-1; the second argument is an element of
LIST-2.  If :test or :test-not is not supplied, ÿeqlþ is used.  It is
an error if :test and :test-not are supplied in the same function call.

If :key is supplied (and not ÿnilþ), it is used to extract the part to
be tested from the LIST element.  The argument to the :key function is
an element of either LIST-1 or LIST-2; the :key function typically
returns part of the supplied element.  If :key is not supplied or
ÿnilþ, the LIST-1 and LIST-2 elements are used.

For every pair that satifies the test, exactly one of the two elements
of the pair will be put in the result.  No element from either list
appears in the result that does not satisfy the test for an element
from the other list.  If one of the lists contains duplicate elements,
there may be duplication in the result.

There is no guarantee that the order of elements in the result will
reflect the ordering of the arguments in any particular way.  The
result list may share cells with, or be ÿeqþ to, either LIST-1 or LIST-2
if appropriate.

Examples:
.........

 (setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")
       list2 (list 1 4 5 b c d "a" "B" "c" "D"))
  ý (1 4 5 B C D "a" "B" "c" "D")
 (intersection list1 list2) ý (C B 4 1 1)
 (intersection list1 list2 :test 'equal) ý ("B" C B 4 1 1)
 (intersection list1 list2 :test #'equalp) ý ("d" "C" "B" "A" C B 4 1 1)
 (nintersection list1 list2) ý (1 1 4 B C)
 list1 ý implementation-dependent ;e.g., (1 1 4 B C)
 list2 ý implementation-dependent ;e.g., (1 4 5 B C D "a" "B" "c" "D")
 (setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))
ý ((1 . 2) (2 . 3) (3 . 4) (4 . 5))
 (setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))
ý ((1 . 3) (2 . 4) (3 . 6) (4 . 8))
 (nintersection list1 list2 :key #'cdr) ý ((2 . 3) (3 . 4))
 list1 ý implementation-dependent ;e.g., ((1 . 2) (2 . 3) (3 . 4))
 list2 ý implementation-dependent ;e.g., ((1 . 3) (2 . 4) (3 . 6) (4 . 8))

Side Effects:
.............

ÿnintersectionþ can modify LIST-1, but not LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*Note union::, *Note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ÿnintersectionþ side effect is not required, it should not be
used in for-effect-only positions in portable code.


File: chris-ansicl.info,  Node: adjoin,  Next: pushnew,  Prev: intersection; nintersection,  Up: Conses

adjoin (Function)
=================

Syntax:
.......

 -- Function: adjoin item list &key key test test-not ý new-list

Arguments and Values:
.....................

ITEM--an object.

LIST--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

NEW-LIST--a list.

Description:
............

Tests whether ITEM is the same as an existing element of LIST.  If the
ITEM is not an existing element, ÿadjoinþ adds it to LIST (as if by
ÿconsþ) and returns the resulting list; otherwise, nothing is added and
the original LIST is returned.

The TEST, TEST-NOT, and KEY affect how it is determined whether ITEM is
the same as an element of LIST.  For details, *Note Satisfying a
Two-Argument Test: SatisfyingTheTwoArgTest.

Examples:
.........

 (setq slist '()) ý NIL
 (adjoin 'a slist) ý (A)
 slist ý NIL
 (setq slist (adjoin '(test-item 1) slist)) ý ((TEST-ITEM 1))
 (adjoin '(test-item 1) slist) ý ((TEST-ITEM 1) (TEST-ITEM 1))
 (adjoin '(test-item 1) slist :test 'equal) ý ((TEST-ITEM 1))
 (adjoin '(new-test-item 1) slist :key #'cadr) ý ((TEST-ITEM 1))
 (adjoin '(new-test-item 1) slist) ý ((NEW-TEST-ITEM 1) (TEST-ITEM 1))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST is
not a proper list.

See Also:
.........

*Note pushnew::, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

 (adjoin item list :key fn)
   Õ (if (member (fn item) list :key fn) list (cons item list))


File: chris-ansicl.info,  Node: pushnew,  Next: set-difference; nset-difference,  Prev: adjoin,  Up: Conses

pushnew (Macro)
===============

Syntax:
.......

 -- Macro: pushnew item place &key key test test-not ý new-place-value

Arguments and Values:
.....................

ITEM--an object.

PLACE--a place, the value of which is a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

NEW-PLACE-VALUE--a list (the new value of PLACE).

Description:
............

ÿpushnewþ tests whether  ITEM is the same as any existing element of
the list stored in PLACE.  If ITEM is not, it is prepended to the list,
and the new list is stored in PLACE.

ÿpushnewþ returns the new list that is stored in PLACE.

Whether or not ITEM is already a member of the list that is in PLACE is
determined by comparisons using :test or :test-not.  The first argument
to the :test or :test-not function is ITEM; the second argument is an
element of the list in PLACE as returned by the :key function (if
supplied).

If :key is supplied, it is used to extract the part to be tested from
both ITEM and the list element, as for ÿadjoinþ.

The argument to the :key function is an element of the list stored in
PLACE. The :key function typically returns part part of the element of
the list.  If :key is not supplied or ÿnilþ, the list element is used.

For information about the evaluation of subforms of PLACE, see *Note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

It is implementation-dependent whether or not ÿpushnewþ actually
executes the storing form for its PLACE in the situation where the ITEM
is already a member of the list held by PLACE.

Examples:
.........

 (setq x '(a (b c) d)) ý (A (B C) D)
 (pushnew 5 (cadr x)) ý (5 B C)
 x ý (A (5 B C) D)
 (pushnew 'b (cadr x)) ý (5 B C)
 x ý (A (5 B C) D)
 (setq lst '((1) (1 2) (1 2 3))) ý ((1) (1 2) (1 2 3))
 (pushnew '(2) lst) ý ((2) (1) (1 2) (1 2 3))
 (pushnew '(1) lst) ý ((1) (2) (1) (1 2) (1 2 3))
 (pushnew '(1) lst :test 'equal) ý ((1) (2) (1) (1 2) (1 2 3))
 (pushnew '(1) lst :key #'car) ý ((1) (2) (1) (1 2) (1 2 3))

Side Effects:
.............

The contents of PLACE may be modified.

See Also:
.........

*Note push::, *Note adjoin::, *Note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of
 (pushnew item place :test p)

is roughly equivalent to
 (setf place (adjoin item place :test p))

except that the subforms of ÿplaceþ are evaluated only once, and ÿitemþ
is evaluated before ÿplaceþ.


File: chris-ansicl.info,  Node: set-difference; nset-difference,  Next: set-exclusive-or; nset-exclusive-or,  Prev: pushnew,  Up: Conses

set-difference, nset-difference (Function)
==========================================

Syntax:
.......

 -- Function: set-difference list-1 list-2 &key key test test-not ý
          result-list

 -- Function: nset-difference list-1 list-2 &key key test test-not ý
          result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-LIST--a list.

Description:
............

ÿset-differenceþ returns a list of elements of LIST-1 that do not
appear in LIST-2.

ÿnset-differenceþ is the destructive version of ÿset-differenceþ.  It
may destroy LIST-1.

For all possible ordered pairs consisting of one element from LIST-1
and one element from LIST-2, the :test or :test-not function is used to
determine whether they satisfy the test.  The first argument to the
:test or :test-not function is the part of an element of LIST-1 that is
returned by the :key function (if supplied); the second argument is the
part of an element of LIST-2 that is returned by the :key function (if
supplied).

If :key is supplied, its argument is a LIST-1 or LIST-2 element. The
:key function typically returns part of the supplied element.  If :key
is not supplied, the LIST-1 or LIST-2 element is used.

An element of LIST-1 appears in the result if and only if it does not
match any element of LIST-2.

There is no guarantee that the order of elements in the result will
reflect the ordering of the arguments in any particular way.  The
result list may share cells with, or be ÿeqþ to, either of LIST-1 or
LIST-2, if appropriate.

Examples:
.........

 (setq lst1 (list "A" "b" "C" "d")
       lst2 (list "a" "B" "C" "d")) ý ("a" "B" "C" "d")
 (set-difference lst1 lst2) ý ("d" "C" "b" "A")
 (set-difference lst1 lst2 :test 'equal) ý ("b" "A")
 (set-difference lst1 lst2 :test #'equalp) ý NIL
 (nset-difference lst1 lst2 :test #'string=) ý ("A" "b")
 (setq lst1 '(("a" . "b") ("c" . "d") ("e" . "f")))
ý (("a" . "b") ("c" . "d") ("e" . "f"))
 (setq lst2 '(("c" . "a") ("e" . "b") ("d" . "a")))
ý (("c" . "a") ("e" . "b") ("d" . "a"))
 (nset-difference lst1 lst2 :test #'string= :key #'cdr)
ý (("c" . "d") ("e" . "f"))
 lst1 ý (("a" . "b") ("c" . "d") ("e" . "f"))
 lst2 ý (("c" . "a") ("e" . "b") ("d" . "a"))

;; Remove all flavor names that contain "c" or "w".
 (set-difference '("strawberry" "chocolate" "banana"
                  "lemon" "pistachio" "rhubarb")
          '(#\c #\w)
          :test #'(lambda (s c) (find c s)))
ý ("banana" "rhubarb" "lemon")    ;One possible ordering.

Side Effects:
.............

ÿnset-differenceþ may destroy LIST-1.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *Note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: chris-ansicl.info,  Node: set-exclusive-or; nset-exclusive-or,  Next: subsetp,  Prev: set-difference; nset-difference,  Up: Conses

set-exclusive-or, nset-exclusive-or (Function)
==============================================

Syntax:
.......

 -- Function: set-exclusive-or list-1 list-2 &key key test test-not ý
          result-list

 -- Function: nset-exclusive-or list-1 list-2 &key key test test-not ý
          result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-LIST--a list.

Description:
............

ÿset-exclusive-orþ returns a list of elements that appear in exactly
one of LIST-1 and LIST-2.

ÿnset-exclusive-orþ is the destructive version of ÿset-exclusive-orþ.

For all possible ordered pairs consisting of one element from LIST-1
and one element from LIST-2, the :test or :test-not function is used to
determine whether they satisfy the test.

If :key is supplied, it is used to extract the part to be tested from
the LIST-1 or LIST-2 element.  The first argument to the :test or
:test-not function is the part of an element of LIST-1 extracted by the
:key function (if supplied); the second argument  is the part of an
element of LIST-2 extracted by the :key function (if supplied).  If
:key is not supplied or ÿnilþ, the LIST-1 or LIST-2 element is used.

The result contains precisely those elements of LIST-1 and LIST-2 that
appear in no matching pair.

The result list of ÿset-exclusive-orþ might share storage with one of
LIST-1 or LIST-2.

Examples:
.........

 (setq lst1 (list 1 "a" "b")
       lst2 (list 1 "A" "b")) ý (1 "A" "b")
 (set-exclusive-or lst1 lst2) ý ("b" "A" "b" "a")
 (set-exclusive-or lst1 lst2 :test #'equal) ý ("A" "a")
 (set-exclusive-or lst1 lst2 :test 'equalp) ý NIL
 (nset-exclusive-or lst1 lst2) ý ("a" "b" "A" "b")
 (setq lst1 (list (("a" . "b") ("c" . "d") ("e" . "f"))))
ý (("a" . "b") ("c" . "d") ("e" . "f"))
 (setq lst2 (list (("c" . "a") ("e" . "b") ("d" . "a"))))
ý (("c" . "a") ("e" . "b") ("d" . "a"))
 (nset-exclusive-or lst1 lst2 :test #'string= :key #'cdr)
ý (("c" . "d") ("e" . "f") ("c" . "a") ("d" . "a"))
 lst1 ý (("a" . "b") ("c" . "d") ("e" . "f"))
 lst2 ý (("c" . "a") ("d" . "a"))

Side Effects:
.............

ÿnset-exclusive-orþ is permitted to modify any part, car or cdr, of the
list structure of LIST-1 or LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *Note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ÿnset-exclusive-orþ side effect is not required, it should
not be used in for-effect-only positions in portable code.


File: chris-ansicl.info,  Node: subsetp,  Next: union; nunion,  Prev: set-exclusive-or; nset-exclusive-or,  Up: Conses

subsetp (Function)
==================

Syntax:
.......

 -- Function: subsetp list-1 list-2 &key key test test-not ý
          generalized-boolean

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿsubsetpþ returns true if every element of LIST-1 matches some element
of LIST-2, and false otherwise.

Whether a list element is the same as another list element is
determined by the functions specified by the keyword arguments.  The
first argument to the :test or :test-not function is typically part of
an element of LIST-1 extracted by the :key function; the second
argument is  typically part of an element of LIST-2 extracted by the
:key function.

The argument to the :key function is an element of either LIST-1 or
LIST-2; the return value is part of the element of the supplied list
element.  If :key is not supplied or ÿnilþ, the LIST-1 or LIST-2
element itself is supplied to the :test or :test-not function.

Examples:
.........

 (setq cosmos '(1 "a" (1 2))) ý (1 "a" (1 2))
 (subsetp '(1) cosmos) ý true
 (subsetp '((1 2)) cosmos) ý false
 (subsetp '((1 2)) cosmos :test 'equal) ý true
 (subsetp '(1 "A") cosmos :test #'equalp) ý true
 (subsetp '((1) (2)) '((1) (2))) ý false
 (subsetp '((1) (2)) '((1) (2)) :key #'car) ý true

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*Note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: chris-ansicl.info,  Node: union; nunion,  Prev: subsetp,  Up: Conses

union, nunion (Function)
========================

Syntax:
.......

 -- Function: union list-1 list-2 &key key test test-not ý result-list

 -- Function: nunion list-1 list-2 &key key test test-not ý result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-LIST--a list.

Description:
............

ÿunionþ and ÿnunionþ return a list that contains every element that
occurs in either LIST-1 or LIST-2.

For all possible ordered pairs consisting of one element from LIST-1
and one element from LIST-2, :test or  :test-not is used to determine
whether they satisfy the test.  The first argument to the :test or
:test-not function is the part of the element of LIST-1 extracted by the
:key function (if supplied); the second argument is the part of the
element of LIST-2 extracted by the :key function (if supplied).

The argument to the :key function is an element of LIST-1 or LIST-2;
the return value is part of the supplied element.  If :key is not
supplied or ÿnilþ, the element of LIST-1 or LIST-2 itself is supplied
to the :test or :test-not function.

For every matching pair, one of the two elements of the pair will be in
the result.  Any element from either LIST-1 or LIST-2 that matches no
element of the other will appear in the result.

If there is a duplication between LIST-1 and LIST-2, only one of the
duplicate instances will be in the result.  If either LIST-1 or LIST-2
has duplicate entries within it, the redundant entries might or might
not appear in the result.

The order of elements in the result do not have to reflect the ordering
of LIST-1 or LIST-2 in any way.  The result list may be ÿeqþ to either
LIST-1 or LIST-2 if appropriate.

Examples:
.........

 (union '(a b c) '(f a d))
ý (A B C F D)
orý (B C F A D)
orý (D F A B C)
 (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)
ý ((X 5) (Y 6) (Z 2))
orý ((X 4) (Y 6) (Z 2))

 (setq lst1 (list 1 2 '(1 2) "a" "b")
       lst2 (list 2 3 '(2 3) "B" "C"))
ý (2 3 (2 3) "B" "C")
 (nunion lst1 lst2)
ý (1 (1 2) "a" "b" 2 3 (2 3) "B" "C")
orý (1 2 (1 2) "a" "b" "C" "B" (2 3) 3)

Side Effects:
.............

ÿnunionþ is permitted to modify any part, car or cdr, of the list
structure of LIST-1 or LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*Note intersection::, *Note Section 3.2.1 (Compiler Terminology):
Compiler Terminology, *Note Section 3.6 (Traversal Rules and Side
Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ÿnunionþ side effect is not required, it should not be used
in for-effect-only positions in portable code.


File: chris-ansicl.info,  Node: Arrays,  Next: Strings,  Prev: Conses,  Up: Top

15 Arrays
*********

* Menu:

* Array Concepts::

Dictionary

* array::
* simple-array::
* vector (System Class)::
* simple-vector::
* bit-vector::
* simple-bit-vector::
* make-array::
* adjust-array::
* adjustable-array-p::
* aref::
* array-dimension::
* array-dimensions::
* array-element-type::
* array-has-fill-pointer-p::
* array-displacement::
* array-in-bounds-p::
* array-rank::
* array-row-major-index::
* array-total-size::
* arrayp::
* fill-pointer::
* row-major-aref::
* upgraded-array-element-type::
* array-dimension-limit::
* array-rank-limit::
* array-total-size-limit::
* simple-vector-p::
* svref::
* vector (Function)::
* vector-pop::
* vector-push; vector-push-extend::
* vectorp::
* bit; sbit::
* bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+::
* bit-vector-p::
* simple-bit-vector-p::


File: chris-ansicl.info,  Node: Array Concepts,  Next: array,  Up: Arrays

15.1 Array Concepts
===================

* Menu:

* Array Elements::
* Specialized Arrays::


File: chris-ansicl.info,  Node: Array Elements,  Next: Specialized Arrays,  Up: Array Concepts

15.1.1 Array Elements
---------------------

An array contains a set of objects called elements that can be
referenced individually according to a rectilinear coordinate system.

15.1.1.1 Array Indices
......................

An array element is referred to by a (possibly empty) series of indices.
The length of the series must equal the rank of the array.  Each index
must be a non-negative fixnum less than the corresponding array
dimension.  Array indexing is zero-origin.

15.1.1.2 Array Dimensions
.........................

An axis of an array is called a "dimension".

Each dimension is a non-negative fixnum; if any dimension of an array
is zero, the array has no elements.  It is permissible for a dimension
to be zero, in which case the array has no elements, and any attempt to
access an element is an error.  However, other properties of the array,
such as the dimensions themselves, may be used.

15.1.1.2.1 Implementation Limits on Individual Array Dimensions
...............................................................

An implementation may impose a limit on dimensions of an array, but
there is a minimum requirement on that limit.  See the variable *Note
array-dimension-limit::.

15.1.1.3 Array Rank
...................

An array can have any number of dimensions (including zero).  The
number of dimensions is called the "rank".

If the rank of an array is zero then the array is said to have no
dimensions, and the product of the dimensions (see ÿarray-total-sizeþ)
is then 1; a zero-rank array therefore has a single element.

15.1.1.3.1 Vectors
..................

An array of rank one (i.e., a one-dimensional array) is called a "vector".

15.1.1.3.1.1 Fill Pointers
..........................

A "fill pointer" is a non-negative integer no larger than the total
number of elements in a vector.  Not all vectors have fill pointers.
See the functions *Note make-array:: and ÿadjust-arrayþ.

An element of a vector is said to be "active" if it has an index that
is greater than or equal to zero, but less than the fill pointer (if
any).  For an array that has no fill pointer, all elements are
considered active.

Only vectors may have fill pointers; multidimensional arrays may not.
A multidimensional array that is displaced to a vector that has a fill
pointer can be created.

15.1.1.3.2 Multidimensional Arrays
..................................

15.1.1.3.2.1 Storage Layout for Multidimensional Arrays
.......................................................

Multidimensional arrays store their components in row-major order; that
is, internally a multidimensional array is stored as a one-dimensional
array, with the multidimensional index sets ordered lexicographically,
last index varying fastest.

15.1.1.3.2.2 Implementation Limits on Array Rank
................................................

An implementation may impose a limit on the rank of an array, but there
is a minimum requirement on that limit.  See the variable *Note
array-rank-limit::.


File: chris-ansicl.info,  Node: Specialized Arrays,  Prev: Array Elements,  Up: Array Concepts

15.1.2 Specialized Arrays
-------------------------

An array can be a general array, meaning each element may be any object,
or it may be a specialized array, meaning that each element must be of
a restricted type.

The phrasing "an array specialized to type «type»" is sometimes used to
emphasize the element type of an array.  This phrasing is tolerated
even when the «type» is ÿtþ, even though an array specialized to type t
is a general array, not a specialized array.

The next figure lists some defined names that are applicable to array
creation, access, and information operations.

adjust-array            array-has-fill-pointer-p   make-array
adjustable-array-p      array-in-bounds-p          svref
aref                    array-rank                 upgraded-array-element-type
array-dimension         array-rank-limit           upgraded-complex-part-type
array-dimension-limit   array-row-major-index      vector
array-dimensions        array-total-size           vector-pop
array-displacement      array-total-size-limit     vector-push
array-element-type      fill-pointer               vector-push-extend

Figure 15.1: General Purpose Array-Related Defined Names

15.1.2.1 Array Upgrading
........................

The "upgraded array element type" of a type Tá is a type Tà that is a
supertype of Tá and that is used instead of Tá whenever Tá is used as
an array element type for object creation or type discrimination.

During creation of an array, the element type that was requested is
called the "expressed array element type".  The upgraded array element
type of the expressed array element type becomes the "actual array
element type" of the array that is created.

Type upgrading implies a movement upwards in the type hierarchy lattice.
A type is always a subtype of its upgraded array element type.  Also,
if a type T_x is a subtype of another type T_y, then the upgraded array
element type of T_x must be a subtype of the upgraded array element
type of T_y.  Two disjoint types can be upgraded to the same type.

The upgraded array element type Tà of a type Tá is a function only of
Tá itself; that is, it is independent of any other property of the array
for which Tà will be used, such as rank, adjustability, fill pointers,
or displacement.  The function ÿupgraded-array-element-typeþ can be
used by conforming programs to predict how the implementation will
upgrade a given type.

15.1.2.2 Required Kinds of Specialized Arrays
.............................................

Vectors whose elements are restricted to type ÿcharacterþ or a subtype
of ÿcharacterþ are called "strings".  Strings are of type ÿstringþ.
The next figure lists some defined names related to strings.

Strings are specialized arrays and might logically have been included
in this chapter.  However, for purposes of readability most information
about strings does not appear in this chapter; see instead *Note
Chapter 16 (Strings): Strings.

char                 string-equal          string-upcase
make-string          string-greaterp       stringÿ/=þ
nstring-capitalize   string-left-trim      stringÿ<þ
nstring-downcase     string-lessp          stringÿ<=þ
nstring-upcase       string-not-equal      stringÿ=þ
schar                string-not-greaterp   stringÿ>þ
string               string-not-lessp      stringÿ>=þ
string-capitalize    string-right-trim     
string-downcase      string-trim           

Figure 15.2: Operators that Manipulate Strings

Vectors whose elements are restricted to type ÿbitþ are called "bit
vectors".  Bit vectors are of type ÿbit-vectorþ.  The next figure lists
some defined names for operations on bit arrays.

bit         bit-ior    bit-orc2
bit-and     bit-nand   bit-xor
bit-andc1   bit-nor    sbit
bit-andc2   bit-not    
bit-eqv     bit-orc1   

Figure 15.3: Operators that Manipulate Bit Arrays


File: chris-ansicl.info,  Node: array,  Next: simple-array,  Prev: Array Concepts,  Up: Arrays

array (System Class)
====================

Class Precedence List:
......................

ÿarrayþ, ÿtþ

Description:
............

An array contains objects arranged according to a Cartesian coordinate
system.  An array provides mappings from a set of fixnums
{iØ,iá,...,i_{r-1}} to corresponding elements of the array, where 0 ã
i_j < d_j, r is the rank of the array, and d_j is the size of dimension
j of the array.

When an array is created, the program requesting its creation may
declare that all elements are of a particular type, called the
expressed array element type.  The implementation is permitted to
upgrade this type in order to produce the actual array element type,
which is the element type for the array is actually specialized.  See
the function *Note upgraded-array-element-type::.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(array [{element-type | *} [dimension-spec]])

DIMENSION-SPEC::=
     rank | * | ({dimension | *}*)

Compound Type Specifier Arguments:
..................................

DIMENSION--a valid array dimension.

ELEMENT-TYPE--a type specifier.

RANK--a non-negative fixnum.

Compound Type Specifier Description:
....................................

This denotes the set of arrays whose element type,  rank,  and
dimensions match any given ELEMENT-TYPE, RANK, and DIMENSIONS.
Specifically:

If ELEMENT-TYPE is the symbol *, arrays are not excluded on the basis
of their element type.  Otherwise, only those ARRAYS are included whose
actual array element type is the result of upgrading ELEMENT-TYPE; see
*Note Section 15.1.2.1 (Array Upgrading): ArrayUpgrading.

If the DIMENSION-SPEC is a RANK, the set includes only those ARRAYS
having that rank.  If the DIMENSION-SPEC is a list of DIMENSIONS, the
set includes only those ARRAYS having a rank given by the length of the
DIMENSIONS, and having the indicated DIMENSIONS; in this case, *
matches any value for the corresponding dimension.  If the
DIMENSION-SPEC is the symbol *, the set is not restricted on the basis
of rank or dimension.

See Also:
.........

*Note *print-array*::, *Note aref::, *Note make-array::, *Note vector
(System Class)::, *Note Section 2.4.8.12 (Sharpsign A): SharpsignA,
*Note Section 22.1.3.8 (Printing Other Arrays): PrintingOtherArrays.

Notes:
......

Note that the type ÿ(array t)þ is a proper subtype of the type ÿ(array
*)þ.  The reason is that the type ÿ(array t)þ is the set of arrays that
can hold any object (the elements are of type ÿtþ,  which includes all
objects).  On the other hand, the type ÿ(array *)þ is the set of all
arrays whatsoever, including for example arrays that can hold only
characters.  The type ÿ(array character)þ is not a subtype of the type
ÿ(array t)þ; the two sets are disjoint because the type ÿ(array
character)þ is not the set of all arrays that can hold characters, but
rather the set of arrays that are specialized to hold precisely
characters and no other objects.


File: chris-ansicl.info,  Node: simple-array,  Next: vector (System Class),  Prev: array,  Up: Arrays

simple-array (Type)
===================

Supertypes:
...........

ÿsimple-arrayþ, ÿarrayþ, ÿtþ

Description:
............

The type of an array that is not displaced to another array, has no
fill pointer, and is not expressly adjustable is a subtype of type
ÿsimple-arrayþ.  The concept of a simple array exists to allow the
implementation to use a specialized representation and to allow the
user to declare that certain values will always be simple arrays.

The types ÿsimple-vectorþ, ÿsimple-stringþ, and ÿsimple-bit-vectorþ are
disjoint subtypes of type ÿsimple-arrayþ, for they respectively mean
ÿ(simple-array t (*))þ, the union of all ÿ(simple-array c (*))þ for any
c being a subtype of type ÿcharacterþ, and ÿ(simple-array bit (*))þ.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(simple-array [{element-type | *} [dimension-spec]])

DIMENSION-SPEC::=
     rank | * | ({dimension | *}*)

Compound Type Specifier Arguments:
..................................

DIMENSION--a valid array dimension.

ELEMENT-TYPE--a type specifier.

RANK--a non-negative fixnum.

Compound Type Specifier Description:
....................................

This compound type specifier is treated exactly as the corresponding
compound type specifier for type ÿarrayþ would be treated, except that
the set is further constrained to include only simple arrays.

Notes:
......

It is implementation-dependent whether displaced arrays, vectors with
fill pointers, or arrays that are actually adjustable are simple arrays.

ÿ(simple-array *)þ refers to all simple arrays regardless of element
type, ÿ(simple-array TYPE-SPECIFIER)þ refers only to those simple arrays
that can result from giving TYPE-SPECIFIER as the :element-type
argument to ÿmake-arrayþ.


File: chris-ansicl.info,  Node: vector (System Class),  Next: simple-vector,  Prev: simple-array,  Up: Arrays

vector (System Class)
=====================

Class Precedence List:
......................

ÿvectorþ, ÿarrayþ, ÿsequenceþ, ÿtþ

Description:
............

Any one-dimensional array is a vector.

The type ÿvectorþ is a subtype of type ÿarrayþ; for all types ÿxþ,
ÿ(vector x)þ is the same as ÿ(array x (*))þ.

The type ÿ(vector t)þ, the type ÿstringþ, and the type ÿbit-vectorþ are
disjoint subtypes of type ÿvectorþ.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(vector [{element-type | *} [{size | *}]])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum.

ELEMENT-TYPE--a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of specialized vectors whose element type and
DIMENSION match the specified values.  Specifically:

If ELEMENT-TYPE is the symbol *, vectors are not excluded on the basis
of their element type.  Otherwise, only those VECTORS are included
whose actual array element type is the result of upgrading ELEMENT-TYPE;
see *Note Section 15.1.2.1 (Array Upgrading): ArrayUpgrading.

If a SIZE is specified, the set includes only those VECTORS whose only
dimension is SIZE.  If the symbol * is specified instead of a SIZE, the
set is not restricted on the basis of dimension.

See Also:
.........

*Note Section 15.1.2.2 (Required Kinds of Specialized Arrays):
RequiredSpecializedArrays, *Note Section 2.4.8.3 (Sharpsign
Left-Parenthesis): SharpsignLeftParen, *Note Section 22.1.3.7 (Printing
Other Vectors): PrintingOtherVectors, *Note Section 2.4.8.12 (Sharpsign
A): SharpsignA.

Notes:
......

The type ÿ(vector E S)þ is equivalent to the type ÿ(array E (S))þ.

The type ÿ(vector bit)þ has the name ÿbit-vectorþ.

The union of all types ÿ(vector C)þ, where C is any subtype of
ÿcharacterþ, has the name ÿstringþ.

ÿ(vector *)þ refers to all vectors regardless of element type, ÿ(vector
TYPE-SPECIFIER)þ refers only to those vectors that can result from
giving TYPE-SPECIFIER as the :element-type argument to ÿmake-arrayþ.


File: chris-ansicl.info,  Node: simple-vector,  Next: bit-vector,  Prev: vector (System Class),  Up: Arrays

simple-vector (Type)
====================

Supertypes:
...........

ÿsimple-vectorþ, ÿvectorþ, ÿsimple-arrayþ, ÿarrayþ, ÿsequenceþ, ÿtþ

Description:
............

The type of a vector that is not displaced to another array, has no
fill pointer, is not expressly adjustable and is able to hold elements
of any type is a subtype of type ÿsimple-vectorþ.

The type ÿsimple-vectorþ is a subtype of type ÿvectorþ, and is a
subtype of type ÿ(vector t)þ.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(simple-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description:
....................................

This is the same as ÿ(simple-array t (SIZE))þ.


File: chris-ansicl.info,  Node: bit-vector,  Next: simple-bit-vector,  Prev: simple-vector,  Up: Arrays

bit-vector (System Class)
=========================

Class Precedence List:
......................

ÿbit-vectorþ, ÿvectorþ, ÿarrayþ, ÿsequenceþ, ÿtþ

Description:
............

A bit vector is a vector the element type of which is bit.

The type ÿbit-vectorþ is a subtype of type ÿvectorþ, for ÿbit-vectorþ
means ÿ(vector bit)þ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(bit-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the same type as the type ÿ(array bit (SIZE))þ; that is,
the set of bit vectors of size SIZE.

See Also:
.........

*Note Section 2.4.8.4 (Sharpsign Asterisk): SharpsignStar, *Note
Section 22.1.3.6 (Printing Bit Vectors): PrintingBitVectors, *Note
Section 15.1.2.2 (Required Kinds of Specialized Arrays):
RequiredSpecializedArrays.


File: chris-ansicl.info,  Node: simple-bit-vector,  Next: make-array,  Prev: bit-vector,  Up: Arrays

simple-bit-vector (Type)
========================

Supertypes:
...........

ÿsimple-bit-vectorþ, ÿbit-vectorþ, ÿvectorþ, ÿsimple-arrayþ, ÿarrayþ,
ÿsequenceþ, ÿtþ

Description:
............

The type of a bit vector that is not displaced to another array, has no
fill pointer, and is not expressly adjustable is a subtype of type
ÿsimple-bit-vectorþ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-bit-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description:
....................................

This denotes the same type as the type ÿ(simple-array bit (SIZE))þ;
that is, the set of simple bit vectors of size SIZE.


File: chris-ansicl.info,  Node: make-array,  Next: adjust-array,  Prev: simple-bit-vector,  Up: Arrays

make-array (Function)
=====================

Syntax:
.......

 -- Function: make-array dimensions &key element-type initial-element
          initial-contents adjustable fill-pointer displaced-to
          displaced-index-offset ý new-array

Arguments and Values:
.....................

DIMENSIONS--a designator for a list of valid array dimensions.

ELEMENT-TYPE--a type specifier.  The default is ÿtþ.

INITIAL-ELEMENT--an object.

INITIAL-CONTENTS--an object.

ADJUSTABLE--a generalized boolean.  The default is ÿnilþ.

FILL-POINTER--a valid fill pointer for the array to be created, or
ÿtþ or ÿnilþ.  The default is ÿnilþ.

DISPLACED-TO--an array or ÿnilþ.  The default is ÿnilþ.  This option
must not be supplied if either INITIAL-ELEMENT or INITIAL-CONTENTS is
supplied.

DISPLACED-INDEX-OFFSET--a valid array row-major index for DISPLACED-TO.
The default is ÿ0þ.  This option must not be supplied unless a non-nil
DISPLACED-TO is supplied.

NEW-ARRAY--an array.

Description:
............

Creates and returns an array constructed of the most specialized type
that can accommodate elements of type given by ELEMENT-TYPE.  If
DIMENSIONS is ÿnilþ then a zero-dimensional array is created.

DIMENSIONS represents the dimensionality of the new array.

ELEMENT-TYPE indicates the type of the elements intended to be stored
in the NEW-ARRAY.  The NEW-ARRAY can actually store any objects of the
type which results from upgrading ELEMENT-TYPE; see *Note Section
15.1.2.1 (Array Upgrading): ArrayUpgrading.

If INITIAL-ELEMENT is supplied, it is used to initialize each element
of NEW-ARRAY.  If INITIAL-ELEMENT is supplied, it must be of the type
given by ELEMENT-TYPE.  INITIAL-ELEMENT cannot be supplied if either
the :initial-contents option is supplied or DISPLACED-TO is non-nil.
If INITIAL-ELEMENT is not supplied, the consequences of later reading
an uninitialized element of NEW-ARRAY are undefined unless either
INITIAL-CONTENTS is supplied or DISPLACED-TO is non-nil.

INITIAL-CONTENTS is used to initialize the contents of array.  For
example:

 (make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0))))

INITIAL-CONTENTS is composed of a nested structure of sequences.  The
numbers of levels in the structure must equal the rank of array.  Each
leaf of the nested structure must be of the type given by ELEMENT-TYPE.
If array is zero-dimensional, then INITIAL-CONTENTS specifies the single
element.  Otherwise, INITIAL-CONTENTS must be a sequence whose length
is equal to the first dimension; each element must be a nested
structure for an array whose dimensions are the remaining dimensions,
and so on.  INITIAL-CONTENTS cannot be supplied if either
INITIAL-ELEMENT is supplied or DISPLACED-TO is non-nil.  If
INITIAL-CONTENTS is not supplied, the consequences of later reading an
uninitialized element of NEW-ARRAY are undefined unless either
INITIAL-ELEMENT is supplied or DISPLACED-TO is non-nil.

If ADJUSTABLE is non-nil, the array is expressly adjustable (and so
actually adjustable); otherwise, the array is not expressly adjustable
(and it is implementation-dependent whether the array is actually
adjustable).

If FILL-POINTER is non-nil, the array must be one-dimensional; that is,
the array must be a vector.  If FILL-POINTER is ÿtþ, the length of the
vector is used to initialize the fill pointer.  If FILL-POINTER is an
integer, it becomes the initial fill pointer for the vector.

If DISPLACED-TO is non-nil, ÿmake-arrayþ will create a displaced array
and DISPLACED-TO is the target of that displaced array.  In that case,
the consequences are undefined if the actual array element type of
DISPLACED-TO is not type equivalent to the actual array element type of
the array being created.  If DISPLACED-TO is ÿnilþ, the array is not a
displaced array.

The DISPLACED-INDEX-OFFSET is made to be the index offset of the array.
When an array A is given as the :displaced-to argument to ÿmake-arrayþ
when creating array B, then array B is said to be displaced to array A.
The total number of elements in an array, called the total size of the
array, is calculated as the product of all the dimensions.  It is
required that the total size of A be no smaller than the sum of the
total size of B plus the offset ÿnþ supplied by the
DISPLACED-INDEX-OFFSET.  The effect of displacing is that array B does
not have any elements of its own, but instead maps accesses to itself
into accesses to array A.  The mapping treats both arrays as if they
were one-dimensional by taking the elements in row-major order, and
then maps an access to element ÿkþ of array B to an access to element
ÿkþ+ÿnþ of array A.

If ÿmake-arrayþ is called with ADJUSTABLE, FILL-POINTER, and
DISPLACED-TO each ÿnilþ, then the result is a simple array.  If
ÿmake-arrayþ is called with one or more of ADJUSTABLE, FILL-POINTER, or
DISPLACED-TO being true, whether the resulting array is a simple array
is implementation-dependent.

When an array A is given as the :displaced-to argument to ÿmake-arrayþ
when creating array B, then array B is said to be displaced to array A.
The total number of elements in an array, called the total size of the
array, is calculated as the product of all the dimensions.  The
consequences are unspecified if the total size of A is smaller than the
sum of the total size of B plus the offset ÿnþ supplied by the
DISPLACED-INDEX-OFFSET.  The effect of displacing is that array B does
not have any elements of its own, but instead maps accesses to itself
into accesses to array A.  The mapping treats both arrays as if they
were one-dimensional by taking the elements in row-major order, and
then maps an access to element ÿkþ of array B to an access to element
ÿkþ+ÿnþ of array A.

Examples:
.........


 (make-array 5) ;; Creates a one-dimensional array of five elements.
 (make-array '(3 4) :element-type '(mod 16)) ;; Creates a
                ;;two-dimensional array, 3 by 4, with four-bit elements.
 (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.

 (make-array nil :initial-element nil) ý #0ANIL
 (make-array 4 :initial-element nil) ý #(NIL NIL NIL NIL)
 (make-array '(2 4)
              :element-type '(unsigned-byte 2)
              :initial-contents '((0 1 2 3) (3 2 1 0)))
ý #2A((0 1 2 3) (3 2 1 0))
 (make-array 6
              :element-type 'character
              :initial-element #\a
              :fill-pointer 3) ý "aaa"

The following is an example of making a displaced array.

 (setq a (make-array '(4 3)))
ý #<ARRAY 4x3 simple 32546632>
 (dotimes (i 4)
   (dotimes (j 3)
     (setf (aref a i j) (list i 'x j '= (* i j)))))
ý NIL
 (setq b (make-array 8 :displaced-to a
                       :displaced-index-offset 2))
ý #<ARRAY 8 indirect 32550757>
 (dotimes (i 8)
   (print (list i (aref b i))))
Ö (0 (0 X 2 = 0))
Ö (1 (1 X 0 = 0))
Ö (2 (1 X 1 = 1))
Ö (3 (1 X 2 = 2))
Ö (4 (2 X 0 = 0))
Ö (5 (2 X 1 = 2))
Ö (6 (2 X 2 = 4))
Ö (7 (3 X 0 = 0))
ý NIL

The last example depends on the fact that arrays are, in effect, stored
in row-major order.

 (setq a1 (make-array 50))
ý #<ARRAY 50 simple 32562043>
 (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))
ý #<ARRAY 20 indirect 32563346>
 (length b1) ý 20

 (setq a2 (make-array 50 :fill-pointer 10))
ý #<ARRAY 50 fill-pointer 10 46100216>
 (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))
ý #<ARRAY 20 indirect 46104010>
 (length a2) ý 10
 (length b2) ý 20

 (setq a3 (make-array 50 :fill-pointer 10))
ý #<ARRAY 50 fill-pointer 10 46105663>
 (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10
                         :fill-pointer 5))
ý #<ARRAY 20 indirect, fill-pointer 5 46107432>
 (length a3) ý 10
 (length b3) ý 5

See Also:
.........

*Note adjustable-array-p::, *Note aref::, *Note arrayp::, *Note
array-element-type::, *Note array-rank-limit::, *Note
array-dimension-limit::, *Note fill-pointer::, *Note
upgraded-array-element-type::

Notes:
......

There is no specified way to create an array for which
ÿadjustable-array-pþ definitely returns false.  There is no specified
way to create an array that is not a simple array.


File: chris-ansicl.info,  Node: adjust-array,  Next: adjustable-array-p,  Prev: make-array,  Up: Arrays

adjust-array (Function)
=======================

Syntax:
.......

 -- Function: adjust-array array new-dimensions &key element-type
          initial-element initial-contents fill-pointer displaced-to
          displaced-index-offset ý adjusted-array

Arguments and Values:
.....................

ARRAY--an array.

NEW-DIMENSIONS--a valid array dimension or a list of valid array
dimensions.

ELEMENT-TYPE--a type specifier.

INITIAL-ELEMENT--an object.  INITIAL-ELEMENT must not be supplied if
either INITIAL-CONTENTS or DISPLACED-TO is supplied.

INITIAL-CONTENTS--an object.  If array has rank greater than zero, then
INITIAL-CONTENTS is composed of nested sequences, the depth of which
must equal the rank of ARRAY.  Otherwise, array is zero-dimensional and
INITIAL-CONTENTS supplies the single element.  INITIAL-CONTENTS must
not be supplied if either INITIAL-ELEMENT or DISPLACED-TO is given.

FILL-POINTER--a valid fill pointer for the array to be created, or ÿtþ,
or ÿnilþ.  The default is ÿnilþ.

DISPLACED-TO--an array or ÿnilþ.  INITIAL-ELEMENTS and INITIAL-CONTENTS
must not be supplied if DISPLACED-TO is supplied.

DISPLACED-INDEX-OFFSET--an object of type ÿ(fixnum 0 n)þ where n is
ÿ(array-total-size DISPLACED-TO)þ.  DISPLACED-INDEX-OFFSET may be
supplied only if DISPLACED-TO is supplied.

ADJUSTED-ARRAY--an array.

Description:
............

ÿadjust-arrayþ changes the dimensions or elements of ARRAY.  The result
is an array of the same type and rank as ARRAY, that is either the
modified ARRAY, or a newly created array to which ARRAY can be
displaced, and that has the given NEW-DIMENSIONS.

NEW-DIMENSIONS specify the size of each dimension of ARRAY.

ELEMENT-TYPE specifies the type of the elements of the resulting array.
If ELEMENT-TYPE is supplied, the consequences are unspecified if the
upgraded array element type of ELEMENT-TYPE is not the same as the
actual array element type of ARRAY.

If INITIAL-CONTENTS is supplied, it is treated as for ÿmake-arrayþ.  In
this case none of the original contents of ARRAY appears in the
resulting array.

If FILL-POINTER is an integer, it becomes the fill pointer for the
resulting array.  If FILL-POINTER is the symbol ÿtþ, it indicates that
the size of the resulting array should be used as the fill pointer.  If
FILL-POINTER is ÿnilþ, it indicates that the fill pointer should be
left as it is.

If DISPLACED-TO non-nil, a displaced array is created. The resulting
array shares its contents with the array given by DISPLACED-TO.  The
resulting array cannot contain more elements than the array it is
displaced to.  If DISPLACED-TO is not supplied or ÿnilþ, the resulting
array is not a displaced array.  If array A is created displaced to
array B and subsequently array B is given to ÿadjust-arrayþ, array A
will still be displaced to array B.  Although ARRAY might be a
displaced array, the resulting array is not a displaced array unless
DISPLACED-TO is supplied and not ÿnilþ.  The interaction between
ÿadjust-arrayþ and displaced arrays is as follows given three arrays,
ÿAþ, ÿBþ, and ÿCþ:

ÿAþ is not displaced before or after the call
      (adjust-array A ...)

     The dimensions of ÿAþ are altered, and the contents rearranged as
     appropriate.  Additional elements of ÿAþ are taken from
     INITIAL-ELEMENT.  The use of INITIAL-CONTENTS causes all old
     contents to be discarded.

ÿAþ is not displaced before, but is displaced to  ÿCþ after the call
      (adjust-array A ... :displaced-to C)

     None of the original contents of ÿAþ appears in ÿAþ afterwards;
     ÿAþ now contains the contents of ÿCþ, without any rearrangement of
     ÿCþ.

ÿAþ is displaced to ÿBþ  before the call, and is displaced to ÿCþ after  the call
      (adjust-array A ... :displaced-to B)
      (adjust-array A ... :displaced-to C)

     ÿBþ and ÿCþ might be the same. The contents of ÿBþ do not appear in
     ÿAþ afterward unless such contents also happen to be in ÿCþ  If
     DISPLACED-INDEX-OFFSET is not supplied in the ÿadjust-arrayþ call,
     it defaults to zero; the old offset into ÿBþ is not retained.

ÿAþ is displaced to ÿBþ before the call, but not displaced afterward.
      (adjust-array A ... :displaced-to B)
      (adjust-array A ... :displaced-to nil)

     ÿAþ gets a new "data region," and contents of ÿBþ are copied into
     it as appropriate to maintain the existing old contents;
     additional elements of ÿAþ are taken from INITIAL-ELEMENT if
     supplied.  However, the use of INITIAL-CONTENTS causes all old
     contents to be discarded.

If DISPLACED-INDEX-OFFSET is supplied, it specifies the offset of the
resulting array from the beginning of the array that it is displaced to.
If DISPLACED-INDEX-OFFSET is not supplied, the offset is 0.  The size
of the resulting array plus the offset value cannot exceed the size of
the array that it is displaced to.

If only NEW-DIMENSIONS and an INITIAL-ELEMENT argument are supplied,
those elements of ARRAY that are still in bounds appear in the
resulting array. The elements of the resulting array that are not in
the bounds of array are initialized to INITIAL-ELEMENT; if
INITIAL-ELEMENT is not provided, the consequences of later reading any
such new element of NEW-ARRAY before it has been initialized are
undefined.

If INITIAL-CONTENTS or DISPLACED-TO is supplied, then none of the
original contents of ARRAY appears in the new array.

The consequences are unspecified if ARRAY is adjusted to a size smaller
than its fill pointer without supplying the FILL-POINTER argument so
that its fill-pointer is properly adjusted in the process.

If ÿAþ is displaced to ÿBþ, the consequences are unspecified if ÿBþ is
adjusted in such a way that it no longer has enough elements to satisfy
ÿAþ.

If ÿadjust-arrayþ is applied to an array that is actually adjustable,
the array returned is identical to ARRAY.  If the array returned by
ÿadjust-arrayþ is distinct from ARRAY, then the argument ARRAY is
unchanged.

Note that if an array A is displaced to another array B, and B is
displaced to another array C, and B is altered by ÿadjust-arrayþ, A
must now refer to the adjust contents of B.  This means that an
implementation cannot collapse the chain to make A refer to C directly
and forget that the chain of reference passes through B.  However,
caching techniques are permitted as long as they preserve the semantics
specified here.

Examples:
.........

 (adjustable-array-p
  (setq ada (adjust-array
              (make-array '(2 3)
                          :adjustable t
                          :initial-contents '((a b c) (1 2 3)))
              '(4 6)))) ý T
 (array-dimensions ada) ý (4 6)
 (aref ada 1 1) ý 2
 (setq beta (make-array '(2 3) :adjustable t))
ý #2A((NIL NIL NIL) (NIL NIL NIL))
 (adjust-array beta '(4 6) :displaced-to ada)
ý #2A((A B C NIL NIL NIL)
       (1 2 3 NIL NIL NIL)
       (NIL NIL NIL NIL NIL NIL)
       (NIL NIL NIL NIL NIL NIL))
 (array-dimensions beta) ý (4 6)
 (aref beta 1 1) ý 2

Suppose that the 4-by-4 array in ÿmþ looks like this:

#2A(( alpha     beta      gamma     delta )
    ( epsilon   zeta      eta       theta )
    ( iota      kappa     lambda    mu    )
    ( nu        xi        omicron   pi    ))

Then the result of

 (adjust-array m '(3 5) :initial-element 'baz)

is a 3-by-5 array with contents

#2A(( alpha     beta      gamma     delta     baz )
    ( epsilon   zeta      eta       theta     baz )
    ( iota      kappa     lambda    mu        baz ))

Exceptional Situations:
.......................

An error of type ÿerrorþ is signaled if FILL-POINTER is supplied and
non-nil but ARRAY has no fill pointer.

See Also:
.........

*Note adjustable-array-p::,    *Note make-array::, *Note
array-dimension-limit::, *Note array-total-size-limit::, *Note array::


File: chris-ansicl.info,  Node: adjustable-array-p,  Next: aref,  Prev: adjust-array,  Up: Arrays

adjustable-array-p (Function)
=============================

Syntax:
.......

 -- Function: adjustable-array-p array ý generalized-boolean

Arguments and Values:
.....................

ARRAY--an array.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if and only if ÿadjust-arrayþ could return a value which
is identical to ARRAY when given that array as its first argument.

Examples:
.........

 (adjustable-array-p
   (make-array 5
               :element-type 'character
               :adjustable t
               :fill-pointer 3)) ý true
 (adjustable-array-p (make-array 4)) ý implementation-dependent

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if its argument is not an
array.

See Also:
.........

*Note adjust-array::, *Note make-array::


File: chris-ansicl.info,  Node: aref,  Next: array-dimension,  Prev: adjustable-array-p,  Up: Arrays

aref (Accessor)
===============

Syntax:
.......

 -- Function: aref array &rest subscripts ý element

(setf (aref array &rest subscripts) new-element)

Arguments and Values:
.....................

ARRAY--an array.

SUBSCRIPTS--a list of valid array indices for the ARRAY.

ELEMENT, NEW-ELEMENT--an object.

Description:
............

Accesses the ARRAY element specified by the SUBSCRIPTS.  If no
SUBSCRIPTS are supplied and ARRAY is zero rank, ÿarefþ accesses the
sole element of ARRAY.

ÿarefþ ignores fill pointers.  It is permissible to use ÿarefþ to
access any ARRAY element, whether active or not.

Examples:
.........

If the variable ÿfooþ names a 3-by-5 array, then the first index could
be 0, 1, or 2, and then second index could be 0, 1, 2, 3, or 4.  The
array elements can be referred to by using the function ÿarefþ; for
example, ÿ(aref foo 2 1)þ refers to element (2, 1) of the array.

 (aref (setq alpha (make-array 4)) 3) ý implementation-dependent
 (setf (aref alpha 3) 'sirens) ý SIRENS
 (aref alpha 3) ý SIRENS
 (aref (setq beta (make-array '(2 4)
                    :element-type '(unsigned-byte 2)
                    :initial-contents '((0 1 2 3) (3 2 1 0))))
        1 2) ý 1
 (setq gamma '(0 2))
 (apply #'aref beta gamma) ý 2
 (setf (apply #'aref beta gamma) 3) ý 3
 (apply #'aref beta gamma) ý 3
 (aref beta 0 2) ý 3

See Also:
.........

*Note bit::, *Note char::, *Note elt::, *Note row-major-aref::, *Note
svref::, *Note Section 3.2.1 (Compiler Terminology): Compiler
Terminology.


File: chris-ansicl.info,  Node: array-dimension,  Next: array-dimensions,  Prev: aref,  Up: Arrays

array-dimension (Function)
==========================

Syntax:
.......

 -- Function: array-dimension array axis-number ý dimension

Arguments and Values:
.....................

ARRAY--an array.

AXIS-NUMBER--an integer greater than or equal to zero and less than the
rank of the ARRAY.

DIMENSION--a non-negative integer.

Description:
............

ÿarray-dimensionþ returns the AXIS-NUMBER dimensioná of ARRAY.  (Any
fill pointer is ignored.)

Examples:
.........

 (array-dimension (make-array 4) 0) ý 4
 (array-dimension (make-array '(2 3)) 1) ý 3

Affected By:
............

None.

See Also:
.........

*Note array-dimensions::, *Note length::

Notes:
......

 (array-dimension array n) Õ (nth n (array-dimensions array))


File: chris-ansicl.info,  Node: array-dimensions,  Next: array-element-type,  Prev: array-dimension,  Up: Arrays

array-dimensions (Function)
===========================

Syntax:
.......

 -- Function: array-dimensions array ý dimensions

Arguments and Values:
.....................

ARRAY--an array.

DIMENSIONS--a list of integers.

Description:
............

Returns a list of the dimensions of ARRAY.  (If ARRAY is a vector with
a fill pointer, that fill pointer is ignored.)

Examples:
.........

 (array-dimensions (make-array 4)) ý (4)
 (array-dimensions (make-array '(2 3))) ý (2 3)
 (array-dimensions (make-array 4 :fill-pointer 2)) ý (4)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if its argument is not an
array.

See Also:
.........

*Note array-dimension::


File: chris-ansicl.info,  Node: array-element-type,  Next: array-has-fill-pointer-p,  Prev: array-dimensions,  Up: Arrays

array-element-type (Function)
=============================

Syntax:
.......

 -- Function: array-element-type array ý typespec

Arguments and Values:
.....................

ARRAY--an array.

TYPESPEC--a type specifier.

Description:
............

Returns a type specifier which represents the actual array element type
of the array, which is the set of objects that such an ARRAY can hold.
(Because of array upgrading, this type specifier can in some cases
denote a supertype of the expressed array element type of the ARRAY.)

Examples:
.........

 (array-element-type (make-array 4)) ý T
 (array-element-type (make-array 12 :element-type '(unsigned-byte 8)))
ý implementation-dependent
 (array-element-type (make-array 12 :element-type '(unsigned-byte 5)))
ý implementation-dependent

 (array-element-type (make-array 5 :element-type '(mod 5)))

could be ÿ(mod 5)þ, ÿ(mod 8)þ, ÿfixnumþ, ÿtþ, or any other type of
which ÿ(mod 5)þ is a subtype.

Affected By:
............

The implementation.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if its argument is not an
array.

See Also:
.........

*Note array::, *Note make-array::, *Note subtypep::, *Note
upgraded-array-element-type::


File: chris-ansicl.info,  Node: array-has-fill-pointer-p,  Next: array-displacement,  Prev: array-element-type,  Up: Arrays

array-has-fill-pointer-p (Function)
===================================

Syntax:
.......

 -- Function: array-has-fill-pointer-p array ý generalized-boolean

Arguments and Values:
.....................

ARRAY--an array.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if ARRAY has a fill pointer; otherwise returns false.

Examples:
.........

 (array-has-fill-pointer-p (make-array 4)) ý implementation-dependent
 (array-has-fill-pointer-p (make-array '(2 3))) ý false
 (array-has-fill-pointer-p
   (make-array 8
               :fill-pointer 2
               :initial-element 'filler)) ý true

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if its argument is not an
array.

See Also:
.........

*Note make-array::, *Note fill-pointer::

Notes:
......

Since arrays of rank other than one cannot have a fill pointer,
ÿarray-has-fill-pointer-pþ always returns ÿnilþ when its argument is
such an array.


File: chris-ansicl.info,  Node: array-displacement,  Next: array-in-bounds-p,  Prev: array-has-fill-pointer-p,  Up: Arrays

array-displacement (Function)
=============================

Syntax:
.......

 -- Function: array-displacement array ý displaced-to,
          displaced-index-offset

Arguments and Values:
.....................

ARRAY--an array.

DISPLACED-TO--an ARRAY or ÿnilþ.

DISPLACED-INDEX-OFFSET--a non-negative fixnum.

Description:
............

If the ARRAY is a displaced array, returns the values of the
:displaced-to and :displaced-index-offset options for the array (see
the functions *Note make-array:: and ÿadjust-arrayþ).  If the ARRAY is
not a displaced array, ÿnilþ and ÿ0þ are returned.

If ÿarray-displacementþ is called on an ARRAY for which a non-nil
object was provided as the :displaced-to argument to ÿmake-arrayþ or
ÿadjust-arrayþ, it must return that object as its first value. It is
implementation-dependent whether ÿarray-displacementþ returns a non-nil
primary value for any other ARRAY.

Examples:
.........

 (setq a1 (make-array 5)) ý #<ARRAY 5 simple 46115576>
 (setq a2 (make-array 4 :displaced-to a1
                        :displaced-index-offset 1))
ý #<ARRAY 4 indirect 46117134>
 (array-displacement a2)
ý #<ARRAY 5 simple 46115576>, 1
 (setq a3 (make-array 2 :displaced-to a2
                        :displaced-index-offset 2))
ý #<ARRAY 2 indirect 46122527>
 (array-displacement a3)
ý #<ARRAY 4 indirect 46117134>, 2

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if ARRAY is not an array.

See Also:
.........

*Note make-array::


File: chris-ansicl.info,  Node: array-in-bounds-p,  Next: array-rank,  Prev: array-displacement,  Up: Arrays

array-in-bounds-p (Function)
============================

Syntax:
.......

 -- Function: array-in-bounds-p array &rest subscripts ý
          generalized-boolean

Arguments and Values:
.....................

ARRAY--an array.

SUBSCRIPTS--a list of integers of length equal to the rank of the array.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if the SUBSCRIPTS are all in bounds for ARRAY; otherwise
returns false.  (If ARRAY is a vector with a fill pointer, that fill
pointer is ignored.)

Examples:
.........

 (setq a (make-array '(7 11) :element-type 'string-char))
 (array-in-bounds-p a 0  0) ý true
 (array-in-bounds-p a 6 10) ý true
 (array-in-bounds-p a 0 -1) ý false
 (array-in-bounds-p a 0 11) ý false
 (array-in-bounds-p a 7  0) ý false

See Also:
.........

*Note array-dimensions::

Notes:
......

 (array-in-bounds-p array subscripts)
 Õ (and (not (some #'minusp (list subscripts)))
         (every #'< (list subscripts) (array-dimensions array)))


File: chris-ansicl.info,  Node: array-rank,  Next: array-row-major-index,  Prev: array-in-bounds-p,  Up: Arrays

array-rank (Function)
=====================

Syntax:
.......

 -- Function: array-rank array ý rank

Arguments and Values:
.....................

ARRAY--an array.

RANK--a non-negative integer.

Description:
............

Returns the number of dimensions of ARRAY.

Examples:
.........

 (array-rank (make-array '())) ý 0
 (array-rank (make-array 4)) ý 1
 (array-rank (make-array '(4))) ý 1
 (array-rank (make-array '(2 3))) ý 2

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if its argument is not an
array.

See Also:
.........

*Note array-rank-limit::, *Note make-array::


File: chris-ansicl.info,  Node: array-row-major-index,  Next: array-total-size,  Prev: array-rank,  Up: Arrays

array-row-major-index (Function)
================================

Syntax:
.......

 -- Function: array-row-major-index array &rest subscripts ý index

Arguments and Values:
.....................

ARRAY--an array.

SUBSCRIPTS--a list of valid array indices for the ARRAY.

INDEX--a valid array row-major index for the ARRAY.

Description:
............

Computes the position according to the row-major ordering of ARRAY for
the element that is specified by SUBSCRIPTS, and returns the offset of
the element in the computed position from the beginning of ARRAY.

For a one-dimensional ARRAY, the result of ÿarray-row-major-indexþ
equals SUBSCRIPT.

ÿarray-row-major-indexþ ignores fill pointers.

Examples:
.........

 (setq a (make-array '(4 7) :element-type '(unsigned-byte 8)))
 (array-row-major-index a 1 2) ý 9
 (array-row-major-index
    (make-array '(2 3 4)
                :element-type '(unsigned-byte 8)
                :displaced-to a
                :displaced-index-offset 4)
    0 2 1) ý 9

Notes:
......

A possible definition of ÿarray-row-major-indexþ, with no
error-checking, is

 (defun array-row-major-index (a &rest subscripts)
   (apply #'+ (maplist #'(lambda (x y)
                            (* (car x) (apply #'* (cdr y))))
                       subscripts
                       (array-dimensions a))))


File: chris-ansicl.info,  Node: array-total-size,  Next: arrayp,  Prev: array-row-major-index,  Up: Arrays

array-total-size (Function)
===========================

Syntax:
.......

 -- Function: array-total-size array ý size

Arguments and Values:
.....................

ARRAY--an array.

SIZE--a non-negative integer.

Description:
............

Returns the array total size of the ARRAY.

Examples:
.........

 (array-total-size (make-array 4)) ý 4
 (array-total-size (make-array 4 :fill-pointer 2)) ý 4
 (array-total-size (make-array 0)) ý 0
 (array-total-size (make-array '(4 2))) ý 8
 (array-total-size (make-array '(4 0))) ý 0
 (array-total-size (make-array '())) ý 1

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if its argument is not an
array.

See Also:
.........

*Note make-array::, *Note array-dimensions::

Notes:
......

If the ARRAY is a vector with a fill pointer, the fill pointer is
ignored when calculating the array total size.

Since the product of no arguments is one, the array total size of a
zero-dimensional array is one.

 (array-total-size x)
    Õ (apply #'* (array-dimensions x))
    Õ (reduce #'* (array-dimensions x))


File: chris-ansicl.info,  Node: arrayp,  Next: fill-pointer,  Prev: array-total-size,  Up: Arrays

arrayp (Function)
=================

Syntax:
.......

 -- Function: arrayp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿarrayþ; otherwise, returns false.

Examples:
.........

 (arrayp (make-array '(2 3 4) :adjustable t)) ý true
 (arrayp (make-array 6)) ý true
 (arrayp #*1011) ý true
 (arrayp "hi") ý true
 (arrayp 'hi) ý false
 (arrayp 12) ý false

See Also:
.........

*Note typep::

Notes:
......

 (arrayp OBJECT) Õ (typep OBJECT 'array)


File: chris-ansicl.info,  Node: fill-pointer,  Next: row-major-aref,  Prev: arrayp,  Up: Arrays

fill-pointer (Accessor)
=======================

Syntax:
.......

 -- Function: fill-pointer vector ý fill-pointer

(setf (fill-pointer vector) new-fill-pointer)

Arguments and Values:
.....................

VECTOR--a vector with a fill pointer.

FILL-POINTER, NEW-FILL-POINTER--a valid fill pointer for the VECTOR.

Description:
............

Accesses the fill pointer of VECTOR.

Examples:
.........

 (setq a (make-array 8 :fill-pointer 4)) ý #(NIL NIL NIL NIL)
 (fill-pointer a) ý 4
 (dotimes (i (length a)) (setf (aref a i) (* i i))) ý NIL
 a ý #(0 1 4 9)
 (setf (fill-pointer a) 3) ý 3
 (fill-pointer a) ý 3
 a ý #(0 1 4)
 (setf (fill-pointer a) 8) ý 8
 a ý #(0 1 4 9 NIL NIL NIL NIL)

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if VECTOR is not a vector
with a fill pointer.

See Also:
.........

*Note make-array::, *Note length::

Notes:
......

There is no operator that will remove a vector's fill pointer.


File: chris-ansicl.info,  Node: row-major-aref,  Next: upgraded-array-element-type,  Prev: fill-pointer,  Up: Arrays

row-major-aref (Accessor)
=========================

Syntax:
.......

 -- Function: row-major-aref array index ý element

(setf (row-major-aref array index) new-element)

Arguments and Values:
.....................

ARRAY--an array.

INDEX--a valid array row-major index for the ARRAY.

ELEMENT, NEW-ELEMENT--an object.

Description:
............

Considers array as a vector by viewing its elements in row-major order,
and returns the element of that vector which is referred to by the
given INDEX.

ÿrow-major-arefþ is valid for use with ÿsetfþ.

See Also:
.........

*Note aref::, *Note array-row-major-index::

Notes:
......

 (row-major-aref array index) Õ
   (aref (make-array (array-total-size array)
                     :displaced-to array
                     :element-type (array-element-type array))
         index)

 (aref array i1 i2 ...) Õ
     (row-major-aref array (array-row-major-index array i1 i2))


File: chris-ansicl.info,  Node: upgraded-array-element-type,  Next: array-dimension-limit,  Prev: row-major-aref,  Up: Arrays

upgraded-array-element-type (Function)
======================================

Syntax:
.......

 -- Function: upgraded-array-element-type typespec &optional
          environment ý upgraded-typespec

Arguments and Values:
.....................

TYPESPEC--a type specifier.

ENVIRONMENT--an environment object.  The default is ÿnilþ, denoting the
null lexical environment and the current global environment.

UPGRADED-TYPESPEC--a type specifier.

Description:
............

Returns the element type of the most specialized array representation
capable of holding items of the type denoted by TYPESPEC.

The TYPESPEC is a subtype of (and possibly type equivalent to) the
UPGRADED-TYPESPEC.

If TYPESPEC is ÿbitþ, the result is type equivalent to ÿbitþ.  If
TYPESPEC is ÿbase-charþ, the result is type equivalent to ÿbase-charþ.
If TYPESPEC is ÿcharacterþ, the result is type equivalent to
ÿcharacterþ.

The purpose of ÿupgraded-array-element-typeþ is to reveal how an
implementation does its upgrading.

The ENVIRONMENT is used to expand any derived type specifiers that are
mentioned in the TYPESPEC.

See Also:
.........

*Note array-element-type::, *Note make-array::

Notes:
......

Except for storage allocation consequences and dealing correctly with
the optional ENVIRONMENT argument, ÿupgraded-array-element-typeþ could
be defined as:

 (defun upgraded-array-element-type (type &optional environment)
   (array-element-type (make-array 0 :element-type type)))


File: chris-ansicl.info,  Node: array-dimension-limit,  Next: array-rank-limit,  Prev: upgraded-array-element-type,  Up: Arrays

array-dimension-limit (Constant Variable)
=========================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ÿ1024þ.

Description:
............

The upper exclusive bound on each individual dimension of an array.

See Also:
.........

*Note make-array::


File: chris-ansicl.info,  Node: array-rank-limit,  Next: array-total-size-limit,  Prev: array-dimension-limit,  Up: Arrays

array-rank-limit (Constant Variable)
====================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ÿ8þ.

Description:
............

The upper exclusive bound on the rank of an array.

See Also:
.........

*Note make-array::


File: chris-ansicl.info,  Node: array-total-size-limit,  Next: simple-vector-p,  Prev: array-rank-limit,  Up: Arrays

array-total-size-limit (Constant Variable)
==========================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ÿ1024þ.

Description:
............

The upper exclusive bound on the array total size of an array.

The actual limit on the array total size imposed by the implementation
might vary according the element type of the array; in this case, the
value of ÿarray-total-size-limitþ will be the smallest of these
possible limits.

See Also:
.........

*Note make-array::, *Note array-element-type::


File: chris-ansicl.info,  Node: simple-vector-p,  Next: svref,  Prev: array-total-size-limit,  Up: Arrays

simple-vector-p (Function)
==========================

Syntax:
.......

 -- Function: simple-vector-p object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿsimple-vectorþ; otherwise, returns
false..

Examples:
.........

 (simple-vector-p (make-array 6)) ý true
 (simple-vector-p "aaaaaa") ý false
 (simple-vector-p (make-array 6 :fill-pointer t)) ý false

See Also:
.........

*Note simple-vector::

Notes:
......

 (simple-vector-p OBJECT) Õ (typep OBJECT 'simple-vector)


File: chris-ansicl.info,  Node: svref,  Next: vector (Function),  Prev: simple-vector-p,  Up: Arrays

svref (Accessor)
================

Syntax:
.......

 -- Function: svref simple-vector index ý element

(setf (svref simple-vector index) new-element)

Arguments and Values:
.....................

SIMPLE-VECTOR--a simple vector.

INDEX--a valid array index for the SIMPLE-VECTOR.

ELEMENT, NEW-ELEMENT--an object (whose type is a subtype of the array
element type of the SIMPLE-VECTOR).

Description:
............

Accesses the element of SIMPLE-VECTOR specified by INDEX.

Examples:
.........

 (simple-vector-p (setq v (vector 1 2 'sirens))) ý true
 (svref v 0) ý 1
 (svref v 2) ý SIRENS
 (setf (svref v 1) 'newcomer) ý NEWCOMER
 v ý #(1 NEWCOMER SIRENS)

See Also:
.........

*Note aref::, *Note sbit::, *Note schar::, *Note vector (Function)::,
*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology.

Notes:
......

ÿsvrefþ is identical to ÿarefþ except that it requires its first
argument to be a simple vector.

 (svref V I) Õ (aref (the simple-vector V) I)


File: chris-ansicl.info,  Node: vector (Function),  Next: vector-pop,  Prev: svref,  Up: Arrays

vector (Function)
=================

Syntax:
.......

 -- Function: vector &rest objects ý vector

Arguments and Values:
.....................

OBJECT--an object.

VECTOR--a vector of type ÿ(vector t ÿ*þ)þ.

Description:
............

Creates a fresh simple general vector whose size corresponds to the
number of OBJECTS.

The vector is initialized to contain the OBJECTS.

Examples:
.........

 (arrayp (setq v (vector 1 2 'sirens))) ý true
 (vectorp v) ý true
 (simple-vector-p v) ý true
 (length v) ý 3

See Also:
.........

*Note make-array::

Notes:
......

ÿvectorþ is analogous to ÿlistþ.

 (vector aá aà ... a_n)
  Õ (make-array (list n) :element-type t
                          :initial-contents
                            (list aá aà ... a_n))


File: chris-ansicl.info,  Node: vector-pop,  Next: vector-push; vector-push-extend,  Prev: vector (Function),  Up: Arrays

vector-pop (Function)
=====================

Syntax:
.......

 -- Function: vector-pop vector ý element

Arguments and Values:
.....................

VECTOR--a vector with a fill pointer.

ELEMENT--an object.

Description:
............

Decreases the fill pointer of VECTOR by one, and retrieves the element
of VECTOR that is designated by the new fill pointer.

Examples:
.........

 (vector-push (setq fable (list 'fable))
              (setq fa (make-array 8
                                   :fill-pointer 2
                                   :initial-element 'sisyphus))) ý 2
 (fill-pointer fa) ý 3
 (eq (vector-pop fa) fable) ý true
 (vector-pop fa) ý SISYPHUS
 (fill-pointer fa) ý 1

Side Effects:
.............

The fill pointer is decreased by one.

Affected By:
............

The value of the fill pointer.

Exceptional Situations:
.......................

An error of type ÿtype-errorþ is signaled if VECTOR does not have a
fill pointer.

If the fill pointer is zero, ÿvector-popþ signals an error of type
ÿerrorþ.

See Also:
.........

*Note vector-push::, *Note vector-push-extend::, *Note fill-pointer::


File: chris-ansicl.info,  Node: vector-push; vector-push-extend,  Next: vectorp,  Prev: vector-pop,  Up: Arrays

vector-push, vector-push-extend (Function)
==========================================

Syntax:
.......

 -- Function: vector-push new-element vector ý new-index-p

 -- Function: vector-push-extend new-element vector &optional extension
          ý new-index

Arguments and Values:
.....................

NEW-ELEMENT--an object.

VECTOR--a vector with a fill pointer.

EXTENSION--a positive integer.  The default is implementation-dependent.

NEW-INDEX-P--a valid array index for VECTOR, or ÿnilþ.

NEW-INDEX--a valid array index for VECTOR.

Description:
............

ÿvector-pushþ and ÿvector-push-extendþ store NEW-ELEMENT in VECTOR.
ÿvector-pushþ attempts to store NEW-ELEMENT in the element of VECTOR
designated by the fill pointer, and to increase the fill pointer by
one.  If the ÿ(>= (fill-pointer VECTOR) (array-dimension VECTOR 0))þ,
neither VECTOR nor its fill pointer are affected.  Otherwise, the store
and increment take place and ÿvector-pushþ returns the former value of
the fill pointer which is one less than the one it leaves in VECTOR.

ÿvector-push-extendþ is just like ÿvector-pushþ except that if the fill
pointer gets too large, VECTOR is extended using ÿadjust-arrayþ so that
it can contain more elements.  EXTENSION is the minimum number of
elements to be added to VECTOR if it must be extended.

ÿvector-pushþ and ÿvector-push-extendþ return the index of NEW-ELEMENT
in VECTOR.  If ÿ(>= (fill-pointer VECTOR) (array-dimension VECTOR 0))þ,
ÿvector-pushþ returns ÿnilþ.

Examples:
.........

 (vector-push (setq fable (list 'fable))
              (setq fa (make-array 8
                                   :fill-pointer 2
                                   :initial-element 'first-one))) ý 2
 (fill-pointer fa) ý 3
 (eq (aref fa 2) fable) ý true
 (vector-push-extend #\X
                    (setq aa
                          (make-array 5
                                      :element-type 'character
                                      :adjustable t
                                      :fill-pointer 3))) ý 3
 (fill-pointer aa) ý 4
 (vector-push-extend #\Y aa 4) ý 4
 (array-total-size aa) ý at least 5
 (vector-push-extend #\Z aa 4) ý 5
 (array-total-size aa) ý 9 ;(or more)

Affected By:
............

The value of the fill pointer.

How VECTOR was created.

Exceptional Situations:
.......................

An error of type ÿerrorþ is signaled by ÿvector-push-extendþ if it
tries to extend VECTOR and VECTOR is not actually adjustable.

An error of type ÿerrorþ is signaled if VECTOR does not have a fill
pointer.

See Also:
.........

*Note adjustable-array-p::, *Note fill-pointer::, *Note vector-pop::


File: chris-ansicl.info,  Node: vectorp,  Next: bit; sbit,  Prev: vector-push; vector-push-extend,  Up: Arrays

vectorp (Function)
==================

Syntax:
.......

 -- Function: vectorp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿvectorþ; otherwise, returns false.

Examples:
.........

 (vectorp "aaaaaa") ý true
 (vectorp (make-array 6 :fill-pointer t)) ý true
 (vectorp (make-array '(2 3 4))) ý false
 (vectorp #*11) ý true
 (vectorp #b11) ý false

Notes:
......

 (vectorp OBJECT) Õ (typep OBJECT 'vector)


File: chris-ansicl.info,  Node: bit; sbit,  Next: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Prev: vectorp,  Up: Arrays

bit, sbit (Accessor)
====================

Syntax:
.......

 -- Function: bit bit-array &rest subscripts ý bit

 -- Function: sbit bit-array &rest subscripts ý bit

Arguments and Values:
.....................

BIT-ARRAY--for ÿbitþ,  a bit array; for ÿsbitþ, a simple bit array.

SUBSCRIPTS--a list of valid array indices for the BIT-ARRAY.

BIT--a bit.

Description:
............

ÿbitþ and ÿsbitþ access the BIT-ARRAY element specified by SUBSCRIPTS.

These functions ignore the fill pointer when accessing elements.

Examples:
.........

 (bit (setq ba (make-array 8
                            :element-type 'bit
                            :initial-element 1))
       3) ý 1
 (setf (bit ba 3) 0) ý 0
 (bit ba 3) ý 0
 (sbit ba 5) ý 1
 (setf (sbit ba 5) 1) ý 1
 (sbit ba 5) ý 1

See Also:
.........

*Note aref::, *Note Section 3.2.1 (Compiler Terminology): Compiler
Terminology.

Notes:
......

ÿbitþ and ÿsbitþ are like ÿarefþ except that they require ARRAYS to be
a bit array and a simple bit array, respectively.

ÿbitþ and ÿsbitþ, unlike ÿcharþ and ÿscharþ, allow the first argument
to be an array of any rank.


File: chris-ansicl.info,  Node: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Next: bit-vector-p,  Prev: bit; sbit,  Up: Arrays

bit-and, bit-andc1, bit-andc2, bit-eqv, bit-ior, bit-nand, bit-nor, bit-not, bit-orc1, bit-orc2, bit-xor (Function)
===================================================================================================================

Syntax:
.......

 -- Function: bit-and bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-andc1 bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-andc2 bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-eqv bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-ior bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-nand bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-nor bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-orc1 bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-orc2 bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-xor bit-array1 bit-array2 &optional opt-arg ý
          resulting-bit-array

 -- Function: bit-not bit-array &optional opt-arg ý resulting-bit-array

Arguments and Values:
.....................

BIT-ARRAY, BIT-ARRAY1, BIT-ARRAY2--a bit array.

OPT-ARG--a bit array, or ÿtþ, or ÿnilþ.  The default is ÿnilþ.

BIT-ARRAY, BIT-ARRAY1, BIT-ARRAY2, and OPT-ARG (if an array) must all
be of the same rank and dimensions.

RESULTING-BIT-ARRAY--a bit array.

Description:
............

These functions perform bit-wise logical operations on BIT-ARRAY1 and
BIT-ARRAY2 and return an array of matching rank and dimensions, such
that any given bit of the result is produced by operating on
corresponding bits from each of the arguments.

In the case of ÿbit-notþ, an array of rank and dimensions matching
BIT-ARRAY is returned that contains a copy of BIT-ARRAY with all the
bits inverted.

If OPT-ARG is of type ÿ(array bit)þ the contents of the result are
destructively placed into OPT-ARG.  If OPT-ARG is the symbol ÿtþ,
BIT-ARRAY or BIT-ARRAY1 is replaced with the result; if OPT-ARG is
ÿnilþ or omitted, a new array is created to contain the result.

The next figure indicates the logical operation performed by each of
the functions.

Function      Operation
------------------------------------------------------------- 
ÿbit-norþ     complement of BIT-ARRAY1 or BIT-ARRAY2
ÿbit-andc1þ   and complement of BIT-ARRAY1 with BIT-ARRAY2
ÿbit-andc2þ   and BIT-ARRAY1 with complement of BIT-ARRAY2
ÿbit-orc1þ    or complement of BIT-ARRAY1 with BIT-ARRAY2
ÿbit-orc2þ    or BIT-ARRAY1 with complement of BIT-ARRAY2

Figure 15.4: Bit-wise Logical Operations on Bit Arrays

Examples:
.........

 (bit-and (setq ba #*11101010) #*01101011) ý #*01101010
 (bit-and #*1100 #*1010) ý #*1000
 (bit-andc1 #*1100 #*1010) ý #*0010
 (setq rba (bit-andc2 ba #*00110011 t)) ý #*11001000
 (eq rba ba) ý true
 (bit-not (setq ba #*11101010)) ý #*00010101
 (setq rba (bit-not ba
                     (setq tba (make-array 8
                                           :element-type 'bit))))
ý #*00010101
 (equal rba tba) ý true
 (bit-xor #*1100 #*1010) ý #*0110

See Also:
.........

*Note lognot::, *Note logand::


File: chris-ansicl.info,  Node: bit-vector-p,  Next: simple-bit-vector-p,  Prev: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Up: Arrays

bit-vector-p (Function)
=======================

Syntax:
.......

 -- Function: bit-vector-p object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿbit-vectorþ; otherwise, returns
false.

Examples:
.........

 (bit-vector-p (make-array 6
                           :element-type 'bit
                           :fill-pointer t)) ý true
 (bit-vector-p #*) ý true
 (bit-vector-p (make-array 6)) ý false

See Also:
.........

*Note typep::

Notes:
......

 (bit-vector-p OBJECT) Õ (typep OBJECT 'bit-vector)


File: chris-ansicl.info,  Node: simple-bit-vector-p,  Prev: bit-vector-p,  Up: Arrays

simple-bit-vector-p (Function)
==============================

Syntax:
.......

 -- Function: simple-bit-vector-p object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿsimple-bit-vectorþ; otherwise,
returns false.

Examples:
.........

 (simple-bit-vector-p (make-array 6)) ý false
 (simple-bit-vector-p #*) ý true

See Also:
.........

*Note simple-vector-p::

Notes:
......

 (simple-bit-vector-p OBJECT) Õ (typep OBJECT 'simple-bit-vector)


File: chris-ansicl.info,  Node: Strings,  Next: Sequences,  Prev: Arrays,  Up: Top

16 Strings
**********

* Menu:

* String Concepts::

Dictionary

* string (System Class)::
* base-string::
* simple-string::
* simple-base-string::
* simple-string-p::
* char; schar::
* string (Function)::
* string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+::
* string-trim; string-left-trim; string-right-trim::
* string=; string/=; string<; string>; string<=; string>=; string-equal; +::
* stringp::
* make-string::


File: chris-ansicl.info,  Node: String Concepts,  Next: string (System Class),  Up: Strings

16.1 String Concepts
====================

* Menu:

* Implications of Strings Being Arrays::
* Subtypes of STRING::


File: chris-ansicl.info,  Node: Implications of Strings Being Arrays,  Next: Subtypes of STRING,  Up: String Concepts

16.1.1 Implications of Strings Being Arrays
-------------------------------------------

Since all strings are arrays, all rules which apply generally to arrays
also apply to strings.  See *Note Section 15.1 (Array Concepts): Array
Concepts.

For example, strings can have fill pointers, and strings are also
subject to the rules of element type upgrading that apply to arrays.


File: chris-ansicl.info,  Node: Subtypes of STRING,  Prev: Implications of Strings Being Arrays,  Up: String Concepts

16.1.2 Subtypes of STRING
-------------------------

All functions that operate on strings will operate on subtypes of
string as well.

However, the consequences are undefined if a character is inserted into
a string for which the element type of the string does not include that
character.


File: chris-ansicl.info,  Node: string (System Class),  Next: base-string,  Prev: String Concepts,  Up: Strings

string (System Class)
=====================

Class Precedence List:
......................

ÿstringþ, ÿvectorþ, ÿarrayþ, ÿsequenceþ, ÿtþ

Description:
............

A string is a specialized vector whose elements are of type ÿcharacterþ
or a suptype of type ÿcharacterþ.  When used as a type specifier for
object creation, ÿstringþ means ÿ(vector character)þ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the union of all types ÿ(array c (SIZE))þ for all subtypes
c of ÿcharacterþ; that is, the set of strings of size SIZE.

See Also:
.........

*Note Section 16.1 (String Concepts): String Concepts, *Note Section
2.4.5 (Double-Quote): Double-Quote, *Note Section 22.1.3.4 (Printing
Strings): PrintingStrings.


File: chris-ansicl.info,  Node: base-string,  Next: simple-string,  Prev: string (System Class),  Up: Strings

base-string (Type)
==================

Supertypes:
...........

ÿbase-stringþ, ÿstringþ, ÿvectorþ, ÿarrayþ, ÿsequenceþ, ÿtþ

Description:
............

The type ÿbase-stringþ is equivalent to ÿ(vector base-char)þ.  The base
string representation is the most efficient string representation that
can hold an arbitrary sequence of standard characters.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(base-string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This is equivalent to the type ÿ(vector base-char SIZE)þ; that is, the
set of base strings of size SIZE.


File: chris-ansicl.info,  Node: simple-string,  Next: simple-base-string,  Prev: base-string,  Up: Strings

simple-string (Type)
====================

Supertypes:
...........

ÿsimple-stringþ, ÿstringþ, ÿvectorþ, ÿsimple-arrayþ, ÿarrayþ,
ÿsequenceþ, ÿtþ

Description:
............

A simple string is a specialized one-dimensional simple array whose
elements are of type ÿcharacterþ or a suptype of type ÿcharacterþ.
When used as a type specifier for object creation, ÿsimple-stringþ
means ÿ(simple-array character (size))þ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the union of all types ÿ(simple-array c (SIZE))þ for all
subtypes c of ÿcharacterþ; that is, the set of simple strings of size
SIZE.


File: chris-ansicl.info,  Node: simple-base-string,  Next: simple-string-p,  Prev: simple-string,  Up: Strings

simple-base-string (Type)
=========================

Supertypes:
...........

ÿsimple-base-stringþ, ÿbase-stringþ, ÿsimple-stringþ, ÿstringþ,
ÿvectorþ, ÿsimple-arrayþ, ÿarrayþ, ÿsequenceþ, ÿtþ

Description:
............

The type ÿsimple-base-stringþ is equivalent to ÿ(simple-array base-char
(*))þ.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-base-string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This is equivalent to the type ÿ(simple-array base-char (SIZE))þ; that
is, the set of simple base strings of size SIZE.


File: chris-ansicl.info,  Node: simple-string-p,  Next: char; schar,  Prev: simple-base-string,  Up: Strings

simple-string-p (Function)
==========================

Syntax:
.......

 -- Function: simple-string-p object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿsimple-stringþ; otherwise, returns
false.

Examples:
.........

 (simple-string-p "aaaaaa") ý true
 (simple-string-p (make-array 6
                              :element-type 'character
                              :fill-pointer t)) ý false

Notes:
......

 (simple-string-p OBJECT) Õ (typep OBJECT 'simple-string)


File: chris-ansicl.info,  Node: char; schar,  Next: string (Function),  Prev: simple-string-p,  Up: Strings

char, schar (Accessor)
======================

Syntax:
.......

 -- Function: char string index ý character

 -- Function: schar string index ý character

Arguments and Values:
.....................

STRING--for ÿcharþ,  a string; for ÿscharþ, a simple string.

INDEX--a valid array index for the STRING.

CHARACTER, NEW-CHARACTER--a character.

Description:
............

ÿcharþ and ÿscharþ access the element of STRING specified by INDEX.

ÿcharþ ignores fill pointers when accessing elements.

Examples:
.........

 (setq my-simple-string (make-string 6 :initial-element #\A)) ý "AAAAAA"
 (schar my-simple-string 4) ý #\A
 (setf (schar my-simple-string 4) #\B) ý #\B
 my-simple-string ý "AAAABA"
 (setq my-filled-string
       (make-array 6 :element-type 'character
                     :fill-pointer 5
                     :initial-contents my-simple-string))
ý "AAAAB"
 (char my-filled-string 4) ý #\B
 (char my-filled-string 5) ý #\A
 (setf (char my-filled-string 3) #\C) ý #\C
 (setf (char my-filled-string 5) #\D) ý #\D
 (setf (fill-pointer my-filled-string) 6) ý 6
 my-filled-string ý "AAACBD"

See Also:
.........

*Note aref::, *Note elt::, *Note Section 3.2.1 (Compiler Terminology):
Compiler Terminology.

Notes:
......

 (char s j) Õ (aref (the string s) j)


File: chris-ansicl.info,  Node: string (Function),  Next: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Prev: char; schar,  Up: Strings

string (Function)
=================

Syntax:
.......

 -- Function: string x ý string

Arguments and Values:
.....................

X--a string, a symbol, or a character.

STRING--a string.

Description:
............

Returns a string described by X; specifically:

   * If X is a string, it is returned.

   * If X is a symbol, its name is returned.

   * If X is a character, then a string containing that one character
     is returned.

   * ÿstringþ might perform additional, implementation-defined
     conversions.

Examples:
.........

 (string "already a string") ý "already a string"
 (string 'elm) ý "ELM"
 (string #\c) ý "c"

Exceptional Situations:
.......................

In the case where a conversion is defined neither by this specification
nor by the implementation, an error of type ÿtype-errorþ is signaled.

See Also:
.........

*Note coerce::, *Note string (System Class):: (type).

Notes:
......

ÿcoerceþ can be used to convert a sequence of characters to a string.

ÿprin1-to-stringþ, ÿprinc-to-stringþ, ÿwrite-to-stringþ, or ÿformatþ
(with a first argument of ÿnilþ) can be used to get a string
representation of a number or any other object.


File: chris-ansicl.info,  Node: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Next: string-trim; string-left-trim; string-right-trim,  Prev: string (Function),  Up: Strings

string-upcase, string-downcase, string-capitalize, nstring-upcase, nstring-downcase, nstring-capitalize (Function)
==================================================================================================================

Syntax:
.......

 -- Function: string-upcase string &key start end ý cased-string

 -- Function: string-downcase string &key start end ý cased-string

 -- Function: string-capitalize string &key start end ý cased-string

 -- Function: nstring-upcase string &key start end ý string

 -- Function: nstring-downcase string &key start end ý string

 -- Function: nstring-capitalize string &key start end ý string

Arguments and Values:
.....................

STRING--a string designator.  For ÿnstring-upcaseþ, ÿnstring-downcaseþ,
and ÿnstring-capitalizeþ, the STRING designator must be a string.

START, END--bounding index designators of STRING.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

CASED-STRING--a string.

Description:
............

ÿstring-upcaseþ,  ÿstring-downcaseþ,  ÿstring-capitalizeþ,
ÿnstring-upcaseþ, ÿnstring-downcaseþ, ÿnstring-capitalizeþ change the
case of the subsequence of STRING bounded by START and END as follows:

string-upcase
     ÿstring-upcaseþ returns a string just like STRING with all
     lowercase characters replaced by the corresponding uppercase
     characters.  More precisely, each character of the result string
     is produced by applying the function ÿchar-upcaseþ to the
     corresponding character of STRING.

string-downcase
     ÿstring-downcaseþ is like ÿstring-upcaseþ except that all
     uppercase characters are replaced by the corresponding lowercase
     characters (using ÿchar-downcaseþ).

string-capitalize
     ÿstring-capitalizeþ produces a copy of STRING such that, for every
     word in the copy, the first character of the "word," if it has
     case, is uppercase and any other characters with case in the word
     are lowercase.  For the purposes of ÿstring-capitalizeþ, a "word"
     is defined to be a consecutive subsequence consisting of
     alphanumeric characters, delimited at each end either by a
     non-alphanumeric character or by an end of the string.

nstring-upcase, nstring-downcase, nstring-capitalize
     ÿnstring-upcaseþ, ÿnstring-downcaseþ, and ÿnstring-capitalizeþ are
     identical to ÿstring-upcaseþ, ÿstring-downcaseþ, and
     ÿstring-capitalizeþ respectively except that they  modify STRING.

For ÿstring-upcaseþ, ÿstring-downcaseþ, and ÿstring-capitalizeþ, STRING
is not modified.  However, if no characters in STRING require
conversion, the result may be either STRING or a copy of it, at the
implementation's discretion.

Examples:
.........

 (string-upcase "abcde") ý "ABCDE"
 (string-upcase "Dr. Livingston, I presume?")
ý "DR. LIVINGSTON, I PRESUME?"
 (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)
ý "Dr. LiVINGston, I presume?"
 (string-downcase "Dr. Livingston, I presume?")
ý "dr. livingston, i presume?"

 (string-capitalize "elm 13c arthur;fig don't") ý "Elm 13c Arthur;Fig Don'T"
 (string-capitalize " hello ") ý " Hello "
 (string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")
ý  "Occluded Casements Forestall Inadvertent Defenestration"
 (string-capitalize 'kludgy-hash-search) ý "Kludgy-Hash-Search"
 (string-capitalize "DON'T!") ý "Don'T!"    ;not "Don't!"
 (string-capitalize "pipe 13a, foo16c") ý "Pipe 13a, Foo16c"

 (setq str (copy-seq "0123ABCD890a")) ý "0123ABCD890a"
 (nstring-downcase str :start 5 :end 7) ý "0123AbcD890a"
 str ý "0123AbcD890a"

Side Effects:
.............

ÿnstring-upcaseþ, ÿnstring-downcaseþ, and ÿnstring-capitalizeþ modify
STRING as appropriate rather than constructing a new string.

See Also:
.........

*Note char-upcase::, *Note char-downcase::

Notes:
......

The result is always of the same length as STRING.


File: chris-ansicl.info,  Node: string-trim; string-left-trim; string-right-trim,  Next: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Prev: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Up: Strings

string-trim, string-left-trim, string-right-trim (Function)
===========================================================

Syntax:
.......

 -- Function: string-trim character-bag string ý trimmed-string

 -- Function: string-left-trim character-bag string ý trimmed-string

 -- Function: string-right-trim character-bag string ý trimmed-string

Arguments and Values:
.....................

CHARACTER-BAG--a sequence containing characters.

STRING--a string designator.

TRIMMED-STRING--a string.

Description:
............

ÿstring-trimþ returns a substring of STRING, with all characters in
CHARACTER-BAG stripped off the beginning and end.  ÿstring-left-trimþ
is similar but strips characters off only the beginning;
ÿstring-right-trimþ strips off only the end.

If no characters need to be trimmed from the STRING, then either STRING
itself or a copy of it may be returned, at the discretion of the
implementation.

All of these functions observe the fill pointer.

Examples:
.........

 (string-trim "abc" "abcaakaaakabcaaa") ý "kaaak"
 (string-trim '(#\Space #\Tab #\Newline) " garbanzo beans
        ") ý "garbanzo beans"
 (string-trim " (*)" " ( *three (silly) words* ) ")
ý "three (silly) words"

 (string-left-trim "abc" "labcabcabc") ý "labcabcabc"
 (string-left-trim " (*)" " ( *three (silly) words* ) ")
ý "three (silly) words* ) "

 (string-right-trim " (*)" " ( *three (silly) words* ) ")
ý " ( *three (silly) words"

Affected By:
............

The implementation.


File: chris-ansicl.info,  Node: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Next: stringp,  Prev: string-trim; string-left-trim; string-right-trim,  Up: Strings

string=, string/=, string<, string>, string<=, string>=, string-equal, string-not-equal, string-lessp, string-greaterp, string-not-greaterp, string-not-lessp (Function)
========================================================================================================================================================================

Syntax:
.......

 -- Function: string= string1 string2 &key start1 end1 start2 end2 ý
          generalized-boolean

 -- Function: string/= string1 string2 &key start1 end1 start2 end2 ý
          mismatch-index

 -- Function: string< string1 string2 &key start1 end1 start2 end2 ý
          mismatch-index

 -- Function: string> string1 string2 &key start1 end1 start2 end2 ý
          mismatch-index

 -- Function: string<= string1 string2 &key start1 end1 start2 end2 ý
          mismatch-index

 -- Function: string>= string1 string2 &key start1 end1 start2 end2 ý
          mismatch-index

 -- Function: string-equal string1 string2 &key start1 end1 start2 end2
          ý generalized-boolean

 -- Function: string-not-equal string1 string2 &key start1 end1 start2
          end2 ý mismatch-index

 -- Function: string-lessp string1 string2 &key start1 end1 start2 end2
          ý mismatch-index

 -- Function: string-greaterp string1 string2 &key start1 end1 start2
          end2 ý mismatch-index

 -- Function: string-not-greaterp string1 string2 &key start1 end1
          start2 end2 ý mismatch-index

 -- Function: string-not-lessp string1 string2 &key start1 end1 start2
          end2 ý mismatch-index

Arguments and Values:
.....................

STRING1--a string designator.

STRING2--a string designator.

START1, END1--bounding index designators of STRING1.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

START2, END2--bounding index designators of STRING2.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

GENERALIZED-BOOLEAN--a generalized boolean.

MISMATCH-INDEX--a bounding index of STRING1, or ÿnilþ.

Description:
............

These functions perform lexicographic comparisons on STRING1 and
STRING2.  ÿstring=þ and ÿstring-equalþ are called equality functions;
the others are called inequality functions.  The comparison operations
these functions perform are restricted to the subsequence of STRING1
bounded by start1 and END1 and to the subsequence of STRING2 bounded by
start2 and END2.

A string a is equal to a string b if it contains the same number of
characters, and the corresponding characters are the same under ÿchar=þ
or ÿchar-equalþ, as appropriate.

A string a is less than a string b if in the first position in which
they differ the character of a is less than the corresponding character
of b according to ÿchar<þ or ÿchar-lesspþ as appropriate, or if string
a is a proper prefix of string b (of shorter length and matching in all
the characters of a).

The equality functions return a GENERALIZED BOOLEAN that is true if the
strings are equal, or false otherwise.

The inequality functions return a MISMATCH-INDEX that is true if the
strings are not equal, or false otherwise.  When the MISMATCH-INDEX is
true, it is an integer representing the first character position at
which the two substrings differ, as an offset from the beginning of
STRING1.

The comparison has one of the following results:

ÿstring=þ
     ÿstring=þ is true if the supplied substrings are of the same
     length and contain the same characters in corresponding positions;
     otherwise it is false.

ÿstring/=þ
     ÿstring/=þ is true if the supplied substrings are different;
     otherwise it is false.

ÿstring-equalþ
     ÿstring-equalþ is just like ÿstring=þ except that differences in
     case are ignored; two characters are considered to be the same if
     ÿchar-equalþ is true of them.

ÿstring<þ
     ÿstring<þ is true if substring1 is less than substring2; otherwise
     it is false.

ÿstring>þ
     ÿstring>þ is true if substring1 is greater than substring2;
     otherwise it is false.

ÿstring-lesspþ, ÿstring-greaterpþ
     ÿstring-lesspþ and ÿstring-greaterpþ are exactly like ÿstring<þ
     and ÿstring>þ, respectively, except that distinctions between
     uppercase and lowercase letters are ignored.  It is as if
     ÿchar-lesspþ were used instead of ÿchar<þ for comparing characters.

ÿstring<=þ
     ÿstring<=þ is true if substring1 is less than or equal to
     substring2; otherwise it is false.

ÿstring>=þ
     ÿstring>=þ is true if substring1 is greater than or equal to
     substring2; otherwise it is false.

ÿstring-not-greaterpþ, ÿstring-not-lesspþ
     ÿstring-not-greaterpþ and ÿstring-not-lesspþ are exactly like
     ÿstring<=þ and ÿstring>=þ, respectively, except that distinctions
     between uppercase and lowercase letters are ignored.  It is as if
     ÿchar-lesspþ were used instead of ÿchar<þ for comparing characters.

Examples:
.........

 (string= "foo" "foo") ý true
 (string= "foo" "Foo") ý false
 (string= "foo" "bar") ý false
 (string= "together" "frog" :start1 1 :end1 3 :start2 2) ý true
 (string-equal "foo" "Foo") ý true
 (string= "abcd" "01234abcd9012" :start2 5 :end2 9) ý true
 (string< "aaaa" "aaab") ý 3
 (string>= "aaaaa" "aaaa") ý 4
 (string-not-greaterp "Abcde" "abcdE") ý 5
 (string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7
                                      :start2 2 :end2 6) ý 6
 (string-not-equal "AAAA" "aaaA") ý false

See Also:
.........

*Note char=::

Notes:
......

ÿequalþ calls ÿstring=þ if applied to two strings.


File: chris-ansicl.info,  Node: stringp,  Next: make-string,  Prev: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Up: Strings

stringp (Function)
==================

Syntax:
.......

 -- Function: stringp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿstringþ; otherwise, returns false.

Examples:
.........

 (stringp "aaaaaa") ý true
 (stringp #\a) ý false

See Also:
.........

*Note typep::, *Note string (System Class):: (type)

Notes:
......

 (stringp OBJECT) Õ (typep OBJECT 'string)


File: chris-ansicl.info,  Node: make-string,  Prev: stringp,  Up: Strings

make-string (Function)
======================

Syntax:
.......

 -- Function: make-string size &key initial-element element-type ý
          string

Arguments and Values:
.....................

SIZE--a valid array dimension.

INITIAL-ELEMENT--a character.  The default is implementation-dependent.

ELEMENT-TYPE--a type specifier.  The default is ÿcharacterþ.

STRING--a simple string.

Description:
............

ÿmake-stringþ returns a simple string of length SIZE whose elements
have been initialized to INITIAL-ELEMENT.

The ELEMENT-TYPE names the type of the elements of the string; a string
is constructed of the most specialized type that can accommodate
elements of the given type.

Examples:
.........

 (make-string 10 :initial-element #\5) ý "5555555555"
 (length (make-string 10)) ý 10

Affected By:
............

The implementation.


File: chris-ansicl.info,  Node: Sequences,  Next: Hash Tables,  Prev: Strings,  Up: Top

17 Sequences
************

* Menu:

* Sequence Concepts::
* Rules about Test Functions::

Dictionary

* sequence::
* copy-seq::
* elt::
* fill::
* make-sequence::
* subseq::
* map::
* map-into::
* reduce::
* count; count-if; count-if-not::
* length::
* reverse; nreverse::
* sort; stable-sort::
* find; find-if; find-if-not::
* position; position-if; position-if-not::
* search::
* mismatch::
* replace::
* substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+::
* concatenate::
* merge::
* remove; remove-if; remove-if-not; delete; delete-if; delete-if-not::
* remove-duplicates; delete-duplicates::


File: chris-ansicl.info,  Node: Sequence Concepts,  Next: Rules about Test Functions,  Up: Sequences

17.1 Sequence Concepts
======================

A "sequence" is an ordered collection of elements, implemented as
either a vector or a list.

Sequences can be created by the function ÿmake-sequenceþ, as well as
other functions that create objects of types that are subtypes of
ÿsequenceþ (e.g., ÿlistþ, ÿmake-listþ, ÿmapcarþ, and ÿvectorþ).

A "sequence function" is a function defined by this specification or
added as an extension by the implementation that operates on one or
more sequences.  Whenever a sequence function must construct and return
a new vector, it always returns a simple vector.  Similarly, any
strings constructed will be simple strings.

concatenate         length               remove
copy-seq            map                  remove-duplicates
count               map-into             remove-if
count-if            merge                remove-if-not
count-if-not        mismatch             replace
delete              notany               reverse
delete-duplicates   notevery             search
delete-if           nreverse             some
delete-if-not       nsubstitute          sort
elt                 nsubstitute-if       stable-sort
every               nsubstitute-if-not   subseq
fill                position             substitute
find                position-if          substitute-if
find-if             position-if-not      substitute-if-not
find-if-not         reduce               

Figure 17.1: Standardized Sequence Functions

* Menu:

* General Restrictions on Parameters that must be Sequences::


File: chris-ansicl.info,  Node: General Restrictions on Parameters that must be Sequences,  Up: Sequence Concepts

17.1.1 General Restrictions on Parameters that must be Sequences
----------------------------------------------------------------

In general, lists (including association lists and property lists) that
are treated as sequences must be proper lists.


File: chris-ansicl.info,  Node: Rules about Test Functions,  Next: sequence,  Prev: Sequence Concepts,  Up: Sequences

17.2 Rules about Test Functions
===============================

* Menu:

* Satisfying a Two-Argument Test::
* Satisfying a One-Argument Test::


File: chris-ansicl.info,  Node: Satisfying a Two-Argument Test,  Next: Satisfying a One-Argument Test,  Up: Rules about Test Functions

17.2.1 Satisfying a Two-Argument Test
-------------------------------------

When an object O is being considered iteratively against each element
E_i of a sequence S by an operator F listed in the next figure, it is
sometimes useful to control the way in which the presence of O is
tested in S is tested by F.  This control is offered on the basis of a
function designated with either a :test or :test-not argument.

adjoin            nset-exclusive-or   search
assoc             nsublis             set-difference
count             nsubst              set-exclusive-or
delete            nsubstitute         sublis
find              nunion              subsetp
intersection      position            subst
member            pushnew             substitute
mismatch          rassoc              tree-equal
nintersection     remove              union
nset-difference   remove-duplicates   

Figure 17.2: Operators that have Two-Argument Tests to be Satisfied

The object O might not be compared directly to E_i.  If a :key argument
is provided, it is a designator for a function of one argument to be
called with each E_i as an argument, and yielding an object Z_i to be
used for comparison.  (If there is no :key argument, Z_i is E_i.)

The function designated by the :key argument is never called on O
itself.  However, if the function operates on multiple sequences (e.g.,
as happens in ÿset-differenceþ), O will be the result of calling the
:key function on an element of the other sequence.

A :test argument, if supplied to F, is a designator for a  function of
two arguments, O and Z_i.  An E_i is said (or, sometimes, an O and an
E_i are said) to "satisfy the test" if this :test function returns a
generalized boolean representing true.

A :test-not argument, if supplied to F, is designator for a function of
two arguments, O and Z_i.  An E_i is said (or, sometimes, an O and an
E_i are said) to "satisfy the test" if this :test-not function returns
a generalized boolean representing false.

If neither a :test nor a :test-not argument is supplied, it is as if a
:test argument of ÿ#'eqlþ was supplied.

The consequences are unspecified if both a :test and a :test-not
argument are supplied in the same call to F.

17.2.1.1 Examples of Satisfying a Two-Argument Test
...................................................

 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equal)
ý (foo bar "BAR" "foo" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equalp)
ý (foo bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string-equal)
ý (bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string=)
ý (BAR "BAR" "foo" "bar")

 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'eql)
ý (1)
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'=)
ý (1 1.0 #C(1.0 0.0))
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test (complement #'=))
ý (1 1.0 #C(1.0 0.0))

 (count 1 '((one 1) (uno 1) (two 2) (dos 2)) :key #'cadr) ý 2

 (count 2.0 '(1 2 3) :test #'eql :key #'float) ý 1

 (count "FOO" (list (make-pathname :name "FOO" :type "X")
                    (make-pathname :name "FOO" :type "Y"))
        :key #'pathname-name
        :test #'equal)
ý 2


File: chris-ansicl.info,  Node: Satisfying a One-Argument Test,  Prev: Satisfying a Two-Argument Test,  Up: Rules about Test Functions

17.2.2 Satisfying a One-Argument Test
-------------------------------------

When using one of the functions in the next figure, the elements E of a
sequence S are filtered not on the basis of the presence or absence of
an object O under a two argument predicate, as with the functions
described in *Note Section 17.2.1 (Satisfying a Two-Argument Test):
Satisfying a Two-Argument Test, but rather on the basis of a one
argument predicate.

assoc-if        member-if            rassoc-if
assoc-if-not    member-if-not        rassoc-if-not
count-if        nsubst-if            remove-if
count-if-not    nsubst-if-not        remove-if-not
delete-if       nsubstitute-if       subst-if
delete-if-not   nsubstitute-if-not   subst-if-not
find-if         position-if          substitute-if
find-if-not     position-if-not      substitute-if-not

Figure 17.3: Operators that have One-Argument Tests to be Satisfied

The element E_i might not be considered directly.  If a :key argument
is provided, it is a designator for a function of one argument to be
called with each E_i as an argument, and yielding an object Z_i to be
used for comparison.  (If there is no :key argument, Z_i is E_i.)

Functions defined in this specification and having a name that ends in
"ÿ-ifþ" accept a first argument that is a designator for a function of
one argument, Z_i.  An E_i is said to "satisfy the test" if this :test
function returns a generalized boolean representing true.

Functions defined in this specification and having a name that ends in
"ÿ-if-notþ" accept a first argument that is a designator for a function
of one argument, Z_i.  An E_i is said to "satisfy the test" if this
:test function returns a generalized boolean representing false.

17.2.2.1 Examples of Satisfying a One-Argument Test
...................................................

 (count-if #'zerop '(1 #C(0.0 0.0) 0 0.0d0 0.0s0 3)) ý 4

 (remove-if-not #'symbolp '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
ý (A B C D E F)
 (remove-if (complement #'symbolp) '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
ý (A B C D E F)

 (count-if #'zerop '("foo" "" "bar" "" "" "baz" "quux") :key #'length)
ý 3


File: chris-ansicl.info,  Node: sequence,  Next: copy-seq,  Prev: Rules about Test Functions,  Up: Sequences

sequence (System Class)
=======================

Class Precedence List:
......................

ÿsequenceþ, ÿtþ

Description:
............

Sequences are ordered collections of objects, called the elements of
the sequence.

The types ÿvectorþ and the type ÿlistþ are disjoint subtypes of type
ÿsequenceþ, but are not necessarily an exhaustive partition of sequence.

When viewing a vector as a sequence, only the active elements of that
vector are considered elements of the sequence; that is, sequence
operations respect the fill pointer when given sequences represented as
vectors.


File: chris-ansicl.info,  Node: copy-seq,  Next: elt,  Prev: sequence,  Up: Sequences

copy-seq (Function)
===================

Syntax:
.......

 -- Function: copy-seq sequence ý copied-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

COPIED-SEQUENCE--a proper sequence.

Description:
............

Creates a copy of SEQUENCE.  The elements of the new sequence are the
same as the corresponding elements of the given SEQUENCE.

If SEQUENCE is a vector, the result is a fresh simple array of rank one
that has the same actual array element type as SEQUENCE.  If SEQUENCE
is a list, the result is a fresh list.

Examples:
.........

 (setq str "a string") ý "a string"
 (equalp str (copy-seq str)) ý true
 (eql str (copy-seq str)) ý false

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note copy-list::

Notes:
......

From a functional standpoint,
 (copy-seq x) Õ (subseq x 0)

However, the programmer intent is typically very different in these two
cases.


File: chris-ansicl.info,  Node: elt,  Next: fill,  Prev: copy-seq,  Up: Sequences

elt (Accessor)
==============

Syntax:
.......

 -- Function: elt sequence index ý object

(setf (elt sequence index) new-object)

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

INDEX--a valid sequence index for SEQUENCE.

OBJECT--an object.

NEW-OBJECT--an object.

Description:
............

Accesses the element of SEQUENCE specified by INDEX.

Examples:
.........

 (setq str (copy-seq "0123456789")) ý "0123456789"
 (elt str 6) ý #\6
 (setf (elt str 0) #\#) ý #\#
 str ý "#123456789"

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.  Should signal an error of type ÿtype-errorþ
if INDEX is not a valid sequence index for SEQUENCE.

See Also:
.........

*Note aref::, *Note nth::, *Note Section 3.2.1 (Compiler Terminology):
Compiler Terminology.

Notes:
......

ÿarefþ may be used to access vector elements that are beyond the
vector's fill pointer.


File: chris-ansicl.info,  Node: fill,  Next: make-sequence,  Prev: elt,  Up: Sequences

fill (Function)
===============

Syntax:
.......

 -- Function: fill sequence item &key start end ý sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

ITEM--a sequence.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

Description:
............

Replaces the elements of SEQUENCE bounded by START and END with ITEM.

Examples:
.........

 (fill (list 0 1 2 3 4 5) '(444)) ý ((444) (444) (444) (444) (444) (444))
 (fill (copy-seq "01234") #\e :start 3) ý "012ee"
 (setq x (vector 'a 'b 'c 'd 'e)) ý #(A B C D E)
 (fill x 'z :start 1 :end 3) ý #(A Z Z D E)
 x ý #(A Z Z D E)
 (fill x 'p) ý #(P P P P P)
 x ý #(P P P P P)

Side Effects:
.............

SEQUENCE is destructively modified.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.  Should signal an error of type ÿtype-errorþ
if START is not a non-negative integer.  Should signal an error of type
ÿtype-errorþ if END is not a non-negative integer or ÿnilþ.

See Also:
.........

*Note replace::, *Note nsubstitute::

Notes:
......

ÿ(fill SEQUENCE ITEM) Õ (nsubstitute-if ITEM (constantly t) SEQUENCE)þ


File: chris-ansicl.info,  Node: make-sequence,  Next: subseq,  Prev: fill,  Up: Sequences

make-sequence (Function)
========================

Syntax:
.......

 -- Function: make-sequence result-type size &key initial-element ý
          sequence

Arguments and Values:
.....................

RESULT-TYPE--a ÿsequenceþ type specifier.

SIZE--a non-negative integer.

INITIAL-ELEMENT--an object.  The default is implementation-dependent.

SEQUENCE--a proper sequence.

Description:
............

Returns a sequence of the type RESULT-TYPE and of length SIZE, each of
the elements of which has been initialized to INITIAL-ELEMENT.

If the RESULT-TYPE is a subtype of ÿlistþ, the result will be a list.

If the RESULT-TYPE is a subtype of ÿvectorþ, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ÿ*þ), the element type of the resulting array
is ÿtþ; otherwise, an error is signaled.

Examples:
.........

 (make-sequence 'list 0) ý ()
 (make-sequence 'string 26 :initial-element #\.)
ý ".........................."
 (make-sequence '(vector double-float) 2
                :initial-element 1d0)
ý #(1.0d0 1.0d0)

 (make-sequence '(vector * 2) 3) should signal an error
 (make-sequence '(vector * 4) 3) should signal an error

Affected By:
............

The implementation.

Exceptional Situations:
.......................

The consequences are unspecified if INITIAL-ELEMENT is not an object
which can be stored in the resulting sequence.

An error of type ÿtype-errorþ must be signaled if the RESULT-TYPE is
neither a recognizable subtype of ÿlistþ, nor a recognizable subtype of
ÿvectorþ.

An error of type ÿtype-errorþ should be signaled if RESULT-TYPE
specifies the number of elements and SIZE is different from that number.

See Also:
.........

*Note make-array::, *Note make-list::

Notes:
......

 (make-sequence 'string 5) Õ (make-string 5)


File: chris-ansicl.info,  Node: subseq,  Next: map,  Prev: make-sequence,  Up: Sequences

subseq (Accessor)
=================

Syntax:
.......

 -- Function: subseq sequence start &optional end ý subsequence

(setf (subseq sequence start &optional end) new-subsequence)

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

START, END--bounding index designators of SEQUENCE.  The default for
END is ÿnilþ.

SUBSEQUENCE--a proper sequence.

NEW-SUBSEQUENCE--a proper sequence.

Description:
............

ÿsubseqþ creates a sequence that is a copy of the subsequence of
SEQUENCE BOUNDED by START and END.

START specifies an offset into the original SEQUENCE and marks the
beginning position of the subsequence.  END marks the position
following the last element of the subsequence.

ÿsubseqþ always allocates a new sequence for a result; it never shares
storage with an old sequence.  The result subsequence is always of the
same type as SEQUENCE.

If SEQUENCE is a vector, the result is a fresh simple array of rank one
that has the same actual array element type as SEQUENCE.  If SEQUENCE
is a list, the result is a fresh list.

ÿsetfþ may be used with ÿsubseqþ to destructively replace elements of a
subsequence with elements taken from a sequence of new values.  If the
subsequence and the new sequence are not of equal length, the shorter
length determines the number of elements that are replaced.  The
remaining elements at the end of the longer sequence are not modified
in the operation.

Examples:
.........

 (setq str "012345") ý "012345"
 (subseq str 2) ý "2345"
 (subseq str 3 5) ý "34"
 (setf (subseq str 4) "abc") ý "abc"
 str ý "0123ab"
 (setf (subseq str 0 2) "A") ý "A"
 str ý "A123ab"

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.  Should be prepared to signal an error of
type ÿtype-errorþ if NEW-SUBSEQUENCE is not a proper sequence.

See Also:
.........

*Note replace::


File: chris-ansicl.info,  Node: map,  Next: map-into,  Prev: subseq,  Up: Sequences

map (Function)
==============

Syntax:
.......

 -- Function: map result-type function &rest sequences+ ý result

Arguments and Values:
.....................

RESULT-TYPE--a ÿsequenceþ type specifier, or ÿnilþ.

FUNCTION--a function designator.  FUNCTION must take as many arguments
as there are SEQUENCES.

SEQUENCE--a proper sequence.

RESULT--if RESULT-TYPE is a type specifier other than ÿnilþ, then a
sequence of the type it denotes; otherwise (if the RESULT-TYPE is
ÿnilþ), ÿnilþ.

Description:
............

Applies FUNCTION to successive sets of arguments in which one argument
is obtained from each sequence.  The FUNCTION is called first on all
the elements with index ÿ0þ, then on all those with index ÿ1þ, and so
on.  The RESULT-TYPE specifies the type of the resulting sequence.

ÿmapþ returns ÿnilþ if RESULT-TYPE is ÿnilþ.  Otherwise, ÿmapþ returns
a sequence such that element ÿjþ is the result of applying FUNCTION to
element ÿjþ of each of the SEQUENCES.  The result sequence is as long
as the shortest of the SEQUENCES.  The consequences are undefined if
the result of applying FUNCTION to the successive elements of the
SEQUENCES cannot be contained in a sequence of the type given by
RESULT-TYPE.

If the RESULT-TYPE is a subtype of ÿlistþ, the result will be a list.

If the RESULT-TYPE is a subtype of ÿvectorþ, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ÿ*þ), the element type of the resulting array
is ÿtþ; otherwise, an error is signaled.

Examples:
.........

 (map 'string #'(lambda (x y)
                  (char "01234567890ABCDEF" (mod (+ x y) 16)))
       '(1 2 3 4)
       '(10 9 8 7)) ý "AAAA"
 (setq seq '("lower" "UPPER" "" "123")) ý ("lower" "UPPER" "" "123")
 (map nil #'nstring-upcase seq) ý NIL
 seq ý ("LOWER" "UPPER" "" "123")
 (map 'list #'- '(1 2 3 4)) ý (-1 -2 -3 -4)
 (map 'string
      #'(lambda (x) (if (oddp x) #\1 #\0))
      '(1 2 3 4)) ý "1010"

 (map '(vector * 4) #'cons "abc" "de") should signal an error

Exceptional Situations:
.......................

An error of type ÿtype-errorþ must be signaled if the RESULT-TYPE is
not a recognizable subtype of ÿlistþ, not a recognizable subtype of
ÿvectorþ, and not ÿnilþ.

Should be prepared to signal an error of type ÿtype-errorþ if any
SEQUENCE is not a proper sequence.

An error of type ÿtype-errorþ should be signaled if RESULT-TYPE
specifies the number of elements and the minimum length of the SEQUENCES
is different from that number.

See Also:
.........

*Note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: chris-ansicl.info,  Node: map-into,  Next: reduce,  Prev: map,  Up: Sequences

map-into (Function)
===================

Syntax:
.......

 -- Function: map-into result-sequence function &rest sequences ý
          result-sequence

Arguments and Values:
.....................

RESULT-SEQUENCE--a proper sequence.

FUNCTION--a designator for a function of as many arguments as there are
SEQUENCES.

SEQUENCE--a proper sequence.

Description:
............

Destructively modifies RESULT-SEQUENCE to contain the results of
applying FUNCTION to each element in the argument SEQUENCES in turn.

RESULT-SEQUENCE and each element of SEQUENCES can each be either a list
or a vector.  If RESULT-SEQUENCE and each element of SEQUENCES are not
all the same length, the iteration terminates when the shortest sequence
(of any of the SEQUENCES or the RESULT-SEQUENCE) is exhausted.  If
RESULT-SEQUENCE is a vector with a fill pointer, the fill pointer is
ignored when deciding how many iterations to perform, and afterwards
the fill pointer is set to the number of times FUNCTION was applied.
If RESULT-SEQUENCE is longer than the shortest element of SEQUENCES,
extra elements at the end of RESULT-SEQUENCE are left unchanged.  If
RESULT-SEQUENCE is ÿnilþ, ÿmap-intoþ immediately returns ÿnilþ, since
ÿnilþ is a sequence of length zero.

If FUNCTION has side effects, it can count on being called first on all
of the elements with index 0, then on all of those numbered 1, and so
on.

Examples:
.........

 (setq a (list 1 2 3 4) b (list 10 10 10 10)) ý (10 10 10 10)
 (map-into a #'+ a b) ý (11 12 13 14)
 a ý (11 12 13 14)
 b ý (10 10 10 10)
 (setq k '(one two three)) ý (ONE TWO THREE)
 (map-into a #'cons k a) ý ((ONE . 11) (TWO . 12) (THREE . 13) 14)
 (map-into a #'gensym) ý (#:G9090 #:G9091 #:G9092 #:G9093)
 a ý (#:G9090 #:G9091 #:G9092 #:G9093)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if
RESULT-SEQUENCE is not a proper sequence.  Should be prepared to signal
an error of type ÿtype-errorþ if SEQUENCE is not a proper sequence.

Notes:
......

ÿmap-intoþ differs from ÿmapþ in that it modifies an existing sequence
rather than creating a new one.  In addition, ÿmap-intoþ can be called
with only two arguments, while ÿmapþ requires at least three arguments.

ÿmap-intoþ could be defined by:

 (defun map-into (result-sequence function &rest sequences)
   (loop for index below (apply #'min
                                (length result-sequence)
                                (mapcar #'length sequences))
         do (setf (elt result-sequence index)
                  (apply function
                         (mapcar #'(lambda (seq) (elt seq index))
                                 sequences))))
   result-sequence)


File: chris-ansicl.info,  Node: reduce,  Next: count; count-if; count-if-not,  Prev: map-into,  Up: Sequences

reduce (Function)
=================

Syntax:
.......

 -- Function: reduce function sequence &key key from-end start end
          initial-value ý result

Arguments and Values:
.....................

FUNCTION--a designator for a function that might be called with either
zero or two arguments.

SEQUENCE--a proper sequence.

KEY--a designator for a function of one argument, or ÿnilþ.

FROM-END--a generalized boolean.  The default is false.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

INITIAL-VALUE--an object.

RESULT--an object.

Description:
............

ÿreduceþ uses a binary operation, FUNCTION, to combine the elements of
SEQUENCE bounded by START and END.

The FUNCTION must accept as arguments two elements of SEQUENCE or the
results from combining those elements.  The FUNCTION must also be able
to accept no arguments.

If KEY is supplied, it is used is used to extract the values to reduce.
The KEY function is applied exactly once to each element of SEQUENCE in
the order implied by the reduction order but not to the value of
INITIAL-VALUE, if supplied.  The KEY function typically returns part of
the element of SEQUENCE.  If KEY is not supplied or is ÿnilþ, the
SEQUENCE element itself is used.

The reduction is left-associative, unless FROM-END is true in which
case it is right-associative.

If INITIAL-VALUE is supplied, it is logically placed before the
subsequence (or after it if FROM-END is true) and included in the
reduction operation.

In the normal case, the result of ÿreduceþ is the combined result of
FUNCTION's being applied to successive pairs of elements of SEQUENCE.
If the subsequence contains exactly one element and no INITIAL-VALUE is
given, then that element is returned and FUNCTION is not called.  If
the subsequence is empty and an INITIAL-VALUE is given, then the
INITIAL-VALUE is returned and FUNCTION is not called.  If the
subsequence is empty and no INITIAL-VALUE is given, then the FUNCTION
is called with zero arguments, and ÿreduceþ returns whatever FUNCTION
does.  This is the only case where the FUNCTION is called with other
than two arguments.

Examples:
.........

 (reduce #'* '(1 2 3 4 5)) ý 120
 (reduce #'append '((1) (2)) :initial-value '(i n i t)) ý (I N I T 1 2)
 (reduce #'append '((1) (2)) :from-end t
                             :initial-value '(i n i t)) ý (1 2 I N I T)
 (reduce #'- '(1 2 3 4)) Õ (- (- (- 1 2) 3) 4) ý -8
 (reduce #'- '(1 2 3 4) :from-end t)    ;Alternating sum.
Õ (- 1 (- 2 (- 3 4))) ý -2
 (reduce #'+ '()) ý 0
 (reduce #'+ '(3)) ý 3
 (reduce #'+ '(foo)) ý FOO
 (reduce #'list '(1 2 3 4)) ý (((1 2) 3) 4)
 (reduce #'list '(1 2 3 4) :from-end t) ý (1 (2 (3 4)))
 (reduce #'list '(1 2 3 4) :initial-value 'foo) ý ((((foo 1) 2) 3) 4)
 (reduce #'list '(1 2 3 4)
        :from-end t :initial-value 'foo) ý (1 (2 (3 (4 foo))))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: chris-ansicl.info,  Node: count; count-if; count-if-not,  Next: length,  Prev: reduce,  Up: Sequences

count, count-if, count-if-not (Function)
========================================

Syntax:
.......

 -- Function: count item sequence &key from-end start end key test
          test-not ý n

 -- Function: count-if predicate sequence &key from-end start end key ý
          n

 -- Function: count-if-not predicate sequence &key from-end start end
          key ý n

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

KEY--a designator for a function of one argument, or ÿnilþ.

N--a non-negative integer less than or equal to the length of SEQUENCE.

Description:
............

ÿcountþ, ÿcount-ifþ, and ÿcount-if-notþ count and return the number of
elements in the SEQUENCE bounded by START and END that satisfy the test.

The FROM-END has no direct effect on the result.  However, if FROM-END
is true, the elements of SEQUENCE will be supplied as arguments to the
TEST, TEST-NOT, and KEY in reverse order, which may change the
side-effects, if any, of those functions.

Examples:
.........

 (count #\a "how many A's are there in here?") ý 2
 (count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) ý 2
 (count-if #'upper-case-p "The Crying of Lot 49" :start 4) ý 2

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note Section 17.2 (Rules about Test Functions): Rules about Test
Functions, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ÿcount-if-notþ is deprecated.


File: chris-ansicl.info,  Node: length,  Next: reverse; nreverse,  Prev: count; count-if; count-if-not,  Up: Sequences

length (Function)
=================

Syntax:
.......

 -- Function: length sequence ý n

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

N--a non-negative integer.

Description:
............

Returns the number of elements in SEQUENCE.

If SEQUENCE is a vector with a fill pointer, the active length as
specified by the fill pointer is returned.

Examples:
.........

 (length "abc") ý 3
 (setq str (make-array '(3) :element-type 'character
                            :initial-contents "abc"
                            :fill-pointer t)) ý "abc"
 (length str) ý 3
 (setf (fill-pointer str) 2) ý 2
 (length str) ý 2

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note list-length::, *Note sequence::


File: chris-ansicl.info,  Node: reverse; nreverse,  Next: sort; stable-sort,  Prev: length,  Up: Sequences

reverse, nreverse (Function)
============================

Syntax:
.......

 -- Function: reverse sequence ý reversed-sequence

 -- Function: nreverse sequence ý reversed-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

REVERSED-SEQUENCE--a sequence.

Description:
............

ÿreverseþ and ÿnreverseþ return a new sequence of the same kind as
SEQUENCE, containing the same elements, but in reverse order.

ÿreverseþ and ÿnreverseþ differ in that ÿreverseþ always creates and
returns a new sequence, whereas ÿnreverseþ might modify and return the
given SEQUENCE.  ÿreverseþ never modifies the given SEQUENCE.

For ÿreverseþ, if SEQUENCE is a vector, the result is a fresh simple
array of rank one that has the same actual array element type as
SEQUENCE.  If SEQUENCE is a list, the result is a fresh list.

For ÿnreverseþ, if SEQUENCE is a vector, the result is a vector that
has the same actual array element type as SEQUENCE.  If SEQUENCE is a
list, the result is a list.

For ÿnreverseþ, SEQUENCE might be destroyed and re-used to produce the
result.  The result might or might not be identical to SEQUENCE.
Specifically, when SEQUENCE is a list, ÿnreverseþ is permitted to
ÿsetfþ any part, ÿcarþ or ÿcdrþ, of any cons that is part of the list
structure of SEQUENCE.  When SEQUENCE is a vector, ÿnreverseþ is
permitted to re-order the elements of SEQUENCE in order to produce the
resulting vector.

Examples:
.........

 (setq str "abc") ý "abc"
 (reverse str) ý "cba"
 str ý "abc"
 (setq str (copy-seq str)) ý "abc"
 (nreverse str) ý "cba"
 str ý implementation-dependent
 (setq l (list 1 2 3)) ý (1 2 3)
 (nreverse l) ý (3 2 1)
 l ý implementation-dependent

Side Effects:
.............

ÿnreverseþ might either create a new sequence, modify the argument
SEQUENCE, or both.  (ÿreverseþ does not modify SEQUENCE.)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.


File: chris-ansicl.info,  Node: sort; stable-sort,  Next: find; find-if; find-if-not,  Prev: reverse; nreverse,  Up: Sequences

sort, stable-sort (Function)
============================

Syntax:
.......

 -- Function: sort sequence predicate &key key ý sorted-sequence

 -- Function: stable-sort sequence predicate &key key ý sorted-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

SORTED-SEQUENCE--a sequence.

Description:
............

ÿsortþ and ÿstable-sortþ destructively sort SEQUENCES according to the
order determined by the PREDICATE function.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

ÿsortþ determines the relationship between two elements by giving keys
extracted from the elements to the PREDICATE.  The first argument to
the PREDICATE function is the part of one element of SEQUENCE extracted
by the KEY function (if supplied); the second argument is the part of
another element of SEQUENCE extracted by the KEY function (if supplied).
PREDICATE should return true if and only if the first argument is
strictly less than the second (in some appropriate sense).  If the
first argument is greater than or equal to the second (in the
appropriate sense), then the PREDICATE should return false.

The argument to the KEY function is the SEQUENCE element.  The return
value of the KEY function becomes an argument to PREDICATE.  If KEY is
not supplied or ÿnilþ, the SEQUENCE element itself is used.  There is
no guarantee on the number of times the KEY will be called.

If the KEY and PREDICATE always return, then the sorting operation will
always terminate, producing a sequence containing the same elements as
SEQUENCE (that is, the result is a permutation of SEQUENCE).  This is
guaranteed even if the PREDICATE does not really consistently represent
a total order (in which case the elements will be scrambled in some
unpredictable way, but no element will be lost).  If the KEY
consistently returns meaningful keys, and the PREDICATE does reflect
some total ordering criterion on those keys, then the elements of the
SORTED-SEQUENCE will be properly sorted according to that ordering.

The sorting operation performed by ÿsortþ is not guaranteed stable.
Elements considered equal by the PREDICATE might or might not stay in
their original order.  The PREDICATE is assumed to consider two
elements ÿxþ and ÿyþ to be equal if ÿ(funcall predicate x y)þ and
ÿ(funcall predicate y x)þ are both false.  ÿstable-sortþ guarantees
stability.

The sorting operation can be destructive in all cases.  In the case of a
vector argument, this is accomplished by permuting the elements in
place.  In the case of a list, the list is destructively reordered in
the same manner as for ÿnreverseþ.

Examples:
.........

 (setq tester (copy-seq "lkjashd")) ý "lkjashd"
 (sort tester #'char-lessp) ý "adhjkls"
 (setq tester (list '(1 2 3) '(4 5 6) '(7 8 9))) ý ((1 2 3) (4 5 6) (7 8 9))
 (sort tester #'> :key #'car)  ý ((7 8 9) (4 5 6) (1 2 3))
 (setq tester (list 1 2 3 4 5 6 7 8 9 0)) ý (1 2 3 4 5 6 7 8 9 0)
 (stable-sort tester #'(lambda (x y) (and (oddp x) (evenp y))))
ý (1 3 5 7 9 2 4 6 8 0)
 (sort (setq committee-data
             (vector (list (list "JonL" "White") "Iteration")
                     (list (list "Dick" "Waters") "Iteration")
                     (list (list "Dick" "Gabriel") "Objects")
                     (list (list "Kent" "Pitman") "Conditions")
                     (list (list "Gregor" "Kiczales") "Objects")
                     (list (list "David" "Moon") "Objects")
                     (list (list "Kathy" "Chapman") "Editorial")
                     (list (list "Larry" "Masinter") "Cleanup")
                     (list (list "Sandra" "Loosemore") "Compiler")))
       #'string-lessp :key #'cadar)
ý #((("Kathy" "Chapman") "Editorial")
     (("Dick" "Gabriel") "Objects")
     (("Gregor" "Kiczales") "Objects")
     (("Sandra" "Loosemore") "Compiler")
     (("Larry" "Masinter") "Cleanup")
     (("David" "Moon") "Objects")
     (("Kent" "Pitman") "Conditions")
     (("Dick" "Waters") "Iteration")
     (("JonL" "White") "Iteration"))
 ;; Note that individual alphabetical order within `committees'
 ;; is preserved.
 (setq committee-data
       (stable-sort committee-data #'string-lessp :key #'cadr))
ý #((("Larry" "Masinter") "Cleanup")
     (("Sandra" "Loosemore") "Compiler")
     (("Kent" "Pitman") "Conditions")
     (("Kathy" "Chapman") "Editorial")
     (("Dick" "Waters") "Iteration")
     (("JonL" "White") "Iteration")
     (("Dick" "Gabriel") "Objects")
     (("Gregor" "Kiczales") "Objects")
     (("David" "Moon") "Objects"))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note merge::, *Note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects, *Note Section 3.7 (Destructive
Operations): Destructive Operations.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.


File: chris-ansicl.info,  Node: find; find-if; find-if-not,  Next: position; position-if; position-if-not,  Prev: sort; stable-sort,  Up: Sequences

find, find-if, find-if-not (Function)
=====================================

Syntax:
.......

 -- Function: find item sequence &key from-end test test-not start end
          key ý element

 -- Function: find-if predicate sequence &key from-end start end key ý
          element

 -- Function: find-if-not predicate sequence &key from-end start end
          key ý element

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

KEY--a designator for a function of one argument, or ÿnilþ.

ELEMENT--an element of the SEQUENCE, or ÿnilþ.

Description:
............

ÿfindþ, ÿfind-ifþ, and ÿfind-if-notþ each search for an element of the
SEQUENCE bounded by START and end that satisfies the predicate PREDICATE
or that satisfies the test TEST or TEST-NOT, as appropriate.

If FROM-END is true, then the result is the rightmost element that
satisfies the test.

If the SEQUENCE contains an element that satisfies the test, then the
leftmost or rightmost SEQUENCE element, depending on FROM-END, is
returned; otherwise ÿnilþ is returned.

Examples:
.........

 (find #\d "here are some letters that can be looked at" :test #'char>)
ý #\Space
 (find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) ý 3
 (find-if-not #'complexp
             '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))
             :start 2) ý NIL

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note position::, *Note Section 17.2 (Rules about Test Functions):
Rules about Test Functions, *Note Section 3.6 (Traversal Rules and Side
Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ÿfind-if-notþ is deprecated.


File: chris-ansicl.info,  Node: position; position-if; position-if-not,  Next: search,  Prev: find; find-if; find-if-not,  Up: Sequences

position, position-if, position-if-not (Function)
=================================================

Syntax:
.......

 -- Function: position item sequence &key from-end test test-not start
          end key ý position

 -- Function: position-if predicate sequence &key from-end start end
          key ý position

 -- Function: position-if-not predicate sequence &key from-end start
          end key ý position

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

KEY--a designator for a function of one argument, or ÿnilþ.

POSITION--a bounding index of SEQUENCE, or ÿnilþ.

Description:
............

ÿpositionþ, ÿposition-ifþ, and ÿposition-if-notþ each search SEQUENCE
for an element that satisfies the test.

The POSITION returned is the index within SEQUENCE of the leftmost  (if
FROM-END is true) or of the rightmost (if FROM-END is false) element
that satisfies the test; otherwise ÿnilþ is returned.  The index
returned is relative to the left-hand end of the entire SEQUENCE,
regardless of the value of start, end, or from-end.

Examples:
.........

 (position #\a "baobab" :from-end t) ý 4
 (position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) ý 2
 (position 595 '()) ý NIL
 (position-if-not #'integerp '(1 2 3 4 5.0)) ý 4

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note find::, *Note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ÿposition-if-notþ is deprecated.


File: chris-ansicl.info,  Node: search,  Next: mismatch,  Prev: position; position-if; position-if-not,  Up: Sequences

search (Function)
=================

Syntax:
.......

 -- Function: search sequence-1 sequence-2 &key from-end test test-not
          key start1 start2 end1 end2 ý position

Arguments and Values:
.....................

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

START1, END1--bounding index designators of SEQUENCE-1.  The defaults
for START1 and END1 are ÿ0þ and ÿnilþ, respectively.

START2, END2--bounding index designators of SEQUENCE-2.  The defaults
for START2 and END2 are ÿ0þ and ÿnilþ, respectively.

POSITION--a bounding index of SEQUENCE-2, or ÿnilþ.

Description:
............

Searches SEQUENCE-2 for a subsequence that matches SEQUENCE-1.

The implementation may choose to search SEQUENCE-2 in any order; there
is no guarantee on the number of times the test is made.  For example,
when START-END is true, the SEQUENCE might actually be searched from
left to right instead of from right to left (but in either case would
return the rightmost matching subsequence).  If the search succeeds,
ÿsearchþ returns the offset into SEQUENCE-2 of the first element of the
leftmost or rightmost matching subsequence, depending on FROM-END;
otherwise ÿsearchþ returns ÿnilþ.

If FROM-END is true, the index of the leftmost element of the rightmost
matching subsequence is returned.

Examples:
.........

 (search "dog" "it's a dog's life") ý 7
 (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) ý 2

See Also:
.........

*Note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not argument is deprecated.


File: chris-ansicl.info,  Node: mismatch,  Next: replace,  Prev: search,  Up: Sequences

mismatch (Function)
===================

Syntax:
.......

 -- Function: mismatch sequence-1 sequence-2 &key from-end test
          test-not key start1 start2 end1 end2 ý position

Arguments and Values:
.....................

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START1, END1--bounding index designators of SEQUENCE-1.  The defaults
for START1 and END1 are ÿ0þ and ÿnilþ, respectively.

START2, END2--bounding index designators of SEQUENCE-2.  The defaults
for START2 and END2 are ÿ0þ and ÿnilþ, respectively.

KEY--a designator for a function of one argument, or ÿnilþ.

POSITION--a bounding index of SEQUENCE-1, or ÿnilþ.

Description:
............

The specified subsequences of SEQUENCE-1 and SEQUENCE-2 are compared
element-wise.

The KEY argument is used for both the SEQUENCE-1 and the SEQUENCE-2.

If SEQUENCE-1 and SEQUENCE-2 are of equal length and match in every
element, the result is false.  Otherwise, the result is a non-negative
integer, the index within SEQUENCE-1 of the leftmost or rightmost
position, depending on FROM-END, at which the two subsequences fail to
match.  If one subsequence is shorter than and a matching prefix of the
other, the result is the index relative to SEQUENCE-1 beyond the last
position tested.

If FROM-END is true, then one plus the index of the rightmost position
in which the SEQUENCES differ is returned.  In effect, the subsequences
are aligned at their right-hand ends; then, the last elements are
compared, the penultimate elements, and so on.  The index returned is
an index relative to SEQUENCE-1.

Examples:
.........

 (mismatch "abcd" "ABCDE" :test #'char-equal) ý 4
 (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) ý 3
 (mismatch '(1 2 3) '(2 3 4) :test-not #'eq :key #'oddp) ý NIL
 (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) ý NIL

See Also:
.........

*Note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not argument is deprecated.


File: chris-ansicl.info,  Node: replace,  Next: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Prev: mismatch,  Up: Sequences

replace (Function)
==================

Syntax:
.......

 -- Function: replace sequence-1 sequence-2 &key start1 end1 start2
          end2 ý sequence-1

Arguments and Values:
.....................

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

START1, END1--bounding index designators of SEQUENCE-1.  The defaults
for START1 and END1 are ÿ0þ and ÿnilþ, respectively.

START2, END2--bounding index designators of SEQUENCE-2.  The defaults
for START2 and END2 are ÿ0þ and ÿnilþ, respectively.

Description:
............

Destructively modifies SEQUENCE-1 by replacing the elements of
SUBSEQUENCE-1 bounded by START1 and END1 with the elements of
SUBSEQUENCE-2 bounded by START2 and END2.

SEQUENCE-1 is destructively modified by copying successive elements
into it from SEQUENCE-2.  Elements of the subsequence of SEQUENCE-2
bounded by START2 and END2 are copied into the subsequence of SEQUENCE-1
bounded by START1 and END1.  If these subsequences are not of the same
length, then the shorter length determines how many elements are copied;
the extra elements near the end of the longer subsequence are not
involved in the operation.  The number of elements copied can be
expressed as:

 (min (- end1 start1) (- end2 start2))

If SEQUENCE-1 and SEQUENCE-2 are the same object and the region being
modified overlaps the region being copied from, then it is as if the
entire source region were copied to another place and only then copied
back into the target region.  However, if SEQUENCE-1 and SEQUENCE-2 are
not the same, but the region being modified overlaps the region being
copied from (perhaps because of shared list structure or displaced
arrays), then after the ÿreplaceþ operation the subsequence of
SEQUENCE-1 being modified will have unpredictable contents.  It is an
error if the elements of SEQUENCE-2 are not of a type that can be
stored into SEQUENCE-1.

Examples:
.........

 (replace "abcdefghij" "0123456789" :start1 4 :end1 7 :start2 4)
ý "abcd456hij"
 (setq lst "012345678") ý "012345678"
 (replace lst lst :start1 2 :start2 0) ý "010123456"
 lst ý "010123456"

Side Effects:
.............

The SEQUENCE-1 is modified.

See Also:
.........

*Note fill::


File: chris-ansicl.info,  Node: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Next: concatenate,  Prev: replace,  Up: Sequences

substitute, substitute-if, substitute-if-not, nsubstitute, nsubstitute-if, nsubstitute-if-not (Function)
========================================================================================================

Syntax:
.......

 -- Function: substitute newitem olditem sequence &key from-end test
          test-not start end count key ý result-sequence

 -- Function: substitute-if newitem predicate sequence &key from-end
          start end count key ý result-sequence

 -- Function: substitute-if-not newitem predicate sequence &key
          from-end start end count key ý result-sequence

 -- Function: nsubstitute newitem olditem sequence &key from-end test
          test-not start end count key ý sequence

 -- Function: nsubstitute-if newitem predicate sequence &key from-end
          start end count key ý sequence

 -- Function: nsubstitute-if-not newitem predicate sequence &key
          from-end start end count key ý sequence

Arguments and Values:
.....................

NEWITEM--an object.

OLDITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

COUNT--an integer or ÿnilþ.  The default is ÿnilþ.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-SEQUENCE--a sequence.

Description:
............

ÿsubstituteþ, ÿsubstitute-ifþ, and ÿsubstitute-if-notþ return a copy of
SEQUENCE in which each element that satisfies the test has been
replaced with NEWITEM.

ÿnsubstituteþ, ÿnsubstitute-ifþ, and ÿnsubstitute-if-notþ are like
ÿsubstituteþ, ÿsubstitute-ifþ, and ÿsubstitute-if-notþ respectively,
but they may modify SEQUENCE.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

COUNT, if supplied, limits the number of elements altered; if more than
COUNT elements satisfy the test, then of these elements only the
leftmost or rightmost, depending on FROM-END, are replaced, as many as
specified by COUNT.  If COUNT is supplied and negative, the behavior is
as if zero had been supplied instead.  If COUNT is ÿnilþ, all matching
items are affected.

Supplying a FROM-END of true matters only when the COUNT is provided
(and non-nil); in that case, only the rightmost COUNT elements
satisfying the test are removed (instead of the leftmost).

PREDICATE, TEST, and TEST-NOT might be called more than once for each
sequence element, and their side effects can happen in any order.

The result of all these functions is a sequence of the same type as
SEQUENCE that has the same elements except that those in the subsequence
bounded by START and END and satisfying the test have been replaced by
NEWITEM.

ÿsubstituteþ, ÿsubstitute-ifþ, and ÿsubstitute-if-notþ return a
SEQUENCE which can share with SEQUENCE or may be identical to the input
SEQUENCE if no elements need to be changed.

ÿnsubstituteþ and  ÿnsubstitute-ifþ are required to ÿsetfþ any ÿcarþ
(if SEQUENCE is a list) or ÿarefþ (if SEQUENCE is a vector) of SEQUENCE
that is required to be replaced with NEWITEM.  If SEQUENCE is a list,
none of the cdrs of the top-level list can be modified.

Examples:
.........

 (substitute #\. #\SPACE "0 2 4 6") ý "0.2.4.6"
 (substitute 9 4 '(1 2 4 1 3 4 5)) ý (1 2 9 1 3 9 5)
 (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) ý (1 2 9 1 3 4 5)
 (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)
ý (1 2 4 1 3 9 5)
 (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) ý (9 9 4 9 3 4 5)

 (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)
ý ((1) (2) (3) 0)
 (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) ý (9 2 4 9 9 4 9)
 (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
ý (1 2 4 1 3 9 5)

 (setq some-things (list 'a 'car 'b 'cdr 'c)) ý (A CAR B CDR C)
 (nsubstitute-if "function was here" #'fboundp some-things
                 :count 1 :from-end t) ý (A CAR B "function was here" C)
 some-things ý (A CAR B "function was here" C)
 (setq alpha-tester (copy-seq "ab ")) ý "ab "
 (nsubstitute-if-not #\z #'alpha-char-p alpha-tester) ý "abz"
 alpha-tester ý "abz"

Side Effects:
.............

ÿnsubstituteþ, ÿnsubstitute-ifþ, and ÿnsubstitute-if-notþ modify
SEQUENCE.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note subst::, *Note nsubst::, *Note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *Note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

The functions ÿsubstitute-if-notþ and ÿnsubstitute-if-notþ are
deprecated.

ÿnsubstituteþ and ÿnsubstitute-ifþ can be used in for-effect-only
positions in code.

Because the side-effecting variants (e.g., ÿnsubstituteþ) potentially
change the path that is being traversed, their effects in the presence
of shared or circular structure may vary in surprising ways when
compared to their non-side-effecting alternatives.  To see this,
consider the following side-effect behavior, which might be exhibited by
some implementations:

 (defun test-it (fn)
   (let ((x (cons 'b nil)))
     (rplacd x x)
     (funcall fn 'a 'b x :count 1)))
 (test-it #'substitute) ý (A . #1=(B . #1#))
 (test-it #'nsubstitute) ý (A . #1#)


File: chris-ansicl.info,  Node: concatenate,  Next: merge,  Prev: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Up: Sequences

concatenate (Function)
======================

Syntax:
.......

 -- Function: concatenate result-type &rest sequences ý result-sequence

Arguments and Values:
.....................

RESULT-TYPE--a ÿsequenceþ type specifier.

SEQUENCES--a sequence.

RESULT-SEQUENCE--a proper sequence of type RESULT-TYPE.

Description:
............

ÿconcatenateþ returns a sequence that contains all the individual
elements of all the SEQUENCES in the order that they are supplied.  The
sequence is of type RESULT-TYPE, which must be a subtype of type
ÿsequenceþ.

All of the SEQUENCES are copied from; the result does not share any
structure with any of the SEQUENCES.  Therefore, if only one SEQUENCE
is provided and it is of type RESULT-TYPE, ÿconcatenateþ is required to
copy SEQUENCE rather than simply returning it.

It is an error if any element of the SEQUENCES cannot be an element of
the sequence result.

If the RESULT-TYPE is a subtype of ÿlistþ, the result will be a list.

If the RESULT-TYPE is a subtype of ÿvectorþ, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ÿ*þ), the element type of the resulting array
is ÿtþ; otherwise, an error is signaled.

Examples:
.........

(concatenate 'string "all" " " "together" " " "now") ý "all together now"
(concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
ý (#\A #\B #\C D E F 1 2 3 1 0 1 1)
(concatenate 'list) ý NIL

  (concatenate '(vector * 2) "a" "bc") should signal an error

Exceptional Situations:
.......................

An error is signaled if the RESULT-TYPE is neither a recognizable
subtype of ÿlistþ, nor a recognizable subtype of ÿvectorþ.

An error of type ÿtype-errorþ should be signaled if RESULT-TYPE
specifies the number of elements and the sum of SEQUENCES is different
from that number.

See Also:
.........

*Note append::


File: chris-ansicl.info,  Node: merge,  Next: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Prev: concatenate,  Up: Sequences

merge (Function)
================

Syntax:
.......

 -- Function: merge result-type sequence-1 sequence-2 predicate &key
          key ý result-sequence

Arguments and Values:
.....................

RESULT-TYPE--a ÿsequenceþ type specifier.

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

PREDICATE--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-SEQUENCE--a proper sequence of type RESULT-TYPE.

Description:
............

Destructively merges SEQUENCE-1 with SEQUENCE-2 according to an order
determined by the PREDICATE.  ÿmergeþ determines the relationship
between two elements by giving keys extracted from the sequence
elements to the PREDICATE.

The first argument to the PREDICATE function is an element of
SEQUENCE-1 as returned by the KEY (if supplied); the second argument is
an element of SEQUENCE-2 as returned by the KEY (if supplied).
PREDICATE should return true if and only if its first argument is
strictly less than the second (in some appropriate sense).  If the
first argument is greater than or equal to the second (in the
appropriate sense), then PREDICATE should return false.  ÿmergeþ
considers two elements ÿxþ and ÿyþ to be equal if ÿ(funcall predicate x
y)þ and ÿ(funcall predicate y x)þ both yield false.

The argument to the KEY is the SEQUENCE element.  Typically, the return
value of the KEY becomes the argument to PREDICATE.  If KEY is not
supplied or ÿnilþ, the sequence element itself is used.  The KEY may be
executed more than once for each sequence element, and its side effects
may occur in any order.

If KEY and PREDICATE return, then the merging operation will terminate.
The result of merging two sequences ÿxþ and ÿyþ is a new sequence of
type RESULT-TYPE ÿzþ, such that the length of ÿzþ is the sum of the
lengths of ÿxþ and ÿyþ, and ÿzþ contains all the elements of ÿxþ and
ÿyþ.  If ÿx1þ and ÿx2þ are two elements of ÿxþ, and ÿx1þ precedes ÿx2þ
in ÿxþ, then ÿx1þ precedes ÿx2þ in ÿzþ, and similarly for elements of
ÿyþ.  In short, ÿzþ is an interleaving of ÿxþ and ÿyþ.

If ÿxþ and ÿyþ were correctly sorted according to the PREDICATE, then
ÿzþ will also be correctly sorted.  If ÿxþ or ÿyþ is not so sorted,
then ÿzþ will not be sorted, but will nevertheless be an interleaving
of ÿxþ and ÿyþ.

The merging operation is guaranteed stable; if two or more elements are
considered equal by the PREDICATE, then the elements from SEQUENCE-1
will precede those from SEQUENCE-2 in the result.

SEQUENCE-1 and/or SEQUENCE-2 may be destroyed.

If the RESULT-TYPE is a subtype of ÿlistþ, the result will be a list.

If the RESULT-TYPE is a subtype of ÿvectorþ, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ÿ*þ), the element type of the resulting array
is ÿtþ; otherwise, an error is signaled.

Examples:
.........

 (setq test1 (list 1 3 4 6 7))
 (setq test2 (list 2 5 8))
 (merge 'list test1 test2 #'<) ý (1 2 3 4 5 6 7 8)
 (setq test1 (copy-seq "BOY"))
 (setq test2 (copy-seq :nosy"))
 (merge 'string test1 test2 #'char-lessp) ý "BnOosYy"
 (setq test1 (vector ((red . 1) (blue . 4))))
 (setq test2 (vector ((yellow . 2) (green . 7))))
 (merge 'vector test1 test2 #'< :key #'cdr)
ý #((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7))

 (merge '(vector * 4) '(1 5) '(2 4 6) #'<) should signal an error

Exceptional Situations:
.......................

An error must be signaled if the RESULT-TYPE is neither a recognizable
subtype of ÿlistþ, nor a recognizable subtype of ÿvectorþ.

An error of type ÿtype-errorþ should be signaled if RESULT-TYPE
specifies the number of elements and the sum of the lengths of
SEQUENCE-1 and SEQUENCE-2 is different from that number.

See Also:
.........

*Note sort::, *Note stable-sort::, *Note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *Note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.


File: chris-ansicl.info,  Node: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Next: remove-duplicates; delete-duplicates,  Prev: merge,  Up: Sequences

remove, remove-if, remove-if-not, delete, delete-if, delete-if-not (Function)
=============================================================================

Syntax:
.......

 -- Function: remove item sequence &key from-end test test-not start
          end count key ý result-sequence

 -- Function: remove-if test sequence &key from-end start end count key
          ý result-sequence

 -- Function: remove-if-not test sequence &key from-end start end count
          key ý result-sequence

 -- Function: delete item sequence &key from-end test test-not start
          end count key ý result-sequence

 -- Function: delete-if test sequence &key from-end start end count key
          ý result-sequence

 -- Function: delete-if-not test sequence &key from-end start end count
          key ý result-sequence

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

TEST--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

COUNT--an integer or ÿnilþ.  The default is ÿnilþ.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-SEQUENCE--a sequence.

Description:
............

ÿremoveþ, ÿremove-ifþ, and ÿremove-if-notþ return a SEQUENCE from which
the elements that satisfy the test have been removed.

ÿdeleteþ, ÿdelete-ifþ, and ÿdelete-if-notþ are like ÿremoveþ,
ÿremove-ifþ, and ÿremove-if-notþ respectively, but they may modify
SEQUENCE.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

Supplying a FROM-END of true matters only when the COUNT is provided;
in that case only the rightmost COUNT elements satisfying the test are
deleted.

COUNT, if supplied, limits the number of elements removed or deleted;
if more than COUNT elements satisfy the test, then of these elements
only the leftmost or rightmost, depending on FROM-END, are deleted or
removed, as many as specified by COUNT.  If COUNT is supplied and
negative, the behavior is as if zero had been supplied instead.  If
COUNT is ÿnilþ, all matching items are affected.

For all these functions, elements not removed or deleted occur in the
same order in the result as they did in SEQUENCE.

ÿremoveþ, ÿremove-ifþ, ÿremove-if-notþ return a sequence of the same
type as SEQUENCE that has the same elements except that those in the
subsequence bounded by START and END and satisfying the test have been
removed.  This is a non-destructive operation. If any elements need to
be removed, the result will be a copy.  The result of ÿremoveþ may share
with SEQUENCE; the result may be identical to the input SEQUENCE if no
elements need to be removed.

ÿdeleteþ, ÿdelete-ifþ, and ÿdelete-if-notþ return a sequence of the
same type as SEQUENCE that has the same elements except that those in
the subsequence bounded by START and END and satisfying the test have
been deleted.  SEQUENCE may be destroyed and used to construct the
result; however, the result might or might not be identical to SEQUENCE.

ÿdeleteþ, when SEQUENCE is a list, is permitted to ÿsetfþ any part,
ÿcarþ or ÿcdrþ, of the top-level list structure in that SEQUENCE.  When
SEQUENCE is a vector,  ÿdeleteþ is permitted to change the dimensions
of the vector and to slide its elements into new positions without
permuting them to produce the resulting vector.

ÿdelete-ifþ is constrained to behave exactly as follows:

 (delete nil sequence
             :test #'(lambda (ignore item) (funcall test item))
             ...)

Examples:
.........

 (remove 4 '(1 3 4 5 9)) ý (1 3 5 9)
 (remove 4 '(1 2 4 1 3 4 5)) ý (1 2 1 3 5)
 (remove 4 '(1 2 4 1 3 4 5) :count 1) ý (1 2 1 3 4 5)
 (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) ý (1 2 4 1 3 5)
 (remove 3 '(1 2 4 1 3 4 5) :test #'>) ý (4 3 4 5)
 (setq lst '(list of four elements)) ý (LIST OF FOUR ELEMENTS)
 (setq lst2 (copy-seq lst)) ý (LIST OF FOUR ELEMENTS)
 (setq lst3 (delete 'four lst)) ý (LIST OF ELEMENTS)
 (equal lst lst2) ý false
 (remove-if #'oddp '(1 2 4 1 3 4 5)) ý (2 4 4)
 (remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
ý (1 2 4 1 3 5)
 (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)
ý (1 2 3 4 5 6 8)
 (setq tester (list 1 2 4 1 3 4 5)) ý (1 2 4 1 3 4 5)
 (delete 4 tester) ý (1 2 1 3 5)
 (setq tester (list 1 2 4 1 3 4 5)) ý (1 2 4 1 3 4 5)
 (delete 4 tester :count 1) ý (1 2 1 3 4 5)
 (setq tester (list 1 2 4 1 3 4 5)) ý (1 2 4 1 3 4 5)
 (delete 4 tester :count 1 :from-end t) ý (1 2 4 1 3 5)
 (setq tester (list 1 2 4 1 3 4 5)) ý (1 2 4 1 3 4 5)
 (delete 3 tester :test #'>) ý (4 3 4 5)
 (setq tester (list 1 2 4 1 3 4 5)) ý (1 2 4 1 3 4 5)
 (delete-if #'oddp tester) ý (2 4 4)
 (setq tester (list 1 2 4 1 3 4 5)) ý (1 2 4 1 3 4 5)
 (delete-if #'evenp tester :count 1 :from-end t) ý (1 2 4 1 3 5)
 (setq tester (list 1 2 3 4 5 6)) ý (1 2 3 4 5 6)
 (delete-if #'evenp tester) ý (1 3 5)
 tester ý implementation-dependent

 (setq foo (list 'a 'b 'c)) ý (A B C)
 (setq bar (cdr foo)) ý (B C)
 (setq foo (delete 'b foo)) ý (A C)
 bar ý ((C)) or ...
 (eq (cdr foo) (car bar)) ý T or ...

Side Effects:
.............

For ÿdeleteþ, ÿdelete-ifþ, and ÿdelete-if-notþ, SEQUENCE may be
destroyed and used to construct the result.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.

See Also:
.........

*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *Note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

The functions ÿdelete-if-notþ and ÿremove-if-notþ are deprecated.


File: chris-ansicl.info,  Node: remove-duplicates; delete-duplicates,  Prev: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Up: Sequences

remove-duplicates, delete-duplicates (Function)
===============================================

Syntax:
.......

 -- Function: remove-duplicates sequence &key from-end test test-not
          start end key ý result-sequence

 -- Function: delete-duplicates sequence &key from-end test test-not
          start end key ý result-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

KEY--a designator for a function of one argument, or ÿnilþ.

RESULT-SEQUENCE--a sequence.

Description:
............

ÿremove-duplicatesþ returns a modified copy of SEQUENCE from which any
element that matches another element occurring in SEQUENCE has been
removed.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

ÿdelete-duplicatesþ is like ÿremove-duplicatesþ, but
ÿdelete-duplicatesþ may modify SEQUENCE.

The elements of SEQUENCE are compared pairwise, and if any two match,
then the one occurring earlier in SEQUENCE is discarded, unless
FROM-END is true, in which case the one later in SEQUENCE is discarded.

ÿremove-duplicatesþ and ÿdelete-duplicatesþ return a sequence of the
same type as SEQUENCE with enough elements removed so that no two of
the remaining elements match.  The order of the elements remaining in
the result is the same as the order in which they appear in SEQUENCE.

ÿremove-duplicatesþ returns a sequence that may share with SEQUENCE or
may be identical to SEQUENCE if no elements need to be removed.

ÿdelete-duplicatesþ, when SEQUENCE is a list, is permitted to ÿsetfþ
any part, ÿcarþ or ÿcdrþ, of the top-level list structure in that
SEQUENCE.  When SEQUENCE is a vector, ÿdelete-duplicatesþ is permitted
to change the dimensions of the vector and to slide its elements into
new positions without permuting them to produce the resulting vector.

Examples:
.........

 (remove-duplicates "aBcDAbCd" :test #'char-equal :from-end t) ý "aBcD"
 (remove-duplicates '(a b c b d d e)) ý (A C B D E)
 (remove-duplicates '(a b c b d d e) :from-end t) ý (A B C D E)
 (remove-duplicates '((foo #\a) (bar #\%) (baz #\A))
     :test #'char-equal :key #'cadr) ý ((BAR #\%) (BAZ #\A))
 (remove-duplicates '((foo #\a) (bar #\%) (baz #\A))
     :test #'char-equal :key #'cadr :from-end t) ý ((FOO #\a) (BAR #\%))
 (setq tester (list 0 1 2 3 4 5 6))
 (delete-duplicates tester :key #'oddp :start 1 :end 6) ý (0 4 5 6)

Side Effects:
.............

ÿdelete-duplicatesþ might destructively modify SEQUENCE.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SEQUENCE is not a proper
sequence.

See Also:
.........

*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *Note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

These functions are useful for converting SEQUENCE into a canonical
form suitable for representing a set.


File: chris-ansicl.info,  Node: Hash Tables,  Next: Filenames,  Prev: Sequences,  Up: Top

18 Hash Tables
**************

* Menu:

* Hash Table Concepts::

Dictionary

* hash-table::
* make-hash-table::
* hash-table-p::
* hash-table-count::
* hash-table-rehash-size::
* hash-table-rehash-threshold::
* hash-table-size::
* hash-table-test::
* gethash::
* remhash::
* maphash::
* with-hash-table-iterator::
* clrhash::
* sxhash::


File: chris-ansicl.info,  Node: Hash Table Concepts,  Next: hash-table,  Up: Hash Tables

18.1 Hash Table Concepts
========================

* Menu:

* Hash-Table Operations::
* Modifying Hash Table Keys::


File: chris-ansicl.info,  Node: Hash-Table Operations,  Next: Modifying Hash Table Keys,  Up: Hash Table Concepts

18.1.1 Hash-Table Operations
----------------------------

The next figure lists some defined names that are applicable to hash
tables.  The following rules apply to hash tables.

   - A hash table can only associate one value with a given key. If an
     attempt is made to add a second value for a given key, the second
     value will replace the first.  Thus, adding a value to a hash
     table is a destructive operation; the hash table is modified.

   - There are four kinds of hash tables: those whose keys are compared
     with ÿeqþ, those whose keys are compared with ÿeqlþ, those whose
     keys are compared with ÿequalþ, and those whose keys are compared
     with ÿequalpþ.

   - Hash tables are created by ÿmake-hash-tableþ.  ÿgethashþ is used
     to look up a key and find the associated value.  New entries are
     added to hash tables using ÿsetfþ with ÿgethashþ.  ÿremhashþ is
     used to remove an entry.  For example:

      (setq a (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32536573>
      (setf (gethash 'color a) 'brown) ý BROWN
      (setf (gethash 'name a) 'fred) ý FRED
      (gethash 'color a) ý BROWN, true
      (gethash 'name a) ý FRED, true
      (gethash 'pointy a) ý NIL, false

     In this example, the symbols ÿcolorþ and ÿnameþ are being used as
     keys, and the symbols ÿbrownþ and ÿfredþ are being used as the
     associated values.  The hash table has two items in it, one of
     which associates from ÿcolorþ to ÿbrownþ, and the other of which
     associates from ÿnameþ to ÿfredþ.

   - A key or a value may be any object.

   - The existence of an entry in the hash table can be determined from
     the secondary value returned by ÿgethashþ.

clrhash            hash-table-p      remhash
gethash            make-hash-table   sxhash
hash-table-count   maphash           

Figure 18.1: Hash-table defined names


File: chris-ansicl.info,  Node: Modifying Hash Table Keys,  Prev: Hash-Table Operations,  Up: Hash Table Concepts

18.1.2 Modifying Hash Table Keys
--------------------------------

The function supplied as the :test argument to ÿmake-hash-tableþ
specifies the `equivalence test' for the hash table it creates.

An object is `visibly modified' with regard to an equivalence test if
there exists some set of objects (or potential objects) which are
equivalent to the object before the modification but are no longer
equivalent afterwards.

If an object Oá is used as a key in a hash table H and is then visibly
modified with regard to the equivalence test of H, then the
consequences are unspecified if Oá, or any object Oà equivalent to Oá
under the equivalence test (either before or after the modification),
is used as a key in further operations on H.  The consequences of using
Oá as a key are unspecified even if Oá is visibly modified and then
later modified again in such a way as to undo the visible modification.

Following are specifications of the modifications which are visible to
the equivalence tests which must be supported by hash tables.  The
modifications are described in terms of modification of components, and
are defined recursively.  Visible modifications of components of the
object are visible modifications of the object.

18.1.2.1 Visible Modification of Objects with respect to EQ and EQL
...................................................................

No standardized function is provided that is capable of visibly
modifying an object with regard to ÿeqþ or ÿeqlþ.

18.1.2.2 Visible Modification of Objects with respect to EQUAL
..............................................................

As a consequence of the behavior for ÿequalþ, the rules for visible
modification of objects not explicitly mentioned in this section are
inherited from those in *Note Section 18.1.2.1 (Visible Modification of
Objects with respect to EQ and EQL): VisModEQL.

18.1.2.2.1 Visible Modification of Conses with respect to EQUAL
...............................................................

Any visible change to the car or the cdr of a cons is considered a
visible modification with regard to ÿequalþ.

18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL
................................................................................

For a vector of type ÿbit-vectorþ or of type ÿstringþ, any visible
change to an active element of the vector, or to the length of the
vector (if it is actually adjustable or has a fill pointer) is
considered a visible modification with regard to ÿequalþ.

18.1.2.3 Visible Modification of Objects with respect to EQUALP
...............................................................

As a consequence of the behavior for ÿequalpþ, the rules for visible
modification of objects not explicitly mentioned in this section are
inherited from those in *Note Section 18.1.2.2 (Visible Modification of
Objects with respect to EQUAL): VisModEQUAL.

18.1.2.3.1 Visible Modification of Structures with respect to EQUALP
....................................................................

Any visible change to a slot of a structure is considered a visible
modification with regard to ÿequalpþ.

18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP
................................................................

In an array, any visible change to an active element, to the fill
pointer (if the array can and does have one), or to the dimensions (if
the array is actually adjustable) is considered a visible modification
with regard to ÿequalpþ.

18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP
.....................................................................

In a hash table, any visible change to the count of entries in the hash
table, to the keys, or to the values associated with the keys is
considered a visible modification with regard to ÿequalpþ.

Note that the visibility of modifications to the keys depends on the
equivalence test of the hash table, not on the specification of
ÿequalpþ.

18.1.2.4 Visible Modifications by Language Extensions
.....................................................

Implementations that extend the language by providing additional mutator
functions (or additional behavior for existing mutator functions) must
document how the use of these extensions interacts with equivalence
tests and hash table searches.

Implementations that extend the language by defining additional
acceptable equivalence tests for hash tables (allowing additional
values for the :test argument to ÿmake-hash-tableþ) must document the
visible components of these tests.


File: chris-ansicl.info,  Node: hash-table,  Next: make-hash-table,  Prev: Hash Table Concepts,  Up: Hash Tables

hash-table (System Class)
=========================

Class Precedence List:
......................

ÿhash-tableþ, ÿtþ

Description:
............

Hash tables provide a way of mapping any object (a key) to an
associated object (a value).

See Also:
.........

*Note Section 18.1 (Hash Table Concepts): Hash Table Concepts, *Note
Section 22.1.3.13 (Printing Other Objects): PrintingOtherObjects.

Notes:
......

The intent is that this mapping be implemented by a hashing mechanism,
such as that described in Section 6.4 "Hashing" of `The Art of Computer
Programming, Volume 3' (pp506-549).  In spite of this intent, no
conforming implementation is required to use any particular technique
to implement the mapping.


File: chris-ansicl.info,  Node: make-hash-table,  Next: hash-table-p,  Prev: hash-table,  Up: Hash Tables

make-hash-table (Function)
==========================

Syntax:
.......

 -- Function: make-hash-table &key test size rehash-size
          rehash-threshold ý hash-table

Arguments and Values:
.....................

TEST--a designator for one of the functions ÿeqþ, ÿeqlþ, ÿequalþ, or
ÿequalpþ.  The default is ÿeqlþ.

SIZE--a non-negative integer.  The default is implementation-dependent.

REHASH-SIZE--a real of type ÿ(or (integer 1 *) (float (1.0) *))þ.  The
default is implementation-dependent.

REHASH-THRESHOLD--a real of type ÿ(real 0 1)þ.  The default is
implementation-dependent.

HASH-TABLE--a hash table.

Description:
............

Creates and returns a new hash table.

TEST determines how keys are compared.  An object is said to be present
in the HASH-TABLE if that object is the same under the test as the key
for some entry in the HASH-TABLE.

SIZE is a hint to the implementation about how much initial space to
allocate in the HASH-TABLE.  This information, taken together with the
REHASH-THRESHOLD, controls the approximate number of entries which it
should be possible to insert before the table has to grow.  The actual
size might be rounded up from SIZE to the next `good' size; for
example, some implementations might round to the next prime number.

REHASH-SIZE specifies a minimum amount to increase the size of the
HASH-TABLE when it becomes full enough to require rehashing; see
REHASH-THESHOLD below.  If REHASH-SIZE is an integer, the expected
growth rate for the table is additive and the integer is the number of
entries to add; if it is a float, the expected growth rate for the
table is multiplicative and the float is the ratio of the new size to
the old size.  As with SIZE, the actual size of the increase might be
rounded up.

REHASH-THRESHOLD specifies how full the HASH-TABLE can get before it
must grow.  It specifies the maximum desired hash-table occupancy level.

The values of REHASH-SIZE and REHASH-THRESHOLD do not constrain the
implementation to use any particular method for computing when and by
how much the size of HASH-TABLE should be enlarged.  Such decisions are
implementation-dependent, and these values only hints from the
programmer to the implementation, and the implementation is permitted
to ignore them.

Examples:
.........

 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 46142754>
 (setf (gethash "one" table) 1) ý 1
 (gethash "one" table) ý NIL, false
 (setq table (make-hash-table :test 'equal)) ý #<HASH-TABLE EQUAL 0/139 46145547>
 (setf (gethash "one" table) 1) ý 1
 (gethash "one" table) ý 1, T
 (make-hash-table :rehash-size 1.5 :rehash-threshold 0.7)
ý #<HASH-TABLE EQL 0/120 46156620>

See Also:
.........

*Note gethash::, *Note hash-table::


File: chris-ansicl.info,  Node: hash-table-p,  Next: hash-table-count,  Prev: make-hash-table,  Up: Hash Tables

hash-table-p (Function)
=======================

Syntax:
.......

 -- Function: hash-table-p object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿhash-tableþ; otherwise, returns
false.

Examples:
.........

 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32511220>
 (hash-table-p table) ý true
 (hash-table-p 37) ý false
 (hash-table-p '((a . 1) (b . 2))) ý false

Notes:
......

 (hash-table-p OBJECT) Õ (typep OBJECT 'hash-table)


File: chris-ansicl.info,  Node: hash-table-count,  Next: hash-table-rehash-size,  Prev: hash-table-p,  Up: Hash Tables

hash-table-count (Function)
===========================

Syntax:
.......

 -- Function: hash-table-count hash-table ý count

Arguments and Values:
.....................

HASH-TABLE--a hash table.

COUNT--a non-negative integer.

Description:
............

Returns the number of entries in the HASH-TABLE.  If HASH-TABLE has
just been created or newly cleared (see ÿclrhashþ) the entry count is
ÿ0þ.

Examples:
.........

 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32115135>
 (hash-table-count table) ý 0
 (setf (gethash 57 table) "fifty-seven") ý "fifty-seven"
 (hash-table-count table) ý 1
 (dotimes (i 100) (setf (gethash i table) i)) ý NIL
 (hash-table-count table) ý 100

Affected By:
............

ÿclrhashþ, ÿremhashþ, ÿsetfþ of ÿgethashþ

See Also:
.........

*Note hash-table-size::

Notes:
......

The following relationships are functionally correct, although in
practice using ÿhash-table-countþ is probably much faster:

 (hash-table-count TABLE) Õ
 (loop for value being the hash-values of TABLE count t) Õ
 (let ((total 0))
   (maphash #'(lambda (key value)
                (declare (ignore key value))
                (incf total))
            TABLE)
   total)


File: chris-ansicl.info,  Node: hash-table-rehash-size,  Next: hash-table-rehash-threshold,  Prev: hash-table-count,  Up: Hash Tables

hash-table-rehash-size (Function)
=================================

Syntax:
.......

 -- Function: hash-table-rehash-size hash-table ý rehash-size

Arguments and Values:
.....................

HASH-TABLE--a hash table.

REHASH-SIZE--a real of type ÿ(or (integer 1 *) (float (1.0) *))þ.

Description:
............

Returns the current rehash size of HASH-TABLE, suitable for use in a
call to ÿmake-hash-tableþ in order to produce a hash table with state
corresponding to the current state of the HASH-TABLE.

Examples:
.........

 (setq table (make-hash-table :size 100 :rehash-size 1.4))
ý #<HASH-TABLE EQL 0/100 2556371>
 (hash-table-rehash-size table) ý 1.4

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if HASH-TABLE is not a hash
table.

See Also:
.........

*Note make-hash-table::, *Note hash-table-rehash-threshold::

Notes:
......

If the hash table was created with an integer rehash size, the result
is an integer, indicating that the rate of growth of the HASH-TABLE
when rehashed is intended to be additive; otherwise, the result is a
float, indicating that the rate of growth of the HASH-TABLE when
rehashed is intended to be multiplicative.  However, this value is only
advice to the implementation; the actual amount by which the HASH-TABLE
will grow upon rehash is implementation-dependent.


File: chris-ansicl.info,  Node: hash-table-rehash-threshold,  Next: hash-table-size,  Prev: hash-table-rehash-size,  Up: Hash Tables

hash-table-rehash-threshold (Function)
======================================

Syntax:
.......

 -- Function: hash-table-rehash-threshold hash-table ý rehash-threshold

Arguments and Values:
.....................

HASH-TABLE--a hash table.

REHASH-THRESHOLD--a real of type ÿ(real 0 1)þ.

Description:
............

Returns the current rehash threshold of HASH-TABLE, which is suitable
for use in a call to ÿmake-hash-tableþ in order to produce a hash table
with state corresponding to the current state of the HASH-TABLE.

Examples:
.........

 (setq table (make-hash-table :size 100 :rehash-threshold 0.5))
ý #<HASH-TABLE EQL 0/100 2562446>
 (hash-table-rehash-threshold table) ý 0.5

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if HASH-TABLE is not a hash
table.

See Also:
.........

*Note make-hash-table::, *Note hash-table-rehash-size::


File: chris-ansicl.info,  Node: hash-table-size,  Next: hash-table-test,  Prev: hash-table-rehash-threshold,  Up: Hash Tables

hash-table-size (Function)
==========================

Syntax:
.......

 -- Function: hash-table-size hash-table ý size

Arguments and Values:
.....................

HASH-TABLE--a hash table.

SIZE--a non-negative integer.

Description:
............

Returns the current size of HASH-TABLE, which is suitable for use in a
call to ÿmake-hash-tableþ in order to produce a hash table with state
corresponding to the current state of the HASH-TABLE.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if HASH-TABLE is not a hash
table.

See Also:
.........

*Note hash-table-count::, *Note make-hash-table::


File: chris-ansicl.info,  Node: hash-table-test,  Next: gethash,  Prev: hash-table-size,  Up: Hash Tables

hash-table-test (Function)
==========================

Syntax:
.......

 -- Function: hash-table-test hash-table ý test

Arguments and Values:
.....................

HASH-TABLE--a hash table.

TEST--a function designator.  For the four standardized hash table test
functions (see ÿmake-hash-tableþ), the TEST value returned is always a
symbol.  If an implementation permits additional tests, it is
implementation-dependent whether such tests are returned as function
objects or function names.

Description:
............

Returns the test used for comparing keys in HASH-TABLE.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if HASH-TABLE is not a hash
table.

See Also:
.........

*Note make-hash-table::


File: chris-ansicl.info,  Node: gethash,  Next: remhash,  Prev: hash-table-test,  Up: Hash Tables

gethash (Accessor)
==================

Syntax:
.......

 -- Function: gethash key hash-table &optional default ý value,
          present-p

(setf (gethash key hash-table &optional default) new-value)

Arguments and Values:
.....................

KEY--an object.

HASH-TABLE--a hash table.

DEFAULT--an object.  The default is ÿnilþ.

VALUE--an object.

PRESENT-P--a generalized boolean.

Description:
............

VALUE is the object in HASH-TABLE whose key is the same as KEY under
the HASH-TABLE's equivalence test.  If there is no such entry, VALUE is
the DEFAULT.

PRESENT-P is true if an entry is found; otherwise, it is false.

ÿsetfþ may be used with ÿgethashþ to modify the value associated with a
given key, or to add a new entry.  When a ÿgethashþ form is used as a
ÿsetfþ PLACE, any DEFAULT which is supplied is evaluated according to
normal left-to-right evaluation rules, but its value is ignored.

Examples:
.........

 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32206334>
 (gethash 1 table) ý NIL, false
 (gethash 1 table 2) ý 2, false
 (setf (gethash 1 table) "one") ý "one"
 (setf (gethash 2 table "two") "two") ý "two"
 (gethash 1 table) ý "one", true
 (gethash 2 table) ý "two", true
 (gethash nil table) ý NIL, false
 (setf (gethash nil table) nil) ý NIL
 (gethash nil table) ý NIL, true
 (defvar *counters* (make-hash-table)) ý *COUNTERS*
 (gethash 'foo *counters*) ý NIL, false
 (gethash 'foo *counters* 0) ý 0, false
 (defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) ý HOW-MANY
 (defun count-it (obj) (incf (how-many obj))) ý COUNT-IT
 (dolist (x '(bar foo foo bar bar baz)) (count-it x))
 (how-many 'foo) ý 2
 (how-many 'bar) ý 3
 (how-many 'quux) ý 0

See Also:
.........

*Note remhash::

Notes:
......

The secondary value, PRESENT-P, can be used to distinguish the absence
of an entry from the presence of an entry that has a value of DEFAULT.


File: chris-ansicl.info,  Node: remhash,  Next: maphash,  Prev: gethash,  Up: Hash Tables

remhash (Function)
==================

Syntax:
.......

 -- Function: remhash key hash-table ý generalized-boolean

Arguments and Values:
.....................

KEY--an object.

HASH-TABLE--a hash table.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Removes the entry for KEY in HASH-TABLE, if any.  Returns true if there
was such an entry, or false otherwise.

Examples:
.........

 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32115666>
 (setf (gethash 100 table) "C") ý "C"
 (gethash 100 table) ý "C", true
 (remhash 100 table) ý true
 (gethash 100 table) ý NIL, false
 (remhash 100 table) ý false

Side Effects:
.............

The HASH-TABLE is modified.


File: chris-ansicl.info,  Node: maphash,  Next: with-hash-table-iterator,  Prev: remhash,  Up: Hash Tables

maphash (Function)
==================

Syntax:
.......

 -- Function: maphash function hash-table ý ÿnilþ

Arguments and Values:
.....................

FUNCTION--a designator for a function of two arguments, the key and the
value.

HASH-TABLE--a hash table.

Description:
............

Iterates over all entries in the HASH-TABLE.  For each entry, the
FUNCTION is called with two arguments--the key and the value of that
entry.

The consequences are unspecified if any attempt is made to add or remove
an entry from the HASH-TABLE while a ÿmaphashþ is in progress, with two
exceptions: the FUNCTION can use can use ÿsetfþ of ÿgethashþ to change
the value part of the entry currently being processed, or it can use
ÿremhashþ to remove that entry.

Examples:
.........

 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32304110>
 (dotimes (i 10) (setf (gethash i table) i)) ý NIL
 (let ((sum-of-squares 0))
    (maphash #'(lambda (key val)
                 (let ((square (* val val)))
                   (incf sum-of-squares square)
                   (setf (gethash key table) square)))
             table)
    sum-of-squares) ý 285
 (hash-table-count table) ý 10
 (maphash #'(lambda (key val)
               (when (oddp val) (remhash key table)))
           table) ý NIL
 (hash-table-count table) ý 5
 (maphash #'(lambda (k v) (print (list k v))) table)
(0 0)
(8 64)
(2 4)
(6 36)
(4 16)
ý NIL

Side Effects:
.............

None, other than any which might be done by the FUNCTION.

See Also:
.........

*Note loop::, *Note with-hash-table-iterator::, *Note Section 3.6
(Traversal Rules and Side Effects): Traversal Rules and Side Effects.


File: chris-ansicl.info,  Node: with-hash-table-iterator,  Next: clrhash,  Prev: maphash,  Up: Hash Tables

with-hash-table-iterator (Macro)
================================

Syntax:
.......

 -- Macro: with-hash-table-iterator (name hash-table) {declaration}*
          {form}* ý {result}*

Arguments and Values:
.....................

NAME--a name suitable for the first argument to ÿmacroletþ.

HASH-TABLE--a form, evaluated once, that should produce a hash table.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by FORMS.

Description:
............

Within the lexical scope of the body, NAME is defined via ÿmacroletþ
such that successive invocations of ÿ(NAME)þ return the items, one by
one, from the hash table that is obtained by evaluating HASH-TABLE only
once.

An invocation ÿ(NAME)þ returns three values as follows:

  1. A generalized boolean that is true if an entry is returned.

  2. The key from the HASH-TABLE entry.

  3. The value from the HASH-TABLE entry.

After all entries have been returned by successive invocations of
ÿ(NAME)þ, then only one value is returned, namely ÿnilþ.

It is unspecified what happens if any of the implicit interior state of
an iteration is returned outside the dynamic extent of the
ÿwith-hash-table-iteratorþ form such as by returning some closure over
the invocation form.

Any number of invocations of ÿwith-hash-table-iteratorþ can be nested,
and the body of the innermost one can invoke all of the locally
established macros, provided all of those macros have distinct names.

Examples:
.........

The following function should return ÿtþ on any hash table, and signal
an error if the usage of ÿwith-hash-table-iteratorþ does not agree with
the corresponding usage of ÿmaphashþ.

 (defun test-hash-table-iterator (hash-table)
   (let ((all-entries '())
         (generated-entries '())
         (unique (list nil)))
     (maphash #'(lambda (key value) (push (list key value) all-entries))
              hash-table)
     (with-hash-table-iterator (generator-fn hash-table)
       (loop
         (multiple-value-bind (more? key value) (generator-fn)
           (unless more? (return))
           (unless (eql value (gethash key hash-table unique))
             (error "Key ~S not found for value ~S" key value))
           (push (list key value) generated-entries))))
     (unless (= (length all-entries)
                (length generated-entries)
                (length (union all-entries generated-entries
                               :key #'car :test (hash-table-test hash-table))))
       (error "Generated entries and Maphash entries don't correspond"))
     t))

The following could be an acceptable definition of ÿmaphashþ,
implemented by ÿwith-hash-table-iteratorþ.

 (defun maphash (function hash-table)
   (with-hash-table-iterator (next-entry hash-table)
     (loop (multiple-value-bind (more key value) (next-entry)
             (unless more (return nil))
             (funcall function key value)))))

Exceptional Situations:
.......................

The consequences are undefined if the local function named NAME
established by ÿwith-hash-table-iteratorþ is called after it has
returned false as its primary value.

See Also:
.........

*Note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: chris-ansicl.info,  Node: clrhash,  Next: sxhash,  Prev: with-hash-table-iterator,  Up: Hash Tables

clrhash (Function)
==================

Syntax:
.......

 -- Function: clrhash hash-table ý hash-table

Arguments and Values:
.....................

HASH-TABLE--a hash table.

Description:
............

Removes all entries from HASH-TABLE, and then returns that empty hash
table.

Examples:
.........

 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32004073>
 (dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) ý NIL
 (hash-table-count table) ý 100
 (gethash 57 table) ý "fifty-seven", true
 (clrhash table) ý #<HASH-TABLE EQL 0/120 32004073>
 (hash-table-count table) ý 0
 (gethash 57 table) ý NIL, false

Side Effects:
.............

The HASH-TABLE is modified.


File: chris-ansicl.info,  Node: sxhash,  Prev: clrhash,  Up: Hash Tables

sxhash (Function)
=================

Syntax:
.......

 -- Function: sxhash object ý hash-code

Arguments and Values:
.....................

OBJECT--an object.

HASH-CODE--a non-negative fixnum.

Description:
............

ÿsxhashþ returns a hash code for OBJECT.

The manner in which the hash code is computed is
implementation-dependent, but subject to certain constraints:

  1. ÿ(equal X Y)þ implies ÿ(= (sxhash X) (sxhash Y))þ.

  2. For any two objects, X and Y, both of which are bit vectors,
     characters, conses, numbers, pathnames, strings, or symbols, and
     which are similar, ÿ(sxhash X)þ and ÿ(sxhash Y)þ yield the same
     mathematical value even if X and Y exist in different Lisp images
     of the same implementation.  See *Note Section 3.2.4 (Literal
     Objects in Compiled Files): Literal Objects in Compiled Files.

  3. The HASH-CODE for an object is always the same within a single
     session provided that the object is not visibly modified with
     regard to the equivalence test ÿequalþ.  See *Note Section 18.1.2
     (Modifying Hash Table Keys): Modifying Hash Table Keys.

  4. The HASH-CODE is intended for hashing.  This places no verifiable
     constraint on a conforming implementation, but the intent is that
     an implementation should make a good-faith effort to produce
     HASH-CODES that are well distributed within the range of
     non-negative fixnums.

  5. Computation of the HASH-CODE must terminate, even if the OBJECT
     contains circularities.

Examples:
.........

 (= (sxhash (list 'list "ab")) (sxhash (list 'list "ab"))) ý true
 (= (sxhash "a") (sxhash (make-string 1 :initial-element #\a))) ý true
 (let ((r (make-random-state)))
   (= (sxhash r) (sxhash (make-random-state r))))
ý implementation-dependent

Affected By:
............

The implementation.

Notes:
......

Many common hashing needs are satisfied by ÿmake-hash-tableþ and the
related functions on hash tables.  ÿsxhashþ is intended for use where
the pre-defined abstractions are insufficient.  Its main intent is to
allow the user a convenient means of implementing more complicated
hashing paradigms than are provided through hash tables.

The hash codes returned by ÿsxhashþ are not necessarily related to any
hashing strategy used by any other function in Common Lisp.

For objects of types that ÿequalþ compares with ÿeqþ, item 3 requires
that the HASH-CODE be based on some immutable quality of the identity
of the object.  Another legitimate implementation technique would be to
have ÿsxhashþ assign (and cache) a random hash code for these objects,
since there is no requirement that similar but non-ÿeqþ objects have
the same hash code.

Although similarity is defined for symbols in terms of both the
symbol's name and the packages in which the symbol is accessible, item
3 disallows using package information to compute the hash code, since
changes to the package status of a symbol are not visible to EQUAL.


File: chris-ansicl.info,  Node: Filenames,  Next: Files,  Prev: Hash Tables,  Up: Top

19 Filenames
************

* Menu:

* Overview of Filenames::
* Pathnames::
* Logical Pathnames::

Dictionary

* pathname (System Class)::
* logical-pathname (System Class)::
* pathname (Function)::
* make-pathname::
* pathnamep::
* pathname-host; pathname-device; pathname-directory; pathname-name; path+::
* load-logical-pathname-translations::
* logical-pathname-translations::
* logical-pathname (Function)::
* *default-pathname-defaults*::
* namestring; file-namestring; directory-namestring; host-namestring; eno+::
* parse-namestring::
* wild-pathname-p::
* pathname-match-p::
* translate-logical-pathname::
* translate-pathname::
* merge-pathnames::


File: chris-ansicl.info,  Node: Overview of Filenames,  Next: Pathnames,  Up: Filenames

19.1 Overview of Filenames
==========================

There are many kinds of file systems, varying widely both in their
superficial syntactic details, and in their underlying power and
structure.  The facilities provided by Common Lisp for referring to and
manipulating files has been chosen to be compatible with many kinds of
file systems, while at the same time minimizing the program-visible
differences between kinds of file systems.

Since file systems vary in their conventions for naming files, there
are two distinct ways to represent filenames: as namestrings and as
pathnames.

* Menu:

* Namestrings as Filenames::
* Pathnames as Filenames::
* Parsing Namestrings Into Pathnames::


File: chris-ansicl.info,  Node: Namestrings as Filenames,  Next: Pathnames as Filenames,  Up: Overview of Filenames

19.1.1 Namestrings as Filenames
-------------------------------

A "namestring" is a string that represents a filename.

In general, the syntax of namestrings involves the use of
implementation-defined conventions, usually those customary for the
file system in which the named file resides.  The only exception is the
syntax of a logical pathname namestring, which is defined in this
specification; see *Note Section 19.3.1 (Syntax of Logical Pathname
Namestrings): Syntax of Logical Pathname Namestrings.

A conforming program must never unconditionally use a literal
namestring other than a logical pathname namestring because Common
Lisp does not define any namestring syntax other than that for logical
pathnames that would be guaranteed to be portable.  However, a
conforming program can, if it is careful, successfully manipulate
user-supplied data which contains or refers to non-portable namestrings.

A namestring can be coerced to a pathname by the functions ÿpathnameþ
or ÿparse-namestringþ.


File: chris-ansicl.info,  Node: Pathnames as Filenames,  Next: Parsing Namestrings Into Pathnames,  Prev: Namestrings as Filenames,  Up: Overview of Filenames

19.1.2 Pathnames as Filenames
-----------------------------

"Pathnames" are structured objects that can represent, in an
implementation-independent way, the filenames that are used natively by
an underlying file system.

In addition, pathnames can also represent certain partially composed
filenames for which an underlying file system might not have a specific
namestring representation.

A pathname need not correspond to any file that actually exists, and
more than one pathname can refer to the same file.  For example, the
pathname with a version of :newest might refer to the same file as a
pathname with the same components except a certain number as the
version.  Indeed, a pathname with version :newest might refer to
different files as time passes, because the meaning of such a pathname
depends on the state of the file system.

Some file systems naturally use a structural model for their filenames,
while others do not.  Within the Common Lisp pathname model, all
filenames are seen as having a particular structure, even if that
structure is not reflected in the underlying file system.  The nature
of the mapping between structure imposed by pathnames and the
structure, if any, that is used by the underlying file system is
implementation-defined.

Every pathname has six components: a host, a device, a directory, a
name, a type, and a version.  By naming files with pathnames, Common
Lisp programs can work in essentially the same way even in file systems
that seem superficially quite different.  For a detailed description of
these components, see *Note Section 19.2.1 (Pathname Components):
Pathname Components.

The mapping of the pathname components into the concepts peculiar to
each file system is implementation-defined.  There exist conceivable
pathnames for which there is no mapping to a syntactically valid
filename in a particular implementation.  An implementation may use
various strategies in an attempt to find a mapping; for example, an
implementation may quietly truncate filenames that exceed length
limitations imposed by the underlying file system, or ignore certain
pathname components for which the file system provides no support.  If
such a mapping cannot be found, an error of type ÿfile-errorþ is
signaled.

The time at which this mapping and associated error signaling occurs is
implementation-dependent.  Specifically, it may occur at the time the
pathname is constructed, when coercing a pathname to a namestring, or
when an attempt is made to open or otherwise access the file designated
by the pathname.

The next figure lists some defined names that are applicable to
pathnames.

*default-pathname-defaults*   namestring           pathname-name
directory-namestring          open                 pathname-type
enough-namestring             parse-namestring     pathname-version
file-namestring               pathname             pathnamep
file-string-length            pathname-device      translate-pathname
host-namestring               pathname-directory   truename
make-pathname                 pathname-host        user-homedir-pathname
merge-pathnames               pathname-match-p     wild-pathname-p

Figure 19.1: Pathname Operations


File: chris-ansicl.info,  Node: Parsing Namestrings Into Pathnames,  Prev: Pathnames as Filenames,  Up: Overview of Filenames

19.1.3 Parsing Namestrings Into Pathnames
-----------------------------------------

Parsing is the operation used to convert a namestring into a pathname.
Except in the case of parsing logical pathname namestrings, this
operation is implementation-dependent, because the format of
namestrings is implementation-dependent.

A conforming implementation is free to accommodate other file system
features in its pathname representation and provides a parser that can
process such specifications in namestrings.  Conforming programs must
not depend on any such features, since those features will not be
portable.


File: chris-ansicl.info,  Node: Pathnames,  Next: Logical Pathnames,  Prev: Overview of Filenames,  Up: Filenames

19.2 Pathnames
==============

* Menu:

* Pathname Components::
* Interpreting Pathname Component Values::
* Merging Pathnames::


File: chris-ansicl.info,  Node: Pathname Components,  Next: Interpreting Pathname Component Values,  Up: Pathnames

19.2.1 Pathname Components
--------------------------

A pathname has six components: a host, a device, a directory, a name, a
type, and a version.

19.2.1.1 The Pathname Host Component
....................................

The name of the file system on which the file resides, or the name of a
logical host.

19.2.1.2 The Pathname Device Component
......................................

Corresponds to the "device" or "file structure" concept in many host
file systems: the name of a logical or physical device containing files.

19.2.1.3 The Pathname Directory Component
.........................................

Corresponds to the "directory" concept in many host file systems: the
name of a group of related files.

19.2.1.4 The Pathname Name Component
....................................

The "name" part of a group of files that can be thought of as
conceptually related.

19.2.1.5 The Pathname Type Component
....................................

Corresponds to the "filetype" or "extension" concept in many host file
systems.  This says what kind of file this is.  This component is
always a string, ÿnilþ, :wild, or :unspecific.

19.2.1.6 The Pathname Version Component
.......................................

Corresponds to the "version number" concept in many host file systems.

The version is either a positive integer or a symbol from the following
list: ÿnilþ, :wild, :unspecific, or :newest (refers to the largest
version number that already exists in the file system when reading a
file, or to a version number greater than any already existing in the
file system when writing a new file).  Implementations can define other
special version symbols.


File: chris-ansicl.info,  Node: Interpreting Pathname Component Values,  Next: Merging Pathnames,  Prev: Pathname Components,  Up: Pathnames

19.2.2 Interpreting Pathname Component Values
---------------------------------------------

19.2.2.1 Strings in Component Values
....................................

19.2.2.1.1 Special Characters in Pathname Components
....................................................

Strings in pathname component values never contain special characters
that represent separation between pathname fields, such as slash in
Unix filenames.  Whether separator characters are permitted as part of
a string in a pathname component is implementation-defined; however, if
the implementation does permit it, it must arrange to properly "quote"
the character for the file system when constructing a namestring.  For
example,

 ;; In a TOPS-20 implementation, which uses ^V to quote
 (NAMESTRING (MAKE-PATHNAME :HOST "OZ" :NAME "<TEST>"))
ý #P"OZ:PS:^V<TEST^V>"
notý #P"OZ:PS:<TEST>"

19.2.2.1.2 Case in Pathname Components
......................................

Namestrings always use local file system case conventions, but Common
Lisp functions that manipulate pathname components allow the caller to
select either of two conventions for representing case in component
values by supplying a value for the :case keyword argument.  The next
figure lists the functions relating to pathnames that permit a :case
argument:

make-pathname     pathname-directory   pathname-name
pathname-device   pathname-host        pathname-type

Figure 19.2: Pathname functions using a :CASE argument

19.2.2.1.2.1 Local Case in Pathname Components
..............................................

For the functions in *Note Figure 19.2: PathnameCaseFuns, a value of
:local for the :case argument (the default for these functions)
indicates that the functions should receive and yield strings in
component values as if they were already represented according to the
host file system's convention for case.

If the file system supports both cases, strings given or received as
pathname component values under this protocol are to be used exactly as
written.  If the file system only supports one case, the strings will
be translated to that case.

19.2.2.1.2.2 Common Case in Pathname Components
...............................................

For the functions in *Note Figure 19.2: PathnameCaseFuns, a value of
:common for the :case argument that these functions should receive and
yield strings in component values according to the following
conventions:

   * All uppercase means to use a file system's customary case.

   * All lowercase means to use the opposite of the customary case.

   * Mixed case represents itself.

Note that these conventions have been chosen in such a way that
translation from :local to :common and back to :local is
information-preserving.

19.2.2.2 Special Pathname Component Values
..........................................

19.2.2.2.1 NIL as a Component Value
...................................

As a pathname component value, ÿnilþ represents that the component is
"unfilled"; see *Note Section 19.2.3 (Merging Pathnames): Merging
Pathnames.

The value of any pathname component can be ÿnilþ.

When constructing a pathname, ÿnilþ in the host component might mean a
default host rather than an actual ÿnilþ in some implementations.

19.2.2.2.2 :WILD as a Component Value
.....................................

If :wild is the value of a pathname component, that component is
considered to be a wildcard, which matches anything.

A conforming program must be prepared to encounter a value of :wild as
the value of any pathname component, or as an element of a list that is
the value of the directory component.

When constructing a pathname, a conforming program may use :wild as the
value of any or all of the directory, name, type, or version component,
but must not use :wild as the value of the host, or device component.

If :wild is used as the value of the directory component in the
construction of a pathname, the effect is equivalent to specifying the
list ÿ(:absolute :wild-inferiors)þ, or the same as ÿ(:absolute :wild)þ
in a file system that does not support :wild-inferiors.  

19.2.2.2.3 :UNSPECIFIC as a Component Value
...........................................

If :unspecific is the value of a pathname component, the component is
considered to be "absent" or to "have no meaning" in the filename being
represented by the pathname.

Whether a value of :unspecific is permitted for any component on any
given file system accessible to the implementation is
implementation-defined.  A conforming program must never
unconditionally use a :unspecific as the value of a pathname component
because such a value is not guaranteed to be permissible in all
implementations.  However, a conforming program can, if it is careful,
successfully manipulate user-supplied data which contains or refers to
non-portable pathname components.  And certainly a conforming program
should be prepared for the possibility that any components of a
pathname could be :unspecific.

When readingá the value of any pathname component, conforming programs
should be prepared for the value to be :unspecific.

When writingá the value of any pathname component, the consequences are
undefined if :unspecific is given for a pathname in a file system for
which it does not make sense.

19.2.2.2.3.1 Relation between component values NIL and :UNSPECIFIC
..................................................................

If a pathname is converted to a namestring, the symbols ÿnilþ and
:unspecific cause the field to be treated as if it were empty.  That is,
both ÿnilþ and :unspecific cause the component not to appear in the
namestring.

However, when merging a pathname with a set of defaults, only a
ÿnilþ value for a component will be replaced with the default for that
component, while a value of :unspecific will be left alone as if the
field were "filled"; see the function *Note merge-pathnames:: and *Note
Section 19.2.3 (Merging Pathnames): Merging Pathnames.

19.2.2.3 Restrictions on Wildcard Pathnames
...........................................

Wildcard pathnames can be used with ÿdirectoryþ but not with ÿopenþ,
and return true from ÿwild-pathname-pþ. When examining wildcard
components of a wildcard pathname, conforming programs must be prepared
to encounter any of the following additional values in any component or
any element of a list that is the directory component:

   * The symbol :wild, which matches anything.

   * A string containing implementation-dependent special wildcard
     characters.

   * Any object, representing an implementation-dependent wildcard
     pattern.

19.2.2.4 Restrictions on Examining Pathname Components
......................................................

The space of possible objects that a conforming program must be
prepared to readá as the value of a pathname component is substantially
larger than the space of possible objects that a conforming program is
permitted to writeá into such a component.

While the values discussed in the subsections of this section, in *Note
Section 19.2.2.2 (Special Pathname Component Values):
SpecialComponentValues, and in *Note Section 19.2.2.3 (Restrictions on
Wildcard Pathnames): WildcardRestrictions.  apply to values that might
be seen when reading the component values, substantially more
restrictive rules apply to constructing pathnames; see *Note Section
19.2.2.5 (Restrictions on Constructing Pathnames):
ConstructingPathnames.

When examining pathname components, conforming programs should be aware
of the following restrictions.

19.2.2.4.1 Restrictions on Examining a Pathname Host Component
..............................................................

It is implementation-dependent what object is used to represent the
host.

19.2.2.4.2 Restrictions on Examining a Pathname Device Component
................................................................

The device might be a string, :wild, :unspecific, or ÿnilþ.

Note that :wild might result from an attempt to readá the pathname
component, even though portable programs are restricted from writingá
such a component value; see *Note Section 19.2.2.3 (Restrictions on
Wildcard Pathnames): WildcardRestrictions. and *Note Section 19.2.2.5
(Restrictions on Constructing Pathnames): ConstructingPathnames.

19.2.2.4.3 Restrictions on Examining a Pathname Directory Component
...................................................................

The directory might be a string, :wild, :unspecific, or ÿnilþ.

The directory can be a list of strings and symbols.  The car of the
list is one of the symbols :absolute or :relative , meaning:

:absolute
     A list whose car is the symbol :absolute represents a directory
     path starting from the root directory.  The list ÿ(:absolute)þ
     represents the root directory.  The list ÿ(:absolute "foo" "bar"
     "baz")þ represents the directory called ÿ"/foo/bar/baz"þ in Unix
     (except possibly for case).

:relative
     A list whose car is the symbol :relative represents a directory
     path starting from a default directory.  The list ÿ(:relative)þ
     has the same meaning as ÿnilþ and hence is not used.  The list
     ÿ(:relative "foo" "bar")þ represents the directory named ÿ"bar"þ
     in the directory named ÿ"foo"þ in the default directory.

Each remaining element of the list is a string or a symbol.

Each string names a single level of directory structure.  The strings
should contain only the directory names themselves--no punctuation
characters.

In place of a string, at any point in the list, symbols can occur to
indicate special file notations.  The next figure lists the symbols
that have standard meanings.  Implementations are permitted to add
additional objects of any type that is disjoint from ÿstringþ if
necessary to represent features of their file systems that cannot be
represented with the standard strings and symbols.

Supplying any non-string, including any of the symbols listed below, to
a file system for which it does not make sense signals an error of type
ÿfile-errorþ.  For example, Unix does not support :wild-inferiors in
most implementations.

Symbol            Meaning
----------------------------------------------------------------------- 
:wild             Wildcard match of one level of directory structure
:wild-inferiors   Wildcard match of any number of directory levels
:up               Go upward in directory structure (semantic)
:back             Go upward in directory structure (syntactic)

Figure 19.3: Special Markers In Directory Component

The following notes apply to the previous figure:

Invalid Combinations
     Using :absolute or :wild-inferiors immediately followed by :up or
     :back signals an error of type ÿfile-errorþ.

Syntactic vs Semantic
     "Syntactic" means that the action of :back depends only on the
     pathname and not on the contents of the file system.

     "Semantic" means that the action of :up depends on the contents of
     the file system; to resolve a pathname containing :up to a
     pathname whose directory component contains only :absolute and
     strings requires probing the file system.

     :up differs from :back only in file systems that support multiple
     names for directories, perhaps via symbolic links.  For example,
     suppose that there is a directory ÿ(:absolute "X" "Y" "Z")þ linked
     to ÿ(:absolute "A" "B" "C")þ and there also exist directories
     ÿ(:absolute "A" "B" "Q")þ and ÿ(:absolute "X" "Y" "Q")þ.  Then
     ÿ(:absolute "X" "Y" "Z" :up "Q")þ designates ÿ(:absolute "A" "B"
     "Q")þ while ÿ(:absolute "X" "Y" "Z" :back "Q")þ designates
     ÿ(:absolute "X" "Y" "Q")þ

19.2.2.4.3.1 Directory Components in Non-Hierarchical File Systems
..................................................................

In non-hierarchical file systems, the only valid list values for the
directory component of a pathname are ÿ(:absolute string)þ and
ÿ(:absolute :wild)þ.  :relative directories and the keywords
:wild-inferiors, :up, and :back are not used in non-hierarchical file
systems.

19.2.2.4.4 Restrictions on Examining a Pathname Name Component
..............................................................

The name might be a string, :wild, :unspecific, or ÿnilþ.

19.2.2.4.5 Restrictions on Examining a Pathname Type Component
..............................................................

The type might be a string, :wild, :unspecific, or ÿnilþ.

19.2.2.4.6 Restrictions on Examining a Pathname Version Component
.................................................................

The version can be any symbol or any integer.

The symbol :newest refers to the largest version number that already
exists in the file system when reading, overwriting, appending,
superseding, or directory listing an existing file.  The symbol :newest
refers to the smallest version number greater than any existing version
number when creating a new file.

The symbols ÿnilþ, :unspecific, and :wild have special meanings and
restrictions; see *Note Section 19.2.2.2 (Special Pathname Component
Values): SpecialComponentValues. and *Note Section 19.2.2.5
(Restrictions on Constructing Pathnames): ConstructingPathnames.

Other symbols and integers have implementation-defined meaning.

19.2.2.4.7 Notes about the Pathname Version Component
.....................................................

It is suggested, but not required, that implementations do the
following:

   * Use positive integers starting at 1 as version numbers.

   * Recognize the symbol :oldest to designate the smallest existing
     version number.

   * Use keywords for other special versions.

19.2.2.5 Restrictions on Constructing Pathnames
...............................................

When constructing a pathname from components, conforming programs must
follow these rules:

   * Any component can be ÿnilþ.  ÿnilþ in the host might mean a
     default host rather than an actual ÿnilþ in some implementations.

   * The host, device, directory, name, and type can be strings.  There
     are implementation-dependent limits on the number and type of
     characters in these strings.

   * The directory can be a list of strings and symbols.  There are
     implementation-dependent limits on the list's length and contents.

   * The version can be :newest.

   * Any component can be taken from the corresponding component of
     another pathname.  When the two pathnames are for different file
     systems (in implementations that support multiple file systems),
     an appropriate translation occurs.  If no meaningful translation
     is possible, an error is signaled.  The definitions of
     "appropriate" and "meaningful" are implementation-dependent.

   * An implementation might support other values for some components,
     but a portable program cannot use those values.  A conforming
     program can use implementation-dependent values but this can make
     it non-portable; for example, it might work only with Unix file
     systems.


File: chris-ansicl.info,  Node: Merging Pathnames,  Prev: Interpreting Pathname Component Values,  Up: Pathnames

19.2.3 Merging Pathnames
------------------------

Merging takes a pathname with unfilled components and supplies values
for those components from a source of defaults.

If a component's value is ÿnilþ, that component is considered to be
unfilled.  If a component's value is any non-nil object, including
:unspecific, that component is considered to be filled.

Except as explicitly specified otherwise, for functions that manipulate
or inquire about files in the file system, the pathname argument to
such a function is merged with ÿ*default-pathname-defaults*þ before
accessing the file system (as if by ÿmerge-pathnamesþ).

19.2.3.1 Examples of Merging Pathnames
......................................

Although the following examples are possible to execute only in
implementations which permit :unspecific in the indicated position
andwhich permit four-letter type components, they serve to illustrate
the basic concept of pathname merging.

 (pathname-type
   (merge-pathnames (make-pathname :type "LISP")
                    (make-pathname :type "TEXT")))
ý "LISP"

 (pathname-type
   (merge-pathnames (make-pathname :type nil)
                    (make-pathname :type "LISP")))
ý "LISP"

 (pathname-type
   (merge-pathnames (make-pathname :type :unspecific)
                    (make-pathname :type "LISP")))
ý :UNSPECIFIC


File: chris-ansicl.info,  Node: Logical Pathnames,  Next: pathname (System Class),  Prev: Pathnames,  Up: Filenames

19.3 Logical Pathnames
======================

* Menu:

* Syntax of Logical Pathname Namestrings::
* Logical Pathname Components::


File: chris-ansicl.info,  Node: Syntax of Logical Pathname Namestrings,  Next: Logical Pathname Components,  Up: Logical Pathnames

19.3.1 Syntax of Logical Pathname Namestrings
---------------------------------------------

The syntax of a logical pathname namestring is as follows.  (Note that
unlike many notational descriptions in this document, this is a
syntactic description of character sequences, not a structural
description of objects.)

LOGICAL-PATHNAME::=
     [ûhost HOST-MARKER]
     [ûRELATIVE-DIRECTORY-MARKER] {ûdirectory DIRECTORY-MARKER}*
     [ûname] [TYPE-MARKER ûtype [VERSION-MARKER ûversion]]

HOST::=
     ûword

DIRECTORY::=
     ûword | ûwildcard-word | ûwild-inferiors-word

NAME::=
     ûword | ûwildcard-word

TYPE::=
     ûword | ûwildcard-word

VERSION::=
     ûpos-int | NEWEST-WORD | WILDCARD-VERSION

HOST-MARKER--a colon.

RELATIVE-DIRECTORY-MARKER--a semicolon.

DIRECTORY-MARKER--a semicolon.

TYPE-MARKER--a dot.

VERSION-MARKER--a dot.

WILD-INFERIORS-WORD--The two character sequence "ÿ**þ" (two asterisks).

NEWEST-WORD--The six character sequence "ÿnewestþ" or the six character
sequence "ÿNEWESTþ".

WILDCARD-VERSION--an asterisk.

WILDCARD-WORD--one or more asterisks, uppercase letters, digits, and
hyphens, including at least one asterisk, with no two asterisks
adjacent.

WORD--one or more uppercase letters, digits, and hyphens.

POS-INT--a positive integer.

19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings
..........................................................................

19.3.1.1.1 The Host part of a Logical Pathname Namestring
.........................................................

The HOST must have been defined as a logical pathname host; this can be
done by using ÿsetfþ of ÿlogical-pathname-translationsþ.

The logical pathname host name ÿ"SYS"þ is reserved for the
implementation.  The existence and meaning of ÿSYS:þ logical pathnames
is implementation-defined.

19.3.1.1.2 The Device part of a Logical Pathname Namestring
...........................................................

There is no syntax for a logical pathname device since the device
component of a logical pathname is always :unspecific; see *Note
Section 19.3.2.1 (Unspecific Components of a Logical Pathname):
LogicalPathCompUnspecific.

19.3.1.1.3 The Directory part of a Logical Pathname Namestring
..............................................................

If a RELATIVE-DIRECTORY-MARKER precedes the DIRECTORIES, the directory
component parsed is as relative; otherwise, the directory component is
parsed as absolute.

If a WILD-INFERIORS-MARKER is specified, it parses into :wild-inferiors.

19.3.1.1.4 The Type part of a Logical Pathname Namestring
.........................................................

The TYPE of a logical pathname for a source file is ÿ"LISP"þ.   This
should be translated into whatever type is appropriate in a physical
pathname.

19.3.1.1.5 The Version part of a Logical Pathname Namestring
............................................................

Some file systems do not have VERSIONS.  Logical pathname translation
to such a file system ignores the VERSION.  This implies that a program
cannot rely on being able to store more than one version of a file
named by a logical pathname.

If a WILDCARD-VERSION is specified, it parses into :wild.

19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring
..........................................................

Each asterisk in a WILDCARD-WORD matches a sequence of zero or more
characters.  The WILDCARD-WORD "ÿ*þ" parses into :wild; other
wildcard-words parse into strings.

19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring
.............................................................

When parsing WORDS and WILDCARD-WORDS, lowercase letters are translated
to uppercase.

19.3.1.1.8 Other Syntax in a Logical Pathname Namestring
........................................................

The consequences of using characters other than those specified here in
a logical pathname namestring are unspecified.

The consequences of using any value not specified here as a logical
pathname component are unspecified.


File: chris-ansicl.info,  Node: Logical Pathname Components,  Prev: Syntax of Logical Pathname Namestrings,  Up: Logical Pathnames

19.3.2 Logical Pathname Components
----------------------------------

19.3.2.1 Unspecific Components of a Logical Pathname
....................................................

The device component of a logical pathname is always :unspecific; no
other component of a logical pathname can be :unspecific.

19.3.2.2 Null Strings as Components of a Logical Pathname
.........................................................

The null string, ÿ""þ, is not a valid value for any component of a
logical pathname.


File: chris-ansicl.info,  Node: pathname (System Class),  Next: logical-pathname (System Class),  Prev: Logical Pathnames,  Up: Filenames

pathname (System Class)
=======================

Class Precedence List:
......................

ÿpathnameþ, ÿtþ

Description:
............

A pathname is a structured object which represents a filename.

There are two kinds of pathnames--physical pathnames and logical
pathnames.


File: chris-ansicl.info,  Node: logical-pathname (System Class),  Next: pathname (Function),  Prev: pathname (System Class),  Up: Filenames

logical-pathname (System Class)
===============================

Class Precedence List:
......................

ÿlogical-pathnameþ, ÿpathnameþ, ÿtþ

Description:
............

A pathname that uses a namestring syntax that is
implementation-independent, and that has component values that are
implementation-independent.  Logical pathnames do not refer directly to
filenames

See Also:
.........

*Note Section 20.1 (File System Concepts): File System Concepts, *Note
Section 2.4.8.14 (Sharpsign P): SharpsignP, *Note Section 22.1.3.11
(Printing Pathnames): PrintingPathnames.


File: chris-ansicl.info,  Node: pathname (Function),  Next: make-pathname,  Prev: logical-pathname (System Class),  Up: Filenames

pathname (Function)
===================

Syntax:
.......

 -- Function: pathname pathspec ý pathname

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

PATHNAME--a pathname.

Description:
............

Returns the pathname denoted by PATHSPEC.

If the PATHSPEC designator is a stream, the stream can be either open
or closed; in both cases, the ÿpathnameþ returned corresponds to the
filename used to open the file.  ÿpathnameþ returns the same pathname
for a file stream after it is closed as it did when it was open.

If the PATHSPEC designator is a file stream created by opening a
logical pathname, a logical pathname is returned.

Examples:
.........

 ;; There is a great degree of variability permitted here.  The next
 ;; several examples are intended to illustrate just a few of the many
 ;; possibilities.  Whether the name is canonicalized to a particular
 ;; case (either upper or lower) depends on both the file system and the
 ;; implementation since two different implementations using the same
 ;; file system might differ on many issues.  How information is stored
 ;; internally (and possibly presented in #S notation) might vary,
 ;; possibly requiring `accessors' such as PATHNAME-NAME to perform case
 ;; conversion upon access.  The format of a namestring is dependent both
 ;; on the file system and the implementation since, for example, one
 ;; implementation might include the host name in a namestring, and
 ;; another might not.  #S notation would generally only be used in a
 ;; situation where no appropriate namestring could be constructed for use
 ;; with #P.
 (setq p1 (pathname "test"))
ý #P"CHOCOLATE:TEST" ; with case canonicalization (e.g., VMS)
orý #P"VANILLA:test"   ; without case canonicalization (e.g., Unix)
orý #P"test"
orý #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
orý #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
 (setq p2 (pathname "test"))
ý #P"CHOCOLATE:TEST"
orý #P"VANILLA:test"
orý #P"test"
orý #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
orý #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
 (pathnamep p1) ý true
 (eq p1 (pathname p1)) ý true
 (eq p1 p2)
ý true
orý false
 (with-open-file (stream "test" :direction :output)
   (pathname stream))
ý #P"ORANGE-CHOCOLATE:>Gus>test.lisp.newest"

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: chris-ansicl.info,  Node: make-pathname,  Next: pathnamep,  Prev: pathname (Function),  Up: Filenames

make-pathname (Function)
========================

Syntax:
.......

 -- Function: make-pathname &key host device directory name type
          version defaults case ý pathname

Arguments and Values:
.....................

HOST--a valid physical pathname host.  Complicated defaulting behavior;
see below.

DEVICE--a valid pathname device.  Complicated defaulting behavior; see
below.

DIRECTORY--a valid pathname directory.  Complicated defaulting
behavior; see below.

NAME--a valid pathname name.  Complicated defaulting behavior; see
below.

TYPE--a valid pathname type.  Complicated defaulting behavior; see
below.

VERSION--a valid pathname version.  Complicated defaulting behavior;
see below.

DEFAULTS--a pathname designator.  The default is a pathname whose host
component is the same as the host component of the value of
ÿ*default-pathname-defaults*þ, and whose other components are all ÿnilþ.

CASE--one of :common or :local.  The default is :local.

PATHNAME--a pathname.

Description:
............

Constructs and returns a pathname from the supplied keyword arguments.

After the components supplied explicitly by HOST, DEVICE, DIRECTORY,
NAME, TYPE, and VERSION are filled in, the merging rules used by
ÿmerge-pathnamesþ are used to fill in any unsupplied components from
the defaults supplied by DEFAULTS.

Whenever a pathname is constructed the components may be canonicalized
if appropriate.  For the explanation of the arguments that can be
supplied for each component, see *Note Section 19.2.1 (Pathname
Components): Pathname Components.

If CASE is supplied, it is treated as described in *Note Section
19.2.2.1.2 (Case in Pathname Components): PathnameComponentCase.

The resulting PATHNAME is a logical pathname if and only its host
component is a logical host or a string that names a defined logical
host.

If the DIRECTORY is a string, it should be the name of a top level
directory, and should not contain any punctuation characters; that is,
specifying a string, str, is equivalent to specifying the list
ÿ(:absolute str)þ.  Specifying the symbol :wild is equivalent to
specifying the list ÿ(:absolute :wild-inferiors)þ, or ÿ(:absolute
:wild)þ in a file system that does not support :wild-inferiors.

Examples:
.........

 ;; Implementation A -- an implementation with access to a single
 ;;  Unix file system.  This implementation happens to never display
 ;;  the `host' information in a namestring, since there is only one host.
 (make-pathname :directory '(:absolute "public" "games")
                :name "chess" :type "db")
ý #P"/public/games/chess.db"


 ;; Implementation B -- an implementation with access to one or more
 ;;  VMS file systems.  This implementation displays `host' information
 ;;  in the namestring only when the host is not the local host.
 ;;  It uses a double colon to separate a host name from the host's local
 ;;  file name.
 (make-pathname :directory '(:absolute "PUBLIC" "GAMES")
                :name "CHESS" :type "DB")
ý #P"SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
 (make-pathname :host "BOBBY"
                :directory '(:absolute "PUBLIC" "GAMES")
                :name "CHESS" :type "DB")
ý #P"BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB"


 ;; Implementation C -- an implementation with simultaneous access to
 ;;  multiple file systems from the same Lisp image.  In this
 ;;  implementation, there is a convention that any text preceding the
 ;;  first colon in a pathname namestring is a host name.
 (dolist (case '(:common :local))
   (dolist (host '("MY-LISPM" "MY-VAX" "MY-UNIX"))
     (print (make-pathname :host host :case case
                           :directory '(:absolute "PUBLIC" "GAMES")
                           :name "CHESS" :type "DB"))))
Ö #P"MY-LISPM:>public>games>chess.db"
Ö #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
Ö #P"MY-UNIX:/public/games/chess.db"
Ö #P"MY-LISPM:>public>games>chess.db"
Ö #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
Ö #P"MY-UNIX:/PUBLIC/GAMES/CHESS.DB"
ý NIL

Affected By:
............

The file system.

See Also:
.........

*Note merge-pathnames::, *Note pathname (System Class)::, *Note
logical-pathname (System Class)::, *Note Section 20.1 (File System
Concepts): File System Concepts, *Note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.

Notes:
......

Portable programs should not supply :unspecific for any component.  See
*Note Section 19.2.2.2.3 (.UNSPECIFIC as a Component Value):
UnspecificComponent.


File: chris-ansicl.info,  Node: pathnamep,  Next: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Prev: make-pathname,  Up: Filenames

pathnamep (Function)
====================

Syntax:
.......

 -- Function: pathnamep object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿpathnameþ; otherwise, returns false.

Examples:
.........

 (setq q "test")  ý "test"
 (pathnamep q) ý false
 (setq q (pathname "test"))
ý #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" :TYPE NIL
       :VERSION NIL)
 (pathnamep q) ý true
 (setq q (logical-pathname "SYS:SITE;FOO.SYSTEM"))
ý #P"SYS:SITE;FOO.SYSTEM"
 (pathnamep q) ý true

Notes:
......

 (pathnamep OBJECT) Õ (typep OBJECT 'pathname)


File: chris-ansicl.info,  Node: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Next: load-logical-pathname-translations,  Prev: pathnamep,  Up: Filenames

pathname-host, pathname-device, pathname-directory, pathname-name, pathname-type, pathname-version (Function)
=============================================================================================================

Syntax:
.......

 -- Function: pathname-host pathname &key case ý host

 -- Function: pathname-device pathname &key case ý device

 -- Function: pathname-directory pathname &key case ý directory

 -- Function: pathname-name pathname &key case ý name

 -- Function: pathname-type pathname &key case ý type

 -- Function: pathname-version pathname ý version

Arguments and Values:
.....................

PATHNAME--a pathname designator.

CASE--one of :local or :common.  The default is :local.

HOST--a valid pathname host.

DEVICE--a valid pathname device.

DIRECTORY--a valid pathname directory.

NAME--a valid pathname name.

TYPE--a valid pathname type.

VERSION--a valid pathname version.

Description:
............

These functions return the components of PATHNAME.

If the PATHNAME designator is a pathname, it represents the name used
to open the file. This may be, but is not required to be, the actual
name of the file.

If CASE is supplied, it is treated as described in *Note Section
19.2.2.1.2 (Case in Pathname Components): PathnameComponentCase.

Examples:
.........

 (setq q (make-pathname :host "KATHY"
                        :directory "CHAPMAN"
                        :name "LOGIN" :type "COM"))
ý #P"KATHY::[CHAPMAN]LOGIN.COM"
 (pathname-host q) ý "KATHY"
 (pathname-name q) ý "LOGIN"
 (pathname-type q) ý "COM"

 ;; Because namestrings are used, the results shown in the remaining
 ;; examples are not necessarily the only possible results.  Mappings
 ;; from namestring representation to pathname representation are
 ;; dependent both on the file system involved and on the implementation
 ;; (since there may be several implementations which can manipulate the
 ;; the same file system, and those implementations are not constrained
 ;; to agree on all details). Consult the documentation for each
 ;; implementation for specific information on how namestrings are treated
 ;; that implementation.

 ;; VMS
 (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP"))
ý (:ABSOLUTE "FOO" "BAR")
 (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP") :case :common)
ý (:ABSOLUTE "FOO" "BAR")

 ;; Unix
 (pathname-directory "foo.l") ý NIL
 (pathname-device "foo.l") ý :UNSPECIFIC
 (pathname-name "foo.l") ý "foo"
 (pathname-name "foo.l" :case :local) ý "foo"
 (pathname-name "foo.l" :case :common) ý "FOO"
 (pathname-type "foo.l") ý "l"
 (pathname-type "foo.l" :case :local) ý "l"
 (pathname-type "foo.l" :case :common) ý "L"
 (pathname-type "foo") ý :UNSPECIFIC
 (pathname-type "foo" :case :common) ý :UNSPECIFIC
 (pathname-type "foo.") ý ""
 (pathname-type "foo." :case :common) ý ""
 (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
ý (:ABSOLUTE "foo" "bar")
 (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
ý (:ABSOLUTE "FOO" "BAR")
 (pathname-directory (parse-namestring "../baz.lisp"))
ý (:RELATIVE :UP)
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz"))
ý (:ABSOLUTE "foo" "BAR" :UP "Mum")
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz") :case :common)
ý (:ABSOLUTE "FOO" "bar" :UP "Mum")
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l"))
ý (:ABSOLUTE "foo" :WILD "bar")
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l") :case :common)
ý (:ABSOLUTE "FOO" :WILD "BAR")

 ;; Symbolics LMFS
 (pathname-directory (parse-namestring ">foo>**>bar>baz.lisp"))
ý (:ABSOLUTE "foo" :WILD-INFERIORS "bar")
 (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp"))
ý (:ABSOLUTE "foo" :WILD "bar")
 (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp") :case :common)
ý (:ABSOLUTE "FOO" :WILD "BAR")
 (pathname-device (parse-namestring ">foo>baz.lisp")) ý :UNSPECIFIC

Affected By:
............

The implementation and the host file system.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if its first argument is
not a pathname.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: chris-ansicl.info,  Node: load-logical-pathname-translations,  Next: logical-pathname-translations,  Prev: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Up: Filenames

load-logical-pathname-translations (Function)
=============================================

Syntax:
.......

 -- Function: load-logical-pathname-translations host ý just-loaded

Arguments and Values:
.....................

HOST--a string.

just-loaded--a generalized boolean.

Description:
............

Searches for and loads the definition of a logical host named HOST, if
it is not already defined.  The specific nature of the search is
implementation-defined.

If the HOST is already defined, no attempt to find or load a definition
is attempted, and false is returned.  If the HOST is not already
defined, but a definition is successfully found and loaded, true is
returned.  Otherwise, an error is signaled.

Examples:
.........

 (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
Ö Error: The logical host HACKS is not defined.
 (load-logical-pathname-translations "HACKS")
Ö ;; Loading SYS:SITE;HACKS.TRANSLATIONS
Ö ;; Loading done.
ý true
 (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
ý #P"HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0"
 (load-logical-pathname-translations "HACKS")
ý false

Exceptional Situations:
.......................

If no definition is found, an error of type ÿerrorþ is signaled.

See Also:
.........

*Note logical-pathname (System Class)::

Notes:
......

Logical pathname definitions will be created not just by implementors
but also by programmers.  As such, it is important that the search
strategy be documented.  For example, an implementation might define
that the definition of a HOST is to be found in a file called
"HOST.translations" in some specifically named directory.


File: chris-ansicl.info,  Node: logical-pathname-translations,  Next: logical-pathname (Function),  Prev: load-logical-pathname-translations,  Up: Filenames

logical-pathname-translations (Accessor)
========================================

Syntax:
.......

 -- Function: logical-pathname-translations host ý translations

(setf (logical-pathname-translations host) new-translations)

Arguments and Values:
.....................

HOST--a logical host designator.

TRANSLATIONS, NEW-TRANSLATIONS--a list.

Description:
............

Returns the host's list of translations.  Each translation is a list of
at least two elements: from-wildcard and to-wildcard.  Any additional
elements are implementation-defined.  From-wildcard is a logical
pathname whose host is HOST.  To-wildcard is a pathname.

ÿ(setf (logical-pathname-translations HOST) translations)þ sets a
logical pathname host's list of translations.  If HOST is a string that
has not been previously used as a logical pathname host, a new logical
pathname host is defined; otherwise an existing host's translations are
replaced.  logical pathname host names are compared with ÿstring-equalþ.

When setting the translations list, each from-wildcard can be a logical
pathname whose host is HOST or a logical pathname namestring parseable
by ÿ(parse-namestring string host)þ, where host represents the
appropriate object as defined by ÿparse-namestringþ. Each to-wildcard
can be anything coercible to a pathname by ÿ(pathname to-wildcard)þ.
If to-wildcard coerces to a logical pathname,
ÿtranslate-logical-pathnameþ will perform repeated translation steps
when it uses it.

HOST is either the host component of a logical pathname or a string
that has been defined as a logical pathname host name by ÿsetfþ of
ÿlogical-pathname-translationsþ.

Examples:
.........

 ;;;A very simple example of setting up a logical pathname host.  No
 ;;;translations are necessary to get around file system restrictions, so
 ;;;all that is necessary is to specify the root of the physical directory
 ;;;tree that contains the logical file system.
 ;;;The namestring syntax on the right-hand side is implementation-dependent.
 (setf (logical-pathname-translations "foo")
       '(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "foo:bar;baz;mum.quux.3")
ý #P"MY-LISPM:>library>foo>bar>baz>mum.quux.3"


 ;;;A more complex example, dividing the files among two file servers
 ;;;and several different directories.  This Unix doesn't support
 ;;;:WILD-INFERIORS in the directory, so each directory level must
 ;;;be translated individually.  No file name or type translations
 ;;;are required except for .MAIL to .MBX.
 ;;;The namestring syntax on the right-hand side is implementation-dependent.
 (setf (logical-pathname-translations "prog")
       '(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")
         ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")
         ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")
         ("EXPERIMENTAL;DOCUMENTATION;*.*.*"
                                  "MY-VAX:SYS$DISK:[JOE.DOC]")
         ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")
         ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:mail;save;ideas.mail.3")
ý #P"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3"


 ;;;Example translations for a program that uses three files main.lisp,
 ;;;auxiliary.lisp, and documentation.lisp.  These translations might be
 ;;;supplied by a software supplier as examples.

 ;;;For Unix with long file names
 (setf (logical-pathname-translations "prog")
       '(("CODE;*.*.*"             "/lib/prog/")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
ý #P"/lib/prog/documentation.lisp"

 ;;;For Unix with 14-character file names, using .lisp as the type
 (setf (logical-pathname-translations "prog")
       '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")
         ("CODE;*.*.*"             "/lib/prog/")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
ý #P"/lib/prog/docum.lisp"


 ;;;For Unix with 14-character file names, using .l as the type
 ;;;The second translation shortens the compiled file type to .b
 (setf (logical-pathname-translations "prog")
       `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))
         (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))
                                   ,(logical-pathname "PROG:**;*.B.*"))
         ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")
         ("CODE;*.*.*"             "/lib/prog/")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
ý #P"/lib/prog/documentatio.l"


 ;;;For a Cray with 6 character names and no directories, types, or versions.
 (setf (logical-pathname-translations "prog")
       (let ((l '(("MAIN" "PGMN")
                  ("AUXILIARY" "PGAUX")
                  ("DOCUMENTATION" "PGDOC")))
             (logpath (logical-pathname "prog:code;"))
             (phypath (pathname "XXX")))
         (append
           ;; Translations for source files
           (mapcar #'(lambda (x)
                       (let ((log (first x))
                             (phy (second x)))
                         (list (make-pathname :name log
                                              :type "LISP"
                                              :version :wild
                                              :defaults logpath)
                               (make-pathname :name phy
                                              :defaults phypath))))
                   l)
           ;; Translations for compiled files
           (mapcar #'(lambda (x)
                       (let* ((log (first x))
                              (phy (second x))
                              (com (compile-file-pathname
                                     (make-pathname :name log
                                                    :type "LISP"
                                                    :version :wild
                                                    :defaults logpath))))
                         (setq phy (concatenate 'string phy "B"))
                         (list com
                               (make-pathname :name phy
                                              :defaults phypath))))
                   l))))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
ý #P"PGDOC"

Exceptional Situations:
.......................

If HOST is incorrectly supplied, an error of type ÿtype-errorþ is
signaled.

See Also:
.........

*Note logical-pathname (System Class)::, *Note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

Implementations can define additional functions that operate on logical
pathname hosts, for example to specify additional translation rules or
options.


File: chris-ansicl.info,  Node: logical-pathname (Function),  Next: *default-pathname-defaults*,  Prev: logical-pathname-translations,  Up: Filenames

logical-pathname (Function)
===========================

Syntax:
.......

 -- Function: logical-pathname pathspec ý logical-pathname

Arguments and Values:
.....................

PATHSPEC--a logical pathname, a logical pathname namestring, or a
stream.

LOGICAL-PATHNAME--a logical pathname.

Description:
............

ÿlogical-pathnameþ converts PATHSPEC to a logical pathname and returns
the new logical pathname.  If PATHSPEC is a logical pathname namestring,
it should contain a host component and its following colon.  If
PATHSPEC is a stream, it should be one for which ÿpathnameþ returns a
logical pathname.

If PATHSPEC is a stream, the stream can be either open or closed.
ÿlogical-pathnameþ returns the same logical pathname after a file is
closed as it did when the file was open.  It is an error if PATHSPEC is
a stream that is created with ÿmake-two-way-streamþ, ÿmake-echo-streamþ,
ÿmake-broadcast-streamþ, ÿmake-concatenated-streamþ,
ÿmake-string-input-streamþ, or ÿmake-string-output-streamþ.

Exceptional Situations:
.......................

Signals an error of type ÿtype-errorþ if PATHSPEC isn't supplied
correctly.

See Also:
.........

*Note logical-pathname (System Class)::, *Note
translate-logical-pathname::, *Note Section 19.3 (Logical Pathnames):
Logical Pathnames.


File: chris-ansicl.info,  Node: *default-pathname-defaults*,  Next: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Prev: logical-pathname (Function),  Up: Filenames

*default-pathname-defaults* (Variable)
======================================

Value Type:
...........

a pathname object.

Initial Value:
..............

An implementation-dependent pathname, typically in the working
directory that was current when Common Lisp was started up.

Description:
............

a pathname, used as the default whenever a function needs a default
pathname and one is not supplied.

Examples:
.........

 ;; This example illustrates a possible usage for a hypothetical Lisp running on a
 ;; DEC TOPS-20 file system.  Since pathname conventions vary between Lisp
 ;; implementations and host file system types, it is not possible to provide a
 ;; general-purpose, conforming example.
 *default-pathname-defaults* ý #P"PS:<FRED>"
 (merge-pathnames (make-pathname :name "CALENDAR"))
ý #P"PS:<FRED>CALENDAR"
 (let ((*default-pathname-defaults* (pathname "<MARY>")))
   (merge-pathnames (make-pathname :name "CALENDAR")))
ý #P"<MARY>CALENDAR"

Affected By:
............

The implementation.


File: chris-ansicl.info,  Node: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Next: parse-namestring,  Prev: *default-pathname-defaults*,  Up: Filenames

namestring, file-namestring, directory-namestring, host-namestring, enough-namestring (Function)
================================================================================================

Syntax:
.......

 -- Function: namestring pathname ý namestring

 -- Function: file-namestring pathname ý namestring

 -- Function: directory-namestring pathname ý namestring

 -- Function: host-namestring pathname ý namestring

 -- Function: enough-namestring pathname &optional defaults ý namestring

Arguments and Values:
.....................

PATHNAME--a pathname designator.

DEFAULTS--a pathname designator.  The default is the value of
ÿ*default-pathname-defaults*þ.

NAMESTRING--a string or ÿnilþ.

Description:
............

These functions convert PATHNAME into a namestring.  The name
represented by PATHNAME is returned as a namestring in an
implementation-dependent canonical form.

ÿnamestringþ returns the full form of PATHNAME.

ÿfile-namestringþ returns just the name, type, and version components
of PATHNAME.

ÿdirectory-namestringþ returns the directory name portion.

ÿhost-namestringþ returns the host name.

ÿenough-namestringþ returns an abbreviated namestring that is just
sufficient to identify the file named by PATHNAME when considered
relative to the DEFAULTS.  It is required that

 (merge-pathnames (enough-namestring pathname defaults) defaults)
Õ (merge-pathnames (parse-namestring pathname nil defaults) defaults)

in all cases, and the result of ÿenough-namestringþ is the shortest
reasonable string that will satisfy this criterion.

It is not necessarily possible to construct a valid namestring by
concatenating some of the three shorter namestrings in some order.

Examples:
.........

 (namestring "getty")
ý "getty"
 (setq q (make-pathname :host "kathy"
                         :directory
                           (pathname-directory *default-pathname-defaults*)
                         :name "getty"))
ý #S(PATHNAME :HOST "kathy" :DEVICE NIL :DIRECTORY directory-name
       :NAME "getty" :TYPE NIL :VERSION NIL)
 (file-namestring q) ý "getty"
 (directory-namestring q) ý directory-name
 (host-namestring q) ý "kathy"

 ;;;Using Unix syntax and the wildcard conventions used by the
 ;;;particular version of Unix on which this example was created:
 (namestring
   (translate-pathname "/usr/dmr/hacks/frob.l"
                       "/usr/d*/hacks/*.l"
                       "/usr/d*/backup/hacks/backup-*.*"))
ý "/usr/dmr/backup/hacks/backup-frob.l"
 (namestring
   (translate-pathname "/usr/dmr/hacks/frob.l"
                       "/usr/d*/hacks/fr*.l"
                       "/usr/d*/backup/hacks/backup-*.*"))
ý "/usr/dmr/backup/hacks/backup-ob.l"

 ;;;This is similar to the above example but uses two different hosts,
 ;;;U: which is a Unix and V: which is a VMS.  Note the translation
 ;;;of file type and alphabetic case conventions.
 (namestring
   (translate-pathname "U:/usr/dmr/hacks/frob.l"
                       "U:/usr/d*/hacks/*.l"
                       "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
ý "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP"
 (namestring
   (translate-pathname "U:/usr/dmr/hacks/frob.l"
                       "U:/usr/d*/hacks/fr*.l"
                       "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
ý "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP"

See Also:
.........

*Note truename::, *Note merge-pathnames::, *Note pathname (System
Class)::, *Note logical-pathname (System Class)::, *Note Section 20.1
(File System Concepts): File System Concepts, *Note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: parse-namestring,  Next: wild-pathname-p,  Prev: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Up: Filenames

parse-namestring (Function)
===========================

Syntax:
.......

 -- Function: parse-namestring thing &optional host default-pathname
          &key start end junk-allowed ý pathname, position

Arguments and Values:
.....................

THING--a string, a pathname, or a stream associated with a file.

HOST--a valid pathname host, a logical host, or ÿnilþ.

DEFAULT-PATHNAME--a pathname designator.  The default is the value of
ÿ*default-pathname-defaults*þ.

START, END--bounding index designators of THING.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

JUNK-ALLOWED--a generalized boolean.  The default is false.

PATHNAME--a pathname, or ÿnilþ.

POSITION--a bounding index designator for THING.

Description:
............

Converts THING into a pathname.

The HOST supplies a host name with respect to which the parsing occurs.

If THING is a stream associated with a file, processing proceeds as if
the pathname used to open that file had been supplied instead.

If THING is a pathname, the HOST and the host component of THING are
compared.  If they match, two values are immediately returned: THING
and START; otherwise (if they do not match), an error is signaled.

Otherwise (if THING is a string), ÿparse-namestringþ parses the name of
a file within the substring of THING bounded by START and END.

If THING is a string then the substring of THING bounded by START and
END is parsed into a pathname as follows:

   * If HOST is a logical host then THING is parsed as a logical
     pathname namestring on the HOST.

   * If HOST is ÿnilþ and THING is a syntactically valid logical
     pathname namestring containing an explicit host, then it is parsed
     as a logical pathname namestring.

   * If  HOST is ÿnilþ, DEFAULT-PATHNAME is a logical pathname, and
     THING is a syntactically valid logical pathname namestring without
     an explicit host, then it is parsed as a logical pathname
     namestring on the host that is the host component of
     DEFAULT-PATHNAME.

   * Otherwise, the parsing of THING is implementation-defined.

In the first of these cases, the host portion of the logical pathname
namestring and its following colon are optional.

If the host portion of the namestring and HOST are both present and do
not match, an error is signaled.

If JUNK-ALLOWED is true, then the primary value is the pathname parsed
or, if no syntactically correct pathname was seen, ÿnilþ.  If
JUNK-ALLOWED is false, then the entire substring is scanned, and the
primary value is the pathname parsed.

In either case, the secondary value is the index into THING of the
delimiter that terminated the parse, or the index beyond the substring
if the parse terminated at the end of the substring (as will always be
the case if JUNK-ALLOWED is false).

Parsing a null string always succeeds, producing a pathname with all
components (except the host) equal to ÿnilþ.

If THING contains an explicit host name and no explicit device name,
then it is implementation-defined whether ÿparse-namestringþ will
supply the standard default device for that host as the device component
of the resulting pathname.

Examples:
.........

 (setq q (parse-namestring "test"))
ý #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
       :TYPE NIL :VERSION NIL)
 (pathnamep q) ý true
 (parse-namestring "test")
ý #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
       :TYPE NIL :VERSION NIL), 4
 (setq s (open xxx)) ý #<Input File Stream...>
 (parse-namestring s)
ý #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx
       :TYPE NIL :VERSION NIL), 0
 (parse-namestring "test" nil nil :start 2 :end 4 )
 ý #S(PATHNAME ...), 15
 (parse-namestring "foo.lisp")
ý #P"foo.lisp"

Exceptional Situations:
.......................

If JUNK-ALLOWED is false, an error of type ÿparse-errorþ is signaled if
THING does not consist entirely of the representation of a pathname,
possibly surrounded on either side by whitespaceá characters if that is
appropriate to the cultural conventions of the implementation.

If HOST is supplied and not ÿnilþ, and THING contains a manifest host
name, an error of type ÿerrorþ is signaled if the hosts do not match.

If THING is a logical pathname namestring and if the host portion of
the namestring and HOST are both present and do not match, an error of
type ÿerrorþ is signaled.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.2.2.2.3 (.UNSPECIFIC as a Component Value):
UnspecificComponent, *Note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.


File: chris-ansicl.info,  Node: wild-pathname-p,  Next: pathname-match-p,  Prev: parse-namestring,  Up: Filenames

wild-pathname-p (Function)
==========================

Syntax:
.......

 -- Function: wild-pathname-p pathname &optional field-key ý
          generalized-boolean

Arguments and Values:
.....................

PATHNAME--a pathname designator.

FIELD-KEY--one of :host, :device :directory, :name, :type, :version, or
ÿnilþ.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿwild-pathname-pþ tests PATHNAME for the presence of wildcard
components.

If PATHNAME is a pathname (as returned by ÿpathnameþ) it represents the
name used to open the file. This may be, but is not required to be, the
actual name of the file.

If FIELD-KEY is not supplied or ÿnilþ, ÿwild-pathname-pþ returns true
if PATHNAME has any wildcard components, ÿnilþ  if PATHNAME has none.
If FIELD-KEY is non-nil, ÿwild-pathname-pþ returns true if the
indicated component of PATHNAME is a wildcard, ÿnilþ if the component
is not a wildcard.

Examples:
.........

 ;;;The following examples are not portable.  They are written to run
 ;;;with particular file systems and particular wildcard conventions.
 ;;;Other implementations will behave differently.  These examples are
 ;;;intended to be illustrative, not to be prescriptive.

 (wild-pathname-p (make-pathname :name :wild)) ý true
 (wild-pathname-p (make-pathname :name :wild) :name) ý true
 (wild-pathname-p (make-pathname :name :wild) :type) ý false
 (wild-pathname-p (pathname "s:>foo>**>")) ý true ;Lispm
 (wild-pathname-p (pathname :name "F*O")) ý true ;Most places

Exceptional Situations:
.......................

If PATHNAME is not a pathname, a string, or a stream associated with a
file an error of type ÿtype-errorþ is signaled.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.

Notes:
......

Not all implementations support wildcards in all fields.  See *Note
Section 19.2.2.2.2 (.WILD as a Component Value): WildComponents. and
*Note Section 19.2.2.3 (Restrictions on Wildcard Pathnames):
WildcardRestrictions.


File: chris-ansicl.info,  Node: pathname-match-p,  Next: translate-logical-pathname,  Prev: wild-pathname-p,  Up: Filenames

pathname-match-p (Function)
===========================

Syntax:
.......

 -- Function: pathname-match-p pathname wildcard ý generalized-boolean

Arguments and Values:
.....................

PATHNAME--a pathname designator.

WILDCARD--a designator for a wild pathname.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿpathname-match-pþ returns true if PATHNAME matches WILDCARD, otherwise
ÿnilþ.  The matching rules are implementation-defined but should be
consistent with ÿdirectoryþ. Missing components of WILDCARD default to
:wild.

It is valid for PATHNAME to be a wild pathname; a wildcard field in
PATHNAME only matches a wildcard field in WILDCARD (i.e.,
ÿpathname-match-pþ is not commutative).  It is valid for WILDCARD to be
a non-wild pathname.

Exceptional Situations:
.......................

If PATHNAME or WILDCARD is not a pathname, string, or stream associated
with a file an error of type ÿtype-errorþ is signaled.

See Also:
.........

*Note directory::, *Note pathname (System Class)::, *Note
logical-pathname (System Class)::, *Note Section 20.1 (File System
Concepts): File System Concepts, *Note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: translate-logical-pathname,  Next: translate-pathname,  Prev: pathname-match-p,  Up: Filenames

translate-logical-pathname (Function)
=====================================

Syntax:
.......

 -- Function: translate-logical-pathname pathname &key ý
          physical-pathname

Arguments and Values:
.....................

PATHNAME--a pathname designator, or a logical pathname namestring.

PHYSICAL-PATHNAME--a physical pathname.

Description:
............

Translates PATHNAME to a physical pathname, which it returns.

If PATHNAME is a stream, the stream can be either open or closed.
ÿtranslate-logical-pathnameþ returns the same physical pathname after a
file is closed as it did when the file was open.  It is an error if
PATHNAME is a stream that is created with ÿmake-two-way-streamþ,
ÿmake-echo-streamþ, ÿmake-broadcast-streamþ,
ÿmake-concatenated-streamþ, ÿmake-string-input-streamþ,
ÿmake-string-output-streamþ.

If PATHNAME is a logical pathname namestring, the host portion of the
logical pathname namestring and its following colon are required.

PATHNAME is first coerced to a pathname.  If the coerced PATHNAME is a
physical pathname, it is returned.  If the coerced PATHNAME is a
logical pathname, the first matching translation (according to
ÿpathname-match-pþ) of the logical pathname host is applied, as if by
calling ÿtranslate-pathnameþ.  If the result is a logical pathname,
this process is repeated.  When the result is finally a physical
pathname, it is returned.  If no translation matches, an error is
signaled.

ÿtranslate-logical-pathnameþ might perform additional translations,
typically to provide translation of file types to local naming
conventions, to accomodate physical file systems with limited length
names, or to deal with special character requirements such as
translating hyphens to underscores or uppercase letters to lowercase.
Any such additional translations are implementation-defined.  Some
implementations do no additional translations.

There are no specified keyword arguments for
ÿtranslate-logical-pathnameþ, but implementations are permitted to
extend it by adding keyword arguments.

Examples:
.........

See ÿlogical-pathname-translationsþ.

Exceptional Situations:
.......................

If PATHNAME is incorrectly supplied, an error of type ÿtype-errorþ is
signaled.

If no translation matches, an error of type ÿfile-errorþ is signaled.

See Also:
.........

*Note logical-pathname (Function)::, *Note
logical-pathname-translations::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: chris-ansicl.info,  Node: translate-pathname,  Next: merge-pathnames,  Prev: translate-logical-pathname,  Up: Filenames

translate-pathname (Function)
=============================

Syntax:
.......

 -- Function: translate-pathname source from-wildcard to-wildcard &key
          ý translated-pathname

Arguments and Values:
.....................

SOURCE--a pathname designator.

FROM-WILDCARD--a pathname designator.

TO-WILDCARD--a pathname designator.

TRANSLATED-PATHNAME--a pathname.

Description:
............

ÿtranslate-pathnameþ translates SOURCE (that matches FROM-WILDCARD)
into a corresponding pathname that matches TO-WILDCARD, and returns the
corresponding pathname.

The resulting pathname is TO-WILDCARD with each wildcard or missing
field replaced by a portion of SOURCE.  A "wildcard field" is a
pathname component with a value of :wild, a :wild element of a
list-valued directory component, or an implementation-defined portion
of a component, such as the ÿ"*"þ in the complex wildcard string
ÿ"foo*bar"þ that some implementations support.  An implementation that
adds other wildcard features, such as regular expressions, must define
how ÿtranslate-pathnameþ extends to those features.  A "missing field"
is a pathname component with a value of ÿnilþ.

The portion of SOURCE that is copied into the resulting pathname is
implementation-defined.  Typically it is determined by the user
interface conventions of the file systems involved.  Usually it is the
portion of SOURCE that matches a wildcard field of FROM-WILDCARD that
is in the same position as the wildcard or missing field of
TO-WILDCARD.  If there is no wildcard field in FROM-WILDCARD at that
position, then usually it is the entire corresponding pathname
component of SOURCE, or in the case of a list-valued directory
component, the entire corresponding list element.

During the copying of a portion of SOURCE into the resulting pathname,
additional implementation-defined translations of case or file naming
conventions might occur, especially when FROM-WILDCARD and TO-WILDCARD
are for different hosts.

It is valid for SOURCE to be a wild pathname; in general this will
produce a wild result.  It is valid for FROM-WILDCARD and/or
TO-WILDCARD to be non-wild pathnames.

There are no specified keyword arguments for ÿtranslate-pathnameþ, but
implementations are permitted to extend it by adding keyword arguments.

ÿtranslate-pathnameþ maps customary case in SOURCE into customary case
in the output pathname.

Examples:
.........

 ;; The results of the following five forms are all implementation-dependent.
 ;; The second item in particular is shown with multiple results just to
 ;; emphasize one of many particular variations which commonly occurs.
 (pathname-name (translate-pathname "foobar" "foo*" "*baz")) ý "barbaz"
 (pathname-name (translate-pathname "foobar" "foo*" "*"))
ý "foobar"
orý "bar"
 (pathname-name (translate-pathname "foobar" "*"    "foo*")) ý "foofoobar"
 (pathname-name (translate-pathname "bar"    "*"    "foo*")) ý "foobar"
 (pathname-name (translate-pathname "foobar" "foo*" "baz*")) ý "bazbar"

 (defun translate-logical-pathname-1 (pathname rules)
   (let ((rule (assoc pathname rules :test #'pathname-match-p)))
     (unless rule (error "No translation rule for ~A" pathname))
     (translate-pathname pathname (first rule) (second rule))))
 (translate-logical-pathname-1 "FOO:CODE;BASIC.LISP"
                       '(("FOO:DOCUMENTATION;" "MY-UNIX:/doc/foo/")
                         ("FOO:CODE;"          "MY-UNIX:/lib/foo/")
                         ("FOO:PATCHES;*;"     "MY-UNIX:/lib/foo/patch/*/")))
ý #P"MY-UNIX:/lib/foo/basic.l"

;;;This example assumes one particular set of wildcard conventions
;;;Not all file systems will run this example exactly as written
 (defun rename-files (from to)
   (dolist (file (directory from))
     (rename-file file (translate-pathname file from to))))
 (rename-files "/usr/me/*.lisp" "/dev/her/*.l")
   ;Renames /usr/me/init.lisp to /dev/her/init.l
 (rename-files "/usr/me/pcl*/*" "/sys/pcl/*/")
   ;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp
   ;In some file systems the result might be /sys/pcl/5-may/low.lisp
 (rename-files "/usr/me/pcl*/*" "/sys/library/*/")
   ;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp
   ;In some file systems the result might be /sys/library/5-may/low.lisp
 (rename-files "/usr/me/foo.bar" "/usr/me2/")
   ;Renames /usr/me/foo.bar to /usr/me2/foo.bar
 (rename-files "/usr/joe/*-recipes.text" "/usr/jim/cookbook/joe's-*-rec.text")
   ;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe's-lamb-rec.text
   ;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe's-pork-rec.text
   ;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe's-veg-rec.text

Exceptional Situations:
.......................

If any of SOURCE, FROM-WILDCARD, or TO-WILDCARD is not a pathname, a
string, or a stream associated with a file an error of type
ÿtype-errorþ is signaled.

ÿ(pathname-match-p SOURCE FROM-WILDCARD)þ must be true or an error of
type ÿerrorþ is signaled.

See Also:
.........

*Note namestring::, *Note pathname-host::, *Note pathname (System
Class)::, *Note logical-pathname (System Class)::, *Note Section 20.1
(File System Concepts): File System Concepts, *Note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

The exact behavior of ÿtranslate-pathnameþ cannot be dictated by the
Common Lisp language and must be allowed to vary, depending on the user
interface conventions of the file systems involved.

The following is an implementation guideline.  One file system performs
this operation by examining each piece of the three pathnames in turn,
where a piece is a pathname component or a list element of a structured
component such as a hierarchical directory.  Hierarchical directory
elements in FROM-WILDCARD and TO-WILDCARD are matched by whether they
are wildcards, not by depth in the directory hierarchy.  If the piece in
TO-WILDCARD is present and not wild, it is copied into the result.  If
the piece in TO-WILDCARD is :wild or ÿnilþ, the piece in SOURCE is
copied into the result.  Otherwise, the piece in TO-WILDCARD might be a
complex wildcard such as ÿ"foo*bar"þ and the piece in FROM-WILDCARD
should be wild; the portion of the piece in SOURCE that matches the
wildcard portion of the piece in FROM-WILDCARD replaces the wildcard
portion of the piece in TO-WILDCARD and the value produced is used in
the result.


File: chris-ansicl.info,  Node: merge-pathnames,  Prev: translate-pathname,  Up: Filenames

merge-pathnames (Function)
==========================

Syntax:
.......

 -- Function: merge-pathnames pathname &optional default-pathname
          default-version ý merged-pathname

Arguments and Values:
.....................

PATHNAME--a pathname designator.

DEFAULT-PATHNAME--a pathname designator.  The default is the value of
ÿ*default-pathname-defaults*þ.

DEFAULT-VERSION--a valid pathname version.  The default is :newest.

MERGED-PATHNAME--a pathname.

Description:
............

Constructs a pathname from PATHNAME by filling in any unsupplied
components with the corresponding values from DEFAULT-PATHNAME and
DEFAULT-VERSION.

Defaulting of pathname components is done by filling in components
taken from another pathname.  This is especially useful for cases such
as a program that has an input file and an output file.  Unspecified
components of the output pathname will come from the input pathname,
except that the type should not default to the type of the input
pathname but rather to the appropriate default type for output from the
program; for example, see the function *Note compile-file-pathname::.

If no version is supplied, DEFAULT-VERSION is used.  If DEFAULT-VERSION
is ÿnilþ, the version component will remain unchanged.

If PATHNAME explicitly specifies a host and not a device, and if the
host component of DEFAULT-PATHNAME matches the host component of
PATHNAME, then the device is taken from the DEFAULT-PATHNAME; otherwise
the device will be the default file device for that host.  If PATHNAME
does not specify a host, device, directory, name, or type, each such
component is copied from DEFAULT-PATHNAME.  If PATHNAME does not
specify a name, then the version, if not provided, will come from
DEFAULT-PATHNAME, just like the other components.  If PATHNAME does
specify a name, then the version is not affected by DEFAULT-PATHNAME.
If this process leaves the version missing, the DEFAULT-VERSION is used.
If the host's file name syntax provides a way to input a version
without a name or type, the user can let the name and type default but
supply a version different from the one in DEFAULT-PATHNAME.

If PATHNAME is a stream, PATHNAME effectively becomes ÿ(pathname
PATHNAME)þ. ÿmerge-pathnamesþ can be used on either an open or a closed
stream.

If PATHNAME is a pathname it represents the name used to open the file.
This may be, but is not required to be, the actual name of the file.

ÿmerge-pathnamesþ recognizes a logical pathname namestring when
DEFAULT-PATHNAME is a logical pathname, or when the namestring begins
with the name of a defined logical host followed by a colon.  In the
first of these two cases, the host portion of the logical pathname
namestring and its following colon are optional.

ÿmerge-pathnamesþ returns a logical pathname if and only if its first
argument is a logical pathname, or its first argument is a logical
pathname namestring with an explicit host, or its first argument does
not specify a host and the DEFAULT-PATHNAME is a logical pathname.

Pathname merging treats a relative directory specially.  If
ÿ(pathname-directory PATHNAME)þ is a list whose car is :relative, and
ÿ(pathname-directory DEFAULT-PATHNAME)þ is a list, then the merged
directory is the value of

 (append (pathname-directory DEFAULT-PATHNAME)
         (cdr  ;remove :relative from the front
           (pathname-directory PATHNAME)))

except that if the resulting list contains a string or :wild
immediately followed by :back, both of them are removed.  This removal
of redundant :back keywords is repeated as many times as possible.  If
ÿ(pathname-directory DEFAULT-PATHNAME)þ is not a list or
ÿ(pathname-directory PATHNAME)þ is not a list whose car is :relative,
the merged directory is ÿ(or (pathname-directory PATHNAME)
(pathname-directory DEFAULT-PATHNAME))þ

ÿmerge-pathnamesþ maps customary case in PATHNAME into customary case
in the output pathname.

Examples:
.........

 (merge-pathnames "CMUC::FORMAT"
                  "CMUC::PS:<LISPIO>.FASL")
ý #P"CMUC::PS:<LISPIO>FORMAT.FASL.0"

See Also:
.........

*Note *default-pathname-defaults*::, *Note pathname (System Class)::,
*Note logical-pathname (System Class)::, *Note Section 20.1 (File
System Concepts): File System Concepts, *Note Section 19.1.2 (Pathnames
as Filenames): Pathnames as Filenames.

Notes:
......

The net effect is that if just a name is supplied, the host, device,
directory, and type will come from DEFAULT-PATHNAME, but the version
will come from DEFAULT-VERSION.  If nothing or just a directory is
supplied, the name, type, and version will come from DEFAULT-PATHNAME
together.


File: chris-ansicl.info,  Node: Files,  Next: Streams,  Prev: Filenames,  Up: Top

20 Files
********

* Menu:

* File System Concepts::

Dictionary

* directory::
* probe-file::
* ensure-directories-exist::
* truename::
* file-author::
* file-write-date::
* rename-file::
* delete-file::
* file-error::
* file-error-pathname::


File: chris-ansicl.info,  Node: File System Concepts,  Next: directory,  Up: Files

20.1 File System Concepts
=========================

This section describes the Common Lisp interface to file systems.  The
model used by this interface assumes that "files" are named by "filenames",
that a filename can be represented by a pathname object, and that given
a pathname a "stream" can be constructed that connects to a file whose
filename it represents.

For information about opening and closing files, and manipulating their
contents, see *Note Chapter 21 (Streams): Streams.

The next figure lists some operators that are applicable to files and
directories.

compile-file   file-length       open
delete-file    file-position     probe-file
directory      file-write-date   rename-file
file-author    load              with-open-file

Figure 20.1: File and Directory Operations

* Menu:

* Coercion of Streams to Pathnames::
* File Operations on Open and Closed Streams::
* Truenames::


File: chris-ansicl.info,  Node: Coercion of Streams to Pathnames,  Next: File Operations on Open and Closed Streams,  Up: File System Concepts

20.1.1 Coercion of Streams to Pathnames
---------------------------------------

A "stream associated with a file" is either a file stream or a synonym
stream whose target is a "stream associated with a file".  Such streams
can be used as pathname designators.

Normally, when a stream associated with a file is used as a pathname
designator, it denotes the pathname used to open the file; this may be,
but is not required to be, the actual name of the file.

Some functions, such as ÿtruenameþ and ÿdelete-fileþ, coerce streams to
pathnames in a different way that involves referring to the actual file
that is open, which might or might not be the file whose name was
opened originally.  Such special situations are always notated
specifically and are not the default.


File: chris-ansicl.info,  Node: File Operations on Open and Closed Streams,  Next: Truenames,  Prev: Coercion of Streams to Pathnames,  Up: File System Concepts

20.1.2 File Operations on Open and Closed Streams
-------------------------------------------------

Many functions that perform file operations accept either open or
closed streams as arguments; see *Note Section 21.1.3 (Stream Arguments
to Standardized Functions): Stream Arguments to Standardized Functions.

Of these, the functions in the next figure treat open and closed
streams differently.

delete-file   file-author       probe-file
directory     file-write-date   truename

Figure 20.2: File Functions that Treat Open and Closed Streams Differently

Since treatment of open streams by the file system may vary
considerably between implementations, however, a closed stream might be
the most reliable kind of argument for some of these functions--in
particular, those in the next figure.  For example, in some file
systems, open files are written under temporary names and not renamed
until closed and/or are held invisible until closed.  In general, any
code that is intended to be portable should use such functions
carefully.

directory   probe-file   truename

Figure 20.3: File Functions where Closed Streams Might Work Best


File: chris-ansicl.info,  Node: Truenames,  Prev: File Operations on Open and Closed Streams,  Up: File System Concepts

20.1.3 Truenames
----------------

Many file systems permit more than one filename to designate a
particular file.

Even where multiple names are possible, most file systems have a
convention for generating a canonical filename in such situations.
Such a canonical filename (or the pathname representing such a
filename) is called a "truename".

The truename of a file may differ from other filenames for the file
because of symbolic links, version numbers, logical device translations
in the file system, logical pathname translations within Common Lisp,
or other artifacts of the file system.

The truename for a file is often, but not necessarily, unique for each
file.  For instance, a Unix file with multiple hard links could have
several truenames.

20.1.3.1 Examples of Truenames
..............................

For example, a DEC TOPS-20 system with files ÿPS:<JOE>FOO.TXT.1þ and
ÿPS:<JOE>FOO.TXT.2þ might permit the second file to be referred to as
ÿPS:<JOE>FOO.TXT.0þ, since the "ÿ.0þ" notation denotes "newest" version
of several files.  In the same file system, a "logical device" "ÿJOE:þ"
might be taken to refer to ÿPS:<JOE>þ" and so the names ÿJOE:FOO.TXT.2þ
or ÿJOE:FOO.TXT.0þ might refer to ÿPS:<JOE>FOO.TXT.2þ.  In all of these
cases, the truename of the file would probably be ÿPS:<JOE>FOO.TXT.2þ.

If a file is a symbolic link to another file (in a file system
permitting such a thing), it is conventional for the truename to be the
canonical name of the file after any symbolic links have been followed;
that is, it is the canonical name of the file whose contents would
become available if an input stream to that file were opened.

In the case of a file still being created (that is, of an output stream
open to such a file), the exact truename of the file might not be known
until the stream is closed.  In this case, the function ÿtruenameþ
might return different values for such a stream before and after it was
closed.  In fact, before it is closed, the name returned might not even
be a valid name in the file system--for example, while a file is being
written, it might have version :newest and might only take on a
specific numeric value later when the file is closed even in a file
system where all files have numeric versions.


File: chris-ansicl.info,  Node: directory,  Next: probe-file,  Prev: File System Concepts,  Up: Files

directory (Function)
====================

Syntax:
.......

 -- Function: directory pathspec &key ý pathnames

Arguments and Values:
.....................

PATHSPEC--a pathname designator, which may contain wild components.

PATHNAMES--a list of physical pathnames.

Description:
............

Determines which, if any, files that are present in the file system
have names matching PATHSPEC, and returns a fresh list of pathnames
corresponding to the truenames of those files.

An implementation may be extended to accept implementation-defined
keyword arguments to ÿdirectoryþ.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

If the attempt to obtain a directory listing is not successful, an
error of type ÿfile-errorþ is signaled.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note ensure-directories-exist::, *Note Section 20.1 (File
System Concepts): File System Concepts, *Note Section 21.1.1.1.2 (Open
and Closed Streams): File Operations on Open and Closed Streams, *Note
Section 19.1.2 (Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

If the PATHSPEC is not wild, the resulting list will contain either
zero or one elements.

Common Lisp specifies "&key" in the argument list to ÿdirectoryþ even
though no standardized keyword arguments to ÿdirectoryþ are defined.
"ÿ:allow-other-keys tþ" may be used in conforming programs in order to
quietly ignore any additional keywords which are passed by the program
but not supported by the implementation.


File: chris-ansicl.info,  Node: probe-file,  Next: ensure-directories-exist,  Prev: directory,  Up: Files

probe-file (Function)
=====================

Syntax:
.......

 -- Function: probe-file pathspec ý truename

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

TRUENAME--a physical pathname or ÿnilþ.

Description:
............

ÿprobe-fileþ tests whether a file exists.

ÿprobe-fileþ returns false if there is no file named PATHSPEC, and
otherwise returns the truename of PATHSPEC.

If the PATHSPEC designator is an open stream, then ÿprobe-fileþ
produces the truename of its associated file.  If PATHSPEC is a stream,
whether open or closed, it is coerced to a pathname as if by the
function ÿpathnameþ.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

An error of type ÿfile-errorþ is signaled if PATHSPEC is wild.

An error of type ÿfile-errorþ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*Note truename::, *Note open::, *Note ensure-directories-exist::, *Note
pathname (System Class)::, *Note logical-pathname (System Class)::,
*Note Section 20.1 (File System Concepts): File System Concepts, *Note
Section 21.1.1.1.2 (Open and Closed Streams): File Operations on Open
and Closed Streams, *Note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.


File: chris-ansicl.info,  Node: ensure-directories-exist,  Next: truename,  Prev: probe-file,  Up: Files

ensure-directories-exist (Function)
===================================

Syntax:
.......

 -- Function: ensure-directories-exist pathspec &key verbose ý
          pathspec, created

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

VERBOSE--a generalized boolean.

CREATED--a generalized boolean.

Description:
............

Tests whether the directories containing the specified file actually
exist, and attempts to create them if they do not.

If the containing directories do not exist and if VERBOSE is true, then
the implementation is permitted (but not required) to perform output to
standard output saying what directories were created.  If the
containing directories exist, or if VERBOSE is false, this function
performs no output.

The primary value is the given pathspec so that this operation can be
straightforwardly composed with other file manipulation expressions.
The secondary value, CREATED, is true if any directories were created.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

An error of type ÿfile-errorþ is signaled if the host, device, or
directory part of PATHSPEC is wild.

If the directory creation attempt is not successful, an error of type
ÿfile-errorþ is signaled; if this occurs, it might be the case that
none, some, or all of the requested creations have actually occurred
within the file system.

See Also:
.........

*Note probe-file::, *Note open::, *Note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: truename,  Next: file-author,  Prev: ensure-directories-exist,  Up: Files

truename (Function)
===================

Syntax:
.......

 -- Function: truename filespec ý truename

Arguments and Values:
.....................

FILESPEC--a pathname designator.

TRUENAME--a physical pathname.

Description:
............

ÿtruenameþ tries to find the file indicated by FILESPEC and returns its
truename.  If the FILESPEC designator is an open stream, its associated
file is used.  If FILESPEC is a stream, ÿtruenameþ can be used whether
the stream is open or closed. It is permissible for ÿtruenameþ to
return more specific information after the stream is closed than when
the stream was open.  If FILESPEC is a pathname it represents the name
used to open the file. This may be, but is not required to be, the
actual name of the file.

Examples:
.........

;; An example involving version numbers.  Note that the precise nature of
;; the truename is implementation-dependent while the file is still open.
 (with-open-file (stream ">vistor>test.text.newest")
   (values (pathname stream)
           (truename stream)))
ý #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"
orý #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.newest"
orý #P"S:>vistor>test.text.newest", #P"S:>vistor>_temp_._temp_.1"

;; In this case, the file is closed when the truename is tried, so the
;; truename information is reliable.
 (with-open-file (stream ">vistor>test.text.newest")
   (close stream)
   (values (pathname stream)
           (truename stream)))
ý #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"

;; An example involving TOP-20's implementation-dependent concept
;; of logical devices -- in this case, "DOC:" is shorthand for
;; "PS:<DOCUMENTATION>" ...
 (with-open-file (stream "CMUC::DOC:DUMPER.HLP")
   (values (pathname stream)
           (truename stream)))
ý #P"CMUC::DOC:DUMPER.HLP", #P"CMUC::PS:<DOCUMENTATION>DUMPER.HLP.13"

Exceptional Situations:
.......................

An error of type ÿfile-errorþ is signaled if an appropriate file cannot
be located within the file system for the given FILESPEC, or if the
file system cannot perform the requested operation.

An error of type ÿfile-errorþ is signaled if PATHNAME is wild.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.

Notes:
......

ÿtruenameþ may be used to account for any filename translations
performed by the file system.


File: chris-ansicl.info,  Node: file-author,  Next: file-write-date,  Prev: truename,  Up: Files

file-author (Function)
======================

Syntax:
.......

 -- Function: file-author pathspec ý author

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

AUTHOR--a string or ÿnilþ.

Description:
............

Returns a string naming the author of the file specified by PATHSPEC,
or ÿnilþ if the author's name cannot be determined.

Examples:
.........

 (with-open-file (stream ">relativity>general.text")
   (file-author s))
ý "albert"

Affected By:
............

The host computer's file system.

Other users of the file named by PATHSPEC.

Exceptional Situations:
.......................

An error of type ÿfile-errorþ is signaled if PATHSPEC is wild.

An error of type ÿfile-errorþ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: chris-ansicl.info,  Node: file-write-date,  Next: rename-file,  Prev: file-author,  Up: Files

file-write-date (Function)
==========================

Syntax:
.......

 -- Function: file-write-date pathspec ý date

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

DATE--a universal time or ÿnilþ.

Description:
............

Returns a universal time representing the time at which the file
specified by PATHSPEC was last written (or created), or returns
ÿnilþ if such a time cannot be determined.

Examples:
.........

 (with-open-file (s "noel.text"
                    :direction :output :if-exists :error)
   (format s "~&Dear Santa,~2%I was good this year.  ~
                Please leave lots of toys.~2%Love, Sue~
             ~2%attachments: milk, cookies~%")
   (truename s))
ý #P"CUPID:/susan/noel.text"
 (with-open-file (s "noel.text")
   (file-write-date s))
ý 2902600800

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

An error of type ÿfile-errorþ is signaled if PATHSPEC is wild.

An error of type ÿfile-errorþ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*Note Section 25.1.4.2 (Universal Time): UniversalTime, *Note Section
19.1.2 (Pathnames as Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: rename-file,  Next: delete-file,  Prev: file-write-date,  Up: Files

rename-file (Function)
======================

Syntax:
.......

 -- Function: rename-file filespec new-name ý defaulted-new-name,
          old-truename, new-truename

Arguments and Values:
.....................

FILESPEC--a pathname designator.

NEW-NAME--a pathname designator other than a stream.

DEFAULTED-NEW-NAME--a pathname

OLD-TRUENAME--a physical pathname.

NEW-TRUENAME--a physical pathname.

Description:
............

ÿrename-fileþ modifies the file system in such a way that the file
indicated by FILESPEC is renamed to DEFAULTED-NEW-NAME.

It is an error to specify a filename containing a wild component, for
FILESPEC to contain a ÿnilþ component where the file system does not
permit a ÿnilþ component, or for the result of defaulting missing
components of NEW-NAME from FILESPEC to contain a ÿnilþ component where
the file system does not permit a ÿnilþ component.

If NEW-NAME is a logical pathname, ÿrename-fileþ returns a logical
pathname as its primary value.

ÿrename-fileþ returns three values if successful.  The primary value,
DEFAULTED-NEW-NAME, is the resulting name which is composed of NEW-NAME
with any missing components filled in by performing a ÿmerge-pathnamesþ
operation using FILESPEC as the defaults.  The secondary value,
OLD-TRUENAME, is the truename of the file before it was renamed.  The
tertiary value, NEW-TRUENAME, is the truename of the file after it was
renamed.

If the FILESPEC designator is an open stream, then the stream itself
and the file associated with it are affected (if the file system
permits).

Examples:
.........

;; An example involving logical pathnames.
 (with-open-file (stream "sys:chemistry;lead.text"
                         :direction :output :if-exists :error)
   (princ "eureka" stream)
   (values (pathname stream) (truename stream)))
ý #P"SYS:CHEMISTRY;LEAD.TEXT.NEWEST", #P"Q:>sys>chem>lead.text.1"
 (rename-file "sys:chemistry;lead.text" "gold.text")
ý #P"SYS:CHEMISTRY;GOLD.TEXT.NEWEST",
   #P"Q:>sys>chem>lead.text.1",
   #P"Q:>sys>chem>gold.text.1"

Exceptional Situations:
.......................

If the renaming operation is not successful, an error of type
ÿfile-errorþ is signaled.

An error of type ÿfile-errorþ might be signaled if FILESPEC is wild.

See Also:
.........

*Note truename::, *Note pathname (System Class)::, *Note
logical-pathname (System Class)::, *Note Section 20.1 (File System
Concepts): File System Concepts, *Note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: delete-file,  Next: file-error,  Prev: rename-file,  Up: Files

delete-file (Function)
======================

Syntax:
.......

 -- Function: delete-file filespec ý ÿtþ

Arguments and Values:
.....................

FILESPEC--a pathname designator.

Description:
............

Deletes the file specified by FILESPEC.

If the FILESPEC designator is an open stream, then FILESPEC and the
file associated with it are affected (if the file system permits), in
which case FILESPEC might be closed immediately, and the deletion might
be immediate or delayed until FILESPEC is explicitly closed, depending
on the requirements of the file system.

It is implementation-dependent whether an attempt to delete a
nonexistent file is considered to be successful.

ÿdelete-fileþ returns true if it succeeds, or signals an error of type
ÿfile-errorþ if it does not.

The consequences are undefined if FILESPEC has a wild component, or if
FILESPEC has a ÿnilþ component and the file system does not permit a
ÿnilþ component.

Examples:
.........

 (with-open-file (s "delete-me.text" :direction :output :if-exists :error))
ý NIL
 (setq p (probe-file "delete-me.text")) ý #P"R:>fred>delete-me.text.1"
 (delete-file p) ý T
 (probe-file "delete-me.text") ý false
 (with-open-file (s "delete-me.text" :direction :output :if-exists :error)
   (delete-file s))
ý T
 (probe-file "delete-me.text") ý false

Exceptional Situations:
.......................

If the deletion operation is not successful, an error of type
ÿfile-errorþ is signaled.

An error of type ÿfile-errorþ might be signaled if FILESPEC is wild.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note Section 20.1 (File System Concepts): File System
Concepts, *Note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: chris-ansicl.info,  Node: file-error,  Next: file-error-pathname,  Prev: delete-file,  Up: Files

file-error (Condition Type)
===========================

Class Precedence List:
......................

ÿfile-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿfile-errorþ consists of error conditions that occur during an
attempt to open or close a file, or during some low-level transactions
with a file system.  The "offending pathname" is initialized by the
:pathname initialization argument to ÿmake-conditionþ, and is accessed
by the function ÿfile-error-pathnameþ.

See Also:
.........

*Note file-error-pathname::, *Note open::, *Note probe-file::, *Note
directory::, *Note ensure-directories-exist::


File: chris-ansicl.info,  Node: file-error-pathname,  Prev: file-error,  Up: Files

file-error-pathname (Function)
==============================

Syntax:
.......

 -- Function: file-error-pathname condition ý pathspec

Arguments and Values:
.....................

CONDITION--a condition of type ÿfile-errorþ.

PATHSPEC--a pathname designator.

Description:
............

Returns the "offending pathname" of a condition of type ÿfile-errorþ.

Exceptional Situations:
.......................

See Also:
.........

*Note file-error::, *Note Chapter 9 (Conditions): Conditions.


File: chris-ansicl.info,  Node: Streams,  Next: Printer,  Prev: Files,  Up: Top

21 Streams
**********

* Menu:

* Stream Concepts::

Dictionary

* stream::
* broadcast-stream::
* concatenated-stream::
* echo-stream::
* file-stream::
* string-stream::
* synonym-stream::
* two-way-stream::
* input-stream-p; output-stream-p::
* interactive-stream-p::
* open-stream-p::
* stream-element-type::
* streamp::
* read-byte::
* write-byte::
* peek-char::
* read-char::
* read-char-no-hang::
* terpri; fresh-line::
* unread-char::
* write-char::
* read-line::
* write-string; write-line::
* read-sequence::
* write-sequence::
* file-length::
* file-position::
* file-string-length::
* open::
* stream-external-format::
* with-open-file::
* close::
* with-open-stream::
* listen::
* clear-input::
* finish-output; force-output; clear-output::
* y-or-n-p; yes-or-no-p::
* make-synonym-stream::
* synonym-stream-symbol::
* broadcast-stream-streams::
* make-broadcast-stream::
* make-two-way-stream::
* two-way-stream-input-stream; two-way-stream-output-stream::
* echo-stream-input-stream; echo-stream-output-stream::
* make-echo-stream::
* concatenated-stream-streams::
* make-concatenated-stream::
* get-output-stream-string::
* make-string-input-stream::
* make-string-output-stream::
* with-input-from-string::
* with-output-to-string::
* *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+::
* *terminal-io*::
* stream-error::
* stream-error-stream::
* end-of-file::


File: chris-ansicl.info,  Node: Stream Concepts,  Next: stream,  Up: Streams

21.1 Stream Concepts
====================

* Menu:

* Introduction to Streams::
* Stream Variables::
* Stream Arguments to Standardized Functions::
* Restrictions on Composite Streams::


File: chris-ansicl.info,  Node: Introduction to Streams,  Next: Stream Variables,  Up: Stream Concepts

21.1.1 Introduction to Streams
------------------------------

A "stream" is an object that can be used with an input or output
function to identify an appropriate source or sink of characters or
bytes for that operation.  A "character" "stream" is a source or sink
of characters.  A "binary" "stream" is a source or sink of bytes.

Some operations may be performed on any kind of stream; the next
figure provides a list of standardized operations that are potentially
useful with any kind of stream.

close                  stream-element-type
input-stream-p         streamp
interactive-stream-p   with-open-stream
output-stream-p        

Figure 21.1: Some General-Purpose Stream Operations

Other operations are only meaningful on certain stream types.  For
example, ÿread-charþ is only defined for character streams and
ÿread-byteþ is only defined for binary streams.

21.1.1.1 Abstract Classifications of Streams
............................................

21.1.1.1.1 Input, Output, and Bidirectional Streams
...................................................

A stream, whether a character stream or a binary stream, can be an "input" "stream"
(source of data), an "output" "stream" (sink for data), both, or (e.g.,
when "ÿ:direction :probeþ" is given to ÿopenþ) neither.

The next figure shows operators relating to input streams.

clear-input   read-byte             read-from-string
listen        read-char             read-line
peek-char     read-char-no-hang     read-preserving-whitespace
read          read-delimited-list   unread-char

Figure 21.2: Operators relating to Input Streams.

The next figure shows operators relating to output streams.

clear-output    prin1             write
finish-output   prin1-to-string   write-byte
force-output    princ             write-char
format          princ-to-string   write-line
fresh-line      print             write-string
pprint          terpri            write-to-string

Figure 21.3: Operators relating to Output Streams.

A stream that is both an input stream and an output stream is called a "bidirectional" "stream".
See the functions *Note input-stream-p:: and ÿoutput-stream-pþ.

Any of the operators listed in *Note Figure 21.2: InputStreamOps. or
*Note Figure 21.3: OutputStreamOps.  can be used with bidirectional
streams.  In addition, the next figure shows a list of operators that
relate specificaly to bidirectional streams.

y-or-n-p   yes-or-no-p   

Figure 21.4: Operators relating to Bidirectional Streams.

21.1.1.1.2 Open and Closed Streams
..................................

Streams are either "open" or "closed".

Except as explicitly specified otherwise, operations that create and
return streams return open streams.

The action of closing a stream marks the end of its use as a source or
sink of data, permitting the implementation to reclaim its internal data
structures, and to free any external resources which might have been
locked by the stream when it was opened.

Except as explicitly specified otherwise, the consequences are
undefined when a closed stream is used where a stream is called for.

Coercion of streams to pathnames is permissible for closed streams; in
some situations, such as for a truename computation, the result might
be different for an open stream and for that same stream once it has
been closed.

21.1.1.1.3 Interactive Streams
..............................

An "interactive stream" is one on which it makes sense to perform
interactive querying.

The precise meaning of an interactive stream is implementation-defined,
and may depend on the underlying operating system.  Some examples of
the things that an implementation might choose to use as identifying
characteristics of an interactive stream include:

   * The stream is connected to a person (or equivalent) in such a way
     that the program can prompt for information and expect to receive
     different input depending on the prompt.

   * The program is expected to prompt for input and support "normal
     input editing".

   * ÿread-charþ might wait for the user to type something before
     returning instead of immediately returning a character or
     end-of-file.

The general intent of having some streams be classified as interactive
streams is to allow them to be distinguished from streams containing
batch (or background or command-file) input.  Output to batch streams
is typically discarded or saved for later viewing, so interactive
queries to such streams might not have the expected effect.

Terminal I/O might or might not be an interactive stream.

21.1.1.2 Abstract Classifications of Streams
............................................

21.1.1.2.4 File Streams
.......................

Some streams, called "file streams", provide access to files.  An
object of class ÿfile-streamþ is used to represent a file stream.

The basic operation for opening a file is ÿopenþ, which typically
returns a file stream (see its dictionary entry for details).  The
basic operation for closing a stream is ÿcloseþ.  The macro
ÿwith-open-fileþ is useful to express the common idiom of opening a file
for the duration of a given body of code, and assuring that the
resulting stream is closed upon exit from that body.

21.1.1.3 Other Subclasses of Stream
...................................

The class ÿstreamþ has a number of subclasses defined by this
specification.  The next figure shows some information about these
subclasses.

Class                   Related Operators
--------------------------------------------------------- 
ÿbroadcast-streamþ      ÿmake-broadcast-streamþ
                        ÿbroadcast-stream-streamsþ
ÿconcatenated-streamþ   ÿmake-concatenated-streamþ
                        ÿconcatenated-stream-streamsþ
ÿecho-streamþ           ÿmake-echo-streamþ
                        ÿecho-stream-input-streamþ
                        ÿecho-stream-output-streamþ
ÿstring-streamþ         ÿmake-string-input-streamþ
                        ÿwith-input-from-stringþ
                        ÿmake-string-output-streamþ
                        ÿwith-output-to-stringþ
                        ÿget-output-stream-stringþ
ÿsynonym-streamþ        ÿmake-synonym-streamþ
                        ÿsynonym-stream-symbolþ
ÿtwo-way-streamþ        ÿmake-two-way-streamþ
                        ÿtwo-way-stream-input-streamþ
                        ÿtwo-way-stream-output-streamþ

Figure 21.5: Defined Names related to Specialized Streams


File: chris-ansicl.info,  Node: Stream Variables,  Next: Stream Arguments to Standardized Functions,  Prev: Introduction to Streams,  Up: Stream Concepts

21.1.2 Stream Variables
-----------------------

Variables whose values must be streams are sometimes called "stream
variables".

Certain stream variables are defined by this specification to be the
proper source of input or output in various situations where no
specific stream has been specified instead.  A complete list of such
standardized stream variables appears in the next figure.  The
consequences are undefined if at any time the value of any of these
variables is not an open stream.

Glossary Term     Variable Name
---------------------------------------- 
debug I/O         ÿ*debug-io*þ
error output      ÿ*error-output*þ
query I/O         ÿ*query-io*þ
standard input    ÿ*standard-input*þ
standard output   ÿ*standard-output*þ
terminal I/O      ÿ*terminal-io*þ
trace output      ÿ*trace-output*þ

Figure 21.6: Standardized Stream Variables

Note that, by convention, standardized stream variables have names
ending in "ÿ-input*þ"  if they must be input streams, ending in
"ÿ-output*þ" if they must be output streams, or ending in "ÿ-io*þ"
if they must be bidirectional streams.

User programs may assign or bind any standardized stream variable
except ÿ*terminal-io*þ.


File: chris-ansicl.info,  Node: Stream Arguments to Standardized Functions,  Next: Restrictions on Composite Streams,  Prev: Stream Variables,  Up: Stream Concepts

21.1.3 Stream Arguments to Standardized Functions
-------------------------------------------------

The operators in the next figure accept stream arguments that might be
either open or closed streams.

broadcast-stream-streams      file-author        pathnamep
close                         file-namestring    probe-file
compile-file                  file-write-date    rename-file
compile-file-pathname         host-namestring    streamp
concatenated-stream-streams   load               synonym-stream-symbol
delete-file                   logical-pathname   translate-logical-pathname
directory                     merge-pathnames    translate-pathname
directory-namestring          namestring         truename
dribble                       open               two-way-stream-input-stream
echo-stream-input-stream      open-stream-p      two-way-stream-output-stream
echo-stream-ouput-stream      parse-namestring   wild-pathname-p
ed                            pathname           with-open-file
enough-namestring             pathname-match-p   

Figure 21.7: Operators that accept either Open or Closed Streams

The operators in the next figure accept stream arguments that must be
open streams.

clear-input                output-stream-p           read-char-no-hang
clear-output               peek-char                 read-delimited-list
file-length                pprint                    read-line
file-position              pprint-fill               read-preserving-whitespace
file-string-length         pprint-indent             stream-element-type
finish-output              pprint-linear             stream-external-format
force-output               pprint-logical-block      terpri
format                     pprint-newline            unread-char
fresh-line                 pprint-tab                with-open-stream
get-output-stream-string   pprint-tabular            write
input-stream-p             prin1                     write-byte
interactive-stream-p       princ                     write-char
listen                     print                     write-line
make-broadcast-stream      print-object              write-string
make-concatenated-stream   print-unreadable-object   y-or-n-p
make-echo-stream           read                      yes-or-no-p
make-synonym-stream        read-byte                 
make-two-way-stream        read-char                 

Figure 21.8: Operators that accept Open Streams only


File: chris-ansicl.info,  Node: Restrictions on Composite Streams,  Prev: Stream Arguments to Standardized Functions,  Up: Stream Concepts

21.1.4 Restrictions on Composite Streams
----------------------------------------

The consequences are undefined if any component of a composite stream
is closed before the composite stream is closed.

The consequences are undefined if the synonym stream symbol is not bound
to an open stream from the time of the synonym stream's creation until
the time it is closed.


File: chris-ansicl.info,  Node: stream,  Next: broadcast-stream,  Prev: Stream Concepts,  Up: Streams

stream (System Class)
=====================

Class Precedence List:
......................

ÿstreamþ, ÿtþ

Description:
............

A stream is an object that can be used with an input or output function
to identify an appropriate source or sink of characters or bytes for
that operation.

For more complete information, see *Note Section 21.1 (Stream
Concepts): Stream Concepts.

See Also:
.........

*Note Section 21.1 (Stream Concepts): Stream Concepts, *Note Section
22.1.3.13 (Printing Other Objects): PrintingOtherObjects, *Note Chapter
22 (Printer): Printer, *Note Chapter 23 (Reader): Reader.


File: chris-ansicl.info,  Node: broadcast-stream,  Next: concatenated-stream,  Prev: stream,  Up: Streams

broadcast-stream (System Class)
===============================

Class Precedence List:
......................

ÿbroadcast-streamþ, ÿstreamþ, ÿtþ

Description:
............

A broadcast stream is an output stream which has associated with it a
set of zero or more output streams such that any output sent to the
broadcast stream gets passed on as output to each of the associated
output streams.  (If a broadcast stream has no component streams, then
all output to the broadcast stream is discarded.)

The set of operations that may be performed on a broadcast stream is
the intersection of those for its associated output streams.

Some output operations (e.g., ÿfresh-lineþ) return values based on the
state of the stream at the time of the operation.  Since these values
might differ for each of the component streams, it is necessary to
describe their return value specifically:

   * ÿstream-element-typeþ returns the value from the last component
     stream, or ÿtþ if there are no component streams.

   * ÿfresh-lineþ returns the value from the last component stream, or
     ÿnilþ if there are no component streams.

   * The functions ÿfile-lengthþ, ÿfile-positionþ, ÿfile-string-lengthþ,
     and ÿstream-external-formatþ return the value from the last
     component stream; if there are no component streams, ÿfile-lengthþ
     and ÿfile-positionþ return ÿ0þ, ÿfile-string-lengthþ returns ÿ1þ,
     and ÿstream-external-formatþ returns :default.

   * The functions ÿstreampþ and ÿoutput-stream-pþ always return true
     for broadcast streams.

   * The functions ÿopen-stream-pþ tests whether the broadcast stream
     is openà, not whether its component streams are open.

   * The functions ÿinput-stream-pþ and interactive-stream-p return an
     implementation-defined, generalized boolean value.

   * For the input operations ÿclear-inputþ ÿlistenþ, ÿpeek-charþ,
     ÿread-byteþ, ÿread-char-no-hangþ, ÿread-charþ, ÿread-lineþ, and
     ÿunread-charþ, the consequences are undefined if the indicated
     operation is performed.  However, an implementation is permitted
     to define such a behavior as an implementation-dependent extension.

For any output operations not having their return values explicitly
specified above or elsewhere in this document, it is defined that the
values returned by such an operation are the values resulting from
performing the operation on the last of its component streams; the
values resulting from performing the operation on all preceding streams
are discarded.  If there are no component streams, the value is
implementation-dependent.

See Also:
.........

*Note broadcast-stream-streams::, *Note make-broadcast-stream::


File: chris-ansicl.info,  Node: concatenated-stream,  Next: echo-stream,  Prev: broadcast-stream,  Up: Streams

concatenated-stream (System Class)
==================================

Class Precedence List:
......................

ÿconcatenated-streamþ, ÿstreamþ, ÿtþ

Description:
............

A concatenated stream is an input stream which is a composite stream of
zero or more other input streams, such that the sequence of data which
can be read from the concatenated stream is the same as the
concatenation of the sequences of data which could be read from each of
the constituent streams.

Input from a concatenated stream is taken from the first of the
associated input streams until it reaches end of fileá; then that
stream is discarded, and subsequent input is taken from the next input
stream, and so on.  An end of file on the associated input streams is
always managed invisibly by the concatenated stream--the only time a
client of a concatenated stream sees an end of file is when an attempt
is made to obtain data from the concatenated stream but it has no
remaining input streams from which to obtain such data.

See Also:
.........

*Note concatenated-stream-streams::, *Note make-concatenated-stream::


File: chris-ansicl.info,  Node: echo-stream,  Next: file-stream,  Prev: concatenated-stream,  Up: Streams

echo-stream (System Class)
==========================

Class Precedence List:
......................

ÿecho-streamþ, ÿstreamþ, ÿtþ

Description:
............

An echo stream is a bidirectional stream that gets  its input  from an
associated input  stream and  sends its output to   an associated
output stream.

All input taken from the input stream is echoed to the output stream.
Whether the input is echoed immediately after it is encountered, or
after it has been read from the input stream is
implementation-dependent.

See Also:
.........

*Note echo-stream-input-stream::, *Note echo-stream-output-stream::,
*Note make-echo-stream::


File: chris-ansicl.info,  Node: file-stream,  Next: string-stream,  Prev: echo-stream,  Up: Streams

file-stream (System Class)
==========================

Class Precedence List:
......................

ÿfile-streamþ, ÿstreamþ, ÿtþ

Description:
............

An object of type ÿfile-streamþ is a stream the direct source or sink
of which is a file.  Such a stream is created explicitly by ÿopenþ and
ÿwith-open-fileþ, and implicitly by functions such as ÿloadþ that
process files.

See Also:
.........

*Note load::, *Note open::, *Note with-open-file::


File: chris-ansicl.info,  Node: string-stream,  Next: synonym-stream,  Prev: file-stream,  Up: Streams

string-stream (System Class)
============================

Class Precedence List:
......................

ÿstring-streamþ, ÿstreamþ, ÿtþ

Description:
............

A string stream is a stream which reads input from or writes output to
an associated string.

The stream element type of a string stream is always a subtype of type
ÿcharacterþ.

See Also:
.........

*Note make-string-input-stream::, *Note make-string-output-stream::,
*Note with-input-from-string::, *Note with-output-to-string::


File: chris-ansicl.info,  Node: synonym-stream,  Next: two-way-stream,  Prev: string-stream,  Up: Streams

synonym-stream (System Class)
=============================

Class Precedence List:
......................

ÿsynonym-streamþ, ÿstreamþ, ÿtþ

Description:
............

A stream that is an alias for another stream, which is the value of a
dynamic variable whose name is the synonym stream symbol of the synonym
stream.

Any operations on a synonym stream will be performed on the stream that
is then the value of the dynamic variable named by the synonym stream
symbol.  If the value of the variable should change, or if the variable
should be bound, then the stream will operate on the new value of the
variable.

See Also:
.........

*Note make-synonym-stream::, *Note synonym-stream-symbol::


File: chris-ansicl.info,  Node: two-way-stream,  Next: input-stream-p; output-stream-p,  Prev: synonym-stream,  Up: Streams

two-way-stream (System Class)
=============================

Class Precedence List:
......................

ÿtwo-way-streamþ, ÿstreamþ, ÿtþ

Description:
............

A bidirectional composite stream that receives its input  from an
associated input  stream and sends    its output to   an associated
output stream.

See Also:
.........

*Note make-two-way-stream::, *Note two-way-stream-input-stream::, *Note
two-way-stream-output-stream::


File: chris-ansicl.info,  Node: input-stream-p; output-stream-p,  Next: interactive-stream-p,  Prev: two-way-stream,  Up: Streams

input-stream-p, output-stream-p (Function)
==========================================

Syntax:
.......

 -- Function: input-stream-p stream ý generalized-boolean

 -- Function: output-stream-p stream ý generalized-boolean

Arguments and Values:
.....................

STREAM--a stream.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿinput-stream-pþ returns true if STREAM is an input stream; otherwise,
returns false.

ÿoutput-stream-pþ returns true if STREAM is an output stream;
otherwise, returns false.

Examples:
.........

 (input-stream-p *standard-input*) ý true
 (input-stream-p *terminal-io*) ý true
 (input-stream-p (make-string-output-stream)) ý false

 (output-stream-p *standard-output*) ý true
 (output-stream-p *terminal-io*) ý true
 (output-stream-p (make-string-input-stream "jr")) ý false

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not a stream.


File: chris-ansicl.info,  Node: interactive-stream-p,  Next: open-stream-p,  Prev: input-stream-p; output-stream-p,  Up: Streams

interactive-stream-p (Function)
===============================

Syntax:
.......

 -- Function: interactive-stream-p stream ý generalized-boolean

Arguments and Values:
.....................

STREAM--a stream.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if STREAM is an interactive stream; otherwise, returns
false.

Examples:
.........

 (when (> measured limit)
   (let ((error (round (* (- measured limit) 100)
                       limit)))
     (unless (if (interactive-stream-p *query-io*)
                 (yes-or-no-p "The frammis is out of tolerance by ~D%.~@
                               Is it safe to proceed? " error)
                 (< error 15))  ;15% is acceptable
       (error "The frammis is out of tolerance by ~D%." error))))

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not a stream.

See Also:
.........

*Note Section 21.1 (Stream Concepts): Stream Concepts.


File: chris-ansicl.info,  Node: open-stream-p,  Next: stream-element-type,  Prev: interactive-stream-p,  Up: Streams

open-stream-p (Function)
========================

Syntax:
.......

 -- Function: open-stream-p stream ý generalized-boolean

Arguments and Values:
.....................

STREAM--a stream.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if STREAM is an open stream; otherwise, returns false.

Streams are open until they have been explicitly closed with ÿcloseþ,
or until they are implicitly closed due to exit from a
ÿwith-output-to-stringþ, ÿwith-open-fileþ, ÿwith-input-from-stringþ,  or
ÿwith-open-streamþ form.

Examples:
.........

 (open-stream-p *standard-input*) ý true

Affected By:
............

ÿcloseþ.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not a stream.


File: chris-ansicl.info,  Node: stream-element-type,  Next: streamp,  Prev: open-stream-p,  Up: Streams

stream-element-type (Function)
==============================

Syntax:
.......

 -- Function: stream-element-type stream ý typespec

Arguments and Values:
.....................

STREAM--a stream.

TYPESPEC--a type specifier.

Description:
............

ÿstream-element-typeþ returns a type specifier that indicates the types
of objects that may be read from or written to STREAM.

Streams created by ÿopenþ have an element type restricted to ÿintegerþ
or a subtype of type ÿcharacterþ.

Examples:
.........

;; Note that the stream must accomodate at least the specified type,
;; but might accomodate other types.  Further note that even if it does
;; accomodate exactly the specified type, the type might be specified in
;; any of several ways.
 (with-open-file (s "test" :element-type '(integer 0 1)
                           :if-exists :error
                           :direction :output)
   (stream-element-type s))
ý INTEGER
orý (UNSIGNED-BYTE 16)
orý (UNSIGNED-BYTE 8)
orý BIT
orý (UNSIGNED-BYTE 1)
orý (INTEGER 0 1)
orý (INTEGER 0 (2))

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not a stream.


File: chris-ansicl.info,  Node: streamp,  Next: read-byte,  Prev: stream-element-type,  Up: Streams

streamp (Function)
==================

Syntax:
.......

 -- Function: streamp object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿstreamþ; otherwise, returns false.

ÿstreampþ is unaffected by whether OBJECT, if it is a stream, is open
or closed.

Examples:
.........

 (streamp *terminal-io*) ý true
 (streamp 1) ý false

Notes:
......

 (streamp OBJECT) Õ (typep OBJECT 'stream)


File: chris-ansicl.info,  Node: read-byte,  Next: write-byte,  Prev: streamp,  Up: Streams

read-byte (Function)
====================

Syntax:
.......

 -- Function: read-byte stream &optional eof-error-p eof-value ý byte

Arguments and Values:
.....................

STREAM--a binary input stream.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ÿnilþ.

BYTE--an integer, or the EOF-VALUE.

Description:
............

ÿread-byteþ reads and returns one byte from STREAM.

If an end of fileà occurs and EOF-ERROR-P is false, the EOF-VALUE is
returned.

Examples:
.........

 (with-open-file (s "temp-bytes"
                     :direction :output
                     :element-type 'unsigned-byte)
    (write-byte 101 s)) ý 101
 (with-open-file (s "temp-bytes" :element-type 'unsigned-byte)
    (format t "~S ~S" (read-byte s) (read-byte s nil 'eof)))
Ö 101 EOF
ý NIL

Side Effects:
.............

Modifies STREAM.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not a stream.

Should signal an error of type ÿerrorþ if STREAM is not  a binary input
stream.

If there are no bytes remaining in the STREAM and EOF-ERROR-P is true,
an error of type ÿend-of-fileþ is signaled.

See Also:
.........

*Note read-char::, *Note read-sequence::, *Note write-byte::


File: chris-ansicl.info,  Node: write-byte,  Next: peek-char,  Prev: read-byte,  Up: Streams

write-byte (Function)
=====================

Syntax:
.......

 -- Function: write-byte byte stream ý byte

Arguments and Values:
.....................

BYTE--an integer of the stream element type of stream.

STREAM--a binary output stream.

Description:
............

ÿwrite-byteþ writes one byte, BYTE, to STREAM.

Examples:
.........

 (with-open-file (s "temp-bytes"
                    :direction :output
                    :element-type 'unsigned-byte)
    (write-byte 101 s)) ý 101

Side Effects:
.............

STREAM is modified.

Affected By:
............

The element type of the STREAM.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not a stream.
Should signal an error of type ÿerrorþ if STREAM is not  a binary
output stream.

Might signal an error of type ÿtype-errorþ if BYTE is not an integer of
the stream element type of stream.

See Also:
.........

*Note read-byte::, *Note write-char::, *Note write-sequence::


File: chris-ansicl.info,  Node: peek-char,  Next: read-char,  Prev: write-byte,  Up: Streams

peek-char (Function)
====================

Syntax:
.......

 -- Function: peek-char &optional peek-type input-stream eof-error-p
          eof-value recursive-p ý char

Arguments and Values:
.....................

PEEK-TYPE--a character or ÿtþ or ÿnilþ.

INPUT-STREAM--input stream designator.  The default is standard input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ÿnilþ.

RECURSIVE-P--a generalized boolean.  The default is false.

CHAR--a character or the EOF-VALUE.

Description:
............

ÿpeek-charþ obtains the next character in INPUT-STREAM without actually
reading it, thus leaving the character to be read at a later time.  It
can also be used to skip over and discard intervening characters in the
INPUT-STREAM until a particular character is found.

If PEEK-TYPE is not supplied or ÿnilþ, ÿpeek-charþ returns the next
character to be read from INPUT-STREAM, without actually removing it
from INPUT-STREAM.  The next time input is done from INPUT-STREAM, the
character will still be there.  If PEEK-TYPE is ÿtþ, then ÿpeek-charþ
skips over whitespaceà characters, but not comments, and then performs
the peeking operation on the next character.  The last character
examined, the one that starts an object, is not removed from
INPUT-STREAM.  If PEEK-TYPE is a character, then ÿpeek-charþ skips over
input characters until a character that is ÿchar=þ to that character is
found; that character is left in INPUT-STREAM.

If an end of fileà occurs and EOF-ERROR-P is false, EOF-VALUE is
returned.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ÿreadþ or a similar function used by the Lisp
reader.

When INPUT-STREAM is an echo stream, characters that are only peeked at
are not echoed. In the case that PEEK-TYPE is not ÿnilþ, the characters
that are passed by ÿpeek-charþ are treated as if by ÿread-charþ, and so
are echoed unless they have been marked otherwise by ÿunread-charþ.

Examples:
.........

 (with-input-from-string (input-stream "    1 2 3 4 5")
    (format t "~S ~S ~S"
            (peek-char t input-stream)
            (peek-char #\4 input-stream)
            (peek-char nil input-stream)))
Ö #\1 #\4 #\4
ý NIL

Affected By:
............

ÿ*readtable*þ, ÿ*standard-input*þ, ÿ*terminal-io*þ.

Exceptional Situations:
.......................

If EOF-ERROR-P is true and an end of fileà occurs an error of type
ÿend-of-fileþ is signaled.

If     PEEK-TYPE is a character, an end of fileà occurs, and
EOF-ERROR-P is true, an error of type ÿend-of-fileþ is signaled.

If RECURSIVE-P is true and an end of fileà occurs, an error of type
ÿend-of-fileþ is signaled.


File: chris-ansicl.info,  Node: read-char,  Next: read-char-no-hang,  Prev: peek-char,  Up: Streams

read-char (Function)
====================

Syntax:
.......

 -- Function: read-char &optional input-stream eof-error-p eof-value
          recursive-p ý char

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ÿnilþ.

RECURSIVE-P--a generalized boolean.  The default is false.

CHAR--a character or the EOF-VALUE.

Description:
............

ÿread-charþ returns the next character from INPUT-STREAM.

When INPUT-STREAM is an ECHO STREAM, the character is echoed on
INPUT-STREAM the first time the character is seen.  Characters that are
not echoed by ÿread-charþ are those that were put there by ÿunread-charþ
and hence are assumed to have been echoed already by a previous call to
ÿread-charþ.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ÿreadþ or a similar function used by the Lisp
reader.

If an end of fileà occurs and EOF-ERROR-P is false, EOF-VALUE is
returned.

Examples:
.........

 (with-input-from-string (is "0123")
    (do ((c (read-char is) (read-char is nil 'the-end)))
        ((not (characterp c)))
     (format t "~S " c)))
Ö #\0 #\1 #\2 #\3
ý NIL

Affected By:
............

ÿ*standard-input*þ, ÿ*terminal-io*þ.

Exceptional Situations:
.......................

If an end of fileà occurs before a character can be read, and
EOF-ERROR-P is true, an error of type ÿend-of-fileþ is signaled.

See Also:
.........

*Note read-byte::, *Note read-sequence::, *Note write-char::, *Note
read::

Notes:
......

The corresponding output function is ÿwrite-charþ.


File: chris-ansicl.info,  Node: read-char-no-hang,  Next: terpri; fresh-line,  Prev: read-char,  Up: Streams

read-char-no-hang (Function)
============================

Syntax:
.......

 -- Function: read-char-no-hang &optional input-stream eof-error-p
          eof-value recursive-p ý char

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ÿnilþ.

RECURSIVE-P--a generalized boolean.  The default is false.

CHAR--a character or ÿnilþ or the EOF-VALUE.

Description:
............

ÿread-char-no-hangþ returns a character from INPUT-STREAM if such a
character is available.  If no character is available,
ÿread-char-no-hangþ returns ÿnilþ.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ÿreadþ or a similar function used by the Lisp
reader.

If an end of fileà occurs and EOF-ERROR-P is false, EOF-VALUE is
returned.

Examples:
.........

;; This code assumes an implementation in which a newline is not
;; required to terminate input from the console.
 (defun test-it ()
   (unread-char (read-char))
   (list (read-char-no-hang)
         (read-char-no-hang)
         (read-char-no-hang)))
ý TEST-IT
;; Implementation A, where a Newline is not required to terminate
;; interactive input on the console.
 (test-it)
Ö a
ý (#\a NIL NIL)
;; Implementation B, where a Newline is required to terminate
;; interactive input on the console, and where that Newline remains
;; on the input stream.
 (test-it)
Ö aô
ý (#\a #\Newline NIL)

Affected By:
............

ÿ*standard-input*þ, ÿ*terminal-io*þ.

Exceptional Situations:
.......................

If an end of fileà occurs when EOF-ERROR-P is true, an error of type
ÿend-of-fileþ is signaled .

See Also:
.........

*Note listen::

Notes:
......

ÿread-char-no-hangþ is exactly like ÿread-charþ, except that if it
would be necessary to wait in order to get a character (as from a
keyboard), ÿnilþ is immediately returned without waiting.


File: chris-ansicl.info,  Node: terpri; fresh-line,  Next: unread-char,  Prev: read-char-no-hang,  Up: Streams

terpri, fresh-line (Function)
=============================

Syntax:
.......

 -- Function: terpri &optional output-stream ý ÿnilþ

 -- Function: fresh-line &optional output-stream ý generalized-boolean

Arguments and Values:
.....................

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿterpriþ outputs a newline to OUTPUT-STREAM.

ÿfresh-lineþ is similar to ÿterpriþ but outputs a newline only if the
OUTPUT-STREAM is not already at the start of a line.  If for some
reason this cannot be determined, then a newline is output anyway.
ÿfresh-lineþ returns true if it outputs a newline; otherwise it returns
false.

Examples:
.........

 (with-output-to-string (s)
    (write-string "some text" s)
    (terpri s)
    (terpri s)
    (write-string "more text" s))
ý "some text

more text"
 (with-output-to-string (s)
    (write-string "some text" s)
    (fresh-line s)
    (fresh-line s)
    (write-string "more text" s))
ý "some text
more text"

Side Effects:
.............

The OUTPUT-STREAM is modified.

Affected By:
............

ÿ*standard-output*þ, ÿ*terminal-io*þ.

Exceptional Situations:
.......................

None.

Notes:
......

ÿterpriþ is identical in effect to

 (write-char #\Newline output-stream)


File: chris-ansicl.info,  Node: unread-char,  Next: write-char,  Prev: terpri; fresh-line,  Up: Streams

unread-char (Function)
======================

Syntax:
.......

 -- Function: unread-char character &optional input-stream ý ÿnilþ

Arguments and Values:
.....................

CHARACTER--a character; must be the last character that was read from
INPUT-STREAM.

INPUT-STREAM--an input stream designator.  The default is standard
input.

Description:
............

ÿunread-charþ places CHARACTER back onto the front of INPUT-STREAM so
that it will again be the next character in INPUT-STREAM.

When INPUT-STREAM is an echo stream, no attempt is made to undo any
echoing of the character that might already have been done on
INPUT-STREAM. However, characters placed on INPUT-STREAM by
ÿunread-charþ are marked in such a way as to inhibit later re-echo by
ÿread-charþ.

It is an error to invoke ÿunread-charþ twice consecutively on the same
stream without an intervening call to ÿread-charþ (or some other input
operation which implicitly reads characters) on that stream.

Invoking ÿpeek-charþ or ÿread-charþ commits all previous characters.
The consequences of invoking ÿunread-charþ on any character preceding
that which is returned by ÿpeek-charþ (including those passed over by
ÿpeek-charþ that has a non-nil PEEK-TYPE) are unspecified.  In
particular, the consequences of invoking ÿunread-charþ after ÿpeek-charþ
are unspecified.

Examples:
.........

 (with-input-from-string (is "0123")
    (dotimes (i 6)
      (let ((c (read-char is)))
        (if (evenp i) (format t "~&~S ~S~%" i c) (unread-char c is)))))
Ö 0 #\0
Ö 2 #\1
Ö 4 #\2
ý NIL

Affected By:
............

ÿ*standard-input*þ, ÿ*terminal-io*þ.

See Also:
.........

*Note peek-char::, *Note read-char::, *Note Section 21.1 (Stream
Concepts): Stream Concepts.

Notes:
......

ÿunread-charþ is intended to be an efficient mechanism for allowing the
Lisp reader and other parsers to perform one-character lookahead in
INPUT-STREAM.


File: chris-ansicl.info,  Node: write-char,  Next: read-line,  Prev: unread-char,  Up: Streams

write-char (Function)
=====================

Syntax:
.......

 -- Function: write-char character &optional output-stream ý character

Arguments and Values:
.....................

CHARACTER--a character.

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

Description:
............

ÿwrite-charþ outputs CHARACTER to OUTPUT-STREAM.

Examples:
.........

 (write-char #\a)
Ö a
ý #\a
 (with-output-to-string (s)
   (write-char #\a s)
   (write-char #\Space s)
   (write-char #\b s))
ý "a b"

Side Effects:
.............

The OUTPUT-STREAM is modified.

Affected By:
............

ÿ*standard-output*þ, ÿ*terminal-io*þ.

See Also:
.........

*Note read-char::, *Note write-byte::, *Note write-sequence::


File: chris-ansicl.info,  Node: read-line,  Next: write-string; write-line,  Prev: write-char,  Up: Streams

read-line (Function)
====================

Syntax:
.......

 -- Function: read-line &optional input-stream eof-error-p eof-value
          recursive-p ý line, missing-newline-p

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ÿnilþ.

RECURSIVE-P--a generalized boolean.  The default is false.

LINE--a string or the EOF-VALUE.

MISSING-NEWLINE-P--a generalized boolean.

Description:
............

Reads from INPUT-STREAM a line of text that is terminated by a newline
or end of file.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ÿreadþ or a similar function used by the Lisp
reader.

The primary value, LINE, is the line that is read, represented as a
string (without the trailing newline, if any).  If  EOF-ERROR-P is false
and the end of file for INPUT-STREAM is reached before any characters
are read, EOF-VALUE is returned as the LINE.

The secondary value, MISSING-NEWLINE-P, is a generalized boolean that is
false if the LINE was terminated by a newline, or true  if the LINE was
terminated by the end of file for INPUT-STREAM (or if the LINE is the
EOF-VALUE).

Examples:
.........

 (setq a "line 1
 line2")
ý "line 1
 line2"
 (read-line (setq input-stream (make-string-input-stream a)))
ý "line 1", false
 (read-line input-stream)
ý "line2", true
 (read-line input-stream nil nil)
ý NIL, true

Affected By:
............

ÿ*standard-input*þ, ÿ*terminal-io*þ.

Exceptional Situations:
.......................

If an end of fileà occurs before any characters are read in the line,
an error is signaled if EOF-ERROR-P is true.

See Also:
.........

*Note read::

Notes:
......

The corresponding output function is ÿwrite-lineþ.


File: chris-ansicl.info,  Node: write-string; write-line,  Next: read-sequence,  Prev: read-line,  Up: Streams

write-string, write-line (Function)
===================================

Syntax:
.......

 -- Function: write-string string &optional output-stream &key start
          end ý string

 -- Function: write-line string &optional output-stream &key start end
          ý string

Arguments and Values:
.....................

STRING--a string.

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

START, END--bounding index designators of STRING.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

Description:
............

ÿwrite-stringþ writes the characters of the subsequence of STRING
bounded by START and END to OUTPUT-STREAM.  ÿwrite-lineþ does the same
thing, but then outputs a newline afterwards.

Examples:
.........

 (prog1 (write-string "books" nil :end 4) (write-string "worms"))
Ö bookworms
ý "books"
 (progn (write-char #\*)
        (write-line "test12" *standard-output* :end 5)
        (write-line "*test2")
        (write-char #\*)
        nil)
Ö *test1
Ö *test2
Ö *
ý NIL

Affected By:
............

ÿ*standard-output*þ, ÿ*terminal-io*þ.

See Also:
.........

*Note read-line::, *Note write-char::

Notes:
......

ÿwrite-lineþ and ÿwrite-stringþ return STRING, not the substring
bounded by START and END.

 (write-string string)
Õ (dotimes (i (length string)
      (write-char (char string i)))

 (write-line string)
Õ (prog1 (write-string string) (terpri))


File: chris-ansicl.info,  Node: read-sequence,  Next: write-sequence,  Prev: write-string; write-line,  Up: Streams

read-sequence (Function)
========================

Syntax:
.......

 -- Function: read-sequence sequence stream &key start end ý position

SEQUENCE--a sequence.

STREAM--an input stream.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

POSITION--an integer greater than or equal to zero, and less than or
equal to the length of the SEQUENCE.

Description:
............

Destructively modifies SEQUENCE by replacing the elements of SEQUENCE
bounded by START and END with elements read from STREAM.

SEQUENCE is destructively modified by copying successive elements into
it from STREAM.  If the end of file for STREAM is reached before
copying all elements of the subsequence, then the extra elements near
the end of SEQUENCE are not updated.

POSITION is the index of the first element of SEQUENCE that was not
updated, which might be less than END because the end of file was
reached.

Examples:
.........

 (defvar *data* (make-array 15 :initial-element nil))
 (values (read-sequence *data* (make-string-input-stream "test string")) *data*)
 ý 11, #(#\t #\e #\s #\t #\Space #\s #\t #\r #\i #\n #\g NIL NIL NIL NIL)

Side Effects:
.............

Modifies STREAM and SEQUENCE.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.  Should signal an error of type ÿtype-errorþ
if START is not a non-negative integer.  Should signal an error of type
ÿtype-errorþ if END is not a non-negative integer or ÿnilþ.

Might signal an error of type ÿtype-errorþ if an element read from the
STREAM is not a member of the element type of the SEQUENCE.

See Also:
.........

*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *Note
write-sequence::, *Note read-line::

Notes:
......

ÿread-sequenceþ is identical in effect to iterating over the indicated
subsequence and reading one element at a time from STREAM and storing
it into SEQUENCE, but may be more efficient than the equivalent loop.
An efficient implementation is more likely to exist for the case where
the SEQUENCE is a vector with the same element type as the STREAM.


File: chris-ansicl.info,  Node: write-sequence,  Next: file-length,  Prev: read-sequence,  Up: Streams

write-sequence (Function)
=========================

Syntax:
.......

 -- Function: write-sequence sequence stream &key start end ý sequence

SEQUENCE--a sequence.

STREAM--an output stream.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

Description:
............

ÿwrite-sequenceþ writes the elements of the subsequence of SEQUENCE
bounded by START and END to STREAM.

Examples:
.........

 (write-sequence "bookworms" *standard-output* :end 4)
 Ö book
 ý "bookworms"

Side Effects:
.............

Modifies STREAM.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ÿtype-errorþ if SEQUENCE
is not a proper sequence.  Should signal an error of type ÿtype-errorþ
if START is not a non-negative integer.  Should signal an error of type
ÿtype-errorþ if END is not a non-negative integer or ÿnilþ.

Might signal an error of type ÿtype-errorþ if an element of the bounded
sequence is not a member of the stream element type of the STREAM.

See Also:
.........

*Note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *Note
read-sequence::, *Note write-string::, *Note write-line::

Notes:
......

ÿwrite-sequenceþ is identical in effect to iterating over the indicated
subsequence and writing one element at a time to STREAM, but may be
more efficient than the equivalent loop.  An efficient implementation
is more likely to exist for the case where the SEQUENCE is a vector
with the same element type as the STREAM.


File: chris-ansicl.info,  Node: file-length,  Next: file-position,  Prev: write-sequence,  Up: Streams

file-length (Function)
======================

Syntax:
.......

 -- Function: file-length stream ý length

Arguments and Values:
.....................

STREAM--a stream associated with a file.

LENGTH--a non-negative integer or ÿnilþ.

Description:
............

ÿfile-lengthþ returns the length of STREAM, or ÿnilþ if the length
cannot be determined.

For a binary file, the length is measured in units of the element type
of the STREAM.

Examples:
.........

 (with-open-file (s "decimal-digits.text"
                    :direction :output :if-exists :error)
   (princ "0123456789" s)
   (truename s))
ý #P"A:>Joe>decimal-digits.text.1"
 (with-open-file (s "decimal-digits.text")
   (file-length s))
ý 10

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not a stream
associated with a file.

See Also:
.........

*Note open::


File: chris-ansicl.info,  Node: file-position,  Next: file-string-length,  Prev: file-length,  Up: Streams

file-position (Function)
========================

Syntax:
.......

 -- Function: file-position stream ý position

 -- Function: file-position stream position-spec ý success-p

Arguments and Values:
.....................

STREAM--a stream.

POSITION-SPEC--a file position designator.

POSITION--a file position or ÿnilþ.

SUCCESS-P--a generalized boolean.

Description:
............

Returns or changes the current position within a STREAM.

When POSITION-SPEC is not supplied, ÿfile-positionþ returns the current
file position in the STREAM, or ÿnilþ if this cannot be determined.

When POSITION-SPEC is supplied, the file position in STREAM is set to
that file position (if possible).  ÿfile-positionþ returns true if the
repositioning is performed successfully, or false if it is not.

An integer returned by ÿfile-positionþ of one argument should be
acceptable as POSITION-SPEC for use with the same file.

For a character file, performing a single ÿread-charþ or ÿwrite-charþ
operation may cause the file position to be increased by more than 1
because of character-set translations (such as translating between the
Common Lisp ÿ#\Newlineþ character and an external ASCII
carriage-return/line-feed sequence) and other aspects of the
implementation.  For a binary file, every ÿread-byteþ or ÿwrite-byteþ
operation increases the file position by 1.

Examples:
.........

 (defun tester ()
   (let ((noticed '()) file-written)
     (flet ((notice (x) (push x noticed) x))
       (with-open-file (s "test.bin"
                          :element-type '(unsigned-byte 8)
                          :direction :output
                          :if-exists :error)
          (notice (file-position s)) ;1
          (write-byte 5 s)
          (write-byte 6 s)
          (let ((p (file-position s)))
            (notice p) ;2
            (notice (when p (file-position s (1- p))))) ;3
          (write-byte 7 s)
          (notice (file-position s)) ;4
          (setq file-written (truename s)))
        (with-open-file (s file-written
                           :element-type '(unsigned-byte 8)
                           :direction :input)
          (notice (file-position s)) ;5
          (let ((length (file-length s)))
            (notice length) ;6
            (when length
              (dotimes (i length)
                (notice (read-byte s)))))) ;7,...
        (nreverse noticed))))
ý tester
 (tester)
ý (0 2 T 2 0 2 5 7)
orý (0 2 NIL 3 0 3 5 6 7)
orý (NIL NIL NIL NIL NIL NIL)

Side Effects:
.............

When the POSITION-SPEC argument is supplied, the file position in the
STREAM might be moved.

Affected By:
............

The value returned by ÿfile-positionþ increases monotonically as input
or output operations are performed.

Exceptional Situations:
.......................

If POSITION-SPEC is supplied, but is too large or otherwise
inappropriate, an error is signaled.

See Also:
.........

*Note file-length::, *Note file-string-length::, *Note open::

Notes:
......

Implementations that have character files represented as a sequence of
records of bounded size might choose to encode the file position as,
for example,
«record-number»*«max-record-size»+«character-within-record».  This is a
valid encoding because it increases monotonically as each character is
read or written, though not necessarily by 1 at each step.  An integer
might then be considered "inappropriate" as POSITION-SPEC to
ÿfile-positionþ if, when decoded into record number and character
number, it turned out that the supplied record was too short for the
specified character number.


File: chris-ansicl.info,  Node: file-string-length,  Next: open,  Prev: file-position,  Up: Streams

file-string-length (Function)
=============================

Syntax:
.......

 -- Function: file-string-length stream object ý length

Arguments and Values:
.....................

STREAM--an output character file stream.

OBJECT--a string or a character.

LENGTH--a non-negative integer, or ÿnilþ.

Description:
............

ÿfile-string-lengthþ returns the difference between what
ÿ(file-position STREAM)þ would be after writing OBJECT and its current
value, or ÿnilþ if this cannot be determined.

The returned value corresponds to the current state of STREAM at the
time of the call and might not be the same if it is called again when
the state of the stream has changed.


File: chris-ansicl.info,  Node: open,  Next: stream-external-format,  Prev: file-string-length,  Up: Streams

open (Function)
===============

Syntax:
.......

 -- Function: open filespec &key direction element-type
          if-exists if-does-not-exist external-format ý stream

Arguments and Values:
.....................

FILESPEC--a pathname designator.

DIRECTION--one of :input, :output, :io, or :probe.  The default is
:input.

ELEMENT-TYPE--a type specifier for recognizable subtype of ÿcharacterþ;
or a type specifier for a finite recognizable subtype of integer; or
one of the symbols signed-byte, unsigned-byte, or :default.  The
default is ÿcharacterþ.

IF-EXISTS--one of :error, :new-version, :rename, :rename-and-delete,
:overwrite, :append, :supersede, or ÿnilþ.  The default is :new-version
if the version component of FILESPEC is :newest, or :error otherwise.

IF-DOES-NOT-EXIST--one of :error, :create, or ÿnilþ.  The default is
:error if DIRECTION is :input or IF-EXISTS is :overwrite or :append;
:create if DIRECTION is :output or :io, and IF-EXISTS is neither
:overwrite nor :append; or ÿnilþ when DIRECTION is :probe.

EXTERNAL-FORMAT--an external file format designator.  The default is
:default.

STREAM--a file stream or ÿnilþ.

Description:
............

ÿopenþ creates, opens, and returns a file stream that is connected to
the file specified by FILESPEC.  FILESPEC is the name of the file to be
opened.  If the FILESPEC designator is a stream, that stream is not
closed first or otherwise affected.

The keyword arguments to ÿopenþ specify the characteristics of the file
stream that is returned, and how to handle errors.

If DIRECTION is :input or :probe, or if IF-EXISTS is not :new-version
and the version component of the FILESPEC is :newest, then the file
opened is that file already existing in the file system that has a
version greater than that of any other file in the file system whose
other pathname components are the same as those of FILESPEC.

An implementation is required to recognize all of the ÿopenþ keyword
options and to do something reasonable in the context of the host
operating system.  For example, if a file system does not support
distinct file versions and does not distinguish the notions of deletion
and expunging, :new-version might be treated the same as :rename or
:supersede, and :rename-and-delete might be treated the same as
:supersede.

:direction
     These are the possible values for DIRECTION, and how they affect
     the nature of the stream that is created:

    :input
          Causes the creation of an input file stream.

    :output
          Causes the creation of an output file stream.

    :io
          Causes the creation of a bidirectional file stream.

    :probe
          Causes the creation of a "no-directional" file stream; in
          effect, the file stream is created and then closed prior to
          being returned by ÿopenþ.

:element-type
     The ELEMENT-TYPE specifies the unit of transaction for the file
     stream.  If it is :default, the unit is determined by file system,
     possibly based on the file.

:if-exists
     IF-EXISTS specifies the action to be taken if DIRECTION is :output
     or :io and a file of the name FILESPEC already exists.  If
     DIRECTION is :input, not supplied, or :probe, IF-EXISTS is ignored.
     These are the results of ÿopenþ as modified by IF-EXISTS:

    :error
          An error of type ÿfile-errorþ is signaled.

    :new-version
          A new file is created with a larger version number.

    :rename
          The existing file is renamed to some other name and then a
          new file is created.

    :rename-and-delete
          The existing file is renamed to some other name, then it is
          deleted but not expunged, and then a new file is created.

    :overwrite
          Output operations on the stream destructively modify the
          existing file.  If DIRECTION is :io the file is opened in a
          bidirectional mode that allows both reading and writing.  The
          file pointer is initially positioned at the beginning of the
          file; however, the file is not truncated back to length zero
          when it is opened.

    :append
          Output operations on the stream destructively modify the
          existing file.  The file pointer is initially positioned at
          the end of the file.

          If DIRECTION is :io, the file is opened in a bidirectional
          mode that allows both reading and writing.

    :supersede
          The existing file is superseded; that is, a new file with the
          same name as the old one is created.  If possible, the
          implementation should not destroy the old file until the new
          stream is closed.

    ÿnilþ
          No file or stream is created; instead, ÿnilþ is returned to
          indicate failure.

:if-does-not-exist
     IF-DOES-NOT-EXIST specifies the action to be taken if a file of
     name FILESPEC does not already exist.  These are the results of
     ÿopenþ as modified by IF-DOES-NOT-EXIST:

    :error
          An error of type ÿfile-errorþ is signaled.

    :create
          An empty file is created.  Processing continues  as if the
          file had already existed but no processing as directed by
          IF-EXISTS is performed.

    ÿnilþ
          No file or stream is created; instead, ÿnilþ is returned to
          indicate failure.

:external-format
     This option selects an external file format for the file: The only
     standardized value for this option is :default, although
     implementations are permitted to define additional external file
     formats and implementation-dependent values returned by
     ÿstream-external-formatþ can also be used by conforming programs.

     The EXTERNAL-FORMAT is meaningful for any kind of file stream
     whose element type is a subtype of character.  This option is
     ignored for streams for which it is not meaningful; however,
     implementations may define other element types for which it is
     meaningful.  The consequences are unspecified if a character is
     written that cannot be represented by the given external file
     format.

When a file is opened, a file stream is constructed to serve as the
file system's ambassador to the Lisp environment; operations on the
file stream are reflected by operations on the file in the file system.

A file can be deleted, renamed, or destructively modified by ÿopenþ.

For information about opening relative pathnames, see *Note Section
19.2.3 (Merging Pathnames): Merging Pathnames.

Examples:
.........

 (open filespec :direction :probe)  ý #<Closed Probe File Stream...>
 (setq q (merge-pathnames (user-homedir-pathname) "test"))
ý #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
    :NAME "test" :TYPE NIL :VERSION :NEWEST>
 (open filespec :if-does-not-exist :create) ý #<Input File Stream...>
 (setq s (open filespec :direction :probe)) ý #<Closed Probe File Stream...>
 (truename s) ý #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY
    directory-name :NAME filespec :TYPE extension :VERSION 1>
 (open s :direction :output :if-exists nil) ý NIL

Affected By:
............

The nature and state of the host computer's file system.

Exceptional Situations:
.......................

If IF-EXISTS is :error, (subject to the constraints on the meaning of
IF-EXISTS listed above), an error of type ÿfile-errorþ is signaled.

If IF-DOES-NOT-EXIST is :error (subject to the constraints on the
meaning of IF-DOES-NOT-EXIST listed above), an error of type
ÿfile-errorþ is signaled.

If it is impossible for an implementation to handle some option in a
manner close to what is specified here, an error of type ÿerrorþ might
be signaled.

An error of type ÿfile-errorþ is signaled if ÿ(wild-pathname-p
FILESPEC)þ returns true.

An error of type ÿerrorþ is signaled if the EXTERNAL-FORMAT is not
understood by the implementation.

The various file systems in existence today have widely differing
capabilities, and some aspects of the file system are beyond the scope
of this specification to define.  A given implementation might not be
able to support all of these options in exactly the manner stated.  An
implementation is required to recognize all of these option keywords
and to try to do something "reasonable" in the context of the host file
system.  Where necessary to accomodate the file system, an
implementation deviate slightly from the semantics specified here
without being disqualified for consideration as a conforming
implementation.  If it is utterly impossible for an implementation to
handle some option in a manner similar to what is specified here, it
may simply signal an error.

With regard to the :element-type option, if a type is requested that is
not supported by the file system, a substitution of types such as that
which goes on in upgrading is permissible.  As a minimum requirement,
it should be the case that opening an output stream to a file in a
given element type and later opening an input stream to the same file
in the same element type should work compatibly.

See Also:
.........

*Note with-open-file::, *Note close::, *Note pathname (System Class)::,
*Note logical-pathname (System Class)::, *Note Section 19.2.3 (Merging
Pathnames): Merging Pathnames, *Note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.

Notes:
......

ÿopenþ does not automatically close the file when an abnormal exit
occurs.

When ELEMENT-TYPE is a subtype of ÿcharacterþ, ÿread-charþ and/or
ÿwrite-charþ can be used on the resulting file stream.

When ELEMENT-TYPE is a subtype of integer, ÿread-byteþ and/or
ÿwrite-byteþ can be used on the resulting file stream.

When ELEMENT-TYPE is :default, the type can be determined by using
ÿstream-element-typeþ.


File: chris-ansicl.info,  Node: stream-external-format,  Next: with-open-file,  Prev: open,  Up: Streams

stream-external-format (Function)
=================================

Syntax:
.......

 -- Function: stream-external-format stream ý format

Arguments and Values:
.....................

STREAM--a file stream.

FORMAT--an external file format.

Description:
............

Returns an external file format designator for the STREAM.

Examples:
.........

 (with-open-file (stream "test" :direction :output)
   (stream-external-format stream))
ý :DEFAULT
orý :ISO8859/1-1987
orý (:ASCII :SAIL)
orý ACME::PROPRIETARY-FILE-FORMAT-17
orý #<FILE-FORMAT :ISO646-1983 2343673>

See Also:
.........

the :external-format argument to the function ÿopenþ and the
ÿwith-open-fileþ macro.

Notes:
......

The FORMAT returned is not necessarily meaningful to other
implementations.


File: chris-ansicl.info,  Node: with-open-file,  Next: close,  Prev: stream-external-format,  Up: Streams

with-open-file (macro)
======================

Syntax:
.......

 -- Macro: with-open-file (stream filespec {options}*) {declaration}*
          {form}* ý results

Arguments and Values:
.....................

STREAM--a variable.

FILESPEC--a pathname designator.

OPTIONS--forms; evaluated.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

ÿwith-open-fileþ uses ÿopenþ to create a file stream to file named by
FILESPEC.  FILESPEC is the name of the file to be opened.  OPTIONS are
used as keyword arguments to ÿopenþ.

The stream object to which the STREAM variable is bound has dynamic
extent; its extent ends when the form is exited.

ÿwith-open-fileþ evaluates the FORMS as an implicit progn with STREAM
bound to the value returned by ÿopenþ.

When control leaves the body, either normally or abnormally (such as by
use of ÿthrowþ), the file is automatically closed.  If a new output
file is being written, and control leaves abnormally, the file is
aborted and the file system is left, so far as possible, as if the file
had never been opened.

It is possible by the use of ÿ:if-exists nilþ or ÿ:if-does-not-exist
nilþ for STREAM to be bound to ÿnilþ.  Users of ÿ:if-does-not-exist
nilþ should check for a valid stream.

The consequences are undefined if an attempt is made to assign the
STREAM variable.  The compiler may choose to issue a warning if such an
attempt is detected.

Examples:
.........

 (setq p (merge-pathnames "test"))
ý #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
    :NAME "test" :TYPE NIL :VERSION :NEWEST>
 (with-open-file (s p :direction :output :if-exists :supersede)
    (format s "Here are a couple~%of test data lines~%")) ý NIL
 (with-open-file (s p)
    (do ((l (read-line s) (read-line s nil 'eof)))
        ((eq l 'eof) "Reached end of file.")
     (format t "~&*** ~A~%" l)))
Ö *** Here are a couple
Ö *** of test data lines
ý "Reached end of file."

;; Normally one would not do this intentionally because it is
;; not perspicuous, but beware when using :IF-DOES-NOT-EXIST NIL
;; that this doesn't happen to you accidentally...
 (with-open-file (foo "no-such-file" :if-does-not-exist nil)
   (read foo))
Ö hello?
ý HELLO? ;This value was read from the terminal, not a file!

;; Here's another bug to avoid...
 (with-open-file (foo "no-such-file" :direction :output :if-does-not-exist nil)
   (format foo "Hello"))
ý "Hello" ;FORMAT got an argument of NIL!

Side Effects:
.............

Creates a stream to the file named by FILENAME (upon entry), and closes
the stream (upon exit).  In some implementations, the file might be
locked in some way while it is open.  If the stream is an output stream,
a file might be created.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

See the function *Note open::.

See Also:
.........

*Note open::, *Note close::, *Note pathname (System Class)::, *Note
logical-pathname (System Class)::, *Note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: close,  Next: with-open-stream,  Prev: with-open-file,  Up: Streams

close (Function)
================

Syntax:
.......

 -- Function: close stream &key abort ý result

Arguments and Values:
.....................

STREAM--a stream (either open or closed).

ABORT--a generalized boolean.  The default is false.

RESULT--ÿtþ if the STREAM was open at the time it was received as an
argument, or implementation-dependent otherwise.

Description:
............

ÿcloseþ closes STREAM.  Closing a stream means that it may no longer be
used in input or output operations.  The act of closing a file stream
ends the association between the stream and its associated file; the
transaction with the file system is terminated, and input/output may no
longer be performed on the stream.

If ABORT is true, an attempt is made to clean up any side effects of
having created STREAM.  If STREAM performs output to a file that was
created when the stream was created, the file is deleted and any
previously existing file is not superseded.

It is permissible to close an already closed stream, but in that case
the RESULT is implementation-dependent.

After STREAM is closed, it is still possible to perform the following
query operations upon it: ÿstreampþ, ÿpathnameþ, ÿtruenameþ,
ÿmerge-pathnamesþ, ÿpathname-hostþ, ÿpathname-deviceþ,
ÿpathname-directoryþ,ÿpathname-nameþ, ÿpathname-typeþ,
ÿpathname-versionþ, ÿnamestringþ, ÿfile-namestringþ,
ÿdirectory-namestringþ, ÿhost-namestringþ, ÿenough-namestringþ, ÿopenþ,
ÿprobe-fileþ, and ÿdirectoryþ.

The effect of ÿcloseþ on a constructed stream is to close the argument
STREAM only.  There is no effect on the constituents of composite
streams.

For a stream created with ÿmake-string-output-streamþ, the result of
ÿget-output-stream-stringþ is unspecified after ÿcloseþ.

Examples:
.........

 (setq s (make-broadcast-stream)) ý #<BROADCAST-STREAM>
 (close s) ý T
 (output-stream-p s) ý true

Side Effects:
.............

The STREAM is closed (if necessary).  If ABORT is true and the STREAM is
an output file stream, its associated file might be deleted.

See Also:
.........

*Note open::


File: chris-ansicl.info,  Node: with-open-stream,  Next: listen,  Prev: close,  Up: Streams

with-open-stream (Macro)
========================

Syntax:
.......

 -- Macro: with-open-stream (var stream) {declaration}* {form}* ý
          {result}*

Arguments and Values:
.....................

VAR--a variable name.

STREAM--a form; evaluated to produce a stream.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

ÿwith-open-streamþ performs a series of operations on STREAM, returns a
value, and then closes the STREAM.

VAR is bound to the value of STREAM, and then FORMS are executed as an
implicit progn.  STREAM is automatically closed on exit from
ÿwith-open-streamþ, no matter whether the exit is normal or abnormal.
The STREAM has dynamic extent; its extent ends when the form is exited.

The consequences are undefined if an attempt is made to assign the the
variable VAR with the FORMS.

Examples:
.........

 (with-open-stream (s (make-string-input-stream "1 2 3 4"))
    (+ (read s) (read s) (read s))) ý 6

Side Effects:
.............

The STREAM is closed (upon exit).

See Also:
.........

*Note close::


File: chris-ansicl.info,  Node: listen,  Next: clear-input,  Prev: with-open-stream,  Up: Streams

listen (Function)
=================

Syntax:
.......

 -- Function: listen &optional input-stream ý generalized-boolean

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if there is a character immediately available from
INPUT-STREAM; otherwise, returns false.  On a non-interactive
INPUT-STREAM, ÿlistenþ returns true except when at end of fileá.  If an
end of file is encountered, ÿlistenþ returns false.  ÿlistenþ is
intended to be used when INPUT-STREAM obtains characters from an
interactive device such as a keyboard.

Examples:
.........

 (progn (unread-char (read-char)) (list (listen) (read-char)))
Ö 1
ý (T #\1)
 (progn (clear-input) (listen))
ý NIL ;Unless you're a very fast typist!

Affected By:
............

ÿ*standard-input*þ

See Also:
.........

*Note interactive-stream-p::, *Note read-char-no-hang::


File: chris-ansicl.info,  Node: clear-input,  Next: finish-output; force-output; clear-output,  Prev: listen,  Up: Streams

clear-input (Function)
======================

Syntax:
.......

 -- Function: clear-input &optional input-stream ý ÿnilþ

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

Description:
............

Clears any available input from INPUT-STREAM.

If ÿclear-inputþ does not make sense for INPUT-STREAM, then
ÿclear-inputþ does nothing.

Examples:
.........

;; The exact I/O behavior of this example might vary from implementation
;; to implementation depending on the kind of interactive buffering that
;; occurs.  (The call to SLEEP here is intended to help even out the
;; differences in implementations which do not do line-at-a-time buffering.)

(defun read-sleepily (&optional (clear-p nil) (zzz 0))
  (list (progn (print '>) (read))
        ;; Note that input typed within the first ZZZ seconds
        ;; will be discarded.
        (progn (print '>)
               (if zzz (sleep zzz))
               (print '>>)
               (if clear-p (clear-input))
               (read))))

(read-sleepily)
Ö > 10
Ö >
Ö >> 20
ý (10 20)

(read-sleepily t)
Ö > 10
Ö >
Ö >> 20
ý (10 20)

(read-sleepily t 10)
Ö > 10
Ö > 20  ; Some implementations won't echo typeahead here.
Ö >> 30
ý (10 30)

Side Effects:
.............

The INPUT-STREAM is modified.

Affected By:
............

ÿ*standard-input*þ

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INPUT-STREAM is not a
stream designator.

See Also:
.........

*Note clear-output::


File: chris-ansicl.info,  Node: finish-output; force-output; clear-output,  Next: y-or-n-p; yes-or-no-p,  Prev: clear-input,  Up: Streams

finish-output, force-output, clear-output (Function)
====================================================

Syntax:
.......

 -- Function: finish-output &optional output-stream ý ÿnilþ

 -- Function: force-output &optional output-stream ý ÿnilþ

 -- Function: clear-output &optional output-stream ý ÿnilþ

Arguments and Values:
.....................

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

Description:
............

ÿfinish-outputþ, ÿforce-outputþ, and ÿclear-outputþ exercise control
over the internal handling of buffered stream output.

ÿfinish-outputþ attempts to ensure that any buffered output sent to
OUTPUT-STREAM has reached its destination, and then returns.

ÿforce-outputþ initiates the emptying of any internal buffers but does
not wait for completion or acknowledgment to return.

ÿclear-outputþ attempts to abort any outstanding output operation in
progress in order to allow as little output as possible to continue to
the destination.

If any of these operations does not make sense for OUTPUT-STREAM, then
it does nothing.  The precise actions of these functions are
implementation-dependent.

Examples:
.........

;; Implementation A
 (progn (princ "am i seen?") (clear-output))
ý NIL

;; Implementation B
 (progn (princ "am i seen?") (clear-output))
Ö am i seen?
ý NIL

Affected By:
............

ÿ*standard-output*þ

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if OUTPUT-STREAM is not a
stream designator.

See Also:
.........

*Note clear-input::


File: chris-ansicl.info,  Node: y-or-n-p; yes-or-no-p,  Next: make-synonym-stream,  Prev: finish-output; force-output; clear-output,  Up: Streams

y-or-n-p, yes-or-no-p (Function)
================================

Syntax:
.......

 -- Function: y-or-n-p &optional control &rest arguments ý
          generalized-boolean

 -- Function: yes-or-no-p &optional control &rest arguments ý
          generalized-boolean

Arguments and Values:
.....................

CONTROL--a format control.

ARGUMENTS--format arguments for CONTROL.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

These functions ask a question and parse a response from the user.
They return true if the answer is affirmative, or false if the answer
is negative.

ÿy-or-n-pþ is for asking the user a question whose answer is either
"yes" or "no."  It is intended that the reply require the user to
answer a yes-or-no question with a single character.  ÿyes-or-no-pþ is
also for asking the user a question whose answer is either "Yes" or
"No."  It is intended that the reply require the user to take more
action than just a single keystroke, such as typing the full word ÿyesþ
or ÿnoþ followed by a newline.

ÿy-or-n-pþ types out a message (if supplied), reads an answer in some
implementation-dependent manner (intended to be short and simple, such
as reading a single character such as ÿYþ or ÿNþ).  ÿyes-or-no-pþ types
out a message (if supplied), attracts the user's attention (for
example, by ringing the terminal's bell), and reads an answer in some
implementation-dependent manner (intended to be multiple characters,
such as ÿYESþ or ÿNOþ).

If FORMAT-CONTROL is supplied and not ÿnilþ, then a ÿfresh-lineþ
operation is performed; then a message is printed as if FORMAT-CONTROL
and ARGUMENTS were given to ÿformatþ.  In any case, ÿyes-or-no-pþ and
ÿy-or-n-pþ will provide a prompt such as "ÿ(Y or N)þ" or "ÿ(Yes or
No)þ" if appropriate.

All input and output are performed using query I/O.

Examples:
.........

 (y-or-n-p "(t or nil) given by")
Ö (t or nil) given by (Y or N) Y
ý true
 (yes-or-no-p "a ~S message" 'frightening)
Ö a FRIGHTENING message (Yes or No) no
ý false
 (y-or-n-p "Produce listing file?")
Ö Produce listing file?
Ö Please respond with Y or N. n
ý false

Side Effects:
.............

Output to and input from query I/O will occur.

Affected By:
............

ÿ*query-io*þ.

See Also:
.........

*Note format::

Notes:
......

ÿyes-or-no-pþ and ÿyes-or-no-pþ do not add question marks to the end of
the prompt string, so any desired question mark or other punctuation
should be explicitly included in the text query.


File: chris-ansicl.info,  Node: make-synonym-stream,  Next: synonym-stream-symbol,  Prev: y-or-n-p; yes-or-no-p,  Up: Streams

make-synonym-stream (Function)
==============================

Syntax:
.......

 -- Function: make-synonym-stream symbol ý synonym-stream

Arguments and Values:
.....................

SYMBOL--a symbol that names a dynamic variable.

SYNONYM-STREAM--a synonym stream.

Description:
............

Returns a synonym stream whose synonym stream symbol is SYMBOL.

Examples:
.........

 (setq a-stream (make-string-input-stream "a-stream")
        b-stream (make-string-input-stream "b-stream"))
ý #<String Input Stream>
 (setq s-stream (make-synonym-stream 'c-stream))
ý #<SYNONYM-STREAM for C-STREAM>
 (setq c-stream a-stream)
ý #<String Input Stream>
 (read s-stream) ý A-STREAM
 (setq c-stream b-stream)
ý #<String Input Stream>
 (read s-stream) ý B-STREAM

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if its argument is not a symbol.

See Also:
.........

*Note Section 21.1 (Stream Concepts): Stream Concepts.


File: chris-ansicl.info,  Node: synonym-stream-symbol,  Next: broadcast-stream-streams,  Prev: make-synonym-stream,  Up: Streams

synonym-stream-symbol (Function)
================================

Syntax:
.......

 -- Function: synonym-stream-symbol synonym-stream ý symbol

Arguments and Values:
.....................

SYNONYM-STREAM--a synonym stream.

SYMBOL--a symbol.

Description:
............

Returns the symbol whose ÿsymbol-valueþ the SYNONYM-STREAM is using.

See Also:
.........

*Note make-synonym-stream::


File: chris-ansicl.info,  Node: broadcast-stream-streams,  Next: make-broadcast-stream,  Prev: synonym-stream-symbol,  Up: Streams

broadcast-stream-streams (Function)
===================================

Syntax:
.......

 -- Function: broadcast-stream-streams broadcast-stream ý streams

Arguments and Values:
.....................

BROADCAST-STREAM--a broadcast stream.

STREAMS--a list of streams.

Description:
............

Returns a list of output streams that constitute all the streams to
which the BROADCAST-STREAM is broadcasting.


File: chris-ansicl.info,  Node: make-broadcast-stream,  Next: make-two-way-stream,  Prev: broadcast-stream-streams,  Up: Streams

make-broadcast-stream (Function)
================================

Syntax:
.......

 -- Function: make-broadcast-stream &rest streams ý broadcast-stream

Arguments and Values:
.....................

STREAM--an output stream.

BROADCAST-STREAM--a broadcast stream.

Description:
............

Returns a broadcast stream.

Examples:
.........

 (setq a-stream (make-string-output-stream)
        b-stream (make-string-output-stream)) ý #<String Output Stream>
 (format (make-broadcast-stream a-stream b-stream)
          "this will go to both streams") ý NIL
 (get-output-stream-string a-stream) ý "this will go to both streams"
 (get-output-stream-string b-stream) ý "this will go to both streams"

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if STREAM is not an output
stream.

See Also:
.........

*Note broadcast-stream-streams::


File: chris-ansicl.info,  Node: make-two-way-stream,  Next: two-way-stream-input-stream; two-way-stream-output-stream,  Prev: make-broadcast-stream,  Up: Streams

make-two-way-stream (Function)
==============================

Syntax:
.......

 -- Function: make-two-way-stream input-stream output-stream ý
          two-way-stream

Arguments and Values:
.....................

INPUT-STREAM--a stream.

OUTPUT-STREAM--a stream.

TWO-WAY-STREAM--a two-way stream.

Description:
............

Returns a two-way stream that gets  its input  from INPUT-STREAM and
sends its output to   OUTPUT-STREAM.

Examples:
.........

 (with-output-to-string (out)
    (with-input-from-string (in "input...")
      (let ((two (make-two-way-stream in out)))
        (format two "output...")
        (setq what-is-read (read two))))) ý "output..."
 what-is-read ý INPUT...

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if INPUT-STREAM is not an
input stream.  Should signal an error of type ÿtype-errorþ if
OUTPUT-STREAM is not an output stream.


File: chris-ansicl.info,  Node: two-way-stream-input-stream; two-way-stream-output-stream,  Next: echo-stream-input-stream; echo-stream-output-stream,  Prev: make-two-way-stream,  Up: Streams

two-way-stream-input-stream, two-way-stream-output-stream (Function)
====================================================================

Syntax:
.......

 -- Function: two-way-stream-input-stream two-way-stream ý input-stream

 -- Function: two-way-stream-output-stream two-way-stream ý
          output-stream

Arguments and Values:
.....................

TWO-WAY-STREAM--a two-way stream.

INPUT-STREAM--an input stream.

OUTPUT-STREAM--an output stream.

Description:
............

ÿtwo-way-stream-input-streamþ returns the stream from which
TWO-WAY-STREAM receives input.

ÿtwo-way-stream-output-streamþ returns the stream to which
TWO-WAY-STREAM sends output.


File: chris-ansicl.info,  Node: echo-stream-input-stream; echo-stream-output-stream,  Next: make-echo-stream,  Prev: two-way-stream-input-stream; two-way-stream-output-stream,  Up: Streams

echo-stream-input-stream, echo-stream-output-stream (Function)
==============================================================

Syntax:
.......

 -- Function: echo-stream-input-stream echo-stream ý input-stream

 -- Function: echo-stream-output-stream echo-stream ý output-stream

Arguments and Values:
.....................

ECHO-STREAM--an echo stream.

INPUT-STREAM--an input stream.

ÿoutput-streamþ--an output stream.

Description:
............

ÿecho-stream-input-streamþ returns the input stream from which
ECHO-STREAM receives input.

ÿecho-stream-output-streamþ returns the output stream to which
ECHO-STREAM sends output.


File: chris-ansicl.info,  Node: make-echo-stream,  Next: concatenated-stream-streams,  Prev: echo-stream-input-stream; echo-stream-output-stream,  Up: Streams

make-echo-stream (Function)
===========================

Syntax:
.......

 -- Function: make-echo-stream input-stream output-stream ý echo-stream

Arguments and Values:
.....................

INPUT-STREAM--an input stream.

OUTPUT-STREAM--an output stream.

ECHO-STREAM--an echo stream.

Description:
............

Creates and returns an echo stream that takes input  from INPUT-STREAM
and  sends output to   OUTPUT-STREAM.

Examples:
.........

 (let ((out (make-string-output-stream)))
    (with-open-stream
        (s (make-echo-stream
            (make-string-input-stream "this-is-read-and-echoed")
            out))
      (read s)
      (format s " * this-is-direct-output")
      (get-output-stream-string out)))
ý "this-is-read-and-echoed * this-is-direct-output"

See Also:
.........

*Note echo-stream-input-stream::, *Note echo-stream-output-stream::,
*Note make-two-way-stream::


File: chris-ansicl.info,  Node: concatenated-stream-streams,  Next: make-concatenated-stream,  Prev: make-echo-stream,  Up: Streams

concatenated-stream-streams (Function)
======================================

Syntax:
.......

 -- Function: concatenated-stream-streams concatenated-stream ý streams

Arguments and Values:
.....................

CONCATENATED-STREAM--a concatenated stream.

STREAMS--a list of input streams.

Description:
............

Returns a list of input streams that constitute the ordered set of
streams the CONCATENATED-STREAM still has to read from, starting with
the current one it is reading from.  The list may be empty if no more
streams remain to be read.

The consequences are undefined if the list structure of the STREAMS is
ever modified.


File: chris-ansicl.info,  Node: make-concatenated-stream,  Next: get-output-stream-string,  Prev: concatenated-stream-streams,  Up: Streams

make-concatenated-stream (Function)
===================================

Syntax:
.......

 -- Function: make-concatenated-stream &rest input-streams ý
          concatenated-stream

Arguments and Values:
.....................

INPUT-STREAM--an input stream.

CONCATENATED-STREAM--a concatenated stream.

Description:
............

Returns a concatenated stream that has the indicated INPUT-STREAMS
initially associated with it.

Examples:
.........

 (read (make-concatenated-stream
         (make-string-input-stream "1")
         (make-string-input-stream "2"))) ý 12

Exceptional Situations:
.......................

Should signal ÿtype-errorþ if any argument is not an input stream.

See Also:
.........

*Note concatenated-stream-streams::


File: chris-ansicl.info,  Node: get-output-stream-string,  Next: make-string-input-stream,  Prev: make-concatenated-stream,  Up: Streams

get-output-stream-string (Function)
===================================

Syntax:
.......

 -- Function: get-output-stream-string string-output-stream ý string

Arguments and Values:
.....................

STRING-OUTPUT-STREAM--a stream.

STRING--a string.

Description:
............

Returns a string containing, in order, all the characters that have
been output to STRING-OUTPUT-STREAM.  This operation clears any
characters on STRING-OUTPUT-STREAM, so the STRING contains only those
characters which have been output since the last call to
ÿget-output-stream-stringþ or since the creation of the
STRING-OUTPUT-STREAM, whichever occurred most recently.

Examples:
.........

 (setq a-stream (make-string-output-stream)
        a-string "abcdefghijklm") ý "abcdefghijklm"
 (write-string a-string a-stream) ý "abcdefghijklm"
 (get-output-stream-string a-stream) ý "abcdefghijklm"
 (get-output-stream-string a-stream) ý ""

Side Effects:
.............

The STRING-OUTPUT-STREAM is cleared.

Exceptional Situations:
.......................

The consequences are undefined if STREAM-OUTPUT-STRING is closed.

The consequences are undefined if STRING-OUTPUT-STREAM is a stream that
was not produced by ÿmake-string-output-streamþ.  The consequences are
undefined if STRING-OUTPUT-STREAM was created implicitly by
ÿwith-output-to-stringþ or ÿformatþ.

See Also:
.........

*Note make-string-output-stream::


File: chris-ansicl.info,  Node: make-string-input-stream,  Next: make-string-output-stream,  Prev: get-output-stream-string,  Up: Streams

make-string-input-stream (Function)
===================================

Syntax:
.......

 -- Function: make-string-input-stream string &optional start end ý
          string-stream

Arguments and Values:
.....................

STRING--a string.

START, END--bounding index designators of STRING.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

STRING-STREAM--an input string stream.

Description:
............

Returns an input string stream.  This stream will supply, in order, the
characters in the substring of STRING bounded by START and END.  After
the last character has been supplied, the string stream will then be at
end of file.

Examples:
.........

 (let ((string-stream (make-string-input-stream "1 one ")))
   (list (read string-stream nil nil)
         (read string-stream nil nil)
         (read string-stream nil nil)))
ý (1 ONE NIL)

 (read (make-string-input-stream "prefixtargetsuffix" 6 12)) ý TARGET

See Also:
.........

*Note with-input-from-string::


File: chris-ansicl.info,  Node: make-string-output-stream,  Next: with-input-from-string,  Prev: make-string-input-stream,  Up: Streams

make-string-output-stream (Function)
====================================

Syntax:
.......

 -- Function: make-string-output-stream &key element-type ý
          string-stream

Arguments and Values:
.....................

ELEMENT-TYPE--a type specifier.  The default is ÿcharacterþ.

STRING-STREAM--an output string stream.

Description:
............

Returns an output string stream that accepts characters and makes
available (via ÿget-output-stream-stringþ) a string that contains the
characters that were actually output.

The ELEMENT-TYPE names the type of the elements of the string; a string
is constructed of the most specialized type that can accommodate
elements of that element-type.

Examples:
.........

 (let ((s (make-string-output-stream)))
   (write-string "testing... " s)
   (prin1 1234 s)
   (get-output-stream-string s))
ý "testing... 1234"

.

See Also:
.........

*Note get-output-stream-string::, *Note with-output-to-string::


File: chris-ansicl.info,  Node: with-input-from-string,  Next: with-output-to-string,  Prev: make-string-output-stream,  Up: Streams

with-input-from-string (Macro)
==============================

Syntax:
.......

 -- Macro: with-input-from-string (var string &key index start end)
          {declaration}* {form}* ý {result}*

Arguments and Values:
.....................

VAR--a variable name.

STRING--a form; evaluated to produce a string.

INDEX--a place.

START, END--bounding index designators of STRING.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULT--the values returned by the FORMS.

Description:
............

Creates an input string stream, provides an opportunity to perform
operations on the stream (returning zero or more values), and then
closes the string stream.

STRING is evaluated first, and VAR is bound to a character input string
stream that supplies characters from the subsequence of the resulting
string bounded by START and END.  The body is executed as an implicit
progn.

The input string stream is automatically closed on exit from
ÿwith-input-from-stringþ, no matter whether the exit is normal or
abnormal.  The input string stream to which the variable VAR is bound
has dynamic extent; its extent ends when the form is exited.

The INDEX is a pointer within the STRING to be advanced.  If
ÿwith-input-from-stringþ is exited normally, then INDEX will have as
its value the index into the STRING indicating the first character not
read which is ÿ(length STRING)þ if all characters were used.  The place
specified by INDEX is not updated as reading progresses, but only at the
end of the operation.

START and INDEX may both specify the same variable, which is a pointer
within the STRING to be advanced, perhaps repeatedly by some containing
loop.

The consequences are undefined if an attempt is made to assign the
variable VAR.

Examples:
.........

 (with-input-from-string (s "XXX1 2 3 4xxx"
                             :index ind
                             :start 3 :end 10)
    (+ (read s) (read s) (read s))) ý 6
 ind ý 9
 (with-input-from-string (s "Animal Crackers" :index j :start 6)
   (read s)) ý CRACKERS

The variable ÿjþ is set to ÿ15þ.

Side Effects:
.............

The value of the place named by INDEX, if any, is modified.

See Also:
.........

*Note make-string-input-stream::, *Note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.


File: chris-ansicl.info,  Node: with-output-to-string,  Next: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Prev: with-input-from-string,  Up: Streams

with-output-to-string (Macro)
=============================

Syntax:
.......

 -- Macro: with-output-to-string (var &optional string-form &key
          element-type) {declaration}* {form}* ý {result}*

Arguments and Values:
.....................

VAR--a variable name.

STRING-FORM--a form or ÿnilþ; if non-nil, evaluated to produce STRING.

STRING--a string that has a fill pointer.

ELEMENT-TYPE--a type specifier; evaluated.  The default is ÿcharacterþ.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--If a STRING-FORM is not supplied or ÿnilþ, a string; otherwise,
the values returned by the FORMS.

Description:
............

ÿwith-output-to-stringþ creates a character output stream, performs a
series of operations that may send results to this stream, and then
closes the stream.

The ELEMENT-TYPE names the type of the elements of the stream; a stream
is constructed of the most specialized type that can accommodate
elements of the given type.

The body is executed as an implicit progn with VAR bound to an output
string stream.  All output to that string stream is saved in a string.

If STRING is supplied, ELEMENT-TYPE is ignored, and the output is
incrementally appended to STRING as if by use of ÿvector-push-extendþ.

The output stream is automatically closed on exit from
ÿwith-output-from-stringþ, no matter whether the exit is normal or
abnormal.  The output string stream to which the variable VAR is bound
has dynamic extent; its extent ends when the form is exited.

If no STRING is provided, then ÿwith-output-from-stringþ produces a
stream that accepts characters and returns a string of the indicated
ELEMENT-TYPE.  If STRING is provided, ÿwith-output-to-stringþ returns
the results of evaluating the last FORM.

The consequences are undefined if an attempt is made to assign the
variable VAR.

Examples:
.........

 (setq fstr (make-array '(0) :element-type 'base-char
                             :fill-pointer 0 :adjustable t)) ý ""
 (with-output-to-string (s fstr)
    (format s "here's some output")
    (input-stream-p s)) ý false
 fstr ý "here's some output"

Side Effects:
.............

The STRING is modified.

Exceptional Situations:
.......................

The consequences are undefined if destructive modifications are
performed directly on the STRING during the dynamic extent of the call.

See Also:
.........

*Note make-string-output-stream::, *Note vector-push-extend::, *Note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.


File: chris-ansicl.info,  Node: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Next: *terminal-io*,  Prev: with-output-to-string,  Up: Streams

*debug-io*, *error-output*, *query-io*, *standard-input*, *standard-output*, *trace-output* (Variable)
======================================================================================================

Value Type:
...........

For ÿ*standard-input*þ: an input stream

For ÿ*error-output*þ, ÿ*standard-output*þ, and ÿ*trace-output*þ: an
output stream.

For ÿ*debug-io*þ, ÿ*query-io*þ: a bidirectional stream.

Initial Value:
..............

implementation-dependent, but it must be an open stream that is not a
generalized synonym stream to an I/O customization variables but that
might be a generalized synonym stream to the value of some I/O
customization variable.  The initial value might also be a generalized
synonym stream to either the symbol ÿ*terminal-io*þ or to the stream
that is its value.

Description:
............

These variables are collectively called the standardized I/O
customization variables.  They can be bound or assigned in order to
change the default destinations for input and/or output used by various
standardized operators and facilities.

The value of ÿ*debug-io*þ, called debug I/O, is a stream to be used for
interactive debugging purposes.

The value of ÿ*error-output*þ, called error output, is a stream to
which warnings and non-interactive error messages should be sent.

The value of ÿ*query-io*þ, called query I/O, is a bidirectional stream
to be used when asking questions of the user.  The question should be
output to this stream, and the answer read from it.

The value of ÿ*standard-input*þ, called standard input, is a stream
that is used by many operators as a default source of input when no
specific input stream is explicitly supplied.

The value of ÿ*standard-output*þ, called standard output, is a stream
that is used by many operators as a default destination for output when
no specific output stream is explicitly supplied.

The value of ÿ*trace-output*þ, called trace output, is the stream on
which traced functions (see ÿtraceþ) and the ÿtimeþ macro print their
output.

Examples:
.........

 (with-output-to-string (*error-output*)
   (warn "this string is sent to *error-output*"))
 ý "Warning: this string is sent to *error-output*
" ;The exact format of this string is implementation-dependent.


 (with-input-from-string (*standard-input* "1001")
    (+ 990 (read))) ý 1991


 (progn (setq out (with-output-to-string (*standard-output*)
                     (print "print and format t send things to")
                     (format t "*standard-output* now going to a string")))
        :done)
ý :DONE
 out
ý "
\"print and format t send things to\" *standard-output* now going to a string"


 (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))
ý FACT
 (trace fact)
ý (FACT)
;; Of course, the format of traced output is implementation-dependent.
 (with-output-to-string (*trace-output*)
   (fact 3))
ý "
1 Enter FACT 3
| 2 Enter FACT 2
|   3 Enter FACT 1
|   3 Exit FACT 1
| 2 Exit FACT 2
1 Exit FACT 6"

See Also:
.........

*Note *terminal-io*::, *Note synonym-stream::, *Note time (Macro)::,
*Note trace::, *Note Chapter 9 (Conditions): Conditions, *Note Chapter
23 (Reader): Reader, *Note Chapter 22 (Printer): Printer.

Notes:
......

The intent of the constraints on the initial value of the I/O
customization variables is to ensure that it is always safe to bind or
assign such a variable to the value of another I/O customization
variable, without unduly restricting implementation flexibility.

It is common for an implementation to make the initial values of
ÿ*debug-io*þ and ÿ*query-io*þ be the same stream, and to make the
initial values of ÿ*error-output*þ and ÿ*standard-output*þ be the same
stream.

The functions ÿy-or-n-pþ and ÿyes-or-no-pþ use query I/O for their
input and output.

In the normal Lisp read-eval-print loop, input is read from standard
input.  Many input functions, including ÿreadþ and ÿread-charþ, take a
stream argument that defaults to standard input.

In the normal Lisp read-eval-print loop, output is sent to standard
output.  Many output functions, including ÿprintþ and ÿwrite-charþ,
take a stream argument that defaults to standard output.

A program that wants, for example, to divert output to a file should do
so by binding ÿ*standard-output*þ; that way error messages sent to
ÿ*error-output*þ can still get to the user by going through
ÿ*terminal-io*þ (if ÿ*error-output*þ is bound to ÿ*terminal-io*þ),
which is usually what is desired.


File: chris-ansicl.info,  Node: *terminal-io*,  Next: stream-error,  Prev: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Up: Streams

*terminal-io* (Variable)
========================

Value Type:
...........

a bidirectional stream.

Initial Value:
..............

implementation-dependent, but it must be an open stream that is not a
generalized synonym stream to an I/O customization variables but that
might be a generalized synonym stream to the value of some I/O
customization variable.

Description:
............

The value of ÿ*terminal-io*þ, called  terminal I/O, is ordinarily a
bidirectional stream that connects to the user's console.  Typically,
writing to this stream would cause the output to appear on a display
screen, for example, and reading from the stream would accept input
from a keyboard.  It is intended that standard input functions such as
ÿreadþ and ÿread-charþ, when used with this stream, cause echoing of
the input into the output side of the stream. The means by which this is
accomplished are implementation-dependent.

The effect of changing the value of ÿ*terminal-io*þ, either by binding
or assignment, is implementation-defined.

Examples:
.........

 (progn (prin1 'foo) (prin1 'bar *terminal-io*))
Ö FOOBAR
ý BAR
 (with-output-to-string (*standard-output*)
   (prin1 'foo)
   (prin1 'bar *terminal-io*))
Ö BAR
ý "FOO"

See Also:
.........

*Note *debug-io*::, *Note *error-output*::, *Note *query-io*::, *Note
*standard-input*::, *Note *standard-output*::, *Note *trace-output*::


File: chris-ansicl.info,  Node: stream-error,  Next: stream-error-stream,  Prev: *terminal-io*,  Up: Streams

stream-error (Condition Type)
=============================

Class Precedence List:
......................

ÿstream-errorþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿstream-errorþ consists of error conditions that are related
to receiving input from or sending output to a stream.  The "offending
stream" is initialized by the :stream initialization argument to
ÿmake-conditionþ, and is accessed by the function ÿstream-error-streamþ.

See Also:
.........

*Note stream-error-stream::


File: chris-ansicl.info,  Node: stream-error-stream,  Next: end-of-file,  Prev: stream-error,  Up: Streams

stream-error-stream (Function)
==============================

Syntax:
.......

 -- Function: stream-error-stream condition ý stream

Arguments and Values:
.....................

CONDITION--a condition of type ÿstream-errorþ.

STREAM--a stream.

Description:
............

Returns the offending stream of a condition of type ÿstream-errorþ.

Examples:
.........

 (with-input-from-string (s "(FOO")
   (handler-case (read s)
     (end-of-file (c)
       (format nil "~&End of file on ~S." (stream-error-stream c)))))
"End of file on #<String Stream>."

See Also:
.........

*Note stream-error::, *Note Chapter 9 (Conditions): Conditions.


File: chris-ansicl.info,  Node: end-of-file,  Prev: stream-error-stream,  Up: Streams

end-of-file (Condition Type)
============================

Class Precedence List:
......................

ÿend-of-fileþ, ÿstream-errorþ, ÿerrorþ, ÿserious-conditionþ,
ÿconditionþ, ÿtþ

Description:
............

The type ÿend-of-fileþ consists of error conditions related to read
operations that are done on streams that have no more data.

See Also:
.........

*Note stream-error-stream::


File: chris-ansicl.info,  Node: Printer,  Next: Reader,  Prev: Streams,  Up: Top

22 Printer
**********

* Menu:

* The Lisp Printer::
* The Lisp Pretty Printer::
* Formatted Output::

Dictionary

* copy-pprint-dispatch::
* formatter::
* pprint-dispatch::
* pprint-exit-if-list-exhausted::
* pprint-fill; pprint-linear; pprint-tabular::
* pprint-indent::
* pprint-logical-block::
* pprint-newline::
* pprint-pop::
* pprint-tab::
* print-object::
* print-unreadable-object::
* set-pprint-dispatch::
* write; prin1; print; pprint; princ::
* write-to-string; prin1-to-string; princ-to-string::
* *print-array*::
* *print-base*; *print-radix*::
* *print-case*::
* *print-circle*::
* *print-escape*::
* *print-gensym*::
* *print-level*; *print-length*::
* *print-lines*::
* *print-miser-width*::
* *print-pprint-dispatch*::
* *print-pretty*::
* *print-readably*::
* *print-right-margin*::
* print-not-readable::
* print-not-readable-object::
* format::


File: chris-ansicl.info,  Node: The Lisp Printer,  Next: The Lisp Pretty Printer,  Up: Printer

22.1 The Lisp Printer
=====================

* Menu:

* Overview of The Lisp Printer::
* Printer Dispatching::
* Default Print-Object Methods::
* Examples of Printer Behavior::


File: chris-ansicl.info,  Node: Overview of The Lisp Printer,  Next: Printer Dispatching,  Up: The Lisp Printer

22.1.1 Overview of The Lisp Printer
-----------------------------------

Common Lisp provides a representation of most objects in the form of
printed text called the printed representation.  Functions such as
ÿprintþ take an object and send the characters of its printed
representation to a stream.  The collection of routines that does this
is known as the (Common Lisp) printer.

Reading a printed representation typically produces an object that is
ÿequalþ to the originally printed object.

22.1.1.1 Multiple Possible Textual Representations
..................................................

Most objects have more than one possible textual representation.  For
example, the positive integer with a magnitude of twenty-seven can be
textually expressed in any of these ways:

 27    27.    #o33    #x1B    #b11011    #.(* 3 3 3)    81/3

A list containing the two symbols ÿAþ and ÿBþ can also be textually
expressed in a variety of ways:

 (A B)    (a b)    (  a  b )    (\A |B|)
(|\A|
  B
)

In general, from the point of view of the Lisp reader, wherever
whitespace is permissible in a textual representation, any number of
spaces and newlines can appear in standard syntax.

When a function such as ÿprintþ produces a printed representation, it
must choose from among many possible textual representations.  In most
cases, it chooses a program readable representation, but in certain
cases it might use a more compact notation that is not program-readable.

A number of option variables, called "printer control variables", are
provided to permit control of individual aspects of the printed
representation of objects.  The next figure shows the standardized
printer control variables; there might also be implementation-defined
printer control variables.

*print-array*    *print-gensym*        *print-pprint-dispatch*
*print-base*     *print-length*        *print-pretty*
*print-case*     *print-level*         *print-radix*
*print-circle*   *print-lines*         *print-readably*
*print-escape*   *print-miser-width*   *print-right-margin*

Figure 22.1: Standardized Printer Control Variables

In addition to the printer control variables, the following additional
defined names relate to or affect the behavior of the Lisp printer:

*package*                     *read-eval*   readtable-case
*read-default-float-format*   *readtable*   

Figure 22.2: Additional Influences on the Lisp printer.

22.1.1.1.1 Printer Escaping
...........................

The variable ÿ*print-escape*þ controls whether the Lisp printer tries
to produce notations such as escape characters and package prefixes.

The variable ÿ*print-readably*þ can be used to override many of the
individual aspects controlled by the other printer control variables
when program-readable output is especially important.

One of the many effects of making the value of ÿ*print-readably*þ be
true is that the Lisp printer behaves as if ÿ*print-escape*þ were also
true.  For notational convenience, we say that if the value of either
ÿ*print-readably*þ or ÿ*print-escape*þ is true, then "printer escaping"
is "enabled"; and we say that if the values of both ÿ*print-readably*þ
and ÿ*print-escape*þ are false, then printer escaping is "disabled".


File: chris-ansicl.info,  Node: Printer Dispatching,  Next: Default Print-Object Methods,  Prev: Overview of The Lisp Printer,  Up: The Lisp Printer

22.1.2 Printer Dispatching
--------------------------

The Lisp printer makes its determination of how to print an object as
follows:

If the value of ÿ*print-pretty*þ is true, printing is controlled by the
current pprint dispatch table; see *Note Section 22.2.1.4 (Pretty Print
Dispatch Tables): PPrintDispatchTables.

Otherwise (if the value of ÿ*print-pretty*þ is false), the object's
ÿprint-objectþ method is used; see *Note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods.


File: chris-ansicl.info,  Node: Default Print-Object Methods,  Next: Examples of Printer Behavior,  Prev: Printer Dispatching,  Up: The Lisp Printer

22.1.3 Default Print-Object Methods
-----------------------------------

This section describes the default behavior of ÿprint-objectþ methods
for the standardized types.

22.1.3.1 Printing Numbers
.........................

22.1.3.1.1 Printing Integers
............................

Integers are printed in the radix specified by the current output base
in positional notation, most significant digit first.  If appropriate,
a radix specifier can be printed; see ÿ*print-radix*þ.  If an integer
is negative, a minus sign is printed and then the absolute value of the
integer is printed.  The integer zero is represented by the single
digit ÿ0þ and never has a sign.  A decimal point might be printed,
depending on the value of ÿ*print-radix*þ.

For related information about the syntax of an integer, see *Note
Section 2.3.2.1.1 (Syntax of an Integer): SyntaxOfIntegers.

22.1.3.1.2 Printing Ratios
..........................

Ratios are printed as follows: the absolute value of the numerator is
printed, as for an integer; then a ÿ/þ; then the denominator.  The
numerator and denominator are both printed in the radix specified by
the current output base; they are obtained as if by ÿnumeratorþ and
ÿdenominatorþ, and so ratios are printed in reduced form (lowest terms).
If appropriate, a radix specifier can be printed; see ÿ*print-radix*þ.
If the ratio is negative, a minus sign is printed before the numerator.

For related information about the syntax of a ratio, see *Note Section
2.3.2.1.2 (Syntax of a Ratio): SyntaxOfRatios.

22.1.3.1.3 Printing Floats
..........................

If the magnitude of the float is either zero or between 10^-3
(inclusive) and 10^7 (exclusive), it is printed as the integer part of
the number, then a decimal point, followed by the fractional part of
the number; there is always at least one digit on each side of the
decimal point.  If the sign of the number (as determined by
ÿfloat-signþ) is negative, then a minus sign is printed before the
number.  If the format of the number does not match that specified by
ÿ*read-default-float-format*þ, then the exponent marker for that format
and the digit ÿ0þ are also printed.  For example, the base of the
natural logarithms as a short float might be printed as ÿ2.71828S0þ.

For non-zero magnitudes outside of the range 10^-3 to 10^7, a float is
printed in computerized scientific notation.  The representation of the
number is scaled to be between 1 (inclusive) and 10 (exclusive) and
then printed, with one digit before the decimal point and at least one
digit after the decimal point.  Next the exponent marker for the format
is printed, except that if the format of the number matches that
specified by ÿ*read-default-float-format*þ, then the exponent marker ÿEþ
is used.  Finally, the power of ten by which the fraction must be
multiplied to equal the original number is printed as a decimal integer.
For example, Avogadro's number as a short float is printed as ÿ6.02S23þ.

For related information about the syntax of a float, see *Note Section
2.3.2.2 (Syntax of a Float): SyntaxOfFloats.

22.1.3.1.4 Printing Complexes
.............................

A complex is printed as ÿ#Cþ, an open parenthesis, the printed
representation of its real part, a space, the printed representation of
its imaginary part, and finally a close parenthesis.

For related information about the syntax of a complex, see *Note
Section 2.3.2.3 (Syntax of a Complex): SyntaxOfComplexes. and *Note
Section 2.4.8.11 (Sharpsign C): SharpsignC.

22.1.3.1.5 Note about Printing Numbers
......................................

The printed representation of a number must not contain escape
characters; see *Note Section 2.3.1.1.1 (Escape Characters and
Potential Numbers): EscCharsAndPotentialNums.

22.1.3.2 Printing Characters
............................

When printer escaping is disabled, a character prints as itself; it is
sent directly to the output stream.  When printer escaping is enabled,
then ÿ#\þ syntax is used.

When the printer types out the name of a character, it uses the same
table as the ÿ#\þ reader macro would use; therefore any character name
that is typed out is acceptable as input (in that implementation).  If
a non-graphic character has a standardized nameÝ, that name is
preferred over non-standard names for printing in ÿ#\þ notation.  For
the graphic standard characters, the character itself is always used
for printing in ÿ#\þ notation--even if the character also has a nameÝ.

For details about the ÿ#\þ reader macro, see *Note Section 2.4.8.1
(Sharpsign Backslash): SharpsignBackslash.

22.1.3.3 Printing Symbols
.........................

When printer escaping is disabled, only the characters of the symbol's
name are output (but the case in which to print characters in the name
is controlled by ÿ*print-case*þ; see *Note Section 22.1.3.3.2 (Effect
of Readtable Case on the Lisp Printer): ReadtableCasePrintEffect.).

The remainder of this section applies only when printer escaping is
enabled.

When printing a symbol, the printer inserts enough single escape and/or
multiple escape characters (backslashes and/or vertical-bars) so that if
ÿreadþ were called with the same ÿ*readtable*þ and with ÿ*read-base*þ
bound to the current output base, it would return the same symbol (if
it is not apparently uninterned) or an uninterned symbol with the same
print name (otherwise).

For example, if the value of ÿ*print-base*þ were ÿ16þ when printing the
symbol ÿfaceþ, it would have to be printed as ÿ\FACEþ or ÿ\Faceþ or
ÿ|FACE|þ, because the token ÿfaceþ would be read as a hexadecimal
number (decimal value 64206) if the value of ÿ*read-base*þ were ÿ16þ.

For additional restrictions concerning characters with  nonstandard
syntax types in the current readtable, see the variable *Note
*print-readably*::

For information about how the Lisp reader parses symbols, see *Note
Section 2.3.4 (Symbols as Tokens): Symbols as Tokens. and *Note Section
2.4.8.5 (Sharpsign Colon): SharpsignColon.

ÿnilþ might be printed as ÿ()þ when ÿ*print-pretty*þ is true and
printer escaping is enabled.

22.1.3.3.1 Package Prefixes for Symbols
.......................................

Package prefixes are printed if necessary.  The rules for package
prefixes are as follows.  When the symbol is printed, if it is in the
ÿKEYWORDþ package, then it is printed with a preceding colon;
otherwise, if it is accessible in the current package, it is printed
without any package prefix; otherwise, it is printed with a package
prefix.

A symbol that is apparently uninterned is printed preceded by "ÿ#:þ" if
ÿ*print-gensym*þ is true and printer escaping is enabled; if
ÿ*print-gensym*þ is false or printer escaping is disabled, then the
symbol is printed without a prefix, as if it were in the current
package.

Because the ÿ#:þ syntax does not intern the following symbol, it is
necessary to use circular-list syntax if ÿ*print-circle*þ is true and
the same uninterned symbol appears several times in an expression to be
printed.  For example, the result of

 (let ((x (make-symbol "FOO"))) (list x x))

would be printed as ÿ(#:foo #:foo)þ if ÿ*print-circle*þ were false, but
as ÿ(#1=#:foo #1#)þ if ÿ*print-circle*þ were true.

A summary of the preceding package prefix rules follows:

ÿfoo:barþ
     ÿfoo:barþ is printed when symbol ÿbarþ is external in its home
     package ÿfooþ and is not accessible in the current package.

ÿfoo::barþ
     ÿfoo::barþ is printed when ÿbarþ is internal in its home package
     ÿfooþ and is not accessible in the current package.

ÿ:barþ
     ÿ:barþ is printed when the home package of ÿbarþ is the ÿKEYWORDþ
     package.

ÿ#:barþ
     ÿ#:barþ is printed when ÿbarþ is apparently uninterned, even in
     the pathological case that ÿbarþ has no home package but is
     nevertheless somehow accessible in the current package.

22.1.3.3.2 Effect of Readtable Case on the Lisp Printer
.......................................................

When printer escaping is disabled, or the characters under
consideration are not already quoted specifically by single escape or
multiple escape syntax, the readtable case of the current readtable
affects the way the Lisp printer writes symbols in the following ways:

:upcase
     When the readtable case is :upcase, uppercase characters are
     printed in the case specified by ÿ*print-case*þ, and lowercase
     characters are printed in their own case.

:downcase
     When the readtable case is :downcase, uppercase characters are
     printed in their own case, and lowercase characters are printed in
     the case specified by ÿ*print-case*þ.

:preserve
     When the readtable case is :preserve, all alphabetic characters
     are printed in their own case.

:invert
     When the readtable case is :invert, the case of all alphabetic
     characters in single case symbol names is inverted.  Mixed-case
     symbol names are printed as is.

The rules for escaping alphabetic characters in symbol names are
affected by the ÿreadtable-caseþ if printer escaping is enabled.
Alphabetic characters are escaped as follows:

:upcase
     When the readtable case is :upcase, all lowercase characters must
     be escaped.

:downcase
     When the readtable case is :downcase, all uppercase characters
     must be escaped.

:preserve
     When the readtable case is :preserve, no alphabetic characters
     need be escaped.

:invert
     When the readtable case is :invert, no alphabetic characters need
     be escaped.

22.1.3.3.2.1 Examples of Effect of Readtable Case on the Lisp Printer
.....................................................................

 (defun test-readtable-case-printing ()
   (let ((*readtable* (copy-readtable nil))
         (*print-case* *print-case*))
     (format t "READTABLE-CASE *PRINT-CASE*  Symbol-name  Output~
              ~%--------------------------------------------------~
              ~%")
     (dolist (readtable-case '(:upcase :downcase :preserve :invert))
       (setf (readtable-case *readtable*) readtable-case)
       (dolist (print-case '(:upcase :downcase :capitalize))
         (dolist (symbol '(|ZEBRA| |Zebra| |zebra|))
           (setq *print-case* print-case)
           (format t "~&:~A~15T:~A~29T~A~42T~A"
                   (string-upcase readtable-case)
                   (string-upcase print-case)
                   (symbol-name symbol)
                   (prin1-to-string symbol)))))))

The output from ÿ(test-readtable-case-printing)þ should be as follows:

    READTABLE-CASE *PRINT-CASE*  Symbol-name  Output
    --------------------------------------------------
    :UPCASE        :UPCASE       ZEBRA        ZEBRA
    :UPCASE        :UPCASE       Zebra        |Zebra|
    :UPCASE        :UPCASE       zebra        |zebra|
    :UPCASE        :DOWNCASE     ZEBRA        zebra
    :UPCASE        :DOWNCASE     Zebra        |Zebra|
    :UPCASE        :DOWNCASE     zebra        |zebra|
    :UPCASE        :CAPITALIZE   ZEBRA        Zebra
    :UPCASE        :CAPITALIZE   Zebra        |Zebra|
    :UPCASE        :CAPITALIZE   zebra        |zebra|
    :DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|
    :DOWNCASE      :UPCASE       Zebra        |Zebra|
    :DOWNCASE      :UPCASE       zebra        ZEBRA
    :DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|
    :DOWNCASE      :DOWNCASE     Zebra        |Zebra|
    :DOWNCASE      :DOWNCASE     zebra        zebra
    :DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|
    :DOWNCASE      :CAPITALIZE   Zebra        |Zebra|
    :DOWNCASE      :CAPITALIZE   zebra        Zebra
    :PRESERVE      :UPCASE       ZEBRA        ZEBRA
    :PRESERVE      :UPCASE       Zebra        Zebra
    :PRESERVE      :UPCASE       zebra        zebra
    :PRESERVE      :DOWNCASE     ZEBRA        ZEBRA
    :PRESERVE      :DOWNCASE     Zebra        Zebra
    :PRESERVE      :DOWNCASE     zebra        zebra
    :PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA
    :PRESERVE      :CAPITALIZE   Zebra        Zebra
    :PRESERVE      :CAPITALIZE   zebra        zebra
    :INVERT        :UPCASE       ZEBRA        zebra
    :INVERT        :UPCASE       Zebra        Zebra
    :INVERT        :UPCASE       zebra        ZEBRA
    :INVERT        :DOWNCASE     ZEBRA        zebra
    :INVERT        :DOWNCASE     Zebra        Zebra
    :INVERT        :DOWNCASE     zebra        ZEBRA
    :INVERT        :CAPITALIZE   ZEBRA        zebra
    :INVERT        :CAPITALIZE   Zebra        Zebra
    :INVERT        :CAPITALIZE   zebra        ZEBRA

22.1.3.4 Printing Strings
.........................

The characters of the string are output in order.  If printer escaping
is enabled, a double-quote is output before and after, and all
double-quotes and single escapes are preceded by backslash.  The
printing of strings is not affected by ÿ*print-array*þ.  Only the
active elements of the string are printed.

For information on how the Lisp reader parses strings, see *Note
Section 2.4.5 (Double-Quote): Double-Quote.

22.1.3.5 Printing Lists and Conses
..................................

Wherever possible, list notation is preferred over dot notation.
Therefore the following algorithm is used to print a cons x:

  1. A left-parenthesis is printed.

  2. The car of x is printed.

  3. If the cdr of x is itself a cons, it is made to be the current cons
     (i.e., x becomes that cons), a space is printed, and step 2 is
     re-entered.

  4. If the cdr of x is not null, a space, a dot, a space, and the cdr
     of x are printed.

  5. A right-parenthesis is printed.

Actually, the above algorithm is only used when ÿ*print-pretty*þ is
false.  When ÿ*print-pretty*þ is true (or when ÿpprintþ is used),
additional whitespaceá may replace the use of a single space, and a
more elaborate algorithm with similar goals but more presentational
flexibility is used; see *Note Section 22.1.2 (Printer Dispatching):
Printer Dispatching.

Although the two expressions below are equivalent, and the reader
accepts either one and produces the same cons, the printer always
prints such a cons in the second form.

 (a . (b . ((c . (d . nil)) . (e . nil))))
 (a b (c d) e)

The printing of conses is affected by ÿ*print-level*þ,
ÿ*print-length*þ, and ÿ*print-circle*þ.

Following are examples of printed representations of lists:

 (a . b)     ;A dotted pair of a and b
 (a.b)       ;A list of one element, the symbol named a.b
 (a. b)      ;A list of two elements a. and b
 (a .b)      ;A list of two elements a and .b
 (a b . c)   ;A dotted list of a and b with c at the end; two conses
 .iot        ;The symbol whose name is .iot
 (. b)       ;Invalid -- an error is signaled if an attempt is made to read
             ;this syntax.
 (a .)       ;Invalid -- an error is signaled.
 (a .. b)    ;Invalid -- an error is signaled.
 (a . . b)   ;Invalid -- an error is signaled.
 (a b c ...) ;Invalid -- an error is signaled.
 (a \. b)    ;A list of three elements a, ., and b
 (a |.| b)   ;A list of three elements a, ., and b
 (a \... b)  ;A list of three elements a, ..., and b
 (a |...| b) ;A list of three elements a, ..., and b

For information on how the Lisp reader parses lists and conses, see
*Note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis.

22.1.3.6 Printing Bit Vectors
.............................

A bit vector is printed as ÿ#*þ followed by the bits of the bit vector
in order.  If ÿ*print-array*þ is false, then the bit vector is printed
in a format (using ÿ#<þ) that is concise but not readable.  Only the
active elements of the bit vector are printed.

For information on Lisp reader parsing of bit vectors, see *Note
Section 2.4.8.4 (Sharpsign Asterisk): SharpsignStar.

22.1.3.7 Printing Other Vectors
...............................

If ÿ*print-array*þ is true and ÿ*print-readably*þ is false, any vector
other than a string or bit vector is printed using general-vector
syntax; this means that information about specialized vector
representations does not appear.  The printed representation of a
zero-length vector is ÿ#()þ.  The printed representation of a
non-zero-length vector begins with ÿ#(þ.  Following that, the first
element of the vector is printed.  If there are any other elements,
they are printed in turn, with each such additional element preceded by
a space if ÿ*print-pretty*þ is false, or whitespaceá if
ÿ*print-pretty*þ is true.  A right-parenthesis after the last element
terminates the printed representation of the vector.  The printing of
vectors is affected by ÿ*print-level*þ and ÿ*print-length*þ.  If the
vector has a fill pointer, then only those elements below the fill
pointer are printed.

If both ÿ*print-array*þ and ÿ*print-readably*þ are false, the vector is
not printed as described above, but in a format (using ÿ#<þ) that is
concise but not readable.

If ÿ*print-readably*þ is true, the vector prints in an
implementation-defined manner; see the variable *Note
*print-readably*::.

For information on how the Lisp reader parses these "other vectors,"
see *Note Section 2.4.8.3 (Sharpsign Left-Parenthesis):
SharpsignLeftParen.

22.1.3.8 Printing Other Arrays
..............................

If  ÿ*print-array*þ is true and ÿ*print-readably*þ is false, any array
other than a vector is printed using ÿ#þÿnþÿAþ format.  Let ÿnþ be the
rank of the array.  Then ÿ#þ is printed, then ÿnþ as a decimal integer,
then ÿAþ, then ÿnþ open parentheses.  Next the elements are scanned in
row-major order, using ÿwriteþ on each element, and separating elements
from each other with whitespaceá.  The array's dimensions are numbered
0 to ÿnþ-1 from left to right, and are enumerated with the rightmost
index changing fastest.  Every time the index for dimension ÿjþ is
incremented, the following actions are taken:

   * If ÿjþ < ÿnþ-1, then a close parenthesis is printed.

   * If incrementing the index for dimension ÿjþ caused it to equal
     dimension ÿjþ, that index is reset to zero and the index for
     dimension ÿjþ-1 is incremented (thereby performing these three
     steps recursively), unless ÿjþ=0, in which case the entire
     algorithm is terminated.  If incrementing the index for dimension
     ÿjþ did not cause it to equal dimension ÿjþ, then a space is
     printed.

   * If ÿjþ < ÿnþ-1, then an open parenthesis is printed.

This causes the contents to be printed in a format suitable for
:initial-contents to ÿmake-arrayþ.  The lists effectively printed by
this procedure are subject to truncation by ÿ*print-level*þ and
ÿ*print-length*þ.

If the array is of a specialized type, containing bits or characters,
then the innermost lists generated by the algorithm given above can
instead be printed using bit-vector or string syntax, provided that
these innermost lists would not be subject to truncation by
ÿ*print-length*þ.

If both ÿ*print-array*þ and ÿ*print-readably*þ are false, then the
array is printed in a format (using ÿ#<þ) that is concise but not
readable.

If ÿ*print-readably*þ is true, the array prints in an
implementation-defined manner; see the variable *Note
*print-readably*::.  In particular, this may be important for arrays
having some dimension ÿ0þ.

For information on how the Lisp reader parses these "other arrays," see
*Note Section 2.4.8.12 (Sharpsign A): SharpsignA.

22.1.3.9 Examples of Printing Arrays
....................................

 (let ((a (make-array '(3 3)))
       (*print-pretty* t)
       (*print-array* t))
   (dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j))))
   (print a)
   (print (make-array 9 :displaced-to a)))
Ö #2A(("<0,0>" "<0,1>" "<0,2>")
Ö     ("<1,0>" "<1,1>" "<1,2>")
Ö     ("<2,0>" "<2,1>" "<2,2>"))
Ö #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>")
ý #<ARRAY 9 indirect 36363476>

22.1.3.10 Printing Random States
................................

A specific syntax for printing objects of type ÿrandom-stateþ is not
specified. However, every implementation must arrange to print a random
state object in such a way that, within the same implementation, ÿreadþ
can construct from the printed representation a copy of the random state
object as if the copy had been made by ÿmake-random-stateþ.

If the type random state is effectively implemented by using the
machinery for ÿdefstructþ, the usual structure syntax can then be used
for printing random state objects; one might look something like

 #S(RANDOM-STATE :DATA #(14 49 98436589 786345 8734658324 ... ))

where the components are implementation-dependent.

22.1.3.11 Printing Pathnames
............................

When printer escaping is enabled, the syntax ÿ#P"..."þ is how a
pathname is printed by ÿwriteþ and the other functions herein described.
The ÿ"..."þ is the namestring representation of the pathname.

When printer escaping is disabled, ÿwriteþ writes a pathname P by
writing ÿ(namestring P)þ instead.

For information on how the Lisp reader parses pathnames, see *Note
Section 2.4.8.14 (Sharpsign P): SharpsignP.

22.1.3.12 Printing Structures
.............................

By default, a structure of type S is printed using ÿ#Sþ syntax.  This
behavior can be customized by specifying a :print-function or
:print-object option to the ÿdefstructþ form that defines S, or by
writing a ÿprint-objectþ method that is specialized for objects of type
S.

Different structures might print out in different ways; the default
notation for structures is:

 #S(STRUCTURE-NAME {SLOT-KEY SLOT-VALUE}*)

where ÿ#Sþ indicates structure syntax, STRUCTURE-NAME is a structure
name, each SLOT-KEY is an initialization argument name for a slot in
the structure, and each corresponding SLOT-VALUE is a representation of
the object in that slot.

For information on how the Lisp reader parses structures, see *Note
Section 2.4.8.13 (Sharpsign S): SharpsignS.

22.1.3.13 Printing Other Objects
................................

Other objects are printed in an implementation-dependent manner.  It is
not required that an implementation print those objects readably.

For example, hash tables, readtables, packages, streams, and functions
might not print readably.

A common notation to use in this circumstance is ÿ#<...>þ.  Since ÿ#<þ
is not readable by the Lisp reader, the precise format of the text
which follows is not important, but a common format to use is that
provided by the ÿprint-unreadable-objectþ macro.

For information on how the Lisp reader treats this notation, see *Note
Section 2.4.8.20 (Sharpsign Less-Than-Sign): SharpsignLeftAngle.  For
information on how to notate objects that cannot be printed readably,
see *Note Section 2.4.8.6 (Sharpsign Dot): SharpsignDot.


File: chris-ansicl.info,  Node: Examples of Printer Behavior,  Prev: Default Print-Object Methods,  Up: The Lisp Printer

22.1.4 Examples of Printer Behavior
-----------------------------------

 (let ((*print-escape* t)) (fresh-line) (write #\a))
Ö #\a
ý #\a
 (let ((*print-escape* nil) (*print-readably* nil))
   (fresh-line)
   (write #\a))
Ö a
ý #\a
 (progn (fresh-line) (prin1 #\a))
Ö #\a
ý #\a
 (progn (fresh-line) (print #\a))
Ö
Ö #\a
ý #\a
 (progn (fresh-line) (princ #\a))
Ö a
ý #\a


 (dolist (val '(t nil))
   (let ((*print-escape* val) (*print-readably* val))
     (print '#\a)
     (prin1 #\a) (write-char #\Space)
     (princ #\a) (write-char #\Space)
     (write #\a)))
Ö #\a #\a a #\a
Ö #\a #\a a a
ý NIL


 (progn (fresh-line) (write '(let ((a 1) (b 2)) (+ a b))))
Ö (LET ((A 1) (B 2)) (+ A B))
ý (LET ((A 1) (B 2)) (+ A B))


 (progn (fresh-line) (pprint '(let ((a 1) (b 2)) (+ a b))))
Ö (LET ((A 1)
Ö       (B 2))
Ö   (+ A B))
ý (LET ((A 1) (B 2)) (+ A B))


 (progn (fresh-line)
        (write '(let ((a 1) (b 2)) (+ a b)) :pretty t))
Ö (LET ((A 1)
Ö       (B 2))
Ö   (+ A B))
ý (LET ((A 1) (B 2)) (+ A B))


 (with-output-to-string (s)
    (write 'write :stream s)
    (prin1 'prin1 s))
ý "WRITEPRIN1"


File: chris-ansicl.info,  Node: The Lisp Pretty Printer,  Next: Formatted Output,  Prev: The Lisp Printer,  Up: Printer

22.2 The Lisp Pretty Printer
============================

* Menu:

* Pretty Printer Concepts::
* Examples of using the Pretty Printer::
* Notes about the Pretty Printer's Background::


File: chris-ansicl.info,  Node: Pretty Printer Concepts,  Next: Examples of using the Pretty Printer,  Up: The Lisp Pretty Printer

22.2.1 Pretty Printer Concepts
------------------------------

The facilities provided by the "pretty printer" permit programs to
redefine the way in which code is displayed, and allow the full power
of pretty printing to be applied to complex combinations of data
structures.

Whether any given style of output is in fact "pretty" is inherently a
somewhat subjective issue.  However, since the effect of the pretty
printer can be customized by conforming programs, the necessary
flexibility is provided for individual programs to achieve an arbitrary
degree of aesthetic control.

By providing direct access to the mechanisms within the pretty printer
that make dynamic decisions about layout, the macros and functions
ÿpprint-logical-blockþ, ÿpprint-newlineþ, and ÿpprint-indentþ make it
possible to specify pretty printing layout rules as a part of any
function that produces output.  They also make it very easy for the
detection of circularity and sharing, and abbreviation based on length
and nesting depth to be supported by the function.

The pretty printer is driven entirely by dispatch based on the value of
ÿ*print-pprint-dispatch*þ.  The function ÿset-pprint-dispatchþ makes it
possible for conforming programs to associate new pretty printing
functions with a type.

22.2.1.1 Dynamic Control of the Arrangement of Output
.....................................................

The actions of the pretty printer when a piece of output is too large
to fit in the space available can be precisely controlled.  Three
concepts underlie the way these operations work--"logical blocks", "conditional
newlines", and "sections".  Before proceeding further, it is important
to define these terms.

The first line of the next figure shows a schematic piece of output.
Each of the characters in the output is represented by "ÿ-þ".  The
positions of conditional newlines are indicated by digits.  The
beginnings and ends of logical blocks are indicated by "ÿ<þ" and "ÿ>þ"
respectively.

The output as a whole is a logical block and the outermost section.
This section is indicated by the ÿ0þ's on the second line of Figure 1.
Logical blocks nested within the output are specified by the macro
ÿpprint-logical-blockþ.  Conditional newline positions are specified by
calls to ÿpprint-newlineþ.  Each conditional newline defines two
sections (one before it and one after it) and is associated with a
third (the section immediately containing it).

The section after a conditional newline consists of: all the output up
to, but not including, (a) the next conditional newline immediately
contained in the same logical block; or if (a) is not applicable, (b)
the next newline that is at a lesser level of nesting in logical
blocks; or if (b) is not applicable, (c) the end of the output.

The section before a conditional newline consists of: all the output
back to, but not including, (a) the previous conditional newline that is
immediately contained in the same logical block; or if (a) is not
applicable, (b) the beginning of the immediately containing logical
block.  The last four lines in Figure 1 indicate the sections before
and after the four conditional newlines.

The section immediately containing a conditional newline is the shortest
section that contains the conditional newline in question.  In the next
figure, the first conditional newline is immediately contained in the
section marked with ÿ0þ's, the second and third conditional newlines
are immediately contained in the section before the fourth conditional
newline, and the fourth conditional newline is immediately contained in
the section after the first conditional newline.

 <-1---<--<--2---3->--4-->->
 000000000000000000000000000
 11 111111111111111111111111
           22 222
              333 3333
        44444444444444 44444

Figure 22.3: Example of Logical Blocks, Conditional Newlines, and Sections

Whenever possible, the pretty printer displays the entire contents of a
section on a single line.  However, if the section is too long to fit in
the space available, line breaks are inserted at conditional newline
positions within the section.

22.2.1.2 Format Directive Interface
...................................

The primary interface to operations for dynamically determining the
arrangement of output is provided through the functions and macros of
the pretty printer.  The next figure shows the defined names related to
pretty printing.

*print-lines*             pprint-dispatch                 pprint-pop
*print-miser-width*       pprint-exit-if-list-exhausted   pprint-tab
*print-pprint-dispatch*   pprint-fill                     pprint-tabular
*print-right-margin*      pprint-indent                   set-pprint-dispatch
copy-pprint-dispatch      pprint-linear                   write
format                    pprint-logical-block            
formatter                 pprint-newline                  

Figure 22.4: Defined names related to pretty printing.

The next figure identifies a set of format directives which serve as an
alternate interface to the same pretty printing operations in a more
textually compact form.

`~I'    `~W'       `~<... :>'
`~:T'   `~/.../'   `~_'

Figure 22.5: Format directives related to Pretty Printing

22.2.1.3 Compiling Format Strings
.................................

A format string is essentially a program in a special-purpose language
that performs printing, and that is interpreted by the function
ÿformatþ.  The ÿformatterþ macro provides the efficiency of using a
compiled function to do that same printing but without losing the
textual compactness of format strings.

A "format control" is either a format string or a function that was
returned by the the ÿformatterþ macro.

22.2.1.4 Pretty Print Dispatch Tables
.....................................

A "pprint dispatch table" is a mapping from keys to pairs of values.
Each key is a type specifier.  The values associated with a key are a
"function" (specifically, a function designator or ÿnilþ) and a
"numerical priority" (specifically, a real).  Basic insertion and
retrieval is done based on the keys with the equality of keys being
tested by ÿequalþ.

When ÿ*print-pretty*þ is true, the "current pprint dispatch table" (in
ÿ*print-pprint-dispatch*þ) controls how objects are printed.  The
information in this table takes precedence over all other mechanisms
for specifying how to print objects.  In particular, it has priority
over user-defined ÿprint-objectþ methods because the current pprint
dispatch table is consulted first.

The function is chosen from the current pprint dispatch table by
finding the highest priority function that is associated with a type
specifier that matches the object; if there is more than one such
function, it is implementation-dependent which is used.

However, if there is no information in the table about how to pretty
print a particular kind of object, a function is invoked which uses
ÿprint-objectþ to print the object.  The value of ÿ*print-pretty*þ is
still true when this function is called, and individual methods for
ÿprint-objectþ might still elect to produce output in a special format
conditional on the value of ÿ*print-pretty*þ.

22.2.1.5 Pretty Printer Margins
...............................

A primary goal of pretty printing is to keep the output between a pair
of margins.  The column where the output begins is taken as the left
margin.  If the current column cannot be determined at the time output
begins, the left margin is assumed to be zero.  The right margin is
controlled by ÿ*print-right-margin*þ.


File: chris-ansicl.info,  Node: Examples of using the Pretty Printer,  Next: Notes about the Pretty Printer's Background,  Prev: Pretty Printer Concepts,  Up: The Lisp Pretty Printer

22.2.2 Examples of using the Pretty Printer
-------------------------------------------

As an example of the interaction of logical blocks, conditional
newlines, and indentation, consider the function ÿsimple-pprint-defunþ
below.  This function prints out lists whose cars are ÿdefunþ in the
standard way assuming that the list has exactly length ÿ4þ.

(defun simple-pprint-defun (*standard-output* list)
  (pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")
    (write (first list))
    (write-char #\Space)
    (pprint-newline :miser)
    (pprint-indent :current 0)
    (write (second list))
    (write-char #\Space)
    (pprint-newline :fill)
    (write (third list))
    (pprint-indent :block 1)
    (write-char #\Space)
    (pprint-newline :linear)
    (write (fourth list))))

Suppose that one evaluates the following:

(simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))

If the line width available is greater than or equal to ÿ26þ, then all
of the output appears on one line.  If the line width available is
reduced to ÿ25þ, a line break is inserted at the linear-style
conditional newline before the expression ÿ(* x y)þ, producing the
output shown.  The ÿ(pprint-indent :block 1)þ causes ÿ(* x y)þ to be
printed at a relative indentation of ÿ1þ in the logical block.

 (DEFUN PROD (X Y)
   (* X Y))

If the line width available is ÿ15þ, a line break is also inserted at
the fill style conditional newline before the argument list.  The call
on ÿ(pprint-indent :current 0)þ causes the argument list to line up
under the function name.

(DEFUN PROD
       (X Y)
  (* X Y))

If ÿ*print-miser-width*þ were greater than or equal to 14, the example
output above would have been as follows, because all indentation changes
are ignored in miser mode and line breaks are inserted at miser-style
conditional newlines.  

 (DEFUN
  PROD
  (X Y)
  (* X Y))

As an example of a per-line prefix, consider that evaluating the
following produces the output shown with a line width of ÿ20þ and
ÿ*print-miser-width*þ of ÿnilþ.

 (pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")
   (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))

 ;;; (DEFUN PROD
 ;;;        (X Y)
 ;;;   (* X Y))

As a more complex (and realistic) example, consider the function
ÿpprint-letþ below.  This specifies how to print a ÿletþ form in the
traditional style.  It is more complex than the example above, because
it has to deal with nested structure.  Also, unlike the example above
it contains complete code to readably print any possible list that
begins with the symbol ÿletþ.  The outermost ÿpprint-logical-blockþ
form handles the printing of the input list as a whole and specifies
that parentheses should be printed in the output.  The second
ÿpprint-logical-blockþ form handles the list of binding pairs.  Each
pair in the list is itself printed by the innermost
ÿpprint-logical-blockþ.  (A ÿloopþ form is used instead of merely
decomposing the pair into two objects so that readable output will be
produced no matter whether the list corresponding to the pair has one
element, two elements, or (being malformed) has more than two elements.)
A space and a fill-style conditional newline are placed after each pair
except the last.  The loop at the end of the topmost
ÿpprint-logical-blockþ form prints out the forms in the body of the
ÿletþ form separated by spaces and linear-style conditional newlines.

 (defun pprint-let (*standard-output* list)
   (pprint-logical-block (nil list :prefix "(" :suffix ")")
     (write (pprint-pop))
     (pprint-exit-if-list-exhausted)
     (write-char #\Space)
     (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
       (pprint-exit-if-list-exhausted)
       (loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
               (pprint-exit-if-list-exhausted)
               (loop (write (pprint-pop))
                     (pprint-exit-if-list-exhausted)
                     (write-char #\Space)
                     (pprint-newline :linear)))
             (pprint-exit-if-list-exhausted)
             (write-char #\Space)
             (pprint-newline :fill)))
     (pprint-indent :block 1)
     (loop (pprint-exit-if-list-exhausted)
           (write-char #\Space)
           (pprint-newline :linear)
           (write (pprint-pop)))))

Suppose that one evaluates the following with ÿ*print-level*þ being 4,
and ÿ*print-circle*þ being true.

 (pprint-let *standard-output*
             '#1=(let (x (*print-length* (f (g 3)))
                       (z . 2) (k (car y)))
                   (setq x (sqrt z)) #1#))

If the line length is greater than or equal to ÿ77þ, the output produced
appears on one line.  However, if the line length is ÿ76þ, line breaks
are inserted at the linear-style conditional newlines separating the
forms in the body and the output below is produced.  Note that, the
degenerate binding pair ÿxþ is printed readably even though it fails to
be a list; a depth abbreviation marker is printed in place of ÿ(g 3)þ;
the binding pair ÿ(z . 2)þ is printed readably even though it is not a
proper list; and appropriate circularity markers are printed.

 #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))
      (SETQ X (SQRT Z))
      #1#)

If the line length is reduced to ÿ35þ, a line break is inserted at one
of the fill-style conditional newlines separating the binding pairs.

 #1=(LET (X (*PRINT-PRETTY* (F #))
          (Z . 2) (K (CAR Y)))
      (SETQ X (SQRT Z))
      #1#)

Suppose that the line length is further reduced to ÿ22þ and
ÿ*print-length*þ is set to ÿ3þ. In this situation, line breaks are
inserted after both the first and second binding pairs.  In addition,
the second binding pair is itself broken across two lines.  Clause (b)
of the description of fill-style conditional newlines (see the function
*Note pprint-newline::) prevents the binding pair ÿ(z . 2)þ from being
printed at the end of the third line.  Note that the length
abbreviation hides the circularity from view and therefore the printing
of circularity markers disappears.

 (LET (X
       (*PRINT-LENGTH*
        (F #))
       (Z . 2) ...)
   (SETQ X (SQRT Z))
   ...)

The next function prints a vector using "ÿ#(...)þ" notation.

(defun pprint-vector (*standard-output* v)
  (pprint-logical-block (nil nil :prefix "#(" :suffix ")")
    (let ((end (length v)) (i 0))
      (when (plusp end)
        (loop (pprint-pop)
              (write (aref v i))
              (if (= (incf i) end) (return nil))
              (write-char #\Space)
              (pprint-newline :fill))))))

Evaluating the following with a line length of 15 produces the output
shown.

 (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))

 #(12 34 567 8
   9012 34 567
   89 0 1 23)

As examples of the convenience of specifying pretty printing with
format strings, consider that the functions ÿsimple-pprint-defunþ and
ÿpprint-letþ used as examples above can be compactly defined as follows.
(The function ÿpprint-vectorþ cannot be defined using ÿformatþ because
the data structure it traverses is not a list.)

(defun simple-pprint-defun (*standard-output* list)
  (format T "~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>" list))

(defun pprint-let (*standard-output* list)
  (format T "~:<~W~^~:<~@{~:<~@{~W~^~_~}~:>~^~:_~}~:>~1I~@{~^~_~W~}~:>" list))

In the following example, the first form restores
ÿ*print-pprint-dispatch*þ to the equivalent of its initial value.  The
next two forms then set up a special way to pretty print ratios.  Note
that the more specific type specifier has to be associated with a
higher priority.

 (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))

 (set-pprint-dispatch 'ratio
   #'(lambda (s obj)
       (format s "#.(/ ~W ~W)"
                 (numerator obj) (denominator obj))))

 (set-pprint-dispatch '(and ratio (satisfies minusp))
   #'(lambda (s obj)
       (format s "#.(- (/ ~W ~W))"
               (- (numerator obj)) (denominator obj)))
   5)

 (pprint '(1/3 -2/3))
 (#.(/ 1 3) #.(- (/ 2 3)))

The following two forms illustrate the definition of pretty printing
functions for types of code.  The first form illustrates how to specify
the traditional method for printing quoted objects using single-quote.
Note the care taken to ensure that data lists that happen to begin with
quote will be printed readably.  The second form specifies that lists
beginning with the symbol ÿmy-letþ should print the same way that lists
beginning with ÿletþ print when the initial pprint dispatch table is in
effect.

 (set-pprint-dispatch '(cons (member quote)) ()
   #'(lambda (s list)
       (if (and (consp (cdr list)) (null (cddr list)))
          (funcall (formatter "'~W") s (cadr list))
          (pprint-fill s list))))

 (set-pprint-dispatch '(cons (member my-let))
                      (pprint-dispatch '(let) nil))

The next example specifies a default method for printing lists that do
not correspond to function calls.  Note that the functions
ÿpprint-linearþ, ÿpprint-fillþ, and ÿpprint-tabularþ are all defined
with optional COLON-P and AT-SIGN-P arguments so that they can be used
as ÿpprint dispatch functionsþ as well as `~/.../' functions.

 (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))
                      #'pprint-fill -5)

 ;; Assume a line length of 9
 (pprint '(0 b c d e f g h i j k))
 (0 b c d
  e f g h
  i j k)

This final example shows how to define a pretty printing function for a
user defined data structure.

 (defstruct family mom kids)

 (set-pprint-dispatch 'family
   #'(lambda (s f)
       (funcall (formatter "~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>")
               s (family-mom f) (family-kids f))))

The pretty printing function for the structure ÿfamilyþ specifies how to
adjust the layout of the output so that it can fit aesthetically into a
variety of line widths.  In addition, it obeys the printer control
variables ÿ*print-level*þ, ÿ*print-length*þ, ÿ*print-lines*þ,
ÿ*print-circle*þ and ÿ*print-escape*þ, and can tolerate several
different kinds of malformity in the data structure.  The output below
shows what is printed out with a right margin of ÿ25þ, ÿ*print-pretty*þ
being true, ÿ*print-escape*þ being false, and a malformed ÿkidsþ list.

 (write (list 'principal-family
              (make-family :mom "Lucy"
                           :kids '("Mark" "Bob" . "Dan")))
        :right-margin 25 :pretty T :escape nil :miser-width nil)
 (PRINCIPAL-FAMILY
  #<Lucy and
      Mark Bob . Dan>)

Note that a pretty printing function for a structure is different from
the structure's ÿprint-objectþ method.  While ÿprint-objectþ methods
are permanently associated with a structure, pretty printing functions
are stored in pprint dispatch tables and can be rapidly changed to
reflect different printing needs.  If there is no pretty printing
function for a structure in the current pprint dispatch table, its
ÿprint-objectþ method is used instead.


File: chris-ansicl.info,  Node: Notes about the Pretty Printer's Background,  Prev: Examples of using the Pretty Printer,  Up: The Lisp Pretty Printer

22.2.3 Notes about the Pretty Printer's Background
--------------------------------------------------

For a background reference to the abstract concepts detailed in this
section, see `XP: A Common Lisp Pretty Printing System'.  The details
of that paper are not binding on this document, but may be helpful in
establishing a conceptual basis for understanding this material.


File: chris-ansicl.info,  Node: Formatted Output,  Next: copy-pprint-dispatch,  Prev: The Lisp Pretty Printer,  Up: Printer

22.3 Formatted Output
=====================

ÿformatþ is useful for producing nicely formatted text, producing
good-looking messages, and so on.  ÿformatþ can generate and return a
string or output to DESTINATION.

The CONTROL-STRING argument to ÿformatþ is actually a format control.
That is, it can be either a format string or a function, for example a
function returned by the ÿformatterþ macro.

If it is a function, the function is called with the appropriate output
stream as its first argument and the data arguments to ÿformatþ as its
remaining arguments.  The function should perform whatever output is
necessary and return the unused tail of the arguments (if any).

The compilation process performed by ÿformatterþ produces a function
that would do with its arguments as the ÿformatþ interpreter would do
with those arguments.

The remainder of this section describes what happens if the
CONTROL-STRING is a format string.

CONTROL-STRING is composed of simple text (characters) and embedded
directives.

ÿformatþ writes the simple text as is; each embedded directive
specifies further text output that is to appear at the corresponding
point within the simple text.  Most directives use one or more elements
of ARGS to create their output.

A directive consists of a tilde, optional prefix parameters separated
by commas, optional colon and at-sign modifiers, and a single character
indicating what kind of directive this is.  There is no required
ordering between the at-sign and colon modifier.  The case of the
directive character is ignored.  Prefix parameters are notated as
signed (sign is optional) decimal numbers, or as a single-quote
followed by a character.  For example, ÿ~5,'0dþ can be used to print an
integer in decimal radix in five columns with leading zeros, or
ÿ~5,'*dþ to get leading asterisks.

In place of a prefix parameter to a directive, ÿVþ (or ÿvþ) can be used.
In this case, ÿformatþ takes an argument from ARGS as a parameter to
the directive.  The argument should be an integer or character.  If the
ARG used by a ÿVþ parameter is ÿnilþ, the effect is as if the parameter
had been omitted.  ÿ#þ can be used in place of a prefix parameter; it
represents the number of ARGS remaining to be processed.  When used
within a recursive format, in the context of ÿ~?þ or ÿ~{þ, the ÿ#þ
prefix parameter represents the number of format arguments remaining
within the recursive call.

Examples of format strings:

ÿ"~S"þ         ;This is an S directive with no parameters or modifiers.
ÿ"~3,-4:@s"þ   ;This is an S directive with two parameters, ÿ3þ and ÿ-4þ,
               ; and both the colon and at-sign flags.
ÿ"~,+4S"þ      ;Here the first prefix parameter is omitted and takes
               ; on its default value, while the second parameter is ÿ4þ.

Figure 22.6: Examples of format control strings

ÿformatþ sends the output to DESTINATION.  If DESTINATION is ÿnilþ,
ÿformatþ creates and returns a string containing the output from
CONTROL-STRING.  If DESTINATION is non-nil, it must be a string with a
fill pointer, a stream, or the symbol ÿtþ.  If DESTINATION is a string
with a fill pointer, the output is added to the end of the string.  If
DESTINATION is a stream, the output is sent to that stream.  If
DESTINATION is ÿtþ, the output is sent to standard output.

In the description of the directives that follows, the term arg in
general refers to the next item of the set of ARGS to be processed.
The word or phrase at the beginning of each description is a mnemonic
for the directive.  ÿformatþ directives do not bind any of the printer
control variables (ÿ*print-...*þ) except as specified in the following
descriptions.  Implementations may specify the binding of new,
implementation-specific printer control variables for each ÿformatþ
directive, but they may neither bind any standard printer control
variables not specified in description of a ÿformatþ directive nor fail
to bind any standard printer control variables as specified in the
description.

* Menu:

* FORMAT Basic Output::
* FORMAT Radix Control::
* FORMAT Floating-Point Printers::
* FORMAT Printer Operations::
* FORMAT Pretty Printer Operations::
* FORMAT Layout Control::
* FORMAT Control-Flow Operations::
* FORMAT Miscellaneous Operations::
* FORMAT Miscellaneous Pseudo-Operations::
* Additional Information about FORMAT Operations::
* Examples of FORMAT::
* Notes about FORMAT::


File: chris-ansicl.info,  Node: FORMAT Basic Output,  Next: FORMAT Radix Control,  Up: Formatted Output

22.3.1 FORMAT Basic Output
--------------------------

22.3.1.1 Tilde C: Character
...........................

The next arg should be a character; it is printed according to the
modifier flags.

ÿ~Cþ prints the character as if by using ÿwrite-charþ if it is a simple
character.  Characters that are not simple are not necessarily printed
as if by ÿwrite-charþ, but are displayed in an implementation-defined,
abbreviated format.  For example,

 (format nil "~C" #\A) ý "A"
 (format nil "~C" #\Space) ý " "

ÿ~:Cþ is the same as ÿ~Cþ for printing characters, but other characters
are "spelled out."  The intent is that this is a "pretty" format for
printing characters.  For simple characters that are not printing, what
is spelled out is the name of the character (see ÿchar-nameþ).  For
characters that are not simple and not printing, what is spelled out is
implementation-defined.  For example,

 (format nil "~:C" #\A) ý "A"
 (format nil "~:C" #\Space) ý "Space"
;; This next example assumes an implementation-defined "Control" attribute.
 (format nil "~:C" #\Control-Space)
ý "Control-Space"
orý "c-Space"

ÿ~:@Cþ prints what ÿ~:Cþ would, and then if the character requires
unusual shift keys on the keyboard to type it, this fact is mentioned.
For example,

 (format nil "~:@C" #\Control-Partial) ý "Control-ï (Top-F)"

This is the format used for telling the user about a key he is expected
to type, in prompts, for instance.  The precise output may depend not
only on the implementation, but on the particular I/O devices in use.

ÿ~@Cþ prints the character in a way that the Lisp reader can understand,
using ÿ#\þ syntax.

ÿ~@Cþ  binds ÿ*print-escape*þ to ÿtþ.

22.3.1.2 Tilde Percent: Newline
...............................

This outputs a ÿ#\Newlineþ character, thereby terminating the current
output line and beginning a new one.  ÿ~n%þ outputs n newlines.  No arg
is used.

22.3.1.3 Tilde Ampersand: Fresh-Line
....................................

Unless it can be determined that the output stream is already at the
beginning of a line, this outputs a newline.  ÿ~n&þ calls ÿfresh-lineþ
and then outputs n- 1 newlines.  ÿ~0&þ does nothing.

22.3.1.4 Tilde Vertical-Bar: Page
.................................

This outputs a page separator character, if possible.  ÿ~n|þ does this
n times.

22.3.1.5 Tilde Tilde: Tilde
...........................

This outputs a tilde.  ÿ~n~þ outputs n tildes.


File: chris-ansicl.info,  Node: FORMAT Radix Control,  Next: FORMAT Floating-Point Printers,  Prev: FORMAT Basic Output,  Up: Formatted Output

22.3.2 FORMAT Radix Control
---------------------------

22.3.2.1 Tilde R: Radix
.......................

ÿ~nRþ prints arg in radix n.  The modifier flags and any remaining
parameters are used as for the ÿ~Dþ directive.  ÿ~Dþ is the same as
ÿ~10Rþ.  The full form is
ÿ~radix,mincol,padchar,commachar,comma-intervalRþ.

If no prefix parameters are given to ÿ~Rþ, then a different
interpretation is given.  The argument should be an integer.  For
example, if arg is 4:

   * ÿ~Rþ prints arg as a cardinal English number: ÿfourþ.

   * ÿ~:Rþ prints arg as an ordinal English number: ÿfourthþ.

   * ÿ~@Rþ prints arg as a Roman numeral: ÿIVþ.

   * ÿ~:@Rþ prints arg as an old Roman numeral: ÿIIIIþ.

For example:

 (format nil "~,,' ,4:B" 13) ý "1101"
 (format nil "~,,' ,4:B" 17) ý "1 0001"
 (format nil "~19,0,' ,4:B" 3333) ý "0000 1101 0000 0101"
 (format nil "~3,,,' ,2:R" 17) ý "1 22"
 (format nil "~,,'|,2:D" #xFFFF) ý  "6|55|35"

If and only if the first parameter, n, is supplied, ÿ~Rþ binds
ÿ*print-escape*þ to false, ÿ*print-radix*þ to false, ÿ*print-base*þ to
n, and ÿ*print-readably*þ to false.

If and only if no parameters are supplied, ÿ~Rþ binds ÿ*print-base*þ to
ÿ10þ.

22.3.2.2 Tilde D: Decimal
.........................

An arg, which should be an integer, is printed in decimal radix.  ÿ~Dþ
will never put a decimal point after the number.

ÿ~mincolDþ uses a column width of mincol; spaces are inserted on the
left if the number requires fewer than mincol columns for its digits
and sign.  If the number doesn't fit in mincol columns, additional
columns are used as needed.

ÿ~mincol,padcharDþ uses padchar as the pad character instead of space.

If arg is not an integer, it is printed in ÿ~Aþ format and decimal base.

The ÿ@þ modifier causes the number's sign to be printed always; the
default is to print it only if the number is negative.  The ÿ:þ
modifier causes commas to be printed between groups of digits;
commachar may be used to change the character used as the comma.
comma-interval must be an integer and defaults to 3.  When the ÿ:þ
modifier is given to any of these directives, the commachar is printed
between groups of comma-interval digits.

Thus the most general form of ÿ~Dþ is
ÿ~mincol,padchar,commachar,comma-intervalDþ.

ÿ~Dþ binds ÿ*print-escape*þ to false, ÿ*print-radix*þ to false,
ÿ*print-base*þ to ÿ10þ, and ÿ*print-readably*þ to false.

22.3.2.3 Tilde B: Binary
........................

This is just like ÿ~Dþ but prints in binary radix (radix 2) instead of
decimal.  The full form is therefore
ÿ~mincol,padchar,commachar,comma-intervalBþ.

ÿ~Bþ binds ÿ*print-escape*þ to false, ÿ*print-radix*þ to false,
ÿ*print-base*þ to ÿ2þ, and ÿ*print-readably*þ to false.

22.3.2.4 Tilde O: Octal
.......................

This is just like ÿ~Dþ but prints in octal radix (radix 8) instead of
decimal.  The full form is therefore
ÿ~mincol,padchar,commachar,comma-intervalOþ.

ÿ~Oþ binds ÿ*print-escape*þ to false, ÿ*print-radix*þ to false,
ÿ*print-base*þ to ÿ8þ, and ÿ*print-readably*þ to false.

22.3.2.5 Tilde X: Hexadecimal
.............................

This is just like ÿ~Dþ but prints in hexadecimal radix (radix 16)
instead of decimal.  The full form is therefore
ÿ~mincol,padchar,commachar,comma-intervalXþ.

ÿ~Xþ binds ÿ*print-escape*þ to false, ÿ*print-radix*þ to false,
ÿ*print-base*þ to ÿ16þ, and ÿ*print-readably*þ to false.


File: chris-ansicl.info,  Node: FORMAT Floating-Point Printers,  Next: FORMAT Printer Operations,  Prev: FORMAT Radix Control,  Up: Formatted Output

22.3.3 FORMAT Floating-Point Printers
-------------------------------------

22.3.3.1 Tilde F: Fixed-Format Floating-Point
.............................................

The next arg is printed as a float.

The full form is ÿ~w,d,k,overflowchar,padcharFþ.  The parameter w is
the width of the field to be printed; d is the number of digits to
print after the decimal point; k is a scale factor that defaults to
zero.

Exactly w characters will be output.  First, leading copies of the
character padchar (which defaults to a space) are printed, if
necessary, to pad the field on the left.  If the arg is negative, then
a minus sign is printed; if the arg is not negative, then a plus sign
is printed if and only if the ÿ@þ modifier was supplied.  Then a
sequence of digits, containing a single embedded decimal point, is
printed; this represents the magnitude of the value of arg times 10^k,
rounded to d fractional digits.  When rounding up and rounding down
would produce printed values equidistant from the scaled value of arg,
then the implementation is free to use either one.  For example,
printing the argument ÿ6.375þ using the format ÿ~4,2Fþ may correctly
produce either ÿ6.37þ or ÿ6.38þ.  Leading zeros are not permitted,
except that a single zero digit is output before the decimal point if
the printed value is less than one, and this single zero digit is not
output at all if w=d+1.

If it is impossible to print the value in the required format in a field
of width w, then one of two actions is taken.  If the parameter
overflowchar is supplied, then w copies of that parameter are printed
instead of the scaled value of arg.  If the overflowchar parameter is
omitted, then the scaled value is printed using more than w characters,
as many more as may be needed.

If the w parameter is omitted, then the field is of variable width.  In
effect, a value is chosen for w in such a way that no leading pad
characters need to be printed and exactly d characters will follow the
decimal point.  For example, the directive ÿ~,2Fþ will print exactly
two digits after the decimal point and as many as necessary before the
decimal point.

If the parameter d is omitted, then there is no constraint on the
number of digits to appear after the decimal point.  A value is chosen
for d in such a way that as many digits as possible may be printed
subject to the width constraint imposed by the parameter w and the
constraint that no trailing zero digits may appear in the fraction,
except that if the fraction to be printed is zero, then a single zero
digit should appear after the decimal point if permitted by the width
constraint.

If both w and d are omitted, then the effect is to print the value
using ordinary free-format output; ÿprin1þ uses this format for any
number whose magnitude is either zero or between 10^-3 (inclusive) and
10^7 (exclusive).

If w is omitted, then if the magnitude of arg is so large (or, if d is
also omitted, so small) that more than 100 digits would have to be
printed, then an implementation is free, at its discretion, to print
the number using exponential notation instead, as if by the directive
ÿ~Eþ (with all parameters to ÿ~Eþ defaulted, not taking their values
from the ÿ~Fþ directive).

If arg is a rational number, then it is coerced to be a single float
and then printed.  Alternatively, an implementation is permitted to
process a rational number by any other method that has essentially the
same behavior but avoids loss of precision or overflow because of the
coercion.  If w and d are not supplied and the number has no exact
decimal representation, for example ÿ1/3þ, some precision cutoff must
be chosen by the implementation since only a finite number of digits
may be printed.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ÿ~wDþ, thereby printing it in
decimal radix and a minimum field width of w.

ÿ~Fþ binds ÿ*print-escape*þ to false and ÿ*print-readably*þ to false.

22.3.3.2 Tilde E: Exponential Floating-Point
............................................

The next arg is printed as a float in exponential notation.

The full form is ÿ~w,d,e,k,overflowchar,padchar,exponentcharEþ.  The
parameter w is the width of the field to be printed; d is the number of
digits to print after the decimal point; e is the number of digits to
use when printing the exponent; k is a scale factor that defaults to
one (not zero).

Exactly w characters will be output.  First, leading copies of the
character padchar (which defaults to a space) are printed, if
necessary, to pad the field on the left.  If the arg is negative, then
a minus sign is printed; if the arg is not negative, then a plus sign
is printed if and only if the ÿ@þ modifier was supplied.  Then a
sequence of digits containing a single embedded decimal point is
printed.  The form of this sequence of digits depends on the scale
factor k.  If k is zero, then d digits are printed after the decimal
point, and a single zero digit appears before the decimal point if the
total field width will permit it.  If k is positive, then it must be
strictly less than d+2;  k significant digits are printed before the
decimal point, and d- k+1 digits are printed after the decimal point.
If k is negative, then it must be strictly greater than - d; a single
zero digit appears before the decimal point if the total field width
will permit it, and after the decimal point are printed first - k zeros
and then d+k significant digits.  The printed fraction must be properly
rounded.  When rounding up and rounding down would produce printed
values equidistant from the scaled value of arg, then the implementation
is free to use either one.  For example, printing the argument ÿ637.5þ
using the format ÿ~8,2Eþ may correctly produce either ÿ6.37E+2þ or
ÿ6.38E+2þ.

Following the digit sequence, the exponent is printed.  First the
character parameter exponentchar is printed; if this parameter is
omitted, then the exponent marker that ÿprin1þ would use is printed, as
determined from the type of the float and the current value of
ÿ*read-default-float-format*þ.  Next, either a plus sign or a minus sign
is printed, followed by e digits representing the power of ten by which
the printed fraction must be multiplied to properly represent the
rounded value of arg.

If it is impossible to print the value in the required format in a field
of width w, possibly because k is too large or too small or because the
exponent cannot be printed in e character positions, then one of two
actions is taken.  If the parameter overflowchar is supplied, then w
copies of that parameter are printed instead of the scaled value of arg.
If the overflowchar parameter is omitted, then the scaled value is
printed using more than w characters, as many more as may be needed; if
the problem is that d is too small for the supplied k or that e is too
small, then a larger value is used for d or e as may be needed.

If the w parameter is omitted, then the field is of variable width.  In
effect a value is chosen for w in such a way that no leading pad
characters need to be printed.

If the parameter d is omitted, then there is no constraint on the
number of digits to appear.  A value is chosen for d in such a way that
as many digits as possible may be printed subject to the width
constraint imposed by the parameter w, the constraint of the scale
factor k, and the constraint that no trailing zero digits may appear in
the fraction, except that if the fraction to be printed is zero then a
single zero digit should appear after the decimal point.

If the parameter e is omitted, then the exponent is printed using the
smallest number of digits necessary to represent its value.

If all of w, d, and e are omitted, then the effect is to print the
value using ordinary free-format exponential-notation output; ÿprin1þ
uses a similar format for any non-zero number whose magnitude is less
than 10^-3 or greater than or equal to 10^7.  The only difference is
that the ÿ~Eþ directive always prints a plus or minus sign in front of
the exponent, while ÿprin1þ omits the plus sign if the exponent is
non-negative.

If arg is a rational number, then it is coerced to be a single float
and then printed.  Alternatively, an implementation is permitted to
process a rational number by any other method that has essentially the
same behavior but avoids loss of precision or overflow because of the
coercion.  If w and d are unsupplied and the number has no exact
decimal representation, for example ÿ1/3þ, some precision cutoff must
be chosen by the implementation since only a finite number of digits
may be printed.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ÿ~wDþ, thereby printing it in
decimal radix and a minimum field width of w.

ÿ~Eþ binds ÿ*print-escape*þ to false and ÿ*print-readably*þ to false.

22.3.3.3 Tilde G: General Floating-Point
........................................

The next arg is printed as a float in either fixed-format or
exponential notation as appropriate.

The full form is ÿ~w,d,e,k,overflowchar,padchar,exponentcharGþ.  The
format in which to print arg depends on the magnitude (absolute value)
of the arg.  Let n be an integer such that 10^n-1 ã |arg| < 10^n.  Let
ee equal e+2, or 4 if e is omitted.  Let ww equal w- ee, or ÿnilþ if w
is omitted.  If d is omitted, first let q be the number of digits
needed to print arg with no loss of information and without leading or
trailing zeros; then let d equal ÿ(max q (min n 7))þ.  Let dd equal d-
n.

If 0 ã dd ã d, then arg is printed as if by the format directives

ÿ~ww,dd,,overflowchar,padcharF~ee@Tþ

Note that the scale factor k is not passed to the ÿ~Fþ directive.  For
all other values of dd, arg is printed as if by the format directive

ÿ~w,d,e,k,overflowchar,padchar,exponentcharEþ

In either case, an ÿ@þ modifier is supplied to the ÿ~Fþ or ÿ~Eþ
directive if and only if one was supplied to the ÿ~Gþ directive.

ÿ~Gþ binds ÿ*print-escape*þ to false and ÿ*print-readably*þ to false.

22.3.3.4 Tilde Dollarsign: Monetary Floating-Point
..................................................

The next arg is printed as a float in fixed-format notation.

The full form is ÿ~d,n,w,padchar$þ.  The parameter d is the number of
digits to print after the decimal point (default value 2); n is the
minimum number of digits to print before the decimal point (default
value 1); w is the minimum total width of the field to be printed
(default value 0).

First padding and the sign are output.  If the arg is negative, then a
minus sign is printed; if the arg is not negative, then a plus sign is
printed if and only if the ÿ@þ modifier was supplied.  If the ÿ:þ
modifier is used, the sign appears before any padding, and otherwise
after the padding.  If w is supplied and the number of other characters
to be output is less than w, then copies of padchar (which defaults to
a space) are output to make the total field width equal w.  Then n
digits are printed for the integer part of arg, with leading zeros if
necessary; then a decimal point; then d digits of fraction, properly
rounded.

If the magnitude of arg is so large that more than m digits would have
to be printed, where m is the larger of w and 100, then an
implementation is free, at its discretion, to print the number using
exponential notation instead, as if by the directive
ÿ~w,q,,,,padcharEþ, where w and padchar are present or omitted
according to whether they were present or omitted in the ÿ~$þ
directive, and where q=d+n- 1, where d and n are the (possibly default)
values given to the ÿ~$þ directive.

If arg is a rational number, then it is coerced to be a single float
and then printed.  Alternatively, an implementation is permitted to
process a rational number by any other method that has essentially the
same behavior but avoids loss of precision or overflow because of the
coercion.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ÿ~wDþ, thereby printing it in
decimal radix and a minimum field width of w.

ÿ~$þ binds ÿ*print-escape*þ to false and ÿ*print-readably*þ to false.


File: chris-ansicl.info,  Node: FORMAT Printer Operations,  Next: FORMAT Pretty Printer Operations,  Prev: FORMAT Floating-Point Printers,  Up: Formatted Output

22.3.4 FORMAT Printer Operations
--------------------------------

22.3.4.1 Tilde A: Aesthetic
...........................

An arg, any object, is printed without escape characters (as by
ÿprincþ).  If arg is a string, its characters will be output verbatim.
If arg is ÿnilþ it will be printed as ÿnilþ; the colon modifier (ÿ~:Aþ)
will cause an arg of ÿnilþ to be printed as (), but if arg is a
composite structure, such as a list or vector, any contained
occurrences of ÿnilþ will still be printed as ÿnilþ.

ÿ~mincolAþ inserts spaces on the right, if necessary, to make the width
at least mincol columns.  The ÿ@þ modifier causes the spaces to be
inserted on the left rather than the right.

ÿ~mincol,colinc,minpad,padcharAþ is the full form of ÿ~Aþ, which allows
control of the padding.  The string is padded on the right (or on the
left if the ÿ@þ modifier is used) with at least minpad copies of
padchar; padding characters are then inserted colinc characters at a
time until the total width is at least mincol.  The defaults are ÿ0þ
for mincol and minpad, ÿ1þ for colinc, and the space character for
padchar.

ÿ~Aþ binds ÿ*print-escape*þ to false, and ÿ*print-readably*þ to false.

22.3.4.2 Tilde S: Standard
..........................

This is just like ÿ~Aþ, but arg is printed with escape characters (as
by ÿprin1þ rather than ÿprincþ).  The output is therefore suitable for
input to ÿreadþ.  ÿ~Sþ accepts all the arguments and modifiers that
ÿ~Aþ does.

ÿ~Sþ binds ÿ*print-escape*þ to ÿtþ.

22.3.4.3 Tilde W: Write
.......................

An argument, any object, is printed obeying every printer control
variable (as by ÿwriteþ).  In addition, ÿ~Wþ interacts correctly with
depth abbreviation, by not resetting the depth counter to zero.  ÿ~Wþ
does not accept parameters.  If given the colon modifier, ÿ~Wþ binds
ÿ*print-pretty*þ to true.  If given the at-sign modifier, ÿ~Wþ binds
ÿ*print-level*þ and ÿ*print-length*þ to ÿnilþ.

ÿ~Wþ provides automatic support for the detection of circularity and
sharing.  If the value of ÿ*print-circle*þ is not ÿnilþ and ÿ~Wþ is
applied to an argument that is a circular (or shared) reference, an
appropriate ÿ#N#þ marker is inserted in the output instead of printing
the argument.


File: chris-ansicl.info,  Node: FORMAT Pretty Printer Operations,  Next: FORMAT Layout Control,  Prev: FORMAT Printer Operations,  Up: Formatted Output

22.3.5 FORMAT Pretty Printer Operations
---------------------------------------

The following constructs provide access to the pretty printer:

22.3.5.1 Tilde Underscore: Conditional Newline
..............................................

Without any modifiers, ÿ~_þ is the same as ÿ(pprint-newline :linear)þ.
ÿ~@_þ  is the same as ÿ(pprint-newline :miser)þ.  ÿ~:_þ  is the same as
ÿ(pprint-newline :fill)þ.  ÿ~:@_þ is the same as ÿ(pprint-newline
:mandatory)þ.

22.3.5.2 Tilde Less-Than-Sign: Logical Block
............................................

ÿ~<...~:>þ

If ÿ~:>þ is used to terminate a ÿ~<...~>þ, the directive is equivalent
to a call to ÿpprint-logical-blockþ.  The argument corresponding to the
ÿ~<...~:>þ directive is treated in the same way as the list argument to
ÿpprint-logical-blockþ, thereby providing automatic support for
non-list arguments and the detection of circularity, sharing, and depth
abbreviation.  The portion of the CONTROL-STRING nested within the
ÿ~<...~:>þ specifies the :prefix (or :per-line-prefix), :suffix, and
body of the ÿpprint-logical-blockþ.

The CONTROL-STRING portion enclosed by ÿ~<...~:>þ can be divided into
segments ÿ~<PREFIX~;BODY~;SUFFIX~:>þ by ÿ~;þ directives.  If the first
section is terminated by ÿ~@;þ, it specifies a per-line prefix rather
than a simple prefix.  The PREFIX and SUFFIX cannot contain format
directives.  An error is signaled if either the prefix or suffix fails
to be a constant string or if the enclosed portion is divided into more
than three segments.

If the enclosed portion is divided into only two segments, the SUFFIX
defaults to the null string.  If the enclosed portion consists of only
a single segment, both the PREFIX and the SUFFIX default to the null
string.  If the colon modifier is used (i.e., ÿ~:<...~:>þ), the PREFIX
and SUFFIX default to ÿ"("þ and ÿ")"þ (respectively) instead of the
null string.

The body segment can be any arbitrary format string.  This format
string is applied to the elements of the list corresponding to the
ÿ~<...~:>þ directive as a whole.  Elements are extracted from this list
using ÿpprint-popþ, thereby providing automatic support for malformed
lists, and the detection of circularity, sharing, and length
abbreviation.  Within the body segment, ÿ~^þ acts like
ÿpprint-exit-if-list-exhaustedþ.

ÿ~<...~:>þ supports a feature not supported by ÿpprint-logical-blockþ.
If ÿ~:@>þ is used to terminate the directive (i.e., ÿ~<...~:@>þ), then
a fill-style conditional newline is automatically inserted after each
group of blanks immediately contained in the body (except for blanks
after a  <Newline> directive).  This makes it easy to achieve the
equivalent of paragraph filling.

If the at-sign modifier is used with ÿ~<...~:>þ, the entire remaining
argument list is passed to the directive as its argument.  All of the
remaining arguments are always consumed by ÿ~@<...~:>þ, even if they
are not all used by the format string nested in the directive.  Other
than the difference in its argument, ÿ~@<...~:>þ is exactly the same as
ÿ~<...~:>þ except that circularity detection is not applied if
ÿ~@<...~:>þ is encountered at top level in a format string.  This
ensures that circularity detection is applied only to data lists, not
to format argument lists.

ÿ" . #N#"þ is printed if circularity or sharing has to be indicated for
its argument as a whole.

To a considerable extent, the basic form of the directive ÿ~<...~>þ is
incompatible with the dynamic control of the arrangement of output by
ÿ~Wþ, ÿ~_þ, ÿ~<...~:>þ, ÿ~Iþ, and ÿ~:Tþ.  As a result, an error is
signaled if any of these directives is nested within ÿ~<...~>þ.  Beyond
this, an error is also signaled if the ÿ~<...~:;...~>þ form of
ÿ~<...~>þ is used in the same format string with ÿ~Wþ, ÿ~_þ,
ÿ~<...~:>þ, ÿ~Iþ, or ÿ~:Tþ.

See also *Note Section 22.3.6.2 (Tilde Less-Than-Sign. Justification):
TildeLessThanJustification.

22.3.5.3 Tilde I: Indent
........................

ÿ~NIþ  is the same as ÿ(pprint-indent :block n)þ.

ÿ~N:Iþ is the same as ÿ(pprint-indent :current n)þ.  In both cases, N
defaults to zero, if it is omitted.

22.3.5.4 Tilde Slash: Call Function
...................................

ÿ~/NAME/þ

User defined functions can be called from within a format string by
using the directive ÿ~/NAME/þ.  The colon modifier, the at-sign
modifier, and arbitrarily many parameters can be specified with the
ÿ~/NAME/þ directive.  NAME can be any arbitrary string that does not
contain a "/".  All of the characters in NAME are treated as if they
were upper case.  If NAME contains a single colon (ÿ:þ) or double colon
(ÿ::þ), then everything up to but not including the first ÿ":"þ or
ÿ"::"þ is taken to be a string that names a package.  Everything after
the first ÿ":"þ or ÿ"::"þ (if any) is taken to be a string that names a
ÿsymbolþ.  The function corresponding to a ÿ~/name/þ directive is
obtained by looking up the symbol that has the indicated name in the
indicated package.  If NAME does not contain a ÿ":"þ or ÿ"::"þ, then
the whole NAME string is looked up in the ÿCOMMON-LISP-USERþ package.

When a ÿ~/name/þ directive is encountered, the indicated function is
called with four or more arguments.  The first four arguments are: the
output stream, the format argument corresponding to the directive, a
generalized boolean that is true if the colon modifier was used, and a
generalized boolean that is true if the at-sign modifier was used.  The
remaining arguments consist of any parameters specified with the
directive.  The function should print the argument appropriately.  Any
values returned by the function are ignored.

The three functions ÿpprint-linearþ, ÿpprint-fillþ, and ÿpprint-tabularþ
are specifically designed so that they can be called by ÿ~/.../þ (i.e.,
ÿ~/pprint-linear/þ, ÿ~/pprint-fill/þ, and ÿ~/pprint-tabular/þ).  In
particular they take colon and at-sign arguments.


File: chris-ansicl.info,  Node: FORMAT Layout Control,  Next: FORMAT Control-Flow Operations,  Prev: FORMAT Pretty Printer Operations,  Up: Formatted Output

22.3.6 FORMAT Layout Control
----------------------------

22.3.6.1 Tilde T: Tabulate
..........................

This spaces over to a given column.  ÿ~colnum,colincTþ will output
sufficient spaces to move the cursor to column colnum.  If the cursor
is already at or beyond column colnum, it will output spaces to move it
to column colnum+k*colinc for the smallest positive integer k possible,
unless colinc is zero, in which case no spaces are output if the cursor
is already at or beyond column colnum.  colnum and colinc default to
ÿ1þ.

If for some reason the current absolute column position cannot be
determined by direct inquiry, ÿformatþ may be able to deduce the
current column position by noting that certain directives (such as
ÿ~%þ, or ÿ~&þ, or ÿ~Aþ with the argument being a string containing a
newline) cause the column position to be reset to zero, and counting
the number of characters emitted since that point.  If that fails,
ÿformatþ may attempt a similar deduction on the riskier assumption that
the destination was at column zero when ÿformatþ was invoked.  If even
this heuristic fails or is implementationally inconvenient, at worst
the ÿ~Tþ operation will simply output two spaces.

ÿ~@Tþ performs relative tabulation.  ÿ~colrel,colinc@Tþ outputs colrel
spaces and then outputs the smallest non-negative number of additional
spaces necessary to move the cursor to a column that is a multiple of
colinc.  For example, the directive ÿ~3,8@Tþ outputs three spaces and
then moves the cursor to a "standard multiple-of-eight tab stop" if not
at one already.  If the current output column cannot be determined,
however, then colinc is ignored, and exactly colrel spaces are output.

If the colon modifier is used with the ÿ~Tþ directive, the tabbing
computation is done relative to the horizontal position where the
section immediately containing the directive begins, rather than with
respect to a horizontal position of zero.  The numerical parameters are
both interpreted as being in units of ems and both default to ÿ1þ.
ÿ~N,M:Tþ is the same as ÿ(pprint-tab :section N M)þ.  ÿ~N,M:@Tþ is the
same as ÿ(pprint-tab :section-relative N M)þ.

22.3.6.2 Tilde Less-Than-Sign: Justification
............................................

ÿ~mincol,colinc,minpad,padchar<str~>þ

This justifies the text produced by processing str within a field at
least mincol columns wide.  str may be divided up into segments with
ÿ~;þ, in which case the spacing is evenly divided between the text
segments.

With no modifiers, the leftmost text segment is left justified in the
field, and the rightmost text segment is right justified.  If there is
only one text element, as a special case, it is right justified.  The
ÿ:þ modifier causes spacing to be introduced before the first text
segment;  the ÿ@þ modifier causes spacing to be added after the last.
The minpad parameter (default ÿ0þ) is the minimum number of padding
characters to be output between each segment.  The padding character is
supplied by padchar, which defaults to the space character.  If the
total width needed to satisfy these constraints is greater than mincol,
then the width used is mincol+k*colinc for the smallest possible
non-negative integer value k.  colinc defaults to ÿ1þ, and mincol
defaults to ÿ0þ.

Note that str may include ÿformatþ directives.  All the clauses in str
are processed in order; it is the resulting pieces of text that are
justified.

The ÿ~^ þ directive may be used to terminate processing of the clauses
prematurely, in which case only the completely processed clauses are
justified.

If the first clause of a ÿ~<þ is terminated with ÿ~:;þ instead of ÿ~;þ,
then it is used in a special way.  All of the clauses are processed
(subject to ÿ~^ þ, of course), but the first one is not used in
performing the spacing and padding.  When the padded result has been
determined, then if it will fit on the current line of output, it is
output, and the text for the first clause is discarded.  If, however,
the padded text will not fit on the current line, then the text segment
for the first clause is output before the padded text.  The first clause
ought to contain a newline (such as a ÿ~%þ directive).  The first
clause is always processed, and so any arguments it refers to will be
used; the decision is whether to use the resulting segment of text, not
whether to process the first clause.  If the ÿ~:;þ has a prefix
parameter n, then the padded text must fit on the current line with n
character positions to spare to avoid outputting the first clause's
text.  For example, the control string

 "~%;; ~{ ~<~%;; ~1:; ~S~>~^ ,~} .~%"

can be used to print a list of items separated by commas without
breaking items over line boundaries, beginning each line with ÿ;; þ.
The prefix parameter ÿ1þ in ÿ~1:;þ accounts for the width of the comma
that will follow the justified item if it is not the last element in
the list, or the period if it is.  If ÿ~:;þ has a second prefix
parameter, then it is used as the width of the line, thus overriding
the natural line width of the output stream.  To make the preceding
example use a line width of 50, one would write

 "~%;; ~{ ~<~%;; ~1,50:; ~S~>~^ ,~}  .~%"

If the second argument is not supplied, then ÿformatþ uses the line
width of the DESTINATION output stream.  If this cannot be determined
(for example, when producing a string result), then ÿformatþ uses ÿ72þ
as the line length.

See also *Note Section 22.3.5.2 (Tilde Less-Than-Sign. Logical Block):
TildeLessThanLogicalBlock.

22.3.6.3 Tilde Greater-Than-Sign: End of Justification
......................................................

ÿ~>þ terminates a ÿ~<þ.  The consequences of using it elsewhere are
undefined.


File: chris-ansicl.info,  Node: FORMAT Control-Flow Operations,  Next: FORMAT Miscellaneous Operations,  Prev: FORMAT Layout Control,  Up: Formatted Output

22.3.7 FORMAT Control-Flow Operations
-------------------------------------

22.3.7.1 Tilde Asterisk: Go-To
..............................

The next arg is ignored.  ÿ~n*þ ignores the next n arguments.

ÿ~:*þ backs up in the list of arguments so that the argument last
processed will be processed again.  ÿ~n:*þ backs up n arguments.

When within a ÿ~{þ construct (see below), the ignoring (in either
direction) is relative to the list of arguments being processed by the
iteration.

ÿ~n@*þ goes to the nth arg, where 0 means the first one; n defaults to
0, so ÿ~@*þ goes back to the first arg.  Directives after a ÿ~n@*þ will
take arguments in sequence beginning with the one gone to.  When within
a ÿ~{þ construct, the "goto" is relative to the list of arguments being
processed by the iteration.

22.3.7.2 Tilde Left-Bracket: Conditional Expression
...................................................

ÿ~[str0~;str1~;...~;strn~]þ

This is a set of control strings, called clauses, one of which is
chosen and used.  The clauses are separated by ÿ~;þ and the construct
is terminated by ÿ~]þ.  For example,

ÿ"~[Siamese~;Manx~;Persian~] Cat"þ

The argth clause is selected, where the first clause is number 0.  If a
prefix parameter is given (as ÿ~n[þ), then the parameter is used
instead of an argument.  If arg is out of range then no clause is
selected and no error is signaled.  After the selected alternative has
been processed, the control string continues after the ÿ~]þ.

ÿ~[str0~;str1~;...~;strn~:;default~]þ has a default case.  If the last
ÿ~;þ used to separate clauses is ÿ~:;þ instead, then the last clause is
an else clause that is performed if no other clause is selected.  For
example:

ÿ"~[Siamese~;Manx~;Persian~:;Alley~] Cat"þ

ÿ~:[ALTERNATIVE~;CONSEQUENT~]þ selects the ALTERNATIVE control string
if arg is false, and selects the CONSEQUENT control string otherwise.

ÿ~@[CONSEQUENT~]þ tests the argument.  If it is true, then the argument
is not used up by the ÿ~[þ command but remains as the next one to be
processed, and the one clause CONSEQUENT is processed.  If the arg is
false, then the argument is used up, and the clause is not processed.
The clause therefore should normally use exactly one argument, and may
expect it to be non-nil.  For example:

 (setq *print-level* nil *print-length* 5)
 (format nil
        "~@[ print level = ~D~]~@[ print length = ~D~]"
        *print-level* *print-length*)
ý  " print length = 5"

Note also that

 (format STREAM "...~@[STR~]..." ...)
Õ (format STREAM "...~:[~;~:*STR~]..." ...)

The combination of ÿ~[þ and ÿ#þ is useful, for example, for dealing
with English conventions for printing lists:

 (setq foo "Items:~#[ none~; ~S~; ~S and ~S~
           ~:;~@{~#[~; and~] ~S~^ ,~}~].")
 (format nil foo) ý  "Items: none."
 (format nil foo 'foo) ý  "Items: FOO."
 (format nil foo 'foo 'bar) ý  "Items: FOO and BAR."
 (format nil foo 'foo 'bar 'baz) ý  "Items: FOO, BAR, and BAZ."
 (format nil foo 'foo 'bar 'baz 'quux) ý  "Items: FOO, BAR, BAZ, and QUUX."

22.3.7.3 Tilde Right-Bracket: End of Conditional Expression
...........................................................

ÿ~]þ terminates a ÿ~[þ.  The consequences of using it elsewhere are
undefined.

22.3.7.4 Tilde Left-Brace: Iteration
....................................

ÿ~{str~}þ

This is an iteration construct.  The argument should be a list, which
is used as a set of arguments as if for a recursive call to ÿformatþ.
The string str is used repeatedly as the control string.  Each
iteration can absorb as many elements of the list as it likes as
arguments; if str uses up two arguments by itself, then two elements of
the list will get used up each time around the loop.  If before any
iteration step the list is empty, then the iteration is terminated.
Also, if a prefix parameter n is given, then there will be at most n
repetitions of processing of str.  Finally, the ÿ~^ þ directive can be
used to terminate the iteration prematurely.

For example:

 (format nil "The winners are:~{ ~S~}."
         '(fred harry jill))
ý "The winners are: FRED HARRY JILL."
 (format nil "Pairs:~{ <~S,~S>~}."
         '(a 1 b 2 c 3))
ý "Pairs: <A,1> <B,2> <C,3>."

ÿ~:{ str~}  þ is similar, but the argument should be a list of sublists.
At each repetition step, one sublist is used as the set of arguments for
processing str; on the next repetition, a new sublist is used, whether
or not all of the last sublist had been processed.  For example:

 (format nil "Pairs:~:{ <~S,~S>~} ."
                 '((a 1) (b 2) (c 3)))
ý "Pairs: <A,1> <B,2> <C,3>."

ÿ~@{ str~} þ is similar to ÿ~{ str~}  þ, but instead of using one
argument that is a list, all the remaining arguments are used as the
list of arguments for the iteration.  Example:

 (format nil "Pairs:~@{ <~S,~S>~} ." 'a 1 'b 2 'c 3)
ý "Pairs: <A,1> <B,2> <C,3>."

If the iteration is terminated before all the remaining arguments are
consumed, then any arguments not processed by the iteration remain to be
processed by any directives following the iteration construct.

ÿ~:@{ str~}  þ combines the features of ÿ~:{ str~}  þ and ÿ~@{ str~}  þ.
All the remaining arguments are used, and each one must be a list.  On
each iteration, the next argument is used as a list of arguments to str.
Example:

 (format nil "Pairs:~:@{ <~S,~S>~} ."
              '(a 1) '(b 2) '(c 3))
ý "Pairs: <A,1> <B,2> <C,3>."

Terminating the repetition construct with ÿ~:} þ instead of ÿ~}  þ
forces str to be processed at least once, even if the initial list of
arguments is null. However, this will not override an explicit prefix
parameter of zero.

If str is empty, then an argument is used as str.  It must be a format
control and precede any arguments processed by the iteration.  As an
example, the following are equivalent:

    (apply #'format stream string arguments)
 Õ (format stream "~1{~:}" string arguments)

This will use ÿstringþ as a formatting string.  The ÿ~1{ þ says it will
be processed at most once, and the ÿ~:} þ says it will be processed at
least once.  Therefore it is processed exactly once, using ÿargumentsþ
as the arguments.  This case may be handled more clearly by the ÿ~?þ
directive, but this general feature of ÿ~{  þ is more powerful than
ÿ~?þ.

22.3.7.5 Tilde Right-Brace: End of Iteration
............................................

ÿ~}þ terminates a ÿ~{þ.  The consequences of using it elsewhere are
undefined.

22.3.7.6 Tilde Question-Mark: Recursive Processing
..................................................

The next arg must be a format control, and the one after it a list;
both are consumed by the ÿ~?þ directive.  The two are processed as a
CONTROL-STRING, with the elements of the list as the arguments.  Once
the recursive processing has been finished, the processing of the
control string containing the ÿ~?þ directive is resumed.  Example:

 (format nil "~? ~D" "<~A ~D>" '("Foo" 5) 7) ý "<Foo 5> 7"
 (format nil "~? ~D" "<~A ~D>" '("Foo" 5 14) 7) ý "<Foo 5> 7"

Note that in the second example three arguments are supplied to the
format string ÿ"<~A ~D>"þ, but only two are processed and the third is
therefore ignored.

With the ÿ@þ modifier, only one arg is directly consumed.  The arg must
be a string; it is processed as part of the control string as if it had
appeared in place of the ÿ~@?þ construct, and any directives in the
recursively processed control string may consume arguments of the
control string containing the ÿ~@?þ directive.  Example:

 (format nil "~@? ~D" "<~A ~D>" "Foo" 5 7) ý "<Foo 5> 7"
 (format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7) ý "<Foo 5> 14"


File: chris-ansicl.info,  Node: FORMAT Miscellaneous Operations,  Next: FORMAT Miscellaneous Pseudo-Operations,  Prev: FORMAT Control-Flow Operations,  Up: Formatted Output

22.3.8 FORMAT Miscellaneous Operations
--------------------------------------

22.3.8.1 Tilde Left-Paren: Case Conversion
..........................................

ÿ~(str~)þ

The contained control string str is processed, and what it produces is
subject to case conversion.

With no flags, every uppercase character is converted to the
corresponding lowercase character.

ÿ~:(þ capitalizes all words, as if by ÿstring-capitalizeþ.

ÿ~@(þ capitalizes just the first word and forces the rest to lower case.

ÿ~:@(þ converts every lowercase character to the corresponding
uppercase character.

In this example ÿ~@(þ is used to cause the first word produced by ÿ~@Rþ
to be capitalized:

 (format nil "~@R ~(~@R~)" 14 14)
ý "XIV xiv"
 (defun f (n) (format nil "~@(~R~) error~:P detected." n)) ý F
 (f 0) ý "Zero errors detected."
 (f 1) ý "One error detected."
 (f 23) ý "Twenty-three errors detected."

When case conversions appear nested, the outer conversion dominates, as
illustrated in the following example:

 (format nil "~@(how is ~:(BOB SMITH~)?~)")
 ý "How is bob smith?"
 notý "How is Bob Smith?"

22.3.8.2 Tilde Right-Paren: End of Case Conversion
..................................................

ÿ~)þ terminates a ÿ~(þ.  The consequences of using it elsewhere are
undefined.

22.3.8.3 Tilde P: Plural
........................

If arg is not ÿeqlþ to the integer ÿ1þ, a lowercase ÿsþ is printed; if
arg is ÿeqlþ to ÿ1þ, nothing is printed.  If arg is a floating-point
ÿ1.0þ, the ÿsþ is printed.

ÿ~:Pþ does the same thing, after doing a ÿ~:*þ to back up one argument;
that is, it prints a lowercase ÿsþ if the previous argument was not ÿ1þ.

ÿ~@Pþ prints ÿyþ if the argument is ÿ1þ, or ÿiesþ if it is not.  ÿ~:@Pþ
does the same thing, but backs up first.

 (format nil "~D tr~:@P/~D win~:P" 7 1) ý "7 tries/1 win"
 (format nil "~D tr~:@P/~D win~:P" 1 0) ý "1 try/0 wins"
 (format nil "~D tr~:@P/~D win~:P" 1 3) ý "1 try/3 wins"


File: chris-ansicl.info,  Node: FORMAT Miscellaneous Pseudo-Operations,  Next: Additional Information about FORMAT Operations,  Prev: FORMAT Miscellaneous Operations,  Up: Formatted Output

22.3.9 FORMAT Miscellaneous Pseudo-Operations
---------------------------------------------

22.3.9.1 Tilde Semicolon: Clause Separator
..........................................

This separates clauses in ÿ~[þ and ÿ~<þ constructs.  The consequences
of using it elsewhere are undefined.

22.3.9.2 Tilde Circumflex: Escape Upward
........................................

ÿ~^ þ

This is an escape construct.  If there are no more arguments remaining
to be processed, then the immediately enclosing ÿ~{  þ or ÿ~<þ construct
is terminated.  If there is no such enclosing construct, then the entire
formatting operation is terminated.  In the ÿ~<þ case, the formatting
is performed, but no more segments are processed before doing the
justification.  ÿ~^ þ may appear anywhere in a ÿ~{  þ construct.

 (setq donestr "Done.~^ ~D warning~:P.~^ ~D error~:P.")
ý "Done.~^ ~D warning~:P.~^ ~D error~:P."
 (format nil donestr) ý "Done."
 (format nil donestr 3) ý "Done. 3 warnings."
 (format nil donestr 1 5) ý "Done. 1 warning. 5 errors."

If a prefix parameter is given, then termination occurs if the parameter
is zero.  (Hence ÿ~^þ is equivalent to ÿ~#^þ.)  If two parameters are
given, termination occurs if they are equal.    If three parameters are
given, termination occurs if the first is less than or equal to the
second and the second is less than or equal to the third.  Of course,
this is useless if all the prefix parameters are constants; at least
one of them should be a ÿ#þ or a ÿVþ parameter.

If ÿ~^þ is used within a ÿ~:{  þ construct, then it terminates the
current iteration step because in the standard case it tests for
remaining arguments of the current step only; the next iteration step
commences immediately.  ÿ~:^þ is used to terminate the iteration
process.  ÿ~:^þ may be used only if the command it would terminate is
ÿ~:{  þ or ÿ~:@{  þ.  The entire iteration process is terminated if and
only if the sublist that is supplying the arguments for the current
iteration step is the last sublist in the case of ÿ~:{ þ, or the last
ÿformatþ argument in the case of ÿ~:@{  þ.  ÿ~:^þ is not equivalent to
ÿ~#:^þ; the latter terminates the entire iteration if and only if no
arguments remain for the current iteration step.  For example:

 (format nil "~:{ ~@?~:^ ...~} " '(("a") ("b"))) ý "a...b"

If ÿ~^þ appears within a control string being processed under the
control of a ÿ~?þ directive, but not within any ÿ~{  þ or ÿ~<þ
construct within that string, then the string being processed will be
terminated, thereby ending processing of the ÿ~?þ directive.
Processing then continues within the string containing the ÿ~?þ
directive at the point following that directive.

If ÿ~^þ appears within a ÿ~[þ or ÿ~(þ construct, then all the commands
up to the ÿ~^þ are properly selected or case-converted, the ÿ~[þ or
ÿ~(þ processing is terminated, and the outward search continues for a
ÿ~{  þ or ÿ~<þ construct to be terminated.  For example:

 (setq tellstr "~@(~@[~R~]~^ ~A!~)")
ý "~@(~@[~R~]~^ ~A!~)"
 (format nil tellstr 23) ý "Twenty-three!"
 (format nil tellstr nil "losers") ý " Losers!"
 (format nil tellstr 23 "losers") ý "Twenty-three losers!"

Following are examples of the use of ÿ~^þ within a ÿ~<þ construct.

 (format nil "~15<~S~;~^~S~;~^~S~>" 'foo)
ý  "            FOO"
 (format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar)
ý  "FOO         BAR"
 (format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar 'baz)
ý  "FOO   BAR   BAZ"

22.3.9.3 Tilde Newline: Ignored Newline
.......................................

Tilde immediately followed by a newline ignores the newline and any
following non-newline whitespaceá characters.  With a ÿ:þ, the newline
is ignored, but any following whitespaceá is left in place.  With an
ÿ@þ, the newline is left in place, but any following whitespaceá is
ignored.  For example:

 (defun type-clash-error (fn nargs argnum right-type wrong-type)
   (format *error-output*
           "~&~S requires its ~:[~:R~;~*~]~
           argument to be of type ~S,~%but it was called ~
           with an argument of type ~S.~%"
           fn (eql nargs 1) argnum right-type wrong-type))
 (type-clash-error 'aref nil 2 'integer 'vector)  prints:
AREF requires its second argument to be of type INTEGER,
but it was called with an argument of type VECTOR.
NIL
 (type-clash-error 'car 1 1 'list 'short-float)  prints:
CAR requires its argument to be of type LIST,
but it was called with an argument of type SHORT-FLOAT.
NIL

Note that in this example newlines appear in the output only as
specified by the ÿ~&þ and ÿ~%þ directives; the actual newline characters
in the control string are suppressed because each is preceded by a
tilde.


File: chris-ansicl.info,  Node: Additional Information about FORMAT Operations,  Next: Examples of FORMAT,  Prev: FORMAT Miscellaneous Pseudo-Operations,  Up: Formatted Output

22.3.10 Additional Information about FORMAT Operations
------------------------------------------------------

22.3.10.1 Nesting of FORMAT Operations
......................................

The case-conversion, conditional, iteration, and justification
constructs can contain other formatting constructs by bracketing them.
These constructs must nest properly with respect to each other.  For
example, it is not legitimate to put the start of a case-conversion
construct in each arm of a conditional and the end of the
case-conversion construct outside the conditional:

 (format nil "~:[abc~:@(def~;ghi~
:@(jkl~]mno~)" x) ;Invalid!

This notation is invalid because the ÿ~[...~;...~]þ and ÿ~(...~)þ
constructs are not properly nested.

The processing indirection caused by the ÿ~?þ directive is also a kind
of nesting for the purposes of this rule of proper nesting.  It is not
permitted to start a bracketing construct within a string processed
under control of a ÿ~?þ directive and end the construct at some point
after the ÿ~?þ construct in the string containing that construct, or
vice versa.  For example, this situation is invalid:

 (format nil "~@?ghi~)" "abc~@(def") ;Invalid!

This notation is invalid because the ÿ~?þ and ÿ~(...~)þ constructs are
not properly nested.

22.3.10.2 Missing and Additional FORMAT Arguments
.................................................

The consequences are undefined if no ARG remains for a directive
requiring an argument.  However, it is permissible for one or more ARGS
to remain unprocessed by a directive; such ARGS are ignored.

22.3.10.3 Additional FORMAT Parameters
......................................

The consequences are undefined if a format directive is given more
parameters than it is described here as accepting.

22.3.10.4 Undefined FORMAT Modifier Combinations
................................................

The consequences are undefined if colon or at-sign modifiers are given
to a directive in a combination not specifically described here as
being meaningful.


File: chris-ansicl.info,  Node: Examples of FORMAT,  Next: Notes about FORMAT,  Prev: Additional Information about FORMAT Operations,  Up: Formatted Output

22.3.11 Examples of FORMAT
--------------------------

 (format nil "foo") ý "foo"
 (setq x 5) ý 5
 (format nil "The answer is ~D." x) ý "The answer is 5."
 (format nil "The answer is ~3D." x) ý "The answer is   5."
 (format nil "The answer is ~3,'0D." x) ý "The answer is 005."
 (format nil "The answer is ~:D." (expt 47 x))
ý "The answer is 229,345,007."
 (setq y "elephant") ý "elephant"
 (format nil "Look at the ~A!" y) ý "Look at the elephant!"
 (setq n 3) ý 3
 (format nil "~D item~:P found." n) ý "3 items found."
 (format nil "~R dog~:[s are~; is~] here." n (= n 1))
ý "three dogs are here."
 (format nil "~R dog~:*~[s are~; is~:;s are~] here." n)
ý "three dogs are here."
 (format nil "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." n)
ý "Here are three puppies."

 (defun foo (x)
   (format nil "~6,2F|~6,2,1,'*F|~6,2,,'?F|~6F|~,2F|~F"
           x x x x x x)) ý FOO
 (foo 3.14159)  ý "  3.14| 31.42|  3.14|3.1416|3.14|3.14159"
 (foo -3.14159) ý " -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159"
 (foo 100.0)    ý "100.00|******|100.00| 100.0|100.00|100.0"
 (foo 1234.0)   ý "1234.00|******|??????|1234.0|1234.00|1234.0"
 (foo 0.006)    ý "  0.01|  0.06|  0.01| 0.006|0.01|0.006"

 (defun foo (x)
    (format nil
           "~9,2,1,,'*E|~10,3,2,2,'?,,'$E|~
            ~9,3,2,-2,'%@E|~9,2E"
           x x x x))
 (foo 3.14159)  ý "  3.14E+0| 31.42$-01|+.003E+03|  3.14E+0"
 (foo -3.14159) ý " -3.14E+0|-31.42$-01|-.003E+03| -3.14E+0"
 (foo 1100.0)   ý "  1.10E+3| 11.00$+02|+.001E+06|  1.10E+3"
 (foo 1100.0L0) ý "  1.10L+3| 11.00$+02|+.001L+06|  1.10L+3"
 (foo 1.1E13)   ý "*********| 11.00$+12|+.001E+16| 1.10E+13"
 (foo 1.1L120)  ý "*********|??????????|%%%%%%%%%|1.10L+120"
 (foo 1.1L1200) ý "*********|??????????|%%%%%%%%%|1.10L+1200"

As an example of the effects of varying the scale factor, the code

 (dotimes (k 13)
   (format t "~%Scale factor ~2D: |~13,6,2,VE|"
           (- k 5) (- k 5) 3.14159))

produces the following output:

Scale factor -5: | 0.000003E+06|
Scale factor -4: | 0.000031E+05|
Scale factor -3: | 0.000314E+04|
Scale factor -2: | 0.003142E+03|
Scale factor -1: | 0.031416E+02|
Scale factor  0: | 0.314159E+01|
Scale factor  1: | 3.141590E+00|
Scale factor  2: | 31.41590E-01|
Scale factor  3: | 314.1590E-02|
Scale factor  4: | 3141.590E-03|
Scale factor  5: | 31415.90E-04|
Scale factor  6: | 314159.0E-05|
Scale factor  7: | 3141590.E-06|

 (defun foo (x)
   (format nil "~9,2,1,,'*G|~9,3,2,3,'?,,'$G|~9,3,2,0,'%G|~9,2G"
          x x x x))
 (foo 0.0314159) ý "  3.14E-2|314.2$-04|0.314E-01|  3.14E-2"
 (foo 0.314159)  ý "  0.31   |0.314    |0.314    | 0.31    "
 (foo 3.14159)   ý "   3.1   | 3.14    | 3.14    |  3.1    "
 (foo 31.4159)   ý "   31.   | 31.4    | 31.4    |  31.    "
 (foo 314.159)   ý "  3.14E+2| 314.    | 314.    |  3.14E+2"
 (foo 3141.59)   ý "  3.14E+3|314.2$+01|0.314E+04|  3.14E+3"
 (foo 3141.59L0) ý "  3.14L+3|314.2$+01|0.314L+04|  3.14L+3"
 (foo 3.14E12)   ý "*********|314.0$+10|0.314E+13| 3.14E+12"
 (foo 3.14L120)  ý "*********|?????????|%%%%%%%%%|3.14L+120"
 (foo 3.14L1200) ý "*********|?????????|%%%%%%%%%|3.14L+1200"

 (format nil "~10<foo~;bar~>")   ý "foo    bar"
 (format nil "~10:<foo~;bar~>")  ý "  foo  bar"
 (format nil "~10<foobar~>")     ý "    foobar"
 (format nil "~10:<foobar~>")    ý "    foobar"
 (format nil "~10:@<foo~;bar~>") ý "  foo bar "
 (format nil "~10@<foobar~>")    ý "foobar    "
 (format nil "~10:@<foobar~>")   ý "  foobar  "

  (FORMAT NIL "Written to ~A." #P"foo.bin")
  ý "Written to foo.bin."


File: chris-ansicl.info,  Node: Notes about FORMAT,  Prev: Examples of FORMAT,  Up: Formatted Output

22.3.12 Notes about FORMAT
--------------------------

Formatted output is performed not only by ÿformatþ, but by certain
other functions that accept a format control the way ÿformatþ does.
For example, error-signaling functions such as ÿcerrorþ accept format
controls.

Note that the meaning of ÿnilþ and ÿtþ as destinations to ÿformatþ are
different than those of ÿnilþ and ÿtþ as stream designators.

The ÿ~^þ should appear only at the beginning of a ÿ~<þ clause, because
it aborts the entire clause in which it appears (as well as all
following clauses).


File: chris-ansicl.info,  Node: copy-pprint-dispatch,  Next: formatter,  Prev: Formatted Output,  Up: Printer

copy-pprint-dispatch (Function)
===============================

Syntax:
.......

 -- Function: copy-pprint-dispatch &optional table ý new-table

Arguments and Values:
.....................

TABLE--a pprint dispatch table, or ÿnilþ.

NEW-TABLE--a fresh pprint dispatch table.

Description:
............

Creates and returns a copy of the specified TABLE, or of the value of
ÿ*print-pprint-dispatch*þ if no TABLE is specified, or of the initial
value of ÿ*print-pprint-dispatch*þ if ÿnilþ is specified.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if TABLE is not a pprint
dispatch table.


File: chris-ansicl.info,  Node: formatter,  Next: pprint-dispatch,  Prev: copy-pprint-dispatch,  Up: Printer

formatter (Macro)
=================

Syntax:
.......

 -- Macro: formatter control-string ý function

Arguments and Values:
.....................

CONTROL-STRING--a format string; not evaluated.

FUNCTION--a function.

Description:
............

Returns a function which has behavior equivalent to:

  #'(lambda (*standard-output* &rest arguments)
      (apply #'format t control-string arguments)
      arguments-tail)

where arguments-tail is either the tail of arguments which has as its
car the argument that would be processed next if there were more format
directives in the CONTROL-STRING, or else ÿnilþ if no more arguments
follow the most recently processed argument.

Examples:
.........

(funcall (formatter "~&~A~A") *standard-output* 'a 'b 'c)
Ö AB
ý (C)

(format t (formatter "~&~A~A") 'a 'b 'c)
Ö AB
ý NIL

Exceptional Situations:
.......................

Might signal an error (at macro expansion time or at run time) if the
argument is not a valid format string.

See Also:
.........

*Note format::


File: chris-ansicl.info,  Node: pprint-dispatch,  Next: pprint-exit-if-list-exhausted,  Prev: formatter,  Up: Printer

pprint-dispatch (Function)
==========================

Syntax:
.......

 -- Function: pprint-dispatch object &optional table ý function, found-p

Arguments and Values:
.....................

OBJECT--an object.

TABLE--a pprint dispatch table, or ÿnilþ.  The default is the value of
ÿ*print-pprint-dispatch*þ.

FUNCTION--a function designator.

FOUND-P--a generalized boolean.

Description:
............

Retrieves the highest priority function in TABLE that is associated
with a type specifier that matches OBJECT.  The function is chosen by
finding all of the type specifiers in TABLE that match the OBJECT and
selecting the highest priority function associated with any of these
type specifiers.  If there is more than one highest priority function,
an arbitrary choice is made.  If no type specifiers match the OBJECT, a
function is returned that prints OBJECT using ÿprint-objectþ.

The secondary value, FOUND-P, is true if a matching type specifier was
found in TABLE, or false otherwise.

If TABLE is ÿnilþ, retrieval is done in the initial pprint dispatch
table.

Affected By:
............

The state of the TABLE.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if table is neither a
pprint-dispatch-table nor ÿnilþ.

Notes:
......

(let ((*print-pretty* t))
  (write object :stream s))
Õ (funcall (pprint-dispatch object) s object)


File: chris-ansicl.info,  Node: pprint-exit-if-list-exhausted,  Next: pprint-fill; pprint-linear; pprint-tabular,  Prev: pprint-dispatch,  Up: Printer

pprint-exit-if-list-exhausted (Local Macro)
===========================================

Syntax:
.......

 -- Macro: pprint-exit-if-list-exhausted <no arguments> ý ÿnilþ

Description:
............

Tests whether or not the LIST passed to the lexically current logical
block has been exhausted; see *Note Section 22.2.1.1 (Dynamic Control
of the Arrangement of Output): DynamicControlofOutput.  If this LIST
has been reduced to ÿnilþ, ÿpprint-exit-if-list-exhaustedþ terminates
the execution of the lexically current logical block except for the
printing of the suffix.  Otherwise ÿpprint-exit-if-list-exhaustedþ
returns ÿnilþ.

Whether or not ÿpprint-exit-if-list-exhaustedþ is fbound in the global
environment is implementation-dependent; however, the restrictions on
redefinition and shadowing of ÿpprint-exit-if-list-exhaustedþ are the
same as for symbols in the ÿCOMMON-LISPþ package which are fbound in
the global environment.  The consequences of attempting to use
ÿpprint-exit-if-list-exhaustedþ outside of ÿpprint-logical-blockþ are
undefined.

Exceptional Situations:
.......................

An error is signaled (at macro expansion time or at run time) if
ÿpprint-exit-if-list-exhaustedþ is used anywhere other than lexically
within a call on ÿpprint-logical-blockþ.  Also, the consequences of
executing ÿpprint-if-list-exhaustedþ outside of the dynamic extent of
the ÿpprint-logical-blockþ which lexically contains it are undefined.

See Also:
.........

*Note pprint-logical-block::, *Note pprint-pop::.


File: chris-ansicl.info,  Node: pprint-fill; pprint-linear; pprint-tabular,  Next: pprint-indent,  Prev: pprint-exit-if-list-exhausted,  Up: Printer

pprint-fill, pprint-linear, pprint-tabular (Function)
=====================================================

Syntax:
.......

 -- Function: pprint-fill stream object &optional colon-p at-sign-p ý
          ÿnilþ

 -- Function: pprint-linear stream object &optional colon-p at-sign-p ý
          ÿnilþ

 -- Function: pprint-tabular stream object &optional colon-p at-sign-p
          tabsize ý ÿnilþ

Arguments and Values:
.....................

STREAM--an output stream designator.

OBJECT--an object.

COLON-P--a generalized boolean.  The default is true.

AT-SIGN-P--a generalized boolean.  The default is
implementation-dependent.

TABSIZE--a non-negative integer.  The default is ÿ16þ.

Description:
............

The functions ÿpprint-fillþ, ÿpprint-linearþ, and ÿpprint-tabularþ
specify particular ways of pretty printing a list to STREAM.  Each
function prints parentheses around the output if and only if COLON-P is
true.  Each function ignores its AT-SIGN-P argument.  (Both arguments
are included even though only one is needed so that these functions can
be used via `~/.../' and as ÿset-pprint-dispatchþ functions, as well as
directly.)  Each function handles abbreviation and the detection of
circularity and sharing correctly, and uses ÿwriteþ to print OBJECT
when it is a non-list.

If OBJECT is a list and if the value of ÿ*print-pretty*þ is false, each
of these functions prints OBJECT using a minimum of whitespace, as
described in *Note Section 22.1.3.5 (Printing Lists and Conses):
PrintingListsAndConses.  Otherwise (if OBJECT is a list and if the
value of ÿ*print-pretty*þ is true):

   * The function ÿpprint-linearþ prints a list either all on one line,
     or with each element on a separate line.

   * The function ÿpprint-fillþ prints a list with as many elements as
     possible on each line.

   * The function ÿpprint-tabularþ is the same as ÿpprint-fillþ except
     that it prints the elements so that they line up in columns.  The
     TABSIZE specifies the column spacing in ems, which is the total
     spacing from the leading edge of one column to the leading edge of
     the next.

Examples:
.........

Evaluating the following with a line length of ÿ25þ produces the output
shown.

(progn (princ "Roads ")
       (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))
Roads ELM     MAIN
      MAPLE   CENTER

Side Effects:
.............

Performs output to the indicated stream.

Affected By:
............

The cursor position on the indicated stream, if it can be determined.

Notes:
......

The function ÿpprint-tabularþ could be defined as follows:

(defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))
  (declare (ignore at-sign-p))
  (when (null tabsize) (setq tabsize 16))
  (pprint-logical-block (s list :prefix (if colon-p "(" "")
                                :suffix (if colon-p ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write (pprint-pop) :stream s)
          (pprint-exit-if-list-exhausted)
          (write-char #\Space s)
          (pprint-tab :section-relative 0 tabsize s)
          (pprint-newline :fill s))))

Note that it would have been inconvenient to specify this function
using ÿformatþ, because of the need to pass its TABSIZE argument
through to a `~:T' format directive nested within an iteration over a
list.


File: chris-ansicl.info,  Node: pprint-indent,  Next: pprint-logical-block,  Prev: pprint-fill; pprint-linear; pprint-tabular,  Up: Printer

pprint-indent (Function)
========================

Syntax:
.......

 -- Function: pprint-indent relative-to n &optional stream ý ÿnilþ

Arguments and Values:
.....................

RELATIVE-TO--either :block or :current.

N--a real.

STREAM--an output stream designator.  The default is standard output.

Description:
............

ÿpprint-indentþ specifies the indentation to use in a logical block on
stream.  If STREAM is a pretty printing stream and the value of
ÿ*print-pretty*þ is true, ÿpprint-indentþ sets the indentation in the
innermost dynamically enclosing logical block; otherwise,
ÿpprint-indentþ has no effect.

N specifies the indentation in ems.  If RELATIVE-TO is :block, the
indentation is set to the horizontal position of the first character in
the dynamically current logical block plus N ems. If RELATIVE-TO is
:current, the indentation is set to the current output position plus N
ems. (For robustness in the face of variable-width fonts, it is
advisable to use :current with an N of zero whenever possible.)

N can be negative; however, the total indentation cannot be moved left
of the beginning of the line or left of the end of the rightmost
per-line prefix--an attempt to move beyond one of these limits is
treated the same as an attempt to move to that limit.  Changes in
indentation caused by PPRINT-INDENT do not take effect until after the
next line break.  In addition, in miser mode all calls to
ÿpprint-indentþ are ignored, forcing the lines corresponding to the
logical block to line up under the first character in the block.

Exceptional Situations:
.......................

An error is signaled if RELATIVE-TO is any object other than :block or
:current.

See Also:
.........

*Note Section 22.3.5.3 (Tilde I. Indent): TildeI.


File: chris-ansicl.info,  Node: pprint-logical-block,  Next: pprint-newline,  Prev: pprint-indent,  Up: Printer

pprint-logical-block (Macro)
============================

Syntax:
.......

 -- Macro: pprint-logical-block
          (stream-symbol object  &key prefix per-line-prefix suffix)
          {declaration}* {form}* ý ÿnilþ

Arguments and Values:
.....................

STREAM-SYMBOL--a stream variable designator.

OBJECT--an object; evaluated.

:prefix--a string; evaluated.  Complicated defaulting behavior; see
below.

:per-line-prefix--a string; evaluated.  Complicated defaulting
behavior; see below.

:suffix--a string; evaluated.  The default is the null string.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

Description:
............

Causes printing to be grouped into a logical block.

The logical block is printed to the stream that is the value of the
variable denoted by STREAM-SYMBOL.  During the execution of the forms,
that variable is bound to a pretty printing stream that supports
decisions about the arrangement of output and then forwards the output
to the destination stream.  All the standard printing functions (e.g.,
ÿwriteþ, ÿprincþ, and ÿterpriþ) can be used to print output to the
pretty printing stream.  All and only the output sent to this pretty
printing stream is treated as being in the logical block.

The PREFIX specifies a prefix to be printed before the beginning of the
logical block.  The PER-LINE-PREFIX specifies a prefix that is printed
before the block and at the beginning of each new line in the block.
The :prefix and :pre-line-prefix arguments are mutually exclusive.  If
neither :prefix nor :per-line-prefix is specified, a PREFIX of the null
string is assumed.

The SUFFIX specifies a suffix that is printed just after the logical
block.

The OBJECT is normally a list that the body FORMS are responsible for
printing.  If OBJECT is not a list, it is printed using ÿwriteþ.  (This
makes it easier to write printing functions that are robust in the face
of malformed arguments.)  If ÿ*print-circle*þ is non-nil and OBJECT is
a circular (or shared) reference to a cons, then an appropriate "ÿ#n#þ"
marker is printed.  (This makes it easy to write printing functions
that provide full support for circularity and sharing abbreviation.)
If ÿ*print-level*þ is not ÿnilþ and the logical block is at a dynamic
nesting depth of greater than ÿ*print-level*þ in logical blocks, "ÿ#þ"
is printed.  (This makes easy to write printing functions that provide
full support for depth abbreviation.)

If either of the three conditions above occurs, the indicated output is
printed on STREAM-SYMBOL and the body FORMS are skipped along with the
printing of the :prefix and :suffix.  (If the body FORMS are not to be
responsible for printing a list, then the first two tests above can be
turned off by supplying ÿnilþ for the OBJECT argument.)

In addition to the OBJECT argument of ÿpprint-logical-blockþ, the
arguments of the standard printing functions (such as ÿwriteþ, ÿprintþ,
ÿprin1þ, and ÿpprintþ, as well as the arguments of the standard format
directives such as `~A', `~S', (and `~W') are all checked (when
necessary) for circularity and sharing.  However, such checking is not
applied to the arguments of the functions ÿwrite-lineþ, ÿwrite-stringþ,
and ÿwrite-charþ or to the literal text output by ÿformatþ.  A
consequence of this is that you must use one of the latter functions if
you want to print some literal text in the output that is not supposed
to be checked for circularity or sharing.

The body FORMS of a ÿpprint-logical-blockþ form must not perform any
side-effects on the surrounding environment; for example, no variables
must be assigned which have not been bound within its scope.

The ÿpprint-logical-blockþ macro may be used regardless of the value of
ÿ*print-pretty*þ.

Affected By:
............

ÿ*print-circle*þ, ÿ*print-level*þ.

Exceptional Situations:
.......................

An error of type ÿtype-errorþ is signaled if any of the :suffix,
:prefix, or :per-line-prefix is supplied but does not evaluate to a
string.

An error is signaled if :prefix and :pre-line-prefix are both used.

ÿpprint-logical-blockþ and the pretty printing stream it creates have
dynamic extent.  The consequences are undefined if, outside of this
extent, output is attempted to the pretty printing stream it creates.

It is also unspecified what happens if, within this extent, any output
is sent directly to the underlying destination stream.

See Also:
.........

*Note pprint-pop::, *Note pprint-exit-if-list-exhausted::, *Note
Section 22.3.5.2 (Tilde Less-Than-Sign. Logical Block):
TildeLessThanLogicalBlock.

Notes:
......

One reason for using the ÿpprint-logical-blockþ macro when the value of
ÿ*print-pretty*þ is ÿnilþ would be to allow it to perform checking for
dotted lists, as well as (in conjunction with ÿpprint-popþ) checking
for ÿ*print-level*þ or ÿ*print-length*þ being exceeded.

Detection of circularity and sharing is supported by the pretty printer
by in essence performing requested output twice.  On the first pass,
circularities and sharing are detected and the actual outputting of
characters is suppressed.  On the second pass, the appropriate "ÿ#N=þ"
and "ÿ#N#þ" markers are inserted and characters are output.  This is
why the restriction on side-effects is necessary.  Obeying this
restriction is facilitated by using ÿpprint-popþ, instead of an
ordinary ÿpopþ when traversing a list being printed by the body FORMS
of the ÿpprint-logical-blockþ form.)


File: chris-ansicl.info,  Node: pprint-newline,  Next: pprint-pop,  Prev: pprint-logical-block,  Up: Printer

pprint-newline (Function)
=========================

Syntax:
.......

 -- Function: pprint-newline kind &optional stream ý ÿnilþ

Arguments and Values:
.....................

KIND--one of :linear, :fill, :miser, or :mandatory.

STREAM--a stream designator.  The default is standard output.

Description:
............

If STREAM is a pretty printing stream and the value of ÿ*print-pretty*þ
is true, a line break is inserted in the output when the appropriate
condition below is satisfied; otherwise, ÿpprint-newlineþ has no effect.

KIND specifies the style of conditional newline.  This parameter is
treated as follows:

:linear
     This specifies a "linear-style" conditional newline.  A line break
     is inserted if and only if the immediately containing section
     cannot be printed on one line.  The effect of this is that line
     breaks are either inserted at every linear-style conditional
     newline in a logical block or at none of them.

:miser
     This specifies a "miser-style" conditional newline.  A line break
     is inserted if and only if the immediately containing section
     cannot be printed on one line and miser style is in effect in the
     immediately containing logical block.  The effect of this is that
     miser-style conditional newlines act like linear-style conditional
     newlines, but only when miser style is in effect.  Miser style is
     in effect for a logical block if and only if the starting position
     of the logical block is less than or equal to
     ÿ*print-miser-width*þ ems from the right margin.

:fill
     This specifies a "fill-style" conditional newline.  A line break
     is inserted if and only if either (a) the following section cannot
     be printed on the end of the current line, (b) the preceding
     section was not printed on a single line, or (c) the immediately
     containing section cannot be printed on one line and miser style
     is in effect in the immediately containing logical block.  If a
     logical block is broken up into a number of subsections by
     fill-style conditional newlines, the basic effect is that the
     logical block is printed with as many subsections as possible on
     each line.  However, if miser style is in effect, fill-style
     conditional newlines act like linear-style conditional newlines.

:mandatory
     This specifies a "mandatory-style" conditional newline.  A line
     break is always inserted.  This implies that  none of the
     containing sections can be printed on a single line and will
     therefore trigger the insertion of line breaks at linear-style
     conditional newlines in these sections.

When a line break is inserted by any type of conditional newline, any
blanks that immediately precede the conditional newline are omitted
from the output and indentation is introduced at the beginning of the
next line.  By default, the indentation causes the following line to
begin in the same horizontal position as the first character in the
immediately containing logical block.  (The indentation can be changed
via ÿpprint-indentþ.)

There are a variety of ways unconditional newlines can be introduced
into the output (i.e., via ÿterpriþ or by printing a string containing
a newline character).  As with mandatory conditional newlines, this
prevents any of the containing sections from being printed on one line.
In general, when an unconditional newline is encountered, it is
printed out without suppression of the preceding blanks and without any
indentation following it.  However, if a per-line prefix has been
specified (see ÿpprint-logical-blockþ), this prefix will always be
printed no matter how a newline originates.

Examples:
.........

See *Note Section 22.2.2 (Examples of using the Pretty Printer):
Examples of using the Pretty Printer.

Side Effects:
.............

Output to STREAM.

Affected By:
............

ÿ*print-pretty*þ, ÿ*print-miser*þ.  The presence of containing logical
blocks.  The placement of newlines and conditional newlines.

Exceptional Situations:
.......................

An error of type ÿtype-errorþ is signaled if KIND is not one of
:linear, :fill, :miser, or :mandatory.

See Also:
.........

*Note Section 22.3.5.1 (Tilde Underscore. Conditional Newline):
TildeUnderscore, *Note Section 22.2.2 (Examples of using the Pretty
Printer): Examples of using the Pretty Printer.


File: chris-ansicl.info,  Node: pprint-pop,  Next: pprint-tab,  Prev: pprint-newline,  Up: Printer

pprint-pop (Local Macro)
========================

Syntax:
.......

 -- Macro: pprint-pop <no arguments> ý object

Arguments and Values:
.....................

OBJECT--an element of the list being printed in the lexically current
logical block, or ÿnilþ.

Description:
............

Pops one element from the list being printed in the lexically current
logical block, obeying ÿ*print-length*þ and ÿ*print-circle*þ as
described below.

Each time ÿpprint-popþ is called, it pops the next value off the list
passed to the lexically current logical block and returns it.  However,
before doing this, it performs three tests:

   * If the remaining `list' is not a list, "ÿ. þ" is printed followed
     by the remaining `list.'  (This makes it easier to write printing
     functions that are robust in the face of malformed arguments.)

   * If ÿ*print-length*þ is non-nil, and ÿpprint-popþ has already been
     called ÿ*print-length*þ times within the immediately containing
     logical block, "ÿ...þ" is printed.  (This makes it easy to write
     printing functions that properly handle ÿ*print-length*þ.)

   * If ÿ*print-circle*þ is non-nil, and the remaining list is a
     circular (or shared) reference, then "ÿ. þ" is printed followed by
     an appropriate "ÿ#n#þ" marker.  (This catches instances of cdr
     circularity and sharing in lists.)

If either of the three conditions above occurs, the indicated output is
printed on the pretty printing stream created by the immediately
containing ÿpprint-logical-blockþ and the execution of the immediately
containing ÿpprint-logical-blockþ is terminated except for the printing
of the suffix.

If ÿpprint-logical-blockþ is given a `list' argument of ÿnilþ--because
it is not processing a list--ÿpprint-popþ can still be used to obtain
support for ÿ*print-length*þ.  In this situation, the first and third
tests above are disabled and ÿpprint-popþ always returns ÿnilþ.  See
*Note Section 22.2.2 (Examples of using the Pretty Printer): Examples
of using the Pretty Printer.--specifically, the ÿpprint-vectorþ example.

Whether or not ÿpprint-popþ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ÿpprint-popþ are the same as for symbols in the
ÿCOMMON-LISPþ package which are fbound in the global environment.  The
consequences of attempting to use ÿpprint-popþ outside of
ÿpprint-logical-blockþ are undefined.

Side Effects:
.............

Might cause output to the pretty printing stream associated with the
lexically current logical block.

Affected By:
............

ÿ*print-length*þ, ÿ*print-circle*þ.

Exceptional Situations:
.......................

An error is signaled (either at macro expansion time or at run time) if
a usage of ÿpprint-popþ occurs where there is no lexically containing
ÿpprint-logical-blockþ form.

The consequences are undefined if ÿpprint-popþ is executed outside of
the dynamic extent of this ÿpprint-logical-blockþ.

See Also:
.........

*Note pprint-exit-if-list-exhausted::, *Note pprint-logical-block::.

Notes:
......

It is frequently a good idea to call ÿpprint-exit-if-list-exhaustedþ
before calling ÿpprint-popþ.


File: chris-ansicl.info,  Node: pprint-tab,  Next: print-object,  Prev: pprint-pop,  Up: Printer

pprint-tab (Function)
=====================

Syntax:
.......

 -- Function: pprint-tab kind colnum colinc &optional stream ý ÿnilþ

Arguments and Values:
.....................

KIND--one of :line, :section, :line-relative, or :section-relative.

COLNUM--a non-negative integer.

COLINC--a non-negative integer.

STREAM--an output stream designator.

Description:
............

Specifies tabbing to STREAM as performed by the standard `~T' format
directive.  If STREAM is a pretty printing stream and the value of
ÿ*print-pretty*þ is true, tabbing is performed; otherwise, ÿpprint-tabþ
has no effect.

The arguments COLNUM and COLINC correspond to the two PARAMETERS to
`~T' and are in terms of ems.  The KIND argument specifies the style of
tabbing.  It must be one of :line (tab as by `~T'), :section (tab as by
`~:T', but measuring horizontal positions relative to the start of the
dynamically enclosing section), :line-relative (tab as by `~@T'), or
:section-relative (tab as by `~:@T', but measuring horizontal positions
relative to the start of the dynamically enclosing section).

Exceptional Situations:
.......................

An error is signaled if KIND is not one of :line, :section,
:line-relative, or :section-relative.

See Also:
.........

*Note pprint-logical-block::


File: chris-ansicl.info,  Node: print-object,  Next: print-unreadable-object,  Prev: pprint-tab,  Up: Printer

print-object (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: print-object object stream ý object

Method Signatures:
..................

print-object (OBJECT standard-object) STREAM  print-object (OBJECT
structure-object) STREAM

Arguments and Values:
.....................

OBJECT--an object.

STREAM--a stream.

Description:
............

The generic function ÿprint-objectþ writes the printed representation
of OBJECT to STREAM.  The function ÿprint-objectþ is called by the Lisp
printer; it should not be called by the user.

Each implementation is required to provide a method on the class
ÿstandard-objectþ and on the class ÿstructure-objectþ.  In addition,
each implementation must provide methods on enough other classes so as
to ensure that there is always an applicable method.  Implementations
are free to add methods for other classes.  Users may write methods for
ÿprint-objectþ for their own classes if they do not wish to inherit an
implementation-dependent method.

The method on the class ÿstructure-objectþ prints the object in the
default ÿ#Sþ notation; see *Note Section 22.1.3.12 (Printing
Structures): PrintingStructures.

Methods on ÿprint-objectþ are responsible for implementing their part
of the semantics of the printer control variables, as follows:

ÿ*print-readably*þ
     All methods for ÿprint-objectþ must obey ÿ*print-readably*þ.  This
     includes both user-defined methods and implementation-defined
     methods.  Readable printing of structures and standard objects is
     controlled by their ÿprint-objectþ method, not by their
     ÿmake-load-formþ method.  Similarity for these objects is
     application dependent and hence is defined to be whatever these
     methods do; see *Note Section 3.2.4.2 (Similarity of Literal
     Objects): Similarity.

ÿ*print-escape*þ
     Each method must implement ÿ*print-escape*þ.

ÿ*print-pretty*þ
     The method may wish to perform specialized line breaking or other
     output conditional on the value of ÿ*print-pretty*þ.  For further
     information, see (for example) the macro ÿpprint-fillþ.  See also
     *Note Section 22.2.1.4 (Pretty Print Dispatch Tables):
     PPrintDispatchTables. and *Note Section 22.2.2 (Examples of using
     the Pretty Printer): Examples of using the Pretty Printer.

ÿ*print-length*þ
     Methods that produce output of indefinite length must obey
     ÿ*print-length*þ.  For further information, see (for example) the
     macros ÿpprint-logical-blockþ and ÿpprint-popþ.  See also *Note
     Section 22.2.1.4 (Pretty Print Dispatch Tables):
     PPrintDispatchTables. and *Note Section 22.2.2 (Examples of using
     the Pretty Printer): Examples of using the Pretty Printer.

ÿ*print-level*þ
     The printer takes care of ÿ*print-level*þ automatically, provided
     that each method handles exactly one level of structure and calls
     ÿwriteþ (or an equivalent function) recursively if there are more
     structural levels.  The printer's decision of whether an object
     has components (and therefore should not be printed when the
     printing depth is not less than ÿ*print-level*þ) is
     implementation-dependent.  In some implementations its
     ÿprint-objectþ method is not called; in others the method is
     called, and the determination that the object has components is
     based on what it tries to write to the STREAM.

ÿ*print-circle*þ
     When the value of ÿ*print-circle*þ is true, a user-defined
     ÿprint-objectþ method can print objects to the supplied stream
     using ÿwriteþ, ÿprin1þ, ÿprincþ, or ÿformatþ and expect
     circularities to be detected and printed using the ÿ#n#þ syntax.
     If a user-defined ÿprint-objectþ method prints to a stream other
     than the one that was supplied, then circularity detection starts
     over for that stream.  See ÿ*print-circle*þ.

ÿ*print-base*þ, ÿ*print-radix*þ, ÿ*print-case*þ,  ÿ*print-gensym*þ, and ÿ*print-array*þ
     These printer control variables apply to specific types of objects
     and are handled by the methods for those objects.

If these rules are not obeyed, the results are undefined.

In general, the printer and the ÿprint-objectþ methods should not
rebind the print control variables as they operate recursively through
the structure, but this is implementation-dependent.

In some implementations the STREAM argument passed to a ÿprint-objectþ
method is not the original stream, but is an intermediate stream that
implements part of the printer.  methods should therefore not depend on
the identity of this stream.

See Also:
.........

*Note pprint-fill::, *Note pprint-logical-block::, *Note pprint-pop::,
*Note write::, *Note *print-readably*::, *Note *print-escape*::, *Note
*print-pretty*::, *Note *print-length*::, *Note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods, *Note Section
22.1.3.12 (Printing Structures): PrintingStructures, *Note Section
22.2.1.4 (Pretty Print Dispatch Tables): PPrintDispatchTables, *Note
Section 22.2.2 (Examples of using the Pretty Printer): Examples of
using the Pretty Printer.


File: chris-ansicl.info,  Node: print-unreadable-object,  Next: set-pprint-dispatch,  Prev: print-object,  Up: Printer

print-unreadable-object (Macro)
===============================

Syntax:
.......

 -- Macro: print-unreadable-object (object stream &key type identity)
          {form}* ý ÿnilþ

Arguments and Values:
.....................

OBJECT--an object; evaluated.

STREAM-- a stream designator; evaluated.

TYPE--a generalized boolean; evaluated.

IDENTITY--a generalized boolean; evaluated.

FORMS--an implicit progn.

Description:
............

Outputs a printed representation of OBJECT on STREAM, beginning with
"ÿ#<þ" and ending with "ÿ>þ".  Everything output to STREAM by the body
FORMS is enclosed in the the angle brackets.  If TYPE is true, the
output from FORMS is preceded by a brief description of the OBJECT's
type and a space character.  If IDENTITY is true, the output from FORMS
is followed by a space character and a representation of the OBJECT's
identity, typically a storage address.

If either TYPE or IDENTITY is not supplied, its value is false.  It is
valid to omit the body FORMS.  If TYPE and IDENTITY are both true and
there are no body FORMS, only one space character separates the type
and the identity.

Examples:
.........

;; Note that in this example, the precise form of the output ;; is
implementation-dependent.

 (defmethod print-object ((obj airplane) stream)
   (print-unreadable-object (obj stream :type t :identity t)
     (princ (tail-number obj) stream)))

 (prin1-to-string my-airplane)
ý "#<Airplane NW0773 36000123135>"
orý "#<FAA:AIRPLANE NW0773 17>"

Exceptional Situations:
.......................

If ÿ*print-readably*þ is true, ÿprint-unreadable-objectþ signals an
error of type ÿprint-not-readableþ without printing anything.


File: chris-ansicl.info,  Node: set-pprint-dispatch,  Next: write; prin1; print; pprint; princ,  Prev: print-unreadable-object,  Up: Printer

set-pprint-dispatch (Function)
==============================

Syntax:
.......

 -- Function: set-pprint-dispatch type-specifier function &optional
          priority table ý ÿnilþ

Arguments and Values:
.....................

TYPE-SPECIFIER--a type specifier.

FUNCTION--a function, a function name, or ÿnilþ.

PRIORITY--a real.  The default is ÿ0þ.

TABLE--a pprint dispatch table.  The default is the value of
ÿ*print-pprint-dispatch*þ.

Description:
............

Installs an entry into the pprint dispatch table which is TABLE.

TYPE-SPECIFIER is the key of the entry.  The first action of
ÿset-pprint-dispatchþ is to remove any pre-existing entry associated
with TYPE-SPECIFIER.  This guarantees that there will never be two
entries associated with the same type specifier in a given pprint
dispatch table.  Equality of type specifiers is tested by ÿequalþ.

Two values are associated with each type specifier in a pprint dispatch
table: a FUNCTION and a PRIORITY.  The FUNCTION must accept two
arguments: the stream to which output is sent and the object to be
printed.  The FUNCTION should pretty print the object to the STREAM.
The FUNCTION can assume that object satisfies the type given by
type-specifier.  The FUNCTION must obey ÿ*print-readably*þ.  Any values
returned by the FUNCTION are ignored.

PRIORITY is a priority to resolve conflicts when an object matches more
than one entry.

It is permissible for FUNCTION to be ÿnilþ.  In this situation, there
will be no TYPE-SPECIFIER entry in TABLE after ÿset-pprint-dispatchþ
returns.

Exceptional Situations:
.......................

An error is signaled if PRIORITY is not a real.

Notes:
......

Since pprint dispatch tables are often used to control the pretty
printing of Lisp code, it is common for the TYPE-SPECIFIER to be an
expression of the form

 (cons CAR-TYPE CDR-TYPE)

This signifies that the corresponding object must be a cons cell whose
car matches the type specifier CAR-TYPE and whose cdr matches the type
specifier CDR-TYPE.  The CDR-TYPE can be omitted in which case it
defaults to t.


File: chris-ansicl.info,  Node: write; prin1; print; pprint; princ,  Next: write-to-string; prin1-to-string; princ-to-string,  Prev: set-pprint-dispatch,  Up: Printer

write, prin1, print, pprint, princ (Function)
=============================================

Syntax:
.......

 -- Function: write OBJECT &key array base case circle escape gensym
          length level lines miser-width pprint-dispatch
          pretty radix readably right-margin stream
          ý object

 -- Function: prin1 object &optional output-stream ý object

 -- Function: princ object &optional output-stream ý object

 -- Function: print object &optional output-stream ý object

 -- Function: pprint object &optional output-stream ý <no values>

Arguments and Values:
.....................

OBJECT--an object.

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

ARRAY--a generalized boolean.

BASE--a radix.

CASE--a symbol of type ÿ(member :upcase :downcase :capitalize)þ.

CIRCLE--a generalized boolean.

ESCAPE--a generalized boolean.

GENSYM--a generalized boolean.

LENGTH--a non-negative integer, or ÿnilþ.

LEVEL--a non-negative integer, or ÿnilþ.

LINES--a non-negative integer, or ÿnilþ.

MISER-WIDTH--a non-negative integer, or ÿnilþ.

PPRINT-DISPATCH--a pprint dispatch table.

PRETTY--a generalized boolean.

RADIX--a generalized boolean.

READABLY--a generalized boolean.

RIGHT-MARGIN--a non-negative integer, or ÿnilþ.

STREAM--an output stream designator.  The default is standard output.

Description:
............

ÿwriteþ, ÿprin1þ, ÿprincþ, ÿprintþ, and ÿpprintþ write the printed
representation of OBJECT to OUTPUT-STREAM.

ÿwriteþ is the general entry point to the Lisp printer.  For each
explicitly supplied keyword parameter named in the next figure, the
corresponding printer control variable is dynamically bound to its value
while printing goes on; for each keyword parameter in the next
figure that is not explicitly supplied, the value of the corresponding
printer control variable is the same as it was at the time ÿwriteþ was
invoked.  Once the appropriate bindings are established, the object is
output by the Lisp printer.

Parameter         Corresponding Dynamic
                  Variable
---------------------------------------------- 
ARRAY             ÿ*print-array*þ
BASE              ÿ*print-base*þ
CASE              ÿ*print-case*þ
CIRCLE            ÿ*print-circle*þ
ESCAPE            ÿ*print-escape*þ
GENSYM            ÿ*print-gensym*þ
LENGTH            ÿ*print-length*þ
LEVEL             ÿ*print-level*þ
LINES             ÿ*print-lines*þ
MISER-WIDTH       ÿ*print-miser-width*þ
PPRINT-DISPATCH   ÿ*print-pprint-dispatch*þ
PRETTY            ÿ*print-pretty*þ
RADIX             ÿ*print-radix*þ
READABLY          ÿ*print-readably*þ
RIGHT-MARGIN      ÿ*print-right-margin*þ

Figure 22.7: Argument correspondences for the WRITE function.

ÿprin1þ, ÿprincþ, ÿprintþ, and ÿpprintþ implicitly bind certain print
parameters to particular values.  The remaining parameter values are
taken from ÿ*print-array*þ, ÿ*print-base*þ, ÿ*print-case*þ,
ÿ*print-circle*þ, ÿ*print-escape*þ, ÿ*print-gensym*þ, ÿ*print-length*þ,
ÿ*print-level*þ, ÿ*print-lines*þ, ÿ*print-miser-width*þ,
ÿ*print-pprint-dispatch*þ, ÿ*print-pretty*þ, ÿ*print-radix*þ, and
ÿ*print-right-margin*þ.

ÿprin1þ produces output suitable for input to ÿreadþ.  It binds
ÿ*print-escape*þ to true.

ÿprincþ is just like ÿprin1þ except that the output has no escape
characters.  It binds ÿ*print-escape*þ   to false and
ÿ*print-readably*þ to false.  The general rule is that output from
ÿprincþ is intended to look good to people, while output from ÿprin1þ
is intended to be acceptable to ÿreadþ.

ÿprintþ is just like ÿprin1þ except that the printed representation of
OBJECT is preceded by a newline and followed by a space.

ÿpprintþ is just like ÿprintþ except that the trailing space is omitted
and OBJECT is printed with the ÿ*print-pretty*þ flag non-nil to produce
pretty output.

OUTPUT-STREAM specifies the stream to which output is to be sent.

Affected By:
............

ÿ*standard-output*þ, ÿ*terminal-io*þ, ÿ*print-escape*þ, ÿ*print-radix*þ,
ÿ*print-base*þ, ÿ*print-circle*þ, ÿ*print-pretty*þ, ÿ*print-level*þ,
ÿ*print-length*þ, ÿ*print-case*þ, ÿ*print-gensym*þ, ÿ*print-array*þ,
ÿ*read-default-float-format*þ.

See Also:
.........

*Note readtable-case::, *Note Section 22.3.4 (FORMAT Printer
Operations): FORMAT Printer Operations.

Notes:
......

The functions ÿprin1þ and ÿprintþ do not bind ÿ*print-readably*þ.

 (prin1 object output-stream)
Õ (write object :stream output-stream :escape t)

 (princ object output-stream)
Õ (write object stream output-stream :escape nil :readably nil)

 (print object output-stream)
Õ (progn (terpri output-stream)
           (write object :stream output-stream
                         :escape t)
           (write-char #\space output-stream))

 (pprint object output-stream)
Õ (write object :stream output-stream :escape t :pretty t)


File: chris-ansicl.info,  Node: write-to-string; prin1-to-string; princ-to-string,  Next: *print-array*,  Prev: write; prin1; print; pprint; princ,  Up: Printer

write-to-string, prin1-to-string, princ-to-string (Function)
============================================================

Syntax:
.......

 -- Function: write-to-string object &key array base case circle escape
          gensym
          length level lines miser-width pprint-dispatch
          pretty radix readably right-margin
          ý string

 -- Function: prin1-to-string object ý string

 -- Function: princ-to-string object ý string

Arguments and Values:
.....................

OBJECT--an object.

ARRAY--a generalized boolean.

BASE--a radix.

CASE--a symbol of type ÿ(member :upcase :downcase :capitalize)þ.

CIRCLE--a generalized boolean.

ESCAPE--a generalized boolean.

GENSYM--a generalized boolean.

LENGTH--a non-negative integer, or ÿnilþ.

LEVEL--a non-negative integer, or ÿnilþ.

LINES--a non-negative integer, or ÿnilþ.

MISER-WIDTH--a non-negative integer, or ÿnilþ.

PPRINT-DISPATCH--a pprint dispatch table.

PRETTY--a generalized boolean.

RADIX--a generalized boolean.

READABLY--a generalized boolean.

RIGHT-MARGIN--a non-negative integer, or ÿnilþ.

STRING--a string.

Description:
............

ÿwrite-to-stringþ, ÿprin1-to-stringþ, and ÿprinc-to-stringþ are used to
create a string consisting of the printed representation of OBJECT.
OBJECT is effectively printed as if by ÿwriteþ, ÿprin1þ, or ÿprincþ,
respectively, and the characters that would be output are made into a
string.

ÿwrite-to-stringþ is the general output function.  It has the ability
to specify all the parameters applicable to the printing of OBJECT.

ÿprin1-to-stringþ acts like ÿwrite-to-stringþ with ÿ:escape tþ, that
is, escape characters are written where appropriate.

ÿprinc-to-stringþ acts like ÿwrite-to-stringþ with ÿ:escape nil
:readably nilþ.  Thus no escape characters are written.

All other keywords that would be specified to ÿwrite-to-stringþ are
default values when ÿprin1-to-stringþ or ÿprinc-to-stringþ is invoked.

The meanings and defaults for the keyword arguments to ÿwrite-to-stringþ
are the same as those for ÿwriteþ.

Examples:
.........

 (prin1-to-string "abc") ý "\"abc\""
 (princ-to-string "abc") ý "abc"

Affected By:
............

ÿ*print-escape*þ, ÿ*print-radix*þ, ÿ*print-base*þ, ÿ*print-circle*þ,
ÿ*print-pretty*þ, ÿ*print-level*þ, ÿ*print-length*þ, ÿ*print-case*þ,
ÿ*print-gensym*þ, ÿ*print-array*þ, ÿ*read-default-float-format*þ.

See Also:
.........

*Note write::

Notes:
......

 (write-to-string OBJECT {KEY ARGUMENT}*)
Õ (with-output-to-string (#1=#:string-stream)
     (write object :stream #1# {KEY ARGUMENT}*))

 (princ-to-string OBJECT)
Õ (with-output-to-string (string-stream)
     (princ OBJECT string-stream))

 (prin1-to-string OBJECT)
Õ (with-output-to-string (string-stream)
     (prin1 OBJECT string-stream))


File: chris-ansicl.info,  Node: *print-array*,  Next: *print-base*; *print-radix*,  Prev: write-to-string; prin1-to-string; princ-to-string,  Up: Printer

*print-array* (Variable)
========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

implementation-dependent.

Description:
............

Controls the format in which arrays are printed.  If it is false, the
contents of arrays other than strings are never printed.  Instead,
arrays are printed in a concise form using ÿ#<þ that gives enough
information for the user to be able to identify the array, but does not
include the entire array contents.  If it is true, non-string arrays
are printed using ÿ#(...)þ, ÿ#*þ, or ÿ#nAþ syntax.

Affected By:
............

The implementation.

See Also:
.........

*Note Section 2.4.8.3 (Sharpsign Left-Parenthesis): SharpsignLeftParen,
*Note Section 2.4.8.20 (Sharpsign Less-Than-Sign): SharpsignLeftAngle.


File: chris-ansicl.info,  Node: *print-base*; *print-radix*,  Next: *print-case*,  Prev: *print-array*,  Up: Printer

*print-base*, *print-radix* (Variable)
======================================

Value Type:
...........

ÿ*print-base*þ--a radix.  ÿ*print-radix*þ--a generalized boolean.

Initial Value:
..............

The initial value of ÿ*print-base*þ is ÿ10þ.  The initial value of
ÿ*print-radix*þ is false.

Description:
............

ÿ*print-base*þ and ÿ*print-radix*þ control the printing of rationals.
The value of ÿ*print-base*þ is called the "current output base".

The value of ÿ*print-base*þ is the radix in which the printer will
print rationals.   For radices above ÿ10þ, letters of the alphabet are
used to represent digits above ÿ9þ.

If the value of ÿ*print-radix*þ is true, the printer will print a radix
specifier to indicate the radix in which it is printing a rational
number.  The radix specifier is always printed using lowercase letters.
If ÿ*print-base*þ is ÿ2þ, ÿ8þ, or ÿ16þ, then the radix specifier used
is ÿ#bþ, ÿ#oþ, or ÿ#xþ, respectively.  For integers, base ten is
indicated by a trailing decimal point instead of a leading radix
specifier; for ratios, ÿ#10rþ is used.

Examples:
.........

 (let ((*print-base* 24.) (*print-radix* t))
   (print 23.))
Ö #24rN
ý 23
 (setq *print-base* 10) ý 10
 (setq *print-radix* nil) ý NIL
 (dotimes (i 35)
    (let ((*print-base* (+ i 2)))           ;print the decimal number 40
      (write 40)                            ;in each base from 2 to 36
      (if (zerop (mod i 10)) (terpri) (format t " "))))
Ö 101000
Ö 1111 220 130 104 55 50 44 40 37 34
Ö 31 2C 2A 28 26 24 22 20 1J 1I
Ö 1H 1G 1F 1E 1D 1C 1B 1A 19 18
Ö 17 16 15 14
ý NIL
 (dolist (pb '(2 3 8 10 16))
    (let ((*print-radix* t)                 ;print the integer 10 and
          (*print-base* pb))                ;the ratio 1/10 in bases 2,
     (format t "~&~S  ~S~%" 10 1/10)))        ;3, 8, 10, 16
Ö #b1010  #b1/1010
Ö #3r101  #3r1/101
Ö #o12  #o1/12
Ö 10.  #10r1/10
Ö #xA  #x1/A
ý NIL

Affected By:
............

Might be bound by ÿformatþ, and ÿwriteþ, ÿwrite-to-stringþ.

See Also:
.........

*Note format::, *Note write::, *Note write-to-string::


File: chris-ansicl.info,  Node: *print-case*,  Next: *print-circle*,  Prev: *print-base*; *print-radix*,  Up: Printer

*print-case* (Variable)
=======================

Value Type:
...........

One of the symbols :upcase, :downcase, or :capitalize.

Initial Value:
..............

The symbol :upcase.

Description:
............

The value of ÿ*print-case*þ controls the case (upper, lower, or mixed)
in which to print any uppercase characters in the names of symbols when
vertical-bar syntax is not used.

ÿ*print-case*þ has an effect at all times when the value of
ÿ*print-escape*þ is false. ÿ*print-case*þ also has an effect when the
value of ÿ*print-escape*þ is true unless inside an escape context
(i.e., unless between vertical-bars or after a slash).

Examples:
.........

 (defun test-print-case ()
   (dolist (*print-case* '(:upcase :downcase :capitalize))
     (format t "~&~S ~S~%" 'this-and-that '|And-something-elSE|)))
ý TEST-PC
;; Although the choice of which characters to escape is specified by
;; *PRINT-CASE*, the choice of how to escape those characters
;; (i.e., whether single escapes or multiple escapes are used)
;; is implementation-dependent.  The examples here show two of the
;; many valid ways in which escaping might appear.
 (test-print-case) ;Implementation A
Ö THIS-AND-THAT |And-something-elSE|
Ö this-and-that a\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
Ö This-And-That A\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
ý NIL
 (test-print-case) ;Implementation B
Ö THIS-AND-THAT |And-something-elSE|
Ö this-and-that a|nd-something-el|se
Ö This-And-That A|nd-something-el|se
ý NIL

See Also:
.........

*Note write::

Notes:
......

ÿreadþ normally converts lowercase characters appearing in symbols to
corresponding uppercase characters, so that internally print names
normally contain only uppercase characters.

If ÿ*print-escape*þ is true, lowercase characters in the name of a
symbol are always printed in lowercase, and are preceded by a single
escape character or enclosed by multiple escape characters; uppercase
characters in the name of a symbol are printed in upper case, in lower
case, or in mixed case so as to capitalize words, according to the
value of ÿ*print-case*þ.  The convention for what constitutes a "word"
is the same as for ÿstring-capitalizeþ.


File: chris-ansicl.info,  Node: *print-circle*,  Next: *print-escape*,  Prev: *print-case*,  Up: Printer

*print-circle* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

false.

Description:
............

Controls the attempt to detect circularity and sharing in an object
being printed.

If false, the printing process merely proceeds by recursive descent
without attempting to detect circularity and sharing.

If true, the printer will endeavor to detect cycles and sharing in the
structure to be printed, and to use ÿ#n=þ and ÿ#n#þ syntax to indicate
the circularities or shared components.

If true, a user-defined ÿprint-objectþ method can print objects to the
supplied stream using ÿwriteþ, ÿprin1þ, ÿprincþ, or ÿformatþ and expect
circularities and sharing to be detected and printed using the ÿ#n#þ
syntax.  If a user-defined ÿprint-objectþ method prints to a stream
other than the one that was supplied, then circularity detection starts
over for that stream.

Note that implementations should not use ÿ#n#þ notation when the Lisp
reader would automatically assure sharing without it (e.g., as happens
with interned symbols).

Examples:
.........

 (let ((a (list 1 2 3)))
   (setf (cdddr a) a)
   (let ((*print-circle* t))
     (write a)
     :done))
Ö #1=(1 2 3 . #1#)
ý :DONE

See Also:
.........

*Note write::

Notes:
......

An attempt to print a circular structure with ÿ*print-circle*þ set to
ÿnilþ may lead to looping behavior and failure to terminate.


File: chris-ansicl.info,  Node: *print-escape*,  Next: *print-gensym*,  Prev: *print-circle*,  Up: Printer

*print-escape* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

true.

Description:
............

If false, escape characters and package prefixes are not output when an
expression is printed.

If true, an attempt is made to print an expression in such a way that
it can be read again to produce an ÿequalþ expression.  (This is only a
guideline; not a requirement.  See ÿ*print-readably*þ.)

For more specific details of how the value of ÿ*print-escape*þ affects
the printing of certain types, see *Note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods.

Examples:
.........

 (let ((*print-escape* t)) (write #\a))
Ö #\a
ý #\a
 (let ((*print-escape* nil)) (write #\a))
Ö a
ý #\a

Affected By:
............

ÿprincþ, ÿprin1þ, ÿformatþ

See Also:
.........

*Note write::, *Note readtable-case::

Notes:
......

ÿprincþ effectively binds ÿ*print-escape*þ to false.  ÿprin1þ
effectively binds ÿ*print-escape*þ to true.


File: chris-ansicl.info,  Node: *print-gensym*,  Next: *print-level*; *print-length*,  Prev: *print-escape*,  Up: Printer

*print-gensym* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

true.

Description:
............

Controls whether the prefix "ÿ#:þ" is printed before apparently
uninterned symbols.  The prefix is printed before such symbols if and
only if the value of ÿ*print-gensym*þ is true.

Examples:
.........

 (let ((*print-gensym* nil))
   (print (gensym)))
Ö G6040
ý #:G6040

See Also:
.........

*Note write::, *Note *print-escape*::


File: chris-ansicl.info,  Node: *print-level*; *print-length*,  Next: *print-lines*,  Prev: *print-gensym*,  Up: Printer

*print-level*, *print-length* (Variable)
========================================

Value Type:
...........

a non-negative integer, or ÿnilþ.

Initial Value:
..............

ÿnilþ.

Description:
............

ÿ*print-level*þ controls how many levels deep a nested object will
print.  If it is false, then no control is exercised.  Otherwise, it is
an integer indicating the maximum level to be printed.  An object to be
printed is at level ÿ0þ; its components (as of a list or vector) are at
level ÿ1þ; and so on.  If an object to be recursively printed has
components and is at a level equal to or greater than the value of
ÿ*print-level*þ, then the object is printed as "ÿ#þ".

ÿ*print-length*þ controls how many elements at a given level are
printed.  If it is false, there is no limit to the number of components
printed.  Otherwise, it is an integer indicating the maximum number of
elements of an object to be printed.  If exceeded, the printer will
print "ÿ...þ" in place of the other elements.  In the case of a dotted
list, if the list contains exactly as many elements as the value of
ÿ*print-length*þ, the terminating atom is printed rather than printing
"ÿ...þ"

ÿ*print-level*þ and ÿ*print-length*þ affect the printing of an any
object printed with a list-like syntax.  They do not affect the
printing of symbols, strings, and bit vectors.

Examples:
.........

 (setq a '(1 (2 (3 (4 (5 (6))))))) ý (1 (2 (3 (4 (5 (6))))))
 (dotimes (i 8)
   (let ((*print-level* i))
     (format t "~&~D -- ~S~%" i a)))
Ö 0 -- #
Ö 1 -- (1 #)
Ö 2 -- (1 (2 #))
Ö 3 -- (1 (2 (3 #)))
Ö 4 -- (1 (2 (3 (4 #))))
Ö 5 -- (1 (2 (3 (4 (5 #)))))
Ö 6 -- (1 (2 (3 (4 (5 (6))))))
Ö 7 -- (1 (2 (3 (4 (5 (6))))))
ý NIL


 (setq a '(1 2 3 4 5 6)) ý (1 2 3 4 5 6)
 (dotimes (i 7)
   (let ((*print-length* i))
     (format t "~&~D -- ~S~%" i a)))
Ö 0 -- (...)
Ö 1 -- (1 ...)
Ö 2 -- (1 2 ...)
Ö 3 -- (1 2 3 ...)
Ö 4 -- (1 2 3 4 ...)
Ö 5 -- (1 2 3 4 5 6)
Ö 6 -- (1 2 3 4 5 6)
ý NIL


(dolist (level-length '((0 1) (1 1) (1 2) (1 3) (1 4)
                        (2 1) (2 2) (2 3) (3 2) (3 3) (3 4)))
 (let ((*print-level*  (first  level-length))
       (*print-length* (second level-length)))
   (format t "~&~D ~D -- ~S~%"
           *print-level* *print-length*
           '(if (member x y) (+ (car x) 3) '(foo . #(a b c d "Baz"))))))
Ö 0 1 -- #
Ö 1 1 -- (IF ...)
Ö 1 2 -- (IF # ...)
Ö 1 3 -- (IF # # ...)
Ö 1 4 -- (IF # # #)
Ö 2 1 -- (IF ...)
Ö 2 2 -- (IF (MEMBER X ...) ...)
Ö 2 3 -- (IF (MEMBER X Y) (+ # 3) ...)
Ö 3 2 -- (IF (MEMBER X ...) ...)
Ö 3 3 -- (IF (MEMBER X Y) (+ (CAR X) 3) ...)
Ö 3 4 -- (IF (MEMBER X Y) (+ (CAR X) 3) '(FOO . #(A B C D ...)))
ý NIL

See Also:
.........

*Note write::


File: chris-ansicl.info,  Node: *print-lines*,  Next: *print-miser-width*,  Prev: *print-level*; *print-length*,  Up: Printer

*print-lines* (Variable)
========================

Value Type:
...........

a non-negative integer, or ÿnilþ.

Initial Value:
..............

ÿnilþ.

Description:
............

When the value of ÿ*print-lines*þ is other than ÿnilþ, it is a limit on
the number of output lines produced when something is pretty printed.
If an attempt is made to go beyond that many lines, "ÿ..þ" is printed
at the end of the last line followed by all of the suffixes (closing
delimiters) that are pending to be printed.

Examples:
.........

 (let ((*print-right-margin* 25) (*print-lines* 3))
   (pprint '(progn (setq a 1 b 2 c 3 d 4))))
Ö (PROGN (SETQ A 1
Ö              B 2
Ö              C 3 ..))
ý <no values>

Notes:
......

The "ÿ..þ" notation is intentionally different than the "ÿ...þ"
notation used for level abbreviation, so that the two different
situations can be visually distinguished.

This notation is used to increase the likelihood that the Lisp reader
will signal an error if an attempt is later made to read the
abbreviated output.  Note however that if the truncation occurs in a
string, as in ÿ"This string has been trunc.."þ, the problem situation
cannot be detected later and no such error will be signaled.


File: chris-ansicl.info,  Node: *print-miser-width*,  Next: *print-pprint-dispatch*,  Prev: *print-lines*,  Up: Printer

*print-miser-width* (Variable)
==============================

Value Type:
...........

a non-negative integer, or ÿnilþ.

Initial Value:
..............

implementation-dependent

Description:
............

If it is not ÿnilþ, the pretty printer switches to a compact style of
output (called miser style) whenever the width available for printing a
substructure is less than or equal to this many ems.


File: chris-ansicl.info,  Node: *print-pprint-dispatch*,  Next: *print-pretty*,  Prev: *print-miser-width*,  Up: Printer

*print-pprint-dispatch* (Variable)
==================================

Value Type:
...........

a pprint dispatch table.

Initial Value:
..............

implementation-dependent, but the initial entries all use a special
class of priorities that have the property that they are less than
every priority that can be specified using ÿset-pprint-dispatchþ, so
that the initial contents of any entry can be overridden.

Description:
............

The pprint dispatch table which currently controls the pretty printer.

See Also:
.........

*Note *print-pretty*::, *Note Section 22.2.1.4 (Pretty Print Dispatch
Tables): PPrintDispatchTables.

Notes:
......

The intent is that the initial value of this variable should cause
`traditional' pretty printing of code.  In general, however, you can
put a value in ÿ*print-pprint-dispatch*þ that makes pretty-printed
output look exactly like non-pretty-printed output.  Setting
ÿ*print-pretty*þ to true just causes the functions contained in the
current pprint dispatch table to have priority over normal
ÿprint-objectþ methods; it has no magic way of enforcing that those
functions actually produce pretty output.  For details, see *Note
Section 22.2.1.4 (Pretty Print Dispatch Tables): PPrintDispatchTables.


File: chris-ansicl.info,  Node: *print-pretty*,  Next: *print-readably*,  Prev: *print-pprint-dispatch*,  Up: Printer

*print-pretty* (Variable)
=========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

implementation-dependent.

Description:
............

Controls whether the Lisp printer calls the pretty printer.

If it is false, the pretty printer is not used and a minimum of
whitespaceá is output when printing an expression.

If it is true, the pretty printer is used, and the Lisp printer will
endeavor to insert extra whitespaceá where appropriate to make
expressions more readable.

ÿ*print-pretty*þ has an effect even when the value of ÿ*print-escape*þ
is false.

Examples:
.........

 (setq *print-pretty* 'nil) ý NIL
 (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil)
Ö (LET ((A 1) (B 2) (C 3)) (+ A B C))
ý NIL
 (let ((*print-pretty* t))
   (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil))
Ö (LET ((A 1)
Ö       (B 2)
Ö       (C 3))
Ö   (+ A B C))
ý NIL
;; Note that the first two expressions printed by this next form
;; differ from the second two only in whether escape characters are printed.
;; In all four cases, extra whitespace is inserted by the pretty printer.
 (flet ((test (x)
          (let ((*print-pretty* t))
            (print x)
            (format t "~%~S " x)
            (terpri) (princ x) (princ " ")
            (format t "~%~A " x))))
  (test '#'(lambda () (list "a" #\b 'c #'d))))
Ö #'(LAMBDA ()
Ö     (LIST "a" #\b 'C #'D))
Ö #'(LAMBDA ()
Ö     (LIST "a" #\b 'C #'D))
Ö #'(LAMBDA ()
Ö     (LIST a b 'C #'D))
Ö #'(LAMBDA ()
Ö     (LIST a b 'C #'D))
ý NIL

See Also:
.........

*Note write::


File: chris-ansicl.info,  Node: *print-readably*,  Next: *print-right-margin*,  Prev: *print-pretty*,  Up: Printer

*print-readably* (Variable)
===========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

false.

Description:
............

If ÿ*print-readably*þ is true, some special rules for printing objects
go into effect.  Specifically, printing any object Oá produces a printed
representation that, when seen by the Lisp reader while the standard
readtable is in effect, will produce an object Oà that is similar to Oá.
The printed representation produced might or might not be the same as
the printed representation produced when ÿ*print-readably*þ is false.
If printing an object readably is not possible, an error of type
ÿprint-not-readableþ is signaled rather than using a syntax (e.g., the
"ÿ#<þ" syntax) that would not be readable by the same implementation.
If the value of some other printer control variable is such that these
requirements would be violated, the value of that other variable is
ignored.

Specifically, if ÿ*print-readably*þ is true, printing proceeds as if
ÿ*print-escape*þ, ÿ*print-array*þ, and ÿ*print-gensym*þ were also true,
and as if ÿ*print-length*þ, ÿ*print-level*þ, and ÿ*print-lines*þ were
false.

If ÿ*print-readably*þ is false, the normal rules for printing and the
normal interpretations of other printer control variables are in effect.

Individual methods for ÿprint-objectþ, including user-defined methods,
are responsible for implementing these requirements.

If ÿ*read-eval*þ is false and ÿ*print-readably*þ is true, any such
method that would output a reference to the "ÿ#.þ" reader macro will
either output something else or will signal an error (as described
above).

Examples:
.........

 (let ((x (list "a" '\a (gensym) '((a (b (c))) d e f g)))
       (*print-escape* nil)
       (*print-gensym* nil)
       (*print-level* 3)
       (*print-length* 3))
   (write x)
   (let ((*print-readably* t))
     (terpri)
     (write x)
     :done))
Ö (a a G4581 ((A #) D E ...))
Ö ("a" |a| #:G4581 ((A (B (C))) D E F G))
ý :DONE

;; This is setup code is shared between the examples
;; of three hypothetical implementations which follow.
 (setq table (make-hash-table)) ý #<HASH-TABLE EQL 0/120 32005763>
 (setf (gethash table 1) 'one) ý ONE
 (setf (gethash table 2) 'two) ý TWO

;; Implementation A
 (let ((*print-readably* t)) (print table))
 Error: Can't print #<HASH-TABLE EQL 0/120 32005763> readably.

;; Implementation B
;; No standardized #S notation for hash tables is defined,
;; but there might be an implementation-defined notation.
 (let ((*print-readably* t)) (print table))
Ö #S(HASH-TABLE :TEST EQL :SIZE 120 :CONTENTS (1 ONE 2 TWO))
ý #<HASH-TABLE EQL 0/120 32005763>

;; Implementation C
;; Note that #. notation can only be used if *READ-EVAL* is true.
;; If *READ-EVAL* were false, this same implementation might have to
;; signal an error unless it had yet another printing strategy to fall
;; back on.
 (let ((*print-readably* t)) (print table))
Ö #.(LET ((HASH-TABLE (MAKE-HASH-TABLE)))
Ö     (SETF (GETHASH 1 HASH-TABLE) ONE)
Ö     (SETF (GETHASH 2 HASH-TABLE) TWO)
Ö     HASH-TABLE)
ý #<HASH-TABLE EQL 0/120 32005763>

See Also:
.........

*Note write::, *Note print-unreadable-object::

Notes:
......

The rules for "similarity" imply that ÿ#Aþ or ÿ#(þ syntax cannot be
used for arrays of element type other than ÿtþ.  An implementation will
have to use another syntax or signal an error of type
ÿprint-not-readableþ.


File: chris-ansicl.info,  Node: *print-right-margin*,  Next: print-not-readable,  Prev: *print-readably*,  Up: Printer

*print-right-margin* (Variable)
===============================

Value Type:
...........

a non-negative integer, or ÿnilþ.

Initial Value:
..............

ÿnilþ.

Description:
............

If it is non-nil, it specifies the right margin (as integer number of
ems) to use when the pretty printer is making layout decisions.

If it is ÿnilþ, the right margin is taken to be the maximum line length
such that output can be displayed without wraparound or truncation.  If
this cannot be determined, an implementation-dependent value is used.

Notes:
......

This measure is in units of ems in order to be compatible with
implementation-defined variable-width fonts while still not requiring
the language to provide support for fonts.


File: chris-ansicl.info,  Node: print-not-readable,  Next: print-not-readable-object,  Prev: *print-right-margin*,  Up: Printer

print-not-readable (Condition Type)
===================================

Class Precedence List:
......................

ÿprint-not-readableþ, ÿerrorþ, ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿprint-not-readableþ consists of error conditions that occur
during output while ÿ*print-readably*þ is true, as a result of
attempting to write a printed representation with the Lisp printer that
would not be correctly read back with the Lisp reader.  The object
which could not be printed is initialized by the :object initialization
argument to ÿmake-conditionþ, and is accessed by the function
ÿprint-not-readable-objectþ.

See Also:
.........

*Note print-not-readable-object::


File: chris-ansicl.info,  Node: print-not-readable-object,  Next: format,  Prev: print-not-readable,  Up: Printer

print-not-readable-object (Function)
====================================

Syntax:
.......

 -- Function: print-not-readable-object condition ý object

Arguments and Values:
.....................

CONDITION--a condition of type ÿprint-not-readableþ.

OBJECT--an object.

Description:
............

Returns the object that could not be printed readably in the situation
represented by CONDITION.

See Also:
.........

*Note print-not-readable::, *Note Chapter 9 (Conditions): Conditions.


File: chris-ansicl.info,  Node: format,  Prev: print-not-readable-object,  Up: Printer

format (Function)
=================

Syntax:
.......

 -- Function: format destination control-string &rest args ý result

Arguments and Values:
.....................

DESTINATION--ÿnilþ, ÿtþ, a stream, or a string with a fill pointer.

CONTROL-STRING--a format control.

ARGS--format arguments for CONTROL-STRING.

RESULT--if DESTINATION is non-nil, then ÿnilþ; otherwise, a string.

Description:
............

ÿformatþ produces formatted output by outputting the characters of
CONTROL-STRING and observing that a tilde introduces a directive.  The
character after the tilde, possibly preceded by prefix parameters and
modifiers, specifies what kind of formatting is desired.  Most
directives use one or more elements of ARGS to create their output.

If DESTINATION is a string, a stream, or ÿtþ, then the RESULT is ÿnilþ.
Otherwise, the RESULT is a string containing the `output.'

ÿformatþ is useful for producing nicely formatted text, producing
good-looking messages, and so on.  ÿformatþ can generate and return a
string or output to DESTINATION.

For details on how the CONTROL-STRING is interpreted, see *Note Section
22.3 (Formatted Output): Formatted Output.

Affected By:
............

ÿ*standard-output*þ, ÿ*print-escape*þ, ÿ*print-radix*þ, ÿ*print-base*þ,
ÿ*print-circle*þ, ÿ*print-pretty*þ, ÿ*print-level*þ, ÿ*print-length*þ,
ÿ*print-case*þ, ÿ*print-gensym*þ, ÿ*print-array*þ.

Exceptional Situations:
.......................

If DESTINATION is a string with a fill pointer, the consequences are
undefined if destructive modifications are performed directly on the
string during the dynamic extent of the call.

See Also:
.........

*Note write::, *Note Section 13.1.10 (Documentation of
Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.


File: chris-ansicl.info,  Node: Reader,  Next: System Construction,  Prev: Printer,  Up: Top

23 Reader
*********

* Menu:

* Reader Concepts::

Dictionary

* readtable::
* copy-readtable::
* make-dispatch-macro-character::
* read; read-preserving-whitespace::
* read-delimited-list::
* read-from-string::
* readtable-case::
* readtablep::
* set-dispatch-macro-character; get-dispatch-macro-character::
* set-macro-character; get-macro-character::
* set-syntax-from-char::
* with-standard-io-syntax::
* *read-base*::
* *read-default-float-format*::
* *read-eval*::
* *read-suppress*::
* *readtable*::
* reader-error::


File: chris-ansicl.info,  Node: Reader Concepts,  Next: readtable,  Up: Reader

23.1 Reader Concepts
====================

* Menu:

* Dynamic Control of the Lisp Reader::
* Effect of Readtable Case on the Lisp Reader::
* Argument Conventions of Some Reader Functions::


File: chris-ansicl.info,  Node: Dynamic Control of the Lisp Reader,  Next: Effect of Readtable Case on the Lisp Reader,  Up: Reader Concepts

23.1.1 Dynamic Control of the Lisp Reader
-----------------------------------------

Various aspects of the Lisp reader can be controlled dynamically.  See
*Note Section 2.1.1 (Readtables): Readtables. and *Note Section 2.1.2
(Variables that affect the Lisp Reader): Variables that affect the Lisp
Reader.


File: chris-ansicl.info,  Node: Effect of Readtable Case on the Lisp Reader,  Next: Argument Conventions of Some Reader Functions,  Prev: Dynamic Control of the Lisp Reader,  Up: Reader Concepts

23.1.2 Effect of Readtable Case on the Lisp Reader
--------------------------------------------------

The readtable case of the current readtable affects the Lisp reader in
the following ways:

:upcase
     When the readtable case is :upcase, unescaped constituent
     characters are converted to uppercase, as specified in *Note
     Section 2.2 (Reader Algorithm): Reader Algorithm.

:downcase
     When the readtable case is :downcase, unescaped constituent
     characters are converted to lowercase.

:preserve
     When the readtable case is :preserve, the case of all characters
     remains unchanged.

:invert
     When the readtable case is :invert, then if all of the unescaped
     letters in the extended token are of the same case, those
     (unescaped) letters are converted to the opposite case.

23.1.2.1 Examples of Effect of Readtable Case on the Lisp Reader
................................................................

 (defun test-readtable-case-reading ()
   (let ((*readtable* (copy-readtable nil)))
     (format t "READTABLE-CASE  Input   Symbol-name~
              ~%-----------------------------------~
              ~%")
     (dolist (readtable-case '(:upcase :downcase :preserve :invert))
       (setf (readtable-case *readtable*) readtable-case)
       (dolist (input '("ZEBRA" "Zebra" "zebra"))
         (format t "~&:~A~16T~A~24T~A"
                 (string-upcase readtable-case)
                 input
                 (symbol-name (read-from-string input)))))))

The output from ÿ(test-readtable-case-reading)þ should be as follows:

 READTABLE-CASE     Input Symbol-name
 -------------------------------------
    :UPCASE         ZEBRA   ZEBRA
    :UPCASE         Zebra   ZEBRA
    :UPCASE         zebra   ZEBRA
    :DOWNCASE       ZEBRA   zebra
    :DOWNCASE       Zebra   zebra
    :DOWNCASE       zebra   zebra
    :PRESERVE       ZEBRA   ZEBRA
    :PRESERVE       Zebra   Zebra
    :PRESERVE       zebra   zebra
    :INVERT         ZEBRA   zebra
    :INVERT         Zebra   Zebra
    :INVERT         zebra   ZEBRA


File: chris-ansicl.info,  Node: Argument Conventions of Some Reader Functions,  Prev: Effect of Readtable Case on the Lisp Reader,  Up: Reader Concepts

23.1.3 Argument Conventions of Some Reader Functions
----------------------------------------------------

23.1.3.1 The EOF-ERROR-P argument
.................................

EOF-ERROR-P in input function calls controls what happens if input is
from a file (or any other input source that has a definite end) and the
end of the file is reached.  If EOF-ERROR-P is true (the default), an
error of type ÿend-of-fileþ is signaled at end of file.  If it is
false, then no error is signaled, and instead the function returns
EOF-VALUE.

Functions such as ÿreadþ that read the representation of an object
rather than a single character always signals an error, regardless of
EOF-ERROR-P, if the file ends in the middle of an object representation.
For example, if a file does not contain enough right parentheses to
balance the left parentheses in it, ÿreadþ signals an error.  If a file
ends in a symbol or a number immediately followed by end-of-file,
ÿreadþ reads the symbol or number successfully and when called again
will act according to EOF-ERROR-P.  Similarly, the function ÿread-lineþ
successfully reads the last line of a file even if that line is
terminated by end-of-file rather than the newline character.  Ignorable
text, such as lines containing only whitespaceà or comments, are not
considered to begin an object; if ÿreadþ begins to read an expression
but sees only such ignorable text, it does not consider the file to end
in the middle of an object.  Thus an EOF-ERROR-P argument controls what
happens when the file ends between objects.

23.1.3.2 The RECURSIVE-P argument
.................................

If RECURSIVE-P is supplied and not ÿnilþ, it specifies that this
function call is not an outermost call to ÿreadþ but an embedded call,
typically from a reader macro function.  It is important to distinguish
such recursive calls for three reasons.

  1. An outermost call establishes the context within which the ÿ#N=þ
     and ÿ#N#þ syntax is scoped.  Consider, for example, the expression

      (cons '#3=(p q r) '(x y . #3#))

     If the single-quote reader macro were defined in this way:

      (set-macro-character #\'       ;incorrect
         #'(lambda (stream char)
              (declare (ignore char))
              (list 'quote (read stream))))

     then each call to the single-quote reader macro function would
     establish independent contexts for the scope of ÿreadþ
     information, including the scope of identifications between
     markers like "ÿ#3=þ" and "ÿ#3#þ".  However, for this expression,
     the scope was clearly intended to be determined by the outer set
     of parentheses, so such a definition would be incorrect.  The
     correct way to define the single-quote reader macro uses
     RECURSIVE-P:

      (set-macro-character #\'       ;correct
         #'(lambda (stream char)
              (declare (ignore char))
              (list 'quote (read stream t nil t))))

  2. A recursive call does not alter whether the reading process is to
     preserve whitespaceà or not (as determined by whether the
     outermost call was to ÿreadþ or ÿread-preserving-whitespaceþ).
     Suppose again that single-quote were to be defined as shown above
     in the incorrect definition.  Then a call to
     ÿread-preserving-whitespaceþ that read the expression
     ÿ'foo<Space>þ would fail to preserve the space character following
     the symbol ÿfooþ because the single-quote reader macro function
     calls ÿreadþ, not ÿread-preserving-whitespaceþ, to read the
     following expression (in this case ÿfooþ).  The correct
     definition, which passes the value true for RECURSIVE-P to ÿreadþ,
     allows the outermost call to determine whether whitespaceà is
     preserved.

  3. When end-of-file is encountered and the EOF-ERROR-P argument is
     not ÿnilþ, the kind of error that is signaled may depend on the
     value of RECURSIVE-P.  If RECURSIVE-P is true, then the end-of-file
     is deemed to have occurred within the middle of a printed
     representation; if RECURSIVE-P is false, then the end-of-file may
     be deemed to have occurred between objects rather than within the
     middle of one.


File: chris-ansicl.info,  Node: readtable,  Next: copy-readtable,  Prev: Reader Concepts,  Up: Reader

readtable (System Class)
========================

Class Precedence List:
......................

ÿreadtableþ, ÿtþ

Description:
............

A readtable maps characters into syntax types for the Lisp reader; see
*Note Chapter 2 (Syntax): Syntax.  A readtable also contains
associations between macro characters and their reader macro functions,
and records information about the case conversion rules to be used by
the Lisp reader when parsing symbols.

Each simple character must be representable in the readtable.  It is
implementation-defined whether non-simple characters can have syntax
descriptions in the readtable.

See Also:
.........

*Note Section 2.1.1 (Readtables): Readtables, *Note Section 22.1.3.13
(Printing Other Objects): PrintingOtherObjects.


File: chris-ansicl.info,  Node: copy-readtable,  Next: make-dispatch-macro-character,  Prev: readtable,  Up: Reader

copy-readtable (Function)
=========================

Syntax:
.......

 -- Function: copy-readtable &optional from-readtable to-readtable ý
          readtable

Arguments and Values:
.....................

FROM-READTABLE--a readtable designator.  The default is the current
readtable.

TO-READTABLE--a readtable or ÿnilþ.  The default is ÿnilþ.

READTABLE--the TO-READTABLE if it is non-nil, or else a fresh readtable.

Description:
............

ÿcopy-readtableþ copies FROM-READTABLE.

If TO-READTABLE is ÿnilþ, a new readtable is created and returned.
Otherwise the readtable specified by TO-READTABLE is modified and
returned.

ÿcopy-readtableþ copies the setting of ÿreadtable-caseþ.

Examples:
.........

 (setq zvar 123) ý 123
 (set-syntax-from-char #\z #\' (setq table2 (copy-readtable))) ý T
 zvar ý 123
 (copy-readtable table2 *readtable*) ý #<READTABLE 614000277>
 zvar ý VAR
 (setq *readtable* (copy-readtable)) ý #<READTABLE 46210223>
 zvar ý VAR
 (setq *readtable* (copy-readtable nil)) ý #<READTABLE 46302670>
 zvar ý 123

See Also:
.........

*Note readtable::, *Note *readtable*::

Notes:
......

(setq *readtable* (copy-readtable nil))

restores the input syntax to standard Common Lisp syntax, even if the
initial readtable has been clobbered (assuming it is not so badly
clobbered that you cannot type in the above expression).

On the other hand,

(setq *readtable* (copy-readtable))

replaces the current readtable with a copy of itself.  This is useful
if you want to save a copy of a readtable for later use, protected from
alteration in the meantime.  It is also useful if you want to locally
bind the readtable to a copy of itself, as in:

(let ((*readtable* (copy-readtable))) ...)


File: chris-ansicl.info,  Node: make-dispatch-macro-character,  Next: read; read-preserving-whitespace,  Prev: copy-readtable,  Up: Reader

make-dispatch-macro-character (Function)
========================================

Syntax:
.......

 -- Function: make-dispatch-macro-character char &optional
          non-terminating-p readtable ý ÿtþ

Arguments and Values:
.....................

CHAR--a character.

NON-TERMINATING-P--a generalized boolean.  The default is false.

READTABLE--a readtable.  The default is the current readtable.

Description:
............

ÿmake-dispatch-macro-characterþ makes CHAR be a dispatching macro
character in READTABLE.

Initially, every character in the dispatch table associated with the
CHAR has an associated function that signals an error of type
ÿreader-errorþ.

If NON-TERMINATING-P is true, the dispatching macro character is made a
non-terminating macro character; if NON-TERMINATING-P is false, the
dispatching macro character is made a terminating macro character.

Examples:
.........

 (get-macro-character #\{) ý NIL, false
 (make-dispatch-macro-character #\{) ý T
 (not (get-macro-character #\{)) ý false

The READTABLE is altered.

See Also:
.........

*Note *readtable*::, *Note set-dispatch-macro-character::


File: chris-ansicl.info,  Node: read; read-preserving-whitespace,  Next: read-delimited-list,  Prev: make-dispatch-macro-character,  Up: Reader

read, read-preserving-whitespace (Function)
===========================================

Syntax:
.......

 -- Function: read &optional input-stream eof-error-p eof-value
          recursive-p ý object

 -- Function: read-preserving-whitespace &optional
          input-stream eof-error-p eof-value recursive-p ý object

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ÿnilþ.

RECURSIVE-P--a generalized boolean.  The default is false.

OBJECT--an object (parsed by the Lisp reader) or the EOF-VALUE.

Description:
............

ÿreadþ parses the printed representation of an object from INPUT-STREAM
and builds such an object.

ÿread-preserving-whitespaceþ is like ÿreadþ but preserves any
whitespaceà character that delimits the printed representation of the
object.  ÿread-preserving-whitespaceþ is exactly like ÿreadþ when the
RECURSIVE-P argument to ÿread-preserving-whitespaceþ is true.

When ÿ*read-suppress*þ is false, ÿreadþ throws away the delimiting
character required by certain printed representations if it is a
whitespaceà character; but ÿreadþ preserves the character (using
ÿunread-charþ) if it is syntactically meaningful, because it could be
the start of the next expression.

If a file ends in a symbol or a number immediately followed by an end
of fileá, ÿreadþ reads the symbol or number successfully; when called
again, it sees the end of fileá and only then acts according to
EOF-ERROR-P.  If a file contains ignorable text at the end, such as
blank lines and comments, ÿreadþ does not consider it to end in the
middle of an object.

If RECURSIVE-P is true, the call to ÿreadþ is expected to be made from
within some function that itself has been called from ÿreadþ or from a
similar input function, rather than from the top level.

Both functions return the object read from INPUT-STREAM.  EOF-VALUE is
returned if EOF-ERROR-P is false and end of file is reached before the
beginning of an object.

Examples:
.........

 (read)
Ö 'a
ý (QUOTE A)
 (with-input-from-string (is " ") (read is nil 'the-end)) ý THE-END
 (defun skip-then-read-char (s c n)
    (if (char= c #\{) (read s t nil t) (read-preserving-whitespace s))
    (read-char-no-hang s)) ý SKIP-THEN-READ-CHAR
 (let ((*readtable* (copy-readtable nil)))
    (set-dispatch-macro-character #\# #\{ #'skip-then-read-char)
    (set-dispatch-macro-character #\# #\} #'skip-then-read-char)
    (with-input-from-string (is "#{123 x #}123 y")
      (format t "~S ~S" (read is) (read is)))) ý #\x, #\Space, NIL

As an example, consider this reader macro definition:

 (defun slash-reader (stream char)
   (declare (ignore char))
   `(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)
                   then (progn (read-char stream t nil t)
                               (read-preserving-whitespace stream t nil t))
                   collect dir
                   while (eql (peek-char nil stream nil nil t) #\/))))
 (set-macro-character #\/ #'slash-reader)

Consider now calling ÿreadþ on this expression:

 (zyedh /usr/games/zork /usr/games/boggle)

The ÿ/þ macro reads objects separated by more ÿ/þ characters; thus
ÿ/usr/games/zorkþ is intended to read as ÿ(path usr games zork)þ.  The
entire example expression should therefore be read as

 (zyedh (path usr games zork) (path usr games boggle))

However, if ÿreadþ had been used instead of
ÿread-preserving-whitespaceþ, then after the reading of the symbol
ÿzorkþ, the following space would be discarded; the next call to
ÿpeek-charþ would see the following ÿ/þ, and the loop would continue,
producing this interpretation:

 (zyedh (path usr games zork usr games boggle))

There are times when whitespaceà should be discarded.  If a command
interpreter takes single-character commands, but occasionally reads an
object then if the whitespaceà after a symbol is not discarded it might
be interpreted as a command some time later after the symbol had been
read.

Affected By:
............

ÿ*standard-input*þ, ÿ*terminal-io*þ, ÿ*readtable*þ,
ÿ*read-default-float-format*þ, ÿ*read-base*þ, ÿ*read-suppress*þ,
ÿ*package*þ, ÿ*read-eval*þ.

Exceptional Situations:
.......................

ÿreadþ signals an error of type ÿend-of-fileþ, regardless of
EOF-ERROR-P, if the file ends in the middle of an object representation.
For example, if a file does not contain enough right parentheses to
balance the left parentheses in it, ÿreadþ signals an error.  This is
detected when ÿreadþ or ÿread-preserving-whitespaceþ is called with
RECURSIVE-P and EOF-ERROR-P non-nil, and end-of-file is reached before
the beginning of an object.

If EOF-ERROR-P is true, an error of type ÿend-of-fileþ is signaled at
the end of file.

See Also:
.........

*Note peek-char::, *Note read-char::, *Note unread-char::, *Note
read-from-string::, *Note read-delimited-list::, *Note parse-integer::,
*Note Chapter 2 (Syntax): Syntax, *Note Section 23.1 (Reader Concepts):
Reader Concepts.


File: chris-ansicl.info,  Node: read-delimited-list,  Next: read-from-string,  Prev: read; read-preserving-whitespace,  Up: Reader

read-delimited-list (Function)
==============================

Syntax:
.......

 -- Function: read-delimited-list char &optional input-stream
          recursive-p ý list

Arguments and Values:
.....................

CHAR--a character.

INPUT-STREAM--an input stream designator.  The default is standard
input.

RECURSIVE-P--a generalized boolean.  The default is false.

LIST--a list of the objects read.

Description:
............

ÿread-delimited-listþ reads objects from INPUT-STREAM until the next
character after an object's representation (ignoring whitespaceà
characters and comments) is CHAR.

ÿread-delimited-listþ looks ahead at each step for the next
non-whitespaceà character and peeks at it as if with ÿpeek-charþ.  If
it is CHAR, then the character is consumed and the list of objects is
returned.  If it is a constituent or escape character, then ÿreadþ is
used to read an object, which is added to the end of the list.  If it
is a macro character, its reader macro function is called; if the
function returns a value, that value is added to the list.  The
peek-ahead process is then repeated.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ÿreadþ or a similar function.

It is an error to reach end-of-file during the operation of
ÿread-delimited-listþ.

The consequences are undefined if CHAR has a syntax type of whitespaceà
in the current readtable.

Examples:
.........

 (read-delimited-list #\]) 1 2 3 4 5 6 ]
ý (1 2 3 4 5 6)

Suppose you wanted ÿ#{a b c ... z}þ to read as a list of all pairs of
the elements a, b, c, ..., z, for example.

 #{p q z a}  reads as  ((p q) (p z) (p a) (q z) (q a) (z a))

This can be done by specifying a macro-character definition for ÿ#{þ
that does two things: reads in all the items up to the ÿ}þ, and
constructs the pairs.  ÿread-delimited-listþ performs the first task.

 (defun |#{-reader| (stream char arg)
   (declare (ignore char arg))
   (mapcon #'(lambda (x)
              (mapcar #'(lambda (y) (list (car x) y)) (cdr x)))
          (read-delimited-list #\} stream t))) ý |#{-reader|

 (set-dispatch-macro-character #\# #\{ #'|#{-reader|) ý T
 (set-macro-character #\} (get-macro-character #\) ÿnilþ))

Note that true is supplied for the RECURSIVE-P argument.

It is necessary here to give a definition to the character ÿ}þ as well
to prevent it from being a constituent.  If the line

 (set-macro-character #\} (get-macro-character #\) ÿnilþ))

shown above were not included, then the ÿ}þ in

 #{ p q z a}

would be considered a constituent character, part of the symbol named
ÿa}þ.  This could be corrected by putting a space before the ÿ}þ, but
it is better to call ÿset-macro-characterþ.

Giving ÿ}þ the same definition as the standard definition of the
character ÿ)þ has the twin benefit of making it terminate tokens for
use with ÿread-delimited-listþ and also making it invalid for use in any
other context. Attempting to read a stray ÿ}þ will signal an error.

Affected By:
............

ÿ*standard-input*þ, ÿ*readtable*þ, ÿ*terminal-io*þ.

See Also:
.........

*Note read::, *Note peek-char::, *Note read-char::, *Note unread-char::.

Notes:
......

ÿread-delimited-listþ is intended for use in implementing reader macros.
Usually it is desirable for CHAR to be a terminating macro character so
that it can be used to delimit tokens; however, ÿread-delimited-listþ
makes no attempt to alter the syntax specified for CHAR by the current
readtable.  The caller must make any necessary changes to the readtable
syntax explicitly.


File: chris-ansicl.info,  Node: read-from-string,  Next: readtable-case,  Prev: read-delimited-list,  Up: Reader

read-from-string (Function)
===========================

Syntax:
.......

 -- Function: read-from-string string &optional eof-error-p eof-value
          &key start end preserve-whitespace ý object, position

Arguments and Values:
.....................

STRING--a string.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ÿnilþ.

START, END--bounding index designators of STRING.  The defaults for
START and END are ÿ0þ and ÿnilþ, respectively.

PRESERVE-WHITESPACE--a generalized boolean.  The default is false.

OBJECT--an object (parsed by the Lisp reader) or the EOF-VALUE.

POSITION--an integer greater than or equal to zero, and less than or
equal to one more than the length of the STRING.

Description:
............

Parses the printed representation of an object from the subsequence of
STRING bounded by START and END, as if ÿreadþ had been called on an
input stream containing those same characters.

If PRESERVE-WHITESPACE is true, the operation will preserve whitespaceà
as ÿread-preserving-whitespaceþ would do.

If an object is successfully parsed, the primary value, OBJECT, is the
object that was parsed.  If EOF-ERROR-P is false and if the end of the
SUBSTRING is reached, EOF-VALUE is returned.

The secondary value, POSITION, is the index of the first character in
the bounded STRING that was not read.  The POSITION may depend upon the
value of PRESERVE-WHITESPACE.  If the entire STRING was read, the
POSITION returned is either the LENGTH of the STRING or one greater
than the LENGTH of the STRING.

Examples:
.........

 (read-from-string " 1 3 5" t nil :start 2) ý 3, 5
 (read-from-string "(a b c)") ý (A B C), 7

Exceptional Situations:
.......................

If the end of the supplied substring occurs before an object can be
read, an error is signaled if EOF-ERROR-P is true.  An error is
signaled if the end of the SUBSTRING occurs in the middle of an
incomplete object.

See Also:
.........

*Note read::, *Note read-preserving-whitespace::

Notes:
......

The reason that POSITION is allowed to be beyond the length of the
STRING is to permit (but not require) the implementation to work by
simulating the effect of a trailing delimiter at the end of the bounded
STRING.  When PRESERVE-WHITESPACE is true, the POSITION might count the
simulated delimiter.


File: chris-ansicl.info,  Node: readtable-case,  Next: readtablep,  Prev: read-from-string,  Up: Reader

readtable-case (Accessor)
=========================

Syntax:
.......

 -- Function: readtable-case readtable ý mode

(setf (readtable-case readtable) mode)

Arguments and Values:
.....................

READTABLE--a readtable.

MODE--a case sensitivity mode.

Description:
............

Accesses the readtable case of READTABLE, which affects the way in
which the Lisp Reader  reads  symbols and the way in which the Lisp
Printer writes symbols.

Examples:
.........

See *Note Section 23.1.2.1 (Examples of Effect of Readtable Case on the
Lisp Reader): ReadtableCaseReadExamples. and *Note Section 22.1.3.3.2.1
(Examples of Effect of Readtable Case on the Lisp Printer):
ReadtableCasePrintExamples.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if READTABLE is not a
readtable.  Should signal an error of type ÿtype-errorþ if MODE is not
a case sensitivity mode.

See Also:
.........

*Note *readtable*::, *Note *print-escape*::, *Note Section 2.2 (Reader
Algorithm): Reader Algorithm, *Note Section 23.1.2 (Effect of Readtable
Case on the Lisp Reader): Effect of Readtable Case on the Lisp Reader,
*Note Section 22.1.3.3.2 (Effect of Readtable Case on the Lisp
Printer): ReadtableCasePrintEffect.

Notes:
......

ÿcopy-readtableþ copies the readtable case of the READTABLE.


File: chris-ansicl.info,  Node: readtablep,  Next: set-dispatch-macro-character; get-dispatch-macro-character,  Prev: readtable-case,  Up: Reader

readtablep (Function)
=====================

Syntax:
.......

 -- Function: readtablep object ý generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ÿreadtableþ; otherwise, returns false.

Examples:
.........

 (readtablep *readtable*) ý true
 (readtablep (copy-readtable)) ý true
 (readtablep '*readtable*) ý false

Notes:
......

 (readtablep OBJECT) Õ (typep OBJECT 'readtable)


File: chris-ansicl.info,  Node: set-dispatch-macro-character; get-dispatch-macro-character,  Next: set-macro-character; get-macro-character,  Prev: readtablep,  Up: Reader

set-dispatch-macro-character, get-dispatch-macro-character (Function)
=====================================================================

Syntax:
.......

 -- Function: get-dispatch-macro-character disp-char sub-char &optional
          readtable ý function

 -- Function: set-dispatch-macro-character disp-char sub-char
          new-function &optional readtable ý ÿtþ

Arguments and Values:
.....................

DISP-CHAR--a character.

SUB-CHAR--a character.

READTABLE--a readtable designator.  The default is the current
readtable.

FUNCTION--a function designator or ÿnilþ.

NEW-FUNCTION--a function designator.

Description:
............

ÿset-dispatch-macro-characterþ causes NEW-FUNCTION to be called when
DISP-CHAR followed by SUB-CHAR is read.  If SUB-CHAR is a lowercase
letter, it is converted to its uppercase equivalent.  It is an error if
SUB-CHAR is one of the ten decimal digits.

ÿset-dispatch-macro-characterþ installs a NEW-FUNCTION to be called
when a particular dispatching macro character pair is read.
NEW-FUNCTION is installed as the dispatch function to be called  when
READTABLE is in use and when DISP-CHAR is followed by SUB-CHAR.

For more information about how the NEW-FUNCTION is invoked, see *Note
Section 2.1.4.4 (Macro Characters): MacroChars.

ÿget-dispatch-macro-characterþ retrieves the dispatch function
associated with DISP-CHAR and SUB-CHAR in READTABLE.

ÿget-dispatch-macro-characterþ returns the macro-character function for
SUB-CHAR under DISP-CHAR, or ÿnilþ if there is no function associated
with SUB-CHAR.  If SUB-CHAR is a decimal digit,
ÿget-dispatch-macro-characterþ returns ÿnilþ.

Examples:
.........

 (get-dispatch-macro-character #\# #\{) ý NIL
 (set-dispatch-macro-character #\# #\{        ;dispatch on #{
    #'(lambda(s c n)
        (let ((list (read s nil (values) t)))  ;list is object after #n{
          (when (consp list)                   ;return nth element of list
            (unless (and n (< 0 n (length list))) (setq n 0))
            (setq list (nth n list)))
         list))) ý T
 #{(1 2 3 4) ý 1
 #3{(0 1 2 3) ý 3
 #{123 ý 123

If it is desired that ÿ#$fooþ : as if it were ÿ(dollars foo)þ.

(defun |#$-reader| (stream subchar arg)
   (declare (ignore subchar arg))
   (list 'dollars (read stream t nil t))) ý |#$-reader|
 (set-dispatch-macro-character #\# #\$ #'|#$-reader|) ý T

See Also:
.........

*Note Section 2.1.4.4 (Macro Characters): MacroChars.

Side Effects:
.............

The READTABLE is modified.

Affected By:
............

ÿ*readtable*þ.

Exceptional Situations:
.......................

For either function, an error is signaled if DISP-CHAR is not a
dispatching macro character in READTABLE.

See Also:
.........

*Note *readtable*::

Notes:
......

It is necessary to use ÿmake-dispatch-macro-characterþ to set up the
dispatch character before specifying its sub-characters.


File: chris-ansicl.info,  Node: set-macro-character; get-macro-character,  Next: set-syntax-from-char,  Prev: set-dispatch-macro-character; get-dispatch-macro-character,  Up: Reader

set-macro-character, get-macro-character (Function)
===================================================

Syntax:
.......

 -- Function: get-macro-character char &optional readtable ý function,
          non-terminating-p

 -- Function: set-macro-character char new-function &optional
          non-terminating-p readtable ý ÿtþ

Arguments and Values:
.....................

CHAR--a character.

NON-TERMINATING-P--a generalized boolean.  The default is false.

READTABLE--a readtable designator.  The default is the current
readtable.

FUNCTION--ÿnilþ, or a designator for a function of two arguments.

NEW-FUNCTION--a function designator.

Description:
............

ÿget-macro-characterþ returns as its primary value, FUNCTION, the
reader macro function associated with CHAR in READTABLE (if any), or
else ÿnilþ if CHAR is not a macro character in READTABLE.  The
secondary value, NON-TERMINATING-P, is true if CHAR is a
non-terminating macro character; otherwise, it is false.

ÿset-macro-characterþ causes CHAR to be a macro character associated
with the reader macro function NEW-FUNCTION (or the designator for
NEW-FUNCTION) in READTABLE.  If NON-TERMINATING-P is true, CHAR becomes
a non-terminating macro character; otherwise it becomes a
terminating macro character.

Examples:
.........

 (get-macro-character #\{) ý NIL, false
 (not (get-macro-character #\;)) ý false

The following is a possible definition for the single-quote reader macro
in standard syntax:

 (defun single-quote-reader (stream char)
   (declare (ignore char))
   (list 'quote (read stream t nil t))) ý SINGLE-QUOTE-READER
 (set-macro-character #\' #'single-quote-reader) ý T

Here ÿsingle-quote-readerþ reads an object following the single-quote
and returns a list of ÿquoteþ and that object.  The CHAR argument is
ignored.

The following is a possible definition for the semicolon reader macro
in standard syntax:

 (defun semicolon-reader (stream char)
   (declare (ignore char))
   ;; First swallow the rest of the current input line.
   ;; End-of-file is acceptable for terminating the comment.
   (do () ((char= (read-char stream nil #\Newline t) #\Newline)))
   ;; Return zero values.
   (values)) ý SEMICOLON-READER
 (set-macro-character #\; #'semicolon-reader) ý T

Side Effects:
.............

The READTABLE is modified.

See Also:
.........

*Note *readtable*::


File: chris-ansicl.info,  Node: set-syntax-from-char,  Next: with-standard-io-syntax,  Prev: set-macro-character; get-macro-character,  Up: Reader

set-syntax-from-char (Function)
===============================

Syntax:
.......

 -- Function: set-syntax-from-char to-char from-char &optional
          to-readtable from-readtable ý ÿtþ

Arguments and Values:
.....................

TO-CHAR--a character.

FROM-CHAR--a character.

TO-READTABLE--a readtable.  The default is the current readtable.

FROM-READTABLE--a readtable designator.  The default is the standard
readtable.

Description:
............

ÿset-syntax-from-charþ makes the syntax of TO-CHAR   in TO-READTABLE
be the same as the syntax of FROM-CHAR in FROM-READTABLE.

ÿset-syntax-from-charþ copies the syntax types of FROM-CHAR.  If
FROM-CHAR is a macro character, its reader macro function is copied
also.  If the character is a dispatching macro character, its entire
dispatch table of reader macro functions is copied.  The constituent
traits of FROM-CHAR are not copied.

A macro definition from a character such as ÿ"þ can be copied to
another character; the standard definition for ÿ"þ looks for another
character that is the same as the character that invoked it.  The
definition of ÿ(þ can not be meaningfully copied to ÿ{þ, on the other
hand.  The result is that lists are of the form ÿ{a b c)þ, not ÿ{a b
c}þ, because the definition always looks for a closing parenthesis, not
a closing brace.

Examples:
.........

 (set-syntax-from-char #\7 #\;) ý T
 123579 ý 1235

Side Effects:
.............

The TO-READTABLE is modified.

Affected By:
............

The existing values in the FROM-READTABLE.

See Also:
.........

*Note set-macro-character::, *Note make-dispatch-macro-character::,
*Note Section 2.1.4 (Character Syntax Types): Character Syntax Types.

Notes:
......

The constituent traits of a character are "hard wired" into the parser
for extended tokens.  For example, if the definition of ÿSþ is copied
to ÿ*þ, then ÿ*þ will become a constituent that is alphabeticà but that
cannot be used as a short float exponent marker.  For further
information, see *Note Section 2.1.4.2 (Constituent Traits):
ConstituentTraits.


File: chris-ansicl.info,  Node: with-standard-io-syntax,  Next: *read-base*,  Prev: set-syntax-from-char,  Up: Reader

with-standard-io-syntax (Macro)
===============================

Syntax:
.......

 -- Macro: with-standard-io-syntax {form}* ý {result}*

Arguments and Values:
.....................

FORMS--an implicit progn.

RESULTS--the values returned by the forms.

Description:
............

Within the dynamic extent of the body of FORMS, all reader/printer
control variables, including any implementation-defined ones not
specified by this standard, are bound to values that produce standard
read/print behavior.  The values for the variables specified by this
standard are listed in the next figure.

Variable                        Value
--------------------------------------------------------------------- 
ÿ*package*þ                     The ÿCL-USERþ package
ÿ*print-array*þ                 ÿtþ
ÿ*print-base*þ                  ÿ10þ
ÿ*print-case*þ                  :upcase
ÿ*print-circle*þ                ÿnilþ
ÿ*print-escape*þ                ÿtþ
ÿ*print-gensym*þ                ÿtþ
ÿ*print-length*þ                ÿnilþ
ÿ*print-level*þ                 ÿnilþ
ÿ*print-lines*þ                 ÿnilþ
ÿ*print-miser-width*þ           ÿnilþ
ÿ*print-pprint-dispatch*þ       The standard pprint dispatch table
ÿ*print-pretty*þ                ÿnilþ
ÿ*print-radix*þ                 ÿnilþ
ÿ*print-readably*þ              ÿtþ
ÿ*print-right-margin*þ          ÿnilþ
ÿ*read-base*þ                   ÿ10þ
ÿ*read-default-float-format*þ   ÿsingle-floatþ
ÿ*read-eval*þ                   ÿtþ
ÿ*read-suppress*þ               ÿnilþ
ÿ*readtable*þ                   The standard readtable

Figure 23.1: Values of standard control variables

Examples:
.........

 (with-open-file (file pathname :direction :output)
   (with-standard-io-syntax
     (print data file)))

;;; ... Later, in another Lisp:

 (with-open-file (file pathname :direction :input)
   (with-standard-io-syntax
     (setq data (read file))))


File: chris-ansicl.info,  Node: *read-base*,  Next: *read-default-float-format*,  Prev: with-standard-io-syntax,  Up: Reader

*read-base* (Variable)
======================

Value Type:
...........

a radix.

Initial Value:
..............

ÿ10þ.

Description:
............

Controls the interpretation of tokens by ÿreadþ as being integers or
ratios.

The value of ÿ*read-base*þ, called the "current input base", is the
radix in which integers and ratios are to be read by the Lisp reader.
The parsing of other numeric types (e.g., floats) is not affected by
this option.

The effect of ÿ*read-base*þ on the reading of any particular rational
number can be locally overridden by explicit use of the ÿ#Oþ, ÿ#Xþ,
ÿ#Bþ, or ÿ#nRþ syntax or by a trailing decimal point.

Examples:
.........

 (dotimes (i 6)
   (let ((*read-base* (+ 10. i)))
     (let ((object (read-from-string "(\\DAD DAD |BEE| BEE 123. 123)")))
       (print (list *read-base* object)))))
Ö (10 (DAD DAD BEE BEE 123 123))
Ö (11 (DAD DAD BEE BEE 123 146))
Ö (12 (DAD DAD BEE BEE 123 171))
Ö (13 (DAD DAD BEE BEE 123 198))
Ö (14 (DAD 2701 BEE BEE 123 227))
Ö (15 (DAD 3088 BEE 2699 123 258))
ý NIL

Notes:
......

Altering the input radix can be useful when reading data files in
special formats.


File: chris-ansicl.info,  Node: *read-default-float-format*,  Next: *read-eval*,  Prev: *read-base*,  Up: Reader

*read-default-float-format* (Variable)
======================================

Value Type:
...........

one of the atomic type specifiers ÿshort-floatþ, ÿsingle-floatþ,
ÿdouble-floatþ, or ÿlong-floatþ, or else some other type specifier
defined by the implementation to be acceptable.

Initial Value:
..............

The symbol ÿsingle-floatþ.

Description:
............

Controls the floating-point format that is to be used when reading a
floating-point number that has no exponent marker or that has ÿeþ or
ÿEþ for an exponent marker.  Other exponent markers explicitly
prescribe the floating-point format to be used.

The printer uses ÿ*read-default-float-format*þ to guide the choice of
exponent markers when printing floating-point numbers.

Examples:
.........

 (let ((*read-default-float-format* 'double-float))
   (read-from-string "(1.0 1.0e0 1.0s0 1.0f0 1.0d0 1.0L0)"))
ý (1.0   1.0   1.0   1.0 1.0   1.0)   ;Implementation has float format F.
ý (1.0   1.0   1.0s0 1.0 1.0   1.0)   ;Implementation has float formats S and F.
ý (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0d0) ;Implementation has float formats F and D.
ý (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0d0) ;Implementation has float formats S, F, D.
ý (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0L0) ;Implementation has float formats F, D, L.
ý (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0L0) ;Implementation has formats S, F, D, L.


File: chris-ansicl.info,  Node: *read-eval*,  Next: *read-suppress*,  Prev: *read-default-float-format*,  Up: Reader

*read-eval* (Variable)
======================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

true.

Description:
............

If it is true, the ÿ#.þ reader macro has its normal effect.  Otherwise,
that reader macro signals an error of type ÿreader-errorþ.

See Also:
.........

*Note *print-readably*::

Notes:
......

If ÿ*read-eval*þ is false and ÿ*print-readably*þ is true, any method
for ÿprint-objectþ that would output a reference to the ÿ#.þ reader
macro either outputs something different or signals an error of type
ÿprint-not-readableþ.


File: chris-ansicl.info,  Node: *read-suppress*,  Next: *readtable*,  Prev: *read-eval*,  Up: Reader

*read-suppress* (Variable)
==========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

false.

Description:
............

This variable is intended primarily to support the operation of the
read-time conditional notations ÿ#+þ and ÿ#-þ. It is important for the
reader macros which implement these notations to be able to skip over
the printed representation of an expression despite the possibility
that the syntax of the skipped expression may not be entirely valid for
the current implementation, since ÿ#+þ and ÿ#-þ exist in order to allow
the same program to be shared among several Lisp implementations
(including dialects other than Common Lisp) despite small
incompatibilities of syntax.

If it is false, the Lisp reader operates normally.

If the value of ÿ*read-suppress*þ is true, ÿreadþ,
ÿread-preserving-whitespaceþ, ÿread-delimited-listþ, and
ÿread-from-stringþ all return a primary value of ÿnilþ when they
complete successfully; however, they continue to parse the
representation of an object in the normal way, in order to skip over
the object, and continue to indicate end of file in the normal way.
Except as noted below, any standardized reader macroà that is defined
to readà a following object or token will do so, but not signal an
error if the object read is not of an appropriate type or syntax.  The
standard syntax and its associated reader macros will not construct any
new objects (e.g., when reading the representation of a symbol, no
symbol will be constructed or interned).

Extended tokens
     All extended tokens are completely uninterpreted.  Errors such as
     those that might otherwise be signaled due to detection of invalid
     potential numbers, invalid patterns of package markers, and
     invalid uses of the dot character are suppressed.

Dispatching macro characters (including sharpsign)
     Dispatching macro characters continue to parse an infix numerical
     argument, and invoke the dispatch function.  The standardized
     sharpsign reader macros do not enforce any constraints on either
     the presence of or the value of the numerical argument.

ÿ#=þ
     The ÿ#=þ notation is totally ignored.  It does not read a
     following object. It produces no object, but is treated as
     whitespaceà.

ÿ##þ
     The ÿ##þ notation always produces ÿnilþ.

No matter what the value of ÿ*read-suppress*þ, parentheses still
continue to delimit and construct lists; the ÿ#(þ notation continues to
delimit vectors; and comments, strings, and the single-quote and
backquote notations continue to be interpreted properly.  Such
situations as ÿ')þ,ÿ#<þ, ÿ#)þ, and ÿ#<Space>þ continue to signal errors.

Examples:
.........

 (let ((*read-suppress* t))
   (mapcar #'read-from-string
           '("#(foo bar baz)" "#P(:type :lisp)" "#c1.2"
             "#.(PRINT 'FOO)" "#3AHELLO" "#S(INTEGER)"
             "#*ABC" "#\GARBAGE" "#RALPHA" "#3R444")))
ý (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)

See Also:
.........

*Note read::, *Note Chapter 2 (Syntax): Syntax.

Notes:
......

Programmers and implementations that define additional macro characters
are strongly encouraged to make them respect ÿ*read-suppress*þ just as
standardized macro characters do.  That is, when the value of
ÿ*read-suppress*þ is true, they should ignore type errors when reading
a following object and the functions that implement dispatching macro
characters should tolerate ÿnilþ as their infix parameter value even if
a numeric value would ordinarily be required.


File: chris-ansicl.info,  Node: *readtable*,  Next: reader-error,  Prev: *read-suppress*,  Up: Reader

*readtable* (Variable)
======================

Value Type:
...........

a readtable.

Initial Value:
..............

A readtable that conforms to the description of Common Lisp syntax in
*Note Chapter 2 (Syntax): Syntax.

Description:
............

The value of ÿ*readtable*þ is called the current readtable.  It
controls the parsing behavior of the Lisp reader, and can also
influence the Lisp printer (e.g., see the function *Note
readtable-case::).

Examples:
.........

 (readtablep *readtable*) ý true
 (setq zvar 123) ý 123
 (set-syntax-from-char #\z #\' (setq table2 (copy-readtable))) ý T
 zvar ý 123
 (setq *readtable* table2) ý #<READTABLE>
 zvar ý VAR
 (setq *readtable* (copy-readtable nil)) ý #<READTABLE>
 zvar ý 123

Affected By:
............

ÿcompile-fileþ, ÿloadþ

See Also:
.........

*Note compile-file::, *Note load::, *Note readtable::, *Note Section
2.1.1.1 (The Current Readtable): CurrentReadtable.


File: chris-ansicl.info,  Node: reader-error,  Prev: *readtable*,  Up: Reader

reader-error (Condition Type)
=============================

Class Precedence List:
......................

ÿreader-errorþ, ÿparse-errorþ, ÿstream-errorþ, ÿerrorþ,
ÿserious-conditionþ, ÿconditionþ, ÿtþ

Description:
............

The type ÿreader-errorþ consists of error conditions that are related
to tokenization and parsing done by the Lisp reader.

See Also:
.........

*Note read::, *Note stream-error-stream::, *Note Section 23.1 (Reader
Concepts): Reader Concepts.


File: chris-ansicl.info,  Node: System Construction,  Next: Environment,  Prev: Reader,  Up: Top

24 System Construction
**********************

* Menu:

* System Construction Concepts::

Dictionary

* compile-file::
* compile-file-pathname::
* load::
* with-compilation-unit::
* *features*::
* *compile-file-pathname*; *compile-file-truename*::
* *load-pathname*; *load-truename*::
* *compile-print*; *compile-verbose*::
* *load-print*; *load-verbose*::
* *modules*::
* provide; require::


File: chris-ansicl.info,  Node: System Construction Concepts,  Next: compile-file,  Up: System Construction

24.1 System Construction Concepts
=================================

* Menu:

* Loading::
* Features::


File: chris-ansicl.info,  Node: Loading,  Next: Features,  Up: System Construction Concepts

24.1.1 Loading
--------------

To ÿloadþ a file is to treat its contents as code and execute that code.
The file may contain "source code" or "compiled code".

A file containing source code is called a "source file".  Loading a
source file is accomplished essentially by sequentially readingà the
forms in the file, evaluating each immediately after it is read.

A file containing compiled code is called a "compiled file".  Loading a
compiled file is similar to loading a source file, except that the file
does not contain text but rather an implementation-dependent
representation of pre-digested expressions created by the compiler.
Often, a compiled file can be loaded more quickly than a source file.
See *Note Section 3.2 (Compilation): Compilation.

The way in which a source file is distinguished from a compiled file is
implementation-dependent.


File: chris-ansicl.info,  Node: Features,  Prev: Loading,  Up: System Construction Concepts

24.1.2 Features
---------------

A "feature" is an aspect or attribute of Common Lisp, of the
implementation, or of the environment.  A feature is identified by a
symbol.

A feature is said to be "present" in a Lisp image if and only if the
symbol naming it is an element of the list held by the variable
ÿ*features*þ, which is called the "features list".

24.1.2.1 Feature Expressions
............................

Boolean combinations of features, called "feature expressions", are
used by the ÿ#+þ and ÿ#-þ reader macros in order to direct conditional
reading of expressions by the Lisp reader.

The rules for interpreting a feature expression are as follows:

feature
     If a symbol naming a feature is used as a feature expression, the
     feature expression succeeds if that feature is present; otherwise
     it fails.

ÿ(not FEATURE-CONDITIONAL)þ
     A not feature expression succeeds if its argument
     FEATURE-CONDITIONAL fails; otherwise, it succeeds.

ÿ(and {feature-conditional}*)þ
     An and feature expression succeeds if all of its argument
     FEATURE-CONDITIONALS succeed; otherwise, it fails.

ÿ(or {feature-conditional}*)þ
     An or feature expression succeeds if any of its argument
     FEATURE-CONDITIONALS succeed; otherwise, it fails.

24.1.2.1.1 Examples of Feature Expressions
..........................................

For example, suppose that in implementation A, the features ÿspiceþ and
ÿperqþ are present, but the feature ÿlispmþ is not present; in
implementation B, the feature ÿlispmþ is present, but the features
ÿspiceþ and ÿperqþ are not present; and in implementation C, none of
the features ÿspiceþ, lispm, or ÿperqþ are present.  The next
figure shows some sample expressions, and how they would be readà in
these implementations.

ÿ(cons #+spice "Spice" #-spice        
"Lispm" x)þ                           
in implementation A ...               ÿ(CONS "Spice" X)þ
in implementation B ...               ÿ(CONS "Lispm" X)þ
in implementation C ...               ÿ(CONS "Lispm" X)þ
ÿ(cons #+spice "Spice" #+LispM        
"Lispm" x)þ                           
in implementation A ...               ÿ(CONS "Spice" X)þ
in implementation B ...               ÿ(CONS "Lispm" X)þ
in implementation C ...               ÿ(CONS X)þ
ÿ(setq a '(1 2 #+perq 43 #+(not       
perq) 27))þ                           
in implementation A ...               ÿ(SETQ A '(1 2 43))þ
in implementation B ...               ÿ(SETQ A '(1 2 27))þ
in implementation C ...               ÿ(SETQ A '(1 2 27))þ
ÿ(let ((a 3) #+(or spice lispm) (b    
3)) (foo a))þ                         
in implementation A ...               ÿ(LET ((A 3) (B 3)) (FOO A))þ
in implementation B ...               ÿ(LET ((A 3) (B 3)) (FOO A))þ
in implementation C ...               ÿ(LET ((A 3)) (FOO A))þ
ÿ(cons #+Lispm "#+Spice" #+Spice      
"foo" #-(or Lispm Spice) 7 x)þ        
in implementation A ...               ÿ(CONS "foo" X)þ
in implementation B ...               ÿ(CONS "#+Spice" X)þ
in implementation C ...               ÿ(CONS 7 X)þ

Figure 24.1: Features examples


File: chris-ansicl.info,  Node: compile-file,  Next: compile-file-pathname,  Prev: System Construction Concepts,  Up: System Construction

compile-file (Function)
=======================

Syntax:
.......

 -- Function: compile-file input-file &key output-file verbose
          print external-format ý output-truename, warnings-p, failure-p

Arguments and Values:
.....................

INPUT-FILE--a pathname designator.  (Default fillers for unspecified
components are taken from ÿ*default-pathname-defaults*þ.)

OUTPUT-FILE--a pathname designator.  The default is
implementation-defined.

VERBOSE--a generalized boolean.  The default is the value of
ÿ*compile-verbose*þ.

PRINT--a generalized boolean.  The default is the value of
ÿ*compile-print*þ.

EXTERNAL-FORMAT--an external file format designator.  The default is
:default.

OUTPUT-TRUENAME--a pathname (the ÿtruenameþ of the output file), or
ÿnilþ.

WARNINGS-P--a generalized boolean.

FAILURE-P--a generalized boolean.

Description:
............

ÿcompile-fileþ transforms the contents of the file specified by
INPUT-FILE into implementation-dependent binary data which are placed
in the file specified by OUTPUT-FILE.

The file to which INPUT-FILE refers should be a source file.
OUTPUT-FILE can be used to specify an output pathname; the actual
pathname of the compiled file to which compiled code will be output is
computed as if by calling ÿcompile-file-pathnameþ.

If INPUT-FILE or OUTPUT-FILE is a logical pathname, it is translated
into a physical pathname as if by calling ÿtranslate-logical-pathnameþ.

If VERBOSE is true, ÿcompile-fileþ prints a message in the form of a
comment (i.e., with a leading semicolon) to standard output indicating
what file is being compiled and other useful information.  If VERBOSE
is false, ÿcompile-fileþ does not print this information.

If PRINT is true, information about top level forms in the file being
compiled is printed to standard output.  Exactly what is printed is
implementation-dependent, but nevertheless some information is printed.
If PRINT is ÿnilþ, no information is printed.

The EXTERNAL-FORMAT specifies the external file format to be used when
opening the file; see the function *Note open::.  ÿcompile-fileþ and
ÿloadþ must cooperate in such a way that the resulting compiled file
can be loaded without specifying an external file format anew; see the
function *Note load::.

ÿcompile-fileþ binds ÿ*readtable*þ and ÿ*package*þ to the values they
held before processing the file.

ÿ*compile-file-truename*þ is bound by ÿcompile-fileþ to hold the
truename of the pathname of the file being compiled.

ÿ*compile-file-pathname*þ is bound by ÿcompile-fileþ to hold a pathname
denoted by the first argument to ÿcompile-fileþ, merged against the
defaults; that is, ÿ(pathname (merge-pathnames INPUT-FILE))þ.

The compiled functions contained in the compiled file become available
for use when the compiled file is loaded into Lisp.  Any function
definition that is processed by the compiler, including ÿ#'(lambda
...)þ forms and local function definitions made by ÿfletþ, ÿlabelsþ and
ÿdefunþ forms, result in an object of type ÿcompiled-functionþ.

The primary value returned by ÿcompile-fileþ, OUTPUT-TRUENAME, is the
ÿtruenameþ of the output file, or ÿnilþ if the file could not be
created.

The secondary value, WARNINGS-P, is false if no conditions of type
ÿerrorþ or ÿwarningþ were detected by the compiler, and true otherwise.

The tertiary value, FAILURE-P, is false if no conditions of type
ÿerrorþ or ÿwarningþ (other than ÿstyle-warningþ) were detected by the
compiler, and true otherwise.

For general information about how files are processed by the file
compiler, see *Note Section 3.2.3 (File Compilation): File Compilation.

Programs to be compiled by the file compiler must only contain
externalizable objects; for details on such objects, see *Note Section
3.2.4 (Literal Objects in Compiled Files): Literal Objects in Compiled
Files.  For information on how to extend the set of externalizable
objects, see the function *Note make-load-form:: and *Note Section
3.2.4.4 (Additional Constraints on Externalizable Objects):
CallingMakeLoadForm.

Affected By:
............

ÿ*error-output*þ, ÿ*standard-output*þ, ÿ*compile-verbose*þ,
ÿ*compile-print*þ

The computer's file system.

Exceptional Situations:
.......................

For information about errors detected during the compilation process,
see *Note Section 3.2.5 (Exceptional Situations in the Compiler):
Exceptional Situations in the Compiler.

An error of type ÿfile-errorþ might be signaled if ÿ(wild-pathname-p
INPUT-FILE)þ returns true.

If either the attempt to open the source file for input or the attempt
to open the compiled file for output fails, an error of type
ÿfile-errorþ is signaled.

See Also:
.........

*Note compile::, *Note declare::, *Note eval-when::, *Note pathname
(System Class)::, *Note logical-pathname (System Class)::, *Note
Section 20.1 (File System Concepts): File System Concepts, *Note
Section 19.1.2 (Pathnames as Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: compile-file-pathname,  Next: load,  Prev: compile-file,  Up: System Construction

compile-file-pathname (Function)
================================

Syntax:
.......

 -- Function: compile-file-pathname input-file &key output-file
          &allow-other-keys ý pathname

Arguments and Values:
.....................

INPUT-FILE--a pathname designator.  (Default fillers for unspecified
components are taken from ÿ*default-pathname-defaults*þ.)

OUTPUT-FILE--a pathname designator.  The default is
implementation-defined.

PATHNAME--a pathname.

Description:
............

Returns the pathname that ÿcompile-fileþ would write into, if given the
same arguments.

The defaults for the OUTPUT-FILE are taken from the pathname that
results from merging the INPUT-FILE with the value of
ÿ*default-pathname-defaults*þ, except that the type component should
default to the appropriate implementation-defined default type for
compiled files.

If INPUT-FILE is a logical pathname and OUTPUT-FILE is unsupplied, the
result is a logical pathname.  If INPUT-FILE is a logical pathname, it
is translated into a physical pathname as if by calling
ÿtranslate-logical-pathnameþ.  If INPUT-FILE is a stream, the stream
can be either open or closed.  ÿcompile-file-pathnameþ returns the same
pathname after a file is closed as it did when the file was open.  It
is an error if INPUT-FILE is a stream that is created with
ÿmake-two-way-streamþ, ÿmake-echo-streamþ, ÿmake-broadcast-streamþ,
ÿmake-concatenated-streamþ, ÿmake-string-input-streamþ,
ÿmake-string-output-streamþ.

If an implementation supports additional keyword arguments to
ÿcompile-fileþ, ÿcompile-file-pathnameþ must accept the same arguments.

Examples:
.........

See ÿlogical-pathname-translationsþ.

Exceptional Situations:
.......................

An error of type ÿfile-errorþ might be signaled if either INPUT-FILE or
OUTPUT-FILE is wild.

See Also:
.........

*Note compile-file::, *Note pathname (System Class)::, *Note
logical-pathname (System Class)::, *Note Section 20.1 (File System
Concepts): File System Concepts, *Note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: load,  Next: with-compilation-unit,  Prev: compile-file-pathname,  Up: System Construction

load (Function)
===============

Syntax:
.......

 -- Function: load filespec &key verbose print
          if-does-not-exist external-format ý generalized-boolean

Arguments and Values:
.....................

FILESPEC--a stream, or a pathname designator.  The default is taken
from ÿ*default-pathname-defaults*þ.

VERBOSE--a generalized boolean.  The default is the value of
ÿ*load-verbose*þ.

PRINT--a generalized boolean.  The default is the value of
ÿ*load-print*þ.

IF-DOES-NOT-EXIST--a generalized boolean.  The default is true.

EXTERNAL-FORMAT--an external file format designator.  The default is
:default.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

ÿloadþ loads the file named by FILESPEC into the Lisp environment.

The manner in which a source file is distinguished from a compiled file
is implementation-dependent.  If the file specification is not complete
and both a source file and a compiled file exist which might match,
then which of those files ÿloadþ selects is implementation-dependent.

If FILESPEC is a stream, ÿloadþ determines what kind of stream it is
and loads directly from the stream.  If FILESPEC is a logical pathname,
it is translated into a physical pathname as if by calling
ÿtranslate-logical-pathnameþ.

ÿloadþ sequentially executes each form it encounters in the file named
by FILESPEC.  If the file is a source file and the implementation
chooses to perform implicit compilation, ÿloadþ must recognize top
level forms as described in *Note Section 3.2.3.1 (Processing of Top
Level Forms): TopLevelForms.  and arrange for each top level form to be
executed before beginning implicit compilation of the next.  (Note,
however, that processing of ÿeval-whenþ forms by ÿloadþ is controlled
by the :execute situation.)

If VERBOSE is true, ÿloadþ prints a message in the form of a comment
(i.e., with a leading semicolon) to standard output indicating what
file is being loaded and other useful information.  If VERBOSE is false,
ÿloadþ does not print this information.

If PRINT is true, ÿloadþ incrementally prints information to standard
output showing the progress of the loading process.  For a source file,
this information might mean printing the values yielded by each form in
the file as soon as those values are returned.  For a compiled file,
what is printed might not reflect precisely the contents of the source
file, but some information is generally printed.  If PRINT is false,
ÿloadþ does not print this information.

If the file named by FILESPEC is successfully loaded, ÿloadþ returns
true.

If the file does not exist, the specific action taken depends on
IF-DOES-NOT-EXIST: if it is ÿnilþ, ÿloadþ returns ÿnilþ; otherwise,
ÿloadþ signals an error.

The EXTERNAL-FORMAT specifies the external file format to be used when
opening the file (see the function *Note open::), except that when the
file named by FILESPEC is a compiled file, the EXTERNAL-FORMAT is
ignored.  ÿcompile-fileþ and ÿloadþ cooperate in an
implementation-dependent way to assure the preservation of the
similarity of characters referred to in the source file at the time the
source file was processed by the file compiler under a given external
file format, regardless of the value of EXTERNAL-FORMAT at the time the
compiled file is loaded.

ÿloadþ binds ÿ*readtable*þ and ÿ*package*þ to the values they held
before loading the file.

ÿ*load-truename*þ is bound by ÿloadþ to hold the truename of the
pathname of the file being loaded.

ÿ*load-pathname*þ is bound by ÿloadþ to hold a pathname that represents
FILESPEC merged against the defaults.  That is, ÿ(pathname
(merge-pathnames FILESPEC))þ.

Examples:
.........

;Establish a data file...
 (with-open-file (str "data.in" :direction :output :if-exists :error)
   (print 1 str) (print '(setq a 888) str) t)
ý T
 (load "data.in") ý true
 a ý 888
 (load (setq p (merge-pathnames "data.in")) :verbose t)
; Loading contents of file /fred/data.in
; Finished loading /fred/data.in
ý true
 (load p :print t)
; Loading contents of file /fred/data.in
;  1
;  888
; Finished loading /fred/data.in
ý true

 ;----[Begin file SETUP]----
 (in-package "MY-STUFF")
 (defmacro compile-truename () `',*compile-file-truename*)
 (defvar *my-compile-truename* (compile-truename) "Just for debugging.")
 (defvar *my-load-pathname* *load-pathname*)
 (defun load-my-system ()
   (dolist (module-name '("FOO" "BAR" "BAZ"))
     (load (merge-pathnames module-name *my-load-pathname*))))
 ;----[End of file SETUP]----


 (load "SETUP")
 (load-my-system)

Affected By:
............

The implementation, and the host computer's file system.

Exceptional Situations:
.......................

If :if-does-not-exist is supplied and is true, or is not supplied,
ÿloadþ signals an error of type ÿfile-errorþ if the file named by
FILESPEC does not exist, or if the file system cannot perform the
requested operation.

An error of type ÿfile-errorþ might be signaled if ÿ(wild-pathname-p
FILESPEC)þ returns true.

See Also:
.........

*Note error (Function)::, *Note merge-pathnames::, *Note
*load-verbose*::, *Note *default-pathname-defaults*::, *Note pathname
(System Class)::, *Note logical-pathname (System Class)::, *Note
Section 20.1 (File System Concepts): File System Concepts, *Note
Section 19.1.2 (Pathnames as Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: with-compilation-unit,  Next: *features*,  Prev: load,  Up: System Construction

with-compilation-unit (Macro)
=============================

Syntax:
.......

 -- Macro: with-compilation-unit (ùûoptionø) {form}* ý {result}*

OPTION::=
     :override override

Arguments and Values:
.....................

OVERRIDE--a generalized boolean; evaluated.  The default is ÿnilþ.

FORMS--an implicit progn.

RESULTS--the values returned by the forms.

Description:
............

Executes FORMS from left to right.  Within the dynamic environment of
ÿwith-compilation-unitþ, actions deferred by the compiler until the end
of compilation will be deferred until the end of the outermost call to
ÿwith-compilation-unitþ.

The set of options permitted may be extended by the implementation, but
the only standardized keyword is :override.

If nested dynamically only the outer call to ÿwith-compilation-unitþ
has any effect unless the value associated with :override is true, in
which case warnings are deferred only to the end of the innermost call
for which OVERRIDE is true.

The function ÿcompile-fileþ provides the effect of

 (with-compilation-unit (:override nil) ...)

around its code.

Any implementation-dependent extensions can only be provided as the
result of an explicit programmer request by use of an
implementation-dependent keyword.  Implementations are forbidden from
attaching additional meaning to a use of this macro which involves
either no keywords or just the keyword :override.

Examples:
.........

If an implementation would normally defer certain kinds of warnings,
such as warnings about undefined functions, to the end of a compilation
unit (such as a file), the following example shows how to cause those
warnings to be deferred to the end of the compilation of several files.

 (defun compile-files (&rest files)
   (with-compilation-unit ()
     (mapcar #'(lambda (file) (compile-file file)) files)))

 (compile-files "A" "B" "C")

Note however that if the implementation does not normally defer any
warnings, use of with-compilation-unit might not have any effect.

See Also:
.........

*Note compile::, *Note compile-file::


File: chris-ansicl.info,  Node: *features*,  Next: *compile-file-pathname*; *compile-file-truename*,  Prev: with-compilation-unit,  Up: System Construction

*features* (Variable)
=====================

Value Type:
...........

a proper list.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ÿ*features*þ is called the features list.  It is a list of
symbols, called features, that correspond to some aspect of the
implementation or environment.

Most features have implementation-dependent meanings; The following
meanings have been assigned to feature names:

:cltl1
     If present, indicates that the ÿLISPþ package purports to conform
     to the 1984 specification `Common Lisp: The Language'.  It is
     possible, but not required, for a conforming implementation to
     have this feature because this specification specifies that its
     symbols are to be in the ÿCOMMON-LISPþ package, not the ÿLISPþ
     package.

:cltl2
     If present, indicates that the implementation purports to conform
     to `Common Lisp: The Language Second Edition'.  This feature must
     not be present in any conforming implementation, since conformance
     to that document is not compatible with conformance to this
     specification.  The name, however, is reserved by this
     specification in order to help programs distinguish
     implementations which conform to that document from
     implementations which conform to this specification.

:ieee-floating-point
     If present, indicates that the implementation purports to conform
     to the requirements of `IEEE Standard for Binary Floating-Point
     Arithmetic'.

:x3j13
     If present, indicates that the implementation conforms to some
     particular working draft of this specification, or to some subset
     of features that approximates a belief about what this
     specification might turn out to contain.  A conforming
     implementation might or might not contain such a feature.  (This
     feature is intended primarily as a stopgap in order to provide
     implementors something to use prior to the availability of a draft
     standard, in order to discourage them from introducing the
     :draft-ansi-cl and :ansi-cl features prematurely.)

:draft-ansi-cl
     If present, indicates that the implementation purports to conform
     to the first full draft of this specification, which went to
     public review in 1992.  A conforming implementation which has the
     :draft-ansi-cl-2 or :ansi-cl feature is not permitted to retain
     the :draft-ansi-cl feature since incompatible changes were made
     subsequent to the first draft.

:draft-ansi-cl-2
     If present, indicates that a second full draft of this
     specification has gone to public review, and that the
     implementation purports to conform to that specification.  (If
     additional public review drafts are produced, this keyword will
     continue to refer to the second draft, and additional keywords
     will be added to identify conformance with such later drafts.  As
     such, the meaning of this keyword can be relied upon not to change
     over time.)  A conforming implementation which has the :ansi-cl
     feature is only permitted to retain the :draft-ansi-cl feature if
     the finally approved standard is not incompatible with the draft
     standard.

:ansi-cl
     If present, indicates that this specification has been adopted by
     ANSI as an official standard, and that the implementation purports
     to conform.

:common-lisp
     This feature must appear in ÿ*features*þ for any implementation
     that has one or more of the features :x3j13, :draft-ansi-cl, or
     :ansi-cl.  It is intended that it should also appear in
     implementations which have the features :cltl1 or :cltl2, but this
     specification cannot force such behavior.  The intent is that this
     feature should identify the language family named "Common Lisp,"
     rather than some specific dialect within that family.

See Also:
.........

*Note Section 1.5.2.1.1 (Use of Read-Time Conditionals):
ReadTimeConditionals, *Note Section 2.4 (Standard Macro Characters):
Standard Macro Characters.

Notes:
......

The value of ÿ*features*þ is used by the ÿ#+þ and ÿ#-þ reader syntax.

Symbols in the features list may be in any package, but in practice
they are generally in the ÿKEYWORDþ package.  This is because ÿKEYWORDþ
is the package used by default when readingà feature expressions in the
ÿ#+þ and ÿ#-þ reader macros.  Code that needs to name a featureà in a
package P (other than ÿKEYWORDþ) can do so by making explicit use of a
package prefix for P, but note that such code must also assure that the
package P exists in order for the feature expression to be readà--even
in cases where the feature expression is expected to fail.

It is generally considered wise for an implementation to include one or
more features identifying the specific implementation, so that
conditional expressions can be written which distinguish idiosyncrasies
of one implementation from those of another.  Since features are
normally symbols in the ÿKEYWORDþ package where name collisions might
easily result, and since no uniquely defined mechanism is designated
for deciding who has the right to use which symbol for what reason, a
conservative strategy is to prefer names derived from one's own company
or product name, since those names are often trademarked and are hence
less likely to be used unwittingly by another implementation.


File: chris-ansicl.info,  Node: *compile-file-pathname*; *compile-file-truename*,  Next: *load-pathname*; *load-truename*,  Prev: *features*,  Up: System Construction

*compile-file-pathname*, *compile-file-truename* (Variable)
===========================================================

Value Type:
...........

The value of ÿ*compile-file-pathname*þ must always be a pathname
 or ÿnilþ.  The value of ÿ*compile-file-truename*þ must always be a
physical pathname or ÿnilþ.

Initial Value:
..............

ÿnilþ.

Description:
............

During a call to ÿcompile-fileþ, ÿ*compile-file-pathname*þ is bound to
the pathname denoted by the first argument to ÿcompile-fileþ, merged
against the defaults; that is, it is bound to ÿ(pathname
(merge-pathnames INPUT-FILE))þ.  During the same time interval,
ÿ*compile-file-truename*þ is bound to the truename of the file being
compiled.

At other times, the value of these variables is ÿnilþ.

If a break loop is entered while ÿcompile-fileþ is ongoing, it is
implementation-dependent whether these variables retain the values they
had just prior to entering the break loop or whether they are bound to
ÿnilþ.

The consequences are unspecified if an attempt is made to assign or
bind either of these variables.

Affected By:
............

The file system.

See Also:
.........

*Note compile-file::


File: chris-ansicl.info,  Node: *load-pathname*; *load-truename*,  Next: *compile-print*; *compile-verbose*,  Prev: *compile-file-pathname*; *compile-file-truename*,  Up: System Construction

*load-pathname*, *load-truename* (Variable)
===========================================

Value Type:
...........

The value of ÿ*load-pathname*þ must always be a pathname          or
ÿnilþ.  The value of ÿ*load-truename*þ must always be a physical
pathname or ÿnilþ.

Initial Value:
..............

ÿnilþ.

Description:
............

During a call to ÿloadþ, ÿ*load-pathname*þ is bound to the pathname
denoted by the the first argument to ÿloadþ, merged against the
defaults; that is, it is bound to ÿ(pathname (merge-pathnames
FILESPEC))þ.  During the same time interval, ÿ*load-truename*þ is bound
to the truename of the file being loaded.

At other times, the value of these variables is ÿnilþ.

If a break loop is entered while ÿloadþ is ongoing, it is
implementation-dependent whether these variables retain the values they
had just prior to entering the break loop or whether they are bound to
ÿnilþ.

The consequences are unspecified if an attempt is made to assign or
bind either of these variables.

Affected By:
............

The file system.

See Also:
.........

*Note load::


File: chris-ansicl.info,  Node: *compile-print*; *compile-verbose*,  Next: *load-print*; *load-verbose*,  Prev: *load-pathname*; *load-truename*,  Up: System Construction

*compile-print*, *compile-verbose* (Variable)
=============================================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ÿ*compile-print*þ   is the default value of the :print
argument to ÿcompile-fileþ.  The value of ÿ*compile-verbose*þ is the
default value of the :verbose argument to ÿcompile-fileþ.

See Also:
.........

*Note compile-file::


File: chris-ansicl.info,  Node: *load-print*; *load-verbose*,  Next: *modules*,  Prev: *compile-print*; *compile-verbose*,  Up: System Construction

*load-print*, *load-verbose* (Variable)
=======================================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

The initial value of ÿ*load-print*þ   is false.  The initial value of
ÿ*load-verbose*þ is implementation-dependent.

Description:
............

The value of ÿ*load-print*þ   is the default value of the :print
argument   to ÿloadþ.  The value of ÿ*load-verbose*þ is the default
value of the :verbose argument to ÿloadþ.

See Also:
.........

*Note load::


File: chris-ansicl.info,  Node: *modules*,  Next: provide; require,  Prev: *load-print*; *load-verbose*,  Up: System Construction

*modules* (Variable)
====================

Value Type:
...........

a list of strings.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ÿ*modules*þ is a list of names of the modules that have
been loaded into the current Lisp image.

Affected By:
............

ÿprovideþ

See Also:
.........

*Note provide::, *Note require::

Notes:
......

The variable ÿ*modules*þ is deprecated.


File: chris-ansicl.info,  Node: provide; require,  Prev: *modules*,  Up: System Construction

provide, require (Function)
===========================

Syntax:
.......

 -- Function: provide module-name ý implementation-dependent

 -- Function: require module-name &optional pathname-list ý
          implementation-dependent

Arguments and Values:
.....................

MODULE-NAME--a string designator.

PATHNAME-LIST--ÿnilþ, or a designator for a non-empty list of pathname
designators.  The default is ÿnilþ.

Description:
............

ÿprovideþ adds the MODULE-NAME to the list held by ÿ*modules*þ, if such
a name is not already present.

ÿrequireþ tests for the presence of the MODULE-NAME in the list held by
ÿ*modules*þ.  If it is present, ÿrequireþ immediately returns.
Otherwise, an attempt is made to load an appropriate set of files as
follows: The PATHNAME-LIST argument, if non-nil, specifies a list of
pathnames to be loaded in order, from left to right.  If the
PATHNAME-LIST is ÿnilþ, an implementation-dependent mechanism will be
invoked in an attempt to load the module named MODULE-NAME; if no such
module can be loaded, an error of type ÿerrorþ is signaled.

Both functions use ÿstring=þ to test for the presence of a MODULE-NAME.

Examples:
.........

;;; This illustrates a nonportable use of REQUIRE, because it
;;; depends on the implementation-dependent file-loading mechanism.

(require "CALCULUS")

;;; This use of REQUIRE is nonportable because of the literal
;;; physical pathname.

(require "CALCULUS" "/usr/lib/lisp/calculus")

;;; One form of portable usage involves supplying a logical pathname,
;;; with appropriate translations defined elsewhere.

(require "CALCULUS" "lib:calculus")

;;; Another form of portable usage involves using a variable or
;;; table lookup function to determine the pathname, which again
;;; must be initialized elsewhere.

(require "CALCULUS" *calculus-module-pathname*)

Side Effects:
.............

ÿprovideþ modifies ÿ*modules*þ.

Affected By:
............

The specific action taken by ÿrequireþ is affected by calls to ÿprovideþ
(or, in general, any changes to the value of ÿ*modules*þ).

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if MODULE-NAME is not a
string designator.

If ÿrequireþ fails to perform the requested operation due to a problem
while interacting with the file system, an error of type ÿfile-errorþ
is signaled.

An error of type ÿfile-errorþ might be signaled if any pathname in
PATHNAME-LIST is a designator for a wild pathname.

See Also:
.........

*Note *modules*::, *Note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.

Notes:
......

The functions ÿprovideþ and ÿrequireþ are deprecated.

If a module consists of a single package, it is customary for the
package and module names to be the same.


File: chris-ansicl.info,  Node: Environment,  Next: Glossary,  Prev: System Construction,  Up: Top

25 Environment
**************

* Menu:

* The External Environment::

Dictionary

* decode-universal-time::
* encode-universal-time::
* get-universal-time; get-decoded-time::
* sleep::
* apropos; apropos-list::
* describe::
* describe-object::
* trace; untrace::
* step::
* time (Macro)::
* internal-time-units-per-second::
* get-internal-real-time::
* get-internal-run-time::
* disassemble::
* documentation; setf documentation::
* room::
* ed::
* inspect::
* dribble::
* - (Variable)::
* +; ++; +++::
* *; **; ***::
* /; //; ///::
* lisp-implementation-type; lisp-implementation-version::
* short-site-name; long-site-name::
* machine-instance::
* machine-type::
* machine-version::
* software-type; software-version::
* user-homedir-pathname::


File: chris-ansicl.info,  Node: The External Environment,  Next: decode-universal-time,  Up: Environment

25.1 The External Environment
=============================

* Menu:

* Top level loop::
* Debugging Utilities::
* Environment Inquiry::
* Time::


File: chris-ansicl.info,  Node: Top level loop,  Next: Debugging Utilities,  Up: The External Environment

25.1.1 Top level loop
---------------------

The top level loop is the Common Lisp mechanism by which the user
normally interacts with the Common Lisp system. This loop is sometimes
referred to as the Lisp read-eval-print loop because it typically
consists of an endless loop that reads an expression, evaluates it and
prints the results.

The top level loop is not completely specified; thus the user interface
is implementation-defined.  The top level loop prints all values
resulting from the evaluation of a form.  The next figure lists
variables that are maintained by the Lisp read-eval-print loop.

*     +     /     -
**    ++    //    
***   +++   ///   

Figure 25.1: Variables maintained by the Read-Eval-Print Loop


File: chris-ansicl.info,  Node: Debugging Utilities,  Next: Environment Inquiry,  Prev: Top level loop,  Up: The External Environment

25.1.2 Debugging Utilities
--------------------------

The next figure shows defined names relating to debugging.

*debugger-hook*   documentation     step
apropos           dribble           time
apropos-list      ed                trace
break             inspect           untrace
describe          invoke-debugger   

Figure 25.2: Defined names relating to debugging


File: chris-ansicl.info,  Node: Environment Inquiry,  Next: Time,  Prev: Debugging Utilities,  Up: The External Environment

25.1.3 Environment Inquiry
--------------------------

Environment inquiry defined names provide information about the
hardware and software configuration on which a Common Lisp program is
being executed.

The next figure shows defined names relating to environment inquiry.

*features*                    machine-instance   short-site-name
lisp-implementation-type      machine-type       software-type
lisp-implementation-version   machine-version    software-version
long-site-name                room               

Figure 25.3: Defined names relating to environment inquiry.


File: chris-ansicl.info,  Node: Time,  Prev: Environment Inquiry,  Up: The External Environment

25.1.4 Time
-----------

Time is represented in four different ways in Common Lisp: decoded time,
universal time, internal time, and seconds.  Decoded time and universal
time are used primarily to represent calendar time, and are precise
only to one second.  Internal time is used primarily to represent
measurements of computer time (such as run time) and is precise to some
implementation-dependent fraction of a second called an internal time
unit, as specified by ÿinternal-time-units-per-secondþ.  An internal
time can be used for either absolute and relative time measurements.
Both a universal time and a decoded time can be used only for absolute
time measurements.  In the case of one function, ÿsleepþ, time
intervals are represented as a non-negative real number of seconds.

The next figure shows defined names relating to time.

decode-universal-time    get-internal-run-time
encode-universal-time    get-universal-time
get-decoded-time         internal-time-units-per-second
get-internal-real-time   sleep

Figure 25.4: Defined names involving Time.

25.1.4.1 Decoded Time
.....................

A "decoded time" is an ordered series of nine values that, taken
together, represent a point in calendar time (ignoring leap seconds):

Second
     An integer between 0 and 59, inclusive.

Minute
     An integer between 0 and 59, inclusive.

Hour
     An integer between 0 and 23, inclusive.

Date
     An integer between 1 and 31, inclusive (the upper limit actually
     depends on the month and year, of course).

Month
     An integer between 1 and 12, inclusive; 1 means January, 2 means
     February, and so on; 12 means December.

Year
     An integer indicating the year A.D.  However, if this integer is
     between 0 and 99, the "obvious" year is used; more precisely, that
     year is assumed that is equal to the integer modulo 100 and within
     fifty years of the current year (inclusive backwards and exclusive
     forwards).  Thus, in the year 1978, year 28 is 1928 but year 27 is
     2027.  (Functions that return time in this format always return a
     full year number.)

Day of week
     An integer between 0 and 6, inclusive; 0 means Monday, 1 means
     Tuesday, and so on; 6 means Sunday.

Daylight saving time flag
     A generalized boolean that, if true, indicates that daylight
     saving time is in effect.

Time zone
     A time zone.

The next figure shows defined names relating to decoded time.

decode-universal-time   get-decoded-time

Figure 25.5: Defined names involving time in Decoded Time.

25.1.4.2 Universal Time
.......................

"Universal time" is an absolute time represented as a single
non-negative integer--the number of seconds since midnight, January 1,
1900 GMT (ignoring leap seconds).  Thus the time 1 is 00:00:01 (that
is, 12:00:01 a.m.) on January 1, 1900 GMT.  Similarly, the time
2398291201 corresponds to time 00:00:01 on January 1, 1976 GMT.  Recall
that the year 1900 was not a leap year; for the purposes of Common
Lisp, a year is a leap year if and only if its number is divisible by 4,
except that years divisible by 100 are not leap years, except that years
divisible by 400 are leap years.  Therefore the year 2000 will be a
leap year.  Because universal time must be a non-negative integer,
times before the base time of midnight, January 1, 1900 GMT cannot be
processed by Common Lisp.

decode-universal-time   get-universal-time
encode-universal-time   

Figure 25.6: Defined names involving time in Universal Time.

25.1.4.3 Internal Time
......................

"Internal time" represents time as a single integer, in terms of an
implementation-dependent unit called an internal time unit.  Relative
time is measured as a number of these units.  Absolute time is relative
to an arbitrary time base.

The next figure shows defined names related to internal time.

get-internal-real-time   internal-time-units-per-second
get-internal-run-time    

Figure 25.7: Defined names involving time in Internal Time.

25.1.4.4 Seconds
................

One function, ÿsleepþ, takes its argument as a non-negative real number
of seconds.  Informally, it may be useful to think of this as a
relative universal time, but it differs in one important way: universal
times are always non-negative integers, whereas the argument to ÿsleepþ
can be any kind of non-negative real, in order to allow for the
possibility of fractional seconds.

sleep   

Figure 25.8: Defined names involving time in Seconds.


File: chris-ansicl.info,  Node: decode-universal-time,  Next: encode-universal-time,  Prev: The External Environment,  Up: Environment

decode-universal-time (Function)
================================

Syntax:
.......

 -- Function: decode-universal-time universal-time &optional time-zone
          ý second, minute, hour, date, month, year, day, daylight-p,
          zone

Arguments and Values:
.....................

UNIVERSAL-TIME--a universal time.

TIME-ZONE--a time zone.

SECOND, MINUTE, HOUR, DATE, MONTH, YEAR, DAY, DAYLIGHT-P, ZONE--a
decoded time.

Description:
............

Returns the decoded time represented by the given universal time.

If TIME-ZONE is not supplied, it defaults to the current time zone
adjusted for daylight saving time.  If TIME-ZONE is supplied, daylight
saving time information is ignored.  The daylight saving time flag is
ÿnilþ if TIME-ZONE is supplied.

Examples:
.........

 (decode-universal-time 0 0) ý 0, 0, 0, 1, 1, 1900, 0, false, 0

;; The next two examples assume Eastern Daylight Time.
 (decode-universal-time 2414296800 5) ý 0, 0, 1, 4, 7, 1976, 6, false, 5
 (decode-universal-time 2414293200) ý 0, 0, 1, 4, 7, 1976, 6, true, 5

;; This example assumes that the time zone is Eastern Daylight Time
;; (and that the time zone is constant throughout the example).
 (let* ((here (nth 8 (multiple-value-list (get-decoded-time)))) ;Time zone
        (recently (get-universal-time))
        (a (nthcdr 7 (multiple-value-list (decode-universal-time recently))))
        (b (nthcdr 7 (multiple-value-list (decode-universal-time recently here)))))
   (list a b (equal a b))) ý ((T 5) (NIL 5) NIL)

Affected By:
............

Implementation-dependent mechanisms for calculating when or if daylight
savings time is in effect for any given session.

See Also:
.........

*Note encode-universal-time::, *Note get-universal-time::, *Note
Section 25.1.4 (Time): Time.


File: chris-ansicl.info,  Node: encode-universal-time,  Next: get-universal-time; get-decoded-time,  Prev: decode-universal-time,  Up: Environment

encode-universal-time (function)
================================

Syntax:
.......

 -- Function: encode-universal-time second minute hour date month year
          &optional time-zone ý universal-time

Arguments and Values:
.....................

SECOND, MINUTE, HOUR, DATE, MONTH, YEAR, TIME-ZONE--the corresponding
parts of a decoded time.  (Note that some of the nine values in a full
decoded time are redundant, and so are not used as inputs to this
function.)

UNIVERSAL-TIME--a universal time.

Description:
............

ÿencode-universal-timeþ converts a time from Decoded Time format to a
universal time.

If TIME-ZONE is supplied, no adjustment for daylight savings time is
performed.

Examples:
.........

 (encode-universal-time 0 0 0 1 1 1900 0) ý 0
 (encode-universal-time 0 0 1 4 7 1976 5) ý 2414296800
;; The next example assumes Eastern Daylight Time.
 (encode-universal-time 0 0 1 4 7 1976) ý 2414293200

See Also:
.........

*Note decode-universal-time::, *Note get-decoded-time::


File: chris-ansicl.info,  Node: get-universal-time; get-decoded-time,  Next: sleep,  Prev: encode-universal-time,  Up: Environment

get-universal-time, get-decoded-time (Function)
===============================================

Syntax:
.......

 -- Function: get-universal-time <no arguments> ý universal-time

 -- Function: get-decoded-time <no arguments> ý second, minute, hour,
          date, month, year, day, daylight-p, zone

Arguments and Values:
.....................

UNIVERSAL-TIME--a universal time.

SECOND, MINUTE, HOUR, DATE, MONTH, YEAR, DAY, DAYLIGHT-P, ZONE--a
decoded time.

Description:
............

ÿget-universal-timeþ returns the current time, represented as a
universal time.

ÿget-decoded-timeþ returns the current time, represented as a decoded
time.

Examples:
.........

;; At noon on July 4, 1976 in Eastern Daylight Time.
 (get-decoded-time) ý 0, 0, 12, 4, 7, 1976, 6, true, 5
;; At exactly the same instant.
 (get-universal-time) ý 2414332800
;; Exactly five minutes later.
 (get-universal-time) ý 2414333100
;; The difference is 300 seconds (five minutes)
 (- * **) ý 300

Affected By:
............

The time of day (i.e., the passage of time), the system clock's ability
to keep accurate time, and the accuracy of the system clock's initial
setting.

Exceptional Situations:
.......................

An error of type ÿerrorþ might be signaled if the current time cannot
be determined.

See Also:
.........

*Note decode-universal-time::, *Note encode-universal-time::, *Note
Section 25.1.4 (Time): Time.

Notes:
......

 (get-decoded-time) Õ (decode-universal-time (get-universal-time))

No implementation is required to have a way to verify that the time
returned is correct.  However, if an implementation provides a validity
check (e.g., the failure to have properly initialized the system clock
can be reliably detected) and that validity check fails, the
implementation is strongly encouraged (but not required) to signal an
error of type ÿerrorþ (rather than, for example, returning a
known-to-be-wrong value) that is correctable by allowing the user to
interactively set the correct time.


File: chris-ansicl.info,  Node: sleep,  Next: apropos; apropos-list,  Prev: get-universal-time; get-decoded-time,  Up: Environment

sleep (Function)
================

Syntax:
.......

 -- Function: sleep seconds ý ÿnilþ

Arguments and Values:
.....................

SECONDS--a non-negative real.

Description:
............

Causes execution to cease and become dormant for approximately the
seconds of real time indicated by SECONDS, whereupon execution is
resumed.

Examples:
.........

 (sleep 1) ý NIL

;; Actually, since SLEEP is permitted to use approximate timing,
;; this might not always yield true, but it will often enough that
;; we felt it to be a productive example of the intent.
 (let ((then (get-universal-time))
       (now  (progn (sleep 10) (get-universal-time))))
   (>= (- now then) 10))
ý true

Side Effects:
.............

Causes processing to pause.

Affected By:
............

The granularity of the scheduler.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if SECONDS is not a
non-negative real.


File: chris-ansicl.info,  Node: apropos; apropos-list,  Next: describe,  Prev: sleep,  Up: Environment

apropos, apropos-list (Function)
================================

Syntax:
.......

 -- Function: apropos string &optional package ý <no values>

 -- Function: apropos-list string &optional package ý symbols

Arguments and Values:
.....................

STRING--a string designator.

PACKAGE--a package designator or ÿnilþ.  The default is ÿnilþ.

SYMBOLS--a list of symbols.

Description:
............

These functions search for interned symbols whose names contain the
substring STRING.

For ÿaproposþ, as each such symbol is found, its name is printed on
standard output.  In addition, if such a symbol is defined as a
function or dynamic variable, information about those definitions might
also be printed.

For ÿapropos-listþ, no output occurs as the search proceeds; instead a
list of the matching symbols is returned when the search is complete.

If PACKAGE is non-nil, only the symbols accessible in that PACKAGE are
searched; otherwise all symbols accessible in any package are searched.

Because a symbol might be available by way of more than one inheritance
path, ÿaproposþ might print information about the same symbol more than
once, or ÿapropos-listþ might return a list containing duplicate
symbols.

Whether or not the search is case-sensitive is implementation-defined.

Affected By:
............

The set of symbols which are currently interned in any packages being
searched.

ÿaproposþ is also affected by ÿ*standard-output*þ.


File: chris-ansicl.info,  Node: describe,  Next: describe-object,  Prev: apropos; apropos-list,  Up: Environment

describe (Function)
===================

Syntax:
.......

 -- Function: describe object &optional stream ý <no values>

Arguments and Values:
.....................

OBJECT--an object.

STREAM--an output stream designator.  The default is standard output.

Description:
............

ÿdescribeþ displays information about OBJECT to STREAM.

For example, ÿdescribeþ of a symbol might show the symbol's value, its
definition, and each of its properties.  ÿdescribeþ of a float might
show the number's internal representation in a way that is useful for
tracking down round-off errors.  In all cases, however, the nature and
format of the output of ÿdescribeþ is implementation-dependent.

ÿdescribeþ can describe something that it finds inside the OBJECT; in
such cases, a notational device such as increased indentation or
positioning in a table is typically used in order to visually
distinguish such recursive descriptions from descriptions of the
argument OBJECT.

The actual act of describing the object is implemented by
ÿdescribe-objectþ.  ÿdescribeþ exists as an interface primarily to
manage argument defaulting (including conversion of arguments ÿtþ and
ÿnilþ into stream objects) and to inhibit any return values from
ÿdescribe-objectþ.

ÿdescribeþ is not intended to be an interactive function.  In a
conforming implementation, ÿdescribeþ must not, by default, prompt for
user input.  User-defined methods for ÿdescribe-objectþ are likewise
restricted.

Side Effects:
.............

Output to standard output or terminal I/O.

Affected By:
............

ÿ*standard-output*þ and ÿ*terminal-io*þ, methods on ÿdescribe-objectþ
and ÿprint-objectþ for objects having user-defined classes.

See Also:
.........

*Note inspect::, *Note describe-object::


File: chris-ansicl.info,  Node: describe-object,  Next: trace; untrace,  Prev: describe,  Up: Environment

describe-object (Standard Generic Function)
===========================================

Syntax:
.......

 -- Generic Function: describe-object object stream ý
          implementation-dependent

Method Signatures:
..................

describe-object (OBJECT standard-object) STREAM

Arguments and Values:
.....................

OBJECT--an object.

STREAM--a stream.

Description:
............

The generic function ÿdescribe-objectþ prints a description of OBJECT
to a STREAM.  ÿdescribe-objectþ is called by ÿdescribeþ; it must not be
called by the user.

Each implementation is required to provide a method on the class
ÿstandard-objectþ and methods on enough other classes so as to ensure
that there is always an applicable method.  Implementations are free to
add methods for other classes.  Users can write methods for
ÿdescribe-objectþ for their own classes if they do not wish to inherit
an implementation-supplied method.

Methods on ÿdescribe-objectþ can recursively call ÿdescribeþ.
Indentation, depth limits, and circularity detection are all taken care
of automatically, provided that each method handles exactly one level
of structure and calls ÿdescribeþ recursively if there are more
structural levels.  The consequences are undefined if this rule is not
obeyed.

In some implementations the STREAM argument passed to a
ÿdescribe-objectþ method is not the original STREAM, but is an
intermediate stream that implements parts of ÿdescribeþ.  Methods
should therefore not depend on the identity of this stream.

Examples:
.........

 (defclass spaceship ()
   ((captain :initarg :captain :accessor spaceship-captain)
    (serial# :initarg :serial-number :accessor spaceship-serial-number)))

 (defclass federation-starship (spaceship) ())

 (defmethod describe-object ((s spaceship) stream)
   (with-slots (captain serial#) s
     (format stream "~&~S is a spaceship of type ~S,~
                     ~%with ~A at the helm ~
                       and with serial number ~D.~%"
             s (type-of s) captain serial#)))

 (make-instance 'federation-starship
                :captain "Rachel Garrett"
                :serial-number "NCC-1701-C")
ý #<FEDERATION-STARSHIP 26312465>

 (describe *)
Ö #<FEDERATION-STARSHIP 26312465> is a spaceship of type FEDERATION-STARSHIP,
Ö with Rachel Garrett at the helm and with serial number NCC-1701-C.
ý <no values>

See Also:
.........

*Note describe::

Notes:
......

The same implementation techniques that are applicable to
ÿprint-objectþ are applicable to ÿdescribe-objectþ.

The reason for making the return values for ÿdescribe-objectþ
unspecified is to  avoid forcing users to include explicit ÿ(values)þ
in all of their methods.  ÿdescribeþ takes care of that.


File: chris-ansicl.info,  Node: trace; untrace,  Next: step,  Prev: describe-object,  Up: Environment

trace, untrace (Macro)
======================

Syntax:
.......

 -- Macro: trace {function-name}* ý trace-result

 -- Macro: untrace {function-name}* ý untrace-result

Arguments and Values:
.....................

FUNCTION-NAME--a function name.

TRACE-RESULT--implementation-dependent, unless no function-names are
supplied, in which case TRACE-RESULT is a list of function names.

UNTRACE-RESULT--implementation-dependent.

Description:
............

ÿtraceþ and ÿuntraceþ control the invocation of the trace facility.

Invoking ÿtraceþ with one or more FUNCTION-NAMES causes the denoted
functions to be "traced."  Whenever a traced function is invoked,
information about the call, about the arguments passed, and about any
eventually returned values is printed to trace output.  If ÿtraceþ is
used with no FUNCTION-NAMES, no tracing action is performed; instead, a
list of the functions currently being traced is returned.

Invoking ÿuntraceþ with one or more function names causes those
functions to be "untraced" (i.e., no longer traced).  If ÿuntraceþ is
used with no FUNCTION-NAMES, all functions currently being traced are
untraced.

If a function to be traced has been open-coded (e.g., because it was
declared ÿinlineþ), a call to that function might not produce trace
output.

Examples:
.........

 (defun fact (n) (if (zerop n) 1 (* n (fact (- n 1)))))
ý FACT
 (trace fact)
ý (FACT)
;; Of course, the format of traced output is implementation-dependent.
 (fact 3)
Ö 1 Enter FACT 3
Ö | 2 Enter FACT 2
Ö |   3 Enter FACT 1
Ö |   | 4 Enter FACT 0
Ö |   | 4 Exit FACT 1
Ö |   3 Exit FACT 1
Ö | 2 Exit FACT 2
Ö 1 Exit FACT 6
ý 6

Side Effects:
.............

Might change the definitions of the functions named by FUNCTION-NAMES.

Affected By:
............

Whether the functions named are defined or already being traced.

Exceptional Situations:
.......................

Tracing an already traced function, or untracing a function not
currently being traced, should produce no harmful effects, but might
signal a warning.

See Also:
.........

*Note *trace-output*::, *Note step::

Notes:
......

ÿtraceþ and ÿuntraceþ may also accept additional
implementation-dependent argument formats.  The format of the trace
output is implementation-dependent.

Although ÿtraceþ can be extended to permit non-standard options,
implementations are nevertheless encouraged (but not required) to warn
about the use of syntax or options that are neither specified by this
standard nor added as an extension by the implementation, since they
could be symptomatic of typographical errors or of reliance on features
supported in implementations other than the current implementation.


File: chris-ansicl.info,  Node: step,  Next: time (Macro),  Prev: trace; untrace,  Up: Environment

step (Macro)
============

Syntax:
.......

 -- Macro: step form ý {result}*

Arguments and Values:
.....................

FORM--a form; evaluated as described below.

RESULTS--the values returned by the FORM.

Description:
............

ÿstepþ implements a debugging paradigm wherein the programmer is
allowed to step through the evaluation of a form.  The specific nature
of the interaction, including which I/O streams are used and whether
the stepping has lexical or dynamic scope, is implementation-defined.

ÿstepþ evaluates FORM in the current environment.  A call to ÿstepþ can
be compiled, but it is acceptable for an implementation to
interactively step through only those parts of the computation that are
interpreted.

It is technically permissible for a conforming implementation to take
no action at all other than normal execution of the FORM.  In such a
situation, ÿ(step form)þ is equivalent to, for example, ÿ(let () form)þ.
In implementations where this is the case, the associated documentation
should mention that fact.

See Also:
.........

*Note trace::

Notes:
......

Implementations are encouraged to respond to the typing of ÿ?þ or the
pressing of a "help key" by providing help including a list of commands.


File: chris-ansicl.info,  Node: time (Macro),  Next: internal-time-units-per-second,  Prev: step,  Up: Environment

time (Macro)
============

Syntax:
.......

 -- Macro: time form ý {result}*

Arguments and Values:
.....................

FORM--a form; evaluated as described below.

RESULTS--the values returned by the FORM.

Description:
............

ÿtimeþ evaluates FORM in the current environment (lexical and dynamic).
A call to ÿtimeþ can be compiled.

ÿtimeþ prints various timing data and other information to trace output.
The nature and format of the printed information is
implementation-defined.  Implementations are encouraged to provide such
information as elapsed real time, machine run time, and storage
management statistics.

Affected By:
............

The accuracy of the results depends, among other things, on the accuracy
of the corresponding functions provided by the underlying operating
system.

The magnitude of the results may depend on the hardware, the operating
system, the lisp implementation, and the state of the global
environment.  Some specific issues which frequently affect the outcome
are hardware speed, nature of the scheduler (if any), number of
competing processes (if any), system paging, whether the call is
interpreted or compiled, whether functions called are compiled, the
kind of garbage collector involved and whether it runs, whether
internal data structures (e.g., hash tables) are implicitly reorganized,
etc.

See Also:
.........

*Note get-internal-real-time::, *Note get-internal-run-time::

Notes:
......

In general, these timings are not guaranteed to be reliable enough for
marketing comparisons. Their value is primarily heuristic, for tuning
purposes.

For useful background information on the complicated issues involved in
interpreting timing results, see `Performance and Evaluation of Lisp
Programs'.


File: chris-ansicl.info,  Node: internal-time-units-per-second,  Next: get-internal-real-time,  Prev: time (Macro),  Up: Environment

internal-time-units-per-second (Constant Variable)
==================================================

Constant Value:
...............

A positive integer, the magnitude of which is implementation-dependent.

Description:
............

The number of internal time units in one second.

See Also:
.........

*Note get-internal-run-time::, *Note get-internal-real-time::

Notes:
......

These units form the basis of the Internal Time format representation.


File: chris-ansicl.info,  Node: get-internal-real-time,  Next: get-internal-run-time,  Prev: internal-time-units-per-second,  Up: Environment

get-internal-real-time (Function)
=================================

Syntax:
.......

 -- Function: get-internal-real-time <no arguments> ý internal-time

Arguments and Values:
.....................

INTERNAL-TIME--a non-negative integer.

Description:
............

ÿget-internal-real-timeþ returns as an integer the current time in
internal time units, relative to an arbitrary time base.  The
difference between the values of two calls to this function is the
amount of elapsed real time (i.e., clock time) between the two calls.

Affected By:
............

Time of day (i.e., the passage of time).  The time base affects the
result magnitude.

See Also:
.........

*Note internal-time-units-per-second::


File: chris-ansicl.info,  Node: get-internal-run-time,  Next: disassemble,  Prev: get-internal-real-time,  Up: Environment

get-internal-run-time (Function)
================================

Syntax:
.......

 -- Function: get-internal-run-time <no arguments> ý internal-time

Arguments and Values:
.....................

INTERNAL-TIME--a non-negative integer.

Description:
............

Returns as an integer the current run time in internal time units.  The
precise meaning of this quantity is implementation-defined;  it may
measure real time, run time, CPU cycles, or some other quantity.  The
intent is that the difference between the values of two calls to this
function be the amount of time between the two calls during which
computational effort was expended on behalf of the executing program.

Affected By:
............

The implementation, the time of day (i.e., the passage of time).

See Also:
.........

*Note internal-time-units-per-second::

Notes:
......

Depending on the implementation, paging time and garbage collection
time might be included in this measurement.  Also, in a multitasking
environment, it might not be possible to show the time for just the
running process, so in some implementations, time taken by other
processes during the same time interval might be included in this
measurement as well.


File: chris-ansicl.info,  Node: disassemble,  Next: documentation; setf documentation,  Prev: get-internal-run-time,  Up: Environment

disassemble (Function)
======================

Syntax:
.......

 -- Function: disassemble fn ý ÿnilþ

Arguments and Values:
.....................

FN--an extended function designator or a lambda expression.

Description:
............

The function ÿdisassembleþ is a debugging aid that composes symbolic
instructions or expressions in some implementation-dependent language
which represent the code used to produce the function which is or is
named by the argument FN.  The result is displayed to standard output
in an implementation-dependent format.

If FN is a lambda expression or interpreted function, it is compiled
first and the result is disassembled.

If the FN designator is a function name, the function that it names is
disassembled.  (If that function is an interpreted function, it is
first compiled but the result of this implicit compilation is not
installed.)

Examples:
.........

 (defun f (a) (1+ a)) ý F
 (eq (symbol-function 'f)
     (progn (disassemble 'f)
            (symbol-function 'f))) ý true

Affected By:
............

ÿ*standard-output*þ.

Exceptional Situations:
.......................

Should signal an error of type ÿtype-errorþ if FN is not an extended
function designator or a lambda expression.


File: chris-ansicl.info,  Node: documentation; setf documentation,  Next: room,  Prev: disassemble,  Up: Environment

documentation, (setf documentation) (Standard Generic Function)
===============================================================

Syntax:
.......

 -- Generic Function: documentation x doc-type ý documentation

 -- Generic Function: (setf documentation) new-value x doc-type ý
          new-value

Argument Precedence Order:
..........................

DOC-TYPE, OBJECT

Method Signatures:
..................

Functions, Macros, and Special Forms

documentation (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ) symbol

documentation (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ) symbol

documentation (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ) symbol

documentation (X ÿlistþ) (DOC-TYPE ÿ(eql 'list)þ) list

documentation (X ÿlistþ) (DOC-TYPE ÿ(eql 'list)þ) list

documentation (X ÿfunctionþ) (DOC-TYPE ÿ(eql 'function)þ) function

documentation (X ÿfunctionþ) (DOC-TYPE ÿ(eql 'function)þ) function

(setf documentation) NEW-VALUE (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ)
symbol

(setf documentation) NEW-VALUE (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ)
symbol

(setf documentation) NEW-VALUE (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ)
symbol

(setf documentation) NEW-VALUE (X ÿlistþ) (DOC-TYPE ÿ(eql 'list)þ) list

(setf documentation) NEW-VALUE (X ÿlistþ) (DOC-TYPE ÿ(eql 'list)þ) list

(setf documentation) NEW-VALUE (X ÿfunctionþ) (DOC-TYPE ÿ(eql
'function)þ) function

(setf documentation) NEW-VALUE (X ÿfunctionþ) (DOC-TYPE ÿ(eql
'function)þ) function

Method Combinations

documentation (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ) symbol

documentation (X ÿmethod-combinationþ) (DOC-TYPE ÿ(eql
'method-combination)þ) method-combination

documentation (X ÿmethod-combinationþ) (DOC-TYPE ÿ(eql
'method-combination)þ) method-combination

(setf documentation) NEW-VALUE (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ)
symbol

(setf documentation) NEW-VALUE (X ÿmethod-combinationþ) (DOC-TYPE ÿ(eql
'method-combination)þ) method-combination

(setf documentation) NEW-VALUE (X ÿmethod-combinationþ) (DOC-TYPE ÿ(eql
'method-combination)þ) method-combination

Methods

documentation (X ÿstandard-methodþ) (DOC-TYPE ÿ(eql 'standard-method)þ)
standard-method

(setf documentation) NEW-VALUE (X ÿstandard-methodþ) (DOC-TYPE ÿ(eql
'standard-method)þ) standard-method

Packages

documentation (X ÿpackageþ) (DOC-TYPE ÿ(eql 'package)þ) package

(setf documentation) NEW-VALUE (X ÿpackageþ) (DOC-TYPE ÿ(eql
'package)þ) package

Types, Classes, and Structure Names

documentation (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ) symbol

documentation (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ) symbol

documentation (X ÿstructure-classþ) (DOC-TYPE ÿ(eql 'structure-class)þ)
structure-class

documentation (X ÿstructure-classþ) (DOC-TYPE ÿ(eql 'structure-class)þ)
structure-class

documentation (X ÿstandard-classþ) (DOC-TYPE ÿ(eql 'standard-class)þ)
standard-class

documentation (X ÿstandard-classþ) (DOC-TYPE ÿ(eql 'standard-class)þ)
standard-class

(setf documentation) NEW-VALUE (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ)
symbol

(setf documentation) NEW-VALUE (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ)
symbol

(setf documentation) NEW-VALUE (X ÿstructure-classþ) (DOC-TYPE ÿ(eql
'structure-class)þ) structure-class

(setf documentation) NEW-VALUE (X ÿstructure-classþ) (DOC-TYPE ÿ(eql
'structure-class)þ) structure-class

(setf documentation) NEW-VALUE (X ÿstandard-classþ) (DOC-TYPE ÿ(eql
'standard-class)þ) standard-class

(setf documentation) NEW-VALUE (X ÿstandard-classþ) (DOC-TYPE ÿ(eql
'standard-class)þ) standard-class

Variables

documentation (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ) symbol

(setf documentation) NEW-VALUE (X ÿsymbolþ) (DOC-TYPE ÿ(eql 'symbol)þ)
symbol

Arguments and Values:
.....................

X--an object.

DOC-TYPE--a symbol.

DOCUMENTATION--a string, or ÿnilþ.

NEW-VALUE--a string.

Description:
............

The generic function ÿdocumentationþ returns the documentation string
associated with the given object if it is available; otherwise it
returns ÿnilþ.

The generic function ÿ(setf documentation)þ updates the documentation
string associated with X to NEW-VALUE.  If X is a list, it must be of
the form ÿ(setf SYMBOL)þ.

Documentation strings are made available for debugging purposes.
Conforming programs are permitted to use documentation strings when
they are present, but should not depend for their correct behavior on
the presence of those documentation strings.  An implementation is
permitted to discard documentation strings at any time for
implementation-defined reasons.

The nature of the documentation string returned depends on the
DOC-TYPE, as follows:

compiler-macro
     Returns the documentation string of the compiler macro whose name
     is the function name X.

function
     If X is a function name, returns the documentation string of the
     function, macro, or special operator whose name is X.

     If X is a function, returns the documentation string associated
     with X.

method-combination
     If X is a symbol, returns the documentation string of the method
     combination whose name is X.

     If X is a method combination, returns the documentation string
     associated with X.

setf
     Returns the documentation string of the setf expander whose name
     is the symbol X.

structure
     Returns the documentation string associated with the structure
     name X.

t
     Returns a documentation string specialized on the class of the
     argument X itself.  For example, if X is a function, the
     documentation string associated with the function X is returned.

type
     If X is a symbol, returns the documentation string of the class
     whose name is the symbol X, if there is such a class.  Otherwise,
     it returns the documentation string of the type which is the type
     specifier symbol X.

     If X is a structure class or standard class, returns the
     documentation string associated with the class X.

variable
     Returns the documentation string of the dynamic variable or
     constant variable whose name is the symbol X.

A conforming implementation or a conforming program may extend the set
of symbols that are acceptable as the DOC-TYPE.

Notes:
......

This standard prescribes no means to retrieve the documentation strings
for individual slots specified in a ÿdefclassþ form, but
implementations might still provide debugging tools and/or programming
language extensions which manipulate this information.  Implementors
wishing to provide such support are encouraged to consult the
Metaobject Protocol for suggestions about how this might be done.


File: chris-ansicl.info,  Node: room,  Next: ed,  Prev: documentation; setf documentation,  Up: Environment

room (Function)
===============

Syntax:
.......

 -- Function: room &optional x ý implementation-dependent

Arguments and Values:
.....................

X--one of ÿtþ, ÿnilþ, or :default.

Description:
............

ÿroomþ prints, to standard output, information about the state of
internal storage and its management.  This might include descriptions
of the amount of memory in use and the degree of memory compaction,
possibly broken down by internal data type if that is appropriate.  The
nature and format of the printed information is
implementation-dependent.  The intent is to provide information that a
programmer might use to tune a program for a particular implementation.

ÿ(room nil)þ prints out a minimal amount of information.  ÿ(room t)þ
prints out a maximal amount of information.  ÿ(room)þ or ÿ(room
:default)þ prints out an intermediate amount of information that is
likely to be useful.

Side Effects:
.............

Output to standard output.

Affected By:
............

ÿ*standard-output*þ.


File: chris-ansicl.info,  Node: ed,  Next: inspect,  Prev: room,  Up: Environment

ed (Function)
=============

Syntax:
.......

 -- Function: ed &optional x ý implementation-dependent

Arguments and Values:
.....................

X--ÿnilþ, a pathname, a string, or a function name.  The default is
ÿnilþ.

Description:
............

ÿedþ invokes the editor if the implementation provides a resident
editor.

If X is ÿnilþ, the editor is entered.  If the editor had been
previously entered, its prior state is resumed, if possible.

If X is a pathname or string, it is taken as the pathname designator
for a file to be edited.

If X is a function name, the text of its definition is edited.  The
means by which the function text is obtained is implementation-defined.

Exceptional Situations:
.......................

The consequences are undefined if the implementation does not provide a
resident editor.

Might signal ÿtype-errorþ if its argument is supplied but is not a
symbol, a pathname, or ÿnilþ.

If a failure occurs when performing some operation on the file system
while attempting to edit a file, an error of type ÿfile-errorþ is
signaled.

An error of type ÿfile-errorþ might be signaled if X is a designator
for a wild pathname.

Implementation-dependent additional conditions might be signaled as
well.

See Also:
.........

*Note pathname (System Class)::, *Note logical-pathname (System
Class)::, *Note compile-file::, *Note load::, *Note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.


File: chris-ansicl.info,  Node: inspect,  Next: dribble,  Prev: ed,  Up: Environment

inspect (Function)
==================

Syntax:
.......

 -- Function: inspect object ý implementation-dependent

Arguments and Values:
.....................

OBJECT--an object.

Description:
............

ÿinspectþ is an interactive version of ÿdescribeþ.  The nature of the
interaction is implementation-dependent, but the purpose of ÿinspectþ
is to make it easy to wander through a data structure, examining and
modifying parts of it.

Side Effects:
.............

implementation-dependent.

Affected By:
............

implementation-dependent.

Exceptional Situations:
.......................

implementation-dependent.

See Also:
.........

*Note describe::

Notes:
......

Implementations are encouraged to respond to the typing of ÿ?þ or a
"help key" by providing help, including a list of commands.


File: chris-ansicl.info,  Node: dribble,  Next: - (Variable),  Prev: inspect,  Up: Environment

dribble (Function)
==================

Syntax:
.......

 -- Function: dribble &optional pathname ý implementation-dependent

Arguments and Values:
.....................

PATHNAME--a pathname designator.

Description:
............

Either binds ÿ*standard-input*þ and ÿ*standard-output*þ or takes other
appropriate action, so as to send a record of the input/output
interaction to a file named by PATHNAME.  ÿdribbleþ is intended to
create a readable record of an interactive session.

If PATHNAME is a logical pathname, it is translated into a physical
pathname as if by calling ÿtranslate-logical-pathnameþ.

ÿ(dribble)þ terminates the recording of input and output and closes the
dribble file.

If ÿdribbleþ is called while a stream to a "dribble file" is still open
from a previous call to ÿdribbleþ, the effect is
implementation-defined.  For example, the already-open stream might be
closed, or dribbling might occur both to the old stream and to a new
one, or the old stream might stay open but not receive any further
output, or the new request might be ignored, or some other action might
be taken.

Affected By:
............

The implementation.

Exceptional Situations:
.......................

If a failure occurs when performing some operation on the file system
while creating the dribble file, an error of type ÿfile-errorþ is
signaled.

An error of type ÿfile-errorþ might be signaled if PATHNAME is a
designator for a wild pathname.

See Also:
.........

*Note Section 19.1.2 (Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

ÿdribbleþ can return before subsequent forms are executed. It also can
enter a recursive interaction loop, returning only when ÿ(dribble)þ is
done.

ÿdribbleþ is intended primarily for interactive debugging; its effect
cannot be relied upon when used in a program.


File: chris-ansicl.info,  Node: - (Variable),  Next: +; ++; +++,  Prev: dribble,  Up: Environment

- (Variable)
============

Value Type:
...........

a form.

Initial Value:
..............

implementation-dependent.

Description:
............

The value of ÿ-þ is the form that is currently being evaluated by the
Lisp read-eval-print loop.

Examples:
.........

(format t "~&Evaluating ~S~%" -)
Ö Evaluating (FORMAT T "~&Evaluating ~S~%" -)
ý NIL

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*Note + (Function):: (variable), *Note * (Function):: (variable), *Note
/ (Function):: (variable), *Note Section 25.1.1 (Top level loop): Top
level loop.


File: chris-ansicl.info,  Node: +; ++; +++,  Next: *; **; ***,  Prev: - (Variable),  Up: Environment

+, ++, +++ (Variable)
=====================

Value Type:
...........

an object.

Initial Value:
..............

implementation-dependent.

Description:
............

The variables ÿ+þ, ++, and +++ are maintained by the Lisp
read-eval-print loop to save forms that were recently evaluated.

The value of ÿ+þ   is the last form that was evaluated, the value of
ÿ++þ  is the previous value of +, and the value of ÿ+++þ is the
previous value of ++.

Examples:
.........

(+ 0 1) ý 1
(- 4 2) ý 2
(/ 9 3) ý 3
(list + ++ +++) ý ((/ 9 3) (- 4 2) (+ 0 1))
(setq a 1 b 2 c 3 d (list a b c)) ý (1 2 3)
(setq a 4 b 5 c 6 d (list a b c)) ý (4 5 6)
(list a b c) ý (4 5 6)
(eval +++) ý (1 2 3)
#.`(,@++ d) ý (1 2 3 (1 2 3))

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*Note - (Function):: (variable), *Note * (Function):: (variable), *Note
/ (Function):: (variable), *Note Section 25.1.1 (Top level loop): Top
level loop.


File: chris-ansicl.info,  Node: *; **; ***,  Next: /; //; ///,  Prev: +; ++; +++,  Up: Environment

*, **, *** (Variable)
=====================

Value Type:
...........

an object.

Initial Value:
..............

implementation-dependent.

Description:
............

The variables ÿ*þ, **, and *** are maintained by the Lisp
read-eval-print loop to save the values of results that are printed
each time through the loop.

The value of ÿ*þ   is the most recent primary value that was printed,
the value of ÿ**þ  is the previous value of *, and the value of ÿ***þ
is the previous value of **.

If several values are produced, * contains the first value only; *
contains ÿnilþ if zero values are produced.

The values of *, **, and *** are updated immediately prior to printing
the return value of a top-level form by the Lisp read-eval-print loop.
If the evaluation of such a form is aborted prior to its normal return,
the values of *, **, and *** are not updated.

Examples:
.........

(values 'a1 'a2) ý A1, A2
'b ý B
(values 'c1 'c2 'c3) ý C1, C2, C3
(list * ** ***) ý (C1 B A1)

(defun cube-root (x) (expt x 1/3)) ý CUBE-ROOT
(compile *) ý CUBE-ROOT
(setq a (cube-root 27.0)) ý 3.0
(* * 9.0) ý 27.0

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*Note - (Function):: (variable), *Note + (Function):: (variable), *Note
/ (Function):: (variable), *Note Section 25.1.1 (Top level loop): Top
level loop.

Notes:
......

 *   Õ (car /)
 **  Õ (car //)
 *** Õ (car ///)


File: chris-ansicl.info,  Node: /; //; ///,  Next: lisp-implementation-type; lisp-implementation-version,  Prev: *; **; ***,  Up: Environment

/, //, /// (Variable)
=====================

Value Type:
...........

a proper list.

Initial Value:
..............

implementation-dependent.

Description:
............

The variables ÿ/þ, //, and /// are maintained by the Lisp
read-eval-print loop to save the values of results that were printed at
the end of the loop.

The value of ÿ/þ   is a list of the most recent values that were
printed, the value of ÿ//þ  is the previous value of /, and the value
of ÿ///þ is the previous value of //.

The values of /, //, and /// are updated immediately prior to printing
the return value of a top-level form by the Lisp read-eval-print loop.
If the evaluation of such a form is aborted prior to its normal return,
the values of /, //, and /// are not updated.

Examples:
.........

 (floor 22 7) ý 3, 1
 (+ (* (car /) 7) (cadr /)) ý 22

Affected By:
............

Lisp read-eval-print loop.

See Also:
.........

*Note - (Function):: (variable), *Note + (Function):: (variable), *Note
* (Function):: (variable), *Note Section 25.1.1 (Top level loop): Top
level loop.


File: chris-ansicl.info,  Node: lisp-implementation-type; lisp-implementation-version,  Next: short-site-name; long-site-name,  Prev: /; //; ///,  Up: Environment

lisp-implementation-type, lisp-implementation-version (Function)
================================================================

Syntax:
.......

 -- Function: lisp-implementation-type <no arguments> ý description

 -- Function: lisp-implementation-version <no arguments> ý description

Arguments and Values:
.....................

DESCRIPTION--a string or ÿnilþ.

Description:
............

ÿlisp-implementation-typeþ and ÿlisp-implementation-versionþ identify
the current implementation of Common Lisp.

ÿlisp-implementation-typeþ returns a string that identifies the generic
name of the particular Common Lisp implementation.

ÿlisp-implementation-versionþ returns a string that identifies the
version of the particular Common Lisp implementation.

If no appropriate and relevant result can be produced, ÿnilþ is
returned instead of a string.

Examples:
.........

 (lisp-implementation-type)
ý "ACME Lisp"
orý "Joe's Common Lisp"
 (lisp-implementation-version)
ý "1.3a"
ý "V2"
orý "Release 17.3, ECO #6"


File: chris-ansicl.info,  Node: short-site-name; long-site-name,  Next: machine-instance,  Prev: lisp-implementation-type; lisp-implementation-version,  Up: Environment

short-site-name, long-site-name (Function)
==========================================

Syntax:
.......

 -- Function: short-site-name <no arguments> ý description

 -- Function: long-site-name <no arguments> ý description

Arguments and Values:
.....................

DESCRIPTION--a string or ÿnilþ.

Description:
............

ÿshort-site-nameþ and ÿlong-site-nameþ return a string that identifies
the physical location of the computer hardware, or ÿnilþ if no
appropriate DESCRIPTION can be produced.

Examples:
.........

 (short-site-name)
ý "MIT AI Lab"
orý "CMU-CSD"
 (long-site-name)
ý "MIT Artificial Intelligence Laboratory"
orý "CMU Computer Science Department"

Affected By:
............

The implementation, the location of the computer hardware, and the
installation/configuration process.


File: chris-ansicl.info,  Node: machine-instance,  Next: machine-type,  Prev: short-site-name; long-site-name,  Up: Environment

machine-instance (Function)
===========================

Syntax:
.......

 -- Function: machine-instance <no arguments> ý description

Arguments and Values:
.....................

DESCRIPTION--a string or ÿnilþ.

Description:
............

Returns a string that identifies the particular instance of the
computer hardware on which Common Lisp is running, or ÿnilþ if no such
string can be computed.

Examples:
.........

 (machine-instance)
ý "ACME.COM"
orý "S/N 123231"
orý "18.26.0.179"
orý "AA-00-04-00-A7-A4"

Affected By:
............

The machine instance, and the implementation.

See Also:
.........

*Note machine-type::, *Note machine-version::


File: chris-ansicl.info,  Node: machine-type,  Next: machine-version,  Prev: machine-instance,  Up: Environment

machine-type (Function)
=======================

Syntax:
.......

 -- Function: machine-type <no arguments> ý description

Arguments and Values:
.....................

DESCRIPTION--a string or ÿnilþ.

Description:
............

Returns a string that identifies the generic name of the computer
hardware on which Common Lisp is running.

Examples:
.........

 (machine-type)
ý "DEC PDP-10"
orý "Symbolics LM-2"

Affected By:
............

The machine type.  The implementation.

See Also:
.........

*Note machine-version::


File: chris-ansicl.info,  Node: machine-version,  Next: software-type; software-version,  Prev: machine-type,  Up: Environment

machine-version (Function)
==========================

Syntax:
.......

 -- Function: machine-version <no arguments> ý description

Arguments and Values:
.....................

DESCRIPTION--a string or ÿnilþ.

Description:
............

Returns a string that identifies the version of the computer hardware
on which Common Lisp is running, or ÿnilþ if no such value can be
computed.

Examples:
.........

 (machine-version) ý "KL-10, microcode 9"

Affected By:
............

The machine version, and the implementation.

See Also:
.........

*Note machine-type::, *Note machine-instance::


File: chris-ansicl.info,  Node: software-type; software-version,  Next: user-homedir-pathname,  Prev: machine-version,  Up: Environment

software-type, software-version (Function)
==========================================

Syntax:
.......

 -- Function: software-type <no arguments> ý description

 -- Function: software-version <no arguments> ý description

Arguments and Values:
.....................

DESCRIPTION--a string or ÿnilþ.

Description:
............

ÿsoftware-typeþ returns a string that identifies the generic name of
any relevant supporting software, or ÿnilþ if no appropriate or
relevant result can be produced.

ÿsoftware-versionþ returns a string that identifies the version of any
relevant supporting software, or ÿnilþ if no appropriate or relevant
result can be produced.

Examples:
.........

 (software-type) ý "Multics"
 (software-version) ý "1.3x"

Affected By:
............

Operating system environment.

Notes:
......

This information should be of use to maintainers of the implementation.


File: chris-ansicl.info,  Node: user-homedir-pathname,  Prev: software-type; software-version,  Up: Environment

user-homedir-pathname (Function)
================================

Syntax:
.......

 -- Function: user-homedir-pathname &optional host ý pathname

Arguments and Values:
.....................

HOST--a string, a list of strings, or :unspecific.

PATHNAME--a pathname, or ÿnilþ.

Description:
............

ÿuser-homedir-pathnameþ determines the pathname that corresponds to the
user's home directory on HOST.  If HOST is not supplied, its value is
implementation-dependent.  For a description of :unspecific, see *Note
Section 19.2.1 (Pathname Components): Pathname Components.

The definition of home directory is implementation-dependent, but
defined in Common Lisp to mean the directory where the user keeps
personal files such as initialization files and mail.

ÿuser-homedir-pathnameþ returns a pathname without any name, type, or
version component (those components are all ÿnilþ) for the user's home
directory on HOST.

If it is impossible to determine the user's home directory on HOST,
then ÿnilþ is returned.  ÿuser-homedir-pathnameþ never returns ÿnilþ if
HOST is not supplied.

Examples:
.........

 (pathnamep (user-homedir-pathname)) ý true

Affected By:
............

The host computer's file system, and the implementation.


File: chris-ansicl.info,  Node: Glossary,  Next: Appendix,  Prev: Environment,  Up: Top

26 Glossary
***********

* Menu:

* Glossary Notation::
* Non-alphabetic::
* A::
* B::
* C::
* D::
* E::
* F::
* G::
* H::
* I::
* K::
* L::
* M::
* N::
* O::
* P::
* Q::
* R::
* S::
* T::
* U::
* V::
* W::
* Y::


File: chris-ansicl.info,  Node: Glossary Notation,  Next: Non-alphabetic,  Up: Glossary

26.1 Glossary Notation
======================

Each entry in this glossary has the following parts:

   * the term being defined, set in boldface.

   * optional pronunciation, enclosed in square brackets and set in
     boldface, as in the following example: [êaélist].  The
     pronunciation key follows `Webster's Third New International
     Dictionary the English Language, Unabridged'.

   * the part or parts of speech, set in italics.  If a term can be
     used as several parts of speech, there is a separate definition
     for each part of speech.

   * one or more definitions, organized as follows:

        - an optional number, present if there are several definitions.
          Lowercase letters might also be used in cases where
          subdefinitions of a numbered definition are necessary.

        - an optional part of speech, set in italics, present if the
          term is one of several parts of speech.

        - an optional discipline, set in italics, present if the term
          has a standard definition being repeated. For example, "Math."

        - an optional context, present if this definition is meaningful
          only in that context. For example, "(of a symbol)".

        - the definition.

        - an optional example sentence. For example, "This is an
          example of an example."

        - optional cross references.

In addition, some terms have idiomatic usage in the Common Lisp
community which is not shared by other communities, or which is not
technically correct.  Definitions labeled "Idiom." represent such
idiomatic usage; these definitions are sometimes followed by an
explanatory note.

Words in this font are words with entries in the glossary.  Words in
example sentences do not follow this convention.

When an ambiguity arises, the longest matching substring has precedence.
For example, "complex float" refers to a single glossary entry for
"complex float" rather than the combined meaning of the glossary terms
"complex" and "float."

Subscript notation, as in "something[n]" means that the nth definition
of "something" is intended.  This notation is used only in situations
where the context might be insufficient to disambiguate.

The following are abbreviations used in the glossary:

Abbreviation       Meaning
---------------------------------------------------------------------- 
adj.               adjective
adv.               adverb
ANSI               compatible with one or more ANSI standards
Comp.              computers
Idiom.             idiomatic
IEEE               compatible with one or more IEEE standards
ISO                compatible with one or more ISO standards
Math.              mathematics
Trad.              traditional
n.                 noun
v.                 verb
v.t.               transitive verb


File: chris-ansicl.info,  Node: Non-alphabetic,  Next: A,  Prev: Glossary Notation,  Up: Glossary

Non-alphabetic
==============

()
     [ênil], n.  an alternative notation for writing the symbol ÿnilþ,
     used to emphasize the use of nil as an empty list.



File: chris-ansicl.info,  Node: A,  Next: B,  Prev: Non-alphabetic,  Up: Glossary

A
=

absolute
     adj.  1. (of a time) representing a specific point in time.  2.
     (of a pathname) representing a specific position in a directory
     hierarchy.  See *Note relative: glos-relative.

access  n., v.t.
     1. v.t. (a place, or array) to readá or writeá the value of the
     place or an element of the array.  2. n. (of a place) an attempt
     to accessá the value of the place.

accessibility  n.
     the state of being accessible.

accessible  adj. 
     1. (of an object) capable of being referenced.  2. (of shared
     slots or local slots in an instance of a class) having been
     defined by the class of the instance or inherited from a
     superclass of that class.  3. (of a symbol in a package) capable
     of being referenced without a package prefix when that package is
     current, regardless of whether the symbol is present in that
     package or is inherited.

accessor  n.
     an operator that performs an access.  See *Note reader:
     glos-reader. and writer.

active  adj. 
     1. (of a handler, a restart, or a catch tag) having been
     established but not yet disestablished.  2. (of an element of an
     array) having an index that is greater than or equal to zero, but
     less than the fill pointer (if any).  For an array that has no
     fill pointer, all elements are considered active.

actual adjustability
     n. (of an array) a generalized boolean that is associated with the
     array, representing whether the array is actually adjustable.  See
     also *Note expressed adjustability: glos-expressed adjustability.
     and ÿadjustable-array-pþ.

actual argument  n. Trad. 
     an argument.

actual array element type  n. (of an array)
     the type for which the array is actually specialized, which is the
     upgraded array element type of the expressed array element type of
     the array.  See the function *Note array-element-type::.

actual complex part type  n. (of a complex)
     the type in which the real and imaginary parts of the complex are
     actually represented, which is the upgraded complex part type of
     the expressed complex part type of the complex.

actual parameter  n. Trad. 
     an argument.

actually adjustable  adj. (of an array)
     such that ÿadjust-arrayþ can adjust its characteristics by direct
     modification.  A conforming program may depend on an array being
     actually adjustable only if either that array is known to have
     been expressly adjustable or if that array has been explicitly
     tested by ÿadjustable-array-pþ.

adjustability  n. (of an array)
     1. expressed adjustability.  2. actual adjustability.

adjustable  adj. (of an array)
     1. expressly adjustable.  2. actually adjustable.

after method  n.
     a method having the qualifier :after.

alist  [êçélist], n. 
     an association list.

alphabetic  n., adj.
     1. adj. (of a character) being one of the standard characters ÿAþ
     through ÿZþ or ÿaþ through ÿzþ, or being any
     implementation-defined character that has case, or being some
     other graphic character defined by the implementation to be
     alphabeticá.  2. a. n.  one of several possible constituent traits
     of a character.  For details, see *Note Section 2.1.4.1
     (Constituent Characters): ConstituentChars. and *Note Section 2.2
     (Reader Algorithm): Reader Algorithm.  b. adj. (of a character)
     being a character that has syntax type constituent in the current
     readtable and that has the constituent trait alphabetic[2a].  See
     *Note Figure 2.8: ConstituentTraitsOfStdChars.

alphanumeric  adj. (of a character)
     being either an alphabeticá character or a numeric character.

ampersand  n.
     the standard character that is called "ampersand" (ÿ&þ).  See
     *Note Figure 2.5: StdCharsThree.

anonymous  adj. 
     1. (of a class or function) having no name 2. (of a restart)
     having a name of ÿnilþ.

apparently uninterned  adj. 
     having a home package of ÿnilþ.  (An apparently uninterned symbol
     might or might not be an uninterned symbol.  Uninterned symbols
     have a home package of ÿnilþ, but symbols which have been
     uninterned from their home package also have a home package of
     ÿnilþ, even though they might still be interned in some other
     package.)

applicable  adj.
     1. (of a handler) being an applicable handler.  2. (of a method)
     being an applicable method.  3. (of a restart) being an applicable
     restart.

applicable handler  n. (for a condition being signaled)
     an active handler for which the associated type contains the
     condition.

applicable method  n. (of a generic function
     called with arguments) a method of the generic function for which
     the arguments satisfy the parameter specializers of that method.
     See *Note Section 7.6.6.1.1 (Selecting the Applicable Methods):
     SelApplMeth.

applicable restart  n.
     1. (for a condition) an active handler for which the associated
     test returns true when given the condition as an argument.  2.
     (for no particular condition) an active handler for which the
     associated test returns true when given ÿnilþ as an argument.

apply  v.t. (a function to a list)
     to call the function with arguments that are the elements of the
     list.  "Applying the function ÿ+þ to a list of integers returns
     the sum of the elements of that list."

argument  n.
     1. (of a function) an object which is offered as data to the
     function when it is called.  2. (of a format control) a format
     argument.

argument evaluation order  n. 
     the order in which arguments are evaluated in a function call.
     "The argument evaluation order for Common Lisp is left to right."
     See *Note Section 3.1 (Evaluation): Evaluation.

argument precedence order  n.
     the order in which the arguments to a generic function are
     considered when sorting the applicable methods into precedence
     order.

around method  n.
     a method having the qualifier :around.

array  n.
     an object of type ÿarrayþ, which serves as a container for other
     objects arranged in a Cartesian coordinate system.

array element type  n. (of an array)
     1. a type associated with the array, and of which all elements of
     the array are constrained to be members.  2. the actual array
     element type of the array.  3. the expressed array element type of
     the array.

array total size  n. 
     the total number of elements in an array, computed by taking the
     product of the dimensions of the array.  (The size of a
     zero-dimensional array is therefore one.)

assign  v.t. (a variable)
     to change the value of the variable in a binding that has already
     been established.  See the special operator *Note setq::.

association list
     n.  a list of conses representing an association of keys with
     values, where the car of each cons is the key and the cdr is the
     value associated with that key.

asterisk  n.
     the standard character that is variously called "asterisk" or
     "star" (ÿ*þ).  See *Note Figure 2.5: StdCharsThree.

at-sign  n.
     the standard character that is variously called "commercial at" or
     "at sign" (ÿ@þ).  See *Note Figure 2.5: StdCharsThree.

atom  n.
     any object that is not a cons.  "A vector is an atom."

atomic  adj. 
     being an atom.  "The number 3, the symbol ÿfooþ, and ÿnilþ are
     atomic."

atomic type specifier  n.
     a type specifier that is atomic.  For every atomic type specifier,
     x, there is an equivalent compound type specifier with no
     arguments supplied, ÿ(x)þ.

attribute  n. (of a character)
     a program-visible aspect of the character.  The only standardized
     attribute of a character is its codeà, but implementations are
     permitted to have additional implementation-defined attributes.
     See *Note Section 13.1.3 (Character Attributes): Character
     Attributes.  "An implementation that support fonts might make font
     information an attribute of a character, while others might
     represent font information separately from characters."

aux variable  n.
     a variable that occurs in the part of a lambda list that was
     introduced by ÿ&auxþ.  Unlike all other variables introduced by a
     lambda-list, aux variables are not parameters.

auxiliary method  n.
     a member of one of two sets of methods (the set of primary methods
     is the other) that form an exhaustive partition of the set of
     methods on the method's generic function.  How these sets are
     determined is dependent on the method combination type; see *Note
     Section 7.6.2 (Introduction to Methods): Introduction to Methods.



File: chris-ansicl.info,  Node: B,  Next: C,  Prev: A,  Up: Glossary

B
=

backquote  n.
     the standard character that is variously called "grave accent" or
     "backquote" (ÿ`þ).  See *Note Figure 2.5: StdCharsThree.

backslash  n.
     the standard character that is variously called "reverse solidus"
     or "backslash" (ÿ\þ).  See *Note Figure 2.5: StdCharsThree.

base character  n.
     a character of type ÿbase-charþ.

base string  n.
     a string of type ÿbase-stringþ.

before method  n.
     a method having the qualifier :before.

bidirectional  adj. (of a stream)
     being both an input stream and an output stream.

binary
     adj.  1. (of a stream) being a stream that has an element type
     that is a subtype of type ÿintegerþ.  The most fundamental
     operation on a binary input stream is ÿread-byteþ and on a binary
     output stream is ÿwrite-byteþ.  See *Note character:
     glos-character.  2. (of a file) having been created by opening a
     binary stream.  (It is implementation-dependent whether this is an
     detectable aspect of the file, or whether any given character file
     can be treated as a binary file.)

bind  v.t. (a variable)
     to establish a binding for the variable.

binding  n. 
     an association between a name and that which the name denotes.  "A
     lexical binding is a lexical association between a name and its
     value."  When the term binding is qualified by the name of a
     namespace, such as "variable" or "function," it restricts the
     binding to the indicated namespace, as in: "ÿletþ establishes
     variable bindings."  or "ÿletþ establishes bindings of variables."

bit  n. 
     an object of type ÿbitþ; that is, the integer ÿ0þ or the integer
     ÿ1þ.

bit array  n.
     a specialized array that is of type ÿ(array bit)þ, and whose
     elements are of type ÿbitþ.

bit vector  n. 
     a specialized vector that is of type ÿbit-vectorþ, and whose
     elements are of type ÿbitþ.

bit-wise logical operation specifier  n. 
     an object which names one of the sixteen possible bit-wise logical
     operations that can be performed by the ÿbooleþ function, and
     which is the value of exactly one of the constant variables
     ÿboole-clrþ,     ÿboole-setþ, ÿboole-1þ,       ÿboole-2þ,
     ÿboole-c1þ,      ÿboole-c2þ, ÿboole-andþ,     ÿboole-iorþ,
     ÿboole-xorþ,     ÿboole-eqvþ, ÿboole-nandþ,    ÿboole-norþ,
     ÿboole-andc1þ,   ÿboole-andc2þ, ÿboole-orc1þ, or ÿboole-orc2þ.

block  n.
     a named lexical exit point, established explicitly by ÿblockþ or
     implicitly by operators such as ÿloopþ, ÿdoþ and ÿprogþ, to which
     control and values may be transfered by using a ÿreturn-fromþ form
     with the name of the block.

block tag  n. 
     the symbol that, within the lexical scope of a ÿblockþ form, names
     the block established by that ÿblockþ form.  See ÿreturnþ or
     ÿreturn-fromþ.

boa lambda list  n.
     a lambda list that is syntactically like an ordinary lambda list,
     but that is processed in "by order of argument" style.  See *Note
     Section 3.4.6 (Boa Lambda Lists): Boa Lambda Lists.

body parameter  n.
     a parameter available in certain lambda lists which from the point
     of view of conforming programs is like a rest parameter in every
     way except that it is introduced by ÿ&bodyþ instead of ÿ&restþ.
     (Implementations are permitted to provide extensions which
     distinguish body parameters and rest parameters--e.g., the forms
     for operators which were defined using a body parameter might be
     pretty printed slightly differently than forms for operators which
     were defined using rest parameters.)

boolean
     n.  an object of type ÿbooleanþ; that is, one of the following
     objects: the symbol ÿtþ   (representing true), or the
     symbol ÿnilþ (representing false).  See *Note generalized boolean:
     glos-generalized boolean.

boolean equivalent  n. (of an object Oá)
     any object Oà that has the same truth value as Oá when both Oá and
     Oà are viewed as generalized booleans.

bound
     adj., v.t.  1. adj. having an associated denotation in a binding.
     "The variables named by a ÿletþ are bound within its body."  See
     *Note unbound: glos-unbound.  2. adj. having a local binding which
     shadowsà another.  "The variable ÿ*print-escape*þ is bound while in
     the ÿprincþ function."  3. v.t. the past tense of bind.

bound declaration  n. 
     a declaration that refers to or is associated with a variable or
     function and that appears within the special form that establishes
     the variable or function, but before the body of that special form
     (specifically, at the head of that form's body).  (If a bound
     declaration refers to a function binding or a lexical variable
     binding, the scope of the declaration is exactly the scope of that
     binding.  If the declaration refers to a dynamic variable binding,
     the scope of the declaration is what the scope of the binding
     would have been if it were lexical rather than dynamic.)

bounded  adj. (of a sequence S,
     by an ordered pair of bounding indices i_{start} and i_{end})
     restricted to a subrange of the elements of S that includes each
     element beginning with (and including) the one indexed by
     i_{start} and continuing up to (but not including) the one indexed
     by i_{end}.

bounding index  n. (of a sequence with length n)
     either of a conceptual pair of integers, i_{start} and i_{end},
     respectively called the "lower bounding index" and "upper bounding
     index", such that 0 ó i_{start} ó i_{end} ó n, and which therefore
     delimit a subrange of the sequence bounded by i_{start} and
     i_{end}.

bounding index designator  (for a sequence)
     one of two objects that, taken together as an ordered pair, behave
     as a designator for bounding indices of the sequence; that is,
     they denote bounding indices of the sequence, and are either: an
     integer (denoting itself) and ÿnilþ  (denoting the length of the
     sequence), or two integers (each denoting themselves).

break loop  n.
     A variant of the normal Lisp read-eval-print loop that is
     recursively entered, usually because the ongoing evaluation of
     some other form has been suspended for the purpose of debugging.
     Often, a break loop provides the ability to exit in such a way as
     to continue the suspended computation.  See the function *Note
     break::.

broadcast stream  n.
     an output stream of type ÿbroadcast-streamþ.

built-in class  n.
     a class that is a generalized instance of class ÿbuilt-in-classþ.

built-in type  n.
     one of the types in *Note Figure 4.2: StandardizedAtomicTypeSpecs.

byte  n.
     1. adjacent bits within an integer.  (The specific number of bits
     can vary from point to point in the program; see the function
     *Note byte::.)  2. an integer in a specified range.  (The specific
     range can vary from point to point in the program; see the
     functions *Note open:: and ÿwrite-byteþ.)

byte specifier  n.
     An object of implementation-dependent nature that is returned by
     the function ÿbyteþ and that specifies the range of bits in an
     integer to be used as a byte by functions such as ÿldbþ.



File: chris-ansicl.info,  Node: C,  Next: D,  Prev: B,  Up: Glossary

C
=

cadr  [êkaédè r], n. (of an object)
     the car of the cdr of that object.

call  v.t., n. 
     1. v.t. (a function with arguments) to cause the code represented
     by that function to be executed in an environment where bindings
     for the values of its parameters have been established based on
     the arguments.  "Calling the function ÿ+þ with the arguments ÿ5þ
     and ÿ1þ yields a value of ÿ6þ."  2. n. a situation in which a
     function is called.

captured initialization form  n.
     an initialization form along with the lexical environment in which
     the form that defined the initialization form was evaluated.
     "Each newly added shared slot is set to the result of evaluating
     the captured initialization form for the slot that was specified
     in the ÿdefclassþ form for the new class."

car  n.
     1. a. (of a cons) the component of a cons corresponding to the
     first argument to ÿconsþ; the other component is the cdr.  "The
     function ÿrplacaþ modifies the car of a cons."  b. (of a list) the
     first element of the list, or ÿnilþ if the list is the empty list.
     2. the object that is held in the cará.  "The function ÿcarþ
     returns the car of a cons."

case  n. (of a character)
     the property of being either uppercase or lowercase.  Not all
     characters have case.  "The characters ÿ#\Aþ and ÿ#\aþ have case,
     but the character ÿ#\$þ has no case."  See *Note Section 13.1.4.3
     (Characters With Case): CharactersWithCase. and the function
     ÿboth-case-pþ.

case sensitivity mode  n.
     one of the symbols :upcase, :downcase, :preserve, or :invert.

catch  n.
     an exit point which is established by a ÿcatchþ form within the
     dynamic scope of its body, which is named by a catch tag, and to
     which control and values may be thrown.

catch tag  n.
     an object which names an active catch.  (If more than one catch is
     active with the same catch tag, it is only possible to throw to
     the innermost such catch because the outer one is shadowedà.)

cddr  [êk.udè édè r] or
     [êkèéd.udè r], n.  (of an object) the cdr of the cdr of that
     object.

cdr  [êk.uédè r], n. 
     1. a. (of a cons) the component of a cons corresponding to the
     second argument to ÿconsþ; the other component is the car.  "The
     function ÿrplacdþ modifies the cdr of a cons."  b. (of a list Lá)
     either the list Là that contains the elements of Lá that follow
     after the first, or else ÿnilþ if Lá is the empty list.  2. the
     object that is held in the cdrá.  "The function ÿcdrþ returns the
     cdr of a cons."

cell
     n. Trad. (of an object) a conceptual slot of that object.  The
     dynamic variable and global function bindings of a symbol are
     sometimes referred to as its value cell and function cell,
     respectively.

character
     n., adj.  1. n. an object of type ÿcharacterþ; that is, an object
     that represents a unitary token in an aggregate quantity of text;
     see *Note Section 13.1 (Character Concepts): Character Concepts.
     2. adj.  a. (of a stream) having an element type that is a subtype
     of type ÿcharacterþ.  The most fundamental operation on a
     character input stream is ÿread-charþ and on a character output
     stream is ÿwrite-charþ. See *Note binary: glos-binary.  b. (of a
     file) having been created by opening a character stream.  (It is
     implementation-dependent whether this is an inspectable aspect of
     the file, or whether any given binary file can be treated as a
     character file.)

character code  n.
     1. one of possibly several attributes of a character.  2. a
     non-negative integer less than the value of ÿchar-code-limitþ that
     is suitable for use as a character codeá.

character designator  n.
     a designator for a character; that is, an object that denotes a
     character and that is one of: a designator for a string of length
     one (denoting the character that is its only element), or a
     character (denoting itself).

circular  adj.
     1. (of a list) a circular list.  2. (of an arbitrary object)
     having a component, element, constituentà, or subexpression (as
     appropriate to the context) that is the object itself.

circular list  n. 
     a chain of conses that has no termination because some cons in the
     chain is the cdr of a later cons.

class  n.
     1. an object that uniquely determines the structure and behavior of
     a set of other objects called its direct instances, that
     contributes structure and behavior to a set of other objects
     called its indirect instances, and that acts as a type specifier
     for a set of objects called its generalized instances.  "The class
     ÿintegerþ is a subclass of the class ÿnumberþ."  (Note that the
     phrase "the class ÿfooþ" is often substituted for the more precise
     phrase "the class named ÿfooþ"--in both cases, a class object (not
     a symbol) is denoted.)  2. (of an object) the uniquely determined
     class of which the object is a direct instance.  See the function
     *Note class-of::.  "The class of the object returned by ÿgensymþ
     is ÿsymbolþ."  (Note that with this usage a phrase such as "its
     class is ÿfooþ" is often substituted for the more precise phrase
     "its class is the class named ÿfooþ"--in both cases, a class
     object (not a symbol) is denoted.)

class designator  n.
     a designator for a class; that is, an object that denotes a class
     and that is one of: a symbol (denoting the class named by that
     symbol; see the function *Note find-class::) or a class (denoting
     itself).

class precedence list  n.
     a unique total ordering on a class and its superclasses that is
     consistent with the local precedence orders for the class and its
     superclasses.  For detailed information, see *Note Section 4.3.5
     (Determining the Class Precedence List): Determining the Class
     Precedence List.

close
     v.t. (a stream) to terminate usage of the stream as a source or
     sink of data, permitting the implementation to reclaim its
     internal data structures, and to free any external resources which
     might have been locked by the stream when it was opened.

closed  adj. (of a stream)
     having been closed (see *Note close: glos-close.).  Some (but not
     all) operations that are valid on open streams are not valid on
     closed streams.  See *Note Section 21.1.1.1.2 (Open and Closed
     Streams): File Operations on Open and Closed Streams.

closure  n.
     a lexical closure.

coalesce  v.t. (literal objects that are similar)
     to consolidate the identity of those objects, such that they
     become the same object.  See *Note Section 3.2.1 (Compiler
     Terminology): Compiler Terminology.

code  n.
     1. Trad.  any representation of actions to be performed, whether
     conceptual or as an actual object, such as forms, lambda
     expressions, objects of type function, text in a source file, or
     instruction sequences in a compiled file.  This is a generic term;
     the specific nature of the representation depends on its context.
     2. (of a character) a character code.

coerce  v.t. (an object to a type)
     to produce an object from the given object, without modifying that
     object, by following some set of coercion rules that must be
     specifically stated for any context in which this term is used.
     The resulting object is necessarily of the indicated type, except
     when that type is a subtype of type ÿcomplexþ; in that case, if a
     complex rational with an imaginary part of zero would result, the
     result is a rational rather than a complex--see *Note Section
     12.1.5.3 (Rule of Canonical Representation for Complex Rationals):
     RuleOfCanonRepForComplexRationals.

colon  n.
     the standard character that is called "colon" (ÿ:þ).  See *Note
     Figure 2.5: StdCharsThree.

comma  n.
     the standard character that is called "comma" (ÿ,þ).  See *Note
     Figure 2.5: StdCharsThree.

compilation  n.
     the process of compiling code by the compiler.

compilation environment  n. 
     1. An environment that represents information known by the
     compiler about a form that is being compiled.  See *Note Section
     3.2.1 (Compiler Terminology): Compiler Terminology.  2. An object
     that represents the compilation environmentá and that is used as a
     second argument to a macro function (which supplies a value for
     any ÿ&environmentþ parameter in the macro function's definition).

compilation unit  n.
     an interval during which a single unit of compilation is occurring.
     See the macro *Note with-compilation-unit::.

compile  v.t. 
     1. (code) to perform semantic preprocessing of the code, usually
     optimizing one or more qualities of the code, such as run-time
     speed of execution or run-time storage usage.  The minimum
     semantic requirements of compilation are that it must remove all
     macro calls and arrange for all load time values to be resolved
     prior to run time.  2. (a function) to produce a new object of
     type ÿcompiled-functionþ which represents the result of compiling
     the code represented by the function.  See the function *Note
     compile::.  3. (a source file) to produce a compiled file from a
     source file.  See the function *Note compile-file::.

compile time  n. 
     the duration of time that the compiler is processing source code.

compile-time definition  n.
     a definition in the compilation environment.

compiled code  n.
     1. compiled functions.  2. code that represents compiled functions,
     such as the contents of a compiled file.

compiled file  n.
     a file which represents the results of compiling the forms which
     appeared in a corresponding source file, and which can be loaded.
     See the function *Note compile-file::.

compiled function  n.
     an object of type ÿcompiled-functionþ, which is a function that
     has been compiled, which contains no references to macros that
     must be expanded at run time, and which contains no unresolved
     references to load time values.

compiler  n.
     a facility that is part of Lisp and that translates code into an
     implementation-dependent form that might be represented or
     executed efficiently.  The functions ÿcompileþ and ÿcompile-fileþ
     permit programs to invoke the compiler.

compiler macro  n.
     an auxiliary macro definition for a globally defined function or
     macro which might or might not be called by any given conforming
     implementation and which must preserve the semantics of the
     globally defined function or macro but which might perform some
     additional optimizations.  (Unlike a macro, a compiler macro does
     not extend the syntax of Common Lisp; rather, it provides an
     alternate implementation strategy for some existing syntax or
     functionality.)

compiler macro expansion  n.
     1. the process of translating a form into another form by a
     compiler macro.  2. the form resulting from this process.

compiler macro form  n.
     a function form or macro form whose operator has a definition as a
     compiler macro, or a ÿfuncallþ form whose first argument is a
     ÿfunctionþ form whose argument is the name of a function that has
     a definition as a compiler macro.

compiler macro function  n. 
     a function of two arguments, a form and an environment, that
     implements compiler macro expansion by producing either a form to
     be used in place of the original argument form or else ÿnilþ,
     indicating that the original form should not be replaced.  See
     *Note Section 3.2.2.1 (Compiler Macros): CompilerMacros.

complex  n.
     an object of type ÿcomplexþ.

complex float  n.
     an object of type ÿcomplexþ which has a complex part type that is
     a subtype of ÿfloatþ.  A complex float is a complex, but it is not
     a float.

complex part type  n. (of a complex)
     1. the type which is used to represent both the real part and the
     imaginary part of the complex.  2. the actual complex part type of
     the complex.  3. the expressed complex part type of the complex.

complex rational  n.
     an object of type ÿcomplexþ which has a complex part type that is
     a subtype of ÿrationalþ.  A complex rational is a complex, but it
     is not a rational.  No complex rational has an imaginary part of
     zero because such a number is always represented by Common Lisp as
     an object of type ÿrationalþ; see *Note Section 12.1.5.3 (Rule of
     Canonical Representation for Complex Rationals):
     RuleOfCanonRepForComplexRationals.

complex single float  n.
     an object of type ÿcomplexþ which has a complex part type that is
     a subtype of ÿsingle-floatþ.  A complex single float is a complex,
     but it is not a single float.

composite stream  n.
     a stream that is composed of one or more other streams.
     "ÿmake-synonym-streamþ creates a composite stream."

compound form  n.
     a non-empty list which is a form: a special form, a lambda form, a
     macro form, or a function form.

compound type specifier  n.
     a type specifier that is a cons; i.e., a type specifier that is
     not an atomic type specifier.  "ÿ(vector single-float)þ is a
     compound type specifier."

concatenated stream  n.
     an input stream of type ÿconcatenated-streamþ.

condition  n.
     1. an object which represents a situation--usually, but not
     necessarily, during signaling.  2. an object of type ÿconditionþ.

condition designator  n.
     one or more objects that, taken together, denote either an
     existing condition object or a condition object to be implicitly
     created.  For details, see *Note Section 9.1.2.1 (Condition
     Designators): ConditionDesignators.

condition handler  n.
     a function that might be invoked by the act of signaling, that
     receives the condition being signaled as its only argument, and
     that is permitted to handle the condition or to decline.  See
     *Note Section 9.1.4.1 (Signaling): Signaling.

condition reporter  n.
     a function that describes how a condition is to be printed when
     the Lisp printer is invoked while ÿ*print-escape*þ is false.  See
     *Note Section 9.1.3 (Printing Conditions): Printing Conditions.

conditional newline  n.
     a point in output where a newline might be inserted at the
     discretion of the pretty printer.  There are four kinds of
     conditional newlines, called "linear-style," "fill-style,"
     "miser-style," and "mandatory-style."  See the function *Note
     pprint-newline:: and *Note Section 22.2.1.1 (Dynamic Control of
     the Arrangement of Output): DynamicControlofOutput.

conformance  n.
     a state achieved by proper and complete adherence to the
     requirements of this specification.  See *Note Section 1.5
     (Conformance): Conformance.

conforming code  n.
     code that is all of part of a conforming program.

conforming implementation  n.
     an implementation, used to emphasize complete and correct
     adherance to all conformance criteria.  A conforming
     implementation is capable of accepting a conforming program as
     input, preparing that program for execution, and executing the
     prepared program in accordance with this specification.  An
     implementation which has been extended may still be a conforming
     implementation provided that no extension interferes with the
     correct function of any conforming program.

conforming processor  n. ANSI 
     a conforming implementation.

conforming program  n.
     a program, used to emphasize the fact that the program depends for
     its correctness only upon documented aspects of Common Lisp, and
     can therefore be expected to run correctly in any conforming
     implementation.

congruent  n. 
     conforming to the rules of lambda list congruency, as detailed in
     *Note Section 7.6.4 (Congruent Lambda-lists for all Methods of a
     Generic Function): Congruent Lambda-lists for all Methods of a
     Generic Function.

cons  n.v. 
     1. n. a compound data object having two components called the car
     and the cdr.  2. v. to create such an object.  3. v. Idiom. to
     create any object, or to allocate storage.

constant  n.
     1. a constant form.  2. a constant variable.  3. a constant object.
     4. a self-evaluating object.

constant form  n.
     any form for which evaluation always yields the same value, that
     neither affects nor is affected by the environment in which it is
     evaluated (except that it is permitted to refer to the names of
     constant variables defined in the environment), and that neither
     affects nor is affected by the state of any object except those
     objects that are otherwise inaccessible parts of objects created
     by the form itself.  "A ÿcarþ form in which the argument is a
     ÿquoteþ form is a constant form."

constant object  n.
     an object that is constrained (e.g., by its context in a program
     or by the source from which it was obtained) to be immutable.  "A
     literal object that has been processed by ÿcompile-fileþ is a
     constant object."

constant variable  n.
     a variable, the value of which can never change; that is, a
     keywordá or a named constant.  "The symbols ÿtþ, ÿnilþ,
     :direction, and ÿmost-positive-fixnumþ are constant variables."

constituent  n., adj.
     1. a. n. the syntax type of a character that is part of a token.
     For details, see *Note Section 2.1.4.1 (Constituent Characters):
     ConstituentChars.  b. adj. (of a character) having the
     constituent[1a] syntax typeà.  c. n. a constituent[1b] character.
     2. n. (of a composite stream) one of possibly several objects that
     collectively comprise the source or sink of that stream.

constituent trait  n. (of a character)
     one of several classifications of a constituent character in a
     readtable.  See *Note Section 2.1.4.1 (Constituent Characters):
     ConstituentChars.

constructed stream  n. 
     a stream whose source or sink is a Lisp object.  Note that since a
     stream is another Lisp object, composite streams are considered
     constructed streams.  "A string stream is a constructed stream."

contagion  n.
     a process whereby operations on objects of differing types (e.g.,
     arithmetic on mixed types of numbers) produce a result whose type
     is controlled by the dominance of one argument's type over the
     types of the other arguments.  See *Note Section 12.1.1.2
     (Contagion in Numeric Operations): NumericContagionRules.

continuable  n. (of an error)
     an error that is correctable by the ÿcontinueþ restart.

control form  n.
     1. a form that establishes one or more places to which control can
     be transferred.  2. a form that transfers control.

copy  n.
     1. (of a cons C) a fresh cons with the same car and cdr as C.  2.
     (of a list L) a fresh list with the same elements as L.  (Only the
     list structure is fresh; the elements are the same.)  See the
     function *Note copy-list::.  3. (of an association list A with
     elements A_i) a fresh list B with elements B_i, each of which is
     ÿnilþ if A_i is ÿnilþ, or else a copy of the cons A_i.  See the
     function *Note copy-alist::.  4. (of a tree T) a fresh tree with
     the same leaves as T.  See the function *Note copy-tree::.  5. (of
     a random state R) a fresh random state that, if used as an
     argument to to the function ÿrandomþ would produce the same series
     of "random" values as R would produce.  6. (of a structure S) a
     fresh structure that has the same type as S, and that has slot
     values, each of which is the same as the corresponding slot value
     of S.  (Note that since the difference between a cons, a list, and
     a tree is a matter of "view" or "intention,"  there can be no
     general-purpose function which, based solely on the type of an
     object, can determine which of these distinct meanings is
     intended.  The distinction rests solely on the basis of the text
     description within this document.  For example, phrases like "a
     copy of the given list" or "copy of the list X" imply the second
     definition.)

correctable  adj. (of an error)
     1. (by a restart other than abort that has been associated with
     the error) capable of being corrected by invoking that restart.
     "The function ÿcerrorþ signals an error that is correctable by the
     continue restart."  (Note that correctability is not a property of
     an error object, but rather a property of the dynamic environment
     that is in effect when the error is signaled.  Specifically, the
     restart is "associated with" the error condition object.  See
     *Note Section 9.1.4.2.4 (Associating a Restart with a Condition):
     AssocRestartWithCond.)  2. (when no specific restart is mentioned)
     correctableá by at least one restart.  "ÿimportþ signals a
     correctable error of type ÿpackage-errorþ if any of the imported
     symbols has the same name as some distinct symbol already
     accessible in the package."

current input base  n. (in a dynamic environment)
     the radix that is the value of ÿ*read-base*þ in that environment,
     and that is the default radix employed by the Lisp reader and its
     related functions.

current logical block  n.
     the context of the innermost lexically enclosing use of
     ÿpprint-logical-blockþ.

current output base  n. (in a dynamic environment)
     the radix that is the value of ÿ*print-base*þ in that environment,
     and that is the default radix employed by the Lisp printer and its
     related functions.

current package  n. (in a dynamic environment)
     the package that is the value of ÿ*package*þ in that environment,
     and that is the default package employed by the Lisp reader and
     Lisp printer, and their related functions.

current pprint dispatch table  n. (in a dynamic environment)
     the pprint dispatch table that is the value of
     ÿ*print-pprint-dispatch*þ in that environment, and that is the
     default pprint dispatch table employed by the pretty printer.

current random state  n. (in a dynamic environment)
     the random state that is the value of ÿ*random-state*þ in that
     environment, and that is the default random state employed by
     ÿrandomþ.

current readtable  n. (in a dynamic environment)
     the readtable that is the value of ÿ*readtable*þ in that
     environment, and that affects the way in which expressionsà are
     parsed into objects by the Lisp reader.



File: chris-ansicl.info,  Node: D,  Next: E,  Prev: C,  Up: Glossary

D
=

data type  n. Trad. 
     a type.

debug I/O  n. 
     the bidirectional stream that is the value of the variable
     ÿ*debug-io*þ.

debugger  n.
     a facility that allows the user to handle a condition
     interactively.  For example, the debugger might permit interactive
     selection of a restart from among the active restarts, and it
     might perform additional implementation-defined services for the
     purposes of debugging.

declaration  n.
     a global declaration or local declaration.

declaration identifier  n.
     one of the symbols ÿdeclarationþ, ÿdynamic-extentþ, ÿftypeþ,
     ÿfunctionþ, ÿignoreþ, ÿinlineþ, ÿnotinlineþ, ÿoptimizeþ, ÿspecialþ,
     or ÿtypeþ; or a symbol which is the name of a type; or a symbol
     which has been declared to be a declaration identifier by using a
     ÿdeclarationþ declaration.

declaration specifier  n.
     an expression that can appear at top level of a declare expression
     or a ÿdeclaimþ form, or as the argument to ÿproclaimþ, and which
     has a car which is a declaration identifier, and which has a cdr
     that is data interpreted according to rules specific to the
     declaration identifier.

declare  v. 
     to establish a declaration.  See *Note declare::, ÿdeclaimþ, or
     ÿproclaimþ.

decline  v. (of a handler)
     to return normally without having handled the condition being
     signaled, permitting the signaling process to continue as if the
     handler had not been present.

decoded time
     n.  absolute time, represented as an ordered series of nine
     objects which, taken together, form a description of a point in
     calendar time, accurate to the nearest second (except that leap
     seconds are ignored).  See *Note Section 25.1.4.1 (Decoded Time):
     DecodedTime.

default method  n.
     a method having no parameter specializers other than the class
     ÿtþ.  Such a method is always an applicable method but might be
     shadowedà by a more specific method.

defaulted initialization argument list  n.
     a list of alternating initialization argument names and values in
     which unsupplied initialization arguments are defaulted, used in
     the protocol for initializing and reinitializing instances of
     classes.

define-method-combination arguments lambda list  n.
     a lambda list used by the :arguments option to
     ÿdefine-method-combinationþ.  See *Note Section 3.4.10
     (Define-method-combination Arguments Lambda Lists):
     Define-method-combination Arguments Lambda Lists.

define-modify-macro lambda list  n.
     a lambda list used by ÿdefine-modify-macroþ.  See *Note Section
     3.4.9 (Define-modify-macro Lambda Lists): Define-modify-macro
     Lambda Lists.

defined name  n.
     a symbol the meaning of which is defined by Common Lisp.

defining form  n.
     a form that has the side-effect of establishing a definition.
     "ÿdefunþ and ÿdefparameterþ are defining forms."

defsetf lambda list  n.
     a lambda list that is like an ordinary lambda list except that it
     does not permit ÿ&auxþ and that it permits use of ÿ&environmentþ.
     See *Note Section 3.4.7 (Defsetf Lambda Lists): Defsetf Lambda
     Lists.

deftype lambda list  n.
     a lambda list that is like a macro lambda list except that the
     default value for unsupplied optional parameters and keyword
     parameters is the symbol * (rather than ÿnilþ).  See *Note Section
     3.4.8 (Deftype Lambda Lists): Deftype Lambda Lists.

denormalized
     adj., ANSI, IEEE (of a float) conforming to the description of
     "denormalized" as described by `IEEE Standard for Binary
     Floating-Point Arithmetic'.  For example, in an implementation
     where the minimum possible exponent was ÿ-7þ but where ÿ0.001þ was
     a valid mantissa, the number ÿ1.0e-10þ might be representable as
     ÿ0.001e-7þ internally even if the normalized representation would
     call for it to be represented instead as ÿ1.0e-10þ or ÿ0.1e-9þ.
     By their nature, denormalized floats generally have less precision
     than normalized floats.

derived type  n.
     a type specifier which is defined in terms of an expansion into
     another type specifier.  ÿdeftypeþ defines derived types, and
     there may be other implementation-defined operators which do so as
     well.

derived type specifier  n.
     a type specifier for a derived type.

designator  n. 
     an object that denotes another object.  In the dictionary entry
     for an operator if a parameter is described as a designator for a
     type, the description of the operator is written in a way that
     assumes that appropriate coercion to that type has already
     occurred; that is, that the parameter is already of the denoted
     type.  For more detailed information, see *Note Section 1.4.1.5
     (Designators): Designators.

destructive  adj. (of an operator)
     capable of modifying some program-visible aspect of one or more
     objects that are either explicit arguments to the operator or that
     can be obtained directly or indirectly from the global environment
     by the operator.

destructuring lambda list  n.
     an extended lambda list used in ÿdestructuring-bindþ and nested
     within macro lambda lists.  See *Note Section 3.4.5 (Destructuring
     Lambda Lists): Destructuring Lambda Lists.

different  adj. 
     not the same "The strings ÿ"FOO"þ and ÿ"foo"þ are different under
     ÿequalþ but not under ÿequalpþ."

digit  n. (in a radix)
     a character that is among the possible digits (ÿ0þ to ÿ9þ, ÿAþ to
     ÿZþ, and ÿaþ to ÿzþ) and that is defined to have an associated
     numeric weight as a digit in that radix.  See *Note Section
     13.1.4.6 (Digits in a Radix): Digits.

dimension  n.
     1. a non-negative integer indicating the number of objects an
     array can hold along one axis.  If the array is a vector with a
     fill pointer, the fill pointer is ignored.  "The second dimension
     of that array is 7."  2. an axis of an array.  "This array has six
     dimensions."

direct instance  n. (of a class C)
     an object whose class is C itself, rather than some subclass of C.
     "The function ÿmake-instanceþ always returns a direct instance of
     the class which is (or is named by) its first argument."

direct subclass  n. (of a class Cá)
     a class Cà, such that Cá is a direct superclass of Cà.

direct superclass  n. (of a class Cá)
     a class Cà which was explicitly designated as a superclass of Cá
     in the definition of Cá.

disestablish  v.t. 
     to withdraw the establishment of an object, a  binding, an exit
     point, a  tag, a  handler, a  restart, or an environment.

disjoint  n. (of types)
     having no elements in common.

dispatching macro character  n. 
     a macro character that has an associated table that specifies the
     function to be called for each character that is seen following
     the dispatching macro character.  See the function *Note
     make-dispatch-macro-character::.

displaced array  n.
     an array which has no storage of its own, but which is instead
     indirected to the storage of another array, called its target, at
     a specified offset, in such a way that any attempt to access the
     displaced array implicitly references the target array.

distinct  adj.
     not identical.

documentation string  n. (in a defining form)
     A literal string which because of the context in which it appears
     (rather than because of some intrinsically observable aspect of
     the string) is taken as documentation.  In some cases, the
     documentation string is saved in such a way that it can later be
     obtained by supplying either an object, or by supplying a name and
     a "kind" to the function ÿdocumentationþ.  "The body of code in a
     ÿdefmacroþ form can be preceded by a documentation string of kind
     function."

dot  n.
     the standard character that is variously called "full stop,"
     "period," or "dot" (ÿ.þ).  See *Note Figure 2.5: StdCharsThree.

dotted list  n.
     a list which has a terminating atom that is not ÿnilþ.  (An atom
     by itself is not a dotted list, however.)

dotted pair  n.
     1. a cons whose cdr is a non-list.  2. any cons, used to emphasize
     the use of the cons as a symmetric data pair.

double float  n.
     an object of type ÿdouble-floatþ.

double-quote  n.
     the standard character that is variously called "quotation mark"
     or "double quote" (ÿ"þ).  See *Note Figure 2.5: StdCharsThree.

dynamic binding  n. 
     a binding in a dynamic environment.

dynamic environment  n.
     that part of an environment that contains bindings with dynamic
     extent.  A dynamic environment contains, among other things: exit
     points established by ÿunwind-protectþ, and bindings of dynamic
     variables, exit points established by ÿcatchþ, condition handlers,
     and restarts.

dynamic extent  n.
     an extent whose duration is bounded by points of establishment and
     disestablishment within the execution of a particular form.  See
     *Note indefinite extent: glos-indefinite extent.  "Dynamic
     variable bindings have dynamic extent."

dynamic scope  n.
     indefinite scope along with dynamic extent.

dynamic variable  n.
     a variable the binding for which is in the dynamic environment.
     See *Note special::.



File: chris-ansicl.info,  Node: E,  Next: F,  Prev: D,  Up: Glossary

E
=

echo stream  n.
     a stream of type ÿecho-streamþ.

effective method  n.
     the combination of applicable methods that are executed when a
     generic function is invoked with a particular sequence of
     arguments.

element  n.
     1. (of a list) an object that is the car of one of the conses that
     comprise the list.  2. (of an array) an object that is stored in
     the array.  3. (of a sequence) an object that is an element of the
     list or array that is the sequence.  4. (of a type) an object that
     is a member of the set of objects designated by the type.  5. (of
     an input stream) a character or number (as appropriate to the
     element type of the stream) that is among the ordered series of
     objects that can be read from the stream (using ÿread-charþ or
     ÿread-byteþ, as appropriate to the stream).  6. (of an output
     stream) a character or number (as appropriate to the element type
     of the stream) that is among the ordered series of objects that
     has been or will be written to the stream (using ÿwrite-charþ or
     ÿwrite-byteþ, as appropriate to the stream).  7. (of a class) a
     generalized instance of the class.

element type  n. 
     1. (of an array) the array element type of the array.  2. (of a
     stream) the stream element type of the stream.

em  n. Trad. 
     a context-dependent unit of measure commonly used in typesetting,
     equal to the displayed width of of a letter "M" in the current
     font.  (The letter "M" is traditionally chosen because it is
     typically represented by the widest glyph in the font, and other
     characters' widths are typically fractions of an em.  In
     implementations providing non-Roman characters with wider
     characters than "M," it is permissible for another character to be
     the implementation-defined reference character for this measure,
     and for "M" to be only a fraction of an em wide.)  In a fixed
     width font, a line with n characters is n ems wide; in a variable
     width font, n ems is the expected upper bound on the width of such
     a line.

empty list
     n.  the list containing no elements. See *Note (): glos-().

empty type  n.
     the type that contains no elements, and that is a subtype of all
     types (including itself).  See *Note nil: glos-nil.

end of file  n.
     1. the point in an input stream beyond which there is no further
     data.  Whether or not there is such a point on an interactive
     stream is implementation-defined.  2. a situation that occurs upon
     an attempt to obtain data from an input stream that is at the end
     of fileá.

environment  n.
     1. a set of bindings. See *Note Section 3.1.1 (Introduction to
     Environments): Introduction to Environments.  2. an environment
     object.  "ÿmacroexpandþ takes an optional environment argument."

environment object  n.
     an object representing a set of lexical bindings, used in the
     processing of a form to provide meanings for names within that
     form.  "ÿmacroexpandþ takes an optional environment argument."
     (The object ÿnilþ when used as an environment object denotes the
     null lexical environment; the values of environment parameters to
     macro functions are objects of implementation-dependent nature
     which represent the environmentá in which the corresponding macro
     form is to be expanded.)  See *Note Section 3.1.1.4 (Environment
     Objects): EnvObjs.

environment parameter  n.
     A parameter in a defining form f for which there is no
     corresponding argument; instead, this parameter receives as its
     value an environment object which corresponds to the lexical
     environment in which the defining form f appeared.

error  n.
     1. (only in the phrase "is an error") a situation in which the
     semantics of a program are not specified, and in which the
     consequences are undefined.  2. a condition which represents an
     error situation.  See *Note Section 1.4.2 (Error Terminology):
     Error Terminology.  3. an object of type ÿerrorþ.

error output  n. 
     the output stream which is the value of the dynamic variable
     ÿ*error-output*þ.

escape  n., adj.
     1. n. a single escape or a multiple escape.  2. adj. single escape
     or multiple escape.

establish  v.t. 
     to build or bring into being a  binding, a  declaration, an exit
     point, a  tag, a  handler, a restart, or an environment.  "ÿletþ
     establishes lexical bindings."

evaluate  v.t. (a form or an implicit progn)
     to execute the code represented by the form (or the series of
     forms making up the implicit progn) by applying the rules of
     evaluation, returning zero or more values.

evaluation  n.
     a model whereby forms are executed, returning zero or more values.
     Such execution might be implemented directly in one step by an
     interpreter or in two steps by first compiling the form and then
     executing the compiled code; this choice is dependent both on
     context and the nature of the implementation, but in any case is
     not in general detectable by any program.  The evaluation model is
     designed in such a way that a conforming implementation might
     legitimately have only a compiler and no interpreter, or vice
     versa.  See *Note Section 3.1.2 (The Evaluation Model): The
     Evaluation Model.

evaluation environment  n.
     a run-time environment in which macro expanders and code specified
     by ÿeval-whenþ to be evaluated are evaluated.  All evaluations
     initiated by the compiler take place in the evaluation environment.

execute  v.t. Trad. (code)
     to perform the imperative actions represented by the code.

execution time  n.
     the duration of time that compiled code is being executed.

exhaustive partition  n. (of a type)
     a set of pairwise disjoint types that form an exhaustive union.

exhaustive union  n. (of a type)
     a set of subtypes of the type, whose union contains all elements
     of that type.

exit point  n.
     a point in a control form from which (e.g., ÿblockþ), through
     which (e.g., ÿunwind-protectþ), or to which (e.g., ÿtagbodyþ)
     control and possibly values can be transferred both actively by
     using another control form and passively through the normal
     control and data flow of evaluation.  "ÿcatchþ and ÿblockþ
     establish bindings for exit points to which ÿthrowþ and
     ÿreturn-fromþ, respectively, can transfer control and values;
     ÿtagbodyþ establishes a binding for an exit point with lexical
     extent to which ÿgoþ can transfer control; and ÿunwind-protectþ
     establishes an exit point through which control might be
     transferred by operators such as ÿthrowþ, ÿreturn-fromþ, and ÿgoþ."

explicit return  n. 
     the act of transferring control (and possibly values) to a block
     by using ÿreturn-fromþ (or ÿreturnþ).

explicit use  n. (of a variable V in a form F)
     a reference to V that is directly apparent in the normal semantics
     of F; i.e., that does not expose any undocumented details of the
     macro expansion of the form itself.  References to V exposed by
     expanding subforms of F are, however, considered to be explicit
     uses of V.

exponent marker  n.
     a character that is used in the textual notation for a float to
     separate the mantissa from the exponent.  The characters defined
     as exponent markers in the standard readtable are shown in the
     next figure.  For more information, see *Note Section 2.1
     (Character Syntax): Character Syntax.  "The exponent marker `d' in
     `3.0d7' indicates that this number is to be represented as a
     double float."

     Marker       Meaning
     ----------------------------------------------------------- 
     ÿDþ or ÿdþ   ÿdouble-floatþ
     ÿEþ or ÿeþ   ÿfloatþ (see ÿ*read-default-float-format*þ)
     ÿFþ or ÿfþ   ÿsingle-floatþ
     ÿLþ or ÿlþ   ÿlong-floatþ
     ÿSþ or ÿsþ   ÿshort-floatþ

     Figure 26.1: Exponent Markers

export  v.t. (a symbol in a package)
     to add the symbol to the list of external symbols of the package.

exported  adj. (of a symbol in a package)
     being an external symbol of the package.

expressed adjustability
     n. (of an array) a generalized boolean that is conceptually (but
     not necessarily actually) associated with the array, representing
     whether the array is expressly adjustable.  See also *Note actual
     adjustability: glos-actual adjustability.

expressed array element type  n. (of an array)
     the type which is the array element type implied by a type
     declaration for the array, or which is the requested array element
     type at its time of creation, prior to any selection of an
     upgraded array element type.  (Common Lisp does not provide a way
     of detecting this type directly at run time, but an implementation
     is permitted to make assumptions about the array's contents and
     the operations which may be performed on the array when this type
     is noted during code analysis, even if those assumptions would not
     be valid in general for the upgraded array element type of the
     expressed array element type.)

expressed complex part type  n. (of a complex)
     the type which is implied as the complex part type by a type
     declaration for the complex, or which is the requested complex
     part type at its time of creation, prior to any selection of an
     upgraded complex part type.  (Common Lisp does not provide a way
     of detecting this type directly at run time, but an implementation
     is permitted to make assumptions about the operations which may be
     performed on the complex when this type is noted during code
     analysis, even if those assumptions would not be valid in general
     for the upgraded complex part type of the expressed complex part
     type.)

expression  n.
     1. an object, often used to emphasize the use of the object to
     encode or represent information in a specialized format, such as
     program text.  "The second expression in a ÿletþ form is a list of
     bindings."  2. the textual notation used to notate an object in a
     source file.  "The expression ÿ'sampleþ is equivalent to ÿ(quote
     sample)þ."

expressly adjustable  adj. (of an array)
     being actually adjustable by virtue of an explicit request for this
     characteristic having been made at the time of its creation.  All
     arrays that are expressly adjustable are actually adjustable, but
     not necessarily vice versa.

extended character  n.
     a character of type ÿextended-charþ: a character that is not a
     base character.

extended function designator
     n.  a designator for a function; that is, an object that denotes a
     function and that is one of: a function name (denoting the
     function it names in the global environment), or a function
     (denoting itself).  The consequences are undefined if a function
     name is used as an extended function designator but it does not
     have a global definition as a function, or if it is a symbol that
     has a global definition as a macro or a special form.  See also
     *Note function designator: glos-function designator.

extended lambda list  n.
     a list resembling an ordinary lambda list in form and purpose, but
     offering additional syntax or functionality not available in an
     ordinary lambda list.  "ÿdefmacroþ uses extended lambda lists."

extension  n.
     a facility in an implementation of Common Lisp  that is not
     specified by this standard.

extent  n.
     the interval of time during which a reference to an object, a
     binding, an exit point, a  tag, a  handler, a  restart, or an
     environment is defined.

external file format  n.
     an object of implementation-dependent nature which determines one
     of possibly several implementation-dependent ways in which
     characters are encoded externally in a character file.

external file format designator  n.
     a designator for an external file format; that is, an object that
     denotes an external file format and that is one of: the symbol
     :default (denoting an implementation-dependent default external
     file format that can accomodate at least the base characters),
     some other object defined by the implementation to be an external
     file format designator (denoting an implementation-defined
     external file format), or some other object defined by the
     implementation to be an external file format (denoting itself).

external symbol  n. (of a package)
     a symbol that is part of the `external interface' to the package
     and that are inheritedß by any other package that uses the package.
     When using the Lisp reader, if a package prefix is used, the name
     of an external symbol is separated from the package name by a
     single package marker while the name of an internal symbol is
     separated from the package name by a double package marker; see
     *Note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens.

externalizable object  n.
     an object that can be used as a literal object in code to be
     processed by the file compiler.



File: chris-ansicl.info,  Node: F,  Next: G,  Prev: E,  Up: Glossary

F
=

false  n.
     the symbol ÿnilþ, used to represent the failure of a predicate
     test.

fbound  [êeféba.und] adj. 
     (of a function name) bound in the function namespace.  (The names
     of macros and special operators are fbound, but the nature and
     type of the object which is their value is
     implementation-dependent.  Further, defining a setf expander F
     does not cause the setf function ÿ(setf F)þ to become defined; as
     such, if there is a such a definition of a setf expander F, the
     function ÿ(setf F)þ can be fbound if and only if, by design or
     coincidence, a function binding for ÿ(setf F)þ has been
     independently established.)  See the functions *Note fboundp:: and
     ÿsymbol-functionþ.

feature  n.
     1. an aspect or attribute of Common Lisp, of the implementation,
     or of the environment.  2. a symbol that names a featureá.  See
     *Note Section 24.1.2 (Features): Features.  "The :ansi-cl feature
     is present in all conforming implementations."

feature expression  n.
     A boolean combination of features used by the ÿ#+þ and ÿ#-þ reader
     macros in order to direct conditional reading of expressions by
     the Lisp reader.  See *Note Section 24.1.2.1 (Feature
     Expressions): FeatureExpressions.

features list  n.
     the list that is the value of ÿ*features*þ.

file  n.
     a named entry in a file system, having an implementation-defined
     nature.

file compiler  n.
     any compiler which compiles source code contained in a file,
     producing a compiled file as output.  The ÿcompile-fileþ function
     is the only interface to such a compiler provided by Common Lisp,
     but there might be other, implementation-defined mechanisms for
     invoking the file compiler.

file position  n. (in a stream)
     a non-negative integer that represents a position in the stream.
     Not all streams are able to represent the notion of file position;
     in the description of any operator which manipulates file
     positions, the behavior for streams that don't have this notion
     must be explicitly stated.  For binary streams, the file position
     represents the number of preceding bytes in the stream.  For
     character streams, the constraint is more relaxed: file positions
     must increase monotonically, the amount of the increase between
     file positions corresponding to any two successive characters in
     the stream is implementation-dependent.

file position designator  n. (in a stream)
     a designator for a file position in that stream; that is, the
     symbol :start (denoting ÿ0þ, the first file position in that
     stream), the symbol :end (denoting the last file position in that
     stream; i.e., the position following the last element of the
     stream), or a file position (denoting itself).

file stream  n.
     an object of type ÿfile-streamþ.

file system  n.
     a facility which permits aggregations of data to be stored in named
     files on some medium that is external to the Lisp image and that
     therefore persists from session to session.

filename  n.
     a handle, not necessarily ever directly represented as an object,
     that can be used to refer to a file in a file system.  Pathnames
     and namestrings are two kinds of objects that substitute for
     filenames in Common Lisp.

fill pointer  n. (of a vector)
     an integer associated with a vector that represents the index
     above which no elements are active.  (A fill pointer is a
     non-negative integer no larger than the total number of elements
     in the vector.  Not all vectors have fill pointers.)

finite  adj. (of a type)
     having a finite number of elements.  "The type specifier ÿ(integer
     0 5)þ denotes a finite type, but the type specifiers ÿintegerþ and
     ÿ(integer 0)þ do not."

fixnum  n. 
     an integer of type ÿfixnumþ.

float  n.
     an object of type ÿfloatþ.

for-value  adj. (of a reference to a binding)
     being a reference that readsá the value of the binding.

form  n.
     1. any object meant to be evaluated.  2.    a symbol, a compound
     form, or a self-evaluating object.  3. (for an operator, as in
     "«operator» form") a compound form having that operator as its
     first element.  "A ÿquoteþ form is a constant form."

formal argument  n. Trad. 
     a parameter.

formal parameter  n. Trad. 
     a parameter.

format  v.t. (a format control and format arguments)
     to perform output as if by ÿformatþ, using the format string and
     format arguments.

format argument  n.
     an object which is used as data by functions such as ÿformatþ
     which interpret format controls.

format control  n.
     a format string, or a function that obeys the argument conventions
     for a function returned by the ÿformatterþ macro.  See *Note
     Section 22.2.1.3 (Compiling Format Strings):
     CompilingFormatStrings.

format directive  n.
     1. a sequence of characters in a format string which is introduced
     by a tilde, and which is specially interpreted by code which
     processes format strings to mean that some special operation
     should be performed, possibly involving data supplied by the
     format arguments that accompanied the format string.  See the
     function *Note format::.  "In ÿ"~D base 10 = ~8R"þ, the character
     sequences `ÿ~Dþ' and `ÿ~8Rþ' are format directives."  2. the
     conceptual category of all format directivesá which use the same
     dispatch character.  "Both ÿ"~3d"þ and ÿ"~3,'0D"þ are valid uses
     of the `ÿ~Dþ' format directive."

format string  n.
     a string which can contain both ordinary text and format
     directives, and which is used in conjunction with format arguments
     to describe how text output should be formatted by certain
     functions, such as ÿformatþ.

free declaration  n.
     a declaration that is not a bound declaration.  See *Note
     declare::.

fresh  adj. 
     1. (of an object yielded by a function) having been
     newly-allocated by that function.  (The caller of a function that
     returns a fresh object may freely modify the object without fear
     that such modification will compromise the future correct behavior
     of that function.)  2. (of a binding for a name) newly-allocated;
     not shared with other bindings for that name.

freshline  n.
     a conceptual operation on a stream, implemented by the function
     ÿfresh-lineþ and by the format directive ÿ~&þ, which advances the
     display position to the beginning of the next line (as if a
     newline had been typed, or the function ÿterpriþ had been called)
     unless the stream is already known to be positioned at the
     beginning of a line.  Unlike newline, freshline is not a character.

funbound  [êefunba.und] n. (of a function name)
     not fbound.

function  n.
     1. an object representing code, which can be called with zero or
     more arguments, and which produces zero or more values.  2. an
     object of type ÿfunctionþ.

function block name  n. (of a function name)
     The symbol that would be used as the name of an implicit block
     which surrounds the body of a function having that function name.
     If the function name is a symbol, its function block name is the
     function name itself.  If the function name is a list whose car is
     setf and whose cadr is a symbol, its function block name is the
     symbol that is the cadr of the function name.  An implementation
     which supports additional kinds of function names must specify for
     each how the corresponding function block name is computed.

function cell  n. Trad. (of a symbol)
     The place which holds the definition of the global function
     binding, if any, named by that symbol, and which is accessed by
     ÿsymbol-functionþ.  See *Note cell: glos-cell.

function designator
     n.  a designator for a function; that is, an object that denotes a
     function and that is one of: a symbol (denoting the function named
     by that symbol in the global environment), or a function (denoting
     itself).  The consequences are undefined if a symbol is used as a
     function designator but it does not have a global definition as a
     function, or it has a global definition as a macro or a special
     form.  See also *Note extended function designator: glos-extended
     function designator.

function form  n.
     a form that is a list and that has a first element which is the
     name of a function to be called on arguments which are the result
     of evaluating subsequent elements of the function form.

function name  n. 
     1. (in an environment) A symbol or a list ÿ(setf symbol)þ that is
     the name of a function in that environment.  2. A symbol or a list
     ÿ(setf symbol)þ.

functional evaluation  n. 
     the process of extracting a functional value from a function name
     or a lambda expression.  The evaluator performs functional
     evaluation implicitly when it encounters a function name or a
     lambda expression in the car of a compound form, or explicitly
     when it encounters a ÿfunctionþ special form.  Neither a use of a
     symbol as a function designator nor a use of the function
     ÿsymbol-functionþ to extract the functional value of a symbol is
     considered a functional evaluation.

functional value  n. 
     1. (of a function name N in an environment E) The value of the
     binding named N in the function namespace for environment E; that
     is, the contents of the function cell named N in environment E.
     2. (of an fbound symbol S) the contents of the symbol's function
     cell; that is, the value of the binding named S in the function
     namespace of the global environment.  (A name that is a macro name
     in the global environment or is a special operator might or might
     not be fbound.  But if S is such a name and is fbound, the specific
     nature of its functional value is implementation-dependent; in
     particular, it might or might not be a function.)

further compilation  n. 
     implementation-dependent compilation beyond minimal compilation.
     Further compilation is permitted to take place at run time.
     "Block compilation and generation of machine-specific instructions
     are examples of further compilation."



File: chris-ansicl.info,  Node: G,  Next: H,  Prev: F,  Up: Glossary

G
=

general  adj. (of an array)
     having element type ÿtþ, and consequently able to have any object
     as an element.

generalized boolean
     n.  an object used as a truth value, where the symbol ÿnilþ 
     represents false and all other objects represent true.  See *Note
     boolean: glos-boolean.

generalized instance  n. (of a class)
     an object the class of which is either that class itself, or some
     subclass of that class.  (Because of the correspondence between
     types and classes, the term "generalized instance of X" implies
     "object of type X" and in cases where X is a class (or class name)
     the reverse is also true.  The former terminology emphasizes the
     view of X as a class while the latter emphasizes the view of X as
     a type specifier.)

generalized reference  n.
     a reference to a location storing an object as if to a variable.
     (Such a reference can be either to read or write the location.)
     See *Note Section 5.1 (Generalized Reference): Generalized
     Reference.  See also place.

generalized synonym stream  n. (with a synonym stream symbol)
     1. (to a stream) a synonym stream to the stream, or a composite
     stream which has as a target a generalized synonym stream to the
     stream.  2. (to a symbol) a synonym stream to the symbol, or a
     composite stream which has as a target a generalized synonym
     stream to the symbol.

generic function  n.
     a function whose behavior depends on the classes or identities of
     the arguments supplied to it and whose parts include, among other
     things, a set of methods, a lambda list, and a method combination
     type.

generic function lambda list  n.
     A lambda list that is used to describe data flow into a generic
     function.  See *Note Section 3.4.2 (Generic Function Lambda
     Lists): Generic Function Lambda Lists.

gensym  n. Trad. 
     an uninterned symbol.  See the function *Note gensym::.

global declaration  n. 
     a form that makes certain kinds of information about code globally
     available; that is, a ÿproclaimþ form or a ÿdeclaimþ form.

global environment  n. 
     that part of an environment that contains bindings with indefinite
     scope and indefinite extent.

global variable  n.
     a dynamic variable or a constant variable.

glyph  n. 
     a visual representation.  "Graphic characters have associated
     glyphs."

go  v. 
     to transfer control to a go point.  See the special operator *Note
     go::.

go point
     one of possibly several exit points that are established by
     ÿtagbodyþ (or other abstractions, such as ÿprogþ, which are built
     from ÿtagbodyþ).

go tag  n. 
     the symbol or integer that, within the lexical scope of a
     ÿtagbodyþ form, names an exit point established by that ÿtagbodyþ
     form.

graphic  adj. (of a character)
     being a "printing" or "displayable" character that has a standard
     visual representation as a single glyph, such as ÿAþ or ÿ*þ or ÿ=þ.
     Space is defined to be graphic.  Of the standard characters, all
     but newline are graphic.  See *Note non-graphic: glos-non-graphic.



File: chris-ansicl.info,  Node: H,  Next: I,  Prev: G,  Up: Glossary

H
=

handle  v. (of a condition being signaled)
     to perform a non-local transfer of control, terminating the ongoing
     signaling of the condition.

handler  n. 
     a condition handler.

hash table  n. 
     an object of type ÿhash-tableþ, which provides a mapping from keys
     to values.

home package  n. (of a symbol)
     the package, if any, which is contents of the package cell of the
     symbol, and which dictates how the Lisp printer prints the symbol
     when it is not accessible in the current package. (Symbols which
     have ÿnilþ in their package cell are said to have no home package,
     and also to be apparently uninterned.)



File: chris-ansicl.info,  Node: I,  Next: K,  Prev: H,  Up: Glossary

I
=

I/O customization variable  n.
     one of the stream variables in the next figure, or some other
     (implementation-defined) stream variable that is defined by the
     implementation to be an I/O customization variable.

     *debug-io*         *error-io*          query-io*
     *standard-input*   *standard-output*   *trace-output*

     Figure 26.2: Standardized I/O Customization Variables

identical  adj. 
     the same under ÿeqþ.

identifier  n. 
     1. a symbol used to identify or to distinguish names.  2. a string
     used the same way.

immutable  adj.
     not subject to change, either because no operator is provided
     which is capable of effecting such change or because some
     constraint exists which prohibits the use of an operator that
     might otherwise be capable of effecting such a change.  Except as
     explicitly indicated otherwise, implementations are not required
     to detect attempts to modify immutable objects or cells; the
     consequences of attempting to make such modification are undefined.
     "Numbers are immutable."

implementation  n. 
     a system, mechanism, or body of code that implements the semantics
     of Common Lisp.

implementation limit  n. 
     a restriction imposed by an implementation.

implementation-defined  adj. 
     implementation-dependent, but required by this specification to be
     defined by each conforming implementation and to be documented by
     the corresponding implementor.

implementation-dependent  adj. 
     describing a behavior or aspect of Common Lisp which has been
     deliberately left unspecified, that might be defined in some
     conforming implementations but not in others, and whose details
     may differ between implementations.  A conforming implementation
     is encouraged (but not required) to document its treatment of each
     item in this specification which is marked
     implementation-dependent, although in some cases such
     documentation might simply identify the item as "undefined."

implementation-independent  adj. 
     used to identify or emphasize a behavior or aspect of Common
     Lisp which does not vary between conforming implementations.

implicit block  n. 
     a block introduced by a macro form rather than by an explicit
     ÿblockþ form.

implicit compilation  n. 
     compilation performed during evaluation.

implicit progn  n. 
     an ordered set of adjacent forms appearing in another form, and
     defined by their context in that form to be executed as if within
     a ÿprognþ.

implicit tagbody  n. 
     an ordered set of adjacent forms and/or tags appearing in another
     form, and defined by their context in that form to be executed as
     if within a ÿtagbodyþ.

import  v.t. (a symbol into a package)
     to make the symbol be present in the package.

improper list
     n.  a list which is not a proper list: a circular list or a dotted
     list.

inaccessible  adj. 
     not accessible.

indefinite extent
     n.  an extent whose duration is unlimited.  "Most Common Lisp
     objects have indefinite extent."

indefinite scope  n. 
     scope that is unlimited.

indicator  n. 
     a property indicator.

indirect instance  n. (of a class Cá)
     an object of class Cà, where Cà is a subclass of Cá.  "An integer
     is an indirect instance of the class ÿnumberþ."

inherit  v.t. 
     1. to receive or acquire a quality, trait, or characteristic; to
     gain access to a feature defined elsewhere.  2. (a class) to
     acquire the structure and behavior defined by a superclass.  3. (a
     package) to make symbols exported by another package accessible by
     using ÿuse-packageþ.

initial pprint dispatch table  n.
     the value of ÿ*print-pprint-dispatch*þ at the time the Lisp image
     is started.

initial readtable  n.
     the value of ÿ*readtable*þ at the time the Lisp image is started.

initialization argument list  n. 
     a property list of initialization argument names and values used
     in the protocol for initializing and reinitializing instances of
     classes.  See *Note Section 7.1 (Object Creation and
     Initialization): Object Creation and Initialization.

initialization form  n. 
     a form used to supply the initial value for a slot or variable.
     "The initialization form for a slot in a ÿdefclassþ form is
     introduced by the keyword :initform."

input  adj. (of a stream)
     supporting input operations (i.e., being a "data source").  An
     input stream might also be an output stream, in which case it is
     sometimes called a bidirectional stream.  See the function *Note
     input-stream-p::.

instance  n. 
     1. a direct instance.  2. a generalized instance.  3. an indirect
     instance.

integer  n. 
     an object of type ÿintegerþ, which represents a mathematical
     integer.

interactive stream  n. 
     a stream on which it makes sense to perform interactive querying.
     See *Note Section 21.1.1.1.3 (Interactive Streams):
     InteractiveStreams.

intern  v.t. 
     1. (a string in a package) to look up the string in the package,
     returning either a symbol with that name which was already
     accessible in the package or a newly created internal symbol of
     the package with that name.  2. Idiom. generally, to observe a
     protocol whereby objects which are equivalent or have equivalent
     names under some predicate defined by the protocol are mapped to a
     single canonical object.

internal symbol  n. (of a package)
     a symbol which is accessible in the package, but which is not an
     external symbol of the package.

internal time  n.
     time, represented as an integer number of internal time units.
     Absolute internal time is measured as an offset from an
     arbitrarily chosen, implementation-dependent base.  See *Note
     Section 25.1.4.3 (Internal Time): InternalTime.

internal time unit  n. 
     a unit of time equal to 1/n of a second, for some
     implementation-defined integer value of n.  See the variable *Note
     internal-time-units-per-second::.

interned  adj. Trad. 
     1. (of a symbol) accessibleß in any package.  2. (of a symbol in a
     specific package) present in that package.

interpreted function  n. 
     a function that is not a compiled function.  (It is possible for
     there to be a conforming implementation which has no interpreted
     functions, but a conforming program must not assume that all
     functions are compiled functions.)

interpreted implementation  n.
     an implementation that uses an execution strategy for interpreted
     functions that does not involve a one-time semantic analysis
     pre-pass, and instead uses "lazy" (and sometimes repetitious)
     semantic analysis of forms as they are encountered during
     execution.

interval designator  n. (of type T)
     an ordered pair of objects that describe a subtype of T by
     delimiting an interval on the real number line.  See *Note Section
     12.1.6 (Interval Designators): Interval Designators.

invalid  n., adj.
     1. n.  a possible constituent trait of a character which if
     present signifies that the character cannot ever appear in a token
     except under the control of a single escape character.  For
     details, see *Note Section 2.1.4.1 (Constituent Characters):
     ConstituentChars.  2. adj. (of a character) being a character that
     has syntax type constituent in the current readtable and that has
     the constituent trait invalidá.  See *Note Figure 2.8:
     ConstituentTraitsOfStdChars.

iteration form  n.
     a compound form whose operator is named in the next figure, or a
     compound form that has an implementation-defined operator and that
     is defined by the implementation to be an iteration form.

     do               do-external-symbols   dotimes
     do*              do-symbols            loop
     do-all-symbols   dolist                

     Figure 26.3: Standardized Iteration Forms

iteration variable  n.
     a variable V, the binding for which was created by an explicit use
     of V in an iteration form.



File: chris-ansicl.info,  Node: K,  Next: L,  Prev: I,  Up: Glossary

K
=

key  n. 
     an object used for selection during retrieval.  See *Note
     association list: glos-association list, property list, and hash
     table.  Also, see *Note Section 17.1 (Sequence Concepts): Sequence
     Concepts.

keyword  n. 
     1. a symbol the home package of which is the ÿKEYWORDþ package.
     2. any symbol, usually but not necessarily in the ÿKEYWORDþ
     package, that is used as an identifying marker in keyword-style
     argument passing.  See *Note lambda (Symbol)::.  3. Idiom. a
     lambda list keyword.

keyword parameter  n.
     A parameter for which a corresponding keyword argument is
     optional.  (There is no such thing as a required keyword argument.)
     If the argument is not supplied, a default value is used.  See
     also *Note supplied-p parameter: glos-supplied-p parameter.

keyword/value pair  n. 
     two successive elements (a keyword and a value, respectively) of a
     property list.



File: chris-ansicl.info,  Node: L,  Next: M,  Prev: K,  Up: Glossary

L
=

lambda combination  n. Trad. 
     a lambda form.

lambda expression  n. 
     a list which can be used in place of a function name in certain
     contexts to denote a function by directly describing its behavior
     rather than indirectly by referring to the name of an established
     function; its name derives from the fact that its first element is
     the symbol ÿlambdaþ.  See *Note lambda (Symbol)::.

lambda form  n. 
     a form that is a list and that has a first element which is a
     lambda expression representing a function to be called on
     arguments which are the result of evaluating subsequent elements
     of the lambda form.

lambda list  n. 
     a list that specifies a set of parameters (sometimes called lambda
     variables) and a protocol for receiving values for those
     parameters; that is, an ordinary lambda list, an extended lambda
     list, or a modified lambda list.

lambda list keyword  n. 
     a symbol whose name begins with ampersand and that is specially
     recognized in a lambda list.  Note that no standardized lambda
     list keyword is in the ÿKEYWORDþ package.

lambda variable  n. 
     a formal parameter, used to emphasize the variable's relation to
     the lambda list that established it.

leaf  n. 
     1. an atom in a treeá.  2. a terminal node of a treeà.

leap seconds  n.
     additional one-second intervals of time that are occasionally
     inserted into the true calendar by official timekeepers as a
     correction similar to "leap years."  All Common Lisp time
     representations ignore leap seconds; every day is assumed to be
     exactly 86400 seconds long.

left-parenthesis  n.
     the standard character "ÿ(þ", that is variously called "left
     parenthesis" or "open parenthesis" See *Note Figure 2.5:
     StdCharsThree.

length  n. (of a sequence)
     the number of elements in the sequence.  (Note that if the
     sequence is a vector with a fill pointer, its length is the same
     as the fill pointer even though the total allocated size of the
     vector might be larger.)

lexical binding  n. 
     a binding in a lexical environment.

lexical closure  n. 
     a function that, when invoked on arguments, executes the body of a
     lambda expression in the lexical environment that was captured at
     the time of the creation of the lexical closure, augmented by
     bindings of the function's parameters to the corresponding
     arguments.

lexical environment  n. 
     that part of the environment that contains bindings whose names
     have lexical scope. A lexical environment contains, among other
     things: ordinary bindings of variable names to values, lexically
     established bindings of function names to functions, macros,
     symbol macros, blocks, tags, and local declarations (see *Note
     declare::).

lexical scope  n. 
     scope that is limited to a spatial or textual region within the
     establishing form.  "The names of parameters to a function
     normally are lexically scoped."

lexical variable  n. 
     a variable the binding for which is in the lexical environment.

Lisp image  n.
     a running instantiation of a Common Lisp implementation.  A Lisp
     image is characterized by a single address space in which any
     object can directly refer to any another in conformance with this
     specification, and by a single, common, global environment.
     (External operating systems sometimes call this a "core image,"
     "fork," "incarnation," "job," or "process."  Note however, that
     the issue of a "process" in such an operating system is
     technically orthogonal to the issue of a Lisp image being defined
     here.  Depending on the operating system, a single "process" might
     have multiple Lisp images, and multiple "processes" might reside
     in a single Lisp image.  Hence, it is the idea of a fully shared
     address space for direct reference among all objects which is the
     defining characteristic.  Note, too, that two "processes" which
     have a communication area that permits the sharing of some but not
     all objects are considered to be distinct Lisp images.)

Lisp printer  n. Trad. 
     the procedure that prints the character representation of an
     object onto a stream. (This procedure is implemented by the
     function ÿwriteþ.)

Lisp read-eval-print loop  n. Trad. 
     an endless loop that readsà a form, evaluates it, and prints
     (i.e., writesà) the results.  In many implementations, the default
     mode of interaction with Common Lisp during program development is
     through such a loop.

Lisp reader  n. Trad. 
     the procedure that parses character representations of objects
     from a stream, producing objects.  (This procedure is implemented
     by the function ÿreadþ.)

list  n. 
     1. a chain of conses in which the car of each cons is an element
     of the list, and the cdr of each cons is either the next link in
     the chain or a terminating atom.  See also *Note proper list:
     glos-proper list, dotted list, or circular list.  2. the type that
     is the union of ÿnullþ and ÿconsþ.

list designator  n.
     a designator for a list of objects; that is, an object that
     denotes a list and that is one of: a non-nil atom (denoting a
     singleton list whose element is that non-nil atom) or a proper
     list (denoting itself).

list structure  n. (of a list)
     the set of conses that make up the list.  Note that while the
     car[1b] component of each such cons is part of the list structure,
     the objects that are elements of the list (i.e., the objects that
     are the carsà of each cons in the list) are not themselves part of
     its list structure, even if they are conses, except in the
     (circularà) case where the list actually contains one of its tails
     as an element.  (The list structure of a list is sometimes
     redundantly referred to as its "top-level list structure" in order
     to emphasize that any conses that are elements of the list are not
     involved.)

literal  adj. (of an object)
     referenced directly in a program rather than being computed by the
     program; that is, appearing as data in a ÿquoteþ form, or, if the
     object is a self-evaluating object, appearing as unquoted data.
     "In the form ÿ(cons "one" '("two"))þ, the expressions ÿ"one"þ,
     ÿ("two")þ, and ÿ"two"þ are literal objects."

load  v.t. (a file)
     to cause the code contained in the file to be executed.  See the
     function *Note load::.

load time  n.
     the duration of time that the loader is loading compiled code.

load time value  n. 
     an object referred to in code by a ÿload-time-valueþ form.  The
     value of such a form is some specific object which can only be
     computed in the run-time environment.  In the case of file
     compilation, the value is computed once as part of the process of
     loading the compiled file, and not again.  See the special
     operator *Note load-time-value::.

loader  n.
     a facility that is part of Lisp and that loads a file.  See the
     function *Note load::.

local declaration  n. 
     an expression which may appear only in specially designated
     positions of certain forms, and which provides information about
     the code contained within the containing form; that is, a declare
     expression.

local precedence order  n. (of a class)
     a list consisting of the class followed by its direct superclasses
     in the order mentioned in the defining form for the class.

local slot  n. (of a class)
     a slot accessible in only one instance, namely the instance in
     which the slot is allocated.

logical block  n.
     a conceptual grouping of related output used by the pretty printer.
     See the macro *Note pprint-logical-block:: and *Note Section
     22.2.1.1 (Dynamic Control of the Arrangement of Output):
     DynamicControlofOutput.

logical host  n.
     an object of implementation-dependent nature that is used as the
     representation of a "host" in a logical pathname, and that has an
     associated set of translation rules for converting logical
     pathnames belonging to that host into physical pathnames.  See
     *Note Section 19.3 (Logical Pathnames): Logical Pathnames.

logical host designator  n.
     a designator for a logical host; that is, an object that denotes a
     logical host and that is one of: a string (denoting the logical
     host that it names), or a logical host (denoting itself).  (Note
     that because the representation of a logical host is
     implementation-dependent, it is possible that an implementation
     might represent a logical host as the string that names it.)

logical pathname  n. 
     an object of type ÿlogical-pathnameþ.

long float  n. 
     an object of type ÿlong-floatþ.

loop keyword  n. Trad.
     a symbol that is a specially recognized part of the syntax of an
     extended ÿloopþ form.  Such symbols are recognized by their name
     (using ÿstring=þ), not by their identity; as such, they may be in
     any package.  A loop keyword is not a keyword.

lowercase  adj. (of a character)
     being among standard characters corresponding to the small letters
     ÿaþ through ÿzþ, or being some other implementation-defined
     character that is defined by the implementation to be lowercase.
     See *Note Section 13.1.4.3 (Characters With Case):
     CharactersWithCase.



File: chris-ansicl.info,  Node: M,  Next: N,  Prev: L,  Up: Glossary

M
=

macro  n. 
     1. a macro form 2. a macro function.  3. a macro name.

macro character  n. 
     a character which, when encountered by the Lisp reader in its main
     dispatch loop, introduces a reader macroá.  (Macro characters have
     nothing to do with macros.)

macro expansion  n. 
     1. the process of translating a macro form into another form.  2.
     the form resulting from this process.

macro form  n. 
     a form that stands for another form (e.g., for the purposes of
     abstraction, information hiding, or syntactic convenience); that
     is, either a compound form whose first element is a macro name, or
        a form that is a symbol that names a symbol macro.

macro function  n. 
     a function of two arguments, a form and an environment, that
     implements macro expansion by producing a form to be evaluated in
     place of the original argument form.

macro lambda list  n.
     an extended lambda list used in forms that establish macro
     definitions, such as ÿdefmacroþ and ÿmacroletþ.  See *Note Section
     3.4.4 (Macro Lambda Lists): Macro Lambda Lists.

macro name  n. 
     a name for which ÿmacro-functionþ returns true and which when used
     as the first element of a compound form identifies that form as a
     macro form.

macroexpand hook  n.
     the function that is the value of ÿ*macroexpand-hook*þ.

mapping  n. 
     1. a type of iteration in which a function is successively applied
     to objects taken from corresponding entries in collections such as
     sequences or hash tables.  2. Math. a relation between two sets in
     which each element of the first set (the "domain") is assigned one
     element of the second set (the "range").

metaclass  n. 
     1. a class whose instances are classes.  2. (of an object) the
     class of the class of the object.

Metaobject Protocol  n.
     one of many possible descriptions of how a conforming
     implementation might implement various aspects of the object
     system.  This description is beyond the scope of this document,
     and no conforming implementation is required to adhere to it
     except as noted explicitly in this specification.  Nevertheless,
     its existence helps to establish normative practice, and
     implementors with no reason to diverge from it are encouraged to
     consider making their implementation adhere to it where possible.
     It is described in detail in `The Art of the Metaobject Protocol'.

method  n. 
     an object that is part of a generic function and which provides
     information about how that generic function should behave when its
     arguments are objects of certain classes or with certain
     identities.

method combination  n. 
     1. generally, the composition of a set of methods to produce an
     effective method for a generic function.  2. an object of type
     ÿmethod-combinationþ, which represents the details of how the
     method combinationá for one or more specific generic functions is
     to be performed.

method-defining form  n. 
     a form that defines a method for a generic function, whether
     explicitly or implicitly.  See *Note Section 7.6.1 (Introduction
     to Generic Functions): Introduction to Generic Functions.

method-defining operator  n.
     an operator corresponding to a method-defining form.  See *Note
     Figure 7.1: StdMethDefOps.

minimal compilation  n.
     actions the compiler must take at compile time.  See *Note Section
     3.2.2 (Compilation Semantics): Compilation Semantics.

modified lambda list
     n.  a list resembling an ordinary lambda list in form and purpose,
     but which deviates in syntax or functionality from the definition
     of an ordinary lambda list.  See *Note ordinary lambda list:
     glos-ordinary lambda list.  "ÿdeftypeþ uses a modified lambda
     list."

most recent  adj.
     innermost; that is, having been established (and not yet
     disestablished) more recently than any other of its kind.

multiple escape  n., adj.
     1. n. the syntax type of a character that is used in pairs  to
     indicate that the enclosed characters are to be treated as
     alphabeticà characters with their case preserved.  For details,
     see *Note Section 2.1.4.5 (Multiple Escape Characters):
     MultipleEscapeChar.  2. adj. (of a character) having the multiple
     escape syntax type.  3. n. a multiple escapeà character.  (In the
     standard readtable, vertical-bar is a multiple escape character.)

multiple values  n. 
     1. more than one value.  "The function ÿtruncateþ returns multiple
     values."  2. a variable number of values, possibly including zero
     or one.  "The function ÿvaluesþ returns multiple values."  3. a
     fixed number of values other than one.  "The macro
     ÿmultiple-value-bindþ is among the few operators in Common
     Lisp which can detect and manipulate multiple values."



File: chris-ansicl.info,  Node: N,  Next: O,  Prev: M,  Up: Glossary

N
=

name  n., v.t. 
     1. n. an identifier by which an object, a binding, or an exit point
     is referred to by association using a binding.  2. v.t. to give a
     name to.  3. n. (of an object having a name component) the object
     which is that component.  "The string which is a symbol's name is
     returned by ÿsymbol-nameþ."  4. n. (of a pathname) a. the name
     component, returned by ÿpathname-nameþ.  b. the entire namestring,
     returned by ÿnamestringþ.  5. n. (of a character) a string that
     names the character and that has length greater than one.  (All
     non-graphic characters are required to have names unless they have
     some implementation-defined attribute which is not null.  Whether
     or not other characters have names is implementation-dependent.)

named constant  n. 
     a variable that is defined by Common Lisp, by the implementation,
     or by user code (see the macro *Note defconstant::) to always
     yield the same value when evaluated.  "The value of a named
     constant may not be changed by assignment or by binding."

namespace  n. 
     1. bindings whose denotations are restricted to a particular kind.
     "The bindings of names to tags is the tag namespace."  2. any
     mapping whose domain is a set of names.  "A package defines a
     namespace."

namestring  n. 
     a string that represents a filename using either the standardized
     notation for naming logical pathnames described in *Note Section
     19.3.1 (Syntax of Logical Pathname Namestrings): Syntax of Logical
     Pathname Namestrings, or some implementation-defined notation for
     naming a physical pathname.

newline  n.
     the standard character <Newline>, notated for the Lisp reader as
     ÿ#\Newlineþ.

next method  n. 
     the next method to be invoked with respect to a given method for a
     particular set of arguments or argument classes.  See *Note
     Section 7.6.6.1.3 (Applying method combination to the sorted list
     of applicable methods): ApplyMethCombToSortedMethods.

nickname  n. (of a package)
     one of possibly several names that can be used to refer to the
     package but that is not the primary name of the package.

nil
     n.  the object that is at once the symbol named ÿ"NIL"þ in the
     ÿCOMMON-LISPþ package, the empty list, the boolean (or generalized
     boolean) representing false, and the name of the empty type.

non-atomic  adj. 
     being other than an atom; i.e., being a cons.

non-constant variable  n.
     a variable that is not a constant variable.

non-correctable  adj. (of an error)
     not intentionally correctable.  (Because of the dynamic nature of
     restarts, it is neither possible nor generally useful to
     completely prohibit an error from being correctable.  This term is
     used in order to express an intent that no special effort should
     be made by code signaling an error to make that error correctable;
     however, there is no actual requirement on conforming programs or
     conforming implementations imposed by this term.)

non-empty  adj.
     having at least one element.

non-generic function  n. 
     a function that is not a generic function.

non-graphic
     adj. (of a character) not graphic.  See *Note Section 13.1.4.1
     (Graphic Characters): GraphicChars.

non-list  n., adj. 
     other than a list; i.e., a non-nil atom.

non-local exit  n. 
     a transfer of control (and sometimes values) to an exit point for
     reasons other than a normal return.  "The operators ÿgoþ, ÿthrowþ,
     and ÿreturn-fromþ cause a non-local exit."

non-nil  n., adj. 
     not ÿnilþ.  Technically, any object which is not ÿnilþ can be
     referred to as true, but that would tend to imply a unique view of
     the object as a generalized boolean.  Referring to such an object
     as non-nil avoids this implication.

non-null lexical environment  n. 
     a lexical environment that has additional information not present
     in the global environment, such as one or more bindings.

non-simple  adj.
     not simple.

non-terminating  adj. (of a macro character)
     being such that it is treated as a constituent character when it
     appears in the middle of an extended token.  See *Note Section 2.2
     (Reader Algorithm): Reader Algorithm.

non-top-level form  n. 
     a form that, by virtue of its position as a subform of another
     form, is not a top level form.  See *Note Section 3.2.3.1
     (Processing of Top Level Forms): TopLevelForms.

normal return  n. 
     the natural transfer of control and values which occurs after the
     complete execution of a form.

normalized  adj., ANSI, IEEE (of a float)
     conforming to the description of "normalized" as described by
     `IEEE Standard for Binary Floating-Point Arithmetic'.  See *Note
     denormalized: glos-denormalized.

null  adj., n. 
     1. adj.  a. (of a list) having no elements: empty.  See *Note
     empty list: glos-empty list.  b. (of a string) having a length of
     zero.  (It is common, both within this document and in observed
     spoken behavior, to refer to an empty string by an apparent
     definite reference, as in "the null string" even though no attempt
     is made to internà null strings.  The phrase "a null string" is
     technically more correct, but is generally considered awkward by
     most Lisp programmers.  As such, the phrase "the null string"
     should be treated as an indefinite reference in all cases except
     for anaphoric references.)  c. (of an implementation-defined
     attribute of a character) An object to which the value of that
     attribute defaults if no specific value was requested.  2. n. an
     object of type ÿnullþ (the only such object being ÿnilþ).

null lexical environment  n. 
     the lexical environment which has no bindings.

number  n.
     an object of type ÿnumberþ.

numeric  adj. (of a character)
     being one of the standard characters ÿ0þ through 9, or being some
     other graphic character defined by the implementation to be
     numeric.



File: chris-ansicl.info,  Node: O,  Next: P,  Prev: N,  Up: Glossary

O
=

object  n. 
     1. any Lisp datum.  "The function ÿconsþ creates an object which
     refers to two other objects."  2. (immediately following the name
     of a type) an object which is of that type, used to emphasize that
     the object is not just a name for an object of that type but
     really an element of the type in cases where objects of that type
     (such as ÿfunctionþ or ÿclassþ) are commonly referred to by name.
     "The function ÿsymbol-functionþ takes a function name and returns
     a function object."

object-traversing  adj. 
     operating in succession on components of an object.  "The
     operators ÿmapcarþ, ÿmaphashþ, ÿwith-package-iteratorþ and ÿcountþ
     perform object-traversing operations."

open  adj., v.t. (a file)
     1. v.t. to create and return a stream to the file.  2. adj. (of a
     stream) having been openedá, but not yet closed.

operator  n. 
     1. a function, macro, or special operator.  2. a symbol that names
     such a function, macro, or special operator.  3. (in a ÿfunctionþ
     special form) the cadr of the ÿfunctionþ special form, which might
     be either an operatorà or a lambda expression.  4. (of a compound
     form) the car of the compound form, which might be either an
     operatorà or a lambda expression, and which is never ÿ(setf
     symbol)þ.

optimize quality  n. 
     one of several aspects of a program that might be optimizable by
     certain compilers.  Since optimizing one such quality might
     conflict with optimizing another, relative priorities for
     qualities can be established in an ÿoptimizeþ declaration.  The
     standardized optimize qualities are ÿcompilation-speedþ (speed of
     the compilation process), ÿdebugþ (ease of debugging), ÿsafetyþ
     (run-time error checking), ÿspaceþ (both code size and run-time
     space), and ÿspeedþ (of the object code).  Implementations may
     define additional optimize qualities.

optional parameter  n.
     A parameter for which a corresponding positional argument is
     optional.  If the argument is not supplied, a default value is
     used.  See also *Note supplied-p parameter: glos-supplied-p
     parameter.

ordinary function  n. 
     a function that is not a generic function.

ordinary lambda list
     n.  the kind of lambda list used by lambda.  See *Note modified
     lambda list: glos-modified lambda list. and extended lambda list.
     "ÿdefunþ uses an ordinary lambda list."

otherwise inaccessible part  n. (of an object, Oá)
     an object, Oà, which would be made inaccessible if Oá were made
     inaccessible.  (Every object is an otherwise inaccessible part of
     itself.)

output  adj. (of a stream)
     supporting output operations (i.e., being a "data sink").  An
     output stream might also be an input stream, in which case it is
     sometimes called a bidirectional stream.  See the function *Note
     output-stream-p::.



File: chris-ansicl.info,  Node: P,  Next: Q,  Prev: O,  Up: Glossary

P
=

package  n. 
     an object of type ÿpackageþ.

package cell  n. Trad. (of a symbol)
     The place in a symbol that holds one of possibly several packages
     in which the symbol is interned, called the home package, or which
     holds ÿnilþ if no such package exists or is known.  See the
     function *Note symbol-package::.

package designator  n.
     a designator for a package; that is, an object that denotes a
     package and that is one of: a string designator (denoting the
     package that has the string that it designates as its name or as
     one of its nicknames), or a package (denoting itself).

package marker  n. 
     a character which is used in the textual notation for a symbol to
     separate the package name from the symbol name, and which is colon
     in the standard readtable.  See *Note Section 2.1 (Character
     Syntax): Character Syntax.

package prefix  n. 
     a notation preceding the name of a symbol in text that is
     processed by the Lisp reader, which uses a package name followed
     by one or more package markers, and which indicates that the
     symbol is looked up in the indicated package.

package registry  n.
     A mapping of names to package objects.  It is possible for there
     to be a package object which is not in this mapping; such a
     package is called an unregistered package.  Operators such as
     ÿfind-packageþ consult this mapping in order to find a package
     from its name.  Operators such as ÿdo-all-symbolsþ,
     ÿfind-all-symbolsþ, and ÿlist-all-packagesþ operate only on
     packages that exist in the package registry.

pairwise  adv. (of an adjective on a set)
     applying individually to all possible pairings of elements of the
     set.  "The types A, B, and C are pairwise disjoint if A and B are
     disjoint, B and C are disjoint, and A and C are disjoint."

parallel
     adj. Trad. (of binding or assignment) done in the style of
     ÿpsetqþ, ÿletþ, or ÿdoþ; that is, first evaluating all of the
     forms that produce values, and only then assigning or binding the
     variables (or places).  Note that this does not imply traditional
     computational "parallelism" since the forms that produce values
     are evaluated sequentially.  See *Note sequential: glos-sequential.

parameter  n. 
     1. (of a function) a variable in the definition of a function
     which takes on the value of a corresponding argument (or of a list
     of corresponding arguments) to that function when it is called, or
     which in some cases is given a default value because there is no
     corresponding argument.  2. (of a format directive) an object
     received as data flow by a format directive due to a prefix
     notation within the format string at the format directive's point
     of use.  See *Note Section 22.3 (Formatted Output): Formatted
     Output.  "In ÿ"~3,'0D"þ, the number ÿ3þ and the character ÿ#\0þ
     are parameters to the ÿ~Dþ format directive."

parameter specializer  n. 
     1. (of a method) an expression which constrains the method to be
     applicable only to argument sequences in which the corresponding
     argument matches the parameter specializer.  2. a class, or a list
     ÿ(eql object)þ.

parameter specializer name  n. 
     1. (of a method definition) an expression used in code to name a
     parameter specializer.  See *Note Section 7.6.2 (Introduction to
     Methods): Introduction to Methods.  2. a class, a symbol naming a
     class, or a list ÿ(eql form)þ.

pathname  n. 
     an object of type ÿpathnameþ, which is a structured representation
     of the name of a file.  A pathname has six components: a "host," a
     "device," a "directory," a "name," a "type," and a "version."

pathname designator  n.
     a designator for a pathname; that is, an object that denotes a
     pathname and that is one of: a pathname namestring (denoting the
     corresponding pathname), a stream associated with a file (denoting
     the pathname used to open the file; this may be, but is not
     required to be, the actual name of the file), or a pathname
     (denoting itself).  See *Note Section 21.1.1.1.2 (Open and Closed
     Streams): File Operations on Open and Closed Streams.

physical pathname  n.
     a pathname that is not a logical pathname.

place  n. 
     1. a form which is suitable for use as a generalized reference.
     2. the conceptual location referred to by such a placeá.

plist  [êpæélist] n. 
     a property list.

portable  adj. (of code)
     required to produce equivalent results and observable side effects
     in all conforming implementations.

potential copy  n. (of an object Oá subject to constriants)
     an object Oà that if the specified constraints are satisfied by Oá
     without any modification might or might not be identical to Oá, or
     else that must be a fresh object that resembles a copy of Oá
     except that it has been modified as necessary to satisfy the
     constraints.

potential number  n. 
     A textual notation that might be parsed by the Lisp reader in some
     conforming implementation as a number but is not required to be
     parsed as a number.  No object is a potential number--either an
     object is a number or it is not.  See *Note Section 2.3.1.1
     (Potential Numbers as Tokens): PotentialNumbersAsTokens.

pprint dispatch table  n. 
     an object that can be the value of ÿ*print-pprint-dispatch*þ and
     hence can control how objects are printed when ÿ*print-pretty*þ is
     true.  See *Note Section 22.2.1.4 (Pretty Print Dispatch Tables):
     PPrintDispatchTables.

predicate  n. 
     a function that returns a generalized boolean as its first value.

present  n.
     1. (of a feature in a Lisp image) a state of being that is in
     effect if and only if the symbol naming the feature is an element
     of the features list.  2. (of a symbol in a package) being
     accessible in that package directly, rather than being inherited
     from another package.

pretty print  v.t. (an object)
     to invoke the pretty printer on the object.

pretty printer  n. 
     the procedure that prints the character representation of an
     object onto a stream when the value of ÿ*print-pretty*þ is true,
     and that uses layout techniques (e.g., indentation) that tend to
     highlight the structure of the object in a way that makes it
     easier for human readers to parse visually.  See the variable
     *Note *print-pprint-dispatch*:: and *Note Section 22.2 (The Lisp
     Pretty Printer): The Lisp Pretty Printer.

pretty printing stream  n. 
     a stream that does pretty printing.  Such streams are created by
     the function ÿpprint-logical-blockþ as a link between the output
     stream and the logical block.

primary method  n. 
     a member of one of two sets of methods (the set of auxiliary
     methods is the other) that form an exhaustive partition of the set
     of methods on the method's generic function.  How these sets are
     determined is dependent on the method combination type; see *Note
     Section 7.6.2 (Introduction to Methods): Introduction to Methods.

primary value  n. (of values resulting from the
     evaluation of a form) the first value, if any, or else ÿnilþ if
     there are no values.  "The primary value returned by ÿtruncateþ is
     an integer quotient, truncated toward zero."

principal  adj. (of a value returned by a Common Lisp function that
     implements a mathematically irrational or transcendental function
     defined in the complex domain) of possibly many (sometimes an
     infinite number of) correct values for the mathematical function,
     being the particular value which the corresponding Common
     Lisp function has been defined to return.

print name  n. Trad. (usually of a symbol)
     a nameß.

printer control variable  n. 
     a variable whose specific purpose is to control some action of the
     Lisp printer; that is, one of the variables in *Note Figure 22.1:
     StdPrinterControlVars, or else some implementation-defined
     variable which is defined by the implementation to be a printer
     control variable.

printer escaping  n.
     The combined state of the printer control variables
     ÿ*print-escape*þ and ÿ*print-readably*þ.  If the value of either
     ÿ*print-readably*þ or ÿ*print-escape*þ is true, then "printer
     escaping" is "enabled"; otherwise (if the values of both
     ÿ*print-readably*þ and ÿ*print-escape*þ are false), then printer
     escaping is "disabled".

printing  adj. (of a character)
     being a graphic character other than space.

process  v.t. (a form by the compiler)
     to perform minimal compilation, determining the time of evaluation
     for a form, and possibly evaluating that form (if required).

processor  n., ANSI
     an implementation.

proclaim  v.t. (a proclamation)
     to establish that proclamation.

proclamation  n. 
     a global declaration.

prog tag  n. Trad. 
     a go tag.

program  n. Trad. 
     Common Lisp code.

programmer  n.
     an active entity, typically a human, that writes a program, and
     that might or might not also be a user of the program.

programmer code  n. 
     code that is supplied by the programmer; that is, code that is not
     system code.

proper list
     n.  A list terminated by the empty list.  (The empty list is a
     proper list.)  See *Note improper list: glos-improper list.

proper name  n. (of a class)
     a symbol that names the class whose name is that symbol.  See the
     functions *Note class-name:: and ÿfind-classþ.

proper sequence  n. 
     a sequence which is not an improper list; that is, a vector or a
     proper list.

proper subtype  n. (of a type)
     a subtype of the type which is not the same type as the type
     (i.e., its elements are a "proper subset" of the type).

property  n. (of a property list)
     1. a conceptual pairing of a property indicator and its associated
     property value on a property list.  2. a property value.

property indicator  n. (of a property list)
     the name part of a property, used as a key when looking up a
     property value on a property list.

property list  n. 
     1.  a list containing an even number of elements that are
     alternating names  (sometimes called indicators or keys) and
     values (sometimes called properties).  When there is more than one
     name and value pair with the identical name in a property list,
     the first such pair determines the property.  2. (of a symbol) the
     component of the symbol containing a property list.

property value  n. (of a property indicator on
     a property list) the object associated with the property indicator
     on the property list.

purports to conform  v.
     makes a good-faith claim of conformance.  This term expresses
     intention to conform, regardless of whether the goal of that
     intention is realized in practice.  For example, language
     implementations have been known to have bugs, and while an
     implementation of this specification with bugs might not be a
     conforming implementation, it can still purport to conform.  This
     is an important distinction in certain specific cases; e.g., see
     the variable *Note *features*::.



File: chris-ansicl.info,  Node: Q,  Next: R,  Prev: P,  Up: Glossary

Q
=

qualified method  n. 
     a method that has one or more qualifiers.

qualifier  n. (of a method for a generic function)
     one of possibly several objects used to annotate the method in a
     way that identifies its role in the method combination.  The
     method combination type determines how many qualifiers are
     permitted for each method, which qualifiers are permitted, and the
     semantics of those qualifiers.

query I/O  n. 
     the bidirectional stream that is the value of the variable
     ÿ*query-io*þ.

quoted object  n. 
     an object which is the second element of a ÿquoteþ form.



File: chris-ansicl.info,  Node: R,  Next: S,  Prev: Q,  Up: Glossary

R
=

radix  n.
     an integer between 2 and 36, inclusive, which can be used to
     designate a base with respect to which certain kinds of numeric
     input or output are performed.  (There are n valid digit
     characters for any given radix n, and those digits are the first n
     digits in the sequence ÿ0þ, ÿ1þ, ..., ÿ9þ, ÿAþ, ÿBþ, ..., ÿZþ,
     which have the weights ÿ0þ, ÿ1þ, ..., ÿ9þ, ÿ10þ, ÿ11þ, ..., ÿ35þ,
     respectively.  Case is not significant in parsing numbers of radix
     greater than ÿ10þ, so "9b8a" and "9B8A" denote the same radix ÿ16þ
     number.)

random state  n. 
     an object of type ÿrandom-stateþ.

rank  n. 
     a non-negative integer indicating the number of dimensions of an
     array.

ratio  n. 
     an object of type ÿratioþ.

ratio marker  n. 
     a character which is used in the textual notation for a ratio to
     separate the numerator from the denominator, and which is slash in
     the standard readtable.  See *Note Section 2.1 (Character Syntax):
     Character Syntax.

rational  n. 
     an object of type ÿrationalþ.

read  v.t. 
     1. (a binding or slot or component) to obtain the value of the
     binding or slot.  2. (an object from a stream) to parse an object
     from its representation on the stream.

readably  adv. (of a manner of printing an object Oá)
     in such a way as to permit the Lisp Reader to later parse the
     printed output into an object Oà that is similar to Oá.

reader
     n.  1. a function that readsá a variable or slot.  2. the Lisp
     reader.

reader macro  n.
     1. a textual notation introduced by dispatch on one or two
     characters that defines special-purpose syntax for use by the Lisp
     reader, and that is implemented by a reader macro function.  See
     *Note Section 2.2 (Reader Algorithm): Reader Algorithm.  2. the
     character or characters that introduce a reader macroá; that is, a
     macro character or the conceptual pairing of a dispatching macro
     character and the character that follows it.  (A reader macro is
     not a kind of macro.)

reader macro function  n.
     a function designator that denotes a function that implements a
     reader macroà.  See the functions *Note set-macro-character:: and
     ÿset-dispatch-macro-characterþ.

readtable  n.
     an object of type ÿreadtableþ.

readtable case  n.
     an attribute of a readtable whose value is a case sensitivity mode,
     and that selects the manner in which characters in a symbol's name
     are to be treated by the Lisp reader and the Lisp printer.  See
     *Note Section 23.1.2 (Effect of Readtable Case on the Lisp
     Reader): Effect of Readtable Case on the Lisp Reader. and *Note
     Section 22.1.3.3.2 (Effect of Readtable Case on the Lisp Printer):
     ReadtableCasePrintEffect.

readtable designator  n.
     a designator for a readtable; that is, an object that denotes a
     readtable and that is one of: ÿnilþ (denoting the standard
     readtable), or a readtable (denoting itself).

recognizable subtype  n. (of a type)
     a subtype of the type which can be reliably detected to be such by
     the implementation.  See the function *Note subtypep::.

reference  n., v.t. 
     1. n. an act or occurrence of referring to an object, a binding,
     an exit point, a tag, or an environment.  2. v.t. to refer to an
     object, a binding, an exit point, a tag, or an environment,
     usually by name.

registered package  n.
     a package object that is installed in the package registry.
     (Every registered package has a name that is a string, as well as
     zero or more string nicknames.  All packages that are initially
     specified by Common Lisp  or created by ÿmake-packageþ or
     ÿdefpackageþ are registered packages.  Registered packages can be
     turned into unregistered packages by ÿdelete-packageþ.)

relative
     adj.  1. (of a time) representing an offset from an absolute time
     in the units appropriate to that time.  For example, a relative
     internal time is the difference between two absolute internal
     times, and is measured in internal time units.  2. (of a pathname)
     representing a position in a directory hierarchy by motion from a
     position other than the root, which might therefore vary.  "The
     notation ÿ#P"../foo.text"þ denotes a relative pathname if the host
     file system is Unix."  See *Note absolute: glos-absolute.

repertoire  n., ISO
     a subtype of ÿcharacterþ.  See *Note Section 13.1.2.2 (Character
     Repertoires): CharRepertoires.

report  n. (of a condition)
     to call the function ÿprint-objectþ on the condition in an
     environment where the value of ÿ*print-escape*þ is false.

report message  n.
     the text that is output by a condition reporter.

required parameter  n.
     A parameter for which a corresponding positional argument must be
     supplied when calling the function.

rest list  n. (of a function having a rest parameter)
     The list to which the rest parameter is bound on some particular
     call to the function.

rest parameter  n.
     A parameter which was introduced by ÿ&restþ.

restart  n. 
     an object of type ÿrestartþ.

restart designator  n.
     a designator for a restart; that is, an object that denotes a
     restart and that is one of: a non-nil symbol (denoting the most
     recently established active restart whose name is that symbol), or
     a restart (denoting itself).

restart function  n.
     a function that invokes a restart, as if by ÿinvoke-restartþ.  The
     primary purpose of a restart function is to provide an alternate
     interface. By convention, a restart function usually has the same
     name as the restart which it invokes. The next figure shows a list
     of the standardized restart functions.

     abort      muffle-warning   use-value
     continue   store-value      

     Figure 26.4: Standardized Restart Functions

return  v.t. (of values)
     1. (from a block) to transfer control and values from the block;
     that is, to cause the block to yield the values immediately
     without doing any further evaluation of the forms in its body.  2.
     (from a form) to yield the values.

return value  n. Trad. 
     a valueá

right-parenthesis  n.
     the standard character "ÿ)þ", that is variously called "right
     parenthesis" or "close parenthesis" See *Note Figure 2.5:
     StdCharsThree.

run time  n.
     1. load time 2. execution time

run-time compiler  n.
     refers to the ÿcompileþ function or to implicit compilation, for
     which the compilation and run-time environments are maintained in
     the same Lisp image.

run-time definition  n.
     a definition in the run-time environment.

run-time environment  n.
     the environment in which a program is executed.



File: chris-ansicl.info,  Node: S,  Next: T,  Prev: R,  Up: Glossary

S
=

safe  adj. 
     1. (of code) processed in a lexical environment where the the
     highest ÿsafetyþ level (ÿ3þ) was in effect.  See *Note optimize::.
     2. (of a call) a safe call.

safe call  n.
     a call in which the call, the function being called, and the point
     of functional evaluation are all safeá code.  For more detailed
     information, see *Note Section 3.5.1.1 (Safe and Unsafe Calls):
     SafeAndUnsafeCalls.

same  adj. 
     1. (of objects under a specified predicate) indistinguishable by
     that predicate.  "The symbol ÿcarþ, the string ÿ"car"þ, and the
     string ÿ"CAR"þ are the ÿsameþ under ÿstring-equalþ".  2. (of
     objects if no predicate is implied by context) indistinguishable
     by ÿeqlþ.  Note that ÿeqþ might be capable of distinguishing some
     numbers and characters which ÿeqlþ cannot distinguish, but the
     nature of such, if any, is implementation-dependent.  Since ÿeqþ
     is used only rarely in this specification, ÿeqlþ is the default
     predicate when none is mentioned explicitly.  "The conses returned
     by two successive calls to ÿconsþ are never the same."  3. (of
     types) having the same set of elements; that is, each type is a
     subtype of the others.  "The types specified by ÿ(integer 0 1)þ,
     ÿ(unsigned-byte 1)þ, and ÿbitþ are the same."

satisfy the test  v. 
     (of an object being considered by a sequence function) 1. (for a
     one argument test) to be in a state such that the function which
     is the PREDICATE argument to the sequence function returns true
     when given a single argument that is the result of calling the
     sequence function's KEY argument on the object being considered.
     See *Note Section 17.2.2 (Satisfying a One-Argument Test):
     Satisfying a One-Argument Test.  2. (for a two argument test) to
     be in a state such that the two-place predicate which is the
     sequence function's TEST argument returns true when given a first
     argument that is the object being considered, and when given a
     second argument that is the result of calling the sequence
     function's KEY argument on an element of the sequence function's
     SEQUENCE argument which is being tested for equality; or to be in
     a state such that the TEST-NOT function returns false given the
     same arguments.  See *Note Section 17.2.1 (Satisfying a
     Two-Argument Test): Satisfying a Two-Argument Test.

scope  n. 
     the structural or textual region of code in which references to an
     object, a binding, an exit point, a tag, or an environment
     (usually by name) can occur.

script  n. ISO
     one of possibly several sets that form an exhaustive partition of
     the type ÿcharacterþ.  See *Note Section 13.1.2.1 (Character
     Scripts): CharScripts.

secondary value  n. (of values resulting from the
     evaluation of a form) the second value, if any, or else ÿnilþ if
     there are fewer than two values.  "The secondary value returned by
     ÿtruncateþ is a remainder."

section  n.
     a partitioning of output by a conditional newline on a pretty
     printing stream.  See *Note Section 22.2.1.1 (Dynamic Control of
     the Arrangement of Output): DynamicControlofOutput.

self-evaluating object  n.
     an object that is neither a symbol nor a cons.  If a
     self-evaluating object is evaluated, it yields itself as its only
     value.  "Strings are self-evaluating objects."

semi-standard  adj. (of a language feature)
     not required to be implemented by any conforming implementation,
     but nevertheless recommended as the canonical approach in
     situations where an implementation does plan to support such a
     feature.  The presence of semi-standard aspects in the language is
     intended to lessen portability problems and reduce the risk of
     gratuitous divergence among implementations that might stand in
     the way of future standardization.

semicolon  n.
     the standard character that is called "semicolon" (ÿ;þ).  See
     *Note Figure 2.5: StdCharsThree.

sequence  n. 
     1. an ordered collection of elements 2. a vector or a list.

sequence function  n.
     one of the functions in *Note Figure 17.1: SequenceFunctions, or
     an implementation-defined function that operates on one or more
     sequences.  and that is defined by the implementation to be a
     sequence function.

sequential
     adj. Trad. (of binding or assignment) done in the style of ÿsetqþ,
     ÿlet*þ, or ÿdo*þ; that is, interleaving the evaluation of the
     forms that produce values with the assignments or bindings of the
     variables (or places).  See *Note parallel: glos-parallel.

sequentially  adv.
     in a sequential way.

serious condition  n. 
     a condition of type ÿserious-conditionþ, which represents a
     situation that is generally sufficiently severe that entry into
     the debugger should be expected if the condition is signaled but
     not handled.

session  n.
     the conceptual aggregation of events in a Lisp image from the time
     it is started to the time it is terminated.

set  v.t. Trad. (any variable
     or a symbol that is the name of a dynamic variable) to assign the
     variable.

setf expander  n. 
     a function used by ÿsetfþ to compute the setf expansion of a place.

setf expansion  n. 
     a set of five expressionsá that, taken together, describe how to
     store into a place and which subforms of the macro call associated
     with the place are evaluated.  See *Note Section 5.1.1.2 (Setf
     Expansions): SetfExpansions.

setf function  n.
     a function whose name is ÿ(setf symbol)þ.

setf function name  n. (of a symbol S)
     the list ÿ(setf S)þ.

shadow  v.t. 
     1. to override the meaning of.  "That binding of ÿXþ shadows an
     outer one."  2. to hide the presence of.  "That ÿmacroletþ of ÿFþ
     shadows the outer ÿfletþ of ÿFþ."  3. to replace.  "That package
     shadows the symbol ÿcl:carþ with its own symbol ÿcarþ."

shadowing symbol  n. (in a package)
     an element of the package's shadowing symbols list.

shadowing symbols list  n. (of a package)
     a list, associated with the package, of symbols that are to be
     exempted from `symbol conflict errors' detected when packages are
     used.  See the function *Note package-shadowing-symbols::.

shared slot  n. (of a class)
     a slot accessible in more than one instance of a class;
     specifically, such a slot is accessible in all direct instances of
     the class and in those indirect instances whose class does not
     shadowá the slot.

sharpsign  n.
     the standard character that is variously called "number sign,"
     "sharp," or "sharp sign" (ÿ#þ).  See *Note Figure 2.5:
     StdCharsThree.

short float  n. 
     an object of type ÿshort-floatþ.

sign  n. 
     one of the standard characters "ÿ+þ" or "ÿ-þ".

signal  v. 
     to announce, using a standard protocol, that a particular
     situation, represented by a condition, has been detected.  See
     *Note Section 9.1 (Condition System Concepts): Condition System
     Concepts.

signature  n. (of a method)
     a description of the parameters and parameter specializers for the
     method which determines the method's applicability for a given set
     of required arguments, and which also describes the argument
     conventions for its other, non-required arguments.

similar  adj. (of two objects)
     defined to be equivalent under the similarity relationship.

similarity  n.
     a two-place conceptual equivalence predicate, which is independent
     of the Lisp image so that two objects in different Lisp images can
     be understood to be equivalent under this predicate.  See *Note
     Section 3.2.4 (Literal Objects in Compiled Files): Literal Objects
     in Compiled Files.

simple  adj.
     1. (of an array) being of type ÿsimple-arrayþ.  2. (of a character)
     having no implementation-defined attributes, or else having
     implementation-defined attributes each of which has the null value
     for that attribute.

simple array  n. 
     an array of type ÿsimple-arrayþ.

simple bit array  n.
     a bit array that is a simple array; that is, an object of type
     ÿ(simple-array bit)þ.

simple bit vector  n. 
     a bit vector of type ÿsimple-bit-vectorþ.

simple condition  n. 
     a condition of type ÿsimple-conditionþ.

simple general vector  n. 
     a simple vector.

simple string  n. 
     a string of type ÿsimple-stringþ.

simple vector  n.
     a vector of type ÿsimple-vectorþ, sometimes called a "simple
     general vector."  Not all vectors that are simple are simple
     vectors--only those that have element type ÿtþ.

single escape  n., adj.
     1. n. the syntax type of a character that indicates that the next
     character is to be treated as an alphabeticà character with its
     case preserved.  For details, see *Note Section 2.1.4.6 (Single
     Escape Character): SingleEscapeChar.  2. adj. (of a character)
     having the single escape syntax type.  3. n. a single escapeà
     character.  (In the standard readtable, slash is the only single
     escape.)

single float  n. 
     an object of type ÿsingle-floatþ.

single-quote  n.
     the standard character that is variously called "apostrophe,"
     "acute accent," "quote," or "single quote" (ÿ'þ).  See *Note
     Figure 2.5: StdCharsThree.

singleton  adj. (of a sequence)
     having only one element.  "ÿ(list 'hello)þ returns a singleton
     list."

situation  n. 
     the evaluation of a form in a specific environment.

slash  n.
     the standard character that is variously called "solidus" or
     "slash" (ÿ/þ).  See *Note Figure 2.5: StdCharsThree.

slot  n. 
     a component of an object that can store a value.

slot specifier  n.
     a representation of a slot that includes the name of the slot and
     zero or more slot options.  A slot option pertains only to a
     single slot.

source code  n. 
     code representing objects suitable for evaluation (e.g., objects
     created by ÿreadþ, by macro expansion, or by compiler macro
     expansion).

source file  n. 
     a file which contains a textual representation of source code,
     that can be edited, loaded, or compiled.

space  n.
     the standard character <Space>, notated for the Lisp reader as
     ÿ#\Spaceþ.

special form  n. 
     a list, other than a macro form, which is a form with special
     syntax or special evaluation rules or both, possibly manipulating
     the evaluation environment or control flow or both.  The first
     element of a special form is a special operator.

special operator  n. 
     one of a fixed set of symbols, enumerated in *Note Figure 3.2:
     CLSpecialOps, that may appear in the car of a form in order to
     identify the form as a special form.

special variable  n. Trad.
     a dynamic variable.

specialize  v.t. (a generic function)
     to define a method for the generic function, or in other words, to
     refine the behavior of the generic function by giving it a specific
     meaning for a particular set of classes or arguments.

specialized  adj. 
     1. (of a generic function) having methods which specialize the
     generic function.  2. (of an array) having an actual array element
     type that is a proper subtype of the type ÿtþ; see *Note Section
     15.1.1 (Array Elements): Array Elements.  "ÿ(make-array 5
     :element-type 'bit)þ makes an array of length five that is
     specialized for bits."

specialized lambda list  n.
     an extended lambda list used in forms that establish method
     definitions, such as ÿdefmethodþ.  See *Note Section 3.4.3
     (Specialized Lambda Lists): Specialized Lambda Lists.

spreadable argument list designator  n.
     a designator for a list of objects; that is, an object that
     denotes a list and that is a non-null list L1 of length n, whose
     last element is a list L2 of length m (denoting a list L3 of
     length m+n-1 whose elements are L1_i for i < n-1 followed by L2_j
     for j < m).  "The list (1 2 (3 4 5)) is a spreadable argument list
     designator for the list (1 2 3 4 5)."

stack allocate  v.t. Trad. 
     to allocate in a non-permanent way, such as on a stack.
     Stack-allocation is an optimization technique used in some
     implementations for allocating certain kinds of objects that have
     dynamic extent.  Such objects are allocated on the stack rather
     than in the heap so that their storage can be freed as part of
     unwinding the stack rather than taking up space in the heap until
     the next garbage collection.  What types (if any) can have dynamic
     extent can vary from implementation to implementation.  No
     implementation is ever required to perform stack-allocation.

stack-allocated  adj. Trad. 
     having been stack allocated.

standard character  n. 
     a character of type ÿstandard-charþ, which is one of a fixed set
     of 96 such characters required to be present in all conforming
     implementations.  See *Note Section 2.1.3 (Standard Characters):
     Standard Characters.

standard class  n. 
     a class that is a generalized instance of class ÿstandard-classþ.

standard generic function
     a function of type ÿstandard-generic-functionþ.

standard input  n. 
     the input stream which is the value of the dynamic variable
     ÿ*standard-input*þ.

standard method combination  n. 
     the method combination named ÿstandardþ.

standard object  n. 
     an object that is a generalized instance of class
     ÿstandard-objectþ.

standard output  n. 
     the output stream which is the value of the dynamic variable
     ÿ*standard-output*þ.

standard pprint dispatch table  n.
     A pprint dispatch table that is different from the initial pprint
     dispatch table, that implements pretty printing as described in
     this specification, and that, unlike other pprint dispatch tables,
     must never be modified by any program.  (Although the definite
     reference "the standard pprint dispatch table" is generally used
     within this document, it is actually implementation-dependent
     whether a single object fills the role of the standard pprint
     dispatch table, or whether there might be multiple such objects,
     any one of which could be used on any given occasion where "the
     standard pprint dispatch table" is called for.  As such, this
     phrase should be seen as an indefinite reference in all cases
     except for anaphoric references.)

standard readtable  n.
     A readtable that is different from the initial readtable, that
     implements the expression syntax defined in this specification,
     and that, unlike other readtables, must never be modified by any
     program.  (Although the definite reference "the standard
     readtable" is generally used within this document, it is actually
     implementation-dependent whether a single object fills the role of
     the standard readtable, or whether there might be multiple such
     objects, any one of which could be used on any given occasion
     where "the standard readtable" is called for.  As such, this
     phrase should be seen as an indefinite reference in all cases
     except for anaphoric references.)

standard syntax  n.
     the syntax represented by the standard readtable and used as a
     reference syntax throughout this document.  See *Note Section 2.1
     (Character Syntax): Character Syntax.

standardized  adj. (of a name, object, or definition)
     having been defined by Common Lisp.  "All standardized variables
     that are required to hold bidirectional streams have "ÿ-io*þ" in
     their name."

startup environment  n.
     the global environment of the running Lisp image from which the
     compiler was invoked.

step  v.t., n. 
     1. v.t. (an iteration variable) to assign the variable a new value
     at the end of an iteration, in preparation for a new iteration.
     2. n. the code that identifies how the next value in an iteration
     is to be computed.  3. v.t. (code) to specially execute the code,
     pausing at intervals to allow user confirmation or intervention,
     usually for debugging.

stream  n. 
     an object that can be used with an input or output function to
     identify an appropriate source or sink of characters or bytes for
     that operation.

stream associated with a file  n. 
     a file stream, or a synonym stream the target of which is a stream
     associated with a file.  Such a stream cannot be created with
     ÿmake-two-way-streamþ, ÿmake-echo-streamþ, ÿmake-broadcast-streamþ,
     ÿmake-concatenated-streamþ, ÿmake-string-input-streamþ, or
     ÿmake-string-output-streamþ.

stream designator  n.
     a designator for a stream; that is, an object that denotes a stream
     and that is one of: ÿtþ (denoting the value of ÿ*terminal-io*þ),
     ÿnilþ (denoting the value of ÿ*standard-input*þ for input stream
     designators or denoting the value of ÿ*standard-output*þ for
     output stream designators), or a stream (denoting itself).

stream element type  n. (of a stream)
     the type of data for which the stream is specialized.

stream variable  n.
     a variable whose value must be a stream.

stream variable designator  n.
     a designator for a stream variable; that is, a symbol that denotes
     a stream variable and that is one of: ÿtþ (denoting
     ÿ*terminal-io*þ), ÿnilþ (denoting ÿ*standard-input*þ for input
     stream variable designators or denoting ÿ*standard-output*þ for
     output stream variable designators), or some other symbol
     (denoting itself).

string  n. 
     a specialized vector that is of type ÿstringþ, and whose elements
     are of type ÿcharacterþ or a suptype of type ÿcharacterþ.

string designator  n.
     a designator for a string; that is, an object that denotes a string
     and that is one of: a character (denoting a singleton string that
     has the character as its only element), a symbol (denoting the
     string that is its name), or a string (denoting itself).  The
     intent is that this term be consistent with the behavior of
     ÿstringþ; implementations that extend ÿstringþ must extend the
     meaning of this term in a compatible way.

string equal  adj. 
     the same under ÿstring-equalþ.

string stream  n. 
     a stream of type ÿstring-streamþ.

structure  n. 
     an object of type ÿstructure-objectþ.

structure class  n. 
     a class that is a generalized instance of class ÿstructure-classþ.

structure name  n.
     a name defined with ÿdefstructþ.  Usually, such a type is also a
     structure class, but there may be implementation-dependent
     situations in which this is not so, if the :type option to
     ÿdefstructþ is used.

style warning  n.
     a condition of type ÿstyle-warningþ.

subclass
     n.  a class that inherits from another class, called a superclass.
     (No class is a subclass of itself.)

subexpression  n. (of an expression)
     an expression that is contained within the expression.  (In fact,
     the state of being a subexpression is not an attribute of the
     subexpression, but really an attribute of the containing
     expression since the same object can at once be a subexpression in
     one context, and not in another.)

subform  n. (of a form)
     an expression that is a subexpression of the form, and which by
     virtue of its position in that form is also a form.  "ÿ(f x)þ and
     ÿxþ, but not ÿexitþ, are subforms of ÿ(return-from exit (f x))þ."

subrepertoire  n. 
     a subset of a repertoire.

subtype
     n.  a type whose membership is the same as or a proper subset of
     the membership of another type, called a supertype.  (Every type
     is a subtype of itself.)

superclass  n. 
     a class from which another class (called a subclass) inherits.
     (No class is a superclass of itself.)  See *Note subclass:
     glos-subclass.

supertype  n. 
     a type whose membership is the same as or a proper superset of the
     membership of another type, called a subtype.  (Every type is a
     supertype of itself.)  See *Note subtype: glos-subtype.

supplied-p parameter
     n.  a parameter which recieves its generalized boolean value
     implicitly due to the presence or absence of an argument
     corresponding to another parameter (such as an optional parameter
     or a rest parameter).  See *Note Section 3.4.1 (Ordinary Lambda
     Lists): Ordinary Lambda Lists.

symbol  n. 
     an object of type ÿsymbolþ.

symbol macro  n. 
     a symbol that stands for another form.  See the macro *Note
     symbol-macrolet::.

synonym stream  n. 
     1. a stream of type ÿsynonym-streamþ, which is consequently a
     stream that is an alias for another stream, which is the value of
     a dynamic variable whose name is the synonym stream symbol of the
     synonym stream.  See the function *Note make-synonym-stream::.  2.
     (to a stream) a synonym stream which has the stream as the value
     of its synonym stream symbol.  3. (to a symbol) a synonym stream
     which has the symbol as its synonym stream symbol.

synonym stream symbol  n. (of a synonym stream)
     the symbol which names the dynamic variable which has as its value
     another stream for which the synonym stream is an alias.

syntax type  n. (of a character)
     one of several classifications, enumerated in *Note Figure 2.6:
     PossibleSyntaxTypes, that are used for dispatch during parsing by
     the Lisp reader.  See *Note Section 2.1.4 (Character Syntax
     Types): Character Syntax Types.

system class  n. 
     a class that may be of type ÿbuilt-in-classþ in a conforming
     implementation and hence cannot be inherited by classes defined by
     conforming programs.

system code  n. 
     code supplied by the implementation to implement this specification
     (e.g., the definition of ÿmapcarþ) or generated automatically in
     support of this specification (e.g., during method combination);
     that is, code that is not programmer code.



File: chris-ansicl.info,  Node: T,  Next: U,  Prev: S,  Up: Glossary

T
=

t
     n.  1. a. the boolean representing true.  b. the canonical
     generalized boolean representing true.  (Although any object other
     than ÿnilþ is considered true as a generalized boolean, ÿtþ is
     generally used when there is no special reason to prefer one such
     object over another.)  2. the name of the type to which all
     objects belong--the supertype of all types (including itself).  3.
     the name of the superclass of all classes except itself.

tag  n. 
     1. a catch tag.  2. a go tag.

tail  n. (of a list)
     an object that is the same as either some cons which makes up that
     list or the atom (if any) which terminates the list.  "The empty
     list is a tail of every proper list."

target  n. 
     1. (of a constructed stream) a constituent of the constructed
     stream.  "The target of a synonym stream is the value of its
     synonym stream symbol."  2. (of a displaced array) the array to
     which the displaced array is displaced.  (In the case of a chain
     of constructed streams or displaced arrays, the unqualified term
     "target" always refers to the immediate target of the first item
     in the chain, not the immediate target of the last item.)

terminal I/O  n. 
     the bidirectional stream that is the value of the variable
     ÿ*terminal-io*þ.

terminating  n. (of a macro character)
     being such that, if it appears while parsing a token, it
     terminates that token.  See *Note Section 2.2 (Reader Algorithm):
     Reader Algorithm.

tertiary value  n. (of values resulting from the
     evaluation of a form) the third value, if any, or else ÿnilþ if
     there are fewer than three values.

throw  v. 
     to transfer control and values to a catch.  See the special
     operator *Note throw::.

tilde  n.
     the standard character that is called "tilde" (ÿ~þ).  See *Note
     Figure 2.5: StdCharsThree.

time
     a representation of a point (absolute time) or an interval
     (relative time) on a time line.  See *Note decoded time:
     glos-decoded time, internal time, and universal time.

time zone  n.
     a rational multiple of ÿ1/3600þ between ÿ-24þ (inclusive) and ÿ24þ
     (inclusive) that represents a time zone as a number of hours
     offset from Greenwich Mean Time.  Time zone values increase with
     motion to the west, so   Massachusetts, U.S.A. is in time zone ÿ5þ,
     California, U.S.A. is time zone ÿ8þ, and Moscow, Russia is time
     zone -3.  (When "daylight savings time" is separately represented
     as an argument or return value, the time zone that accompanies it
     does not depend on whether daylight savings time is in effect.)

token  n.
     a textual representation for a number or a symbol.  See *Note
     Section 2.3 (Interpretation of Tokens): Interpretation of Tokens.

top level form  n. 
     a form which is processed specially by ÿcompile-fileþ for the
     purposes of enabling compile time evaluation of that form.  Top
     level forms include those forms which are not subforms of any
     other form, and certain other cases.  See *Note Section 3.2.3.1
     (Processing of Top Level Forms): TopLevelForms.

trace output  n. 
     the output stream which is the value of the dynamic variable
     ÿ*trace-output*þ.

tree  n. 
     1. a binary recursive data structure made up of conses and atoms:
     the conses are themselves also trees (sometimes called "subtrees"
     or "branches"), and the atoms are terminal nodes (sometimes called
     leaves). Typically, the leaves represent data while the branches
     establish some relationship among that data.  2. in general, any
     recursive data structure that has some notion of "branches" and
     leaves.

tree structure  n. (of a treeá)
     the set of conses that make up the tree.  Note that while the
     car[1b] component of each such cons is part of the tree structure,
     the objects that are the carsà of each cons in the tree are not
     themselves part of its tree structure unless they are also conses.

true  n. 
     any object that is not false and that is used to represent the
     success of a predicate test.  See *Note t: glos-t.á.

truename  n. 
     1. the canonical filename of a file in the file system.  See *Note
     Section 20.1.3 (Truenames): Truenames.  2. a pathname representing
     a truenameá.

two-way stream  n. 
     a stream of type ÿtwo-way-streamþ, which is a bidirectional
     composite stream that receives its input  from an associated input
     stream and sends    its output to   an associated output stream.

type  n. 
     1. a set of objects, usually with common structure, behavior, or
     purpose.  (Note that the expression "X is of type S_A" naturally
     implies that "X is of type S_B" if S_A is a subtype of S_B.)  2.
     (immediately following the name of a type) a subtype of that type.
     "The type ÿvectorþ is an array type."

type declaration  n. 
     a declaration that asserts that every reference to a specified
     binding within the scope of the declaration results in some object
     of the specified type.

type equivalent  adj. (of two types X and Y)
     having the same elements; that is, X is a subtype of Y and Y is a
     subtype of X.

type expand  n.
     to fully expand a type specifier, removing any references to
     derived types.  (Common Lisp provides no program interface to cause
     this to occur, but the semantics of Common Lisp are such that every
     implementation must be able to do this internally, and some
     situations involving type specifiers are most easily described in
     terms of a fully expanded type specifier.)

type specifier  n. 
     an expression that denotes a type.  "The symbol ÿrandom-stateþ,
     the list ÿ(integer 3 5)þ, the list ÿ(and list (not null))þ, and
     the class named ÿstandard-classþ are type specifiers."



File: chris-ansicl.info,  Node: U,  Next: V,  Prev: T,  Up: Glossary

U
=

unbound
     adj.  not having an associated denotation in a binding.  See *Note
     bound: glos-bound.

unbound variable  n.
     a name that is syntactically plausible as the name of a variable
     but which is not bound in the variable namespace.

undefined function  n.
     a name that is syntactically plausible as the name of a function
     but which is not bound in the function namespace.

unintern  v.t. (a symbol in a package)
     to make the symbol not be present in that package.  (The symbol
     might continue to be accessible by inheritance.)

uninterned  adj. (of a symbol)
     not accessible in any package; i.e., not internedá.

universal time  n.
     time, represented as a non-negative integer number of seconds.
     Absolute universal time is measured as an offset from the
     beginning of the year 1900 (ignoring leap seconds).  See *Note
     Section 25.1.4.2 (Universal Time): UniversalTime.

unqualified method  n. 
     a method with no qualifiers.

unregistered package  n.
     a package object that is not present in the package registry.  An
     unregistered package has no name; i.e., its name is ÿnilþ.  See
     the function *Note delete-package::.

unsafe  adj. (of code)
     not safe.  (Note that, unless explicitly specified otherwise, if a
     particular kind of error checking is guaranteed only in a safe
     context, the same checking might or might not occur in that
     context if it were unsafe; describing a context as unsafe means
     that certain kinds of error checking are not reliably enabled but
     does not guarantee that error checking is definitely disabled.)

unsafe call  n.
     a call that is not a safe call.  For more detailed information,
     see *Note Section 3.5.1.1 (Safe and Unsafe Calls):
     SafeAndUnsafeCalls.

upgrade  v.t. (a declared type to an actual type)
     1. (when creating an array) to substitute an actual array element
     type for an expressed array element type when choosing an
     appropriately specialized array representation.  See the function
     *Note upgraded-array-element-type::.  2. (when creating a complex)
     to substitute an actual complex part type for an expressed complex
     part type when choosing an appropriately specialized complex
     representation.  See the function *Note
     upgraded-complex-part-type::.

upgraded array element type  n. (of a type)
     a type that is a supertype of the type and that is used instead of
     the type whenever the type is used as an array element type for
     object creation or type discrimination.  See *Note Section
     15.1.2.1 (Array Upgrading): ArrayUpgrading.

upgraded complex part type  n. (of a type)
     a type that is a supertype of the type and that is used instead of
     the type whenever the type is used as a complex part type for
     object creation or type discrimination.  See the function *Note
     upgraded-complex-part-type::.

uppercase  adj. (of a character)
     being among standard characters corresponding to the capital
     letters ÿAþ through ÿZþ, or being some other
     implementation-defined character that is defined by the
     implementation to be uppercase.  See *Note Section 13.1.4.3
     (Characters With Case): CharactersWithCase.

use  v.t. (a package Pá)
     to inherit the external symbols of Pá.  (If a package Pà uses Pá,
     the external symbols of Pá become internal symbols of Pà unless
     they are explicitly exported.)  "The package ÿCL-USERþ uses the
     package ÿCLþ."

use list  n. (of a package)
     a (possibly empty) list associated with each package which
     determines what other packages are currently being used by that
     package.

user  n. 
     an active entity, typically a human, that invokes or interacts
     with a program at run time, but that is not necessarily a
     programmer.



File: chris-ansicl.info,  Node: V,  Next: W,  Prev: U,  Up: Glossary

V
=

valid array dimension  n. 
     a fixnum suitable for use as an array dimension.  Such a fixnum
     must be greater than or equal to zero, and less than the value of
     ÿarray-dimension-limitþ.  When multiple array dimensions are to be
     used together to specify a multi-dimensional array, there is also
     an implied constraint that the product of all of the dimensions be
     less than the value of ÿarray-total-size-limitþ.

valid array index  n. (of an array)
     a fixnum suitable for use as one of possibly several indices needed
     to name an element of the array according to a multi-dimensional
     Cartesian coordinate system. Such a fixnum must be greater than or
     equal to zero, and must be less than the corresponding dimensioná
     of the array.  (Unless otherwise explicitly specified, the phrase
     "a list of valid array indices" further implies that the length of
     the list must be the same as the rank of the array.)  "For a ÿ2þ
     by ÿ3þ array, valid array indices for the first  dimension are ÿ0þ
     and ÿ1þ, and valid array indices for the second dimension are ÿ0þ,
     ÿ1þ and ÿ2þ."

valid array row-major index  n. (of an array,
     which might have any number of dimensionsà) a single fixnum
     suitable for use in naming any element of the array, by viewing
     the array's storage as a linear series of elements in row-major
     order.  Such a fixnum must be greater than or equal to zero, and
     less than the array total size of the array.

valid fill pointer  n. (of an array)
     a fixnum suitable for use as a fill pointer for the array.  Such a
     fixnum must be greater than or equal to zero, and less than or
     equal to the array total size of the array.

valid logical pathname host  n.
     a string that has been defined as the name of a logical host.  See
     the function *Note load-logical-pathname-translations::.

valid pathname device  n.
     a string, ÿnilþ, :unspecific, or some other object defined by the
     implementation to be a valid pathname device.

valid pathname directory  n.
     a string, a list of strings, ÿnilþ, :wild, :unspecific, or some
     other object defined by the implementation to be a valid directory
     component.

valid pathname host  n.
     a valid physical pathname host or a valid logical pathname host.

valid pathname name  n.
     a string, ÿnilþ, :wild, :unspecific, or some other object defined
     by the implementation to be a valid pathname name.

valid pathname type  n.
     a string, ÿnilþ, :wild, :unspecific.

valid pathname version  n.
     a non-negative integer, or one of :wild, :newest, :unspecific, or
     ÿnilþ.  The symbols :oldest, :previous, and :installed are
     semi-standard special version symbols.

valid physical pathname host  n.
     any of a string, a list of strings, or the symbol :unspecific,
     that is recognized by the implementation as the name of a host.

valid sequence index  n. (of a sequence)
     an integer suitable for use to name an element of the sequence.
     Such an integer must be greater than or equal to zero, and must be
     less than the length of the sequence.  (If the sequence is an
     array, the valid sequence index is further constrained to be a
     fixnum.)

value  n. 
     1. a. one of possibly several objects that are the result of an
     evaluation.  b. (in a situation where exactly one value is
     expected from the evaluation of a form) the primary value returned
     by the form.  c. (of forms in an implicit progn) one of possibly
     several objects that result from the evaluation of the last form,
     or ÿnilþ if there are no forms.  2. an object associated with a
     name in a binding.  3. (of a symbol) the value of the dynamic
     variable named by that symbol.  4. an object associated with a key
     in an association list, a  property list, or a  hash table.

value cell  n. Trad. (of a symbol)
     The place which holds the value, if any, of the dynamic variable
     named by that symbol, and which is accessed by ÿsymbol-valueþ.
     See *Note cell: glos-cell.

variable  n. 
     a binding in the "variable" namespace.  See *Note Section
     3.1.2.1.1 (Symbols as Forms): SymbolsAsForms.

vector  n. 
     a one-dimensional array.

vertical-bar  n.
     the standard character that is called "vertical bar" (ÿ|þ).  See
     *Note Figure 2.5: StdCharsThree.



File: chris-ansicl.info,  Node: W,  Next: Y,  Prev: V,  Up: Glossary

W
=

whitespace  n. 
     1. one or more characters that are either the graphic character
     ÿ#\Spaceþ or else non-graphic characters such as ÿ#\Newlineþ that
     only move the print position.  2. a. n. the syntax type of a
     character that is a token separator.  For details, see *Note
     Section 2.1.4.7 (Whitespace Characters): WhitespaceChars.  b.
     adj. (of a character) having the whitespace[2a] syntax typeà.  c.
     n. a whitespace[2b] character.

wild  adj.
     1. (of a namestring) using an implementation-defined syntax for
     naming files, which might "match" any of possibly several possible
     filenames, and which can therefore be used to refer to the
     aggregate of the files named by those filenames.  2. (of a
     pathname) a structured representation of a name which might
     "match" any of possibly several pathnames, and which can therefore
     be used to refer to the aggregate of the files named by those
     pathnames.  The set of wild pathnames includes, but is not
     restricted to, pathnames which have a component which is :wild, or
     which have a directory component which contains :wild or
     :wild-inferors.  See the function *Note wild-pathname-p::.

write  v.t. 
     1. (a binding or slot or component) to change the value of the
     binding or slot.  2. (an object to a stream) to output a
     representation of the object to the stream.

writer  n.
     a function that writesá a variable or slot.



File: chris-ansicl.info,  Node: Y,  Prev: W,  Up: Glossary

Y
=

yield  v.t. (values)
     to produce the values as the result of evaluation.  "The form ÿ(+
     2 3)þ yields ÿ5þ."



File: chris-ansicl.info,  Node: Appendix,  Next: Index,  Prev: Glossary,  Up: Top

Appendix A Appendix
*******************

* Menu:

* Removed Language Features::


File: chris-ansicl.info,  Node: Removed Language Features,  Up: Appendix

A.1 Removed Language Features
=============================

* Menu:

* Requirements for removed and deprecated features::
* Removed Types::
* Removed Operators::
* Removed Argument Conventions::
* Removed Variables::
* Removed Reader Syntax::
* Packages No Longer Required::


File: chris-ansicl.info,  Node: Requirements for removed and deprecated features,  Next: Removed Types,  Up: Removed Language Features

A.1.1 Requirements for removed and deprecated features
------------------------------------------------------

For this standard, some features from the language described in `Common
Lisp: The Language' have been removed, and others have been deprecated
(and will most likely not appear in future Common Lisp standards).
Which features were removed and which were deprecated was decided on a
case-by-case basis by the X3J13 committee.

Conforming implementations that wish to retain any removed features for
compatibility must assure that such compatibility does not interfere
with the correct function of conforming programs.  For example, symbols
corresponding to the names of removed functions may not appear in the
the ÿCOMMON-LISPþ package.  (Note, however, that this specification has
been devised in such a way that there can be a package named ÿLISPþ
which can contain such symbols.)

Conforming implementations must implement all deprecated features.  For
a list of deprecated features, see *Note Section 1.8 (Deprecated
Language Features): Deprecated Language Features.


File: chris-ansicl.info,  Node: Removed Types,  Next: Removed Operators,  Prev: Requirements for removed and deprecated features,  Up: Removed Language Features

A.1.2 Removed Types
-------------------

The type ÿstring-charþ was removed.


File: chris-ansicl.info,  Node: Removed Operators,  Next: Removed Argument Conventions,  Prev: Removed Types,  Up: Removed Language Features

A.1.3 Removed Operators
-----------------------

The functions ÿint-charþ , ÿchar-bitsþ , ÿchar-fontþ , ÿmake-charþ ,
ÿchar-bitþ , ÿset-char-bitþ , ÿstring-char-pþ , and ÿcommonpþ were
removed.

The special operator ÿcompiler-letþ was removed.


File: chris-ansicl.info,  Node: Removed Argument Conventions,  Next: Removed Variables,  Prev: Removed Operators,  Up: Removed Language Features

A.1.4 Removed Argument Conventions
----------------------------------

The FONT argument to ÿdigit-charþ was removed.  The BITS and FONT
arguments to ÿcode-charþ 

were removed.


File: chris-ansicl.info,  Node: Removed Variables,  Next: Removed Reader Syntax,  Prev: Removed Argument Conventions,  Up: Removed Language Features

A.1.5 Removed Variables
-----------------------

The variables ÿchar-font-limitþ , ÿchar-bits-limitþ , ÿchar-control-bitþ ,
ÿchar-meta-bitþ , ÿchar-super-bitþ , ÿchar-hyper-bitþ , and
ÿ*break-on-warnings*þ were removed.


File: chris-ansicl.info,  Node: Removed Reader Syntax,  Next: Packages No Longer Required,  Prev: Removed Variables,  Up: Removed Language Features

A.1.6 Removed Reader Syntax
---------------------------

The "ÿ#,þ" reader macro in standard syntax was removed.


File: chris-ansicl.info,  Node: Packages No Longer Required,  Prev: Removed Reader Syntax,  Up: Removed Language Features

A.1.7 Packages No Longer Required
---------------------------------

The packages ÿLISPþ , ÿUSERþ , and ÿSYSTEMþ are no longer required.  It
is valid for packages with one or more of these names to be provided by
a conforming implementation as extensions.


File: chris-ansicl.info,  Node: Index,  Next: Symbol Index,  Prev: Appendix,  Up: Top

Index
*****

 [index ]
* Menu:

* #:                                     Sharpsign.           (line   6)
* &allow-other-keys:                     Ordinary Lambda Lists.
                                                              (line 106)
* &aux:                                  Ordinary Lambda Lists.
                                                              (line 213)
* &body:                                 Macro Lambda Lists.  (line  64)
* &environment:                          Macro Lambda Lists.  (line  83)
* &key:                                  Ordinary Lambda Lists.
                                                              (line 106)
* &optional:                             Ordinary Lambda Lists.
                                                              (line  75)
* &rest:                                 Ordinary Lambda Lists.
                                                              (line  93)
* &whole:                                Macro Lambda Lists.  (line  73)
* ':                                     Single-Quote.        (line   6)
* (:                                     Left-Parenthesis.    (line   6)
* ():                                    Notational Conventions.
                                                              (line 382)
* (setf class-name):                     setf class-name.     (line   6)
* (setf documentation):                  documentation; setf documentation.
                                                              (line   6)
* ):                                     Right-Parenthesis.   (line   6)
* * <1>:                                 * (Function).        (line   6)
* *:                                     *; **; ***.          (line   6)
* **:                                    *; **; ***.          (line   6)
* ***:                                   *; **; ***.          (line   6)
* *break-on-signals*:                    *break-on-signals*.  (line   6)
* *break-on-warnings*:                   Removed Variables.   (line   8)
* *compile-file-pathname*:               *compile-file-pathname*; *compile-file-truename*.
                                                              (line   6)
* *compile-file-truename*:               *compile-file-pathname*; *compile-file-truename*.
                                                              (line   6)
* *compile-print*:                       *compile-print*; *compile-verbose*.
                                                              (line   6)
* *compile-verbose*:                     *compile-print*; *compile-verbose*.
                                                              (line   6)
* *debug-io*:                            *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                              (line   6)
* *debugger-hook*:                       *debugger-hook*.     (line   6)
* *default-pathname-defaults*:           *default-pathname-defaults*.
                                                              (line   6)
* *error-output*:                        *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                              (line   6)
* *features* <1>:                        Sharpsign.           (line 462)
* *features* <2>:                        *features*.          (line   6)
* *features*:                            Conforming Programs. (line  64)
* *gensym-counter*:                      *gensym-counter*.    (line   6)
* *load-pathname*:                       *load-pathname*; *load-truename*.
                                                              (line   6)
* *load-print*:                          *load-print*; *load-verbose*.
                                                              (line   6)
* *load-truename*:                       *load-pathname*; *load-truename*.
                                                              (line   6)
* *load-verbose*:                        *load-print*; *load-verbose*.
                                                              (line   6)
* *macroexpand-hook*:                    *macroexpand-hook*.  (line   6)
* *modules*:                             *modules*.           (line   6)
* *package*:                             *package*.           (line   6)
* *print-array*:                         *print-array*.       (line   6)
* *print-base*:                          *print-base*; *print-radix*.
                                                              (line   6)
* *print-case*:                          *print-case*.        (line   6)
* *print-circle* <1>:                    *print-circle*.      (line   6)
* *print-circle*:                        Sharpsign.           (line 399)
* *print-escape*:                        *print-escape*.      (line   6)
* *print-gensym*:                        *print-gensym*.      (line   6)
* *print-length*:                        *print-level*; *print-length*.
                                                              (line   6)
* *print-level*:                         *print-level*; *print-length*.
                                                              (line   6)
* *print-lines*:                         *print-lines*.       (line   6)
* *print-miser-width*:                   *print-miser-width*. (line   6)
* *print-pprint-dispatch*:               *print-pprint-dispatch*.
                                                              (line   6)
* *print-pretty*:                        *print-pretty*.      (line   6)
* *print-radix*:                         *print-base*; *print-radix*.
                                                              (line   6)
* *print-readably*:                      *print-readably*.    (line   6)
* *print-right-margin*:                  *print-right-margin*.
                                                              (line   6)
* *query-io*:                            *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                              (line   6)
* *random-state*:                        *random-state*.      (line   6)
* *read-base* <1>:                       Sharpsign.           (line 247)
* *read-base* <2>:                       *read-base*.         (line   6)
* *read-base*:                           Sharpsign.           (line 261)
* *read-default-float-format*:           *read-default-float-format*.
                                                              (line   6)
* *read-eval* <1>:                       Sharpsign.           (line 209)
* *read-eval*:                           *read-eval*.         (line   6)
* *read-suppress*:                       *read-suppress*.     (line   6)
* *readtable*:                           *readtable*.         (line   6)
* *standard-input*:                      *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                              (line   6)
* *standard-output*:                     *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                              (line   6)
* *terminal-io*:                         *terminal-io*.       (line   6)
* *trace-output*:                        *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                              (line   6)
* + <1>:                                 +; ++; +++.          (line   6)
* + <2>:                                 Method Selection and Combination.
                                                              (line 240)
* +:                                     + (Function).        (line   6)
* ++:                                    +; ++; +++.          (line   6)
* +++:                                   +; ++; +++.          (line   6)
* ,:                                     Comma.               (line   6)
* - <1>:                                 - (Variable).        (line   6)
* -:                                     - (Function).        (line   6)
* .:                                     Left-Parenthesis.    (line  21)
* .. <1>:                                Re-Reading Abbreviated Expressions.
                                                              (line   6)
* ..:                                    *print-lines*.       (line  21)
* ... <1>:                               Re-Reading Abbreviated Expressions.
                                                              (line   6)
* ...:                                   pprint-pop.          (line  34)
* / <1>:                                 / (Function).        (line   6)
* /:                                     /; //; ///.          (line   6)
* //:                                    /; //; ///.          (line   6)
* ///:                                   /; //; ///.          (line   6)
* /=:                                    =; /=; <; >; <=; >=. (line   6)
* 1+:                                    1+; 1-.              (line   6)
* 1-:                                    1+; 1-.              (line   6)
* :absolute:                             Interpreting Pathname Component Values.
                                                              (line 205)
* :back:                                 Interpreting Pathname Component Values.
                                                              (line 239)
* :common:                               Interpreting Pathname Component Values.
                                                              (line  58)
* :compile-toplevel:                     eval-when.           (line  14)
* :execute:                              eval-when.           (line  15)
* :load-toplevel:                        eval-when.           (line  14)
* :local:                                Interpreting Pathname Component Values.
                                                              (line  44)
* :relative:                             Interpreting Pathname Component Values.
                                                              (line 205)
* :unspecific:                           Interpreting Pathname Component Values.
                                                              (line 109)
* :up:                                   Interpreting Pathname Component Values.
                                                              (line 239)
* :wild:                                 Interpreting Pathname Component Values.
                                                              (line 239)
* :wild-inferiors:                       Interpreting Pathname Component Values.
                                                              (line 239)
* ;:                                     Semicolon.           (line   6)
* <:                                     =; /=; <; >; <=; >=. (line   6)
* <=:                                    =; /=; <; >; <=; >=. (line   6)
* =:                                     =; /=; <; >; <=; >=. (line   6)
* >:                                     =; /=; <; >; <=; >=. (line   6)
* >=:                                    =; /=; <; >; <=; >=. (line   6)
* `:                                     Backquote.           (line   6)
* A (format directive):                  FORMAT Printer Operations.
                                                              (line   9)
* A (sharpsign reader macro):            Sharpsign.           (line 323)
* abort <1>:                             abort; continue; muffle-warning; store-value; use-value.
                                                              (line   6)
* abort:                                 abort (Restart).     (line   6)
* abs:                                   abs.                 (line   6)
* accessible:                            Introduction to Packages.
                                                              (line  84)
* acons:                                 acons.               (line   6)
* acos:                                  asin; acos; atan.    (line   6)
* acosh:                                 sinh; cosh; tanh; asinh; acosh; atanh.
                                                              (line   6)
* active:                                Array Elements.      (line  57)
* actual array element type:             Specialized Arrays.  (line  38)
* add-method:                            add-method.          (line   6)
* adjoin:                                adjoin.              (line   6)
* adjust-array:                          adjust-array.        (line   6)
* adjustable-array-p:                    adjustable-array-p.  (line   6)
* allocate-instance:                     allocate-instance.   (line   6)
* alpha-char-p:                          alpha-char-p.        (line   6)
* alphanumericp:                         alphanumericp.       (line   6)
* Ampersand (format directive):          FORMAT Basic Output. (line  59)
* and <1>:                               and (Type Specifier).
                                                              (line   6)
* and <2>:                               and (Macro).         (line   6)
* and:                                   Method Selection and Combination.
                                                              (line 240)
* append <1>:                            append.              (line   6)
* append:                                Method Selection and Combination.
                                                              (line 240)
* apply:                                 apply.               (line   6)
* apropos:                               apropos; apropos-list.
                                                              (line   6)
* apropos-list:                          apropos; apropos-list.
                                                              (line   6)
* aref:                                  aref.                (line   6)
* arithmetic-error:                      arithmetic-error.    (line   6)
* arithmetic-error-operands:             arithmetic-error-operands; arithmetic-error-operation.
                                                              (line   6)
* arithmetic-error-operation:            arithmetic-error-operands; arithmetic-error-operation.
                                                              (line   6)
* array <1>:                             Sharpsign.           (line 323)
* array:                                 array.               (line   6)
* array-dimension:                       array-dimension.     (line   6)
* array-dimension-limit:                 array-dimension-limit.
                                                              (line   6)
* array-dimensions:                      array-dimensions.    (line   6)
* array-displacement:                    array-displacement.  (line   6)
* array-element-type:                    array-element-type.  (line   6)
* array-has-fill-pointer-p:              array-has-fill-pointer-p.
                                                              (line   6)
* array-in-bounds-p:                     array-in-bounds-p.   (line   6)
* array-rank:                            array-rank.          (line   6)
* array-rank-limit:                      array-rank-limit.    (line   6)
* array-row-major-index:                 array-row-major-index.
                                                              (line   6)
* array-total-size:                      array-total-size.    (line   6)
* array-total-size-limit:                array-total-size-limit.
                                                              (line   6)
* arrayp:                                arrayp.              (line   6)
* ash:                                   ash.                 (line   6)
* asin:                                  asin; acos; atan.    (line   6)
* asinh:                                 sinh; cosh; tanh; asinh; acosh; atanh.
                                                              (line   6)
* assert:                                assert.              (line   6)
* assoc:                                 assoc; assoc-if; assoc-if-not.
                                                              (line   6)
* assoc-if:                              assoc; assoc-if; assoc-if-not.
                                                              (line   6)
* assoc-if-not:                          assoc; assoc-if; assoc-if-not.
                                                              (line   6)
* association list:                      Conses as Lists.     (line  38)
* Asterisk (format directive):           FORMAT Control-Flow Operations.
                                                              (line   9)
* Asterisk (sharpsign reader macro):     Sharpsign.           (line 151)
* atan:                                  asin; acos; atan.    (line   6)
* atanh:                                 sinh; cosh; tanh; asinh; acosh; atanh.
                                                              (line   6)
* atom <1>:                              atom (Function).     (line   6)
* atom:                                  atom (Type).         (line   6)
* B (format directive):                  FORMAT Radix Control.
                                                              (line  73)
* B (sharpsign reader macro):            Sharpsign.           (line 224)
* Backquote (reader macro):              Backquote.           (line   6)
* Backslash (sharpsign reader macro):    Sharpsign.           (line  78)
* base-char:                             base-char.           (line   6)
* base-string:                           base-string.         (line   6)
* bidirectional:                         Introduction to Streams.
                                                              (line  56)
* bignum:                                bignum.              (line   6)
* binary:                                Introduction to Streams.
                                                              (line   9)
* binding:                               Introduction to Environments.
                                                              (line   6)
* bit <1>:                               bit; sbit.           (line   6)
* bit:                                   bit (Type).          (line   6)
* bit vector:                            Specialized Arrays.  (line  78)
* bit-and:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-andc1:                             bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-andc2:                             bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-eqv:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-ior:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-nand:                              bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-nor:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-not:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-orc1:                              bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-orc2:                              bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* bit-vector <1>:                        Sharpsign.           (line 151)
* bit-vector:                            bit-vector.          (line   6)
* bit-vector-p:                          bit-vector-p.        (line   6)
* bit-xor:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                              (line   6)
* block:                                 block.               (line   6)
* boa lambda list:                       Boa Lambda Lists.    (line   6)
* boole:                                 boole.               (line   6)
* boole-1:                               boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-2:                               boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-and:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-andc1:                           boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-andc2:                           boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-c1:                              boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-c2:                              boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-clr:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-eqv:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-ior:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-nand:                            boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-nor:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-orc1:                            boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-orc2:                            boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-set:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boole-xor:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                              (line   6)
* boolean:                               boolean.             (line   6)
* both-case-p:                           upper-case-p; lower-case-p; both-case-p.
                                                              (line   6)
* bound declaration:                     Declaration Scope.   (line  11)
* boundp:                                boundp.              (line   6)
* break:                                 break.               (line   6)
* broadcast-stream:                      broadcast-stream.    (line   6)
* broadcast-stream-streams:              broadcast-stream-streams.
                                                              (line   6)
* built-in-class:                        built-in-class.      (line   6)
* butlast:                               butlast; nbutlast.   (line   6)
* byte:                                  byte; byte-size; byte-position.
                                                              (line   6)
* byte-position:                         byte; byte-size; byte-position.
                                                              (line   6)
* byte-size:                             byte; byte-size; byte-position.
                                                              (line   6)
* C (format directive):                  FORMAT Basic Output. (line   9)
* C (sharpsign reader macro):            Sharpsign.           (line 296)
* caaaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caaadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caaar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caadar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caaddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caadr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caar:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cadaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cadadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cadar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caddar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cadddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* caddr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cadr:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* call-arguments-limit:                  call-arguments-limit.
                                                              (line   6)
* call-method:                           call-method; make-method.
                                                              (line   6)
* call-next-method:                      call-next-method.    (line   6)
* car:                                   car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* case:                                  case; ccase; ecase.  (line   6)
* case in symbol names:                  Notational Conventions.
                                                              (line 326)
* catch:                                 catch.               (line   6)
* ccase:                                 case; ccase; ecase.  (line   6)
* cdaaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdaadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdaar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdadar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdaddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdadr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdar:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cddaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cddadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cddar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdddar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cddddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdddr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cddr:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* cdr:                                   car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                              (line   6)
* ceiling:                               floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* cell-error:                            cell-error.          (line   6)
* cell-error-name:                       cell-error-name.     (line   6)
* cerror:                                cerror.              (line   6)
* change-class:                          change-class.        (line   6)
* char:                                  char; schar.         (line   6)
* char-bit:                              Removed Operators.   (line   7)
* char-bits:                             Removed Operators.   (line   6)
* char-bits-limit:                       Removed Variables.   (line   6)
* char-code:                             char-code.           (line   6)
* char-code-limit:                       char-code-limit.     (line   6)
* char-control-bit:                      Removed Variables.   (line   6)
* char-downcase:                         char-upcase; char-downcase.
                                                              (line   6)
* char-equal:                            char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char-font:                             Removed Operators.   (line   6)
* char-font-limit:                       Removed Variables.   (line   6)
* char-greaterp:                         char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char-hyper-bit:                        Removed Variables.   (line   7)
* char-int:                              char-int.            (line   6)
* char-lessp:                            char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char-meta-bit:                         Removed Variables.   (line   7)
* char-name:                             char-name.           (line   6)
* char-not-equal:                        char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char-not-greaterp:                     char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char-not-lessp:                        char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char-super-bit:                        Removed Variables.   (line   7)
* char-upcase:                           char-upcase; char-downcase.
                                                              (line   6)
* char/=:                                char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char<:                                 char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char<=:                                char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char=:                                 char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char>:                                 char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* char>=:                                char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                              (line   6)
* character <1>:                         Introduction to Streams.
                                                              (line   8)
* character <2>:                         Sharpsign.           (line  78)
* character <3>:                         character (Function).
                                                              (line   6)
* character <4>:                         character (System Class).
                                                              (line   6)
* character:                             Introduction to Characters.
                                                              (line   6)
* characterp:                            characterp.          (line   6)
* check-type:                            check-type.          (line   6)
* circular list <1>:                     list (System Class). (line  20)
* circular list:                         Conses as Lists.     (line  20)
* Circumflex (format directive):         FORMAT Miscellaneous Pseudo-Operations.
                                                              (line  15)
* cis:                                   cis.                 (line   6)
* CL:                                    Standardized Packages.
                                                              (line  21)
* CL-USER:                               Standardized Packages.
                                                              (line 156)
* class <1>:                             class.               (line   6)
* class:                                 Introduction to Classes.
                                                              (line   6)
* class precedence list <1>:             Determining the Class Precedence List.
                                                              (line   9)
* class precedence list:                 Introduction to Classes.
                                                              (line  35)
* class-name:                            class-name.          (line   6)
* class-of:                              class-of.            (line   6)
* clear-input:                           clear-input.         (line   6)
* clear-output:                          finish-output; force-output; clear-output.
                                                              (line   6)
* close:                                 close.               (line   6)
* closed:                                Introduction to Streams.
                                                              (line  71)
* clrhash:                               clrhash.             (line   6)
* coalesce:                              Compiler Terminology.
                                                              (line  24)
* code-char <1>:                         Removed Argument Conventions.
                                                              (line   7)
* code-char:                             code-char.           (line   6)
* coerce:                                coerce.              (line   6)
* Colon (sharpsign reader macro):        Sharpsign.           (line 196)
* Comma (reader macro):                  Comma.               (line   6)
* comment <1>:                           Sharpsign.           (line 473)
* comment:                               Semicolon.           (line   6)
* COMMON-LISP <1>:                       Standardized Packages.
                                                              (line  21)
* COMMON-LISP:                           Symbols in the COMMON-LISP Package.
                                                              (line   7)
* COMMON-LISP-USER:                      Standardized Packages.
                                                              (line 156)
* commonp:                               Removed Operators.   (line   7)
* compilation environment:               Compiler Terminology.
                                                              (line  51)
* compilation-speed:                     optimize.            (line   9)
* compile <1>:                           eval-when.           (line  15)
* compile <2>:                           Compilation Semantics.
                                                              (line 161)
* compile:                               compile.             (line   6)
* compile time:                          Compiler Terminology.
                                                              (line  74)
* compile-file <1>:                      compile-file.        (line   6)
* compile-file:                          Compilation Semantics.
                                                              (line 162)
* compile-file-pathname:                 compile-file-pathname.
                                                              (line   6)
* compile-time definition:               Compiler Terminology.
                                                              (line  78)
* compiled code <1>:                     Loading.             (line   7)
* compiled code:                         Compiler Terminology.
                                                              (line  13)
* compiled file:                         Loading.             (line  13)
* compiled-function:                     compiled-function.   (line   6)
* compiled-function-p:                   compiled-function-p. (line   6)
* compiler:                              Compiler Terminology.
                                                              (line  10)
* compiler macro:                        Compilation Semantics.
                                                              (line 149)
* compiler-macro-function:               compiler-macro-function.
                                                              (line   6)
* complement:                            complement.          (line   6)
* complex <1>:                           complex (System Class).
                                                              (line   6)
* complex <2>:                           Default Print-Object Methods.
                                                              (line  71)
* complex <3>:                           complex (Function).  (line   6)
* complex:                               Sharpsign.           (line 296)
* complexp:                              complexp.            (line   6)
* compound type specifier:               Type Specifiers.     (line  53)
* compute-applicable-methods:            compute-applicable-methods.
                                                              (line   6)
* compute-restarts:                      compute-restarts.    (line   6)
* concatenate:                           concatenate.         (line   6)
* concatenated-stream:                   concatenated-stream. (line   6)
* concatenated-stream-streams:           concatenated-stream-streams.
                                                              (line   6)
* cond:                                  cond.                (line   6)
* condition:                             condition.           (line   6)
* condition designator:                  Creating Conditions. (line  17)
* condition reporter:                    Printing Conditions. (line   9)
* conditional newlines:                  Pretty Printer Concepts.
                                                              (line  35)
* conforming code:                       Conforming Programs. (line   6)
* conforming implementation:             Conforming Implementations.
                                                              (line   6)
* conforming program:                    Conforming Programs. (line   6)
* congruence:                            Introduction to Methods.
                                                              (line  49)
* conjugate:                             conjugate.           (line   6)
* cons <1>:                              Cons Concepts.       (line   6)
* cons <2>:                              cons (System Class). (line   6)
* cons <3>:                              cons (Function).     (line   6)
* cons <4>:                              Backquote.           (line   6)
* cons:                                  Comma.               (line   6)
* consequences:                          Error Terminology.   (line  92)
* consp:                                 consp.               (line   6)
* constantly:                            constantly.          (line   6)
* constantp:                             constantp.           (line   6)
* continue <1>:                          abort; continue; muffle-warning; store-value; use-value.
                                                              (line   6)
* continue <2>:                          continue (Restart).  (line   6)
* continue:                              abort; continue; muffle-warning; store-value; use-value.
                                                              (line   6)
* control-error:                         control-error.       (line   6)
* copy-alist:                            copy-alist.          (line   6)
* copy-list:                             copy-list.           (line   6)
* copy-pprint-dispatch:                  copy-pprint-dispatch.
                                                              (line   6)
* copy-readtable:                        copy-readtable.      (line   6)
* copy-seq:                              copy-seq.            (line   6)
* copy-structure:                        copy-structure.      (line   6)
* copy-symbol:                           copy-symbol.         (line   6)
* copy-tree:                             copy-tree.           (line   6)
* cos:                                   sin; cos; tan.       (line   6)
* cosh:                                  sinh; cosh; tanh; asinh; acosh; atanh.
                                                              (line   6)
* count:                                 count; count-if; count-if-not.
                                                              (line   6)
* count-if:                              count; count-if; count-if-not.
                                                              (line   6)
* count-if-not:                          count; count-if; count-if-not.
                                                              (line   6)
* ctypecase:                             typecase; ctypecase; etypecase.
                                                              (line   6)
* current input base:                    *read-base*.         (line  22)
* current output base:                   *print-base*; *print-radix*.
                                                              (line  21)
* current package:                       Introduction to Packages.
                                                              (line   7)
* current pprint dispatch table:         Pretty Printer Concepts.
                                                              (line 137)
* current readtable:                     Readtables.          (line  25)
* D (format directive):                  FORMAT Radix Control.
                                                              (line  44)
* debug:                                 optimize.            (line   9)
* decf:                                  incf; decf.          (line   6)
* declaim:                               declaim.             (line   6)
* declaration <1>:                       Minimal Declaration Processing Requirements.
                                                              (line   7)
* declaration <2>:                       declaration.         (line   6)
* declaration:                           Declarations.        (line   6)
* declaration identifier:                Declaration Identifiers.
                                                              (line   6)
* declaration specifier:                 Declaration Specifiers.
                                                              (line   6)
* declare:                               declare.             (line   6)
* decode-float:                          decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                              (line   6)
* decode-universal-time:                 decode-universal-time.
                                                              (line   6)
* decoded time:                          Time.                (line  30)
* default method:                        Introduction to Methods.
                                                              (line 101)
* defclass:                              defclass.            (line   6)
* defconstant:                           defconstant.         (line   6)
* defgeneric:                            defgeneric.          (line   6)
* define-compiler-macro:                 define-compiler-macro.
                                                              (line   6)
* define-condition:                      define-condition.    (line   6)
* define-method-combination:             define-method-combination.
                                                              (line   6)
* define-method-combination arguments lambda list: Define-method-combination Arguments Lambda Lists.
                                                              (line   6)
* define-modify-macro:                   define-modify-macro. (line   6)
* define-modify-macro lambda list:       Define-modify-macro Lambda Lists.
                                                              (line   6)
* define-setf-expander:                  define-setf-expander.
                                                              (line   6)
* define-symbol-macro:                   define-symbol-macro. (line   6)
* defmacro:                              defmacro.            (line   6)
* defmethod:                             defmethod.           (line   6)
* defpackage:                            defpackage.          (line   6)
* defparameter:                          defparameter; defvar.
                                                              (line   6)
* defsetf:                               defsetf.             (line   6)
* defsetf lambda list:                   Defsetf Lambda Lists.
                                                              (line   6)
* defstruct:                             defstruct.           (line   6)
* deftype:                               deftype.             (line   6)
* deftype lambda list:                   Deftype Lambda Lists.
                                                              (line   6)
* defun:                                 defun.               (line   6)
* defvar:                                defparameter; defvar.
                                                              (line   6)
* delete:                                remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                              (line   6)
* delete-duplicates:                     remove-duplicates; delete-duplicates.
                                                              (line   6)
* delete-file:                           delete-file.         (line   6)
* delete-if:                             remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                              (line   6)
* delete-if-not:                         remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                              (line   6)
* delete-package:                        delete-package.      (line   6)
* denominator:                           numerator; denominator.
                                                              (line   6)
* deposit-field:                         deposit-field.       (line   6)
* derived type specifier:                Type Specifiers.     (line 110)
* describe:                              describe.            (line   6)
* describe-object:                       describe-object.     (line   6)
* designator:                            Notational Conventions.
                                                              (line 425)
* destructuring lambda list:             Destructuring Lambda Lists.
                                                              (line   6)
* destructuring-bind:                    destructuring-bind.  (line   6)
* digit-char <1>:                        Removed Argument Conventions.
                                                              (line   6)
* digit-char:                            digit-char.          (line   6)
* digit-char-p:                          digit-char-p.        (line   6)
* dimension:                             Array Elements.      (line  20)
* direct subclass:                       Introduction to Classes.
                                                              (line  26)
* direct superclass:                     Introduction to Classes.
                                                              (line  25)
* directory:                             directory.           (line   6)
* directory-namestring:                  namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                              (line   6)
* disassemble:                           disassemble.         (line   6)
* division-by-zero:                      division-by-zero.    (line   6)
* do:                                    do; do*.             (line   6)
* do*:                                   do; do*.             (line   6)
* do-all-symbols:                        do-symbols; do-external-symbols; do-all-symbols.
                                                              (line   6)
* do-external-symbols:                   do-symbols; do-external-symbols; do-all-symbols.
                                                              (line   6)
* do-symbols:                            do-symbols; do-external-symbols; do-all-symbols.
                                                              (line   6)
* documentation:                         documentation; setf documentation.
                                                              (line   6)
* dolist:                                dolist.              (line   6)
* Dollarsign (format directive):         FORMAT Floating-Point Printers.
                                                              (line 204)
* dot <1>:                               pprint-pop.          (line  28)
* dot:                                   Left-Parenthesis.    (line  21)
* Dot (sharpsign reader macro):          Sharpsign.           (line 209)
* Dot Dot <1>:                           Re-Reading Abbreviated Expressions.
                                                              (line   6)
* Dot Dot:                               *print-lines*.       (line  21)
* Dot Dot Dot <1>:                       Re-Reading Abbreviated Expressions.
                                                              (line   6)
* Dot Dot Dot:                           pprint-pop.          (line  34)
* dotimes:                               dotimes.             (line   6)
* dotted list <1>:                       list (System Class). (line  19)
* dotted list:                           Conses as Lists.     (line  16)
* double-float:                          short-float; single-float; double-float; long-float.
                                                              (line   6)
* double-float-epsilon:                  short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* double-float-negative-epsilon:         short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* Double-Quote (reader macro):           Double-Quote.        (line   6)
* dpb:                                   dpb.                 (line   6)
* dribble:                               dribble.             (line   6)
* dynamic environment:                   Introduction to Environments.
                                                              (line  37)
* dynamic-extent:                        dynamic-extent.      (line   6)
* E (format directive):                  FORMAT Floating-Point Printers.
                                                              (line  85)
* ecase:                                 case; ccase; ecase.  (line   6)
* echo-stream:                           echo-stream.         (line   6)
* echo-stream-input-stream:              echo-stream-input-stream; echo-stream-output-stream.
                                                              (line   6)
* echo-stream-output-stream:             echo-stream-input-stream; echo-stream-output-stream.
                                                              (line   6)
* ed:                                    ed.                  (line   6)
* effective method:                      Method Selection and Combination.
                                                              (line   7)
* eighth:                                first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* elt:                                   elt.                 (line   6)
* empty list:                            list (System Class). (line  18)
* encode-universal-time:                 encode-universal-time.
                                                              (line   6)
* end-of-file:                           end-of-file.         (line   6)
* endp:                                  endp.                (line   6)
* enough-namestring:                     namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                              (line   6)
* ensure-directories-exist:              ensure-directories-exist.
                                                              (line   6)
* ensure-generic-function:               ensure-generic-function.
                                                              (line   6)
* environment:                           Introduction to Environments.
                                                              (line  10)
* environment object:                    Introduction to Environments.
                                                              (line 103)
* eq:                                    eq.                  (line   6)
* eql <1>:                               eql (Function).      (line   6)
* eql:                                   eql (Type Specifier).
                                                              (line   6)
* equal:                                 equal.               (line   6)
* Equal-Sign (sharpsign reader macro):   Sharpsign.           (line 399)
* equalp:                                equalp.              (line   6)
* error <1>:                             error (Condition Type).
                                                              (line   6)
* error:                                 error (Function).    (line   6)
* etypecase:                             typecase; ctypecase; etypecase.
                                                              (line   6)
* eval <1>:                              Sharpsign.           (line 209)
* eval <2>:                              eval.                (line   6)
* eval:                                  eval-when.           (line  15)
* eval-when <1>:                         File Compilation.    (line  67)
* eval-when:                             eval-when.           (line   6)
* evaluation:                            Evaluation.          (line  10)
* evaluation environment:                Compiler Terminology.
                                                              (line  60)
* evaluation order <1>:                  Defaulting of Initialization Arguments.
                                                              (line  53)
* evaluation order <2>:                  assert.              (line  46)
* evaluation order <3>:                  multiple-value-setq. (line  41)
* evaluation order <4>:                  ldb.                 (line  39)
* evaluation order <5>:                  Overview of Places and Generalized Reference.
                                                              (line  97)
* evaluation order <6>:                  Variable Initialization and Stepping Clauses.
                                                              (line  81)
* evaluation order <7>:                  catch.               (line  29)
* evaluation order <8>:                  Overview of Places and Generalized Reference.
                                                              (line  56)
* evaluation order:                      load-time-value.     (line  42)
* evenp:                                 evenp; oddp.         (line   6)
* every:                                 every; some; notevery; notany.
                                                              (line   6)
* exp:                                   exp; expt.           (line   6)
* export:                                export.              (line   6)
* expressed array element type:          Specialized Arrays.  (line  37)
* expt:                                  exp; expt.           (line   6)
* extended-char:                         extended-char.       (line   6)
* extensions:                            Error Terminology.   (line 124)
* external symbol:                       Introduction to Packages.
                                                              (line  56)
* externalizable object:                 Literal Objects in Compiled Files.
                                                              (line  35)
* F (format directive):                  FORMAT Floating-Point Printers.
                                                              (line   9)
* fboundp:                               fboundp.             (line   6)
* fceiling:                              floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* fdefinition:                           fdefinition.         (line   6)
* feature:                               Features.            (line   6)
* feature expression:                    Features.            (line  17)
* features list:                         Features.            (line  12)
* ffloor:                                floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* fifth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* file:                                  File System Concepts.
                                                              (line   7)
* file stream:                           Introduction to Streams.
                                                              (line 125)
* file-author:                           file-author.         (line   6)
* file-error:                            file-error.          (line   6)
* file-error-pathname:                   file-error-pathname. (line   6)
* file-length:                           file-length.         (line   6)
* file-namestring:                       namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                              (line   6)
* file-position:                         file-position.       (line   6)
* file-stream:                           file-stream.         (line   6)
* file-string-length:                    file-string-length.  (line   6)
* file-write-date:                       file-write-date.     (line   6)
* filename:                              File System Concepts.
                                                              (line   7)
* fill:                                  fill.                (line   6)
* fill pointer:                          Array Elements.      (line  53)
* fill-pointer:                          fill-pointer.        (line   6)
* fill-style conditional newline <1>:    Examples of using the Pretty Printer.
                                                              (line  84)
* fill-style conditional newline:        pprint-newline.      (line  47)
* find:                                  find; find-if; find-if-not.
                                                              (line   6)
* find-all-symbols:                      find-all-symbols.    (line   6)
* find-class:                            find-class.          (line   6)
* find-if:                               find; find-if; find-if-not.
                                                              (line   6)
* find-if-not:                           find; find-if; find-if-not.
                                                              (line   6)
* find-method:                           find-method.         (line   6)
* find-package:                          find-package.        (line   6)
* find-restart:                          find-restart.        (line   6)
* find-symbol:                           find-symbol.         (line   6)
* finish-output:                         finish-output; force-output; clear-output.
                                                              (line   6)
* first:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* fixnum:                                fixnum.              (line   6)
* flet:                                  flet; labels; macrolet.
                                                              (line   6)
* float <1>:                             float (System Class).
                                                              (line   6)
* float <2>:                             Default Print-Object Methods.
                                                              (line  43)
* float:                                 float (Function).    (line   6)
* float-digits:                          decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                              (line   6)
* float-precision:                       decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                              (line   6)
* float-radix:                           decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                              (line   6)
* float-sign:                            decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                              (line   6)
* floating-point-inexact:                floating-point-inexact.
                                                              (line   6)
* floating-point-invalid-operation:      floating-point-invalid-operation.
                                                              (line   6)
* floating-point-overflow:               floating-point-overflow.
                                                              (line   6)
* floating-point-underflow:              floating-point-underflow.
                                                              (line   6)
* floatp:                                floatp.              (line   6)
* floor:                                 floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* fmakunbound:                           fmakunbound.         (line   6)
* force-output:                          finish-output; force-output; clear-output.
                                                              (line   6)
* format:                                format.              (line   6)
* format control:                        Pretty Printer Concepts.
                                                              (line 124)
* formatter:                             formatter.           (line   6)
* fourth:                                first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* free declaration:                      Declaration Scope.   (line  15)
* fresh-line:                            terpri; fresh-line.  (line   6)
* fround:                                floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* ftruncate:                             floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* ftype:                                 ftype.               (line   6)
* funcall:                               funcall.             (line   6)
* function <1>:                          function (System Class).
                                                              (line   6)
* function <2>:                          Sharpsign.           (line 104)
* function:                              function (Special Operator).
                                                              (line   6)
* function-keywords:                     function-keywords.   (line   6)
* function-lambda-expression:            function-lambda-expression.
                                                              (line   6)
* functionp:                             functionp.           (line   6)
* further compilation:                   Compiler Terminology.
                                                              (line  38)
* G (format directive):                  FORMAT Floating-Point Printers.
                                                              (line 175)
* gcd:                                   gcd.                 (line   6)
* generalized reference:                 Overview of Places and Generalized Reference.
                                                              (line   6)
* generic function <1>:                  Introduction to Generic Functions.
                                                              (line   6)
* generic function:                      generic-function.    (line  14)
* generic function lambda list:          Generic Function Lambda Lists.
                                                              (line   6)
* generic-function:                      generic-function.    (line   6)
* gensym:                                gensym.              (line   6)
* gentemp:                               gentemp.             (line   6)
* get:                                   get.                 (line   6)
* get-decoded-time:                      get-universal-time; get-decoded-time.
                                                              (line   6)
* get-dispatch-macro-character:          set-dispatch-macro-character; get-dispatch-macro-character.
                                                              (line   6)
* get-internal-real-time:                get-internal-real-time.
                                                              (line   6)
* get-internal-run-time:                 get-internal-run-time.
                                                              (line   6)
* get-macro-character:                   set-macro-character; get-macro-character.
                                                              (line   6)
* get-output-stream-string:              get-output-stream-string.
                                                              (line   6)
* get-properties:                        get-properties.      (line   6)
* get-setf-expansion:                    get-setf-expansion.  (line   6)
* get-universal-time:                    get-universal-time; get-decoded-time.
                                                              (line   6)
* getf:                                  getf.                (line   6)
* gethash:                               gethash.             (line   6)
* global declaration:                    Declarations.        (line   9)
* global environment:                    Introduction to Environments.
                                                              (line  20)
* go:                                    go.                  (line   6)
* graphic:                               Character Categories.
                                                              (line  23)
* graphic-char-p:                        graphic-char-p.      (line   6)
* Greater-Than-Sign (format directive):  FORMAT Layout Control.
                                                              (line 115)
* handler-bind:                          handler-bind.        (line   6)
* handler-case:                          handler-case.        (line   6)
* hash-table:                            hash-table.          (line   6)
* hash-table-count:                      hash-table-count.    (line   6)
* hash-table-p:                          hash-table-p.        (line   6)
* hash-table-rehash-size:                hash-table-rehash-size.
                                                              (line   6)
* hash-table-rehash-threshold:           hash-table-rehash-threshold.
                                                              (line   6)
* hash-table-size:                       hash-table-size.     (line   6)
* hash-table-test:                       hash-table-test.     (line   6)
* host-namestring:                       namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                              (line   6)
* I (format directive):                  FORMAT Pretty Printer Operations.
                                                              (line  87)
* identity:                              identity.            (line   6)
* if:                                    if.                  (line   6)
* ignorable:                             ignore; ignorable.   (line   6)
* ignore:                                ignore; ignorable.   (line   6)
* ignore-errors:                         ignore-errors.       (line   6)
* imagpart:                              realpart; imagpart.  (line   6)
* implicit compilation:                  Compiler Terminology.
                                                              (line  17)
* import:                                import.              (line   6)
* improper list:                         Conses as Lists.     (line  13)
* in-package:                            in-package.          (line   6)
* incf:                                  incf; decf.          (line   6)
* initial readtable:                     Readtables.          (line  45)
* initialization argument list:          Object Creation and Initialization.
                                                              (line   8)
* initialize-instance:                   initialize-instance (Standard Generic Function).
                                                              (line   6)
* inline:                                inline; notinline.   (line   6)
* input:                                 Introduction to Streams.
                                                              (line  32)
* input-stream-p:                        input-stream-p; output-stream-p.
                                                              (line   6)
* inspect:                               inspect.             (line   6)
* instance:                              Introduction to Classes.
                                                              (line   7)
* int-char:                              Removed Operators.   (line   6)
* integer:                               integer.             (line   6)
* integer-decode-float:                  decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                              (line   6)
* integer-length:                        integer-length.      (line   6)
* integerp:                              integerp.            (line   6)
* interactive stream:                    Introduction to Streams.
                                                              (line  92)
* interactive-stream-p:                  interactive-stream-p.
                                                              (line   6)
* intern:                                intern.              (line   6)
* internal symbol:                       Introduction to Packages.
                                                              (line  54)
* internal time:                         Time.                (line 100)
* internal-time-units-per-second:        internal-time-units-per-second.
                                                              (line   6)
* intersection:                          intersection; nintersection.
                                                              (line   6)
* invalid-method-error:                  invalid-method-error.
                                                              (line   6)
* invoke-debugger:                       invoke-debugger.     (line   6)
* invoke-restart:                        invoke-restart.      (line   6)
* invoke-restart-interactively:          invoke-restart-interactively.
                                                              (line   6)
* is signaled:                           Error Terminology.   (line  27)
* isqrt:                                 sqrt; isqrt.         (line   6)
* keyword:                               keyword.             (line   6)
* KEYWORD:                               Standardized Packages.
                                                              (line 165)
* keywordp:                              keywordp.            (line   6)
* labels:                                flet; labels; macrolet.
                                                              (line   6)
* lambda <1>:                            lambda (Macro).      (line   6)
* lambda:                                lambda (Symbol).     (line   6)
* lambda list:                           Lambda Lists.        (line   6)
* lambda-list-keywords:                  lambda-list-keywords.
                                                              (line   6)
* lambda-parameters-limit:               lambda-parameters-limit.
                                                              (line   6)
* last:                                  last.                (line   6)
* lcm:                                   lcm.                 (line   6)
* ldb:                                   ldb.                 (line   6)
* ldb-test:                              ldb-test.            (line   6)
* ldiff:                                 ldiff; tailp.        (line   6)
* least-negative-double-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-negative-long-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-negative-normalized-double-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-negative-normalized-long-float:  most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-negative-normalized-short-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-negative-normalized-single-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-negative-short-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-negative-single-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-double-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-long-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-normalized-double-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-normalized-long-float:  most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-normalized-short-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-normalized-single-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-short-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* least-positive-single-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* leaves:                                Conses as Trees.     (line   9)
* Left-Brace (format directive):         FORMAT Control-Flow Operations.
                                                              (line  89)
* Left-Bracket (format directive):       FORMAT Control-Flow Operations.
                                                              (line  27)
* Left-Paren (format directive):         FORMAT Miscellaneous Operations.
                                                              (line   9)
* Left-Parenthesis (reader macro):       Left-Parenthesis.    (line   6)
* Left-Parenthesis (sharpsign reader macro): Sharpsign.       (line 114)
* length:                                length.              (line   6)
* Less-Than-Sign (format directive) <1>: FORMAT Layout Control.
                                                              (line  47)
* Less-Than-Sign (format directive):     FORMAT Pretty Printer Operations.
                                                              (line  19)
* Less-Than-Sign (sharpsign reader macro): Sharpsign.         (line 559)
* let:                                   let; let*.           (line   6)
* let*:                                  let; let*.           (line   6)
* lexical environment:                   Introduction to Environments.
                                                              (line  64)
* linear-style conditional newline <1>:  Examples of using the Pretty Printer.
                                                              (line  33)
* linear-style conditional newline:      pprint-newline.      (line  29)
* LISP:                                  Packages No Longer Required.
                                                              (line   6)
* lisp-implementation-type:              lisp-implementation-type; lisp-implementation-version.
                                                              (line   6)
* lisp-implementation-version:           lisp-implementation-type; lisp-implementation-version.
                                                              (line   6)
* list <1>:                              Method Selection and Combination.
                                                              (line 240)
* list <2>:                              list (System Class). (line   6)
* list <3>:                              list; list*.         (line   6)
* list <4>:                              list (System Class). (line  14)
* list <5>:                              Left-Parenthesis.    (line   6)
* list <6>:                              Conses as Lists.     (line   6)
* list <7>:                              Backquote.           (line   6)
* list:                                  Comma.               (line   6)
* list*:                                 list; list*.         (line   6)
* list-all-packages:                     list-all-packages.   (line   6)
* list-length:                           list-length.         (line   6)
* listen:                                listen.              (line   6)
* listp:                                 listp.               (line   6)
* literal object:                        Compiler Terminology.
                                                              (line  20)
* load <1>:                              load.                (line   6)
* load:                                  eval-when.           (line  15)
* load-logical-pathname-translations:    load-logical-pathname-translations.
                                                              (line   6)
* load-time-value <1>:                   Compilation Semantics.
                                                              (line 160)
* load-time-value:                       load-time-value.     (line   6)
* local declaration:                     Declarations.        (line   9)
* local precedence order <1>:            Introduction to Classes.
                                                              (line  45)
* local precedence order:                Determining the Class Precedence List.
                                                              (line   7)
* locally:                               locally.             (line   6)
* log:                                   log.                 (line   6)
* logand:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* logandc1:                              logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* logandc2:                              logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* logbitp:                               logbitp.             (line   6)
* logcount:                              logcount.            (line   6)
* logeqv:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* logical blocks:                        Pretty Printer Concepts.
                                                              (line  35)
* logical-pathname <1>:                  logical-pathname (Function).
                                                              (line   6)
* logical-pathname:                      logical-pathname (System Class).
                                                              (line   6)
* logical-pathname-translations:         logical-pathname-translations.
                                                              (line   6)
* logior:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* lognand:                               logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* lognor:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* lognot:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* logorc1:                               logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* logorc2:                               logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* logtest:                               logtest.             (line   6)
* logxor:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                              (line   6)
* long-float:                            short-float; single-float; double-float; long-float.
                                                              (line   6)
* long-float-epsilon:                    short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* long-float-negative-epsilon:           short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* long-site-name:                        short-site-name; long-site-name.
                                                              (line   6)
* loop:                                  loop.                (line   6)
* loop-finish:                           loop-finish.         (line   6)
* lower-case-p:                          upper-case-p; lower-case-p; both-case-p.
                                                              (line   6)
* machine-instance:                      machine-instance.    (line   6)
* machine-type:                          machine-type.        (line   6)
* machine-version:                       machine-version.     (line   6)
* macro:                                 Compilation Semantics.
                                                              (line 153)
* macro lambda list:                     Macro Lambda Lists.  (line   6)
* macro-function:                        macro-function.      (line   6)
* macroexpand:                           macroexpand; macroexpand-1.
                                                              (line   6)
* macroexpand-1:                         macroexpand; macroexpand-1.
                                                              (line   6)
* macrolet <1>:                          Compilation Semantics.
                                                              (line 155)
* macrolet:                              flet; labels; macrolet.
                                                              (line   6)
* make-array:                            make-array.          (line   6)
* make-broadcast-stream:                 make-broadcast-stream.
                                                              (line   6)
* make-char:                             Removed Operators.   (line   6)
* make-concatenated-stream:              make-concatenated-stream.
                                                              (line   6)
* make-condition:                        make-condition.      (line   6)
* make-dispatch-macro-character:         make-dispatch-macro-character.
                                                              (line   6)
* make-echo-stream:                      make-echo-stream.    (line   6)
* make-hash-table:                       make-hash-table.     (line   6)
* make-instance:                         make-instance.       (line   6)
* make-instances-obsolete:               make-instances-obsolete.
                                                              (line   6)
* make-list:                             make-list.           (line   6)
* make-load-form:                        make-load-form.      (line   6)
* make-load-form-saving-slots:           make-load-form-saving-slots.
                                                              (line   6)
* make-method:                           call-method; make-method.
                                                              (line   6)
* make-package:                          make-package.        (line   6)
* make-pathname:                         make-pathname.       (line   6)
* make-random-state:                     make-random-state.   (line   6)
* make-sequence:                         make-sequence.       (line   6)
* make-string:                           make-string.         (line   6)
* make-string-input-stream:              make-string-input-stream.
                                                              (line   6)
* make-string-output-stream:             make-string-output-stream.
                                                              (line   6)
* make-symbol:                           make-symbol.         (line   6)
* make-synonym-stream:                   make-synonym-stream. (line   6)
* make-two-way-stream:                   make-two-way-stream. (line   6)
* makunbound:                            makunbound.          (line   6)
* mandatory-style conditional newline:   pprint-newline.      (line  60)
* map:                                   map.                 (line   6)
* map-into:                              map-into.            (line   6)
* mapc:                                  mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                              (line   6)
* mapcan:                                mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                              (line   6)
* mapcar:                                mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                              (line   6)
* mapcon:                                mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                              (line   6)
* maphash:                               maphash.             (line   6)
* mapl:                                  mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                              (line   6)
* maplist:                               mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                              (line   6)
* mask-field:                            mask-field.          (line   6)
* max <1>:                               Method Selection and Combination.
                                                              (line 240)
* max:                                   max; min.            (line   6)
* member <1>:                            member; member-if; member-if-not.
                                                              (line   6)
* member:                                member (Type Specifier).
                                                              (line   6)
* member-if:                             member; member-if; member-if-not.
                                                              (line   6)
* member-if-not:                         member; member-if; member-if-not.
                                                              (line   6)
* merge:                                 merge.               (line   6)
* merge-pathnames:                       merge-pathnames.     (line   6)
* metaclass <1>:                         Introduction to Types and Classes.
                                                              (line  45)
* metaclass:                             Introduction to Classes.
                                                              (line  73)
* method:                                method.              (line   6)
* method-combination:                    method-combination.  (line   6)
* method-combination-error:              method-combination-error.
                                                              (line   6)
* method-defining operator:              Introduction to Generic Functions.
                                                              (line  59)
* method-qualifiers:                     method-qualifiers.   (line   6)
* might signal:                          Error Terminology.   (line 106)
* min <1>:                               Method Selection and Combination.
                                                              (line 240)
* min:                                   max; min.            (line   6)
* minimal compilation:                   Compiler Terminology.
                                                              (line  30)
* Minus (sharpsign reader macro):        Sharpsign.           (line 462)
* minusp:                                minusp; plusp.       (line   6)
* miser-style conditional newline <1>:   Examples of using the Pretty Printer.
                                                              (line  52)
* miser-style conditional newline:       pprint-newline.      (line  36)
* mismatch:                              mismatch.            (line   6)
* mod <1>:                               mod; rem.            (line   6)
* mod:                                   mod (Type Specifier).
                                                              (line   6)
* most-negative-double-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* most-negative-fixnum:                  most-positive-fixnum; most-negative-fixnum.
                                                              (line   6)
* most-negative-long-float:              most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* most-negative-short-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* most-negative-single-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* most-positive-double-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* most-positive-fixnum:                  most-positive-fixnum; most-negative-fixnum.
                                                              (line   6)
* most-positive-long-float:              most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* most-positive-short-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* most-positive-single-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                              (line   6)
* muffle-warning <1>:                    muffle-warning (Restart).
                                                              (line   6)
* muffle-warning:                        abort; continue; muffle-warning; store-value; use-value.
                                                              (line   6)
* multiple escape:                       Character Syntax Types.
                                                              (line 216)
* multiple-value-bind:                   multiple-value-bind. (line   6)
* multiple-value-call:                   multiple-value-call. (line   6)
* multiple-value-list:                   multiple-value-list. (line   6)
* multiple-value-prog1:                  multiple-value-prog1.
                                                              (line   6)
* multiple-value-setq:                   multiple-value-setq. (line   6)
* multiple-values-limit:                 multiple-values-limit.
                                                              (line   6)
* must signal:                           Error Terminology.   (line  27)
* name:                                  Notational Conventions.
                                                              (line  24)
* name-char:                             name-char.           (line   6)
* namespace:                             Introduction to Environments.
                                                              (line  13)
* namestring <1>:                        Namestrings as Filenames.
                                                              (line   6)
* namestring:                            namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                              (line   6)
* nbutlast:                              butlast; nbutlast.   (line   6)
* nconc <1>:                             nconc.               (line   6)
* nconc:                                 Method Selection and Combination.
                                                              (line 240)
* Newline (format directive):            FORMAT Miscellaneous Pseudo-Operations.
                                                              (line  82)
* next method:                           Method Selection and Combination.
                                                              (line  87)
* next-method-p:                         next-method-p.       (line   6)
* nil <1>:                               Notational Conventions.
                                                              (line 382)
* nil <2>:                               nil (Constant Variable).
                                                              (line   6)
* nil <3>:                               nil (Type).          (line   6)
* nil:                                   Notational Conventions.
                                                              (line 382)
* nintersection:                         intersection; nintersection.
                                                              (line   6)
* ninth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* no-applicable-method:                  no-applicable-method.
                                                              (line   6)
* no-next-method:                        no-next-method.      (line   6)
* non-graphic:                           Character Categories.
                                                              (line  34)
* non-terminating:                       Character Syntax Types.
                                                              (line 186)
* not <1>:                               not (Function).      (line   6)
* not:                                   not (Type Specifier).
                                                              (line   6)
* notany:                                every; some; notevery; notany.
                                                              (line   6)
* notevery:                              every; some; notevery; notany.
                                                              (line   6)
* notinline <1>:                         Minimal Declaration Processing Requirements.
                                                              (line   7)
* notinline:                             inline; notinline.   (line   6)
* nreconc:                               revappend; nreconc.  (line   6)
* nreverse:                              reverse; nreverse.   (line   6)
* nset-difference:                       set-difference; nset-difference.
                                                              (line   6)
* nset-exclusive-or:                     set-exclusive-or; nset-exclusive-or.
                                                              (line   6)
* nstring-capitalize:                    string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                              (line   6)
* nstring-downcase:                      string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                              (line   6)
* nstring-upcase:                        string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                              (line   6)
* nsublis:                               sublis; nsublis.     (line   6)
* nsubst:                                subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                              (line   6)
* nsubst-if:                             subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                              (line   6)
* nsubst-if-not:                         subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                              (line   6)
* nsubstitute:                           substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                              (line   6)
* nsubstitute-if:                        substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                              (line   6)
* nsubstitute-if-not:                    substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                              (line   6)
* nth:                                   nth.                 (line   6)
* nth-value:                             nth-value.           (line   6)
* nthcdr:                                nthcdr.              (line   6)
* null <1>:                              null (System Class). (line   6)
* null <2>:                              null (Function).     (line   6)
* null:                                  Character Attributes.
                                                              (line  16)
* null lexical environment:              Introduction to Environments.
                                                              (line  93)
* number:                                number.              (line   6)
* numberp:                               numberp.             (line   6)
* numerator:                             numerator; denominator.
                                                              (line   6)
* nunion:                                union; nunion.       (line   6)
* O (format directive):                  FORMAT Radix Control.
                                                              (line  83)
* O (sharpsign reader macro):            Sharpsign.           (line 235)
* oddp:                                  evenp; oddp.         (line   6)
* open <1>:                              Introduction to Streams.
                                                              (line  71)
* open:                                  open.                (line   6)
* open-stream-p:                         open-stream-p.       (line   6)
* optimize:                              optimize.            (line   6)
* or <1>:                                or (Type Specifier). (line   6)
* or <2>:                                or (Macro).          (line   6)
* or:                                    Method Selection and Combination.
                                                              (line 240)
* order of evaluation <1>:               Variable Initialization and Stepping Clauses.
                                                              (line  81)
* order of evaluation <2>:               multiple-value-setq. (line  41)
* order of evaluation <3>:               catch.               (line  29)
* order of evaluation <4>:               ldb.                 (line  39)
* order of evaluation <5>:               Overview of Places and Generalized Reference.
                                                              (line  56)
* order of evaluation <6>:               Defaulting of Initialization Arguments.
                                                              (line  53)
* order of evaluation <7>:               Overview of Places and Generalized Reference.
                                                              (line  97)
* order of evaluation <8>:               assert.              (line  46)
* order of evaluation:                   load-time-value.     (line  42)
* ordinary lambda list:                  Ordinary Lambda Lists.
                                                              (line   6)
* otherwise <1>:                         case; ccase; ecase.  (line  25)
* otherwise:                             typecase; ctypecase; etypecase.
                                                              (line  25)
* output:                                Introduction to Streams.
                                                              (line  33)
* output-stream-p:                       input-stream-p; output-stream-p.
                                                              (line   6)
* P (format directive):                  FORMAT Miscellaneous Operations.
                                                              (line  50)
* P (sharpsign reader macro):            Sharpsign.           (line 388)
* package <1>:                           Introduction to Packages.
                                                              (line   6)
* package:                               package.             (line   6)
* package-error:                         package-error.       (line   6)
* package-error-package:                 package-error-package.
                                                              (line   6)
* package-name:                          package-name.        (line   6)
* package-nicknames:                     package-nicknames.   (line   6)
* package-shadowing-symbols:             package-shadowing-symbols.
                                                              (line   6)
* package-use-list:                      package-use-list.    (line   6)
* package-used-by-list:                  package-used-by-list.
                                                              (line   6)
* packagep:                              packagep.            (line   6)
* pairlis:                               pairlis.             (line   6)
* parse-error:                           parse-error.         (line   6)
* parse-integer:                         parse-integer.       (line   6)
* parse-namestring:                      parse-namestring.    (line   6)
* pathname <1>:                          pathname (Function). (line   6)
* pathname <2>:                          Pathnames as Filenames.
                                                              (line   6)
* pathname <3>:                          Sharpsign.           (line 388)
* pathname:                              pathname (System Class).
                                                              (line   6)
* pathname-device:                       pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                              (line   6)
* pathname-directory:                    pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                              (line   6)
* pathname-host:                         pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                              (line   6)
* pathname-match-p:                      pathname-match-p.    (line   6)
* pathname-name:                         pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                              (line   6)
* pathname-type:                         pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                              (line   6)
* pathname-version:                      pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                              (line   6)
* pathnamep:                             pathnamep.           (line   6)
* peek-char:                             peek-char.           (line   6)
* Percent (format directive):            FORMAT Basic Output. (line  52)
* phase:                                 phase.               (line   6)
* pi:                                    pi.                  (line   6)
* place:                                 Overview of Places and Generalized Reference.
                                                              (line   6)
* Plus (sharpsign reader macro):         Sharpsign.           (line 439)
* plusp:                                 minusp; plusp.       (line   6)
* pop:                                   pop.                 (line   6)
* position:                              position; position-if; position-if-not.
                                                              (line   6)
* position-if:                           position; position-if; position-if-not.
                                                              (line   6)
* position-if-not:                       position; position-if; position-if-not.
                                                              (line   6)
* pprint:                                write; prin1; print; pprint; princ.
                                                              (line   6)
* pprint dispatch table:                 Pretty Printer Concepts.
                                                              (line 130)
* pprint-dispatch:                       pprint-dispatch.     (line   6)
* pprint-exit-if-list-exhausted:         pprint-exit-if-list-exhausted.
                                                              (line   6)
* pprint-fill:                           pprint-fill; pprint-linear; pprint-tabular.
                                                              (line   6)
* pprint-indent:                         pprint-indent.       (line   6)
* pprint-linear:                         pprint-fill; pprint-linear; pprint-tabular.
                                                              (line   6)
* pprint-logical-block:                  pprint-logical-block.
                                                              (line   6)
* pprint-newline:                        pprint-newline.      (line   6)
* pprint-pop:                            pprint-pop.          (line   6)
* pprint-tab:                            pprint-tab.          (line   6)
* pprint-tabular:                        pprint-fill; pprint-linear; pprint-tabular.
                                                              (line   6)
* prepared to signal:                    Error Terminology.   (line  46)
* present <1>:                           Features.            (line  10)
* present:                               Introduction to Packages.
                                                              (line  73)
* pretty printer:                        Pretty Printer Concepts.
                                                              (line   6)
* prin1:                                 write; prin1; print; pprint; princ.
                                                              (line   6)
* prin1-to-string:                       write-to-string; prin1-to-string; princ-to-string.
                                                              (line   6)
* princ:                                 write; prin1; print; pprint; princ.
                                                              (line   6)
* princ-to-string:                       write-to-string; prin1-to-string; princ-to-string.
                                                              (line   6)
* print:                                 write; prin1; print; pprint; princ.
                                                              (line   6)
* print-not-readable:                    print-not-readable.  (line   6)
* print-not-readable-object:             print-not-readable-object.
                                                              (line   6)
* print-object:                          print-object.        (line   6)
* print-unreadable-object:               print-unreadable-object.
                                                              (line   6)
* printer control variable:              Overview of The Lisp Printer.
                                                              (line  41)
* printer escaping <1>:                  Overview of The Lisp Printer.
                                                              (line  76)
* printer escaping:                      P.                   (line 186)
* probe-file:                            probe-file.          (line   6)
* process:                               Compiler Terminology.
                                                              (line  34)
* proclaim:                              proclaim.            (line   6)
* proclamation:                          Declarations.        (line  10)
* prog:                                  prog; prog*.         (line   6)
* prog*:                                 prog; prog*.         (line   6)
* prog1:                                 prog1; prog2.        (line   6)
* prog2:                                 prog1; prog2.        (line   6)
* progn <1>:                             Method Selection and Combination.
                                                              (line 240)
* progn:                                 progn.               (line   6)
* program-error:                         program-error.       (line   6)
* progv:                                 progv.               (line   6)
* proper list <1>:                       list (System Class). (line  18)
* proper list:                           Conses as Lists.     (line  10)
* provide:                               provide; require.    (line   6)
* psetf:                                 setf; psetf.         (line   6)
* psetq:                                 psetq.               (line   6)
* push:                                  push.                (line   6)
* pushnew:                               pushnew.             (line   6)
* Question-Mark (format directive):      FORMAT Control-Flow Operations.
                                                              (line 168)
* quotation (of forms) <1>:              Backquote.           (line   6)
* quotation (of forms) <2>:              Single-Quote.        (line   6)
* quotation (of forms):                  Comma.               (line   6)
* quotation (of strings):                Double-Quote.        (line   6)
* quote <1>:                             Comma.               (line   6)
* quote <2>:                             Backquote.           (line   6)
* quote <3>:                             quote.               (line   6)
* quote:                                 Single-Quote.        (line   6)
* R (format directive):                  FORMAT Radix Control.
                                                              (line   9)
* R (sharpsign reader macro):            Sharpsign.           (line 261)
* random:                                random.              (line   6)
* random-state:                          random-state.        (line   6)
* random-state-p:                        random-state-p.      (line   6)
* rank:                                  Array Elements.      (line  39)
* rassoc:                                rassoc; rassoc-if; rassoc-if-not.
                                                              (line   6)
* rassoc-if:                             rassoc; rassoc-if; rassoc-if-not.
                                                              (line   6)
* rassoc-if-not:                         rassoc; rassoc-if; rassoc-if-not.
                                                              (line   6)
* ratio <1>:                             Default Print-Object Methods.
                                                              (line  29)
* ratio:                                 ratio.               (line   6)
* rational <1>:                          rational (System Class).
                                                              (line   6)
* rational:                              rational; rationalize.
                                                              (line   6)
* rationalize:                           rational; rationalize.
                                                              (line   6)
* rationalp:                             rationalp.           (line   6)
* read:                                  read; read-preserving-whitespace.
                                                              (line   6)
* read-byte:                             read-byte.           (line   6)
* read-char:                             read-char.           (line   6)
* read-char-no-hang:                     read-char-no-hang.   (line   6)
* read-delimited-list:                   read-delimited-list. (line   6)
* read-from-string:                      read-from-string.    (line   6)
* read-line:                             read-line.           (line   6)
* read-preserving-whitespace:            read; read-preserving-whitespace.
                                                              (line   6)
* read-sequence:                         read-sequence.       (line   6)
* reader macro function:                 Character Syntax Types.
                                                              (line 169)
* reader-error:                          reader-error.        (line   6)
* readtable <1>:                         readtable.           (line   6)
* readtable:                             Readtables.          (line   7)
* readtable-case:                        readtable-case.      (line   6)
* readtablep:                            readtablep.          (line   6)
* real:                                  real.                (line   6)
* realp:                                 realp.               (line   6)
* realpart:                              realpart; imagpart.  (line   6)
* redefinition:                          Standardized Packages.
                                                              (line  69)
* reduce:                                reduce.              (line   6)
* reinitialize-instance:                 reinitialize-instance.
                                                              (line   6)
* rem:                                   mod; rem.            (line   6)
* remf:                                  remf.                (line   6)
* remhash:                               remhash.             (line   6)
* remove:                                remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                              (line   6)
* remove-duplicates:                     remove-duplicates; delete-duplicates.
                                                              (line   6)
* remove-if:                             remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                              (line   6)
* remove-if-not:                         remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                              (line   6)
* remove-method:                         remove-method.       (line   6)
* remprop:                               remprop.             (line   6)
* rename-file:                           rename-file.         (line   6)
* rename-package:                        rename-package.      (line   6)
* repertoire:                            Introduction to Scripts and Repertoires.
                                                              (line  30)
* replace:                               replace.             (line   6)
* report message:                        Printing Conditions. (line   9)
* require:                               provide; require.    (line   6)
* rest:                                  rest.                (line   6)
* restart:                               restart.             (line   6)
* restart-bind:                          restart-bind.        (line   6)
* restart-case:                          restart-case.        (line   6)
* restart-name:                          restart-name.        (line   6)
* return:                                return.              (line   6)
* return-from:                           return-from.         (line   6)
* revappend:                             revappend; nreconc.  (line   6)
* reverse:                               reverse; nreverse.   (line   6)
* Right-Brace (format directive):        FORMAT Control-Flow Operations.
                                                              (line 162)
* Right-Bracket (format directive):      FORMAT Control-Flow Operations.
                                                              (line  83)
* Right-Paren (format directive):        FORMAT Miscellaneous Operations.
                                                              (line  44)
* Right-Parenthesis (reader macro):      Right-Parenthesis.   (line   6)
* room:                                  room.                (line   6)
* rotatef:                               rotatef.             (line   6)
* round:                                 floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* row-major-aref:                        row-major-aref.      (line   6)
* rplaca:                                rplaca; rplacd.      (line   6)
* rplacd:                                rplaca; rplacd.      (line   6)
* run time:                              Compiler Terminology.
                                                              (line  84)
* run-time compiler:                     Compiler Terminology.
                                                              (line  91)
* run-time definition:                   Compiler Terminology.
                                                              (line  88)
* run-time environment:                  Compiler Terminology.
                                                              (line  65)
* S (format directive):                  FORMAT Printer Operations.
                                                              (line  33)
* S (sharpsign reader macro):            Sharpsign.           (line 361)
* safe:                                  Error Terminology.   (line  12)
* safe call:                             Argument Mismatch Detection.
                                                              (line   9)
* safety <1>:                            Minimal Declaration Processing Requirements.
                                                              (line   7)
* safety:                                optimize.            (line   9)
* satisfies:                             satisfies.           (line   6)
* satisfy the test <1>:                  Satisfying a One-Argument Test.
                                                              (line  31)
* satisfy the test <2>:                  Satisfying a Two-Argument Test.
                                                              (line  42)
* satisfy the test:                      Satisfying a One-Argument Test.
                                                              (line  36)
* sbit:                                  bit; sbit.           (line   6)
* scale-float:                           decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                              (line   6)
* schar:                                 char; schar.         (line   6)
* search:                                search.              (line   6)
* second:                                first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* sections:                              Pretty Printer Concepts.
                                                              (line  36)
* Semicolon (format directive):          FORMAT Miscellaneous Pseudo-Operations.
                                                              (line   9)
* Semicolon (reader macro):              Semicolon.           (line   6)
* sequence <1>:                          sequence.            (line   6)
* sequence:                              Sequence Concepts.   (line   6)
* sequence function:                     Sequence Concepts.   (line  13)
* serious-condition:                     serious-condition.   (line   6)
* set:                                   set.                 (line   6)
* set-char-bit:                          Removed Operators.   (line   7)
* set-difference:                        set-difference; nset-difference.
                                                              (line   6)
* set-dispatch-macro-character:          set-dispatch-macro-character; get-dispatch-macro-character.
                                                              (line   6)
* set-exclusive-or:                      set-exclusive-or; nset-exclusive-or.
                                                              (line   6)
* set-macro-character:                   set-macro-character; get-macro-character.
                                                              (line   6)
* set-pprint-dispatch:                   set-pprint-dispatch. (line   6)
* set-syntax-from-char:                  set-syntax-from-char.
                                                              (line   6)
* setf:                                  setf; psetf.         (line   6)
* setq:                                  setq.                (line   6)
* seventh:                               first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* shadow <1>:                            shadow.              (line   6)
* shadow <2>:                            Introduction to Classes.
                                                              (line  39)
* shadow:                                Shadowing.           (line   8)
* shadowing symbol:                      Introduction to Packages.
                                                              (line 188)
* shadowing-import:                      shadowing-import.    (line   6)
* shared-initialize:                     shared-initialize (Standard Generic Function).
                                                              (line   6)
* Sharpsign (reader macro):              Sharpsign.           (line   6)
* Sharpsign (sharpsign reader macro):    Sharpsign.           (line 411)
* Sharpsign A (reader macro):            Sharpsign.           (line 323)
* Sharpsign Asterisk (reader macro):     Sharpsign.           (line 151)
* Sharpsign B (reader macro):            Sharpsign.           (line 224)
* Sharpsign Backslash (reader macro):    Sharpsign.           (line  78)
* Sharpsign C (reader macro):            Sharpsign.           (line 296)
* Sharpsign Colon (reader macro):        Sharpsign.           (line 196)
* Sharpsign Dot (reader macro):          Sharpsign.           (line 209)
* Sharpsign Equal-Sign (reader macro):   Sharpsign.           (line 399)
* Sharpsign Left-Parenthesis (reader macro): Sharpsign.       (line 114)
* Sharpsign Less-Than-Sign (reader macro): Sharpsign.         (line 559)
* Sharpsign Minus (reader macro):        Sharpsign.           (line 462)
* Sharpsign O (reader macro):            Sharpsign.           (line 235)
* Sharpsign P (reader macro):            Sharpsign.           (line 388)
* Sharpsign Plus (reader macro):         Sharpsign.           (line 439)
* Sharpsign R (reader macro):            Sharpsign.           (line 261)
* Sharpsign Right-Parenthesis <1>:       Sharpsign.           (line 574)
* Sharpsign Right-Parenthesis:           Re-Reading Abbreviated Expressions.
                                                              (line   6)
* Sharpsign S (reader macro):            Sharpsign.           (line 361)
* Sharpsign Sharpsign (reader macro) <1>: pprint-pop.         (line  39)
* Sharpsign Sharpsign (reader macro):    Sharpsign.           (line 411)
* Sharpsign Single-Quote (reader macro): Sharpsign.           (line 104)
* Sharpsign Vertical-Bar (reader macro): Sharpsign.           (line 473)
* Sharpsign Whitespace <1>:              Sharpsign.           (line 567)
* Sharpsign Whitespace:                  Re-Reading Abbreviated Expressions.
                                                              (line   6)
* Sharpsign X (reader macro):            Sharpsign.           (line 247)
* shiftf:                                shiftf.              (line   6)
* short-float:                           short-float; single-float; double-float; long-float.
                                                              (line   6)
* short-float-epsilon:                   short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* short-float-negative-epsilon:          short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* short-site-name:                       short-site-name; long-site-name.
                                                              (line   6)
* should signal:                         Error Terminology.   (line  37)
* signal <1>:                            Error Terminology.   (line  27)
* signal <2>:                            signal.              (line   6)
* signal:                                Error Terminology.   (line 106)
* signed-byte:                           signed-byte.         (line   6)
* signum:                                signum.              (line   6)
* similar:                               Literal Objects in Compiled Files.
                                                              (line  37)
* simple-array:                          simple-array.        (line   6)
* simple-base-string:                    simple-base-string.  (line   6)
* simple-bit-vector <1>:                 Sharpsign.           (line 151)
* simple-bit-vector:                     simple-bit-vector.   (line   6)
* simple-bit-vector-p:                   simple-bit-vector-p. (line   6)
* simple-condition:                      simple-condition.    (line   6)
* simple-condition-format-arguments:     simple-condition-format-control; simple-condition-format-arguments.
                                                              (line   6)
* simple-condition-format-control:       simple-condition-format-control; simple-condition-format-arguments.
                                                              (line   6)
* simple-error:                          simple-error.        (line   6)
* simple-string:                         simple-string.       (line   6)
* simple-string-p:                       simple-string-p.     (line   6)
* simple-type-error:                     simple-type-error.   (line   6)
* simple-vector <1>:                     simple-vector.       (line   6)
* simple-vector:                         Sharpsign.           (line 114)
* simple-vector-p:                       simple-vector-p.     (line   6)
* simple-warning:                        simple-warning.      (line   6)
* sin:                                   sin; cos; tan.       (line   6)
* single escape:                         Character Syntax Types.
                                                              (line 238)
* single-float:                          short-float; single-float; double-float; long-float.
                                                              (line   6)
* single-float-epsilon:                  short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* single-float-negative-epsilon:         short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                              (line   6)
* Single-Quote (reader macro):           Single-Quote.        (line   6)
* Single-Quote (sharpsign reader macro): Sharpsign.           (line 104)
* sinh:                                  sinh; cosh; tanh; asinh; acosh; atanh.
                                                              (line   6)
* sixth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* Slash (format directive):              FORMAT Pretty Printer Operations.
                                                              (line  95)
* sleep:                                 sleep.               (line   6)
* slot specifier:                        Defining Classes.    (line  15)
* slot-boundp:                           slot-boundp.         (line   6)
* slot-exists-p:                         slot-exists-p.       (line   6)
* slot-makunbound:                       slot-makunbound.     (line   6)
* slot-missing:                          slot-missing.        (line   6)
* slot-unbound:                          slot-unbound.        (line   6)
* slot-value:                            slot-value.          (line   6)
* software-type:                         software-type; software-version.
                                                              (line   6)
* software-version:                      software-type; software-version.
                                                              (line   6)
* some:                                  every; some; notevery; notany.
                                                              (line   6)
* sort:                                  sort; stable-sort.   (line   6)
* source code:                           Loading.             (line   7)
* source file:                           Loading.             (line   9)
* space:                                 optimize.            (line   9)
* special <1>:                           special.             (line   6)
* special:                               Minimal Declaration Processing Requirements.
                                                              (line   7)
* special-operator-p:                    special-operator-p.  (line   6)
* specialized lambda list:               Specialized Lambda Lists.
                                                              (line   6)
* speed:                                 optimize.            (line   9)
* sqrt:                                  sqrt; isqrt.         (line   6)
* stable-sort:                           sort; stable-sort.   (line   6)
* standard:                              Method Selection and Combination.
                                                              (line 240)
* standard character:                    Standard Characters. (line   8)
* standard readtable:                    Readtables.          (line  34)
* standard syntax:                       Character Syntax.    (line  10)
* standard-char:                         standard-char.       (line   6)
* standard-char-p:                       standard-char-p.     (line   6)
* standard-class:                        standard-class.      (line   6)
* standard-generic-function:             standard-generic-function.
                                                              (line   6)
* standard-method:                       standard-method.     (line   6)
* standard-object:                       standard-object.     (line   6)
* startup environment:                   Compiler Terminology.
                                                              (line  48)
* step:                                  step.                (line   6)
* storage-condition:                     storage-condition.   (line   6)
* store-value <1>:                       abort; continue; muffle-warning; store-value; use-value.
                                                              (line   6)
* store-value <2>:                       store-value (Restart).
                                                              (line   6)
* store-value:                           abort; continue; muffle-warning; store-value; use-value.
                                                              (line   6)
* stream <1>:                            stream.              (line   6)
* stream <2>:                            Introduction to Streams.
                                                              (line  33)
* stream <3>:                            File System Concepts.
                                                              (line   9)
* stream:                                Introduction to Streams.
                                                              (line  32)
* stream associated with a file:         Coercion of Streams to Pathnames.
                                                              (line   7)
* stream variable:                       Stream Variables.    (line   6)
* stream-element-type:                   stream-element-type. (line   6)
* stream-error:                          stream-error.        (line   6)
* stream-error-stream:                   stream-error-stream. (line   6)
* stream-external-format:                stream-external-format.
                                                              (line   6)
* streamp:                               streamp.             (line   6)
* string <1>:                            Double-Quote.        (line   6)
* string <2>:                            Specialized Arrays.  (line  58)
* string <3>:                            string (System Class).
                                                              (line   6)
* string:                                string (Function).   (line   6)
* string-capitalize:                     string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                              (line   6)
* string-char:                           Removed Types.       (line   6)
* string-char-p:                         Removed Operators.   (line   7)
* string-downcase:                       string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                              (line   6)
* string-equal:                          string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string-greaterp:                       string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string-left-trim:                      string-trim; string-left-trim; string-right-trim.
                                                              (line   6)
* string-lessp:                          string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string-not-equal:                      string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string-not-greaterp:                   string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string-not-lessp:                      string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string-right-trim:                     string-trim; string-left-trim; string-right-trim.
                                                              (line   6)
* string-stream:                         string-stream.       (line   6)
* string-trim:                           string-trim; string-left-trim; string-right-trim.
                                                              (line   6)
* string-upcase:                         string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                              (line   6)
* string/=:                              string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string<:                               string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string<=:                              string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string=:                               string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string>:                               string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* string>=:                              string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                              (line   6)
* stringp:                               stringp.             (line   6)
* structure:                             Sharpsign.           (line 361)
* structure-class:                       structure-class.     (line   6)
* structure-object:                      structure-object.    (line   6)
* style-warning:                         style-warning.       (line   6)
* subclass:                              Introduction to Classes.
                                                              (line  29)
* sublis:                                sublis; nsublis.     (line   6)
* subseq:                                subseq.              (line   6)
* subsetp:                               subsetp.             (line   6)
* subst:                                 subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                              (line   6)
* subst-if:                              subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                              (line   6)
* subst-if-not:                          subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                              (line   6)
* substitute:                            substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                              (line   6)
* substitute-if:                         substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                              (line   6)
* substitute-if-not:                     substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                              (line   6)
* subtypep:                              subtypep.            (line   6)
* superclass:                            Introduction to Classes.
                                                              (line  27)
* svref:                                 svref.               (line   6)
* sxhash:                                sxhash.              (line   6)
* symbol <1>:                            Sharpsign.           (line 196)
* symbol:                                symbol.              (line   6)
* symbol macro:                          Compilation Semantics.
                                                              (line 153)
* symbol-function:                       symbol-function.     (line   6)
* symbol-macrolet <1>:                   symbol-macrolet.     (line   6)
* symbol-macrolet:                       Compilation Semantics.
                                                              (line 156)
* symbol-name:                           symbol-name.         (line   6)
* symbol-package:                        symbol-package.      (line   6)
* symbol-plist:                          symbol-plist.        (line   6)
* symbol-value:                          symbol-value.        (line   6)
* symbolp:                               symbolp.             (line   6)
* synonym-stream:                        synonym-stream.      (line   6)
* synonym-stream-symbol:                 synonym-stream-symbol.
                                                              (line   6)
* syntax type:                           Character Syntax Types.
                                                              (line  14)
* SYSTEM:                                Packages No Longer Required.
                                                              (line   6)
* t <1>:                                 typecase; ctypecase; etypecase.
                                                              (line  25)
* t <2>:                                 t (System Class).    (line   6)
* t <3>:                                 t (Constant Variable).
                                                              (line   6)
* t:                                     case; ccase; ecase.  (line  25)
* T (format directive):                  FORMAT Layout Control.
                                                              (line   9)
* tagbody:                               tagbody.             (line   6)
* tailp:                                 ldiff; tailp.        (line   6)
* tan:                                   sin; cos; tan.       (line   6)
* tanh:                                  sinh; cosh; tanh; asinh; acosh; atanh.
                                                              (line   6)
* tenth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* terminating:                           Character Syntax Types.
                                                              (line 190)
* terpri:                                terpri; fresh-line.  (line   6)
* the:                                   the.                 (line   6)
* third:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                              (line   6)
* throw:                                 throw.               (line   6)
* Tilde (format directive):              FORMAT Basic Output. (line  72)
* Tilde A (format directive):            FORMAT Printer Operations.
                                                              (line   9)
* Tilde Ampersand (format directive):    FORMAT Basic Output. (line  59)
* Tilde Asterisk (format directive):     FORMAT Control-Flow Operations.
                                                              (line   9)
* Tilde B (format directive):            FORMAT Radix Control.
                                                              (line  73)
* Tilde C (format directive):            FORMAT Basic Output. (line   9)
* Tilde Circumflex (format directive):   FORMAT Miscellaneous Pseudo-Operations.
                                                              (line  15)
* Tilde D (format directive):            FORMAT Radix Control.
                                                              (line  44)
* Tilde Dollarsign (format directive):   FORMAT Floating-Point Printers.
                                                              (line 204)
* Tilde E (format directive):            FORMAT Floating-Point Printers.
                                                              (line  85)
* Tilde F (format directive):            FORMAT Floating-Point Printers.
                                                              (line   9)
* Tilde G (format directive):            FORMAT Floating-Point Printers.
                                                              (line 175)
* Tilde Greater-Than-Sign (format directive): FORMAT Layout Control.
                                                              (line 115)
* Tilde I (format directive):            FORMAT Pretty Printer Operations.
                                                              (line  87)
* Tilde Left-Brace (format directive):   FORMAT Control-Flow Operations.
                                                              (line  89)
* Tilde Left-Bracket (format directive): FORMAT Control-Flow Operations.
                                                              (line  27)
* Tilde Left-Paren (format directive):   FORMAT Miscellaneous Operations.
                                                              (line   9)
* Tilde Less-Than-Sign (format directive) <1>: FORMAT Pretty Printer Operations.
                                                              (line  19)
* Tilde Less-Than-Sign (format directive): FORMAT Layout Control.
                                                              (line  47)
* Tilde Newline (format directive):      FORMAT Miscellaneous Pseudo-Operations.
                                                              (line  82)
* Tilde O (format directive):            FORMAT Radix Control.
                                                              (line  83)
* Tilde P (format directive):            FORMAT Miscellaneous Operations.
                                                              (line  50)
* Tilde Percent (format directive):      FORMAT Basic Output. (line  52)
* Tilde Question-Mark (format directive): FORMAT Control-Flow Operations.
                                                              (line 168)
* Tilde R (format directive):            FORMAT Radix Control.
                                                              (line   9)
* Tilde Right-Brace (format directive):  FORMAT Control-Flow Operations.
                                                              (line 162)
* Tilde Right-Bracket (format directive): FORMAT Control-Flow Operations.
                                                              (line  83)
* Tilde Right-Paren (format directive):  FORMAT Miscellaneous Operations.
                                                              (line  44)
* Tilde S (format directive):            FORMAT Printer Operations.
                                                              (line  33)
* Tilde Semicolon (format directive):    FORMAT Miscellaneous Pseudo-Operations.
                                                              (line   9)
* Tilde Slash (format directive):        FORMAT Pretty Printer Operations.
                                                              (line  95)
* Tilde T (format directive):            FORMAT Layout Control.
                                                              (line   9)
* Tilde Tilde (format directive):        FORMAT Basic Output. (line  72)
* Tilde Underscore (format directive):   FORMAT Pretty Printer Operations.
                                                              (line  11)
* Tilde Vertical-Bar (format directive): FORMAT Basic Output. (line  66)
* Tilde W (format directive):            FORMAT Printer Operations.
                                                              (line  43)
* Tilde X (format directive):            FORMAT Radix Control.
                                                              (line  93)
* time:                                  time (Macro).        (line   6)
* token:                                 Character Syntax Types.
                                                              (line  77)
* trace:                                 trace; untrace.      (line   6)
* translate-logical-pathname:            translate-logical-pathname.
                                                              (line   6)
* translate-pathname:                    translate-pathname.  (line   6)
* tree:                                  Conses as Trees.     (line   6)
* tree-equal:                            tree-equal.          (line   6)
* truename <1>:                          Truenames.           (line  12)
* truename:                              truename.            (line   6)
* truncate:                              floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                              (line   6)
* two-way-stream:                        two-way-stream.      (line   6)
* two-way-stream-input-stream:           two-way-stream-input-stream; two-way-stream-output-stream.
                                                              (line   6)
* two-way-stream-output-stream:          two-way-stream-input-stream; two-way-stream-output-stream.
                                                              (line   6)
* type:                                  type.                (line   6)
* type-error:                            type-error.          (line   6)
* type-error-datum:                      type-error-datum; type-error-expected-type.
                                                              (line   6)
* type-error-expected-type:              type-error-datum; type-error-expected-type.
                                                              (line   6)
* type-of:                               type-of.             (line   6)
* typecase:                              typecase; ctypecase; etypecase.
                                                              (line   6)
* typep:                                 typep.               (line   6)
* unbound-slot:                          unbound-slot.        (line   6)
* unbound-slot-instance:                 unbound-slot-instance.
                                                              (line   6)
* unbound-variable:                      unbound-variable.    (line   6)
* undefined consequences:                Error Terminology.   (line  92)
* undefined-function:                    undefined-function.  (line   6)
* Underscore (format directive):         FORMAT Pretty Printer Operations.
                                                              (line  11)
* unexport:                              unexport.            (line   6)
* unintern:                              unintern.            (line   6)
* union:                                 union; nunion.       (line   6)
* universal time:                        Time.                (line  79)
* unless:                                when; unless.        (line   6)
* unread-char:                           unread-char.         (line   6)
* unsafe:                                Error Terminology.   (line  21)
* unsafe call:                           Argument Mismatch Detection.
                                                              (line  67)
* unsigned-byte:                         unsigned-byte.       (line   6)
* unspecified consequences:              Error Terminology.   (line  82)
* unspecified values:                    Error Terminology.   (line 111)
* untrace:                               trace; untrace.      (line   6)
* unuse-package:                         unuse-package.       (line   6)
* unwind-protect:                        unwind-protect.      (line   6)
* update-instance-for-different-class:   update-instance-for-different-class.
                                                              (line   6)
* update-instance-for-redefined-class:   update-instance-for-redefined-class.
                                                              (line   6)
* upgraded array element type:           Specialized Arrays.  (line  32)
* upgraded-array-element-type:           upgraded-array-element-type.
                                                              (line   6)
* upgraded-complex-part-type:            upgraded-complex-part-type.
                                                              (line   6)
* upper-case-p:                          upper-case-p; lower-case-p; both-case-p.
                                                              (line   6)
* use-package:                           use-package.         (line   6)
* use-value <1>:                         use-value (Restart). (line   6)
* use-value:                             abort; continue; muffle-warning; store-value; use-value.
                                                              (line   6)
* USER:                                  Packages No Longer Required.
                                                              (line   6)
* user-homedir-pathname:                 user-homedir-pathname.
                                                              (line   6)
* values <1>:                            values (Type Specifier).
                                                              (line   6)
* values:                                values (Accessor).   (line   6)
* values-list:                           values-list.         (line   6)
* vector <1>:                            vector (Function).   (line   6)
* vector <2>:                            Sharpsign.           (line 114)
* vector <3>:                            Array Elements.      (line  48)
* vector:                                vector (System Class).
                                                              (line   6)
* vector-pop:                            vector-pop.          (line   6)
* vector-push:                           vector-push; vector-push-extend.
                                                              (line   6)
* vector-push-extend:                    vector-push; vector-push-extend.
                                                              (line   6)
* vectorp:                               vectorp.             (line   6)
* Vertical-Bar (format directive):       FORMAT Basic Output. (line  66)
* Vertical-Bar (sharpsign reader macro): Sharpsign.           (line 473)
* W (format directive):                  FORMAT Printer Operations.
                                                              (line  43)
* warn:                                  warn.                (line   6)
* warning <1>:                           Error Terminology.   (line 150)
* warning:                               warning.             (line   6)
* when:                                  when; unless.        (line   6)
* wild-pathname-p:                       wild-pathname-p.     (line   6)
* with-accessors:                        with-accessors.      (line   6)
* with-compilation-unit:                 with-compilation-unit.
                                                              (line   6)
* with-condition-restarts:               with-condition-restarts.
                                                              (line   6)
* with-hash-table-iterator:              with-hash-table-iterator.
                                                              (line   6)
* with-input-from-string:                with-input-from-string.
                                                              (line   6)
* with-open-file:                        with-open-file.      (line   6)
* with-open-stream:                      with-open-stream.    (line   6)
* with-output-to-string:                 with-output-to-string.
                                                              (line   6)
* with-package-iterator:                 with-package-iterator.
                                                              (line   6)
* with-simple-restart:                   with-simple-restart. (line   6)
* with-slots:                            with-slots.          (line   6)
* with-standard-io-syntax:               with-standard-io-syntax.
                                                              (line   6)
* write:                                 write; prin1; print; pprint; princ.
                                                              (line   6)
* write-byte:                            write-byte.          (line   6)
* write-char:                            write-char.          (line   6)
* write-line:                            write-string; write-line.
                                                              (line   6)
* write-sequence:                        write-sequence.      (line   6)
* write-string:                          write-string; write-line.
                                                              (line   6)
* write-to-string:                       write-to-string; prin1-to-string; princ-to-string.
                                                              (line   6)
* X (format directive):                  FORMAT Radix Control.
                                                              (line  93)
* X (sharpsign reader macro):            Sharpsign.           (line 247)
* y-or-n-p:                              y-or-n-p; yes-or-no-p.
                                                              (line   6)
* yes-or-no-p:                           y-or-n-p; yes-or-no-p.
                                                              (line   6)
* zerop:                                 zerop.               (line   6)


File: chris-ansicl.info,  Node: Symbol Index,  Next: List of Figures,  Prev: Index,  Up: Top

Symbol Index
************

 [index ]
* Menu:

* (setf class-name):                     setf class-name.       (line 6)
* (setf documentation):                  documentation; setf documentation.
                                                                (line 6)
* * <1>:                                 *; **; ***.            (line 6)
* *:                                     * (Function).          (line 6)
* **:                                    *; **; ***.            (line 6)
* ***:                                   *; **; ***.            (line 6)
* *break-on-signals*:                    *break-on-signals*.    (line 6)
* *compile-file-pathname*:               *compile-file-pathname*; *compile-file-truename*.
                                                                (line 6)
* *compile-file-truename*:               *compile-file-pathname*; *compile-file-truename*.
                                                                (line 6)
* *compile-print*:                       *compile-print*; *compile-verbose*.
                                                                (line 6)
* *compile-verbose*:                     *compile-print*; *compile-verbose*.
                                                                (line 6)
* *debug-io*:                            *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                                (line 6)
* *debugger-hook*:                       *debugger-hook*.       (line 6)
* *default-pathname-defaults*:           *default-pathname-defaults*.
                                                                (line 6)
* *error-output*:                        *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                                (line 6)
* *features*:                            *features*.            (line 6)
* *gensym-counter*:                      *gensym-counter*.      (line 6)
* *load-pathname*:                       *load-pathname*; *load-truename*.
                                                                (line 6)
* *load-print*:                          *load-print*; *load-verbose*.
                                                                (line 6)
* *load-truename*:                       *load-pathname*; *load-truename*.
                                                                (line 6)
* *load-verbose*:                        *load-print*; *load-verbose*.
                                                                (line 6)
* *macroexpand-hook*:                    *macroexpand-hook*.    (line 6)
* *modules*:                             *modules*.             (line 6)
* *package*:                             *package*.             (line 6)
* *print-array*:                         *print-array*.         (line 6)
* *print-base*:                          *print-base*; *print-radix*.
                                                                (line 6)
* *print-case*:                          *print-case*.          (line 6)
* *print-circle*:                        *print-circle*.        (line 6)
* *print-escape*:                        *print-escape*.        (line 6)
* *print-gensym*:                        *print-gensym*.        (line 6)
* *print-length*:                        *print-level*; *print-length*.
                                                                (line 6)
* *print-level*:                         *print-level*; *print-length*.
                                                                (line 6)
* *print-lines*:                         *print-lines*.         (line 6)
* *print-miser-width*:                   *print-miser-width*.   (line 6)
* *print-pprint-dispatch*:               *print-pprint-dispatch*.
                                                                (line 6)
* *print-pretty*:                        *print-pretty*.        (line 6)
* *print-radix*:                         *print-base*; *print-radix*.
                                                                (line 6)
* *print-readably*:                      *print-readably*.      (line 6)
* *print-right-margin*:                  *print-right-margin*.  (line 6)
* *query-io*:                            *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                                (line 6)
* *random-state*:                        *random-state*.        (line 6)
* *read-base*:                           *read-base*.           (line 6)
* *read-default-float-format*:           *read-default-float-format*.
                                                                (line 6)
* *read-eval*:                           *read-eval*.           (line 6)
* *read-suppress*:                       *read-suppress*.       (line 6)
* *readtable*:                           *readtable*.           (line 6)
* *standard-input*:                      *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                                (line 6)
* *standard-output*:                     *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                                (line 6)
* *terminal-io*:                         *terminal-io*.         (line 6)
* *trace-output*:                        *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+.
                                                                (line 6)
* + <1>:                                 +; ++; +++.            (line 6)
* +:                                     + (Function).          (line 6)
* ++:                                    +; ++; +++.            (line 6)
* +++:                                   +; ++; +++.            (line 6)
* - <1>:                                 - (Function).          (line 6)
* -:                                     - (Variable).          (line 6)
* / <1>:                                 /; //; ///.            (line 6)
* /:                                     / (Function).          (line 6)
* //:                                    /; //; ///.            (line 6)
* ///:                                   /; //; ///.            (line 6)
* /=:                                    =; /=; <; >; <=; >=.   (line 6)
* 1+:                                    1+; 1-.                (line 6)
* 1-:                                    1+; 1-.                (line 6)
* <:                                     =; /=; <; >; <=; >=.   (line 6)
* <=:                                    =; /=; <; >; <=; >=.   (line 6)
* =:                                     =; /=; <; >; <=; >=.   (line 6)
* >:                                     =; /=; <; >; <=; >=.   (line 6)
* >=:                                    =; /=; <; >; <=; >=.   (line 6)
* abort <1>:                             abort; continue; muffle-warning; store-value; use-value.
                                                                (line 6)
* abort:                                 abort (Restart).       (line 6)
* abs:                                   abs.                   (line 6)
* acons:                                 acons.                 (line 6)
* acos:                                  asin; acos; atan.      (line 6)
* acosh:                                 sinh; cosh; tanh; asinh; acosh; atanh.
                                                                (line 6)
* add-method:                            add-method.            (line 6)
* adjoin:                                adjoin.                (line 6)
* adjust-array:                          adjust-array.          (line 6)
* adjustable-array-p:                    adjustable-array-p.    (line 6)
* allocate-instance:                     allocate-instance.     (line 6)
* alpha-char-p:                          alpha-char-p.          (line 6)
* alphanumericp:                         alphanumericp.         (line 6)
* and <1>:                               and (Type Specifier).  (line 6)
* and:                                   and (Macro).           (line 6)
* append:                                append.                (line 6)
* apply:                                 apply.                 (line 6)
* apropos:                               apropos; apropos-list. (line 6)
* apropos-list:                          apropos; apropos-list. (line 6)
* aref:                                  aref.                  (line 6)
* arithmetic-error:                      arithmetic-error.      (line 6)
* arithmetic-error-operands:             arithmetic-error-operands; arithmetic-error-operation.
                                                                (line 6)
* arithmetic-error-operation:            arithmetic-error-operands; arithmetic-error-operation.
                                                                (line 6)
* array:                                 array.                 (line 6)
* array-dimension:                       array-dimension.       (line 6)
* array-dimension-limit:                 array-dimension-limit. (line 6)
* array-dimensions:                      array-dimensions.      (line 6)
* array-displacement:                    array-displacement.    (line 6)
* array-element-type:                    array-element-type.    (line 6)
* array-has-fill-pointer-p:              array-has-fill-pointer-p.
                                                                (line 6)
* array-in-bounds-p:                     array-in-bounds-p.     (line 6)
* array-rank:                            array-rank.            (line 6)
* array-rank-limit:                      array-rank-limit.      (line 6)
* array-row-major-index:                 array-row-major-index. (line 6)
* array-total-size:                      array-total-size.      (line 6)
* array-total-size-limit:                array-total-size-limit.
                                                                (line 6)
* arrayp:                                arrayp.                (line 6)
* ash:                                   ash.                   (line 6)
* asin:                                  asin; acos; atan.      (line 6)
* asinh:                                 sinh; cosh; tanh; asinh; acosh; atanh.
                                                                (line 6)
* assert:                                assert.                (line 6)
* assoc:                                 assoc; assoc-if; assoc-if-not.
                                                                (line 6)
* assoc-if:                              assoc; assoc-if; assoc-if-not.
                                                                (line 6)
* assoc-if-not:                          assoc; assoc-if; assoc-if-not.
                                                                (line 6)
* atan:                                  asin; acos; atan.      (line 6)
* atanh:                                 sinh; cosh; tanh; asinh; acosh; atanh.
                                                                (line 6)
* atom <1>:                              atom (Type).           (line 6)
* atom:                                  atom (Function).       (line 6)
* base-char:                             base-char.             (line 6)
* base-string:                           base-string.           (line 6)
* bignum:                                bignum.                (line 6)
* bit <1>:                               bit (Type).            (line 6)
* bit:                                   bit; sbit.             (line 6)
* bit-and:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-andc1:                             bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-andc2:                             bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-eqv:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-ior:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-nand:                              bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-nor:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-not:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-orc1:                              bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-orc2:                              bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* bit-vector:                            bit-vector.            (line 6)
* bit-vector-p:                          bit-vector-p.          (line 6)
* bit-xor:                               bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+.
                                                                (line 6)
* block:                                 block.                 (line 6)
* boole:                                 boole.                 (line 6)
* boole-1:                               boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-2:                               boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-and:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-andc1:                           boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-andc2:                           boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-c1:                              boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-c2:                              boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-clr:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-eqv:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-ior:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-nand:                            boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-nor:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-orc1:                            boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-orc2:                            boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-set:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boole-xor:                             boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+.
                                                                (line 6)
* boolean:                               boolean.               (line 6)
* both-case-p:                           upper-case-p; lower-case-p; both-case-p.
                                                                (line 6)
* boundp:                                boundp.                (line 6)
* break:                                 break.                 (line 6)
* broadcast-stream:                      broadcast-stream.      (line 6)
* broadcast-stream-streams:              broadcast-stream-streams.
                                                                (line 6)
* built-in-class:                        built-in-class.        (line 6)
* butlast:                               butlast; nbutlast.     (line 6)
* byte:                                  byte; byte-size; byte-position.
                                                                (line 6)
* byte-position:                         byte; byte-size; byte-position.
                                                                (line 6)
* byte-size:                             byte; byte-size; byte-position.
                                                                (line 6)
* caaaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caaadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caaar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caadar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caaddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caadr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caar:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cadaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cadadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cadar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caddar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cadddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* caddr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cadr:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* call-arguments-limit:                  call-arguments-limit.  (line 6)
* call-method:                           call-method; make-method.
                                                                (line 6)
* call-next-method:                      call-next-method.      (line 6)
* car:                                   car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* case:                                  case; ccase; ecase.    (line 6)
* catch:                                 catch.                 (line 6)
* ccase:                                 case; ccase; ecase.    (line 6)
* cdaaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdaadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdaar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdadar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdaddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdadr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdar:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cddaar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cddadr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cddar:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdddar:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cddddr:                                car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdddr:                                 car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cddr:                                  car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* cdr:                                   car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+.
                                                                (line 6)
* ceiling:                               floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* cell-error:                            cell-error.            (line 6)
* cell-error-name:                       cell-error-name.       (line 6)
* cerror:                                cerror.                (line 6)
* change-class:                          change-class.          (line 6)
* char:                                  char; schar.           (line 6)
* char-code:                             char-code.             (line 6)
* char-code-limit:                       char-code-limit.       (line 6)
* char-downcase:                         char-upcase; char-downcase.
                                                                (line 6)
* char-equal:                            char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char-greaterp:                         char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char-int:                              char-int.              (line 6)
* char-lessp:                            char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char-name:                             char-name.             (line 6)
* char-not-equal:                        char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char-not-greaterp:                     char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char-not-lessp:                        char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char-upcase:                           char-upcase; char-downcase.
                                                                (line 6)
* char/=:                                char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char<:                                 char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char<=:                                char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char=:                                 char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char>:                                 char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* char>=:                                char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+.
                                                                (line 6)
* character <1>:                         character (Function).  (line 6)
* character:                             character (System Class).
                                                                (line 6)
* characterp:                            characterp.            (line 6)
* check-type:                            check-type.            (line 6)
* cis:                                   cis.                   (line 6)
* class:                                 class.                 (line 6)
* class-name:                            class-name.            (line 6)
* class-of:                              class-of.              (line 6)
* clear-input:                           clear-input.           (line 6)
* clear-output:                          finish-output; force-output; clear-output.
                                                                (line 6)
* close:                                 close.                 (line 6)
* clrhash:                               clrhash.               (line 6)
* code-char:                             code-char.             (line 6)
* coerce:                                coerce.                (line 6)
* compile:                               compile.               (line 6)
* compile-file:                          compile-file.          (line 6)
* compile-file-pathname:                 compile-file-pathname. (line 6)
* compiled-function:                     compiled-function.     (line 6)
* compiled-function-p:                   compiled-function-p.   (line 6)
* compiler-macro-function:               compiler-macro-function.
                                                                (line 6)
* complement:                            complement.            (line 6)
* complex <1>:                           complex (Function).    (line 6)
* complex:                               complex (System Class).
                                                                (line 6)
* complexp:                              complexp.              (line 6)
* compute-applicable-methods:            compute-applicable-methods.
                                                                (line 6)
* compute-restarts:                      compute-restarts.      (line 6)
* concatenate:                           concatenate.           (line 6)
* concatenated-stream:                   concatenated-stream.   (line 6)
* concatenated-stream-streams:           concatenated-stream-streams.
                                                                (line 6)
* cond:                                  cond.                  (line 6)
* condition:                             condition.             (line 6)
* conjugate:                             conjugate.             (line 6)
* cons <1>:                              cons (Function).       (line 6)
* cons:                                  cons (System Class).   (line 6)
* consp:                                 consp.                 (line 6)
* constantly:                            constantly.            (line 6)
* constantp:                             constantp.             (line 6)
* continue <1>:                          abort; continue; muffle-warning; store-value; use-value.
                                                                (line 6)
* continue:                              continue (Restart).    (line 6)
* control-error:                         control-error.         (line 6)
* copy-alist:                            copy-alist.            (line 6)
* copy-list:                             copy-list.             (line 6)
* copy-pprint-dispatch:                  copy-pprint-dispatch.  (line 6)
* copy-readtable:                        copy-readtable.        (line 6)
* copy-seq:                              copy-seq.              (line 6)
* copy-structure:                        copy-structure.        (line 6)
* copy-symbol:                           copy-symbol.           (line 6)
* copy-tree:                             copy-tree.             (line 6)
* cos:                                   sin; cos; tan.         (line 6)
* cosh:                                  sinh; cosh; tanh; asinh; acosh; atanh.
                                                                (line 6)
* count:                                 count; count-if; count-if-not.
                                                                (line 6)
* count-if:                              count; count-if; count-if-not.
                                                                (line 6)
* count-if-not:                          count; count-if; count-if-not.
                                                                (line 6)
* ctypecase:                             typecase; ctypecase; etypecase.
                                                                (line 6)
* decf:                                  incf; decf.            (line 6)
* declaim:                               declaim.               (line 6)
* declaration:                           declaration.           (line 6)
* declare:                               declare.               (line 6)
* decode-float:                          decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                                (line 6)
* decode-universal-time:                 decode-universal-time. (line 6)
* defclass:                              defclass.              (line 6)
* defconstant:                           defconstant.           (line 6)
* defgeneric:                            defgeneric.            (line 6)
* define-compiler-macro:                 define-compiler-macro. (line 6)
* define-condition:                      define-condition.      (line 6)
* define-method-combination:             define-method-combination.
                                                                (line 6)
* define-modify-macro:                   define-modify-macro.   (line 6)
* define-setf-expander:                  define-setf-expander.  (line 6)
* define-symbol-macro:                   define-symbol-macro.   (line 6)
* defmacro:                              defmacro.              (line 6)
* defmethod:                             defmethod.             (line 6)
* defpackage:                            defpackage.            (line 6)
* defparameter:                          defparameter; defvar.  (line 6)
* defsetf:                               defsetf.               (line 6)
* defstruct:                             defstruct.             (line 6)
* deftype:                               deftype.               (line 6)
* defun:                                 defun.                 (line 6)
* defvar:                                defparameter; defvar.  (line 6)
* delete:                                remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                                (line 6)
* delete-duplicates:                     remove-duplicates; delete-duplicates.
                                                                (line 6)
* delete-file:                           delete-file.           (line 6)
* delete-if:                             remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                                (line 6)
* delete-if-not:                         remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                                (line 6)
* delete-package:                        delete-package.        (line 6)
* denominator:                           numerator; denominator.
                                                                (line 6)
* deposit-field:                         deposit-field.         (line 6)
* describe:                              describe.              (line 6)
* describe-object:                       describe-object.       (line 6)
* destructuring-bind:                    destructuring-bind.    (line 6)
* digit-char:                            digit-char.            (line 6)
* digit-char-p:                          digit-char-p.          (line 6)
* directory:                             directory.             (line 6)
* directory-namestring:                  namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                                (line 6)
* disassemble:                           disassemble.           (line 6)
* division-by-zero:                      division-by-zero.      (line 6)
* do:                                    do; do*.               (line 6)
* do*:                                   do; do*.               (line 6)
* do-all-symbols:                        do-symbols; do-external-symbols; do-all-symbols.
                                                                (line 6)
* do-external-symbols:                   do-symbols; do-external-symbols; do-all-symbols.
                                                                (line 6)
* do-symbols:                            do-symbols; do-external-symbols; do-all-symbols.
                                                                (line 6)
* documentation:                         documentation; setf documentation.
                                                                (line 6)
* dolist:                                dolist.                (line 6)
* dotimes:                               dotimes.               (line 6)
* double-float:                          short-float; single-float; double-float; long-float.
                                                                (line 6)
* double-float-epsilon:                  short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* double-float-negative-epsilon:         short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* dpb:                                   dpb.                   (line 6)
* dribble:                               dribble.               (line 6)
* dynamic-extent:                        dynamic-extent.        (line 6)
* ecase:                                 case; ccase; ecase.    (line 6)
* echo-stream:                           echo-stream.           (line 6)
* echo-stream-input-stream:              echo-stream-input-stream; echo-stream-output-stream.
                                                                (line 6)
* echo-stream-output-stream:             echo-stream-input-stream; echo-stream-output-stream.
                                                                (line 6)
* ed:                                    ed.                    (line 6)
* eighth:                                first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* elt:                                   elt.                   (line 6)
* encode-universal-time:                 encode-universal-time. (line 6)
* end-of-file:                           end-of-file.           (line 6)
* endp:                                  endp.                  (line 6)
* enough-namestring:                     namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                                (line 6)
* ensure-directories-exist:              ensure-directories-exist.
                                                                (line 6)
* ensure-generic-function:               ensure-generic-function.
                                                                (line 6)
* eq:                                    eq.                    (line 6)
* eql <1>:                               eql (Type Specifier).  (line 6)
* eql:                                   eql (Function).        (line 6)
* equal:                                 equal.                 (line 6)
* equalp:                                equalp.                (line 6)
* error <1>:                             error (Condition Type).
                                                                (line 6)
* error:                                 error (Function).      (line 6)
* etypecase:                             typecase; ctypecase; etypecase.
                                                                (line 6)
* eval:                                  eval.                  (line 6)
* eval-when:                             eval-when.             (line 6)
* evenp:                                 evenp; oddp.           (line 6)
* every:                                 every; some; notevery; notany.
                                                                (line 6)
* exp:                                   exp; expt.             (line 6)
* export:                                export.                (line 6)
* expt:                                  exp; expt.             (line 6)
* extended-char:                         extended-char.         (line 6)
* fboundp:                               fboundp.               (line 6)
* fceiling:                              floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* fdefinition:                           fdefinition.           (line 6)
* ffloor:                                floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* fifth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* file-author:                           file-author.           (line 6)
* file-error:                            file-error.            (line 6)
* file-error-pathname:                   file-error-pathname.   (line 6)
* file-length:                           file-length.           (line 6)
* file-namestring:                       namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                                (line 6)
* file-position:                         file-position.         (line 6)
* file-stream:                           file-stream.           (line 6)
* file-string-length:                    file-string-length.    (line 6)
* file-write-date:                       file-write-date.       (line 6)
* fill:                                  fill.                  (line 6)
* fill-pointer:                          fill-pointer.          (line 6)
* find:                                  find; find-if; find-if-not.
                                                                (line 6)
* find-all-symbols:                      find-all-symbols.      (line 6)
* find-class:                            find-class.            (line 6)
* find-if:                               find; find-if; find-if-not.
                                                                (line 6)
* find-if-not:                           find; find-if; find-if-not.
                                                                (line 6)
* find-method:                           find-method.           (line 6)
* find-package:                          find-package.          (line 6)
* find-restart:                          find-restart.          (line 6)
* find-symbol:                           find-symbol.           (line 6)
* finish-output:                         finish-output; force-output; clear-output.
                                                                (line 6)
* first:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* fixnum:                                fixnum.                (line 6)
* flet:                                  flet; labels; macrolet.
                                                                (line 6)
* float <1>:                             float (System Class).  (line 6)
* float:                                 float (Function).      (line 6)
* float-digits:                          decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                                (line 6)
* float-precision:                       decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                                (line 6)
* float-radix:                           decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                                (line 6)
* float-sign:                            decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                                (line 6)
* floating-point-inexact:                floating-point-inexact.
                                                                (line 6)
* floating-point-invalid-operation:      floating-point-invalid-operation.
                                                                (line 6)
* floating-point-overflow:               floating-point-overflow.
                                                                (line 6)
* floating-point-underflow:              floating-point-underflow.
                                                                (line 6)
* floatp:                                floatp.                (line 6)
* floor:                                 floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* fmakunbound:                           fmakunbound.           (line 6)
* force-output:                          finish-output; force-output; clear-output.
                                                                (line 6)
* format:                                format.                (line 6)
* formatter:                             formatter.             (line 6)
* fourth:                                first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* fresh-line:                            terpri; fresh-line.    (line 6)
* fround:                                floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* ftruncate:                             floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* ftype:                                 ftype.                 (line 6)
* funcall:                               funcall.               (line 6)
* function <1>:                          function (Special Operator).
                                                                (line 6)
* function:                              function (System Class).
                                                                (line 6)
* function-keywords:                     function-keywords.     (line 6)
* function-lambda-expression:            function-lambda-expression.
                                                                (line 6)
* functionp:                             functionp.             (line 6)
* gcd:                                   gcd.                   (line 6)
* generic-function:                      generic-function.      (line 6)
* gensym:                                gensym.                (line 6)
* gentemp:                               gentemp.               (line 6)
* get:                                   get.                   (line 6)
* get-decoded-time:                      get-universal-time; get-decoded-time.
                                                                (line 6)
* get-dispatch-macro-character:          set-dispatch-macro-character; get-dispatch-macro-character.
                                                                (line 6)
* get-internal-real-time:                get-internal-real-time.
                                                                (line 6)
* get-internal-run-time:                 get-internal-run-time. (line 6)
* get-macro-character:                   set-macro-character; get-macro-character.
                                                                (line 6)
* get-output-stream-string:              get-output-stream-string.
                                                                (line 6)
* get-properties:                        get-properties.        (line 6)
* get-setf-expansion:                    get-setf-expansion.    (line 6)
* get-universal-time:                    get-universal-time; get-decoded-time.
                                                                (line 6)
* getf:                                  getf.                  (line 6)
* gethash:                               gethash.               (line 6)
* go:                                    go.                    (line 6)
* graphic-char-p:                        graphic-char-p.        (line 6)
* handler-bind:                          handler-bind.          (line 6)
* handler-case:                          handler-case.          (line 6)
* hash-table:                            hash-table.            (line 6)
* hash-table-count:                      hash-table-count.      (line 6)
* hash-table-p:                          hash-table-p.          (line 6)
* hash-table-rehash-size:                hash-table-rehash-size.
                                                                (line 6)
* hash-table-rehash-threshold:           hash-table-rehash-threshold.
                                                                (line 6)
* hash-table-size:                       hash-table-size.       (line 6)
* hash-table-test:                       hash-table-test.       (line 6)
* host-namestring:                       namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                                (line 6)
* identity:                              identity.              (line 6)
* if:                                    if.                    (line 6)
* ignorable:                             ignore; ignorable.     (line 6)
* ignore:                                ignore; ignorable.     (line 6)
* ignore-errors:                         ignore-errors.         (line 6)
* imagpart:                              realpart; imagpart.    (line 6)
* import:                                import.                (line 6)
* in-package:                            in-package.            (line 6)
* incf:                                  incf; decf.            (line 6)
* initialize-instance:                   initialize-instance (Standard Generic Function).
                                                                (line 6)
* inline:                                inline; notinline.     (line 6)
* input-stream-p:                        input-stream-p; output-stream-p.
                                                                (line 6)
* inspect:                               inspect.               (line 6)
* integer:                               integer.               (line 6)
* integer-decode-float:                  decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                                (line 6)
* integer-length:                        integer-length.        (line 6)
* integerp:                              integerp.              (line 6)
* interactive-stream-p:                  interactive-stream-p.  (line 6)
* intern:                                intern.                (line 6)
* internal-time-units-per-second:        internal-time-units-per-second.
                                                                (line 6)
* intersection:                          intersection; nintersection.
                                                                (line 6)
* invalid-method-error:                  invalid-method-error.  (line 6)
* invoke-debugger:                       invoke-debugger.       (line 6)
* invoke-restart:                        invoke-restart.        (line 6)
* invoke-restart-interactively:          invoke-restart-interactively.
                                                                (line 6)
* isqrt:                                 sqrt; isqrt.           (line 6)
* keyword:                               keyword.               (line 6)
* keywordp:                              keywordp.              (line 6)
* labels:                                flet; labels; macrolet.
                                                                (line 6)
* lambda <1>:                            lambda (Symbol).       (line 6)
* lambda:                                lambda (Macro).        (line 6)
* lambda-list-keywords:                  lambda-list-keywords.  (line 6)
* lambda-parameters-limit:               lambda-parameters-limit.
                                                                (line 6)
* last:                                  last.                  (line 6)
* lcm:                                   lcm.                   (line 6)
* ldb:                                   ldb.                   (line 6)
* ldb-test:                              ldb-test.              (line 6)
* ldiff:                                 ldiff; tailp.          (line 6)
* least-negative-double-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-negative-long-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-negative-normalized-double-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-negative-normalized-long-float:  most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-negative-normalized-short-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-negative-normalized-single-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-negative-short-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-negative-single-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-double-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-long-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-normalized-double-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-normalized-long-float:  most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-normalized-short-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-normalized-single-float: most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-short-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* least-positive-single-float:           most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* length:                                length.                (line 6)
* let:                                   let; let*.             (line 6)
* let*:                                  let; let*.             (line 6)
* lisp-implementation-type:              lisp-implementation-type; lisp-implementation-version.
                                                                (line 6)
* lisp-implementation-version:           lisp-implementation-type; lisp-implementation-version.
                                                                (line 6)
* list <1>:                              list; list*.           (line 6)
* list:                                  list (System Class).   (line 6)
* list*:                                 list; list*.           (line 6)
* list-all-packages:                     list-all-packages.     (line 6)
* list-length:                           list-length.           (line 6)
* listen:                                listen.                (line 6)
* listp:                                 listp.                 (line 6)
* load:                                  load.                  (line 6)
* load-logical-pathname-translations:    load-logical-pathname-translations.
                                                                (line 6)
* load-time-value:                       load-time-value.       (line 6)
* locally:                               locally.               (line 6)
* log:                                   log.                   (line 6)
* logand:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* logandc1:                              logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* logandc2:                              logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* logbitp:                               logbitp.               (line 6)
* logcount:                              logcount.              (line 6)
* logeqv:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* logical-pathname <1>:                  logical-pathname (Function).
                                                                (line 6)
* logical-pathname:                      logical-pathname (System Class).
                                                                (line 6)
* logical-pathname-translations:         logical-pathname-translations.
                                                                (line 6)
* logior:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* lognand:                               logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* lognor:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* lognot:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* logorc1:                               logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* logorc2:                               logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* logtest:                               logtest.               (line 6)
* logxor:                                logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+.
                                                                (line 6)
* long-float:                            short-float; single-float; double-float; long-float.
                                                                (line 6)
* long-float-epsilon:                    short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* long-float-negative-epsilon:           short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* long-site-name:                        short-site-name; long-site-name.
                                                                (line 6)
* loop:                                  loop.                  (line 6)
* loop-finish:                           loop-finish.           (line 6)
* lower-case-p:                          upper-case-p; lower-case-p; both-case-p.
                                                                (line 6)
* machine-instance:                      machine-instance.      (line 6)
* machine-type:                          machine-type.          (line 6)
* machine-version:                       machine-version.       (line 6)
* macro-function:                        macro-function.        (line 6)
* macroexpand:                           macroexpand; macroexpand-1.
                                                                (line 6)
* macroexpand-1:                         macroexpand; macroexpand-1.
                                                                (line 6)
* macrolet:                              flet; labels; macrolet.
                                                                (line 6)
* make-array:                            make-array.            (line 6)
* make-broadcast-stream:                 make-broadcast-stream. (line 6)
* make-concatenated-stream:              make-concatenated-stream.
                                                                (line 6)
* make-condition:                        make-condition.        (line 6)
* make-dispatch-macro-character:         make-dispatch-macro-character.
                                                                (line 6)
* make-echo-stream:                      make-echo-stream.      (line 6)
* make-hash-table:                       make-hash-table.       (line 6)
* make-instance:                         make-instance.         (line 6)
* make-instances-obsolete:               make-instances-obsolete.
                                                                (line 6)
* make-list:                             make-list.             (line 6)
* make-load-form:                        make-load-form.        (line 6)
* make-load-form-saving-slots:           make-load-form-saving-slots.
                                                                (line 6)
* make-method:                           call-method; make-method.
                                                                (line 6)
* make-package:                          make-package.          (line 6)
* make-pathname:                         make-pathname.         (line 6)
* make-random-state:                     make-random-state.     (line 6)
* make-sequence:                         make-sequence.         (line 6)
* make-string:                           make-string.           (line 6)
* make-string-input-stream:              make-string-input-stream.
                                                                (line 6)
* make-string-output-stream:             make-string-output-stream.
                                                                (line 6)
* make-symbol:                           make-symbol.           (line 6)
* make-synonym-stream:                   make-synonym-stream.   (line 6)
* make-two-way-stream:                   make-two-way-stream.   (line 6)
* makunbound:                            makunbound.            (line 6)
* map:                                   map.                   (line 6)
* map-into:                              map-into.              (line 6)
* mapc:                                  mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                                (line 6)
* mapcan:                                mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                                (line 6)
* mapcar:                                mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                                (line 6)
* mapcon:                                mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                                (line 6)
* maphash:                               maphash.               (line 6)
* mapl:                                  mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                                (line 6)
* maplist:                               mapc; mapcar; mapcan; mapl; maplist; mapcon.
                                                                (line 6)
* mask-field:                            mask-field.            (line 6)
* max:                                   max; min.              (line 6)
* member <1>:                            member; member-if; member-if-not.
                                                                (line 6)
* member:                                member (Type Specifier).
                                                                (line 6)
* member-if:                             member; member-if; member-if-not.
                                                                (line 6)
* member-if-not:                         member; member-if; member-if-not.
                                                                (line 6)
* merge:                                 merge.                 (line 6)
* merge-pathnames:                       merge-pathnames.       (line 6)
* method:                                method.                (line 6)
* method-combination:                    method-combination.    (line 6)
* method-combination-error:              method-combination-error.
                                                                (line 6)
* method-qualifiers:                     method-qualifiers.     (line 6)
* min:                                   max; min.              (line 6)
* minusp:                                minusp; plusp.         (line 6)
* mismatch:                              mismatch.              (line 6)
* mod <1>:                               mod (Type Specifier).  (line 6)
* mod:                                   mod; rem.              (line 6)
* most-negative-double-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* most-negative-fixnum:                  most-positive-fixnum; most-negative-fixnum.
                                                                (line 6)
* most-negative-long-float:              most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* most-negative-short-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* most-negative-single-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* most-positive-double-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* most-positive-fixnum:                  most-positive-fixnum; most-negative-fixnum.
                                                                (line 6)
* most-positive-long-float:              most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* most-positive-short-float:             most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* most-positive-single-float:            most-positive-short-float; least-positive-short-float; least-positive-n+.
                                                                (line 6)
* muffle-warning <1>:                    muffle-warning (Restart).
                                                                (line 6)
* muffle-warning:                        abort; continue; muffle-warning; store-value; use-value.
                                                                (line 6)
* multiple-value-bind:                   multiple-value-bind.   (line 6)
* multiple-value-call:                   multiple-value-call.   (line 6)
* multiple-value-list:                   multiple-value-list.   (line 6)
* multiple-value-prog1:                  multiple-value-prog1.  (line 6)
* multiple-value-setq:                   multiple-value-setq.   (line 6)
* multiple-values-limit:                 multiple-values-limit. (line 6)
* name-char:                             name-char.             (line 6)
* namestring:                            namestring; file-namestring; directory-namestring; host-namestring; eno+.
                                                                (line 6)
* nbutlast:                              butlast; nbutlast.     (line 6)
* nconc:                                 nconc.                 (line 6)
* next-method-p:                         next-method-p.         (line 6)
* nil <1>:                               nil (Type).            (line 6)
* nil:                                   nil (Constant Variable).
                                                                (line 6)
* nintersection:                         intersection; nintersection.
                                                                (line 6)
* ninth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* no-applicable-method:                  no-applicable-method.  (line 6)
* no-next-method:                        no-next-method.        (line 6)
* not <1>:                               not (Function).        (line 6)
* not:                                   not (Type Specifier).  (line 6)
* notany:                                every; some; notevery; notany.
                                                                (line 6)
* notevery:                              every; some; notevery; notany.
                                                                (line 6)
* notinline:                             inline; notinline.     (line 6)
* nreconc:                               revappend; nreconc.    (line 6)
* nreverse:                              reverse; nreverse.     (line 6)
* nset-difference:                       set-difference; nset-difference.
                                                                (line 6)
* nset-exclusive-or:                     set-exclusive-or; nset-exclusive-or.
                                                                (line 6)
* nstring-capitalize:                    string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                                (line 6)
* nstring-downcase:                      string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                                (line 6)
* nstring-upcase:                        string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                                (line 6)
* nsublis:                               sublis; nsublis.       (line 6)
* nsubst:                                subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                                (line 6)
* nsubst-if:                             subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                                (line 6)
* nsubst-if-not:                         subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                                (line 6)
* nsubstitute:                           substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                                (line 6)
* nsubstitute-if:                        substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                                (line 6)
* nsubstitute-if-not:                    substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                                (line 6)
* nth:                                   nth.                   (line 6)
* nth-value:                             nth-value.             (line 6)
* nthcdr:                                nthcdr.                (line 6)
* null <1>:                              null (System Class).   (line 6)
* null:                                  null (Function).       (line 6)
* number:                                number.                (line 6)
* numberp:                               numberp.               (line 6)
* numerator:                             numerator; denominator.
                                                                (line 6)
* nunion:                                union; nunion.         (line 6)
* oddp:                                  evenp; oddp.           (line 6)
* open:                                  open.                  (line 6)
* open-stream-p:                         open-stream-p.         (line 6)
* optimize:                              optimize.              (line 6)
* or <1>:                                or (Macro).            (line 6)
* or:                                    or (Type Specifier).   (line 6)
* output-stream-p:                       input-stream-p; output-stream-p.
                                                                (line 6)
* package:                               package.               (line 6)
* package-error:                         package-error.         (line 6)
* package-error-package:                 package-error-package. (line 6)
* package-name:                          package-name.          (line 6)
* package-nicknames:                     package-nicknames.     (line 6)
* package-shadowing-symbols:             package-shadowing-symbols.
                                                                (line 6)
* package-use-list:                      package-use-list.      (line 6)
* package-used-by-list:                  package-used-by-list.  (line 6)
* packagep:                              packagep.              (line 6)
* pairlis:                               pairlis.               (line 6)
* parse-error:                           parse-error.           (line 6)
* parse-integer:                         parse-integer.         (line 6)
* parse-namestring:                      parse-namestring.      (line 6)
* pathname <1>:                          pathname (System Class).
                                                                (line 6)
* pathname:                              pathname (Function).   (line 6)
* pathname-device:                       pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                                (line 6)
* pathname-directory:                    pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                                (line 6)
* pathname-host:                         pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                                (line 6)
* pathname-match-p:                      pathname-match-p.      (line 6)
* pathname-name:                         pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                                (line 6)
* pathname-type:                         pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                                (line 6)
* pathname-version:                      pathname-host; pathname-device; pathname-directory; pathname-name; path+.
                                                                (line 6)
* pathnamep:                             pathnamep.             (line 6)
* peek-char:                             peek-char.             (line 6)
* phase:                                 phase.                 (line 6)
* pi:                                    pi.                    (line 6)
* plusp:                                 minusp; plusp.         (line 6)
* pop:                                   pop.                   (line 6)
* position:                              position; position-if; position-if-not.
                                                                (line 6)
* position-if:                           position; position-if; position-if-not.
                                                                (line 6)
* position-if-not:                       position; position-if; position-if-not.
                                                                (line 6)
* pprint:                                write; prin1; print; pprint; princ.
                                                                (line 6)
* pprint-dispatch:                       pprint-dispatch.       (line 6)
* pprint-exit-if-list-exhausted:         pprint-exit-if-list-exhausted.
                                                                (line 6)
* pprint-fill:                           pprint-fill; pprint-linear; pprint-tabular.
                                                                (line 6)
* pprint-indent:                         pprint-indent.         (line 6)
* pprint-linear:                         pprint-fill; pprint-linear; pprint-tabular.
                                                                (line 6)
* pprint-logical-block:                  pprint-logical-block.  (line 6)
* pprint-newline:                        pprint-newline.        (line 6)
* pprint-pop:                            pprint-pop.            (line 6)
* pprint-tab:                            pprint-tab.            (line 6)
* pprint-tabular:                        pprint-fill; pprint-linear; pprint-tabular.
                                                                (line 6)
* prin1:                                 write; prin1; print; pprint; princ.
                                                                (line 6)
* prin1-to-string:                       write-to-string; prin1-to-string; princ-to-string.
                                                                (line 6)
* princ:                                 write; prin1; print; pprint; princ.
                                                                (line 6)
* princ-to-string:                       write-to-string; prin1-to-string; princ-to-string.
                                                                (line 6)
* print:                                 write; prin1; print; pprint; princ.
                                                                (line 6)
* print-not-readable:                    print-not-readable.    (line 6)
* print-not-readable-object:             print-not-readable-object.
                                                                (line 6)
* print-object:                          print-object.          (line 6)
* print-unreadable-object:               print-unreadable-object.
                                                                (line 6)
* probe-file:                            probe-file.            (line 6)
* proclaim:                              proclaim.              (line 6)
* prog:                                  prog; prog*.           (line 6)
* prog*:                                 prog; prog*.           (line 6)
* prog1:                                 prog1; prog2.          (line 6)
* prog2:                                 prog1; prog2.          (line 6)
* progn:                                 progn.                 (line 6)
* program-error:                         program-error.         (line 6)
* progv:                                 progv.                 (line 6)
* provide:                               provide; require.      (line 6)
* psetf:                                 setf; psetf.           (line 6)
* psetq:                                 psetq.                 (line 6)
* push:                                  push.                  (line 6)
* pushnew:                               pushnew.               (line 6)
* quote:                                 quote.                 (line 6)
* random:                                random.                (line 6)
* random-state:                          random-state.          (line 6)
* random-state-p:                        random-state-p.        (line 6)
* rassoc:                                rassoc; rassoc-if; rassoc-if-not.
                                                                (line 6)
* rassoc-if:                             rassoc; rassoc-if; rassoc-if-not.
                                                                (line 6)
* rassoc-if-not:                         rassoc; rassoc-if; rassoc-if-not.
                                                                (line 6)
* ratio:                                 ratio.                 (line 6)
* rational <1>:                          rational; rationalize. (line 6)
* rational:                              rational (System Class).
                                                                (line 6)
* rationalize:                           rational; rationalize. (line 6)
* rationalp:                             rationalp.             (line 6)
* read:                                  read; read-preserving-whitespace.
                                                                (line 6)
* read-byte:                             read-byte.             (line 6)
* read-char:                             read-char.             (line 6)
* read-char-no-hang:                     read-char-no-hang.     (line 6)
* read-delimited-list:                   read-delimited-list.   (line 6)
* read-from-string:                      read-from-string.      (line 6)
* read-line:                             read-line.             (line 6)
* read-preserving-whitespace:            read; read-preserving-whitespace.
                                                                (line 6)
* read-sequence:                         read-sequence.         (line 6)
* reader-error:                          reader-error.          (line 6)
* readtable:                             readtable.             (line 6)
* readtable-case:                        readtable-case.        (line 6)
* readtablep:                            readtablep.            (line 6)
* real:                                  real.                  (line 6)
* realp:                                 realp.                 (line 6)
* realpart:                              realpart; imagpart.    (line 6)
* reduce:                                reduce.                (line 6)
* reinitialize-instance:                 reinitialize-instance. (line 6)
* rem:                                   mod; rem.              (line 6)
* remf:                                  remf.                  (line 6)
* remhash:                               remhash.               (line 6)
* remove:                                remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                                (line 6)
* remove-duplicates:                     remove-duplicates; delete-duplicates.
                                                                (line 6)
* remove-if:                             remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                                (line 6)
* remove-if-not:                         remove; remove-if; remove-if-not; delete; delete-if; delete-if-not.
                                                                (line 6)
* remove-method:                         remove-method.         (line 6)
* remprop:                               remprop.               (line 6)
* rename-file:                           rename-file.           (line 6)
* rename-package:                        rename-package.        (line 6)
* replace:                               replace.               (line 6)
* require:                               provide; require.      (line 6)
* rest:                                  rest.                  (line 6)
* restart:                               restart.               (line 6)
* restart-bind:                          restart-bind.          (line 6)
* restart-case:                          restart-case.          (line 6)
* restart-name:                          restart-name.          (line 6)
* return:                                return.                (line 6)
* return-from:                           return-from.           (line 6)
* revappend:                             revappend; nreconc.    (line 6)
* reverse:                               reverse; nreverse.     (line 6)
* room:                                  room.                  (line 6)
* rotatef:                               rotatef.               (line 6)
* round:                                 floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* row-major-aref:                        row-major-aref.        (line 6)
* rplaca:                                rplaca; rplacd.        (line 6)
* rplacd:                                rplaca; rplacd.        (line 6)
* satisfies:                             satisfies.             (line 6)
* sbit:                                  bit; sbit.             (line 6)
* scale-float:                           decode-float; scale-float; float-radix; float-sign; float-digits; float+.
                                                                (line 6)
* schar:                                 char; schar.           (line 6)
* search:                                search.                (line 6)
* second:                                first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* sequence:                              sequence.              (line 6)
* serious-condition:                     serious-condition.     (line 6)
* set:                                   set.                   (line 6)
* set-difference:                        set-difference; nset-difference.
                                                                (line 6)
* set-dispatch-macro-character:          set-dispatch-macro-character; get-dispatch-macro-character.
                                                                (line 6)
* set-exclusive-or:                      set-exclusive-or; nset-exclusive-or.
                                                                (line 6)
* set-macro-character:                   set-macro-character; get-macro-character.
                                                                (line 6)
* set-pprint-dispatch:                   set-pprint-dispatch.   (line 6)
* set-syntax-from-char:                  set-syntax-from-char.  (line 6)
* setf:                                  setf; psetf.           (line 6)
* setq:                                  setq.                  (line 6)
* seventh:                               first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* shadow:                                shadow.                (line 6)
* shadowing-import:                      shadowing-import.      (line 6)
* shared-initialize:                     shared-initialize (Standard Generic Function).
                                                                (line 6)
* shiftf:                                shiftf.                (line 6)
* short-float:                           short-float; single-float; double-float; long-float.
                                                                (line 6)
* short-float-epsilon:                   short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* short-float-negative-epsilon:          short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* short-site-name:                       short-site-name; long-site-name.
                                                                (line 6)
* signal:                                signal.                (line 6)
* signed-byte:                           signed-byte.           (line 6)
* signum:                                signum.                (line 6)
* simple-array:                          simple-array.          (line 6)
* simple-base-string:                    simple-base-string.    (line 6)
* simple-bit-vector:                     simple-bit-vector.     (line 6)
* simple-bit-vector-p:                   simple-bit-vector-p.   (line 6)
* simple-condition:                      simple-condition.      (line 6)
* simple-condition-format-arguments:     simple-condition-format-control; simple-condition-format-arguments.
                                                                (line 6)
* simple-condition-format-control:       simple-condition-format-control; simple-condition-format-arguments.
                                                                (line 6)
* simple-error:                          simple-error.          (line 6)
* simple-string:                         simple-string.         (line 6)
* simple-string-p:                       simple-string-p.       (line 6)
* simple-type-error:                     simple-type-error.     (line 6)
* simple-vector:                         simple-vector.         (line 6)
* simple-vector-p:                       simple-vector-p.       (line 6)
* simple-warning:                        simple-warning.        (line 6)
* sin:                                   sin; cos; tan.         (line 6)
* single-float:                          short-float; single-float; double-float; long-float.
                                                                (line 6)
* single-float-epsilon:                  short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* single-float-negative-epsilon:         short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+.
                                                                (line 6)
* sinh:                                  sinh; cosh; tanh; asinh; acosh; atanh.
                                                                (line 6)
* sixth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* sleep:                                 sleep.                 (line 6)
* slot-boundp:                           slot-boundp.           (line 6)
* slot-exists-p:                         slot-exists-p.         (line 6)
* slot-makunbound:                       slot-makunbound.       (line 6)
* slot-missing:                          slot-missing.          (line 6)
* slot-unbound:                          slot-unbound.          (line 6)
* slot-value:                            slot-value.            (line 6)
* software-type:                         software-type; software-version.
                                                                (line 6)
* software-version:                      software-type; software-version.
                                                                (line 6)
* some:                                  every; some; notevery; notany.
                                                                (line 6)
* sort:                                  sort; stable-sort.     (line 6)
* special:                               special.               (line 6)
* special-operator-p:                    special-operator-p.    (line 6)
* sqrt:                                  sqrt; isqrt.           (line 6)
* stable-sort:                           sort; stable-sort.     (line 6)
* standard-char:                         standard-char.         (line 6)
* standard-char-p:                       standard-char-p.       (line 6)
* standard-class:                        standard-class.        (line 6)
* standard-generic-function:             standard-generic-function.
                                                                (line 6)
* standard-method:                       standard-method.       (line 6)
* standard-object:                       standard-object.       (line 6)
* step:                                  step.                  (line 6)
* storage-condition:                     storage-condition.     (line 6)
* store-value <1>:                       store-value (Restart). (line 6)
* store-value:                           abort; continue; muffle-warning; store-value; use-value.
                                                                (line 6)
* stream:                                stream.                (line 6)
* stream-element-type:                   stream-element-type.   (line 6)
* stream-error:                          stream-error.          (line 6)
* stream-error-stream:                   stream-error-stream.   (line 6)
* stream-external-format:                stream-external-format.
                                                                (line 6)
* streamp:                               streamp.               (line 6)
* string <1>:                            string (System Class). (line 6)
* string:                                string (Function).     (line 6)
* string-capitalize:                     string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                                (line 6)
* string-downcase:                       string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                                (line 6)
* string-equal:                          string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string-greaterp:                       string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string-left-trim:                      string-trim; string-left-trim; string-right-trim.
                                                                (line 6)
* string-lessp:                          string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string-not-equal:                      string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string-not-greaterp:                   string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string-not-lessp:                      string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string-right-trim:                     string-trim; string-left-trim; string-right-trim.
                                                                (line 6)
* string-stream:                         string-stream.         (line 6)
* string-trim:                           string-trim; string-left-trim; string-right-trim.
                                                                (line 6)
* string-upcase:                         string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+.
                                                                (line 6)
* string/=:                              string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string<:                               string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string<=:                              string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string=:                               string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string>:                               string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* string>=:                              string=; string/=; string<; string>; string<=; string>=; string-equal; +.
                                                                (line 6)
* stringp:                               stringp.               (line 6)
* structure-class:                       structure-class.       (line 6)
* structure-object:                      structure-object.      (line 6)
* style-warning:                         style-warning.         (line 6)
* sublis:                                sublis; nsublis.       (line 6)
* subseq:                                subseq.                (line 6)
* subsetp:                               subsetp.               (line 6)
* subst:                                 subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                                (line 6)
* subst-if:                              subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                                (line 6)
* subst-if-not:                          subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not.
                                                                (line 6)
* substitute:                            substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                                (line 6)
* substitute-if:                         substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                                (line 6)
* substitute-if-not:                     substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+.
                                                                (line 6)
* subtypep:                              subtypep.              (line 6)
* svref:                                 svref.                 (line 6)
* sxhash:                                sxhash.                (line 6)
* symbol:                                symbol.                (line 6)
* symbol-function:                       symbol-function.       (line 6)
* symbol-macrolet:                       symbol-macrolet.       (line 6)
* symbol-name:                           symbol-name.           (line 6)
* symbol-package:                        symbol-package.        (line 6)
* symbol-plist:                          symbol-plist.          (line 6)
* symbol-value:                          symbol-value.          (line 6)
* symbolp:                               symbolp.               (line 6)
* synonym-stream:                        synonym-stream.        (line 6)
* synonym-stream-symbol:                 synonym-stream-symbol. (line 6)
* t <1>:                                 t (Constant Variable). (line 6)
* t:                                     t (System Class).      (line 6)
* tagbody:                               tagbody.               (line 6)
* tailp:                                 ldiff; tailp.          (line 6)
* tan:                                   sin; cos; tan.         (line 6)
* tanh:                                  sinh; cosh; tanh; asinh; acosh; atanh.
                                                                (line 6)
* tenth:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* terpri:                                terpri; fresh-line.    (line 6)
* the:                                   the.                   (line 6)
* third:                                 first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+.
                                                                (line 6)
* throw:                                 throw.                 (line 6)
* time:                                  time (Macro).          (line 6)
* trace:                                 trace; untrace.        (line 6)
* translate-logical-pathname:            translate-logical-pathname.
                                                                (line 6)
* translate-pathname:                    translate-pathname.    (line 6)
* tree-equal:                            tree-equal.            (line 6)
* truename:                              truename.              (line 6)
* truncate:                              floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround.
                                                                (line 6)
* two-way-stream:                        two-way-stream.        (line 6)
* two-way-stream-input-stream:           two-way-stream-input-stream; two-way-stream-output-stream.
                                                                (line 6)
* two-way-stream-output-stream:          two-way-stream-input-stream; two-way-stream-output-stream.
                                                                (line 6)
* type:                                  type.                  (line 6)
* type-error:                            type-error.            (line 6)
* type-error-datum:                      type-error-datum; type-error-expected-type.
                                                                (line 6)
* type-error-expected-type:              type-error-datum; type-error-expected-type.
                                                                (line 6)
* type-of:                               type-of.               (line 6)
* typecase:                              typecase; ctypecase; etypecase.
                                                                (line 6)
* typep:                                 typep.                 (line 6)
* unbound-slot:                          unbound-slot.          (line 6)
* unbound-slot-instance:                 unbound-slot-instance. (line 6)
* unbound-variable:                      unbound-variable.      (line 6)
* undefined-function:                    undefined-function.    (line 6)
* unexport:                              unexport.              (line 6)
* unintern:                              unintern.              (line 6)
* union:                                 union; nunion.         (line 6)
* unless:                                when; unless.          (line 6)
* unread-char:                           unread-char.           (line 6)
* unsigned-byte:                         unsigned-byte.         (line 6)
* untrace:                               trace; untrace.        (line 6)
* unuse-package:                         unuse-package.         (line 6)
* unwind-protect:                        unwind-protect.        (line 6)
* update-instance-for-different-class:   update-instance-for-different-class.
                                                                (line 6)
* update-instance-for-redefined-class:   update-instance-for-redefined-class.
                                                                (line 6)
* upgraded-array-element-type:           upgraded-array-element-type.
                                                                (line 6)
* upgraded-complex-part-type:            upgraded-complex-part-type.
                                                                (line 6)
* upper-case-p:                          upper-case-p; lower-case-p; both-case-p.
                                                                (line 6)
* use-package:                           use-package.           (line 6)
* use-value <1>:                         use-value (Restart).   (line 6)
* use-value:                             abort; continue; muffle-warning; store-value; use-value.
                                                                (line 6)
* user-homedir-pathname:                 user-homedir-pathname. (line 6)
* values <1>:                            values (Accessor).     (line 6)
* values:                                values (Type Specifier).
                                                                (line 6)
* values-list:                           values-list.           (line 6)
* vector <1>:                            vector (System Class). (line 6)
* vector:                                vector (Function).     (line 6)
* vector-pop:                            vector-pop.            (line 6)
* vector-push:                           vector-push; vector-push-extend.
                                                                (line 6)
* vector-push-extend:                    vector-push; vector-push-extend.
                                                                (line 6)
* vectorp:                               vectorp.               (line 6)
* warn:                                  warn.                  (line 6)
* warning:                               warning.               (line 6)
* when:                                  when; unless.          (line 6)
* wild-pathname-p:                       wild-pathname-p.       (line 6)
* with-accessors:                        with-accessors.        (line 6)
* with-compilation-unit:                 with-compilation-unit. (line 6)
* with-condition-restarts:               with-condition-restarts.
                                                                (line 6)
* with-hash-table-iterator:              with-hash-table-iterator.
                                                                (line 6)
* with-input-from-string:                with-input-from-string.
                                                                (line 6)
* with-open-file:                        with-open-file.        (line 6)
* with-open-stream:                      with-open-stream.      (line 6)
* with-output-to-string:                 with-output-to-string. (line 6)
* with-package-iterator:                 with-package-iterator. (line 6)
* with-simple-restart:                   with-simple-restart.   (line 6)
* with-slots:                            with-slots.            (line 6)
* with-standard-io-syntax:               with-standard-io-syntax.
                                                                (line 6)
* write:                                 write; prin1; print; pprint; princ.
                                                                (line 6)
* write-byte:                            write-byte.            (line 6)
* write-char:                            write-char.            (line 6)
* write-line:                            write-string; write-line.
                                                                (line 6)
* write-sequence:                        write-sequence.        (line 6)
* write-string:                          write-string; write-line.
                                                                (line 6)
* write-to-string:                       write-to-string; prin1-to-string; princ-to-string.
                                                                (line 6)
* y-or-n-p:                              y-or-n-p; yes-or-no-p. (line 6)
* yes-or-no-p:                           y-or-n-p; yes-or-no-p. (line 6)
* zerop:                                 zerop.                 (line 6)


File: chris-ansicl.info,  Node: List of Figures,  Prev: Symbol Index,  Up: Top

List of Figures
***************

* Menu:

* Figure 1.1: Notations for NIL:         fig1.1.
* Figure 1.2: Deprecated Functions:      fig1.2.
* Figure 1.3: Functions with ...:        fig1.3.
* Figure 1.4: Symbols in the ...:        fig1.4.
* Figure 1.5: Symbols in the ...:        fig1.5.
* Figure 1.6: Symbols in the ...:        fig1.6.
* Figure 1.7: Symbols in the ...:        fig1.7.
* Figure 1.8: Symbols in the ...:        fig1.8.
* Figure 1.9: Symbols in the ...:        fig1.9.
* Figure 1.10: Symbols in the ...:       fig1.10.
* Figure 1.11: Symbols in the ...:       fig1.11.
* Figure 1.12: Symbols in the ...:       fig1.12.
* Figure 1.13: Symbols in the ...:       fig1.13.
* Figure 1.14: Symbols in the ...:       fig1.14.
* Figure 1.15: Symbols in the ...:       fig1.15.
* Figure 2.1: Readtable defined ...:     fig2.1.
* Figure 2.2: Variables that ...:        fig2.2.
* Figure 2.3: Standard Character ...:    fig2.3.
* Figure 2.4: Standard Character ...:    fig2.4.
* Figure 2.5: Standard Character ...:    StdCharsThree.
* Figure 2.6: Possible Character ...:    PossibleSyntaxTypes.
* Figure 2.7: Character Syntax ...:      CharSyntaxTypesInStdSyntax.
* Figure 2.8: Constituent Traits ...:    ConstituentTraitsOfStdChars.
* Figure 2.9: Syntax for Numeric ...:    SyntaxForNumericTokens.
* Figure 2.10: Examples of ...:          fig2.10.
* Figure 2.11: Examples of symbols:      fig2.11.
* Figure 2.12: Examples of ...:          fig2.12.
* Figure 2.13: Examples of Ratios:       fig2.13.
* Figure 2.14: Examples of ...:          fig2.14.
* Figure 2.15: Examples of the ...:      fig2.15.
* Figure 2.16: Examples of the ...:      fig2.16.
* Figure 2.17: Valid patterns ...:       fig2.17.
* Figure 2.18: Examples of the ...:      fig2.18.
* Figure 2.19: Standard # ...:           fig2.19.
* Figure 2.20: Radix Indicator ...:      fig2.20.
* Figure 2.21: Complex Number ...:       fig2.21.
* Figure 3.1: Some Defined Names ...:    fig3.1.
* Figure 3.2: Common Lisp ...:           CLSpecialOps.
* Figure 3.3: Defined names ...:         fig3.3.
* Figure 3.4: Some ...:                  fig3.4.
* Figure 3.5: Some operators ...:        fig3.5.
* Figure 3.6: Defined names ...:         fig3.6.
* Figure 3.7: EVAL-WHEN processing:      fig3.7.
* Figure 3.8: Defining Macros ...:       fig3.8.
* Figure 3.9: Common Lisp ...:           fig3.9.
* Figure 3.10: What Kind of ...:         fig3.10.
* Figure 3.11: Defined names ...:        fig3.11.
* Figure 3.12: Standardized ...:         fig3.12.
* Figure 3.13: Lambda List ...:          fig3.13.
* Figure 3.14: Lambda List ...:          fig3.14.
* Figure 3.15: Standardized ...:         fig3.15.
* Figure 3.16: Lambda List ...:          fig3.16.
* Figure 3.17: Operators that ...:       fig3.17.
* Figure 3.18: Lambda List ...:          fig3.18.
* Figure 3.19: Lambda List ...:          fig3.19.
* Figure 3.20: Lambda List ...:          fig3.20.
* Figure 3.21: Lambda List ...:          fig3.21.
* Figure 3.22: Global ...:               fig3.22.
* Figure 3.23: Standardized ...:         fig3.23.
* Figure 3.24: Local Declaration ...:    fig3.24.
* Figure 3.25: Optimize qualities:       fig3.25.
* Figure 4.1: Cross-References ...:      TypeInfoXrefs.
* Figure 4.2: Standardized ...:          StandardizedAtomicTypeSpecs.
* Figure 4.3: Standardized ...:          StandardizedCompoundTypeSpecNames.
* Figure 4.4: Standardized ...:          fig4.4.
* Figure 4.5: Defined names ...:         TypesAndDeclsNames.
* Figure 4.6: Standardized Type ...:     StandardizedTypeSpecifierNames.
* Figure 4.7: Object System Classes:     ObjectSystemClasses.
* Figure 4.8: Classes that ...:          ClassTypeCorrespondence.
* Figure 4.9: Result ...:                fig4.9.
* Figure 5.1: Examples of setf:          fig5.1.
* Figure 5.2: Operators relating ...:    fig5.2.
* Figure 5.3: Sample Setf ...:           fig5.3.
* Figure 5.4: Sample Setf ...:           fig5.4.
* Figure 5.5: Sample Setf ...:           fig5.5.
* Figure 5.6: Sample Setf ...:           fig5.6.
* Figure 5.7: Functions that ...:        fig5.7.
* Figure 5.8: Functions that ...:        fig5.8.
* Figure 5.9: Read-Modify-Write ...:     fig5.9.
* Figure 5.10: Macros that have ...:     fig5.10.
* Figure 5.11: Operators that ...:       fig5.11.
* Figure 5.12: Summary and ...:          fig5.12.
* Figure 5.13: Summary and ...:          fig5.13.
* Figure 7.1: Standardized ...:          StdMethDefOps.
* Figure 7.2: Built-in Method ...:       fig7.2.
* Figure 9.1: Standardized ...:          StandardizedConditionTypes.
* Figure 9.2: Operators that ...:        fig9.2.
* Figure 9.3: Operators that ...:        fig9.3.
* Figure 9.4: Operators relating ...:    fig9.4.
* Figure 9.5: Defined names ...:         fig9.5.
* Figure 9.6: Defined names ...:         fig9.6.
* Figure 9.7: Operators relating ...:    fig9.7.
* Figure 10.1: Property list ...:        fig10.1.
* Figure 10.2: Symbol creation ...:      fig10.2.
* Figure 11.1: Some Defined ...:         fig11.1.
* Figure 11.2: Standardized ...:         fig11.2.
* Figure 12.1: Operators ...:            fig12.1.
* Figure 12.2: Defined names ...:        fig12.2.
* Figure 12.3: Operators for ...:        fig12.3.
* Figure 12.4: Defined names ...:        fig12.4.
* Figure 12.5: Defined names ...:        fig12.5.
* Figure 12.6: Defined names ...:        fig12.6.
* Figure 12.7: Defined names ...:        fig12.7.
* Figure 12.8: Functions ...:            fig12.8.
* Figure 12.9: Trigonometric ...:        fig12.9.
* Figure 12.10: Quadrant ...:            fig12.10.
* Figure 12.11: Random-state ...:        fig12.11.
* Figure 12.12: Recommended ...:         fig12.12.
* Figure 12.13: Uses of /=, =, ...:      fig12.13.
* Figure 12.14: Mathematical ...:        fig12.14.
* Figure 12.15: Quadrant ...:            fig12.15.
* Figure 12.16: Mathematical ...:        fig12.16.
* Figure 12.17: Bit-Wise Logical ...:    fig12.17.
* Figure 12.18: Bit-wise Logical ...:    fig12.18.
* Figure 13.1: Character defined ...:    fig13.1.
* Figure 13.2: Character defined ...:    fig13.2.
* Figure 14.1: Some defined ...:         fig14.1.
* Figure 14.2: Some defined ...:         fig14.2.
* Figure 14.3: Some defined ...:         fig14.3.
* Figure 14.4: Some defined ...:         fig14.4.
* Figure 14.5: Some defined ...:         fig14.5.
* Figure 14.6: CAR and CDR variants:     fig14.6.
* Figure 15.1: General Purpose ...:      fig15.1.
* Figure 15.2: Operators that ...:       fig15.2.
* Figure 15.3: Operators that ...:       fig15.3.
* Figure 15.4: Bit-wise Logical ...:     fig15.4.
* Figure 17.1: Standardized ...:         SequenceFunctions.
* Figure 17.2: Operators that ...:       fig17.2.
* Figure 17.3: Operators that ...:       fig17.3.
* Figure 18.1: Hash-table ...:           fig18.1.
* Figure 19.1: Pathname Operations:      fig19.1.
* Figure 19.2: Pathname ...:             PathnameCaseFuns.
* Figure 19.3: Special Markers ...:      fig19.3.
* Figure 20.1: File and ...:             fig20.1.
* Figure 20.2: File Functions ...:       fig20.2.
* Figure 20.3: File Functions ...:       fig20.3.
* Figure 21.1: Some ...:                 fig21.1.
* Figure 21.2: Operators ...:            InputStreamOps.
* Figure 21.3: Operators ...:            OutputStreamOps.
* Figure 21.4: Operators ...:            fig21.4.
* Figure 21.5: Defined Names ...:        fig21.5.
* Figure 21.6: Standardized ...:         StandardizedStreamVars.
* Figure 21.7: Operators that ...:       OpenOrClosedStreamOps.
* Figure 21.8: Operators that ...:       fig21.8.
* Figure 22.1: Standardized ...:         StdPrinterControlVars.
* Figure 22.2: Additional ...:           fig22.2.
* Figure 22.3: Example of ...:           fig22.3.
* Figure 22.4: Defined names ...:        fig22.4.
* Figure 22.5: Format directives ...:    fig22.5.
* Figure 22.6: Examples of ...:          fig22.6.
* Figure 22.7: Argument ...:             fig22.7.
* Figure 23.1: Values of ...:            fig23.1.
* Figure 24.1: Features examples:        fig24.1.
* Figure 25.1: Variables ...:            fig25.1.
* Figure 25.2: Defined names ...:        fig25.2.
* Figure 25.3: Defined names ...:        fig25.3.
* Figure 25.4: Defined names ...:        fig25.4.
* Figure 25.5: Defined names ...:        fig25.5.
* Figure 25.6: Defined names ...:        fig25.6.
* Figure 25.7: Defined names ...:        fig25.7.
* Figure 25.8: Defined names ...:        fig25.8.
* Figure 26.1: Exponent Markers:         fig26.1.
* Figure 26.2: Standardized I/O ...:     fig26.2.
* Figure 26.3: Standardized ...:         fig26.3.
* Figure 26.4: Standardized ...:         fig26.4.



Tag Table:
Node: Top223
Ref: Top-Footnote-11085
Node: Credits1158
Node: Introduction18020
Node: Scope; Purpose; and History18392
Node: Scope and Purpose18620
Node: History19078
Node: Organization of the Document28663
Node: Referenced Publications31274
Node: Definitions34921
Node: Notational Conventions35307
Ref: ModifiedBNF37351
Ref: CaseInSymbols45908
Ref: fig1.148432
Ref: Designators49861
Node: Error Terminology52654
Node: Sections Not Formally Part Of This Standard60033
Node: Interpreting Dictionary Entries61540
Ref: TypeSpecEntries64898
Node: Conformance79826
Node: Conforming Implementations80236
Ref: ReqLangFeatures80572
Node: Conforming Programs84166
Ref: ReadTimeConditionals86182
Node: Language Extensions87252
Node: Language Subsets89563
Node: Deprecated Language Features90266
Node: Deprecated Functions91131
Ref: fig1.291367
Node: Deprecated Argument Conventions91669
Ref: fig1.392055
Node: Deprecated Variables92690
Node: Deprecated Reader Syntax92950
Node: Symbols in the COMMON-LISP Package93465
Ref: fig1.493799
Ref: fig1.595370
Ref: fig1.697433
Ref: fig1.799853
Ref: fig1.8101517
Ref: fig1.9103435
Ref: fig1.10105528
Ref: fig1.11107423
Ref: fig1.12108898
Ref: fig1.13110469
Ref: fig1.14112246
Ref: fig1.15113768
Node: Syntax115559
Node: Character Syntax115797
Node: Readtables116561
Ref: fig2.1116979
Ref: CurrentReadtable117398
Node: Variables that affect the Lisp Reader118590
Ref: fig2.2119012
Node: Standard Characters119169
Ref: fig2.3119729
Ref: fig2.4121638
Ref: StdCharsThree122179
Node: Character Syntax Types123861
Ref: PossibleSyntaxTypes124673
Ref: CharSyntaxTypesInStdSyntax125140
Ref: ConstituentChars127652
Ref: ConstituentTraits128182
Ref: ConstituentTraitsOfStdChars129031
Ref: MacroChars132119
Ref: MultipleEscapeChar134819
Ref: SingleEscapeChar135617
Ref: WhitespaceChars136241
Node: Reader Algorithm136564
Node: Interpretation of Tokens143126
Node: Numbers as Tokens143495
Ref: SyntaxForNumericTokens143840
Ref: PotentialNumbersAsTokens144540
Ref: EscCharsAndPotentialNums146859
Ref: fig2.10147650
Ref: fig2.11148019
Ref: fig2.12148289
Node: Constructing Numbers from Tokens148398
Ref: SyntaxOfIntegers149377
Ref: SyntaxOfRatios149891
Ref: fig2.13150148
Ref: SyntaxOfFloats150821
Ref: fig2.14151988
Ref: SyntaxOfComplexes153339
Node: The Consing Dot154091
Node: Symbols as Tokens154658
Ref: fig2.15155412
Ref: fig2.16156353
Node: Valid Patterns for Tokens158180
Ref: fig2.17158470
Node: Package System Consistency Rules161560
Node: Standard Macro Characters163284
Node: Left-Parenthesis164062
Node: Right-Parenthesis165564
Node: Single-Quote165930
Node: Semicolon166488
Node: Double-Quote169444
Ref: fig2.18170259
Node: Backquote170915
Node: Comma175710
Node: Sharpsign176035
Ref: fig2.19176983
Ref: SharpsignBackslash180397
Ref: SharpsignQuote181527
Ref: SharpsignLeftParen181880
Ref: SharpsignStar183278
Ref: SharpsignColon184715
Ref: SharpsignDot185139
Ref: SharpsignB185720
Ref: SharpsignO186001
Ref: SharpsignX186293
Ref: SharpsignR186701
Ref: fig2.20187332
Ref: SharpsignC187928
Ref: fig2.21188567
Ref: SharpsignA189037
Ref: SharpsignS190275
Ref: SharpsignP191310
Ref: SharpsignLeftAngle197934
Node: Re-Reading Abbreviated Expressions198607
Node: Evaluation and Compilation199123
Node: Evaluation199989
Node: Introduction to Environments201330
Ref: NullLexicalEnv204684
Ref: EnvObjs205034
Node: The Evaluation Model205857
Ref: SymbolsAsForms206466
Ref: fig3.1207996
Ref: ConstantVars210915
Ref: CLSpecialOps213913
Ref: fig3.3215910
Ref: FunctionForms216113
Ref: fig3.4218005
Ref: LambdaForms218479
Node: Lambda Expressions219883
Node: Closures and Lexical Binding220551
Node: Shadowing224151
Node: Extent227266
Node: Return Values229538
Ref: fig3.5230377
Node: Compilation230907
Node: Compiler Terminology231223
Node: Compilation Semantics235558
Ref: CompilerMacros236071
Ref: fig3.6237409
Ref: MinimalCompilation242445
Ref: SemanticConstraints243459
Node: File Compilation246943
Ref: TopLevelForms248926
Ref: fig3.7250282
Ref: fig3.8254798
Node: Literal Objects in Compiled Files255810
Ref: Similarity258545
Ref: CallingMakeLoadForm266494
Node: Exceptional Situations in the Compiler268931
Node: Declarations271051
Node: Minimal Declaration Processing Requirements271846
Node: Declaration Specifiers273004
Node: Declaration Identifiers273522
Ref: fig3.9273807
Node: Declaration Scope274538
Node: Lambda Lists279463
Ref: fig3.10279839
Ref: fig3.11281552
Node: Ordinary Lambda Lists282040
Ref: fig3.12282399
Ref: fig3.13282700
Ref: SuppressingKeyArgChecks290911
Node: Generic Function Lambda Lists296460
Ref: fig3.14297338
Node: Specialized Lambda Lists297866
Ref: fig3.15298383
Ref: fig3.16298571
Node: Macro Lambda Lists299213
Ref: fig3.17299502
Ref: fig3.18300640
Ref: DestructuringByLambdaLists304138
Node: Destructuring Lambda Lists308882
Node: Boa Lambda Lists310187
Node: Defsetf Lambda Lists314008
Ref: fig3.19314623
Node: Deftype Lambda Lists314966
Node: Define-modify-macro Lambda Lists315593
Ref: fig3.20316014
Node: Define-method-combination Arguments Lambda Lists316484
Ref: fig3.21317045
Node: Syntactic Interaction of Documentation Strings and Declarations317352
Node: Error Checking in Function Calls318109
Node: Argument Mismatch Detection318389
Ref: SafeAndUnsafeCalls318621
Ref: UnrecognizedKeyArgs322508
Ref: InvalidKeyArgs323004
Ref: OddNumberOfKeyArgs323494
Ref: DestructuringMismatch323944
Node: Traversal Rules and Side Effects325138
Node: Destructive Operations326395
Node: Modification of Literal Objects326707
Node: Transfer of Control during a Destructive Operation329123
Node: lambda (Symbol)330160
Node: lambda (Macro)331500
Node: compile332593
Node: eval335724
Node: eval-when337676
Node: load-time-value343934
Node: quote349720
Node: compiler-macro-function351298
Node: define-compiler-macro352301
Node: defmacro359149
Node: macro-function365202
Node: macroexpand; macroexpand-1367414
Ref: macroexpand367637
Ref: macroexpand-1367637
Node: define-symbol-macro372176
Node: symbol-macrolet374697
Node: *macroexpand-hook*377852
Node: proclaim380070
Ref: fig3.22380883
Node: declaim382168
Node: declare382984
Ref: fig3.23383660
Ref: fig3.24385194
Node: ignore; ignorable387010
Ref: ignore387200
Ref: ignorable387200
Node: dynamic-extent389051
Node: type395053
Node: inline; notinline401550
Ref: inline401728
Ref: notinline401728
Node: ftype405268
Node: declaration406783
Node: optimize407654
Ref: fig3.25408328
Node: special409871
Node: locally414047
Node: the416108
Node: special-operator-p418414
Node: constantp419309
Node: Types and Classes422226
Node: Introduction to Types and Classes423101
Node: Types425407
Node: Data Type Definition425629
Ref: TypeInfoXrefs426076
Node: Type Relationships427189
Node: Type Specifiers428964
Ref: StandardizedAtomicTypeSpecs429565
Ref: StandardizedCompoundTypeSpecNames433113
Ref: fig4.4433756
Ref: TypesAndDeclsNames434512
Ref: StandardizedTypeSpecifierNames435043
Node: Classes437533
Ref: ObjectSystemClasses437910
Node: Introduction to Classes438392
Node: Defining Classes443980
Node: Creating Instances of Classes445642
Node: Inheritance446494
Node: Determining the Class Precedence List448457
Node: Redefining Classes455837
Node: Integrating Types and Classes462409
Ref: ClassTypeCorrespondence466360
Node: nil (Type)468816
Node: boolean469243
Node: function (System Class)470056
Node: compiled-function474395
Node: generic-function475263
Node: standard-generic-function476291
Node: class476810
Node: built-in-class477329
Node: structure-class478252
Node: standard-class478653
Node: method479035
Node: standard-method480194
Node: structure-object480611
Node: standard-object481267
Node: method-combination481695
Node: t (System Class)482340
Node: satisfies482691
Node: member (Type Specifier)483835
Node: not (Type Specifier)484825
Node: and (Type Specifier)485506
Node: or (Type Specifier)486313
Node: values (Type Specifier)487325
Node: eql (Type Specifier)488531
Node: coerce489287
Node: deftype493940
Node: subtypep497138
Ref: fig4.9498284
Node: type-of504142
Node: typep506897
Node: type-error510316
Node: type-error-datum; type-error-expected-type511048
Ref: type-error-datum511304
Ref: type-error-expected-type511304
Node: simple-type-error512382
Node: Data and Control Flow513170
Node: Generalized Reference514647
Node: Overview of Places and Generalized Reference514953
Ref: fig5.1516181
Ref: fig5.2516629
Ref: GenRefSubFormEval517291
Ref: SetfExpansions520086
Ref: fig5.3522092
Ref: fig5.4522360
Ref: fig5.5522735
Ref: fig5.6523432
Node: Kinds of Places523926
Ref: FnFormsAsGenRefs524523
Ref: fig5.7524725
Ref: fig5.8526889
Ref: SETFofVALUES531955
Ref: SETFofAPPLY533261
Node: Treatment of Other Macros Based on SETF536233
Ref: fig5.9537559
Node: Transfer of Control to an Exit Point537639
Node: apply539448
Node: defun541476
Node: fdefinition545185
Node: fboundp547022
Node: fmakunbound548681
Node: flet; labels; macrolet549615
Ref: flet549822
Ref: labels549822
Ref: macrolet549822
Node: funcall557404
Node: function (Special Operator)559089
Node: function-lambda-expression561283
Node: functionp564335
Node: compiled-function-p565212
Node: call-arguments-limit566245
Node: lambda-list-keywords566859
Node: lambda-parameters-limit567638
Node: defconstant568269
Node: defparameter; defvar570950
Ref: defparameter571140
Ref: defvar571140
Node: destructuring-bind577354
Node: let; let*578713
Ref: let578886
Node: progv581859
Node: setq583348
Node: psetq584916
Node: block586752
Node: catch588497
Node: go591202
Node: return-from592643
Node: return594711
Node: tagbody595658
Ref: fig5.10597715
Node: throw597903
Node: unwind-protect600553
Node: nil (Constant Variable)605421
Node: not (Function)605839
Node: t (Constant Variable)606709
Node: eq607669
Ref: fig5.11609786
Node: eql (Function)609931
Node: equal612797
Ref: fig5.12614695
Node: equalp616390
Ref: fig5.13618406
Node: identity620247
Node: complement620986
Node: constantly622635
Node: every; some; notevery; notany623587
Ref: every623802
Ref: some623802
Node: and (Macro)626634
Node: cond628359
Node: if629911
Node: or (Macro)631080
Node: when; unless632443
Ref: when632608
Ref: unless632608
Node: case; ccase; ecase634875
Ref: case635072
Ref: ccase635072
Node: typecase; ctypecase; etypecase639781
Ref: typecase640009
Ref: ctypecase640009
Node: multiple-value-bind645170
Node: multiple-value-call647003
Node: multiple-value-list648207
Node: multiple-value-prog1649008
Node: multiple-value-setq649937
Node: values (Accessor)651480
Node: values-list653363
Node: multiple-values-limit654317
Node: nth-value655121
Node: prog; prog*656350
Node: prog1; prog2659913
Ref: prog1660066
Ref: prog2660066
Node: progn661898
Node: define-modify-macro663272
Node: defsetf665767
Node: define-setf-expander671699
Node: get-setf-expansion676434
Node: setf; psetf678140
Ref: setf678298
Ref: psetf678298
Node: shiftf680586
Node: rotatef683072
Node: control-error684810
Node: program-error685431
Node: undefined-function685971
Node: Iteration686567
Node: The LOOP Facility686798
Node: Overview of the Loop Facility687242
Ref: SimpleLoop687703
Ref: DestructuringLOOPVars701578
Node: Variable Initialization and Stepping Clauses705763
Node: Value Accumulation Clauses724781
Node: Termination Test Clauses732413
Node: Unconditional Execution Clauses739121
Node: Conditional Execution Clauses740265
Node: Miscellaneous Clauses743328
Node: Examples of Miscellaneous Loop Features746007
Node: Notes about Loop748916
Node: do; do*749934
Ref: do750068
Node: dotimes758109
Node: dolist761386
Node: loop763587
Node: loop-finish769216
Node: Objects771864
Node: Object Creation and Initialization773090
Node: Initialization Arguments777017
Node: Declaring the Validity of Initialization Arguments779588
Node: Defaulting of Initialization Arguments783078
Node: Rules for Initialization Arguments786362
Node: Shared-Initialize789813
Node: Initialize-Instance792565
Node: Definitions of Make-Instance and Initialize-Instance795330
Node: Changing the Class of an Instance797409
Node: Modifying the Structure of the Instance798633
Node: Initializing Newly Added Local Slots799492
Node: Customizing the Change of Class of an Instance801282
Node: Reinitializing an Instance802096
Node: Customizing Reinitialization803640
Node: Meta-Objects804316
Node: Standard Meta-objects804851
Node: Slots805802
Node: Introduction to Slots806035
Node: Accessing Slots808513
Node: Inheritance of Slots and Slot Options811114
Node: Generic Functions and Methods815854
Node: Introduction to Generic Functions816357
Ref: StdMethDefOps819431
Node: Introduction to Methods819841
Node: Agreement on Parameter Specializers and Qualifiers826114
Node: Congruent Lambda-lists for all Methods of a Generic Function827112
Node: Keyword Arguments in Generic Functions and Methods829276
Node: Method Selection and Combination832055
Ref: DeterminingtheEffectiveMethod833362
Ref: SelApplMeth833771
Ref: ApplyMethCombToSortedMethods835923
Ref: StdMethComb837810
Ref: BuiltInMethCombTypes843330
Ref: fig7.2843793
Node: Inheritance of Methods847195
Node: function-keywords847817
Node: ensure-generic-function849339
Node: allocate-instance852516
Node: reinitialize-instance854123
Node: shared-initialize (Standard Generic Function)856601
Node: update-instance-for-different-class861381
Node: update-instance-for-redefined-class865826
Node: change-class871094
Node: slot-boundp875092
Node: slot-exists-p876856
Node: slot-makunbound877656
Node: slot-missing879177
Node: slot-unbound881504
Node: slot-value883161
Node: method-qualifiers885820
Node: no-applicable-method886575
Node: no-next-method887689
Node: remove-method888835
Node: make-instance889649
Node: make-instances-obsolete891167
Node: make-load-form892496
Node: make-load-form-saving-slots903956
Node: with-accessors905907
Node: with-slots908657
Node: defclass911803
Node: defgeneric924356
Node: defmethod934368
Node: find-class941739
Node: next-method-p943786
Node: call-method; make-method944882
Ref: call-method945082
Node: call-next-method947833
Node: compute-applicable-methods951009
Node: define-method-combination952158
Node: find-method975492
Node: add-method978225
Node: initialize-instance (Standard Generic Function)979541
Node: class-name981547
Node: setf class-name982357
Node: class-of983000
Node: unbound-slot983935
Node: unbound-slot-instance984645
Node: Structures985260
Node: defstruct985434
Node: copy-structure1025279
Node: Conditions1025873
Node: Condition System Concepts1027022
Node: Condition Types1030649
Ref: StandardizedConditionTypes1030934
Ref: fig9.21032457
Ref: fig9.31032626
Node: Creating Conditions1033299
Ref: ConditionDesignators1033908
Node: Printing Conditions1035536
Node: Signaling and Handling Conditions1040501
Ref: fig9.41042473
Ref: Signaling1042611
Ref: fig9.51043488
Ref: Restarts1044588
Ref: InterfacesToRestarts1047696
Ref: fig9.61048077
Ref: AssocRestartWithCond1048852
Node: Assertions1049530
Ref: fig9.71049930
Node: Notes about the Condition System's Background1050038
Node: condition1050540
Node: warning1052254
Node: style-warning1052607
Node: serious-condition1053795
Node: error (Condition Type)1055025
Node: cell-error1055382
Node: cell-error-name1055985
Node: parse-error1057057
Node: storage-condition1057518
Node: assert1059104
Node: error (Function)1062881
Node: cerror1066372
Node: check-type1070810
Node: simple-error1074776
Node: invalid-method-error1075265
Node: method-combination-error1076838
Node: signal1077978
Node: simple-condition1080489
Node: simple-condition-format-control; simple-condition-format-arguments1081439
Ref: simple-condition-format-control1081753
Ref: simple-condition-format-arguments1081753
Node: warn1082807
Node: simple-warning1085164
Node: invoke-debugger1085623
Node: break1087101
Node: *debugger-hook*1089471
Node: *break-on-signals*1091790
Node: handler-bind1094253
Node: handler-case1096745
Node: ignore-errors1101712
Node: define-condition1103573
Node: make-condition1114255
Node: restart1115515
Node: compute-restarts1116130
Node: find-restart1118722
Node: invoke-restart1120670
Node: invoke-restart-interactively1122334
Node: restart-bind1124565
Node: restart-case1128622
Node: restart-name1137965
Node: with-condition-restarts1138872
Node: with-simple-restart1140239
Node: abort (Restart)1143460
Node: continue (Restart)1144501
Node: muffle-warning (Restart)1145685
Node: store-value (Restart)1147224
Node: use-value (Restart)1148492
Node: abort; continue; muffle-warning; store-value; use-value1149235
Ref: abort1149506
Ref: continue1149506
Ref: muffle-warning1149506
Ref: store-value1149506
Ref: use-value1149506
Node: Symbols1155054
Node: Symbol Concepts1155497
Ref: fig10.11155716
Ref: fig10.21155896
Node: symbol1156066
Node: keyword1161230
Node: symbolp1161812
Node: keywordp1162514
Node: make-symbol1163310
Node: copy-symbol1164872
Node: gensym1167128
Node: *gensym-counter*1169388
Node: gentemp1170137
Node: symbol-function1172921
Node: symbol-name1175658
Node: symbol-package1176332
Node: symbol-plist1178017
Node: symbol-value1179152
Node: get1180963
Node: remprop1183999
Node: boundp1186448
Node: makunbound1187385
Node: set1188109
Node: unbound-variable1189635
Node: Packages1190195
Node: Package Concepts1190912
Node: Introduction to Packages1191105
Ref: fig11.11191995
Node: Standardized Packages1200062
Ref: fig11.21200424
Node: package1209412
Node: export1209980
Node: find-symbol1213054
Node: find-package1215351
Node: find-all-symbols1216357
Node: import1217235
Node: list-all-packages1219720
Node: rename-package1220371
Node: shadow1221603
Node: shadowing-import1223888
Node: delete-package1225760
Node: make-package1230416
Node: with-package-iterator1232422
Node: unexport1237923
Node: unintern1239455
Node: in-package1241544
Node: unuse-package1242517
Node: use-package1243865
Node: defpackage1245932
Node: do-symbols; do-external-symbols; do-all-symbols1254263
Node: intern1257819
Node: package-name1260194
Node: package-nicknames1261202
Node: package-shadowing-symbols1261959
Node: package-use-list1263140
Node: package-used-by-list1264007
Node: packagep1264852
Node: *package*1265470
Node: package-error1266714
Node: package-error-package1267387
Node: Numbers1268066
Node: Number Concepts1270103
Node: Numeric Operations1270442
Ref: fig12.11270902
Ref: fig12.21271134
Ref: fig12.31271460
Ref: fig12.41271703
Ref: NumericContagionRules1274734
Ref: fig12.51275623
Ref: fig12.61276638
Node: Implementation-Dependent Numeric Constants1276815
Ref: fig12.71277170
Node: Rational Computations1278000
Ref: FloatSubstitutability1279570
Ref: fig12.81281151
Node: Floating-point Computations1282082
Ref: RuleOfFloatAndRationalContagion1282449
Ref: RuleOfFloatPrecisionContagion1285196
Node: Complex Computations1285321
Ref: RuleOfComplexContagion1285896
Ref: RuleOfCanonRepForComplexRationals1286164
Ref: fig12.91288035
Ref: fig12.101288421
Node: Interval Designators1288936
Node: Random-State Operations1290442
Ref: fig12.111290695
Node: number1290814
Node: complex (System Class)1291972
Node: real1294149
Node: float (System Class)1295296
Node: short-float; single-float; double-float; long-float1297852
Ref: fig12.121299020
Node: rational (System Class)1301811
Node: ratio1302858
Node: integer1303551
Node: signed-byte1305021
Node: unsigned-byte1306039
Node: mod (Type Specifier)1307156
Node: bit (Type)1307863
Node: fixnum1308210
Node: bignum1308680
Node: =; /=; <; >; <=; >=1308990
Ref: =1309154
Ref: fig12.131310736
Node: max; min1312359
Node: minusp; plusp1314243
Node: zerop1315162
Node: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround1316145
Ref: floor1316460
Ref: ceiling1316460
Ref: truncate1316460
Ref: round1316460
Node: sin; cos; tan1320951
Node: asin; acos; atan1321907
Ref: asin1322063
Ref: acos1322063
Ref: atan1322063
Ref: fig12.141322702
Ref: fig12.151326470
Node: pi1328488
Node: sinh; cosh; tanh; asinh; acosh; atanh1329565
Ref: fig12.161330321
Node: * (Function)1334145
Node: + (Function)1335167
Node: - (Function)1336122
Node: / (Function)1337416
Node: 1+; 1-1339058
Ref: 1+1339184
Ref: 1- (Function)1339184
Node: abs1340000
Node: evenp; oddp1341374
Node: exp; expt1342264
Ref: exp1342398
Ref: expt1342398
Node: gcd1345468
Node: incf; decf1346437
Ref: incf1346560
Ref: decf1346560
Node: lcm1347644
Node: log1348680
Node: mod; rem1350752
Node: signum1351960
Node: sqrt; isqrt1353598
Ref: sqrt1353742
Node: random-state1355613
Node: make-random-state1356485
Node: random1358348
Node: random-state-p1359807
Node: *random-state*1360544
Node: numberp1361875
Node: cis1362499
Node: complex (Function)1363111
Node: complexp1364687
Node: conjugate1365334
Node: phase1366046
Node: realpart; imagpart1367582
Ref: realpart1367760
Ref: imagpart1367760
Node: upgraded-complex-part-type1368571
Node: realp1369577
Node: numerator; denominator1370180
Node: rational; rationalize1371213
Ref: rational1371400
Node: rationalp1372729
Node: ash1373352
Node: integer-length1374811
Node: integerp1376341
Node: parse-integer1376948
Node: boole1379043
Ref: fig12.171379806
Node: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+1383377
Node: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+1384535
Ref: logand1384965
Ref: lognot1384965
Ref: fig12.181386201
Node: logbitp1388521
Node: logcount1389721
Node: logtest1391038
Node: byte; byte-size; byte-position1392088
Ref: byte1392291
Ref: byte-size1392291
Ref: byte-position1392291
Node: deposit-field1393309
Node: dpb1394319
Node: ldb1395657
Node: ldb-test1397169
Node: mask-field1397954
Node: most-positive-fixnum; most-negative-fixnum1399229
Node: decode-float; scale-float; float-radix; float-sign; float-digits; float+1399958
Node: float (Function)1405579
Node: floatp1406513
Node: most-positive-short-float; least-positive-short-float; least-positive-n+1407166
Node: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+1411531
Node: arithmetic-error1412909
Node: arithmetic-error-operands; arithmetic-error-operation1413746
Ref: arithmetic-error-operands1414030
Ref: arithmetic-error-operation1414030
Node: division-by-zero1414723
Node: floating-point-invalid-operation1415221
Node: floating-point-inexact1415998
Node: floating-point-overflow1416742
Node: floating-point-underflow1417243
Node: Characters1417718
Node: Character Concepts1418346
Node: Introduction to Characters1418833
Ref: fig13.11419572
Ref: fig13.21420045
Node: Introduction to Scripts and Repertoires1420209
Ref: CharScripts1420523
Ref: CharRepertoires1421369
Node: Character Attributes1422091
Node: Character Categories1423114
Ref: GraphicChars1424095
Ref: CharactersWithCase1425457
Ref: Digits1427660
Node: Identity of Characters1428258
Node: Ordering of Characters1428545
Node: Character Names1430175
Node: Treatment of Newline during Input and Output1431343
Node: Character Encodings1431907
Node: Documentation of Implementation-Defined Scripts1432715
Node: character (System Class)1434217
Node: base-char1434950
Node: standard-char1436935
Node: extended-char1437521
Node: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+1438040
Ref: char=1438507
Ref: char-equal1438507
Node: character (Function)1444058
Node: characterp1444960
Node: alpha-char-p1445851
Node: alphanumericp1447028
Node: digit-char1448382
Node: digit-char-p1449458
Node: graphic-char-p1450853
Node: standard-char-p1451796
Node: char-upcase; char-downcase1452623
Ref: char-upcase1452851
Ref: char-downcase1452851
Node: upper-case-p; lower-case-p; both-case-p1455078
Ref: upper-case-p1455326
Node: char-code1456710
Node: char-int1457434
Node: code-char1458392
Node: char-code-limit1459132
Node: char-name1459772
Node: name-char1461676
Node: Conses1462517
Node: Cons Concepts1463720
Ref: fig14.11463935
Node: Conses as Trees1464251
Ref: fig14.21464715
Node: Conses as Lists1465461
Ref: fig14.31466292
Ref: fig14.41467014
Ref: fig14.51467343
Node: list (System Class)1468099
Node: null (System Class)1469393
Node: cons (System Class)1469977
Node: atom (Type)1471250
Node: cons (Function)1471487
Node: consp1472333
Node: atom (Function)1473033
Node: rplaca; rplacd1473699
Ref: rplaca1473920
Node: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+1474801
Ref: car1475420
Ref: cdr1475420
Ref: fig14.61477945
Node: copy-tree1480580
Node: sublis; nsublis1482147
Node: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not1485825
Ref: subst1486131
Ref: nsubst1486131
Node: tree-equal1490143
Node: copy-list1491966
Node: list; list*1493169
Ref: list1493314
Node: list-length1494693
Node: listp1496451
Node: make-list1497211
Node: push1498125
Node: pop1499353
Node: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+1500722
Ref: first1501038
Node: nth1503344
Node: endp1504377
Node: null (Function)1505772
Node: nconc1506567
Node: append1508547
Node: revappend; nreconc1509629
Node: butlast; nbutlast1511669
Ref: butlast1511834
Node: last1513357
Node: ldiff; tailp1514964
Node: nthcdr1518340
Node: rest1519426
Node: member; member-if; member-if-not1520359
Ref: member1520594
Node: mapc; mapcar; mapcan; mapl; maplist; mapcon1522685
Node: acons1526844
Node: assoc; assoc-if; assoc-if-not1527848
Ref: assoc1528042
Node: copy-alist1530992
Node: pairlis1532200
Node: rassoc; rassoc-if; rassoc-if-not1533670
Ref: rassoc1533879
Node: get-properties1535795
Node: getf1537144
Node: remf1539857
Node: intersection; nintersection1541213
Ref: intersection1541396
Node: adjoin1545126
Node: pushnew1546971
Node: set-difference; nset-difference1549681
Ref: set-difference1549908
Node: set-exclusive-or; nset-exclusive-or1553037
Node: subsetp1556150
Node: union; nunion1558185
Ref: union1558314
Node: Arrays1561261
Node: Array Concepts1562179
Node: Array Elements1562349
Node: Specialized Arrays1565437
Ref: fig15.11566127
Ref: ArrayUpgrading1566766
Ref: RequiredSpecializedArrays1568040
Ref: fig15.21568480
Ref: fig15.31569185
Node: array1569376
Node: simple-array1572505
Node: vector (System Class)1574443
Node: simple-vector1576704
Node: bit-vector1577701
Node: simple-bit-vector1578839
Node: make-array1579808
Node: adjust-array1588135
Node: adjustable-array-p1596014
Node: aref1596951
Node: array-dimension1598568
Node: array-dimensions1599399
Node: array-element-type1600223
Node: array-has-fill-pointer-p1601581
Node: array-displacement1602695
Node: array-in-bounds-p1604327
Node: array-rank1605445
Node: array-row-major-index1606184
Node: array-total-size1607628
Node: arrayp1608831
Node: fill-pointer1609533
Node: row-major-aref1610601
Node: upgraded-array-element-type1611641
Node: array-dimension-limit1613237
Node: array-rank-limit1613736
Node: array-total-size-limit1614200
Node: simple-vector-p1614936
Node: svref1615668
Node: vector (Function)1616747
Node: vector-pop1617603
Node: vector-push; vector-push-extend1618848
Ref: vector-push1619050
Ref: vector-push-extend1619050
Node: vectorp1621603
Node: bit; sbit1622278
Ref: bit1622476
Ref: sbit1622476
Node: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+1623552
Ref: fig15.41626069
Node: bit-vector-p1627024
Node: simple-bit-vector-p1627847
Node: Strings1628528
Node: String Concepts1629056
Node: Implications of Strings Being Arrays1629268
Node: Subtypes of STRING1629768
Node: string (System Class)1630181
Node: base-string1631328
Node: simple-string1632254
Node: simple-base-string1633287
Node: simple-string-p1634186
Node: char; schar1634919
Ref: char1635077
Ref: schar1635077
Node: string (Function)1636303
Node: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+1637642
Node: string-trim; string-left-trim; string-right-trim1641703
Node: string=; string/=; string<; string>; string<=; string>=; string-equal; +1643442
Ref: string=1643976
Ref: string-equal1643976
Node: stringp1649143
Node: make-string1649822
Node: Sequences1650746
Node: Sequence Concepts1651458
Ref: SequenceFunctions1652222
Node: General Restrictions on Parameters that must be Sequences1653101
Node: Rules about Test Functions1653469
Node: Satisfying a Two-Argument Test1653735
Ref: SatisfyingTheTwoArgTest1653950
Ref: fig17.21654291
Node: Satisfying a One-Argument Test1657118
Ref: fig17.31657696
Node: sequence1659394
Node: copy-seq1660091
Node: elt1661209
Node: fill1662276
Node: make-sequence1663625
Node: subseq1665682
Node: map1667703
Node: map-into1670556
Node: reduce1673349
Node: count; count-if; count-if-not1676605
Node: length1678800
Node: reverse; nreverse1679773
Ref: reverse1679942
Ref: nreverse1679942
Node: sort; stable-sort1681887
Ref: sort1682076
Ref: stable-sort1682076
Node: find; find-if; find-if-not1687304
Ref: find1687532
Node: position; position-if; position-if-not1689683
Ref: position1689924
Node: search1691926
Node: mismatch1693913
Node: replace1696224
Node: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+1698559
Ref: substitute1698930
Ref: nsubstitute1698930
Node: concatenate1704518
Node: merge1706674
Node: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not1710956
Node: remove-duplicates; delete-duplicates1717283
Node: Hash Tables1720923
Node: Hash Table Concepts1721354
Node: Hash-Table Operations1721563
Ref: fig18.11723380
Node: Modifying Hash Table Keys1723547
Ref: VisModEQL1725037
Ref: VisModEQUAL1725279
Node: hash-table1728265
Node: make-hash-table1729096
Node: hash-table-p1731933
Node: hash-table-count1732639
Node: hash-table-rehash-size1733952
Node: hash-table-rehash-threshold1735446
Node: hash-table-size1736476
Node: hash-table-test1737253
Node: gethash1738116
Node: remhash1740120
Node: maphash1740911
Node: with-hash-table-iterator1742669
Node: clrhash1746029
Node: sxhash1746824
Node: Filenames1749854
Node: Overview of Filenames1750602
Node: Namestrings as Filenames1751389
Node: Pathnames as Filenames1752513
Ref: fig19.11755308
Node: Parsing Namestrings Into Pathnames1755872
Node: Pathnames1756612
Node: Pathname Components1756859
Node: Interpreting Pathname Component Values1758649
Ref: PathnameComponentCase1759738
Ref: PathnameCaseFuns1760097
Ref: SpecialComponentValues1761619
Ref: WildComponents1762106
Ref: UnspecificComponent1762976
Ref: WildcardRestrictions1764844
Ref: fig19.31768905
Ref: ConstructingPathnames1772508
Node: Merging Pathnames1773784
Node: Logical Pathnames1775232
Node: Syntax of Logical Pathname Namestrings1775483
Node: Logical Pathname Components1779683
Ref: LogicalPathCompUnspecific1779995
Node: pathname (System Class)1780326
Node: logical-pathname (System Class)1780748
Node: pathname (Function)1781468
Node: make-pathname1784122
Node: pathnamep1788671
Node: pathname-host; pathname-device; pathname-directory; pathname-name; path+1789538
Ref: pathname-host1789944
Node: load-logical-pathname-translations1794081
Node: logical-pathname-translations1795945
Node: logical-pathname (Function)1803393
Node: *default-pathname-defaults*1804841
Node: namestring; file-namestring; directory-namestring; host-namestring; eno+1806050
Ref: namestring1806430
Node: parse-namestring1809839
Node: wild-pathname-p1814694
Node: pathname-match-p1816966
Node: translate-logical-pathname1818302
Node: translate-pathname1821008
Node: merge-pathnames1827535
Node: Files1832244
Node: File System Concepts1832574
Ref: fig20.11833236
Node: Coercion of Streams to Pathnames1833564
Node: File Operations on Open and Closed Streams1834482
Ref: fig20.21835045
Ref: fig20.31835685
Node: Truenames1835786
Node: directory1838169
Node: probe-file1839863
Node: ensure-directories-exist1841275
Node: truename1842936
Node: file-author1845561
Node: file-write-date1846685
Node: rename-file1848031
Node: delete-file1850625
Node: file-error1852482
Node: file-error-pathname1853240
Node: Streams1853818
Node: Stream Concepts1855303
Node: Introduction to Streams1855570
Ref: fig21.11856178
Ref: InputStreamOps1857018
Ref: OutputStreamOps1857341
Ref: fig21.41858081
Ref: InteractiveStreams1859059
Ref: fig21.51861105
Node: Stream Variables1862116
Ref: StandardizedStreamVars1862770
Node: Stream Arguments to Standardized Functions1863459
Ref: OpenOrClosedStreamOps1863830
Ref: fig21.81864826
Node: Restrictions on Composite Streams1866064
Node: stream1866577
Node: broadcast-stream1867286
Node: concatenated-stream1870082
Node: echo-stream1871306
Node: file-stream1872056
Node: string-stream1872614
Node: synonym-stream1873217
Node: two-way-stream1874021
Node: input-stream-p; output-stream-p1874591
Ref: input-stream-p1874811
Ref: output-stream-p1874811
Node: interactive-stream-p1875681
Node: open-stream-p1876804
Node: stream-element-type1877700
Node: streamp1878974
Node: read-byte1879609
Node: write-byte1880977
Node: peek-char1882067
Node: read-char1884850
Node: read-char-no-hang1886636
Node: terpri; fresh-line1888731
Node: unread-char1890175
Node: write-char1892178
Node: read-line1893003
Node: write-string; write-line1894962
Ref: write-string1895149
Ref: write-line1895149
Node: read-sequence1896491
Node: write-sequence1898808
Node: file-length1900455
Node: file-position1901448
Node: file-string-length1905137
Node: open1905918
Node: stream-external-format1915756
Node: with-open-file1916630
Node: close1919863
Node: with-open-stream1922024
Node: listen1923245
Node: clear-input1924324
Node: finish-output; force-output; clear-output1925994
Ref: clear-output1926242
Node: y-or-n-p; yes-or-no-p1927693
Node: make-synonym-stream1930329
Node: synonym-stream-symbol1931402
Node: broadcast-stream-streams1931925
Node: make-broadcast-stream1932469
Node: make-two-way-stream1933483
Node: two-way-stream-input-stream; two-way-stream-output-stream1934561
Ref: two-way-stream-input-stream1934895
Ref: two-way-stream-output-stream1934895
Node: echo-stream-input-stream; echo-stream-output-stream1935424
Ref: echo-stream-input-stream1935743
Ref: echo-stream-output-stream1935743
Node: make-echo-stream1936248
Node: concatenated-stream-streams1937302
Node: make-concatenated-stream1938080
Node: get-output-stream-string1938969
Node: make-string-input-stream1940512
Node: make-string-output-stream1941648
Node: with-input-from-string1942739
Node: with-output-to-string1945266
Node: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+1947996
Ref: *debug-io*1948377
Ref: *error-output*1948377
Ref: *query-io*1948377
Ref: *standard-input*1948377
Ref: *standard-output*1948377
Ref: *trace-output*1948377
Node: *terminal-io*1952623
Node: stream-error1954174
Node: stream-error-stream1954815
Node: end-of-file1955564
Node: Printer1956044
Node: The Lisp Printer1956995
Node: Overview of The Lisp Printer1957271
Ref: StdPrinterControlVars1959151
Ref: fig22.21959631
Node: Printer Dispatching1960605
Node: Default Print-Object Methods1961264
Ref: PrintingIntegers1961700
Ref: PrintingRatios1962344
Ref: PrintingFloats1963009
Ref: PrintingComplexes1964566
Ref: PrintingCharacters1965244
Ref: PrintingSymbols1966062
Ref: ReadtableCasePrintEffect1969377
Ref: ReadtableCasePrintExamples1971043
Ref: PrintingStrings1973966
Ref: PrintingListsAndConses1974456
Ref: PrintingBitVectors1976682
Ref: PrintingOtherVectors1977125
Ref: PrintingOtherArrays1978520
Ref: PrintingRandomStates1981209
Ref: PrintingPathnames1981935
Ref: PrintingStructures1982409
Ref: PrintingOtherObjects1983241
Node: Examples of Printer Behavior1984002
Node: The Lisp Pretty Printer1985228
Node: Pretty Printer Concepts1985537
Ref: DynamicControlofOutput1987061
Ref: fig22.31989319
Ref: fig22.41990099
Ref: fig22.51990793
Ref: CompilingFormatStrings1990976
Ref: PPrintDispatchTables1991470
Node: Examples of using the Pretty Printer1993239
Node: Notes about the Pretty Printer's Background2004406
Node: Formatted Output2004938
Ref: fig22.62007511
Node: FORMAT Basic Output2009470
Node: FORMAT Radix Control2011990
Node: FORMAT Floating-Point Printers2015512
Node: FORMAT Printer Operations2027848
Node: FORMAT Pretty Printer Operations2030245
Ref: TildeUnderscore2030640
Ref: TildeLessThanLogicalBlock2030955
Ref: TildeI2034362
Node: FORMAT Layout Control2036297
Ref: TildeLessThanJustification2038710
Node: FORMAT Control-Flow Operations2042178
Node: FORMAT Miscellaneous Operations2049926
Node: FORMAT Miscellaneous Pseudo-Operations2052043
Node: Additional Information about FORMAT Operations2056896
Node: Examples of FORMAT2059110
Node: Notes about FORMAT2062763
Node: copy-pprint-dispatch2063427
Node: formatter2064178
Node: pprint-dispatch2065308
Node: pprint-exit-if-list-exhausted2066817
Node: pprint-fill; pprint-linear; pprint-tabular2068489
Ref: pprint-fill2068750
Node: pprint-indent2071977
Node: pprint-logical-block2073888
Node: pprint-newline2079463
Node: pprint-pop2083945
Node: pprint-tab2087233
Node: print-object2088619
Node: print-unreadable-object2093875
Node: set-pprint-dispatch2095666
Node: write; prin1; print; pprint; princ2097882
Ref: write2098145
Ref: fig22.72100047
Node: write-to-string; prin1-to-string; princ-to-string2102863
Ref: write-to-string2103150
Node: *print-array*2105795
Node: *print-base*; *print-radix*2106746
Node: *print-case*2108939
Node: *print-circle*2111214
Node: *print-escape*2112757
Node: *print-gensym*2113882
Node: *print-level*; *print-length*2114506
Ref: *print-length*2114713
Node: *print-lines*2117309
Node: *print-miser-width*2118654
Node: *print-pprint-dispatch*2119180
Node: *print-pretty*2120554
Node: *print-readably*2122252
Node: *print-right-margin*2125792
Node: print-not-readable2126647
Node: print-not-readable-object2127487
Node: format2128092
Node: Reader2129967
Node: Reader Concepts2130588
Node: Dynamic Control of the Lisp Reader2130860
Node: Effect of Readtable Case on the Lisp Reader2131311
Ref: ReadtableCaseReadExamples2132456
Node: Argument Conventions of Some Reader Functions2133571
Node: readtable2137902
Node: copy-readtable2138773
Node: make-dispatch-macro-character2140601
Node: read; read-preserving-whitespace2141867
Ref: read2142103
Ref: read-preserving-whitespace2142103
Node: read-delimited-list2147060
Node: read-from-string2150737
Node: readtable-case2153192
Node: readtablep2154623
Node: set-dispatch-macro-character; get-dispatch-macro-character2155293
Ref: set-dispatch-macro-character2155609
Node: set-macro-character; get-macro-character2158345
Ref: set-macro-character2158635
Node: set-syntax-from-char2160885
Node: with-standard-io-syntax2163093
Ref: fig23.12163807
Node: *read-base*2165098
Node: *read-default-float-format*2166360
Node: *read-eval*2167834
Node: *read-suppress*2168538
Node: *readtable*2172179
Node: reader-error2173209
Node: System Construction2173764
Node: System Construction Concepts2174257
Node: Loading2174472
Node: Features2175423
Ref: FeatureExpressions2175934
Ref: FeatureExpExamples2176875
Ref: fig24.12177301
Node: compile-file2178598
Node: compile-file-pathname2183684
Node: load2185864
Node: with-compilation-unit2191318
Node: *features*2193500
Node: *compile-file-pathname*; *compile-file-truename*2199042
Node: *load-pathname*; *load-truename*2200389
Node: *compile-print*; *compile-verbose*2201672
Node: *load-print*; *load-verbose*2202312
Ref: *load-verbose*2202544
Node: *modules*2202979
Node: provide; require2203545
Ref: provide2203698
Ref: require2203698
Node: Environment2206406
Node: The External Environment2207256
Node: Top level loop2207511
Ref: fig25.12208226
Node: Debugging Utilities2208348
Ref: fig25.22208600
Node: Environment Inquiry2208856
Ref: fig25.32209259
Node: Time2209565
Ref: fig25.42210506
Ref: DecodedTime2210774
Ref: fig25.52212110
Ref: UniversalTime2212261
Ref: fig25.62213043
Ref: InternalTime2213221
Ref: fig25.72213522
Ref: fig25.82214081
Node: decode-universal-time2214146
Node: encode-universal-time2216055
Node: get-universal-time; get-decoded-time2217207
Ref: get-universal-time2217438
Ref: get-decoded-time2217438
Node: sleep2219341
Node: apropos; apropos-list2220413
Node: describe2221969
Node: describe-object2223842
Node: trace; untrace2226680
Ref: trace2226832
Node: step2229460
Node: time (Macro)2230799
Node: internal-time-units-per-second2232671
Node: get-internal-real-time2233264
Node: get-internal-run-time2234118
Node: disassemble2235452
Node: documentation; setf documentation2236824
Ref: documentation2237073
Node: room2243466
Node: ed2244591
Node: inspect2246115
Node: dribble2247010
Node: - (Variable)2248932
Node: +; ++; +++2249615
Node: *; **; ***2250661
Node: /; //; ///2252161
Node: lisp-implementation-type; lisp-implementation-version2253371
Node: short-site-name; long-site-name2254548
Node: machine-instance2255524
Node: machine-type2256311
Node: machine-version2256950
Node: software-type; software-version2257670
Node: user-homedir-pathname2258695
Node: Glossary2260049
Node: Glossary Notation2260354
Node: Non-alphabetic2263256
Ref: glos-()2263391
Node: A2263520
Ref: glos-absolute2263619
Ref: glos-actual adjustability2264979
Ref: glos-association list2270421
Node: B2272320
Ref: glos-binary2272967
Ref: glos-boolean2276015
Ref: glos-bound2276410
Node: C2279629
Ref: glos-cell2282326
Ref: glos-character2282555
Ref: glos-close2285687
Node: D2302421
Ref: glos-decoded time2303992
Ref: glos-denormalized2305987
Node: E2311855
Ref: glos-empty list2314046
Ref: fig26.12319629
Ref: glos-expressed adjustability2320171
Ref: glos-extended function designator2322637
Node: F2325151
Ref: glos-function designator2333096
Node: G2335555
Ref: glos-generalized boolean2335772
Node: H2338778
Node: I2339511
Ref: fig26.22339813
Ref: glos-improper list2342440
Ref: glos-indefinite extent2342584
Ref: fig26.32347384
Node: K2347708
Node: L2348734
Node: M2358267
Ref: glos-modified lambda list2361899
Node: N2363249
Ref: glos-nil2365529
Ref: glos-non-graphic2366530
Node: O2369392
Ref: glos-ordinary lambda list2371745
Node: P2372397
Ref: glos-parallel2374349
Ref: glos-proper list2381788
Node: Q2383762
Node: R2384451
Ref: glos-reader2385992
Ref: glos-relative2388394
Ref: fig26.42390329
Node: S2391334
Ref: glos-sequential2395807
Ref: glos-subclass2410249
Ref: glos-subtype2411007
Ref: glos-supplied-p parameter2411586
Node: T2413465
Ref: glos-t2413544
Node: U2419405
Ref: glos-unbound2419490
Node: V2423329
Node: W2427802
Node: Y2429344
Node: Appendix2429529
Node: Removed Language Features2429695
Node: Requirements for removed and deprecated features2430048
Node: Removed Types2431267
Node: Removed Operators2431509
Node: Removed Argument Conventions2431898
Node: Removed Variables2432225
Node: Removed Reader Syntax2432598
Node: Packages No Longer Required2432863
Node: Index2433245
Node: Symbol Index2599562
Node: List of Figures2709500

End Tag Table
