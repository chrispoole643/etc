This is libc.info, produced by makeinfo version 4.8 from libc.texinfo.

INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* Libc: (libc).                 C library.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION GNU C library functions and macros
START-INFO-DIR-ENTRY
* ALTWERASE: (libc)Local Modes.
* ARGP_ERR_UNKNOWN: (libc)Argp Parser Functions.
* ARG_MAX: (libc)General Limits.
* BC_BASE_MAX: (libc)Utility Limits.
* BC_DIM_MAX: (libc)Utility Limits.
* BC_SCALE_MAX: (libc)Utility Limits.
* BC_STRING_MAX: (libc)Utility Limits.
* BRKINT: (libc)Input Modes.
* BUFSIZ: (libc)Controlling Buffering.
* CCTS_OFLOW: (libc)Control Modes.
* CHILD_MAX: (libc)General Limits.
* CIGNORE: (libc)Control Modes.
* CLK_TCK: (libc)CPU Time.
* CLOCAL: (libc)Control Modes.
* CLOCKS_PER_SEC: (libc)CPU Time.
* COLL_WEIGHTS_MAX: (libc)Utility Limits.
* CPU_CLR: (libc)CPU Affinity.
* CPU_ISSET: (libc)CPU Affinity.
* CPU_SET: (libc)CPU Affinity.
* CPU_SETSIZE: (libc)CPU Affinity.
* CPU_ZERO: (libc)CPU Affinity.
* CREAD: (libc)Control Modes.
* CRTS_IFLOW: (libc)Control Modes.
* CS5: (libc)Control Modes.
* CS6: (libc)Control Modes.
* CS7: (libc)Control Modes.
* CS8: (libc)Control Modes.
* CSIZE: (libc)Control Modes.
* CSTOPB: (libc)Control Modes.
* DES_FAILED: (libc)DES Encryption.
* DTTOIF: (libc)Directory Entries.
* E2BIG: (libc)Error Codes.
* EACCES: (libc)Error Codes.
* EADDRINUSE: (libc)Error Codes.
* EADDRNOTAVAIL: (libc)Error Codes.
* EADV: (libc)Error Codes.
* EAFNOSUPPORT: (libc)Error Codes.
* EAGAIN: (libc)Error Codes.
* EALREADY: (libc)Error Codes.
* EAUTH: (libc)Error Codes.
* EBACKGROUND: (libc)Error Codes.
* EBADE: (libc)Error Codes.
* EBADF: (libc)Error Codes.
* EBADFD: (libc)Error Codes.
* EBADMSG: (libc)Error Codes.
* EBADR: (libc)Error Codes.
* EBADRPC: (libc)Error Codes.
* EBADRQC: (libc)Error Codes.
* EBADSLT: (libc)Error Codes.
* EBFONT: (libc)Error Codes.
* EBUSY: (libc)Error Codes.
* ECANCELED: (libc)Error Codes.
* ECHILD: (libc)Error Codes.
* ECHO: (libc)Local Modes.
* ECHOCTL: (libc)Local Modes.
* ECHOE: (libc)Local Modes.
* ECHOK: (libc)Local Modes.
* ECHOKE: (libc)Local Modes.
* ECHONL: (libc)Local Modes.
* ECHOPRT: (libc)Local Modes.
* ECHRNG: (libc)Error Codes.
* ECOMM: (libc)Error Codes.
* ECONNABORTED: (libc)Error Codes.
* ECONNREFUSED: (libc)Error Codes.
* ECONNRESET: (libc)Error Codes.
* ED: (libc)Error Codes.
* EDEADLK: (libc)Error Codes.
* EDEADLOCK: (libc)Error Codes.
* EDESTADDRREQ: (libc)Error Codes.
* EDIED: (libc)Error Codes.
* EDOM: (libc)Error Codes.
* EDOTDOT: (libc)Error Codes.
* EDQUOT: (libc)Error Codes.
* EEXIST: (libc)Error Codes.
* EFAULT: (libc)Error Codes.
* EFBIG: (libc)Error Codes.
* EFTYPE: (libc)Error Codes.
* EGRATUITOUS: (libc)Error Codes.
* EGREGIOUS: (libc)Error Codes.
* EHOSTDOWN: (libc)Error Codes.
* EHOSTUNREACH: (libc)Error Codes.
* EIDRM: (libc)Error Codes.
* EIEIO: (libc)Error Codes.
* EILSEQ: (libc)Error Codes.
* EINPROGRESS: (libc)Error Codes.
* EINTR: (libc)Error Codes.
* EINVAL: (libc)Error Codes.
* EIO: (libc)Error Codes.
* EISCONN: (libc)Error Codes.
* EISDIR: (libc)Error Codes.
* EISNAM: (libc)Error Codes.
* EKEYEXPIRED: (libc)Error Codes.
* EKEYREJECTED: (libc)Error Codes.
* EKEYREVOKED: (libc)Error Codes.
* EL2HLT: (libc)Error Codes.
* EL2NSYNC: (libc)Error Codes.
* EL3HLT: (libc)Error Codes.
* EL3RST: (libc)Error Codes.
* ELIBACC: (libc)Error Codes.
* ELIBBAD: (libc)Error Codes.
* ELIBEXEC: (libc)Error Codes.
* ELIBMAX: (libc)Error Codes.
* ELIBSCN: (libc)Error Codes.
* ELNRNG: (libc)Error Codes.
* ELOOP: (libc)Error Codes.
* EMEDIUMTYPE: (libc)Error Codes.
* EMFILE: (libc)Error Codes.
* EMLINK: (libc)Error Codes.
* EMSGSIZE: (libc)Error Codes.
* EMULTIHOP: (libc)Error Codes.
* ENAMETOOLONG: (libc)Error Codes.
* ENAVAIL: (libc)Error Codes.
* ENEEDAUTH: (libc)Error Codes.
* ENETDOWN: (libc)Error Codes.
* ENETRESET: (libc)Error Codes.
* ENETUNREACH: (libc)Error Codes.
* ENFILE: (libc)Error Codes.
* ENOANO: (libc)Error Codes.
* ENOBUFS: (libc)Error Codes.
* ENOCSI: (libc)Error Codes.
* ENODATA: (libc)Error Codes.
* ENODEV: (libc)Error Codes.
* ENOENT: (libc)Error Codes.
* ENOEXEC: (libc)Error Codes.
* ENOKEY: (libc)Error Codes.
* ENOLCK: (libc)Error Codes.
* ENOLINK: (libc)Error Codes.
* ENOMEDIUM: (libc)Error Codes.
* ENOMEM: (libc)Error Codes.
* ENOMSG: (libc)Error Codes.
* ENONET: (libc)Error Codes.
* ENOPKG: (libc)Error Codes.
* ENOPROTOOPT: (libc)Error Codes.
* ENOSPC: (libc)Error Codes.
* ENOSR: (libc)Error Codes.
* ENOSTR: (libc)Error Codes.
* ENOSYS: (libc)Error Codes.
* ENOTBLK: (libc)Error Codes.
* ENOTCONN: (libc)Error Codes.
* ENOTDIR: (libc)Error Codes.
* ENOTEMPTY: (libc)Error Codes.
* ENOTNAM: (libc)Error Codes.
* ENOTRECOVERABLE: (libc)Error Codes.
* ENOTSOCK: (libc)Error Codes.
* ENOTSUP: (libc)Error Codes.
* ENOTTY: (libc)Error Codes.
* ENOTUNIQ: (libc)Error Codes.
* ENXIO: (libc)Error Codes.
* EOF: (libc)EOF and Errors.
* EOPNOTSUPP: (libc)Error Codes.
* EOVERFLOW: (libc)Error Codes.
* EOWNERDEAD: (libc)Error Codes.
* EPERM: (libc)Error Codes.
* EPFNOSUPPORT: (libc)Error Codes.
* EPIPE: (libc)Error Codes.
* EPROCLIM: (libc)Error Codes.
* EPROCUNAVAIL: (libc)Error Codes.
* EPROGMISMATCH: (libc)Error Codes.
* EPROGUNAVAIL: (libc)Error Codes.
* EPROTO: (libc)Error Codes.
* EPROTONOSUPPORT: (libc)Error Codes.
* EPROTOTYPE: (libc)Error Codes.
* EQUIV_CLASS_MAX: (libc)Utility Limits.
* ERANGE: (libc)Error Codes.
* EREMCHG: (libc)Error Codes.
* EREMOTE: (libc)Error Codes.
* EREMOTEIO: (libc)Error Codes.
* ERESTART: (libc)Error Codes.
* ERFKILL: (libc)Error Codes.
* EROFS: (libc)Error Codes.
* ERPCMISMATCH: (libc)Error Codes.
* ESHUTDOWN: (libc)Error Codes.
* ESOCKTNOSUPPORT: (libc)Error Codes.
* ESPIPE: (libc)Error Codes.
* ESRCH: (libc)Error Codes.
* ESRMNT: (libc)Error Codes.
* ESTALE: (libc)Error Codes.
* ESTRPIPE: (libc)Error Codes.
* ETIME: (libc)Error Codes.
* ETIMEDOUT: (libc)Error Codes.
* ETOOMANYREFS: (libc)Error Codes.
* ETXTBSY: (libc)Error Codes.
* EUCLEAN: (libc)Error Codes.
* EUNATCH: (libc)Error Codes.
* EUSERS: (libc)Error Codes.
* EWOULDBLOCK: (libc)Error Codes.
* EXDEV: (libc)Error Codes.
* EXFULL: (libc)Error Codes.
* EXIT_FAILURE: (libc)Exit Status.
* EXIT_SUCCESS: (libc)Exit Status.
* EXPR_NEST_MAX: (libc)Utility Limits.
* FD_CLOEXEC: (libc)Descriptor Flags.
* FD_CLR: (libc)Waiting for I/O.
* FD_ISSET: (libc)Waiting for I/O.
* FD_SET: (libc)Waiting for I/O.
* FD_SETSIZE: (libc)Waiting for I/O.
* FD_ZERO: (libc)Waiting for I/O.
* FILENAME_MAX: (libc)Limits for Files.
* FLUSHO: (libc)Local Modes.
* FOPEN_MAX: (libc)Opening Streams.
* FP_ILOGB0: (libc)Exponents and Logarithms.
* FP_ILOGBNAN: (libc)Exponents and Logarithms.
* F_DUPFD: (libc)Duplicating Descriptors.
* F_GETFD: (libc)Descriptor Flags.
* F_GETFL: (libc)Getting File Status Flags.
* F_GETLK: (libc)File Locks.
* F_GETOWN: (libc)Interrupt Input.
* F_OK: (libc)Testing File Access.
* F_SETFD: (libc)Descriptor Flags.
* F_SETFL: (libc)Getting File Status Flags.
* F_SETLK: (libc)File Locks.
* F_SETLKW: (libc)File Locks.
* F_SETOWN: (libc)Interrupt Input.
* HUGE_VAL: (libc)Math Error Reporting.
* HUGE_VALF: (libc)Math Error Reporting.
* HUGE_VALL: (libc)Math Error Reporting.
* HUPCL: (libc)Control Modes.
* I: (libc)Complex Numbers.
* ICANON: (libc)Local Modes.
* ICRNL: (libc)Input Modes.
* IEXTEN: (libc)Local Modes.
* IFNAMSIZ: (libc)Interface Naming.
* IFTODT: (libc)Directory Entries.
* IGNBRK: (libc)Input Modes.
* IGNCR: (libc)Input Modes.
* IGNPAR: (libc)Input Modes.
* IMAXBEL: (libc)Input Modes.
* INADDR_ANY: (libc)Host Address Data Type.
* INADDR_BROADCAST: (libc)Host Address Data Type.
* INADDR_LOOPBACK: (libc)Host Address Data Type.
* INADDR_NONE: (libc)Host Address Data Type.
* INFINITY: (libc)Infinity and NaN.
* INLCR: (libc)Input Modes.
* INPCK: (libc)Input Modes.
* IPPORT_RESERVED: (libc)Ports.
* IPPORT_USERRESERVED: (libc)Ports.
* ISIG: (libc)Local Modes.
* ISTRIP: (libc)Input Modes.
* IXANY: (libc)Input Modes.
* IXOFF: (libc)Input Modes.
* IXON: (libc)Input Modes.
* LINE_MAX: (libc)Utility Limits.
* LINK_MAX: (libc)Limits for Files.
* L_ctermid: (libc)Identifying the Terminal.
* L_cuserid: (libc)Who Logged In.
* L_tmpnam: (libc)Temporary Files.
* MAXNAMLEN: (libc)Limits for Files.
* MAXSYMLINKS: (libc)Symbolic Links.
* MAX_CANON: (libc)Limits for Files.
* MAX_INPUT: (libc)Limits for Files.
* MB_CUR_MAX: (libc)Selecting the Conversion.
* MB_LEN_MAX: (libc)Selecting the Conversion.
* MDMBUF: (libc)Control Modes.
* MSG_DONTROUTE: (libc)Socket Data Options.
* MSG_OOB: (libc)Socket Data Options.
* MSG_PEEK: (libc)Socket Data Options.
* NAME_MAX: (libc)Limits for Files.
* NAN: (libc)Infinity and NaN.
* NCCS: (libc)Mode Data Types.
* NGROUPS_MAX: (libc)General Limits.
* NOFLSH: (libc)Local Modes.
* NOKERNINFO: (libc)Local Modes.
* NSIG: (libc)Standard Signals.
* NULL: (libc)Null Pointer Constant.
* ONLCR: (libc)Output Modes.
* ONOEOT: (libc)Output Modes.
* OPEN_MAX: (libc)General Limits.
* OPOST: (libc)Output Modes.
* OXTABS: (libc)Output Modes.
* O_ACCMODE: (libc)Access Modes.
* O_APPEND: (libc)Operating Modes.
* O_ASYNC: (libc)Operating Modes.
* O_CREAT: (libc)Open-time Flags.
* O_EXCL: (libc)Open-time Flags.
* O_EXEC: (libc)Access Modes.
* O_EXLOCK: (libc)Open-time Flags.
* O_FSYNC: (libc)Operating Modes.
* O_IGNORE_CTTY: (libc)Open-time Flags.
* O_NDELAY: (libc)Operating Modes.
* O_NOATIME: (libc)Operating Modes.
* O_NOCTTY: (libc)Open-time Flags.
* O_NOLINK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Operating Modes.
* O_NOTRANS: (libc)Open-time Flags.
* O_RDONLY: (libc)Access Modes.
* O_RDWR: (libc)Access Modes.
* O_READ: (libc)Access Modes.
* O_SHLOCK: (libc)Open-time Flags.
* O_SYNC: (libc)Operating Modes.
* O_TRUNC: (libc)Open-time Flags.
* O_WRITE: (libc)Access Modes.
* O_WRONLY: (libc)Access Modes.
* PARENB: (libc)Control Modes.
* PARMRK: (libc)Input Modes.
* PARODD: (libc)Control Modes.
* PATH_MAX: (libc)Limits for Files.
* PA_FLAG_MASK: (libc)Parsing a Template String.
* PENDIN: (libc)Local Modes.
* PF_FILE: (libc)Local Namespace Details.
* PF_INET6: (libc)Internet Namespace.
* PF_INET: (libc)Internet Namespace.
* PF_LOCAL: (libc)Local Namespace Details.
* PF_UNIX: (libc)Local Namespace Details.
* PIPE_BUF: (libc)Limits for Files.
* P_tmpdir: (libc)Temporary Files.
* RAND_MAX: (libc)ISO Random.
* RE_DUP_MAX: (libc)General Limits.
* RLIM_INFINITY: (libc)Limits on Resources.
* R_OK: (libc)Testing File Access.
* SA_NOCLDSTOP: (libc)Flags for Sigaction.
* SA_ONSTACK: (libc)Flags for Sigaction.
* SA_RESTART: (libc)Flags for Sigaction.
* SEEK_CUR: (libc)File Positioning.
* SEEK_END: (libc)File Positioning.
* SEEK_SET: (libc)File Positioning.
* SIGABRT: (libc)Program Error Signals.
* SIGALRM: (libc)Alarm Signals.
* SIGBUS: (libc)Program Error Signals.
* SIGCHLD: (libc)Job Control Signals.
* SIGCLD: (libc)Job Control Signals.
* SIGCONT: (libc)Job Control Signals.
* SIGEMT: (libc)Program Error Signals.
* SIGFPE: (libc)Program Error Signals.
* SIGHUP: (libc)Termination Signals.
* SIGILL: (libc)Program Error Signals.
* SIGINFO: (libc)Miscellaneous Signals.
* SIGINT: (libc)Termination Signals.
* SIGIO: (libc)Asynchronous I/O Signals.
* SIGIOT: (libc)Program Error Signals.
* SIGKILL: (libc)Termination Signals.
* SIGLOST: (libc)Operation Error Signals.
* SIGPIPE: (libc)Operation Error Signals.
* SIGPOLL: (libc)Asynchronous I/O Signals.
* SIGPROF: (libc)Alarm Signals.
* SIGQUIT: (libc)Termination Signals.
* SIGSEGV: (libc)Program Error Signals.
* SIGSTOP: (libc)Job Control Signals.
* SIGSYS: (libc)Program Error Signals.
* SIGTERM: (libc)Termination Signals.
* SIGTRAP: (libc)Program Error Signals.
* SIGTSTP: (libc)Job Control Signals.
* SIGTTIN: (libc)Job Control Signals.
* SIGTTOU: (libc)Job Control Signals.
* SIGURG: (libc)Asynchronous I/O Signals.
* SIGUSR1: (libc)Miscellaneous Signals.
* SIGUSR2: (libc)Miscellaneous Signals.
* SIGVTALRM: (libc)Alarm Signals.
* SIGWINCH: (libc)Miscellaneous Signals.
* SIGXCPU: (libc)Operation Error Signals.
* SIGXFSZ: (libc)Operation Error Signals.
* SIG_ERR: (libc)Basic Signal Handling.
* SOCK_DGRAM: (libc)Communication Styles.
* SOCK_RAW: (libc)Communication Styles.
* SOCK_RDM: (libc)Communication Styles.
* SOCK_SEQPACKET: (libc)Communication Styles.
* SOCK_STREAM: (libc)Communication Styles.
* SOL_SOCKET: (libc)Socket-Level Options.
* SSIZE_MAX: (libc)General Limits.
* STREAM_MAX: (libc)General Limits.
* SUN_LEN: (libc)Local Namespace Details.
* SV_INTERRUPT: (libc)BSD Handler.
* SV_ONSTACK: (libc)BSD Handler.
* SV_RESETHAND: (libc)BSD Handler.
* S_IFMT: (libc)Testing File Type.
* S_ISBLK: (libc)Testing File Type.
* S_ISCHR: (libc)Testing File Type.
* S_ISDIR: (libc)Testing File Type.
* S_ISFIFO: (libc)Testing File Type.
* S_ISLNK: (libc)Testing File Type.
* S_ISREG: (libc)Testing File Type.
* S_ISSOCK: (libc)Testing File Type.
* S_TYPEISMQ: (libc)Testing File Type.
* S_TYPEISSEM: (libc)Testing File Type.
* S_TYPEISSHM: (libc)Testing File Type.
* TMP_MAX: (libc)Temporary Files.
* TOSTOP: (libc)Local Modes.
* TZNAME_MAX: (libc)General Limits.
* VDISCARD: (libc)Other Special.
* VDSUSP: (libc)Signal Characters.
* VEOF: (libc)Editing Characters.
* VEOL2: (libc)Editing Characters.
* VEOL: (libc)Editing Characters.
* VERASE: (libc)Editing Characters.
* VINTR: (libc)Signal Characters.
* VKILL: (libc)Editing Characters.
* VLNEXT: (libc)Other Special.
* VMIN: (libc)Noncanonical Input.
* VQUIT: (libc)Signal Characters.
* VREPRINT: (libc)Editing Characters.
* VSTART: (libc)Start/Stop Characters.
* VSTATUS: (libc)Other Special.
* VSTOP: (libc)Start/Stop Characters.
* VSUSP: (libc)Signal Characters.
* VTIME: (libc)Noncanonical Input.
* VWERASE: (libc)Editing Characters.
* WCHAR_MAX: (libc)Extended Char Intro.
* WCHAR_MIN: (libc)Extended Char Intro.
* WCOREDUMP: (libc)Process Completion Status.
* WEOF: (libc)EOF and Errors.
* WEOF: (libc)Extended Char Intro.
* WEXITSTATUS: (libc)Process Completion Status.
* WIFEXITED: (libc)Process Completion Status.
* WIFSIGNALED: (libc)Process Completion Status.
* WIFSTOPPED: (libc)Process Completion Status.
* WSTOPSIG: (libc)Process Completion Status.
* WTERMSIG: (libc)Process Completion Status.
* W_OK: (libc)Testing File Access.
* X_OK: (libc)Testing File Access.
* _Complex_I: (libc)Complex Numbers.
* _Exit: (libc)Termination Internals.
* _IOFBF: (libc)Controlling Buffering.
* _IOLBF: (libc)Controlling Buffering.
* _IONBF: (libc)Controlling Buffering.
* _Imaginary_I: (libc)Complex Numbers.
* _PATH_UTMP: (libc)Manipulating the Database.
* _PATH_WTMP: (libc)Manipulating the Database.
* _POSIX2_C_DEV: (libc)System Options.
* _POSIX2_C_VERSION: (libc)Version Supported.
* _POSIX2_FORT_DEV: (libc)System Options.
* _POSIX2_FORT_RUN: (libc)System Options.
* _POSIX2_LOCALEDEF: (libc)System Options.
* _POSIX2_SW_DEV: (libc)System Options.
* _POSIX_CHOWN_RESTRICTED: (libc)Options for Files.
* _POSIX_JOB_CONTROL: (libc)System Options.
* _POSIX_NO_TRUNC: (libc)Options for Files.
* _POSIX_SAVED_IDS: (libc)System Options.
* _POSIX_VDISABLE: (libc)Options for Files.
* _POSIX_VERSION: (libc)Version Supported.
* __fbufsize: (libc)Controlling Buffering.
* __flbf: (libc)Controlling Buffering.
* __fpending: (libc)Controlling Buffering.
* __fpurge: (libc)Flushing Buffers.
* __freadable: (libc)Opening Streams.
* __freading: (libc)Opening Streams.
* __fsetlocking: (libc)Streams and Threads.
* __fwritable: (libc)Opening Streams.
* __fwriting: (libc)Opening Streams.
* __gconv_end_fct: (libc)glibc iconv Implementation.
* __gconv_fct: (libc)glibc iconv Implementation.
* __gconv_init_fct: (libc)glibc iconv Implementation.
* __va_copy: (libc)Argument Macros.
* _exit: (libc)Termination Internals.
* _flushlbf: (libc)Flushing Buffers.
* _tolower: (libc)Case Conversion.
* _toupper: (libc)Case Conversion.
* a64l: (libc)Encode Binary Data.
* abort: (libc)Aborting a Program.
* abs: (libc)Absolute Value.
* accept: (libc)Accepting Connections.
* access: (libc)Testing File Access.
* acos: (libc)Inverse Trig Functions.
* acosf: (libc)Inverse Trig Functions.
* acosh: (libc)Hyperbolic Functions.
* acoshf: (libc)Hyperbolic Functions.
* acoshl: (libc)Hyperbolic Functions.
* acosl: (libc)Inverse Trig Functions.
* addmntent: (libc)mtab.
* addseverity: (libc)Adding Severity Classes.
* adjtime: (libc)High-Resolution Calendar.
* adjtimex: (libc)High-Resolution Calendar.
* aio_cancel64: (libc)Cancel AIO Operations.
* aio_cancel: (libc)Cancel AIO Operations.
* aio_error64: (libc)Status of AIO Operations.
* aio_error: (libc)Status of AIO Operations.
* aio_fsync64: (libc)Synchronizing AIO Operations.
* aio_fsync: (libc)Synchronizing AIO Operations.
* aio_init: (libc)Configuration of AIO.
* aio_read64: (libc)Asynchronous Reads/Writes.
* aio_read: (libc)Asynchronous Reads/Writes.
* aio_return64: (libc)Status of AIO Operations.
* aio_return: (libc)Status of AIO Operations.
* aio_suspend64: (libc)Synchronizing AIO Operations.
* aio_suspend: (libc)Synchronizing AIO Operations.
* aio_write64: (libc)Asynchronous Reads/Writes.
* aio_write: (libc)Asynchronous Reads/Writes.
* alarm: (libc)Setting an Alarm.
* alloca: (libc)Variable Size Automatic.
* alphasort64: (libc)Scanning Directory Content.
* alphasort: (libc)Scanning Directory Content.
* argp_error: (libc)Argp Helper Functions.
* argp_failure: (libc)Argp Helper Functions.
* argp_help: (libc)Argp Help.
* argp_parse: (libc)Argp.
* argp_state_help: (libc)Argp Helper Functions.
* argp_usage: (libc)Argp Helper Functions.
* argz_add: (libc)Argz Functions.
* argz_add_sep: (libc)Argz Functions.
* argz_append: (libc)Argz Functions.
* argz_count: (libc)Argz Functions.
* argz_create: (libc)Argz Functions.
* argz_create_sep: (libc)Argz Functions.
* argz_delete: (libc)Argz Functions.
* argz_extract: (libc)Argz Functions.
* argz_insert: (libc)Argz Functions.
* argz_next: (libc)Argz Functions.
* argz_replace: (libc)Argz Functions.
* argz_stringify: (libc)Argz Functions.
* asctime: (libc)Formatting Calendar Time.
* asctime_r: (libc)Formatting Calendar Time.
* asin: (libc)Inverse Trig Functions.
* asinf: (libc)Inverse Trig Functions.
* asinh: (libc)Hyperbolic Functions.
* asinhf: (libc)Hyperbolic Functions.
* asinhl: (libc)Hyperbolic Functions.
* asinl: (libc)Inverse Trig Functions.
* asprintf: (libc)Dynamic Output.
* assert: (libc)Consistency Checking.
* assert_perror: (libc)Consistency Checking.
* atan2: (libc)Inverse Trig Functions.
* atan2f: (libc)Inverse Trig Functions.
* atan2l: (libc)Inverse Trig Functions.
* atan: (libc)Inverse Trig Functions.
* atanf: (libc)Inverse Trig Functions.
* atanh: (libc)Hyperbolic Functions.
* atanhf: (libc)Hyperbolic Functions.
* atanhl: (libc)Hyperbolic Functions.
* atanl: (libc)Inverse Trig Functions.
* atexit: (libc)Cleanups on Exit.
* atof: (libc)Parsing of Floats.
* atoi: (libc)Parsing of Integers.
* atol: (libc)Parsing of Integers.
* atoll: (libc)Parsing of Integers.
* backtrace: (libc)Backtraces.
* backtrace_symbols: (libc)Backtraces.
* backtrace_symbols_fd: (libc)Backtraces.
* basename: (libc)Finding Tokens in a String.
* basename: (libc)Finding Tokens in a String.
* bcmp: (libc)String/Array Comparison.
* bcopy: (libc)Copying and Concatenation.
* bind: (libc)Setting Address.
* bind_textdomain_codeset: (libc)Charset conversion in gettext.
* bindtextdomain: (libc)Locating gettext catalog.
* brk: (libc)Resizing the Data Segment.
* bsearch: (libc)Array Search Function.
* btowc: (libc)Converting a Character.
* bzero: (libc)Copying and Concatenation.
* cabs: (libc)Absolute Value.
* cabsf: (libc)Absolute Value.
* cabsl: (libc)Absolute Value.
* cacos: (libc)Inverse Trig Functions.
* cacosf: (libc)Inverse Trig Functions.
* cacosh: (libc)Hyperbolic Functions.
* cacoshf: (libc)Hyperbolic Functions.
* cacoshl: (libc)Hyperbolic Functions.
* cacosl: (libc)Inverse Trig Functions.
* calloc: (libc)Allocating Cleared Space.
* canonicalize_file_name: (libc)Symbolic Links.
* carg: (libc)Operations on Complex.
* cargf: (libc)Operations on Complex.
* cargl: (libc)Operations on Complex.
* casin: (libc)Inverse Trig Functions.
* casinf: (libc)Inverse Trig Functions.
* casinh: (libc)Hyperbolic Functions.
* casinhf: (libc)Hyperbolic Functions.
* casinhl: (libc)Hyperbolic Functions.
* casinl: (libc)Inverse Trig Functions.
* catan: (libc)Inverse Trig Functions.
* catanf: (libc)Inverse Trig Functions.
* catanh: (libc)Hyperbolic Functions.
* catanhf: (libc)Hyperbolic Functions.
* catanhl: (libc)Hyperbolic Functions.
* catanl: (libc)Inverse Trig Functions.
* catclose: (libc)The catgets Functions.
* catgets: (libc)The catgets Functions.
* catopen: (libc)The catgets Functions.
* cbc_crypt: (libc)DES Encryption.
* cbrt: (libc)Exponents and Logarithms.
* cbrtf: (libc)Exponents and Logarithms.
* cbrtl: (libc)Exponents and Logarithms.
* ccos: (libc)Trig Functions.
* ccosf: (libc)Trig Functions.
* ccosh: (libc)Hyperbolic Functions.
* ccoshf: (libc)Hyperbolic Functions.
* ccoshl: (libc)Hyperbolic Functions.
* ccosl: (libc)Trig Functions.
* ceil: (libc)Rounding Functions.
* ceilf: (libc)Rounding Functions.
* ceill: (libc)Rounding Functions.
* cexp: (libc)Exponents and Logarithms.
* cexpf: (libc)Exponents and Logarithms.
* cexpl: (libc)Exponents and Logarithms.
* cfgetispeed: (libc)Line Speed.
* cfgetospeed: (libc)Line Speed.
* cfmakeraw: (libc)Noncanonical Input.
* cfree: (libc)Freeing after Malloc.
* cfsetispeed: (libc)Line Speed.
* cfsetospeed: (libc)Line Speed.
* cfsetspeed: (libc)Line Speed.
* chdir: (libc)Working Directory.
* chmod: (libc)Setting Permissions.
* chown: (libc)File Owner.
* cimag: (libc)Operations on Complex.
* cimagf: (libc)Operations on Complex.
* cimagl: (libc)Operations on Complex.
* clearenv: (libc)Environment Access.
* clearerr: (libc)Error Recovery.
* clearerr_unlocked: (libc)Error Recovery.
* clock: (libc)CPU Time.
* clog10: (libc)Exponents and Logarithms.
* clog10f: (libc)Exponents and Logarithms.
* clog10l: (libc)Exponents and Logarithms.
* clog: (libc)Exponents and Logarithms.
* clogf: (libc)Exponents and Logarithms.
* clogl: (libc)Exponents and Logarithms.
* close: (libc)Opening and Closing Files.
* closedir: (libc)Reading/Closing Directory.
* closelog: (libc)closelog.
* confstr: (libc)String Parameters.
* conj: (libc)Operations on Complex.
* conjf: (libc)Operations on Complex.
* conjl: (libc)Operations on Complex.
* connect: (libc)Connecting.
* copysign: (libc)FP Bit Twiddling.
* copysignf: (libc)FP Bit Twiddling.
* copysignl: (libc)FP Bit Twiddling.
* cos: (libc)Trig Functions.
* cosf: (libc)Trig Functions.
* cosh: (libc)Hyperbolic Functions.
* coshf: (libc)Hyperbolic Functions.
* coshl: (libc)Hyperbolic Functions.
* cosl: (libc)Trig Functions.
* cpow: (libc)Exponents and Logarithms.
* cpowf: (libc)Exponents and Logarithms.
* cpowl: (libc)Exponents and Logarithms.
* cproj: (libc)Operations on Complex.
* cprojf: (libc)Operations on Complex.
* cprojl: (libc)Operations on Complex.
* creal: (libc)Operations on Complex.
* crealf: (libc)Operations on Complex.
* creall: (libc)Operations on Complex.
* creat64: (libc)Opening and Closing Files.
* creat: (libc)Opening and Closing Files.
* crypt: (libc)crypt.
* crypt_r: (libc)crypt.
* csin: (libc)Trig Functions.
* csinf: (libc)Trig Functions.
* csinh: (libc)Hyperbolic Functions.
* csinhf: (libc)Hyperbolic Functions.
* csinhl: (libc)Hyperbolic Functions.
* csinl: (libc)Trig Functions.
* csqrt: (libc)Exponents and Logarithms.
* csqrtf: (libc)Exponents and Logarithms.
* csqrtl: (libc)Exponents and Logarithms.
* ctan: (libc)Trig Functions.
* ctanf: (libc)Trig Functions.
* ctanh: (libc)Hyperbolic Functions.
* ctanhf: (libc)Hyperbolic Functions.
* ctanhl: (libc)Hyperbolic Functions.
* ctanl: (libc)Trig Functions.
* ctermid: (libc)Identifying the Terminal.
* ctime: (libc)Formatting Calendar Time.
* ctime_r: (libc)Formatting Calendar Time.
* cuserid: (libc)Who Logged In.
* dcgettext: (libc)Translation with gettext.
* dcngettext: (libc)Advanced gettext functions.
* des_setparity: (libc)DES Encryption.
* dgettext: (libc)Translation with gettext.
* difftime: (libc)Elapsed Time.
* dirfd: (libc)Opening a Directory.
* dirname: (libc)Finding Tokens in a String.
* div: (libc)Integer Division.
* dngettext: (libc)Advanced gettext functions.
* drand48: (libc)SVID Random.
* drand48_r: (libc)SVID Random.
* drem: (libc)Remainder Functions.
* dremf: (libc)Remainder Functions.
* dreml: (libc)Remainder Functions.
* dup2: (libc)Duplicating Descriptors.
* dup: (libc)Duplicating Descriptors.
* ecb_crypt: (libc)DES Encryption.
* ecvt: (libc)System V Number Conversion.
* ecvt_r: (libc)System V Number Conversion.
* encrypt: (libc)DES Encryption.
* encrypt_r: (libc)DES Encryption.
* endfsent: (libc)fstab.
* endgrent: (libc)Scanning All Groups.
* endhostent: (libc)Host Names.
* endmntent: (libc)mtab.
* endnetent: (libc)Networks Database.
* endnetgrent: (libc)Lookup Netgroup.
* endprotoent: (libc)Protocols Database.
* endpwent: (libc)Scanning All Users.
* endservent: (libc)Services Database.
* endutent: (libc)Manipulating the Database.
* endutxent: (libc)XPG Functions.
* envz_add: (libc)Envz Functions.
* envz_entry: (libc)Envz Functions.
* envz_get: (libc)Envz Functions.
* envz_merge: (libc)Envz Functions.
* envz_strip: (libc)Envz Functions.
* erand48: (libc)SVID Random.
* erand48_r: (libc)SVID Random.
* erf: (libc)Special Functions.
* erfc: (libc)Special Functions.
* erfcf: (libc)Special Functions.
* erfcl: (libc)Special Functions.
* erff: (libc)Special Functions.
* erfl: (libc)Special Functions.
* err: (libc)Error Messages.
* errno: (libc)Checking for Errors.
* error: (libc)Error Messages.
* error_at_line: (libc)Error Messages.
* errx: (libc)Error Messages.
* execl: (libc)Executing a File.
* execle: (libc)Executing a File.
* execlp: (libc)Executing a File.
* execv: (libc)Executing a File.
* execve: (libc)Executing a File.
* execvp: (libc)Executing a File.
* exit: (libc)Normal Termination.
* exp10: (libc)Exponents and Logarithms.
* exp10f: (libc)Exponents and Logarithms.
* exp10l: (libc)Exponents and Logarithms.
* exp2: (libc)Exponents and Logarithms.
* exp2f: (libc)Exponents and Logarithms.
* exp2l: (libc)Exponents and Logarithms.
* exp: (libc)Exponents and Logarithms.
* expf: (libc)Exponents and Logarithms.
* expl: (libc)Exponents and Logarithms.
* expm1: (libc)Exponents and Logarithms.
* expm1f: (libc)Exponents and Logarithms.
* expm1l: (libc)Exponents and Logarithms.
* fabs: (libc)Absolute Value.
* fabsf: (libc)Absolute Value.
* fabsl: (libc)Absolute Value.
* fchdir: (libc)Working Directory.
* fchmod: (libc)Setting Permissions.
* fchown: (libc)File Owner.
* fclean: (libc)Cleaning Streams.
* fclose: (libc)Closing Streams.
* fcloseall: (libc)Closing Streams.
* fcntl: (libc)Control Operations.
* fcvt: (libc)System V Number Conversion.
* fcvt_r: (libc)System V Number Conversion.
* fdatasync: (libc)Synchronizing I/O.
* fdim: (libc)Misc FP Arithmetic.
* fdimf: (libc)Misc FP Arithmetic.
* fdiml: (libc)Misc FP Arithmetic.
* fdopen: (libc)Descriptors and Streams.
* fdopendir: (libc)Opening a Directory.
* feclearexcept: (libc)Status bit operations.
* fedisableexcept: (libc)Control Functions.
* feenableexcept: (libc)Control Functions.
* fegetenv: (libc)Control Functions.
* fegetexcept: (libc)Control Functions.
* fegetexceptflag: (libc)Status bit operations.
* fegetround: (libc)Rounding.
* feholdexcept: (libc)Control Functions.
* feof: (libc)EOF and Errors.
* feof_unlocked: (libc)EOF and Errors.
* feraiseexcept: (libc)Status bit operations.
* ferror: (libc)EOF and Errors.
* ferror_unlocked: (libc)EOF and Errors.
* fesetenv: (libc)Control Functions.
* fesetexceptflag: (libc)Status bit operations.
* fesetround: (libc)Rounding.
* fetestexcept: (libc)Status bit operations.
* feupdateenv: (libc)Control Functions.
* fflush: (libc)Flushing Buffers.
* fflush_unlocked: (libc)Flushing Buffers.
* fgetc: (libc)Character Input.
* fgetc_unlocked: (libc)Character Input.
* fgetgrent: (libc)Scanning All Groups.
* fgetgrent_r: (libc)Scanning All Groups.
* fgetpos64: (libc)Portable Positioning.
* fgetpos: (libc)Portable Positioning.
* fgetpwent: (libc)Scanning All Users.
* fgetpwent_r: (libc)Scanning All Users.
* fgets: (libc)Line Input.
* fgets_unlocked: (libc)Line Input.
* fgetwc: (libc)Character Input.
* fgetwc_unlocked: (libc)Character Input.
* fgetws: (libc)Line Input.
* fgetws_unlocked: (libc)Line Input.
* fileno: (libc)Descriptors and Streams.
* fileno_unlocked: (libc)Descriptors and Streams.
* finite: (libc)Floating Point Classes.
* finitef: (libc)Floating Point Classes.
* finitel: (libc)Floating Point Classes.
* flockfile: (libc)Streams and Threads.
* floor: (libc)Rounding Functions.
* floorf: (libc)Rounding Functions.
* floorl: (libc)Rounding Functions.
* fma: (libc)Misc FP Arithmetic.
* fmaf: (libc)Misc FP Arithmetic.
* fmal: (libc)Misc FP Arithmetic.
* fmax: (libc)Misc FP Arithmetic.
* fmaxf: (libc)Misc FP Arithmetic.
* fmaxl: (libc)Misc FP Arithmetic.
* fmemopen: (libc)String Streams.
* fmin: (libc)Misc FP Arithmetic.
* fminf: (libc)Misc FP Arithmetic.
* fminl: (libc)Misc FP Arithmetic.
* fmod: (libc)Remainder Functions.
* fmodf: (libc)Remainder Functions.
* fmodl: (libc)Remainder Functions.
* fmtmsg: (libc)Printing Formatted Messages.
* fnmatch: (libc)Wildcard Matching.
* fopen64: (libc)Opening Streams.
* fopen: (libc)Opening Streams.
* fopencookie: (libc)Streams and Cookies.
* fork: (libc)Creating a Process.
* forkpty: (libc)Pseudo-Terminal Pairs.
* fpathconf: (libc)Pathconf.
* fpclassify: (libc)Floating Point Classes.
* fprintf: (libc)Formatted Output Functions.
* fputc: (libc)Simple Output.
* fputc_unlocked: (libc)Simple Output.
* fputs: (libc)Simple Output.
* fputs_unlocked: (libc)Simple Output.
* fputwc: (libc)Simple Output.
* fputwc_unlocked: (libc)Simple Output.
* fputws: (libc)Simple Output.
* fputws_unlocked: (libc)Simple Output.
* fread: (libc)Block Input/Output.
* fread_unlocked: (libc)Block Input/Output.
* free: (libc)Freeing after Malloc.
* freopen64: (libc)Opening Streams.
* freopen: (libc)Opening Streams.
* frexp: (libc)Normalization Functions.
* frexpf: (libc)Normalization Functions.
* frexpl: (libc)Normalization Functions.
* fscanf: (libc)Formatted Input Functions.
* fseek: (libc)File Positioning.
* fseeko64: (libc)File Positioning.
* fseeko: (libc)File Positioning.
* fsetpos64: (libc)Portable Positioning.
* fsetpos: (libc)Portable Positioning.
* fstat64: (libc)Reading Attributes.
* fstat: (libc)Reading Attributes.
* fsync: (libc)Synchronizing I/O.
* ftell: (libc)File Positioning.
* ftello64: (libc)File Positioning.
* ftello: (libc)File Positioning.
* ftruncate64: (libc)File Size.
* ftruncate: (libc)File Size.
* ftrylockfile: (libc)Streams and Threads.
* ftw64: (libc)Working with Directory Trees.
* ftw: (libc)Working with Directory Trees.
* funlockfile: (libc)Streams and Threads.
* futimes: (libc)File Times.
* fwide: (libc)Streams and I18N.
* fwprintf: (libc)Formatted Output Functions.
* fwrite: (libc)Block Input/Output.
* fwrite_unlocked: (libc)Block Input/Output.
* fwscanf: (libc)Formatted Input Functions.
* gamma: (libc)Special Functions.
* gammaf: (libc)Special Functions.
* gammal: (libc)Special Functions.
* gcvt: (libc)System V Number Conversion.
* get_avphys_pages: (libc)Query Memory Parameters.
* get_current_dir_name: (libc)Working Directory.
* get_nprocs: (libc)Processor Resources.
* get_nprocs_conf: (libc)Processor Resources.
* get_phys_pages: (libc)Query Memory Parameters.
* getc: (libc)Character Input.
* getc_unlocked: (libc)Character Input.
* getchar: (libc)Character Input.
* getchar_unlocked: (libc)Character Input.
* getcontext: (libc)System V contexts.
* getcwd: (libc)Working Directory.
* getdate: (libc)General Time String Parsing.
* getdate_r: (libc)General Time String Parsing.
* getdelim: (libc)Line Input.
* getdomainnname: (libc)Host Identification.
* getegid: (libc)Reading Persona.
* getenv: (libc)Environment Access.
* geteuid: (libc)Reading Persona.
* getfsent: (libc)fstab.
* getfsfile: (libc)fstab.
* getfsspec: (libc)fstab.
* getgid: (libc)Reading Persona.
* getgrent: (libc)Scanning All Groups.
* getgrent_r: (libc)Scanning All Groups.
* getgrgid: (libc)Lookup Group.
* getgrgid_r: (libc)Lookup Group.
* getgrnam: (libc)Lookup Group.
* getgrnam_r: (libc)Lookup Group.
* getgrouplist: (libc)Setting Groups.
* getgroups: (libc)Reading Persona.
* gethostbyaddr: (libc)Host Names.
* gethostbyaddr_r: (libc)Host Names.
* gethostbyname2: (libc)Host Names.
* gethostbyname2_r: (libc)Host Names.
* gethostbyname: (libc)Host Names.
* gethostbyname_r: (libc)Host Names.
* gethostent: (libc)Host Names.
* gethostid: (libc)Host Identification.
* gethostname: (libc)Host Identification.
* getitimer: (libc)Setting an Alarm.
* getline: (libc)Line Input.
* getloadavg: (libc)Processor Resources.
* getlogin: (libc)Who Logged In.
* getmntent: (libc)mtab.
* getmntent_r: (libc)mtab.
* getnetbyaddr: (libc)Networks Database.
* getnetbyname: (libc)Networks Database.
* getnetent: (libc)Networks Database.
* getnetgrent: (libc)Lookup Netgroup.
* getnetgrent_r: (libc)Lookup Netgroup.
* getopt: (libc)Using Getopt.
* getopt_long: (libc)Getopt Long Options.
* getopt_long_only: (libc)Getopt Long Options.
* getpagesize: (libc)Query Memory Parameters.
* getpass: (libc)getpass.
* getpeername: (libc)Who is Connected.
* getpgid: (libc)Process Group Functions.
* getpgrp: (libc)Process Group Functions.
* getpgrp: (libc)Process Group Functions.
* getpid: (libc)Process Identification.
* getppid: (libc)Process Identification.
* getpriority: (libc)Traditional Scheduling Functions.
* getprotobyname: (libc)Protocols Database.
* getprotobynumber: (libc)Protocols Database.
* getprotoent: (libc)Protocols Database.
* getpt: (libc)Allocation.
* getpwent: (libc)Scanning All Users.
* getpwent_r: (libc)Scanning All Users.
* getpwnam: (libc)Lookup User.
* getpwnam_r: (libc)Lookup User.
* getpwuid: (libc)Lookup User.
* getpwuid_r: (libc)Lookup User.
* getrlimit64: (libc)Limits on Resources.
* getrlimit: (libc)Limits on Resources.
* getrusage: (libc)Resource Usage.
* gets: (libc)Line Input.
* getservbyname: (libc)Services Database.
* getservbyport: (libc)Services Database.
* getservent: (libc)Services Database.
* getsid: (libc)Process Group Functions.
* getsockname: (libc)Reading Address.
* getsockopt: (libc)Socket Option Functions.
* getsubopt: (libc)Suboptions.
* gettext: (libc)Translation with gettext.
* gettimeofday: (libc)High-Resolution Calendar.
* getuid: (libc)Reading Persona.
* getumask: (libc)Setting Permissions.
* getutent: (libc)Manipulating the Database.
* getutent_r: (libc)Manipulating the Database.
* getutid: (libc)Manipulating the Database.
* getutid_r: (libc)Manipulating the Database.
* getutline: (libc)Manipulating the Database.
* getutline_r: (libc)Manipulating the Database.
* getutmp: (libc)XPG Functions.
* getutmpx: (libc)XPG Functions.
* getutxent: (libc)XPG Functions.
* getutxid: (libc)XPG Functions.
* getutxline: (libc)XPG Functions.
* getw: (libc)Character Input.
* getwc: (libc)Character Input.
* getwc_unlocked: (libc)Character Input.
* getwchar: (libc)Character Input.
* getwchar_unlocked: (libc)Character Input.
* getwd: (libc)Working Directory.
* glob64: (libc)Calling Glob.
* glob: (libc)Calling Glob.
* globfree64: (libc)More Flags for Globbing.
* globfree: (libc)More Flags for Globbing.
* gmtime: (libc)Broken-down Time.
* gmtime_r: (libc)Broken-down Time.
* grantpt: (libc)Allocation.
* gsignal: (libc)Signaling Yourself.
* gtty: (libc)BSD Terminal Modes.
* hasmntopt: (libc)mtab.
* hcreate: (libc)Hash Search Function.
* hcreate_r: (libc)Hash Search Function.
* hdestroy: (libc)Hash Search Function.
* hdestroy_r: (libc)Hash Search Function.
* hsearch: (libc)Hash Search Function.
* hsearch_r: (libc)Hash Search Function.
* htonl: (libc)Byte Order.
* htons: (libc)Byte Order.
* hypot: (libc)Exponents and Logarithms.
* hypotf: (libc)Exponents and Logarithms.
* hypotl: (libc)Exponents and Logarithms.
* iconv: (libc)Generic Conversion Interface.
* iconv_close: (libc)Generic Conversion Interface.
* iconv_open: (libc)Generic Conversion Interface.
* if_freenameindex: (libc)Interface Naming.
* if_indextoname: (libc)Interface Naming.
* if_nameindex: (libc)Interface Naming.
* if_nametoindex: (libc)Interface Naming.
* ilogb: (libc)Exponents and Logarithms.
* ilogbf: (libc)Exponents and Logarithms.
* ilogbl: (libc)Exponents and Logarithms.
* imaxabs: (libc)Absolute Value.
* imaxdiv: (libc)Integer Division.
* in6addr_any: (libc)Host Address Data Type.
* in6addr_loopback: (libc)Host Address Data Type.
* index: (libc)Search Functions.
* inet_addr: (libc)Host Address Functions.
* inet_aton: (libc)Host Address Functions.
* inet_lnaof: (libc)Host Address Functions.
* inet_makeaddr: (libc)Host Address Functions.
* inet_netof: (libc)Host Address Functions.
* inet_network: (libc)Host Address Functions.
* inet_ntoa: (libc)Host Address Functions.
* inet_ntop: (libc)Host Address Functions.
* inet_pton: (libc)Host Address Functions.
* initgroups: (libc)Setting Groups.
* initstate: (libc)BSD Random.
* initstate_r: (libc)BSD Random.
* innetgr: (libc)Netgroup Membership.
* int: (libc)Random Access Directory.
* ioctl: (libc)IOCTLs.
* isalnum: (libc)Classification of Characters.
* isalpha: (libc)Classification of Characters.
* isascii: (libc)Classification of Characters.
* isatty: (libc)Is It a Terminal.
* isblank: (libc)Classification of Characters.
* iscntrl: (libc)Classification of Characters.
* isdigit: (libc)Classification of Characters.
* isfinite: (libc)Floating Point Classes.
* isgraph: (libc)Classification of Characters.
* isgreater: (libc)FP Comparison Functions.
* isgreaterequal: (libc)FP Comparison Functions.
* isinf: (libc)Floating Point Classes.
* isinff: (libc)Floating Point Classes.
* isinfl: (libc)Floating Point Classes.
* isless: (libc)FP Comparison Functions.
* islessequal: (libc)FP Comparison Functions.
* islessgreater: (libc)FP Comparison Functions.
* islower: (libc)Classification of Characters.
* isnan: (libc)Floating Point Classes.
* isnan: (libc)Floating Point Classes.
* isnanf: (libc)Floating Point Classes.
* isnanl: (libc)Floating Point Classes.
* isnormal: (libc)Floating Point Classes.
* isprint: (libc)Classification of Characters.
* ispunct: (libc)Classification of Characters.
* isspace: (libc)Classification of Characters.
* isunordered: (libc)FP Comparison Functions.
* isupper: (libc)Classification of Characters.
* iswalnum: (libc)Classification of Wide Characters.
* iswalpha: (libc)Classification of Wide Characters.
* iswblank: (libc)Classification of Wide Characters.
* iswcntrl: (libc)Classification of Wide Characters.
* iswctype: (libc)Classification of Wide Characters.
* iswdigit: (libc)Classification of Wide Characters.
* iswgraph: (libc)Classification of Wide Characters.
* iswlower: (libc)Classification of Wide Characters.
* iswprint: (libc)Classification of Wide Characters.
* iswpunct: (libc)Classification of Wide Characters.
* iswspace: (libc)Classification of Wide Characters.
* iswupper: (libc)Classification of Wide Characters.
* iswxdigit: (libc)Classification of Wide Characters.
* isxdigit: (libc)Classification of Characters.
* j0: (libc)Special Functions.
* j0f: (libc)Special Functions.
* j0l: (libc)Special Functions.
* j1: (libc)Special Functions.
* j1f: (libc)Special Functions.
* j1l: (libc)Special Functions.
* jn: (libc)Special Functions.
* jnf: (libc)Special Functions.
* jnl: (libc)Special Functions.
* jrand48: (libc)SVID Random.
* jrand48_r: (libc)SVID Random.
* kill: (libc)Signaling Another Process.
* killpg: (libc)Signaling Another Process.
* l64a: (libc)Encode Binary Data.
* labs: (libc)Absolute Value.
* lcong48: (libc)SVID Random.
* lcong48_r: (libc)SVID Random.
* ldexp: (libc)Normalization Functions.
* ldexpf: (libc)Normalization Functions.
* ldexpl: (libc)Normalization Functions.
* ldiv: (libc)Integer Division.
* lfind: (libc)Array Search Function.
* lgamma: (libc)Special Functions.
* lgamma_r: (libc)Special Functions.
* lgammaf: (libc)Special Functions.
* lgammaf_r: (libc)Special Functions.
* lgammal: (libc)Special Functions.
* lgammal_r: (libc)Special Functions.
* link: (libc)Hard Links.
* lio_listio64: (libc)Asynchronous Reads/Writes.
* lio_listio: (libc)Asynchronous Reads/Writes.
* listen: (libc)Listening.
* llabs: (libc)Absolute Value.
* lldiv: (libc)Integer Division.
* llrint: (libc)Rounding Functions.
* llrintf: (libc)Rounding Functions.
* llrintl: (libc)Rounding Functions.
* llround: (libc)Rounding Functions.
* llroundf: (libc)Rounding Functions.
* llroundl: (libc)Rounding Functions.
* localeconv: (libc)The Lame Way to Locale Data.
* localtime: (libc)Broken-down Time.
* localtime_r: (libc)Broken-down Time.
* log10: (libc)Exponents and Logarithms.
* log10f: (libc)Exponents and Logarithms.
* log10l: (libc)Exponents and Logarithms.
* log1p: (libc)Exponents and Logarithms.
* log1pf: (libc)Exponents and Logarithms.
* log1pl: (libc)Exponents and Logarithms.
* log2: (libc)Exponents and Logarithms.
* log2f: (libc)Exponents and Logarithms.
* log2l: (libc)Exponents and Logarithms.
* log: (libc)Exponents and Logarithms.
* logb: (libc)Exponents and Logarithms.
* logbf: (libc)Exponents and Logarithms.
* logbl: (libc)Exponents and Logarithms.
* logf: (libc)Exponents and Logarithms.
* login: (libc)Logging In and Out.
* login_tty: (libc)Logging In and Out.
* logl: (libc)Exponents and Logarithms.
* logout: (libc)Logging In and Out.
* logwtmp: (libc)Logging In and Out.
* longjmp: (libc)Non-Local Details.
* lrand48: (libc)SVID Random.
* lrand48_r: (libc)SVID Random.
* lrint: (libc)Rounding Functions.
* lrintf: (libc)Rounding Functions.
* lrintl: (libc)Rounding Functions.
* lround: (libc)Rounding Functions.
* lroundf: (libc)Rounding Functions.
* lroundl: (libc)Rounding Functions.
* lsearch: (libc)Array Search Function.
* lseek64: (libc)File Position Primitive.
* lseek: (libc)File Position Primitive.
* lstat64: (libc)Reading Attributes.
* lstat: (libc)Reading Attributes.
* lutimes: (libc)File Times.
* madvise: (libc)Memory-mapped I/O.
* makecontext: (libc)System V contexts.
* mallinfo: (libc)Statistics of Malloc.
* malloc: (libc)Basic Allocation.
* mallopt: (libc)Malloc Tunable Parameters.
* mblen: (libc)Non-reentrant Character Conversion.
* mbrlen: (libc)Converting a Character.
* mbrtowc: (libc)Converting a Character.
* mbsinit: (libc)Keeping the state.
* mbsnrtowcs: (libc)Converting Strings.
* mbsrtowcs: (libc)Converting Strings.
* mbstowcs: (libc)Non-reentrant String Conversion.
* mbtowc: (libc)Non-reentrant Character Conversion.
* mcheck: (libc)Heap Consistency Checking.
* memalign: (libc)Aligned Memory Blocks.
* memccpy: (libc)Copying and Concatenation.
* memchr: (libc)Search Functions.
* memcmp: (libc)String/Array Comparison.
* memcpy: (libc)Copying and Concatenation.
* memfrob: (libc)Trivial Encryption.
* memmem: (libc)Search Functions.
* memmove: (libc)Copying and Concatenation.
* mempcpy: (libc)Copying and Concatenation.
* memrchr: (libc)Search Functions.
* memset: (libc)Copying and Concatenation.
* mkdir: (libc)Creating Directories.
* mkdtemp: (libc)Temporary Files.
* mkfifo: (libc)FIFO Special Files.
* mknod: (libc)Making Special Files.
* mkstemp: (libc)Temporary Files.
* mktemp: (libc)Temporary Files.
* mktime: (libc)Broken-down Time.
* mlock: (libc)Page Lock Functions.
* mlockall: (libc)Page Lock Functions.
* mmap64: (libc)Memory-mapped I/O.
* mmap: (libc)Memory-mapped I/O.
* modf: (libc)Rounding Functions.
* modff: (libc)Rounding Functions.
* modfl: (libc)Rounding Functions.
* mount: (libc)Mount-Unmount-Remount.
* mprobe: (libc)Heap Consistency Checking.
* mrand48: (libc)SVID Random.
* mrand48_r: (libc)SVID Random.
* mremap: (libc)Memory-mapped I/O.
* msync: (libc)Memory-mapped I/O.
* mtrace: (libc)Tracing malloc.
* munlock: (libc)Page Lock Functions.
* munlockall: (libc)Page Lock Functions.
* munmap: (libc)Memory-mapped I/O.
* muntrace: (libc)Tracing malloc.
* nan: (libc)FP Bit Twiddling.
* nanf: (libc)FP Bit Twiddling.
* nanl: (libc)FP Bit Twiddling.
* nanosleep: (libc)Sleeping.
* nearbyint: (libc)Rounding Functions.
* nearbyintf: (libc)Rounding Functions.
* nearbyintl: (libc)Rounding Functions.
* nextafter: (libc)FP Bit Twiddling.
* nextafterf: (libc)FP Bit Twiddling.
* nextafterl: (libc)FP Bit Twiddling.
* nexttoward: (libc)FP Bit Twiddling.
* nexttowardf: (libc)FP Bit Twiddling.
* nexttowardl: (libc)FP Bit Twiddling.
* nftw64: (libc)Working with Directory Trees.
* nftw: (libc)Working with Directory Trees.
* ngettext: (libc)Advanced gettext functions.
* nice: (libc)Traditional Scheduling Functions.
* nl_langinfo: (libc)The Elegant and Fast Way.
* nrand48: (libc)SVID Random.
* nrand48_r: (libc)SVID Random.
* ntohl: (libc)Byte Order.
* ntohs: (libc)Byte Order.
* ntp_adjtime: (libc)High Accuracy Clock.
* ntp_gettime: (libc)High Accuracy Clock.
* obstack_1grow: (libc)Growing Objects.
* obstack_1grow_fast: (libc)Extra Fast Growing.
* obstack_alignment_mask: (libc)Obstacks Data Alignment.
* obstack_alloc: (libc)Allocation in an Obstack.
* obstack_base: (libc)Status of an Obstack.
* obstack_blank: (libc)Growing Objects.
* obstack_blank_fast: (libc)Extra Fast Growing.
* obstack_chunk_size: (libc)Obstack Chunks.
* obstack_copy0: (libc)Allocation in an Obstack.
* obstack_copy: (libc)Allocation in an Obstack.
* obstack_finish: (libc)Growing Objects.
* obstack_free: (libc)Freeing Obstack Objects.
* obstack_grow0: (libc)Growing Objects.
* obstack_grow: (libc)Growing Objects.
* obstack_init: (libc)Preparing for Obstacks.
* obstack_int_grow: (libc)Growing Objects.
* obstack_int_grow_fast: (libc)Extra Fast Growing.
* obstack_next_free: (libc)Status of an Obstack.
* obstack_object_size: (libc)Growing Objects.
* obstack_object_size: (libc)Status of an Obstack.
* obstack_printf: (libc)Dynamic Output.
* obstack_ptr_grow: (libc)Growing Objects.
* obstack_ptr_grow_fast: (libc)Extra Fast Growing.
* obstack_room: (libc)Extra Fast Growing.
* obstack_vprintf: (libc)Variable Arguments Output.
* offsetof: (libc)Structure Measurement.
* on_exit: (libc)Cleanups on Exit.
* open64: (libc)Opening and Closing Files.
* open: (libc)Opening and Closing Files.
* open_memstream: (libc)String Streams.
* open_obstack_stream: (libc)Obstack Streams.
* opendir: (libc)Opening a Directory.
* openlog: (libc)openlog.
* openpty: (libc)Pseudo-Terminal Pairs.
* parse_printf_format: (libc)Parsing a Template String.
* pathconf: (libc)Pathconf.
* pause: (libc)Using Pause.
* pclose: (libc)Pipe to a Subprocess.
* perror: (libc)Error Messages.
* pipe: (libc)Creating a Pipe.
* popen: (libc)Pipe to a Subprocess.
* posix_memalign: (libc)Aligned Memory Blocks.
* pow10: (libc)Exponents and Logarithms.
* pow10f: (libc)Exponents and Logarithms.
* pow10l: (libc)Exponents and Logarithms.
* pow: (libc)Exponents and Logarithms.
* powf: (libc)Exponents and Logarithms.
* powl: (libc)Exponents and Logarithms.
* pread64: (libc)I/O Primitives.
* pread: (libc)I/O Primitives.
* printf: (libc)Formatted Output Functions.
* printf_size: (libc)Predefined Printf Handlers.
* printf_size_info: (libc)Predefined Printf Handlers.
* psignal: (libc)Signal Messages.
* ptsname: (libc)Allocation.
* ptsname_r: (libc)Allocation.
* putc: (libc)Simple Output.
* putc_unlocked: (libc)Simple Output.
* putchar: (libc)Simple Output.
* putchar_unlocked: (libc)Simple Output.
* putenv: (libc)Environment Access.
* putpwent: (libc)Writing a User Entry.
* puts: (libc)Simple Output.
* pututline: (libc)Manipulating the Database.
* pututxline: (libc)XPG Functions.
* putw: (libc)Simple Output.
* putwc: (libc)Simple Output.
* putwc_unlocked: (libc)Simple Output.
* putwchar: (libc)Simple Output.
* putwchar_unlocked: (libc)Simple Output.
* pwrite64: (libc)I/O Primitives.
* pwrite: (libc)I/O Primitives.
* qecvt: (libc)System V Number Conversion.
* qecvt_r: (libc)System V Number Conversion.
* qfcvt: (libc)System V Number Conversion.
* qfcvt_r: (libc)System V Number Conversion.
* qgcvt: (libc)System V Number Conversion.
* qsort: (libc)Array Sort Function.
* raise: (libc)Signaling Yourself.
* rand: (libc)ISO Random.
* rand_r: (libc)ISO Random.
* random: (libc)BSD Random.
* random_r: (libc)BSD Random.
* rawmemchr: (libc)Search Functions.
* read: (libc)I/O Primitives.
* readdir64: (libc)Reading/Closing Directory.
* readdir64_r: (libc)Reading/Closing Directory.
* readdir: (libc)Reading/Closing Directory.
* readdir_r: (libc)Reading/Closing Directory.
* readlink: (libc)Symbolic Links.
* readv: (libc)Scatter-Gather.
* realloc: (libc)Changing Block Size.
* realpath: (libc)Symbolic Links.
* recv: (libc)Receiving Data.
* recvfrom: (libc)Receiving Datagrams.
* recvmsg: (libc)Receiving Datagrams.
* regcomp: (libc)POSIX Regexp Compilation.
* regerror: (libc)Regexp Cleanup.
* regexec: (libc)Matching POSIX Regexps.
* regfree: (libc)Regexp Cleanup.
* register_printf_function: (libc)Registering New Conversions.
* remainder: (libc)Remainder Functions.
* remainderf: (libc)Remainder Functions.
* remainderl: (libc)Remainder Functions.
* remove: (libc)Deleting Files.
* rename: (libc)Renaming Files.
* rewind: (libc)File Positioning.
* rewinddir: (libc)Random Access Directory.
* rindex: (libc)Search Functions.
* rint: (libc)Rounding Functions.
* rintf: (libc)Rounding Functions.
* rintl: (libc)Rounding Functions.
* rmdir: (libc)Deleting Files.
* round: (libc)Rounding Functions.
* roundf: (libc)Rounding Functions.
* roundl: (libc)Rounding Functions.
* rpmatch: (libc)Yes-or-No Questions.
* sbrk: (libc)Resizing the Data Segment.
* scalb: (libc)Normalization Functions.
* scalbf: (libc)Normalization Functions.
* scalbl: (libc)Normalization Functions.
* scalbln: (libc)Normalization Functions.
* scalblnf: (libc)Normalization Functions.
* scalblnl: (libc)Normalization Functions.
* scalbn: (libc)Normalization Functions.
* scalbnf: (libc)Normalization Functions.
* scalbnl: (libc)Normalization Functions.
* scandir64: (libc)Scanning Directory Content.
* scandir: (libc)Scanning Directory Content.
* scanf: (libc)Formatted Input Functions.
* sched_get_priority_max: (libc)Basic Scheduling Functions.
* sched_get_priority_min: (libc)Basic Scheduling Functions.
* sched_getaffinity: (libc)CPU Affinity.
* sched_getparam: (libc)Basic Scheduling Functions.
* sched_getscheduler: (libc)Basic Scheduling Functions.
* sched_rr_get_interval: (libc)Basic Scheduling Functions.
* sched_setaffinity: (libc)CPU Affinity.
* sched_setparam: (libc)Basic Scheduling Functions.
* sched_setscheduler: (libc)Basic Scheduling Functions.
* sched_yield: (libc)Basic Scheduling Functions.
* seed48: (libc)SVID Random.
* seed48_r: (libc)SVID Random.
* seekdir: (libc)Random Access Directory.
* select: (libc)Waiting for I/O.
* send: (libc)Sending Data.
* sendmsg: (libc)Receiving Datagrams.
* sendto: (libc)Sending Datagrams.
* setbuf: (libc)Controlling Buffering.
* setbuffer: (libc)Controlling Buffering.
* setcontext: (libc)System V contexts.
* setdomainname: (libc)Host Identification.
* setegid: (libc)Setting Groups.
* setenv: (libc)Environment Access.
* seteuid: (libc)Setting User ID.
* setfsent: (libc)fstab.
* setgid: (libc)Setting Groups.
* setgrent: (libc)Scanning All Groups.
* setgroups: (libc)Setting Groups.
* sethostent: (libc)Host Names.
* sethostid: (libc)Host Identification.
* sethostname: (libc)Host Identification.
* setitimer: (libc)Setting an Alarm.
* setjmp: (libc)Non-Local Details.
* setkey: (libc)DES Encryption.
* setkey_r: (libc)DES Encryption.
* setlinebuf: (libc)Controlling Buffering.
* setlocale: (libc)Setting the Locale.
* setlogmask: (libc)setlogmask.
* setmntent: (libc)mtab.
* setnetent: (libc)Networks Database.
* setnetgrent: (libc)Lookup Netgroup.
* setpgid: (libc)Process Group Functions.
* setpgrp: (libc)Process Group Functions.
* setpriority: (libc)Traditional Scheduling Functions.
* setprotoent: (libc)Protocols Database.
* setpwent: (libc)Scanning All Users.
* setregid: (libc)Setting Groups.
* setreuid: (libc)Setting User ID.
* setrlimit64: (libc)Limits on Resources.
* setrlimit: (libc)Limits on Resources.
* setservent: (libc)Services Database.
* setsid: (libc)Process Group Functions.
* setsockopt: (libc)Socket Option Functions.
* setstate: (libc)BSD Random.
* setstate_r: (libc)BSD Random.
* settimeofday: (libc)High-Resolution Calendar.
* setuid: (libc)Setting User ID.
* setutent: (libc)Manipulating the Database.
* setutxent: (libc)XPG Functions.
* setvbuf: (libc)Controlling Buffering.
* shutdown: (libc)Closing a Socket.
* sigaction: (libc)Advanced Signal Handling.
* sigaddset: (libc)Signal Sets.
* sigaltstack: (libc)Signal Stack.
* sigblock: (libc)Blocking in BSD.
* sigdelset: (libc)Signal Sets.
* sigemptyset: (libc)Signal Sets.
* sigfillset: (libc)Signal Sets.
* siginterrupt: (libc)BSD Handler.
* sigismember: (libc)Signal Sets.
* siglongjmp: (libc)Non-Local Exits and Signals.
* sigmask: (libc)Blocking in BSD.
* signal: (libc)Basic Signal Handling.
* signbit: (libc)FP Bit Twiddling.
* significand: (libc)Normalization Functions.
* significandf: (libc)Normalization Functions.
* significandl: (libc)Normalization Functions.
* sigpause: (libc)Blocking in BSD.
* sigpending: (libc)Checking for Pending Signals.
* sigprocmask: (libc)Process Signal Mask.
* sigsetjmp: (libc)Non-Local Exits and Signals.
* sigsetmask: (libc)Blocking in BSD.
* sigstack: (libc)Signal Stack.
* sigsuspend: (libc)Sigsuspend.
* sigvec: (libc)BSD Handler.
* sin: (libc)Trig Functions.
* sincos: (libc)Trig Functions.
* sincosf: (libc)Trig Functions.
* sincosl: (libc)Trig Functions.
* sinf: (libc)Trig Functions.
* sinh: (libc)Hyperbolic Functions.
* sinhf: (libc)Hyperbolic Functions.
* sinhl: (libc)Hyperbolic Functions.
* sinl: (libc)Trig Functions.
* sleep: (libc)Sleeping.
* snprintf: (libc)Formatted Output Functions.
* socket: (libc)Creating a Socket.
* socketpair: (libc)Socket Pairs.
* sprintf: (libc)Formatted Output Functions.
* sqrt: (libc)Exponents and Logarithms.
* sqrtf: (libc)Exponents and Logarithms.
* sqrtl: (libc)Exponents and Logarithms.
* srand48: (libc)SVID Random.
* srand48_r: (libc)SVID Random.
* srand: (libc)ISO Random.
* srandom: (libc)BSD Random.
* srandom_r: (libc)BSD Random.
* sscanf: (libc)Formatted Input Functions.
* ssignal: (libc)Basic Signal Handling.
* stat64: (libc)Reading Attributes.
* stat: (libc)Reading Attributes.
* stime: (libc)Simple Calendar Time.
* stpcpy: (libc)Copying and Concatenation.
* stpncpy: (libc)Copying and Concatenation.
* strcasecmp: (libc)String/Array Comparison.
* strcasestr: (libc)Search Functions.
* strcat: (libc)Copying and Concatenation.
* strchr: (libc)Search Functions.
* strchrnul: (libc)Search Functions.
* strcmp: (libc)String/Array Comparison.
* strcoll: (libc)Collation Functions.
* strcpy: (libc)Copying and Concatenation.
* strcspn: (libc)Search Functions.
* strdup: (libc)Copying and Concatenation.
* strdupa: (libc)Copying and Concatenation.
* strerror: (libc)Error Messages.
* strerror_r: (libc)Error Messages.
* strfmon: (libc)Formatting Numbers.
* strfry: (libc)strfry.
* strftime: (libc)Formatting Calendar Time.
* strlen: (libc)String Length.
* strncasecmp: (libc)String/Array Comparison.
* strncat: (libc)Copying and Concatenation.
* strncmp: (libc)String/Array Comparison.
* strncpy: (libc)Copying and Concatenation.
* strndup: (libc)Copying and Concatenation.
* strndupa: (libc)Copying and Concatenation.
* strnlen: (libc)String Length.
* strpbrk: (libc)Search Functions.
* strptime: (libc)Low-Level Time String Parsing.
* strrchr: (libc)Search Functions.
* strsep: (libc)Finding Tokens in a String.
* strsignal: (libc)Signal Messages.
* strspn: (libc)Search Functions.
* strstr: (libc)Search Functions.
* strtod: (libc)Parsing of Floats.
* strtof: (libc)Parsing of Floats.
* strtoimax: (libc)Parsing of Integers.
* strtok: (libc)Finding Tokens in a String.
* strtok_r: (libc)Finding Tokens in a String.
* strtol: (libc)Parsing of Integers.
* strtold: (libc)Parsing of Floats.
* strtoll: (libc)Parsing of Integers.
* strtoq: (libc)Parsing of Integers.
* strtoul: (libc)Parsing of Integers.
* strtoull: (libc)Parsing of Integers.
* strtoumax: (libc)Parsing of Integers.
* strtouq: (libc)Parsing of Integers.
* strverscmp: (libc)String/Array Comparison.
* strxfrm: (libc)Collation Functions.
* stty: (libc)BSD Terminal Modes.
* swapcontext: (libc)System V contexts.
* swprintf: (libc)Formatted Output Functions.
* swscanf: (libc)Formatted Input Functions.
* symlink: (libc)Symbolic Links.
* sync: (libc)Synchronizing I/O.
* syscall: (libc)System Calls.
* sysconf: (libc)Sysconf Definition.
* sysctl: (libc)System Parameters.
* syslog: (libc)syslog; vsyslog.
* system: (libc)Running a Command.
* sysv_signal: (libc)Basic Signal Handling.
* tan: (libc)Trig Functions.
* tanf: (libc)Trig Functions.
* tanh: (libc)Hyperbolic Functions.
* tanhf: (libc)Hyperbolic Functions.
* tanhl: (libc)Hyperbolic Functions.
* tanl: (libc)Trig Functions.
* tcdrain: (libc)Line Control.
* tcflow: (libc)Line Control.
* tcflush: (libc)Line Control.
* tcgetattr: (libc)Mode Functions.
* tcgetpgrp: (libc)Terminal Access Functions.
* tcgetsid: (libc)Terminal Access Functions.
* tcsendbreak: (libc)Line Control.
* tcsetattr: (libc)Mode Functions.
* tcsetpgrp: (libc)Terminal Access Functions.
* tdelete: (libc)Tree Search Function.
* tdestroy: (libc)Tree Search Function.
* tempnam: (libc)Temporary Files.
* textdomain: (libc)Locating gettext catalog.
* tfind: (libc)Tree Search Function.
* tgamma: (libc)Special Functions.
* tgammaf: (libc)Special Functions.
* tgammal: (libc)Special Functions.
* time: (libc)Simple Calendar Time.
* timegm: (libc)Broken-down Time.
* timelocal: (libc)Broken-down Time.
* times: (libc)Processor Time.
* tmpfile64: (libc)Temporary Files.
* tmpfile: (libc)Temporary Files.
* tmpnam: (libc)Temporary Files.
* tmpnam_r: (libc)Temporary Files.
* toascii: (libc)Case Conversion.
* tolower: (libc)Case Conversion.
* toupper: (libc)Case Conversion.
* towctrans: (libc)Wide Character Case Conversion.
* towlower: (libc)Wide Character Case Conversion.
* towupper: (libc)Wide Character Case Conversion.
* trunc: (libc)Rounding Functions.
* truncate64: (libc)File Size.
* truncate: (libc)File Size.
* truncf: (libc)Rounding Functions.
* truncl: (libc)Rounding Functions.
* tsearch: (libc)Tree Search Function.
* ttyname: (libc)Is It a Terminal.
* ttyname_r: (libc)Is It a Terminal.
* twalk: (libc)Tree Search Function.
* tzset: (libc)Time Zone Functions.
* ulimit: (libc)Limits on Resources.
* umask: (libc)Setting Permissions.
* umount2: (libc)Mount-Unmount-Remount.
* umount: (libc)Mount-Unmount-Remount.
* uname: (libc)Platform Type.
* ungetc: (libc)How Unread.
* ungetwc: (libc)How Unread.
* unlink: (libc)Deleting Files.
* unlockpt: (libc)Allocation.
* unsetenv: (libc)Environment Access.
* updwtmp: (libc)Manipulating the Database.
* utime: (libc)File Times.
* utimes: (libc)File Times.
* utmpname: (libc)Manipulating the Database.
* utmpxname: (libc)XPG Functions.
* va_arg: (libc)Argument Macros.
* va_end: (libc)Argument Macros.
* va_start: (libc)Argument Macros.
* va_start: (libc)Old Varargs.
* valloc: (libc)Aligned Memory Blocks.
* vasprintf: (libc)Variable Arguments Output.
* verr: (libc)Error Messages.
* verrx: (libc)Error Messages.
* versionsort64: (libc)Scanning Directory Content.
* versionsort: (libc)Scanning Directory Content.
* vfork: (libc)Creating a Process.
* vfprintf: (libc)Variable Arguments Output.
* vfscanf: (libc)Variable Arguments Input.
* vfwprintf: (libc)Variable Arguments Output.
* vfwscanf: (libc)Variable Arguments Input.
* vlimit: (libc)Limits on Resources.
* vprintf: (libc)Variable Arguments Output.
* vscanf: (libc)Variable Arguments Input.
* vsnprintf: (libc)Variable Arguments Output.
* vsprintf: (libc)Variable Arguments Output.
* vsscanf: (libc)Variable Arguments Input.
* vswprintf: (libc)Variable Arguments Output.
* vswscanf: (libc)Variable Arguments Input.
* vsyslog: (libc)syslog; vsyslog.
* vtimes: (libc)Resource Usage.
* vwarn: (libc)Error Messages.
* vwarnx: (libc)Error Messages.
* vwprintf: (libc)Variable Arguments Output.
* vwscanf: (libc)Variable Arguments Input.
* wait3: (libc)BSD Wait Functions.
* wait4: (libc)Process Completion.
* wait: (libc)Process Completion.
* waitpid: (libc)Process Completion.
* warn: (libc)Error Messages.
* warnx: (libc)Error Messages.
* wcpcpy: (libc)Copying and Concatenation.
* wcpncpy: (libc)Copying and Concatenation.
* wcrtomb: (libc)Converting a Character.
* wcscasecmp: (libc)String/Array Comparison.
* wcscat: (libc)Copying and Concatenation.
* wcschr: (libc)Search Functions.
* wcschrnul: (libc)Search Functions.
* wcscmp: (libc)String/Array Comparison.
* wcscoll: (libc)Collation Functions.
* wcscpy: (libc)Copying and Concatenation.
* wcscspn: (libc)Search Functions.
* wcsdup: (libc)Copying and Concatenation.
* wcsftime: (libc)Formatting Calendar Time.
* wcslen: (libc)String Length.
* wcsncasecmp: (libc)String/Array Comparison.
* wcsncat: (libc)Copying and Concatenation.
* wcsncmp: (libc)String/Array Comparison.
* wcsncpy: (libc)Copying and Concatenation.
* wcsnlen: (libc)String Length.
* wcsnrtombs: (libc)Converting Strings.
* wcspbrk: (libc)Search Functions.
* wcsrchr: (libc)Search Functions.
* wcsrtombs: (libc)Converting Strings.
* wcsspn: (libc)Search Functions.
* wcsstr: (libc)Search Functions.
* wcstod: (libc)Parsing of Floats.
* wcstof: (libc)Parsing of Floats.
* wcstoimax: (libc)Parsing of Integers.
* wcstok: (libc)Finding Tokens in a String.
* wcstol: (libc)Parsing of Integers.
* wcstold: (libc)Parsing of Floats.
* wcstoll: (libc)Parsing of Integers.
* wcstombs: (libc)Non-reentrant String Conversion.
* wcstoq: (libc)Parsing of Integers.
* wcstoul: (libc)Parsing of Integers.
* wcstoull: (libc)Parsing of Integers.
* wcstoumax: (libc)Parsing of Integers.
* wcstouq: (libc)Parsing of Integers.
* wcswcs: (libc)Search Functions.
* wcsxfrm: (libc)Collation Functions.
* wctob: (libc)Converting a Character.
* wctomb: (libc)Non-reentrant Character Conversion.
* wctrans: (libc)Wide Character Case Conversion.
* wctype: (libc)Classification of Wide Characters.
* wmemchr: (libc)Search Functions.
* wmemcmp: (libc)String/Array Comparison.
* wmemcpy: (libc)Copying and Concatenation.
* wmemmove: (libc)Copying and Concatenation.
* wmempcpy: (libc)Copying and Concatenation.
* wmemset: (libc)Copying and Concatenation.
* wordexp: (libc)Calling Wordexp.
* wordfree: (libc)Calling Wordexp.
* wprintf: (libc)Formatted Output Functions.
* write: (libc)I/O Primitives.
* writev: (libc)Scatter-Gather.
* wscanf: (libc)Formatted Input Functions.
* y0: (libc)Special Functions.
* y0f: (libc)Special Functions.
* y0l: (libc)Special Functions.
* y1: (libc)Special Functions.
* y1f: (libc)Special Functions.
* y1l: (libc)Special Functions.
* yn: (libc)Special Functions.
* ynf: (libc)Special Functions.
* ynl: (libc)Special Functions.
END-INFO-DIR-ENTRY

   This file documents the GNU C library.

   This is Edition 0.12, last updated 2007-10-27, of `The GNU C Library
Reference Manual', for version 2.8.

   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008, 2010 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation" and
"GNU Lesser General Public License", the Front-Cover texts being "A GNU
Manual", and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."


File: libc.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Main Menu
*********

This is Edition 0.12, last updated 2007-10-27, of `The GNU C Library
Reference Manual', for Version 2.8 of the GNU C Library.

* Menu:

* Introduction::                 Purpose of the GNU C Library.
* Error Reporting::              How library functions report errors.
* Memory::                       Allocating virtual memory and controlling
                                   paging.
* Character Handling::           Character testing and conversion functions.
* String and Array Utilities::   Utilities for copying and comparing strings
                                   and arrays.
* Character Set Handling::       Support for extended character sets.
* Locales::                      The country and language can affect the
                                   behavior of library functions.
* Message Translation::          How to make the program speak the user's
                                   language.
* Searching and Sorting::        General searching and sorting functions.
* Pattern Matching::             Matching shell ``globs'' and regular
                                   expressions.
* I/O Overview::                 Introduction to the I/O facilities.
* I/O on Streams::               High-level, portable I/O facilities.
* Low-Level I/O::                Low-level, less portable I/O.
* File System Interface::        Functions for manipulating files.
* Pipes and FIFOs::              A simple interprocess communication
                                   mechanism.
* Sockets::                      A more complicated IPC mechanism, with
                                   networking support.
* Low-Level Terminal Interface:: How to change the characteristics of a
                                   terminal device.
* Syslog::                       System logging and messaging.
* Mathematics::                  Math functions, useful constants, random
                                   numbers.
* Arithmetic::                   Low level arithmetic functions.
* Date and Time::                Functions for getting the date and time and
                                   formatting them nicely.
* Resource Usage And Limitation:: Functions for examining resource usage and
                                   getting and setting limits.
* Non-Local Exits::              Jumping out of nested function calls.
* Signal Handling::              How to send, block, and handle signals.
* Program Basics::               Writing the beginning and end of your
                                   program.
* Processes::                    How to create processes and run other
                                   programs.
* Job Control::                  All about process groups and sessions.
* Name Service Switch::          Accessing system databases.
* Users and Groups::             How users are identified and classified.
* System Management::            Controlling the system and getting
                                   information about it.
* System Configuration::         Parameters describing operating system
                                   limits.
* Cryptographic Functions::      DES encryption and password handling.
* Debugging Support::            Functions to help debugging applications.

Appendices

* Language Features::            C language features provided by the library.
* Library Summary::              A summary showing the syntax, header file,
                                   and derivation of each library feature.
* Installation::                 How to install the GNU C library.
* Maintenance::                  How to enhance and port the GNU C Library.
* Contributors::                 Who wrote what parts of the GNU C library.
* Free Manuals::		 Free Software Needs Free Documentation.
* Copying::                      The GNU Lesser General Public License says
                                  how you can copy and share the GNU C Library.
* Documentation License::        This manual is under the GNU Free
                                  Documentation License.

Indices

* Concept Index::                Index of concepts and names.
* Type Index::                   Index of types and type qualifiers.
* Function Index::               Index of functions and function-like macros.
* Variable Index::               Index of variables and variable-like macros.
* File Index::                   Index of programs and files.

 --- The Detailed Node Listing ---

Introduction

* Getting Started::             What this manual is for and how to use it.
* Standards and Portability::   Standards and sources upon which the GNU
                                 C library is based.
* Using the Library::           Some practical uses for the library.
* Roadmap to the Manual::       Overview of the remaining chapters in
                                 this manual.

Standards and Portability

* ISO C::                       The international standard for the C
                                 programming language.
* POSIX::                       The ISO/IEC 9945 (aka IEEE 1003) standards
                                 for operating systems.
* Berkeley Unix::               BSD and SunOS.
* SVID::                        The System V Interface Description.
* XPG::                         The X/Open Portability Guide.

Using the Library

* Header Files::                How to include the header files in your
                                 programs.
* Macro Definitions::           Some functions in the library may really
                                 be implemented as macros.
* Reserved Names::              The C standard reserves some names for
                                 the library, and some for users.
* Feature Test Macros::         How to control what names are defined.

Error Reporting

* Checking for Errors::         How errors are reported by library functions.
* Error Codes::                 Error code macros; all of these expand
                                 into integer constant values.
* Error Messages::              Mapping error codes onto error messages.

Memory

* Memory Concepts::             An introduction to concepts and terminology.
* Memory Allocation::           Allocating storage for your program data
* Locking Pages::               Preventing page faults
* Resizing the Data Segment::   `brk', `sbrk'

Memory Allocation

* Memory Allocation and C::     How to get different kinds of allocation in C.
* Unconstrained Allocation::    The `malloc' facility allows fully general
		 		 dynamic allocation.
* Allocation Debugging::        Finding memory leaks and not freed memory.
* Obstacks::                    Obstacks are less general than malloc
				 but more efficient and convenient.
* Variable Size Automatic::     Allocation of variable-sized blocks
				 of automatic storage that are freed when the
				 calling function returns.

Unconstrained Allocation

* Basic Allocation::            Simple use of `malloc'.
* Malloc Examples::             Examples of `malloc'.  `xmalloc'.
* Freeing after Malloc::        Use `free' to free a block you
				 got with `malloc'.
* Changing Block Size::         Use `realloc' to make a block
				 bigger or smaller.
* Allocating Cleared Space::    Use `calloc' to allocate a
				 block and clear it.
* Efficiency and Malloc::       Efficiency considerations in use of
				 these functions.
* Aligned Memory Blocks::       Allocating specially aligned memory.
* Malloc Tunable Parameters::   Use `mallopt' to adjust allocation
                                 parameters.
* Heap Consistency Checking::   Automatic checking for errors.
* Hooks for Malloc::            You can use these hooks for debugging
				 programs that use `malloc'.
* Statistics of Malloc::        Getting information about how much
				 memory your program is using.
* Summary of Malloc::           Summary of `malloc' and related functions.

Allocation Debugging

* Tracing malloc::               How to install the tracing functionality.
* Using the Memory Debugger::    Example programs excerpts.
* Tips for the Memory Debugger:: Some more or less clever ideas.
* Interpreting the traces::      What do all these lines mean?

Obstacks

* Creating Obstacks::		How to declare an obstack in your program.
* Preparing for Obstacks::	Preparations needed before you can
				 use obstacks.
* Allocation in an Obstack::    Allocating objects in an obstack.
* Freeing Obstack Objects::     Freeing objects in an obstack.
* Obstack Functions::		The obstack functions are both
				 functions and macros.
* Growing Objects::             Making an object bigger by stages.
* Extra Fast Growing::		Extra-high-efficiency (though more
				 complicated) growing objects.
* Status of an Obstack::        Inquiries about the status of an obstack.
* Obstacks Data Alignment::     Controlling alignment of objects in obstacks.
* Obstack Chunks::              How obstacks obtain and release chunks;
				 efficiency considerations.
* Summary of Obstacks::

Variable Size Automatic

* Alloca Example::              Example of using `alloca'.
* Advantages of Alloca::        Reasons to use `alloca'.
* Disadvantages of Alloca::     Reasons to avoid `alloca'.
* GNU C Variable-Size Arrays::  Only in GNU C, here is an alternative
				 method of allocating dynamically and
				 freeing automatically.

Locking Pages

* Why Lock Pages::                Reasons to read this section.
* Locked Memory Details::         Everything you need to know locked
                                    memory
* Page Lock Functions::           Here's how to do it.

Character Handling

* Classification of Characters::       Testing whether characters are
			                letters, digits, punctuation, etc.

* Case Conversion::                    Case mapping, and the like.
* Classification of Wide Characters::  Character class determination for
                                        wide characters.
* Using Wide Char Classes::            Notes on using the wide character
                                        classes.
* Wide Character Case Conversion::     Mapping of wide characters.

String and Array Utilities

* Representation of Strings::   Introduction to basic concepts.
* String/Array Conventions::    Whether to use a string function or an
				 arbitrary array function.
* String Length::               Determining the length of a string.
* Copying and Concatenation::   Functions to copy the contents of strings
				 and arrays.
* String/Array Comparison::     Functions for byte-wise and character-wise
				 comparison.
* Collation Functions::         Functions for collating strings.
* Search Functions::            Searching for a specific element or substring.
* Finding Tokens in a String::  Splitting a string into tokens by looking
				 for delimiters.
* strfry::                      Function for flash-cooking a string.
* Trivial Encryption::          Obscuring data.
* Encode Binary Data::          Encoding and Decoding of Binary Data.
* Argz and Envz Vectors::       Null-separated string vectors.

Argz and Envz Vectors

* Argz Functions::              Operations on argz vectors.
* Envz Functions::              Additional operations on environment vectors.

Character Set Handling

* Extended Char Intro::              Introduction to Extended Characters.
* Charset Function Overview::        Overview about Character Handling
                                      Functions.
* Restartable multibyte conversion:: Restartable multibyte conversion
                                      Functions.
* Non-reentrant Conversion::         Non-reentrant Conversion Function.
* Generic Charset Conversion::       Generic Charset Conversion.

Restartable multibyte conversion

* Selecting the Conversion::     Selecting the conversion and its properties.
* Keeping the state::            Representing the state of the conversion.
* Converting a Character::       Converting Single Characters.
* Converting Strings::           Converting Multibyte and Wide Character
                                  Strings.
* Multibyte Conversion Example:: A Complete Multibyte Conversion Example.

Non-reentrant Conversion

* Non-reentrant Character Conversion::  Non-reentrant Conversion of Single
                                         Characters.
* Non-reentrant String Conversion::     Non-reentrant Conversion of Strings.
* Shift State::                         States in Non-reentrant Functions.

Generic Charset Conversion

* Generic Conversion Interface::    Generic Character Set Conversion Interface.
* iconv Examples::                  A complete `iconv' example.
* Other iconv Implementations::     Some Details about other `iconv'
                                     Implementations.
* glibc iconv Implementation::      The `iconv' Implementation in the GNU C
                                     library.

Locales

* Effects of Locale::           Actions affected by the choice of
                                 locale.
* Choosing Locale::             How the user specifies a locale.
* Locale Categories::           Different purposes for which you can
                                 select a locale.
* Setting the Locale::          How a program specifies the locale
                                 with library functions.
* Standard Locales::            Locale names available on all systems.
* Locale Information::          How to access the information for the locale.
* Formatting Numbers::          A dedicated function to format numbers.
* Yes-or-No Questions::         Check a Response against the locale.

Locale Information

* The Lame Way to Locale Data::   ISO C's `localeconv'.
* The Elegant and Fast Way::      X/Open's `nl_langinfo'.

The Lame Way to Locale Data

* General Numeric::             Parameters for formatting numbers and
                                 currency amounts.
* Currency Symbol::             How to print the symbol that identifies an
                                 amount of money (e.g. `$').
* Sign of Money Amount::        How to print the (positive or negative) sign
                                 for a monetary amount, if one exists.

Message Translation

* Message catalogs a la X/Open::  The `catgets' family of functions.
* The Uniforum approach::         The `gettext' family of functions.

Message catalogs a la X/Open

* The catgets Functions::      The `catgets' function family.
* The message catalog files::  Format of the message catalog files.
* The gencat program::         How to generate message catalogs files which
                                can be used by the functions.
* Common Usage::               How to use the `catgets' interface.

The Uniforum approach

* Message catalogs with gettext::  The `gettext' family of functions.
* Helper programs for gettext::    Programs to handle message catalogs
                                    for `gettext'.

Message catalogs with gettext

* Translation with gettext::       What has to be done to translate a message.
* Locating gettext catalog::       How to determine which catalog to be used.
* Advanced gettext functions::     Additional functions for more complicated
                                    situations.
* Charset conversion in gettext::  How to specify the output character set
                                    `gettext' uses.
* GUI program problems::           How to use `gettext' in GUI programs.
* Using gettextized software::     The possibilities of the user to influence
                                    the way `gettext' works.

Searching and Sorting

* Comparison Functions::        Defining how to compare two objects.
				 Since the sort and search facilities
                                 are general, you have to specify the
                                 ordering.
* Array Search Function::       The `bsearch' function.
* Array Sort Function::         The `qsort' function.
* Search/Sort Example::         An example program.
* Hash Search Function::        The `hsearch' function.
* Tree Search Function::        The `tsearch' function.

Pattern Matching

* Wildcard Matching::    Matching a wildcard pattern against a single string.
* Globbing::             Finding the files that match a wildcard pattern.
* Regular Expressions::  Matching regular expressions against strings.
* Word Expansion::       Expanding shell variables, nested commands,
			    arithmetic, and wildcards.
			    This is what the shell does with shell commands.

Globbing

* Calling Glob::             Basic use of `glob'.
* Flags for Globbing::       Flags that enable various options in `glob'.
* More Flags for Globbing::  GNU specific extensions to `glob'.

Regular Expressions

* POSIX Regexp Compilation::    Using `regcomp' to prepare to match.
* Flags for POSIX Regexps::     Syntax variations for `regcomp'.
* Matching POSIX Regexps::      Using `regexec' to match the compiled
				   pattern that you get from `regcomp'.
* Regexp Subexpressions::       Finding which parts of the string were matched.
* Subexpression Complications:: Find points of which parts were matched.
* Regexp Cleanup::		Freeing storage; reporting errors.

Word Expansion

* Expansion Stages::            What word expansion does to a string.
* Calling Wordexp::             How to call `wordexp'.
* Flags for Wordexp::           Options you can enable in `wordexp'.
* Wordexp Example::             A sample program that does word expansion.
* Tilde Expansion::             Details of how tilde expansion works.
* Variable Substitution::       Different types of variable substitution.

I/O Overview

* I/O Concepts::       Some basic information and terminology.
* File Names::         How to refer to a file.

I/O Concepts

* Streams and File Descriptors::    The GNU Library provides two ways
			             to access the contents of files.
* File Position::                   The number of bytes from the
                                     beginning of the file.

File Names

* Directories::                 Directories contain entries for files.
* File Name Resolution::        A file name specifies how to look up a file.
* File Name Errors::            Error conditions relating to file names.
* File Name Portability::       File name portability and syntax issues.

I/O on Streams

* Streams::                     About the data type representing a stream.
* Standard Streams::            Streams to the standard input and output
                                 devices are created for you.
* Opening Streams::             How to create a stream to talk to a file.
* Closing Streams::             Close a stream when you are finished with it.
* Streams and Threads::         Issues with streams in threaded programs.
* Streams and I18N::            Streams in internationalized applications.
* Simple Output::               Unformatted output by characters and lines.
* Character Input::             Unformatted input by characters and words.
* Line Input::                  Reading a line or a record from a stream.
* Unreading::                   Peeking ahead/pushing back input just read.
* Block Input/Output::          Input and output operations on blocks of data.
* Formatted Output::            `printf' and related functions.
* Customizing Printf::          You can define new conversion specifiers for
                                 `printf' and friends.
* Formatted Input::             `scanf' and related functions.
* EOF and Errors::              How you can tell if an I/O error happens.
* Error Recovery::		What you can do about errors.
* Binary Streams::              Some systems distinguish between text files
                                 and binary files.
* File Positioning::            About random-access streams.
* Portable Positioning::        Random access on peculiar ISO C systems.
* Stream Buffering::            How to control buffering of streams.
* Other Kinds of Streams::      Streams that do not necessarily correspond
                                 to an open file.
* Formatted Messages::          Print strictly formatted messages.

Unreading

* Unreading Idea::              An explanation of unreading with pictures.
* How Unread::                  How to call `ungetc' to do unreading.

Formatted Output

* Formatted Output Basics::     Some examples to get you started.
* Output Conversion Syntax::    General syntax of conversion
                                 specifications.
* Table of Output Conversions:: Summary of output conversions and
                                 what they do.
* Integer Conversions::         Details about formatting of integers.
* Floating-Point Conversions::  Details about formatting of
                                 floating-point numbers.
* Other Output Conversions::    Details about formatting of strings,
                                 characters, pointers, and the like.
* Formatted Output Functions::  Descriptions of the actual functions.
* Dynamic Output::		Functions that allocate memory for the output.
* Variable Arguments Output::   `vprintf' and friends.
* Parsing a Template String::   What kinds of args does a given template
                                 call for?
* Example of Parsing::          Sample program using `parse_printf_format'.

Customizing Printf

* Registering New Conversions::         Using `register_printf_function'
                                         to register a new output conversion.
* Conversion Specifier Options::        The handler must be able to get
                                         the options specified in the
                                         template when it is called.
* Defining the Output Handler::         Defining the handler and arginfo
                                         functions that are passed as arguments
                                         to `register_printf_function'.
* Printf Extension Example::            How to define a `printf'
                                         handler function.
* Predefined Printf Handlers::          Predefined `printf' handlers.

Formatted Input

* Formatted Input Basics::      Some basics to get you started.
* Input Conversion Syntax::     Syntax of conversion specifications.
* Table of Input Conversions::  Summary of input conversions and what they do.
* Numeric Input Conversions::   Details of conversions for reading numbers.
* String Input Conversions::    Details of conversions for reading strings.
* Dynamic String Input::	String conversions that `malloc' the buffer.
* Other Input Conversions::     Details of miscellaneous other conversions.
* Formatted Input Functions::   Descriptions of the actual functions.
* Variable Arguments Input::    `vscanf' and friends.

Stream Buffering

* Buffering Concepts::          Terminology is defined here.
* Flushing Buffers::            How to ensure that output buffers are flushed.
* Controlling Buffering::       How to specify what kind of buffering to use.

Other Kinds of Streams

* String Streams::              Streams that get data from or put data in
                                 a string or memory buffer.
* Obstack Streams::		Streams that store data in an obstack.
* Custom Streams::              Defining your own streams with an arbitrary
                                 input data source and/or output data sink.

Custom Streams

* Streams and Cookies::         The "cookie" records where to fetch or
                                 store data that is read or written.
* Hook Functions::              How you should define the four "hook
                                 functions" that a custom stream needs.

Formatted Messages

* Printing Formatted Messages::   The `fmtmsg' function.
* Adding Severity Classes::       Add more severity classes.
* Example::                       How to use `fmtmsg' and `addseverity'.

Low-Level I/O

* Opening and Closing Files::           How to open and close file
                                         descriptors.
* I/O Primitives::                      Reading and writing data.
* File Position Primitive::             Setting a descriptor's file
                                         position.
* Descriptors and Streams::             Converting descriptor to stream
                                         or vice-versa.
* Stream/Descriptor Precautions::       Precautions needed if you use both
                                         descriptors and streams.
* Scatter-Gather::                      Fast I/O to discontinuous buffers.
* Memory-mapped I/O::                   Using files like memory.
* Waiting for I/O::                     How to check for input or output
					 on multiple file descriptors.
* Synchronizing I/O::                   Making sure all I/O actions completed.
* Asynchronous I/O::                    Perform I/O in parallel.
* Control Operations::                  Various other operations on file
					 descriptors.
* Duplicating Descriptors::             Fcntl commands for duplicating
                                         file descriptors.
* Descriptor Flags::                    Fcntl commands for manipulating
                                         flags associated with file
                                         descriptors.
* File Status Flags::                   Fcntl commands for manipulating
                                         flags associated with open files.
* File Locks::                          Fcntl commands for implementing
                                         file locking.
* Interrupt Input::                     Getting an asynchronous signal when
                                         input arrives.
* IOCTLs::                              Generic I/O Control operations.

Stream/Descriptor Precautions

* Linked Channels::	   Dealing with channels sharing a file position.
* Independent Channels::   Dealing with separately opened, unlinked channels.
* Cleaning Streams::	   Cleaning a stream makes it safe to use
                            another channel.

Asynchronous I/O

* Asynchronous Reads/Writes::    Asynchronous Read and Write Operations.
* Status of AIO Operations::     Getting the Status of AIO Operations.
* Synchronizing AIO Operations:: Getting into a consistent state.
* Cancel AIO Operations::        Cancellation of AIO Operations.
* Configuration of AIO::         How to optimize the AIO implementation.

File Status Flags

* Access Modes::                Whether the descriptor can read or write.
* Open-time Flags::             Details of `open'.
* Operating Modes::             Special modes to control I/O operations.
* Getting File Status Flags::   Fetching and changing these flags.

File System Interface

* Working Directory::           This is used to resolve relative
				 file names.
* Accessing Directories::       Finding out what files a directory
				 contains.
* Working with Directory Trees:: Apply actions to all files or a selectable
                                 subset of a directory hierarchy.
* Hard Links::                  Adding alternate names to a file.
* Symbolic Links::              A file that ``points to'' a file name.
* Deleting Files::              How to delete a file, and what that means.
* Renaming Files::              Changing a file's name.
* Creating Directories::        A system call just for creating a directory.
* File Attributes::             Attributes of individual files.
* Making Special Files::        How to create special files.
* Temporary Files::             Naming and creating temporary files.

Accessing Directories

* Directory Entries::           Format of one directory entry.
* Opening a Directory::         How to open a directory stream.
* Reading/Closing Directory::   How to read directory entries from the stream.
* Simple Directory Lister::     A very simple directory listing program.
* Random Access Directory::     Rereading part of the directory
                                 already read with the same stream.
* Scanning Directory Content::  Get entries for user selected subset of
                                 contents in given directory.
* Simple Directory Lister Mark II::  Revised version of the program.

File Attributes

* Attribute Meanings::          The names of the file attributes,
                                 and what their values mean.
* Reading Attributes::          How to read the attributes of a file.
* Testing File Type::           Distinguishing ordinary files,
                                 directories, links...
* File Owner::                  How ownership for new files is determined,
			         and how to change it.
* Permission Bits::             How information about a file's access
                                 mode is stored.
* Access Permission::           How the system decides who can access a file.
* Setting Permissions::         How permissions for new files are assigned,
			         and how to change them.
* Testing File Access::         How to find out if your process can
                                 access a file.
* File Times::                  About the time attributes of a file.
* File Size::			Manually changing the size of a file.

Pipes and FIFOs

* Creating a Pipe::             Making a pipe with the `pipe' function.
* Pipe to a Subprocess::        Using a pipe to communicate with a
				 child process.
* FIFO Special Files::          Making a FIFO special file.
* Pipe Atomicity::		When pipe (or FIFO) I/O is atomic.

Sockets

* Socket Concepts::	Basic concepts you need to know about.
* Communication Styles::Stream communication, datagrams and other styles.
* Socket Addresses::	How socket names (``addresses'') work.
* Interface Naming::	Identifying specific network interfaces.
* Local Namespace::	Details about the local namespace.
* Internet Namespace::	Details about the Internet namespace.
* Misc Namespaces::	Other namespaces not documented fully here.
* Open/Close Sockets::  Creating sockets and destroying them.
* Connections::		Operations on sockets with connection state.
* Datagrams::		Operations on datagram sockets.
* Inetd::		Inetd is a daemon that starts servers on request.
			   The most convenient way to write a server
			   is to make it work with Inetd.
* Socket Options::	Miscellaneous low-level socket options.
* Networks Database::   Accessing the database of network names.

Socket Addresses

* Address Formats::		About `struct sockaddr'.
* Setting Address::		Binding an address to a socket.
* Reading Address::		Reading the address of a socket.

Local Namespace

* Concepts: Local Namespace Concepts. What you need to understand.
* Details: Local Namespace Details.   Address format, symbolic names, etc.
* Example: Local Socket Example.      Example of creating a socket.

Internet Namespace

* Internet Address Formats::    How socket addresses are specified in the
                                 Internet namespace.
* Host Addresses::	        All about host addresses of Internet host.
* Protocols Database::		Referring to protocols by name.
* Ports::			Internet port numbers.
* Services Database::           Ports may have symbolic names.
* Byte Order::		        Different hosts may use different byte
                                 ordering conventions; you need to
                                 canonicalize host address and port number.
* Inet Example::	        Putting it all together.

Host Addresses

* Abstract Host Addresses::	What a host number consists of.
* Data type: Host Address Data Type.	Data type for a host number.
* Functions: Host Address Functions.	Functions to operate on them.
* Names: Host Names.		Translating host names to host numbers.

Open/Close Sockets

* Creating a Socket::           How to open a socket.
* Closing a Socket::            How to close a socket.
* Socket Pairs::                These are created like pipes.

Connections

* Connecting::    	     What the client program must do.
* Listening::		     How a server program waits for requests.
* Accepting Connections::    What the server does when it gets a request.
* Who is Connected::	     Getting the address of the
				other side of a connection.
* Transferring Data::        How to send and receive data.
* Byte Stream Example::	     An example program: a client for communicating
			      over a byte stream socket in the Internet namespace.
* Server Example::	     A corresponding server program.
* Out-of-Band Data::         This is an advanced feature.

Transferring Data

* Sending Data::		Sending data with `send'.
* Receiving Data::		Reading data with `recv'.
* Socket Data Options::		Using `send' and `recv'.

Datagrams

* Sending Datagrams::    Sending packets on a datagram socket.
* Receiving Datagrams::  Receiving packets on a datagram socket.
* Datagram Example::     An example program: packets sent over a
                           datagram socket in the local namespace.
* Example Receiver::	 Another program, that receives those packets.

Inetd

* Inetd Servers::
* Configuring Inetd::

Socket Options

* Socket Option Functions::     The basic functions for setting and getting
                                 socket options.
* Socket-Level Options::        Details of the options at the socket level.

Low-Level Terminal Interface

* Is It a Terminal::            How to determine if a file is a terminal
			         device, and what its name is.
* I/O Queues::                  About flow control and typeahead.
* Canonical or Not::            Two basic styles of input processing.
* Terminal Modes::              How to examine and modify flags controlling
			         details of terminal I/O: echoing,
                                 signals, editing.  Posix.
* BSD Terminal Modes::          BSD compatible terminal mode setting
* Line Control::                Sending break sequences, clearing
                                 terminal buffers ...
* Noncanon Example::            How to read single characters without echo.
* Pseudo-Terminals::            How to open a pseudo-terminal.

Terminal Modes

* Mode Data Types::             The data type `struct termios' and
                                 related types.
* Mode Functions::              Functions to read and set the terminal
                                 attributes.
* Setting Modes::               The right way to set terminal attributes
                                 reliably.
* Input Modes::                 Flags controlling low-level input handling.
* Output Modes::                Flags controlling low-level output handling.
* Control Modes::               Flags controlling serial port behavior.
* Local Modes::                 Flags controlling high-level input handling.
* Line Speed::                  How to read and set the terminal line speed.
* Special Characters::          Characters that have special effects,
			         and how to change them.
* Noncanonical Input::          Controlling how long to wait for input.

Special Characters

* Editing Characters::          Special characters that terminate lines and
                                  delete text, and other editing functions.
* Signal Characters::           Special characters that send or raise signals
                                  to or for certain classes of processes.
* Start/Stop Characters::       Special characters that suspend or resume
                                  suspended output.
* Other Special::		Other special characters for BSD systems:
				  they can discard output, and print status.

Pseudo-Terminals

* Allocation::             Allocating a pseudo terminal.
* Pseudo-Terminal Pairs::  How to open both sides of a
                            pseudo-terminal in a single operation.

Syslog

* Overview of Syslog::           Overview of a system's Syslog facility
* Submitting Syslog Messages::   Functions to submit messages to Syslog

Submitting Syslog Messages

* openlog::                      Open connection to Syslog
* syslog; vsyslog::              Submit message to Syslog
* closelog::                     Close connection to Syslog
* setlogmask::                   Cause certain messages to be ignored
* Syslog Example::               Example of all of the above

Mathematics

* Mathematical Constants::      Precise numeric values for often-used
                                 constants.
* Trig Functions::              Sine, cosine, tangent, and friends.
* Inverse Trig Functions::      Arcsine, arccosine, etc.
* Exponents and Logarithms::    Also pow and sqrt.
* Hyperbolic Functions::        sinh, cosh, tanh, etc.
* Special Functions::           Bessel, gamma, erf.
* Errors in Math Functions::    Known Maximum Errors in Math Functions.
* Pseudo-Random Numbers::       Functions for generating pseudo-random
				 numbers.
* FP Function Optimizations::   Fast code or small code.

Pseudo-Random Numbers

* ISO Random::                  `rand' and friends.
* BSD Random::                  `random' and friends.
* SVID Random::                 `drand48' and friends.

Arithmetic

* Integers::                    Basic integer types and concepts
* Integer Division::            Integer division with guaranteed rounding.
* Floating Point Numbers::      Basic concepts.  IEEE 754.
* Floating Point Classes::      The five kinds of floating-point number.
* Floating Point Errors::       When something goes wrong in a calculation.
* Rounding::                    Controlling how results are rounded.
* Control Functions::           Saving and restoring the FPU's state.
* Arithmetic Functions::        Fundamental operations provided by the library.
* Complex Numbers::             The types.  Writing complex constants.
* Operations on Complex::       Projection, conjugation, decomposition.
* Parsing of Numbers::          Converting strings to numbers.
* System V Number Conversion::  An archaic way to convert numbers to strings.

Floating Point Errors

* FP Exceptions::               IEEE 754 math exceptions and how to detect them.
* Infinity and NaN::            Special values returned by calculations.
* Status bit operations::       Checking for exceptions after the fact.
* Math Error Reporting::        How the math functions report errors.

Arithmetic Functions

* Absolute Value::              Absolute values of integers and floats.
* Normalization Functions::     Extracting exponents and putting them back.
* Rounding Functions::          Rounding floats to integers.
* Remainder Functions::         Remainders on division, precisely defined.
* FP Bit Twiddling::            Sign bit adjustment.  Adding epsilon.
* FP Comparison Functions::     Comparisons without risk of exceptions.
* Misc FP Arithmetic::          Max, min, positive difference, multiply-add.

Parsing of Numbers

* Parsing of Integers::         Functions for conversion of integer values.
* Parsing of Floats::           Functions for conversion of floating-point
				 values.

Date and Time

* Time Basics::                 Concepts and definitions.
* Elapsed Time::                Data types to represent elapsed times
* Processor And CPU Time::      Time a program has spent executing.
* Calendar Time::               Manipulation of ``real'' dates and times.
* Setting an Alarm::            Sending a signal after a specified time.
* Sleeping::                    Waiting for a period of time.

Processor And CPU Time

* CPU Time::                    The `clock' function.
* Processor Time::              The `times' function.

Calendar Time

* Simple Calendar Time::        Facilities for manipulating calendar time.
* High-Resolution Calendar::    A time representation with greater precision.
* Broken-down Time::            Facilities for manipulating local time.
* High Accuracy Clock::         Maintaining a high accuracy system clock.
* Formatting Calendar Time::    Converting times to strings.
* Parsing Date and Time::       Convert textual time and date information back
                                 into broken-down time values.
* TZ Variable::                 How users specify the time zone.
* Time Zone Functions::         Functions to examine or specify the time zone.
* Time Functions Example::      An example program showing use of some of
				 the time functions.

Parsing Date and Time

* Low-Level Time String Parsing::  Interpret string according to given format.
* General Time String Parsing::    User-friendly function to parse data and
                                    time strings.

Resource Usage And Limitation

* Resource Usage::		Measuring various resources used.
* Limits on Resources::		Specifying limits on resource usage.
* Priority::			Reading or setting process run priority.
* Memory Resources::            Querying memory available resources.
* Processor Resources::         Learn about the processors available.

Priority

* Absolute Priority::               The first tier of priority.  Posix
* Realtime Scheduling::             Scheduling among the process nobility
* Basic Scheduling Functions::      Get/set scheduling policy, priority
* Traditional Scheduling::          Scheduling among the vulgar masses
* CPU Affinity::                    Limiting execution to certain CPUs

Traditional Scheduling

* Traditional Scheduling Intro::
* Traditional Scheduling Functions::

Memory Resources

* Memory Subsystem::           Overview about traditional Unix memory handling.
* Query Memory Parameters::    How to get information about the memory
                                subsystem?

Non-Local Exits

* Intro: Non-Local Intro.        When and how to use these facilities.
* Details: Non-Local Details.    Functions for non-local exits.
* Non-Local Exits and Signals::  Portability issues.
* System V contexts::            Complete context control a la System V.

Signal Handling

* Concepts of Signals::         Introduction to the signal facilities.
* Standard Signals::            Particular kinds of signals with
                                 standard names and meanings.
* Signal Actions::              Specifying what happens when a
                                 particular signal is delivered.
* Defining Handlers::           How to write a signal handler function.
* Interrupted Primitives::	Signal handlers affect use of `open',
				 `read', `write' and other functions.
* Generating Signals::          How to send a signal to a process.
* Blocking Signals::            Making the system hold signals temporarily.
* Waiting for a Signal::        Suspending your program until a signal
                                 arrives.
* Signal Stack::                Using a Separate Signal Stack.
* BSD Signal Handling::         Additional functions for backward
			         compatibility with BSD.

Concepts of Signals

* Kinds of Signals::            Some examples of what can cause a signal.
* Signal Generation::           Concepts of why and how signals occur.
* Delivery of Signal::          Concepts of what a signal does to the
                                 process.

Standard Signals

* Program Error Signals::       Used to report serious program errors.
* Termination Signals::         Used to interrupt and/or terminate the
                                 program.
* Alarm Signals::               Used to indicate expiration of timers.
* Asynchronous I/O Signals::    Used to indicate input is available.
* Job Control Signals::         Signals used to support job control.
* Operation Error Signals::     Used to report operational system errors.
* Miscellaneous Signals::       Miscellaneous Signals.
* Signal Messages::             Printing a message describing a signal.

Signal Actions

* Basic Signal Handling::       The simple `signal' function.
* Advanced Signal Handling::    The more powerful `sigaction' function.
* Signal and Sigaction::        How those two functions interact.
* Sigaction Function Example::  An example of using the sigaction function.
* Flags for Sigaction::         Specifying options for signal handling.
* Initial Signal Actions::      How programs inherit signal actions.

Defining Handlers

* Handler Returns::             Handlers that return normally, and what
                                 this means.
* Termination in Handler::      How handler functions terminate a program.
* Longjmp in Handler::          Nonlocal transfer of control out of a
                                 signal handler.
* Signals in Handler::          What happens when signals arrive while
                                 the handler is already occupied.
* Merged Signals::		When a second signal arrives before the
				 first is handled.
* Nonreentrancy::               Do not call any functions unless you know they
                                 are reentrant with respect to signals.
* Atomic Data Access::          A single handler can run in the middle of
                                 reading or writing a single object.

Atomic Data Access

* Non-atomic Example::		A program illustrating interrupted access.
* Types: Atomic Types.		Data types that guarantee no interruption.
* Usage: Atomic Usage.		Proving that interruption is harmless.

Generating Signals

* Signaling Yourself::          A process can send a signal to itself.
* Signaling Another Process::   Send a signal to another process.
* Permission for kill::         Permission for using `kill'.
* Kill Example::                Using `kill' for Communication.

Blocking Signals

* Why Block::                           The purpose of blocking signals.
* Signal Sets::                         How to specify which signals to
                                         block.
* Process Signal Mask::                 Blocking delivery of signals to your
				         process during normal execution.
* Testing for Delivery::                Blocking to Test for Delivery of
                                         a Signal.
* Blocking for Handler::                Blocking additional signals while a
				         handler is being run.
* Checking for Pending Signals::        Checking for Pending Signals
* Remembering a Signal::                How you can get almost the same
                                         effect as blocking a signal, by
                                         handling it and setting a flag
                                         to be tested later.

Waiting for a Signal

* Using Pause::                 The simple way, using `pause'.
* Pause Problems::              Why the simple way is often not very good.
* Sigsuspend::                  Reliably waiting for a specific signal.

BSD Signal Handling

* BSD Handler::                 BSD Function to Establish a Handler.
* Blocking in BSD::             BSD Functions for Blocking Signals.

Program Basics

* Program Arguments::           Parsing your program's command-line arguments.
* Environment Variables::       Less direct parameters affecting your program
* System Calls::                Requesting service from the system
* Program Termination::         Telling the system you're done; return status

Program Arguments

* Argument Syntax::             By convention, options start with a hyphen.
* Parsing Program Arguments::   Ways to parse program options and arguments.

Parsing Program Arguments

* Getopt::                      Parsing program options using `getopt'.
* Argp::                        Parsing program options using `argp_parse'.
* Suboptions::                  Some programs need more detailed options.
* Suboptions Example::          This shows how it could be done for `mount'.

Environment Variables

* Environment Access::          How to get and set the values of
				 environment variables.
* Standard Environment::        These environment variables have
                		 standard interpretations.

Program Termination

* Normal Termination::          If a program calls `exit', a
                                 process terminates normally.
* Exit Status::                 The `exit status' provides information
                                 about why the process terminated.
* Cleanups on Exit::            A process can run its own cleanup
                                 functions upon normal termination.
* Aborting a Program::          The `abort' function causes
                                 abnormal program termination.
* Termination Internals::       What happens when a process terminates.

Processes

* Running a Command::           The easy way to run another program.
* Process Creation Concepts::   An overview of the hard way to do it.
* Process Identification::      How to get the process ID of a process.
* Creating a Process::          How to fork a child process.
* Executing a File::            How to make a process execute another program.
* Process Completion::          How to tell when a child process has completed.
* Process Completion Status::   How to interpret the status value
                                 returned from a child process.
* BSD Wait Functions::  	More functions, for backward compatibility.
* Process Creation Example::    A complete example program.

Job Control

* Concepts of Job Control::     Jobs can be controlled by a shell.
* Job Control is Optional::     Not all POSIX systems support job control.
* Controlling Terminal::        How a process gets its controlling terminal.
* Access to the Terminal::      How processes share the controlling terminal.
* Orphaned Process Groups::     Jobs left after the user logs out.
* Implementing a Shell::        What a shell must do to implement job control.
* Functions for Job Control::   Functions to control process groups.

Implementing a Shell

* Data Structures::             Introduction to the sample shell.
* Initializing the Shell::      What the shell must do to take
				 responsibility for job control.
* Launching Jobs::              Creating jobs to execute commands.
* Foreground and Background::   Putting a job in foreground of background.
* Stopped and Terminated Jobs::  Reporting job status.
* Continuing Stopped Jobs::     How to continue a stopped job in
				 the foreground or background.
* Missing Pieces::              Other parts of the shell.

Functions for Job Control

* Identifying the Terminal::    Determining the controlling terminal's name.
* Process Group Functions::     Functions for manipulating process groups.
* Terminal Access Functions::   Functions for controlling terminal access.

Name Service Switch

* NSS Basics::                  What is this NSS good for.
* NSS Configuration File::      Configuring NSS.
* NSS Module Internals::        How does it work internally.
* Extending NSS::               What to do to add services or databases.

NSS Configuration File

* Services in the NSS configuration::  Service names in the NSS configuration.
* Actions in the NSS configuration::  React appropriately to the lookup result.
* Notes on NSS Configuration File::  Things to take care about while
                                     configuring NSS.

NSS Module Internals

* NSS Module Names::            Construction of the interface function of
                                the NSS modules.
* NSS Modules Interface::       Programming interface in the NSS module
                                functions.

Extending NSS

* Adding another Service to NSS::  What is to do to add a new service.
* NSS Module Function Internals::  Guidelines for writing new NSS
                                        service functions.

Users and Groups

* User and Group IDs::          Each user has a unique numeric ID;
				 likewise for groups.
* Process Persona::             The user IDs and group IDs of a process.
* Why Change Persona::          Why a program might need to change
				 its user and/or group IDs.
* How Change Persona::          Changing the user and group IDs.
* Reading Persona::             How to examine the user and group IDs.

* Setting User ID::             Functions for setting the user ID.
* Setting Groups::              Functions for setting the group IDs.

* Enable/Disable Setuid::       Turning setuid access on and off.
* Setuid Program Example::      The pertinent parts of one sample program.
* Tips for Setuid::             How to avoid granting unlimited access.

* Who Logged In::               Getting the name of the user who logged in,
				 or of the real user ID of the current process.

* User Accounting Database::    Keeping information about users and various
                                 actions in databases.

* User Database::               Functions and data structures for
                        	 accessing the user database.
* Group Database::              Functions and data structures for
                        	 accessing the group database.
* Database Example::            Example program showing the use of database
				 inquiry functions.
* Netgroup Database::           Functions for accessing the netgroup database.

User Accounting Database

* Manipulating the Database::   Scanning and modifying the user
                                 accounting database.
* XPG Functions::               A standardized way for doing the same thing.
* Logging In and Out::          Functions from BSD that modify the user
                                 accounting database.

User Database

* User Data Structure::         What each user record contains.
* Lookup User::                 How to look for a particular user.
* Scanning All Users::          Scanning the list of all users, one by one.
* Writing a User Entry::        How a program can rewrite a user's record.

Group Database

* Group Data Structure::        What each group record contains.
* Lookup Group::                How to look for a particular group.
* Scanning All Groups::         Scanning the list of all groups.

Netgroup Database

* Netgroup Data::                  Data in the Netgroup database and where
                                   it comes from.
* Lookup Netgroup::                How to look for a particular netgroup.
* Netgroup Membership::            How to test for netgroup membership.

System Management

* Host Identification::         Determining the name of the machine.
* Platform Type::               Determining operating system and basic
                                  machine type
* Filesystem Handling::         Controlling/querying mounts
* System Parameters::           Getting and setting various system parameters

Filesystem Handling

* Mount Information::           What is or could be mounted?
* Mount-Unmount-Remount::       Controlling what is mounted and how

Mount Information

* fstab::                       The `fstab' file
* mtab::                        The `mtab' file
* Other Mount Information::     Other (non-libc) sources of mount information

System Configuration

* General Limits::           Constants and functions that describe
				various process-related limits that have
				one uniform value for any given machine.
* System Options::           Optional POSIX features.
* Version Supported::        Version numbers of POSIX.1 and POSIX.2.
* Sysconf::                  Getting specific configuration values
                                of general limits and system options.
* Minimums::                 Minimum values for general limits.

* Limits for Files::         Size limitations that pertain to individual files.
                                These can vary between file systems
                                or even from file to file.
* Options for Files::        Optional features that some files may support.
* File Minimums::            Minimum values for file limits.
* Pathconf::                 Getting the limit values for a particular file.

* Utility Limits::           Capacity limits of some POSIX.2 utility programs.
* Utility Minimums::         Minimum allowable values of those limits.

* String Parameters::        Getting the default search path.

Sysconf

* Sysconf Definition::        Detailed specifications of `sysconf'.
* Constants for Sysconf::     The list of parameters `sysconf' can read.
* Examples of Sysconf::       How to use `sysconf' and the parameter
				 macros properly together.

Cryptographic Functions

* Legal Problems::              This software can get you locked up, or worse.
* getpass::                     Prompting the user for a password.
* crypt::                       A one-way function for passwords.
* DES Encryption::              Routines for DES encryption.

Debugging Support

* Backtraces::                Obtaining and printing a back trace of the
                               current stack.

Language Features

* Consistency Checking::        Using `assert' to abort if
				 something ``impossible'' happens.
* Variadic Functions::          Defining functions with varying numbers
                                 of args.
* Null Pointer Constant::       The macro `NULL'.
* Important Data Types::        Data types for object sizes.
* Data Type Measurements::      Parameters of data type representations.

Variadic Functions

* Why Variadic::                Reasons for making functions take
                                 variable arguments.
* How Variadic::                How to define and call variadic functions.
* Variadic Example::            A complete example.

How Variadic

* Variadic Prototypes::  How to make a prototype for a function
			  with variable arguments.
* Receiving Arguments::  Steps you must follow to access the
			  optional argument values.
* How Many Arguments::   How to decide whether there are more arguments.
* Calling Variadics::    Things you need to know about calling
			  variable arguments functions.
* Argument Macros::      Detailed specification of the macros
        		  for accessing variable arguments.
* Old Varargs::		 The pre-ISO way of defining variadic functions.

Data Type Measurements

* Width of Type::           How many bits does an integer type hold?
* Range of Type::           What are the largest and smallest values
			     that an integer type can hold?
* Floating Type Macros::    Parameters that measure the floating point types.
* Structure Measurement::   Getting measurements on structure types.

Floating Type Macros

* Floating Point Concepts::     Definitions of terminology.
* Floating Point Parameters::   Details of specific macros.
* IEEE Floating Point::         The measurements for one common
                                 representation.

Installation

* Configuring and compiling::   How to compile and test GNU libc.
* Running make install::        How to install it once you've got it
 compiled.
* Tools for Compilation::       You'll need these first.
* Linux::                       Specific advice for GNU/Linux systems.
* Reporting Bugs::              So they'll get fixed.

Maintenance

* Source Layout::         How to add new functions or header files
                             to the GNU C library.
* Porting::               How to port the GNU C library to
                             a new machine or operating system.

Porting

* Hierarchy Conventions::       The layout of the `sysdeps' hierarchy.
* Porting to Unix::             Porting the library to an average
                                   Unix-like system.


File: libc.info,  Node: Introduction,  Next: Error Reporting,  Prev: Top,  Up: Top

1 Introduction
**************

The C language provides no built-in facilities for performing such
common operations as input/output, memory management, string
manipulation, and the like.  Instead, these facilities are defined in a
standard "library", which you compile and link with your programs.  

   The GNU C library, described in this document, defines all of the
library functions that are specified by the ISO C standard, as well as
additional features specific to POSIX and other derivatives of the Unix
operating system, and extensions specific to the GNU system.

   The purpose of this manual is to tell you how to use the facilities
of the GNU library.  We have mentioned which features belong to which
standards to help you identify things that are potentially non-portable
to other systems.  But the emphasis in this manual is not on strict
portability.

* Menu:

* Getting Started::             What this manual is for and how to use it.
* Standards and Portability::   Standards and sources upon which the GNU
                                 C library is based.
* Using the Library::           Some practical uses for the library.
* Roadmap to the Manual::       Overview of the remaining chapters in
                                 this manual.


File: libc.info,  Node: Getting Started,  Next: Standards and Portability,  Up: Introduction

1.1 Getting Started
===================

This manual is written with the assumption that you are at least
somewhat familiar with the C programming language and basic programming
concepts.  Specifically, familiarity with ISO standard C (*note ISO
C::), rather than "traditional" pre-ISO C dialects, is assumed.

   The GNU C library includes several "header files", each of which
provides definitions and declarations for a group of related facilities;
this information is used by the C compiler when processing your program.
For example, the header file `stdio.h' declares facilities for
performing input and output, and the header file `string.h' declares
string processing utilities.  The organization of this manual generally
follows the same division as the header files.

   If you are reading this manual for the first time, you should read
all of the introductory material and skim the remaining chapters.
There are a _lot_ of functions in the GNU C library and it's not
realistic to expect that you will be able to remember exactly _how_ to
use each and every one of them.  It's more important to become
generally familiar with the kinds of facilities that the library
provides, so that when you are writing your programs you can recognize
_when_ to make use of library functions, and _where_ in this manual you
can find more specific information about them.


File: libc.info,  Node: Standards and Portability,  Next: Using the Library,  Prev: Getting Started,  Up: Introduction

1.2 Standards and Portability
=============================

This section discusses the various standards and other sources that the
GNU C library is based upon.  These sources include the ISO C and POSIX
standards, and the System V and Berkeley Unix implementations.

   The primary focus of this manual is to tell you how to make effective
use of the GNU library facilities.  But if you are concerned about
making your programs compatible with these standards, or portable to
operating systems other than GNU, this can affect how you use the
library.  This section gives you an overview of these standards, so that
you will know what they are when they are mentioned in other parts of
the manual.

   *Note Library Summary::, for an alphabetical list of the functions
and other symbols provided by the library.  This list also states which
standards each function or symbol comes from.

* Menu:

* ISO C::                       The international standard for the C
                                 programming language.
* POSIX::                       The ISO/IEC 9945 (aka IEEE 1003) standards
                                 for operating systems.
* Berkeley Unix::               BSD and SunOS.
* SVID::                        The System V Interface Description.
* XPG::                         The X/Open Portability Guide.


File: libc.info,  Node: ISO C,  Next: POSIX,  Up: Standards and Portability

1.2.1 ISO C
-----------

The GNU C library is compatible with the C standard adopted by the
American National Standards Institute (ANSI): `American National
Standard X3.159-1989--"ANSI C"' and later by the International
Standardization Organization (ISO): `ISO/IEC 9899:1990, "Programming
languages--C"'.  We here refer to the standard as ISO C since this is
the more general standard in respect of ratification.  The header files
and library facilities that make up the GNU library are a superset of
those specified by the ISO C standard.

   If you are concerned about strict adherence to the ISO C standard,
you should use the `-ansi' option when you compile your programs with
the GNU C compiler.  This tells the compiler to define _only_ ISO
standard features from the library header files, unless you explicitly
ask for additional features.  *Note Feature Test Macros::, for
information on how to do this.

   Being able to restrict the library to include only ISO C features is
important because ISO C puts limitations on what names can be defined
by the library implementation, and the GNU extensions don't fit these
limitations.  *Note Reserved Names::, for more information about these
restrictions.

   This manual does not attempt to give you complete details on the
differences between ISO C and older dialects.  It gives advice on how
to write programs to work portably under multiple C dialects, but does
not aim for completeness.


File: libc.info,  Node: POSIX,  Next: Berkeley Unix,  Prev: ISO C,  Up: Standards and Portability

1.2.2 POSIX (The Portable Operating System Interface)
-----------------------------------------------------

The GNU library is also compatible with the ISO "POSIX" family of
standards, known more formally as the "Portable Operating System
Interface for Computer Environments" (ISO/IEC 9945).  They were also
published as ANSI/IEEE Std 1003.  POSIX is derived mostly from various
versions of the Unix operating system.

   The library facilities specified by the POSIX standards are a
superset of those required by ISO C; POSIX specifies additional
features for ISO C functions, as well as specifying new additional
functions.  In general, the additional requirements and functionality
defined by the POSIX standards are aimed at providing lower-level
support for a particular kind of operating system environment, rather
than general programming language support which can run in many diverse
operating system environments.

   The GNU C library implements all of the functions specified in
`ISO/IEC 9945-1:1996, the POSIX System Application Program Interface',
commonly referred to as POSIX.1.  The primary extensions to the ISO C
facilities specified by this standard include file system interface
primitives (*note File System Interface::), device-specific terminal
control functions (*note Low-Level Terminal Interface::), and process
control functions (*note Processes::).

   Some facilities from `ISO/IEC 9945-2:1993, the POSIX Shell and
Utilities standard' (POSIX.2) are also implemented in the GNU library.
These include utilities for dealing with regular expressions and other
pattern matching facilities (*note Pattern Matching::).


File: libc.info,  Node: Berkeley Unix,  Next: SVID,  Prev: POSIX,  Up: Standards and Portability

1.2.3 Berkeley Unix
-------------------

The GNU C library defines facilities from some versions of Unix which
are not formally standardized, specifically from the 4.2 BSD, 4.3 BSD,
and 4.4 BSD Unix systems (also known as "Berkeley Unix") and from
"SunOS" (a popular 4.2 BSD derivative that includes some Unix System V
functionality).  These systems support most of the ISO C and POSIX
facilities, and 4.4 BSD and newer releases of SunOS in fact support
them all.

   The BSD facilities include symbolic links (*note Symbolic Links::),
the `select' function (*note Waiting for I/O::), the BSD signal
functions (*note BSD Signal Handling::), and sockets (*note Sockets::).


File: libc.info,  Node: SVID,  Next: XPG,  Prev: Berkeley Unix,  Up: Standards and Portability

1.2.4 SVID (The System V Interface Description)
-----------------------------------------------

The "System V Interface Description" (SVID) is a document describing
the AT&T Unix System V operating system.  It is to some extent a
superset of the POSIX standard (*note POSIX::).

   The GNU C library defines most of the facilities required by the SVID
that are not also required by the ISO C or POSIX standards, for
compatibility with  System V Unix and other Unix systems (such as
SunOS) which include these facilities.  However, many of the more
obscure and less generally useful facilities required by the SVID are
not included.  (In fact, Unix System V itself does not provide them
all.)

   The supported facilities from System V include the methods for
inter-process communication and shared memory, the `hsearch' and
`drand48' families of functions, `fmtmsg' and several of the
mathematical functions.


File: libc.info,  Node: XPG,  Prev: SVID,  Up: Standards and Portability

1.2.5 XPG (The X/Open Portability Guide)
----------------------------------------

The X/Open Portability Guide, published by the X/Open Company, Ltd., is
a more general standard than POSIX.  X/Open owns the Unix copyright and
the XPG specifies the requirements for systems which are intended to be
a Unix system.

   The GNU C library complies to the X/Open Portability Guide, Issue
4.2, with all extensions common to XSI (X/Open System Interface)
compliant systems and also all X/Open UNIX extensions.

   The additions on top of POSIX are mainly derived from functionality
available in System V and BSD systems.  Some of the really bad mistakes
in System V systems were corrected, though.  Since fulfilling the XPG
standard with the Unix extensions is a precondition for getting the
Unix brand chances are good that the functionality is available on
commercial systems.


File: libc.info,  Node: Using the Library,  Next: Roadmap to the Manual,  Prev: Standards and Portability,  Up: Introduction

1.3 Using the Library
=====================

This section describes some of the practical issues involved in using
the GNU C library.

* Menu:

* Header Files::                How to include the header files in your
                                 programs.
* Macro Definitions::           Some functions in the library may really
                                 be implemented as macros.
* Reserved Names::              The C standard reserves some names for
                                 the library, and some for users.
* Feature Test Macros::         How to control what names are defined.


File: libc.info,  Node: Header Files,  Next: Macro Definitions,  Up: Using the Library

1.3.1 Header Files
------------------

Libraries for use by C programs really consist of two parts: "header
files" that define types and macros and declare variables and
functions; and the actual library or "archive" that contains the
definitions of the variables and functions.

   (Recall that in C, a "declaration" merely provides information that
a function or variable exists and gives its type.  For a function
declaration, information about the types of its arguments might be
provided as well.  The purpose of declarations is to allow the compiler
to correctly process references to the declared variables and functions.
A "definition", on the other hand, actually allocates storage for a
variable or says what a function does.)  

   In order to use the facilities in the GNU C library, you should be
sure that your program source files include the appropriate header
files.  This is so that the compiler has declarations of these
facilities available and can correctly process references to them.
Once your program has been compiled, the linker resolves these
references to the actual definitions provided in the archive file.

   Header files are included into a program source file by the
`#include' preprocessor directive.  The C language supports two forms
of this directive; the first,

     #include "HEADER"

is typically used to include a header file HEADER that you write
yourself; this would contain definitions and declarations describing the
interfaces between the different parts of your particular application.
By contrast,

     #include <file.h>

is typically used to include a header file `file.h' that contains
definitions and declarations for a standard library.  This file would
normally be installed in a standard place by your system administrator.
You should use this second form for the C library header files.

   Typically, `#include' directives are placed at the top of the C
source file, before any other code.  If you begin your source files with
some comments explaining what the code in the file does (a good idea),
put the `#include' directives immediately afterwards, following the
feature test macro definition (*note Feature Test Macros::).

   For more information about the use of header files and `#include'
directives, *note Header Files: (cpp.info)Header Files.

   The GNU C library provides several header files, each of which
contains the type and macro definitions and variable and function
declarations for a group of related facilities.  This means that your
programs may need to include several header files, depending on exactly
which facilities you are using.

   Some library header files include other library header files
automatically.  However, as a matter of programming style, you should
not rely on this; it is better to explicitly include all the header
files required for the library facilities you are using.  The GNU C
library header files have been written in such a way that it doesn't
matter if a header file is accidentally included more than once;
including a header file a second time has no effect.  Likewise, if your
program needs to include multiple header files, the order in which they
are included doesn't matter.

   *Compatibility Note:* Inclusion of standard header files in any
order and any number of times works in any ISO C implementation.
However, this has traditionally not been the case in many older C
implementations.

   Strictly speaking, you don't _have to_ include a header file to use
a function it declares; you could declare the function explicitly
yourself, according to the specifications in this manual.  But it is
usually better to include the header file because it may define types
and macros that are not otherwise available and because it may define
more efficient macro replacements for some functions.  It is also a sure
way to have the correct declaration.


File: libc.info,  Node: Macro Definitions,  Next: Reserved Names,  Prev: Header Files,  Up: Using the Library

1.3.2 Macro Definitions of Functions
------------------------------------

If we describe something as a function in this manual, it may have a
macro definition as well.  This normally has no effect on how your
program runs--the macro definition does the same thing as the function
would.  In particular, macro equivalents for library functions evaluate
arguments exactly once, in the same way that a function call would.  The
main reason for these macro definitions is that sometimes they can
produce an inline expansion that is considerably faster than an actual
function call.

   Taking the address of a library function works even if it is also
defined as a macro.  This is because, in this context, the name of the
function isn't followed by the left parenthesis that is syntactically
necessary to recognize a macro call.

   You might occasionally want to avoid using the macro definition of a
function--perhaps to make your program easier to debug.  There are two
ways you can do this:

   * You can avoid a macro definition in a specific use by enclosing
     the name of the function in parentheses.  This works because the
     name of the function doesn't appear in a syntactic context where
     it is recognizable as a macro call.

   * You can suppress any macro definition for a whole source file by
     using the `#undef' preprocessor directive, unless otherwise stated
     explicitly in the description of that facility.

   For example, suppose the header file `stdlib.h' declares a function
named `abs' with

     extern int abs (int);

and also provides a macro definition for `abs'.  Then, in:

     #include <stdlib.h>
     int f (int *i) { return abs (++*i); }

the reference to `abs' might refer to either a macro or a function.  On
the other hand, in each of the following examples the reference is to a
function and not a macro.

     #include <stdlib.h>
     int g (int *i) { return (abs) (++*i); }

     #undef abs
     int h (int *i) { return abs (++*i); }

   Since macro definitions that double for a function behave in exactly
the same way as the actual function version, there is usually no need
for any of these methods.  In fact, removing macro definitions usually
just makes your program slower.


File: libc.info,  Node: Reserved Names,  Next: Feature Test Macros,  Prev: Macro Definitions,  Up: Using the Library

1.3.3 Reserved Names
--------------------

The names of all library types, macros, variables and functions that
come from the ISO C standard are reserved unconditionally; your program
*may not* redefine these names.  All other library names are reserved
if your program explicitly includes the header file that defines or
declares them.  There are several reasons for these restrictions:

   * Other people reading your code could get very confused if you were
     using a function named `exit' to do something completely different
     from what the standard `exit' function does, for example.
     Preventing this situation helps to make your programs easier to
     understand and contributes to modularity and maintainability.

   * It avoids the possibility of a user accidentally redefining a
     library function that is called by other library functions.  If
     redefinition were allowed, those other functions would not work
     properly.

   * It allows the compiler to do whatever special optimizations it
     pleases on calls to these functions, without the possibility that
     they may have been redefined by the user.  Some library
     facilities, such as those for dealing with variadic arguments
     (*note Variadic Functions::) and non-local exits (*note Non-Local
     Exits::), actually require a considerable amount of cooperation on
     the part of the C compiler, and with respect to the
     implementation, it might be easier for the compiler to treat these
     as built-in parts of the language.

   In addition to the names documented in this manual, reserved names
include all external identifiers (global functions and variables) that
begin with an underscore (`_') and all identifiers regardless of use
that begin with either two underscores or an underscore followed by a
capital letter are reserved names.  This is so that the library and
header files can define functions, variables, and macros for internal
purposes without risk of conflict with names in user programs.

   Some additional classes of identifier names are reserved for future
extensions to the C language or the POSIX.1 environment.  While using
these names for your own purposes right now might not cause a problem,
they do raise the possibility of conflict with future versions of the C
or POSIX standards, so you should avoid these names.

   * Names beginning with a capital `E' followed a digit or uppercase
     letter may be used for additional error code names.  *Note Error
     Reporting::.

   * Names that begin with either `is' or `to' followed by a lowercase
     letter may be used for additional character testing and conversion
     functions.  *Note Character Handling::.

   * Names that begin with `LC_' followed by an uppercase letter may be
     used for additional macros specifying locale attributes.  *Note
     Locales::.

   * Names of all existing mathematics functions (*note Mathematics::)
     suffixed with `f' or `l' are reserved for corresponding functions
     that operate on `float' and `long double' arguments, respectively.

   * Names that begin with `SIG' followed by an uppercase letter are
     reserved for additional signal names.  *Note Standard Signals::.

   * Names that begin with `SIG_' followed by an uppercase letter are
     reserved for additional signal actions.  *Note Basic Signal
     Handling::.

   * Names beginning with `str', `mem', or `wcs' followed by a
     lowercase letter are reserved for additional string and array
     functions.  *Note String and Array Utilities::.

   * Names that end with `_t' are reserved for additional type names.

   In addition, some individual header files reserve names beyond those
that they actually define.  You only need to worry about these
restrictions if your program includes that particular header file.

   * The header file `dirent.h' reserves names prefixed with `d_'.  

   * The header file `fcntl.h' reserves names prefixed with `l_', `F_',
     `O_', and `S_'.  

   * The header file `grp.h' reserves names prefixed with `gr_'.  

   * The header file `limits.h' reserves names suffixed with `_MAX'.  

   * The header file `pwd.h' reserves names prefixed with `pw_'.  

   * The header file `signal.h' reserves names prefixed with `sa_' and
     `SA_'.  

   * The header file `sys/stat.h' reserves names prefixed with `st_'
     and `S_'.  

   * The header file `sys/times.h' reserves names prefixed with `tms_'.  

   * The header file `termios.h' reserves names prefixed with `c_',
     `V', `I', `O', and `TC'; and names prefixed with `B' followed by a
     digit.  


File: libc.info,  Node: Feature Test Macros,  Prev: Reserved Names,  Up: Using the Library

1.3.4 Feature Test Macros
-------------------------

The exact set of features available when you compile a source file is
controlled by which "feature test macros" you define.

   If you compile your programs using `gcc -ansi', you get only the
ISO C library features, unless you explicitly request additional
features by defining one or more of the feature macros.  *Note GNU CC
Command Options: (gcc.info)Invoking GCC, for more information about GCC
options.

   You should define these macros by using `#define' preprocessor
directives at the top of your source code files.  These directives
_must_ come before any `#include' of a system header file.  It is best
to make them the very first thing in the file, preceded only by
comments.  You could also use the `-D' option to GCC, but it's better
if you make the source files indicate their own meaning in a
self-contained way.

   This system exists to allow the library to conform to multiple
standards.  Although the different standards are often described as
supersets of each other, they are usually incompatible because larger
standards require functions with names that smaller ones reserve to the
user program.  This is not mere pedantry -- it has been a problem in
practice.  For instance, some non-GNU programs define functions named
`getline' that have nothing to do with this library's `getline'.  They
would not be compilable if all features were enabled indiscriminately.

   This should not be used to verify that a program conforms to a
limited standard.  It is insufficient for this purpose, as it will not
protect you from including header files outside the standard, or
relying on semantics undefined within the standard.

 -- Macro: _POSIX_SOURCE
     If you define this macro, then the functionality from the POSIX.1
     standard (IEEE Standard 1003.1) is available, as well as all of the
     ISO C facilities.

     The state of `_POSIX_SOURCE' is irrelevant if you define the macro
     `_POSIX_C_SOURCE' to a positive integer.

 -- Macro: _POSIX_C_SOURCE
     Define this macro to a positive integer to control which POSIX
     functionality is made available.  The greater the value of this
     macro, the more functionality is made available.

     If you define this macro to a value greater than or equal to `1',
     then the functionality from the 1990 edition of the POSIX.1
     standard (IEEE Standard 1003.1-1990) is made available.

     If you define this macro to a value greater than or equal to `2',
     then the functionality from the 1992 edition of the POSIX.2
     standard (IEEE Standard 1003.2-1992) is made available.

     If you define this macro to a value greater than or equal to
     `199309L', then the functionality from the 1993 edition of the
     POSIX.1b standard (IEEE Standard 1003.1b-1993) is made available.

     Greater values for `_POSIX_C_SOURCE' will enable future extensions.
     The POSIX standards process will define these values as necessary,
     and the GNU C Library should support them some time after they
     become standardized.  The 1996 edition of POSIX.1 (ISO/IEC 9945-1:
     1996) states that if you define `_POSIX_C_SOURCE' to a value
     greater than or equal to `199506L', then the functionality from
     the 1996 edition is made available.

 -- Macro: _BSD_SOURCE
     If you define this macro, functionality derived from 4.3 BSD Unix
     is included as well as the ISO C, POSIX.1, and POSIX.2 material.

     Some of the features derived from 4.3 BSD Unix conflict with the
     corresponding features specified by the POSIX.1 standard.  If this
     macro is defined, the 4.3 BSD definitions take precedence over the
     POSIX definitions.

     Due to the nature of some of the conflicts between 4.3 BSD and
     POSIX.1, you need to use a special "BSD compatibility library"
     when linking programs compiled for BSD compatibility.  This is
     because some functions must be defined in two different ways, one
     of them in the normal C library, and one of them in the
     compatibility library.  If your program defines `_BSD_SOURCE', you
     must give the option `-lbsd-compat' to the compiler or linker when
     linking the program, to tell it to find functions in this special
     compatibility library before looking for them in the normal C
     library.  

 -- Macro: _SVID_SOURCE
     If you define this macro, functionality derived from SVID is
     included as well as the ISO C, POSIX.1, POSIX.2, and X/Open
     material.

 -- Macro: _XOPEN_SOURCE
 -- Macro: _XOPEN_SOURCE_EXTENDED
     If you define this macro, functionality described in the X/Open
     Portability Guide is included.  This is a superset of the POSIX.1
     and POSIX.2 functionality and in fact `_POSIX_SOURCE' and
     `_POSIX_C_SOURCE' are automatically defined.

     As the unification of all Unices, functionality only available in
     BSD and SVID is also included.

     If the macro `_XOPEN_SOURCE_EXTENDED' is also defined, even more
     functionality is available.  The extra functions will make all
     functions available which are necessary for the X/Open Unix brand.

     If the macro `_XOPEN_SOURCE' has the value 500 this includes all
     functionality described so far plus some new definitions from the
     Single Unix Specification, version 2.

 -- Macro: _LARGEFILE_SOURCE
     If this macro is defined some extra functions are available which
     rectify a few shortcomings in all previous standards.
     Specifically, the functions `fseeko' and `ftello' are available.
     Without these functions the difference between the ISO C interface
     (`fseek', `ftell') and the low-level POSIX interface (`lseek')
     would lead to problems.

     This macro was introduced as part of the Large File Support
     extension (LFS).

 -- Macro: _LARGEFILE64_SOURCE
     If you define this macro an additional set of functions is made
     available which enables 32 bit systems to use files of sizes beyond
     the usual limit of 2GB.  This interface is not available if the
     system does not support files that large.  On systems where the
     natural file size limit is greater than 2GB (i.e., on 64 bit
     systems) the new functions are identical to the replaced functions.

     The new functionality is made available by a new set of types and
     functions which replace the existing ones.  The names of these new
     objects contain `64' to indicate the intention, e.g., `off_t' vs.
     `off64_t' and `fseeko' vs. `fseeko64'.

     This macro was introduced as part of the Large File Support
     extension (LFS).  It is a transition interface for the period when
     64 bit offsets are not generally used (see `_FILE_OFFSET_BITS').

 -- Macro: _FILE_OFFSET_BITS
     This macro determines which file system interface shall be used,
     one replacing the other.  Whereas `_LARGEFILE64_SOURCE' makes the
     64 bit interface available as an additional interface,
     `_FILE_OFFSET_BITS' allows the 64 bit interface to replace the old
     interface.

     If `_FILE_OFFSET_BITS' is undefined, or if it is defined to the
     value `32', nothing changes.  The 32 bit interface is used and
     types like `off_t' have a size of 32 bits on 32 bit systems.

     If the macro is defined to the value `64', the large file interface
     replaces the old interface.  I.e., the functions are not made
     available under different names (as they are with
     `_LARGEFILE64_SOURCE').  Instead the old function names now
     reference the new functions, e.g., a call to `fseeko' now indeed
     calls `fseeko64'.

     This macro should only be selected if the system provides
     mechanisms for handling large files.  On 64 bit systems this macro
     has no effect since the `*64' functions are identical to the
     normal functions.

     This macro was introduced as part of the Large File Support
     extension (LFS).

 -- Macro: _ISOC99_SOURCE
     Until the revised ISO C standard is widely adopted the new features
     are not automatically enabled.  The GNU libc nevertheless has a
     complete implementation of the new standard and to enable the new
     features the macro `_ISOC99_SOURCE' should be defined.

 -- Macro: _GNU_SOURCE
     If you define this macro, everything is included: ISO C89,
     ISO C99, POSIX.1, POSIX.2, BSD, SVID, X/Open, LFS, and GNU
     extensions.  In the cases where POSIX.1 conflicts with BSD, the
     POSIX definitions take precedence.

     If you want to get the full effect of `_GNU_SOURCE' but make the
     BSD definitions take precedence over the POSIX definitions, use
     this sequence of definitions:

          #define _GNU_SOURCE
          #define _BSD_SOURCE
          #define _SVID_SOURCE

     Note that if you do this, you must link your program with the BSD
     compatibility library by passing the `-lbsd-compat' option to the
     compiler or linker.  *NB:* If you forget to do this, you may get
     very strange errors at run time.

 -- Macro: _REENTRANT
 -- Macro: _THREAD_SAFE
     If you define one of these macros, reentrant versions of several
     functions get declared.  Some of the functions are specified in
     POSIX.1c but many others are only available on a few other systems
     or are unique to GNU libc.  The problem is the delay in the
     standardization of the thread safe C library interface.

     Unlike on some other systems, no special version of the C library
     must be used for linking.  There is only one version but while
     compiling this it must have been specified to compile as thread
     safe.

   We recommend you use `_GNU_SOURCE' in new programs.  If you don't
specify the `-ansi' option to GCC and don't define any of these macros
explicitly, the effect is the same as defining `_POSIX_C_SOURCE' to 2
and `_POSIX_SOURCE', `_SVID_SOURCE', and `_BSD_SOURCE' to 1.

   When you define a feature test macro to request a larger class of
features, it is harmless to define in addition a feature test macro for
a subset of those features.  For example, if you define
`_POSIX_C_SOURCE', then defining `_POSIX_SOURCE' as well has no effect.
Likewise, if you define `_GNU_SOURCE', then defining either
`_POSIX_SOURCE' or `_POSIX_C_SOURCE' or `_SVID_SOURCE' as well has no
effect.

   Note, however, that the features of `_BSD_SOURCE' are not a subset of
any of the other feature test macros supported.  This is because it
defines BSD features that take precedence over the POSIX features that
are requested by the other macros.  For this reason, defining
`_BSD_SOURCE' in addition to the other feature test macros does have an
effect: it causes the BSD features to take priority over the conflicting
POSIX features.


File: libc.info,  Node: Roadmap to the Manual,  Prev: Using the Library,  Up: Introduction

1.4 Roadmap to the Manual
=========================

Here is an overview of the contents of the remaining chapters of this
manual.

   * *Note Error Reporting::, describes how errors detected by the
     library are reported.

   * *Note Language Features::, contains information about library
     support for standard parts of the C language, including things
     like the `sizeof' operator and the symbolic constant `NULL', how
     to write functions accepting variable numbers of arguments, and
     constants describing the ranges and other properties of the
     numerical types.  There is also a simple debugging mechanism which
     allows you to put assertions in your code, and have diagnostic
     messages printed if the tests fail.

   * *Note Memory::, describes the GNU library's facilities for
     managing and using virtual and real memory, including dynamic
     allocation of virtual memory.  If you do not know in advance how
     much memory your program needs, you can allocate it dynamically
     instead, and manipulate it via pointers.

   * *Note Character Handling::, contains information about character
     classification functions (such as `isspace') and functions for
     performing case conversion.

   * *Note String and Array Utilities::, has descriptions of functions
     for manipulating strings (null-terminated character arrays) and
     general byte arrays, including operations such as copying and
     comparison.

   * *Note I/O Overview::, gives an overall look at the input and output
     facilities in the library, and contains information about basic
     concepts such as file names.

   * *Note I/O on Streams::, describes I/O operations involving streams
     (or `FILE *' objects).  These are the normal C library functions
     from `stdio.h'.

   * *Note Low-Level I/O::, contains information about I/O operations
     on file descriptors.  File descriptors are a lower-level mechanism
     specific to the Unix family of operating systems.

   * *Note File System Interface::, has descriptions of operations on
     entire files, such as functions for deleting and renaming them and
     for creating new directories.  This chapter also contains
     information about how you can access the attributes of a file,
     such as its owner and file protection modes.

   * *Note Pipes and FIFOs::, contains information about simple
     interprocess communication mechanisms.  Pipes allow communication
     between two related processes (such as between a parent and
     child), while FIFOs allow communication between processes sharing
     a common file system on the same machine.

   * *Note Sockets::, describes a more complicated interprocess
     communication mechanism that allows processes running on different
     machines to communicate over a network.  This chapter also
     contains information about Internet host addressing and how to use
     the system network databases.

   * *Note Low-Level Terminal Interface::, describes how you can change
     the attributes of a terminal device.  If you want to disable echo
     of characters typed by the user, for example, read this chapter.

   * *Note Mathematics::, contains information about the math library
     functions.  These include things like random-number generators and
     remainder functions on integers as well as the usual trigonometric
     and exponential functions on floating-point numbers.

   * *Note Low-Level Arithmetic Functions: Arithmetic, describes
     functions for simple arithmetic, analysis of floating-point
     values, and reading numbers from strings.

   * *Note Searching and Sorting::, contains information about functions
     for searching and sorting arrays.  You can use these functions on
     any kind of array by providing an appropriate comparison function.

   * *Note Pattern Matching::, presents functions for matching regular
     expressions and shell file name patterns, and for expanding words
     as the shell does.

   * *Note Date and Time::, describes functions for measuring both
     calendar time and CPU time, as well as functions for setting
     alarms and timers.

   * *Note Character Set Handling::, contains information about
     manipulating characters and strings using character sets larger
     than will fit in the usual `char' data type.

   * *Note Locales::, describes how selecting a particular country or
     language affects the behavior of the library.  For example, the
     locale affects collation sequences for strings and how monetary
     values are formatted.

   * *Note Non-Local Exits::, contains descriptions of the `setjmp' and
     `longjmp' functions.  These functions provide a facility for
     `goto'-like jumps which can jump from one function to another.

   * *Note Signal Handling::, tells you all about signals--what they
     are, how to establish a handler that is called when a particular
     kind of signal is delivered, and how to prevent signals from
     arriving during critical sections of your program.

   * *Note Program Basics::, tells how your programs can access their
     command-line arguments and environment variables.

   * *Note Processes::, contains information about how to start new
     processes and run programs.

   * *Note Job Control::, describes functions for manipulating process
     groups and the controlling terminal.  This material is probably
     only of interest if you are writing a shell or other program which
     handles job control specially.

   * *Note Name Service Switch::, describes the services which are
     available for looking up names in the system databases, how to
     determine which service is used for which database, and how these
     services are implemented so that contributors can design their own
     services.

   * *Note User Database::, and *Note Group Database::, tell you how to
     access the system user and group databases.

   * *Note System Management::, describes functions for controlling and
     getting information about the hardware and software configuration
     your program is executing under.

   * *Note System Configuration::, tells you how you can get
     information about various operating system limits.  Most of these
     parameters are provided for compatibility with POSIX.

   * *Note Library Summary::, gives a summary of all the functions,
     variables, and macros in the library, with complete data types and
     function prototypes, and says what standard or system each is
     derived from.

   * *Note Maintenance::, explains how to build and install the GNU C
     library on your system, how to report any bugs you might find, and
     how to add new functions or port the library to a new system.

   If you already know the name of the facility you are interested in,
you can look it up in *Note Library Summary::.  This gives you a
summary of its syntax and a pointer to where you can find a more
detailed description.  This appendix is particularly useful if you just
want to verify the order and type of arguments to a function, for
example.  It also tells you what standard or system each function,
variable, or macro is derived from.


File: libc.info,  Node: Error Reporting,  Next: Memory,  Prev: Introduction,  Up: Top

2 Error Reporting
*****************

Many functions in the GNU C library detect and report error conditions,
and sometimes your programs need to check for these error conditions.
For example, when you open an input file, you should verify that the
file was actually opened correctly, and print an error message or take
other appropriate action if the call to the library function failed.

   This chapter describes how the error reporting facility works.  Your
program should include the header file `errno.h' to use this facility.  

* Menu:

* Checking for Errors::         How errors are reported by library functions.
* Error Codes::                 Error code macros; all of these expand
                                 into integer constant values.
* Error Messages::              Mapping error codes onto error messages.


File: libc.info,  Node: Checking for Errors,  Next: Error Codes,  Up: Error Reporting

2.1 Checking for Errors
=======================

Most library functions return a special value to indicate that they have
failed.  The special value is typically `-1', a null pointer, or a
constant such as `EOF' that is defined for that purpose.  But this
return value tells you only that an error has occurred.  To find out
what kind of error it was, you need to look at the error code stored in
the variable `errno'.  This variable is declared in the header file
`errno.h'.  

 -- Variable: volatile int errno
     The variable `errno' contains the system error number.  You can
     change the value of `errno'.

     Since `errno' is declared `volatile', it might be changed
     asynchronously by a signal handler; see *Note Defining Handlers::.
     However, a properly written signal handler saves and restores the
     value of `errno', so you generally do not need to worry about this
     possibility except when writing signal handlers.

     The initial value of `errno' at program startup is zero.  Many
     library functions are guaranteed to set it to certain nonzero
     values when they encounter certain kinds of errors.  These error
     conditions are listed for each function.  These functions do not
     change `errno' when they succeed; thus, the value of `errno' after
     a successful call is not necessarily zero, and you should not use
     `errno' to determine _whether_ a call failed.  The proper way to
     do that is documented for each function.  _If_ the call failed,
     you can examine `errno'.

     Many library functions can set `errno' to a nonzero value as a
     result of calling other library functions which might fail.  You
     should assume that any library function might alter `errno' when
     the function returns an error.

     *Portability Note:* ISO C specifies `errno' as a "modifiable
     lvalue" rather than as a variable, permitting it to be implemented
     as a macro.  For example, its expansion might involve a function
     call, like `*_errno ()'.  In fact, that is what it is on the GNU
     system itself.  The GNU library, on non-GNU systems, does whatever
     is right for the particular system.

     There are a few library functions, like `sqrt' and `atan', that
     return a perfectly legitimate value in case of an error, but also
     set `errno'.  For these functions, if you want to check to see
     whether an error occurred, the recommended method is to set `errno'
     to zero before calling the function, and then check its value
     afterward.

   All the error codes have symbolic names; they are macros defined in
`errno.h'.  The names start with `E' and an upper-case letter or digit;
you should consider names of this form to be reserved names.  *Note
Reserved Names::.

   The error code values are all positive integers and are all distinct,
with one exception: `EWOULDBLOCK' and `EAGAIN' are the same.  Since the
values are distinct, you can use them as labels in a `switch'
statement; just don't use both `EWOULDBLOCK' and `EAGAIN'.  Your
program should not make any other assumptions about the specific values
of these symbolic constants.

   The value of `errno' doesn't necessarily have to correspond to any
of these macros, since some library functions might return other error
codes of their own for other situations.  The only values that are
guaranteed to be meaningful for a particular library function are the
ones that this manual lists for that function.

   On non-GNU systems, almost any system call can return `EFAULT' if it
is given an invalid pointer as an argument.  Since this could only
happen as a result of a bug in your program, and since it will not
happen on the GNU system, we have saved space by not mentioning
`EFAULT' in the descriptions of individual functions.

   In some Unix systems, many system calls can also return `EFAULT' if
given as an argument a pointer into the stack, and the kernel for some
obscure reason fails in its attempt to extend the stack.  If this ever
happens, you should probably try using statically or dynamically
allocated memory instead of stack memory on that system.


File: libc.info,  Node: Error Codes,  Next: Error Messages,  Prev: Checking for Errors,  Up: Error Reporting

2.2 Error Codes
===============

The error code macros are defined in the header file `errno.h'.  All of
them expand into integer constant values.  Some of these error codes
can't occur on the GNU system, but they can occur using the GNU library
on other systems.

 -- Macro: int EPERM
     Operation not permitted; only the owner of the file (or other
     resource) or processes with special privileges can perform the
     operation.

 -- Macro: int ENOENT
     No such file or directory.  This is a "file doesn't exist" error
     for ordinary files that are referenced in contexts where they are
     expected to already exist.

 -- Macro: int ESRCH
     No process matches the specified process ID.

 -- Macro: int EINTR
     Interrupted function call; an asynchronous signal occurred and
     prevented completion of the call.  When this happens, you should
     try the call again.

     You can choose to have functions resume after a signal that is
     handled, rather than failing with `EINTR'; see *Note Interrupted
     Primitives::.

 -- Macro: int EIO
     Input/output error; usually used for physical read or write errors.

 -- Macro: int ENXIO
     No such device or address.  The system tried to use the device
     represented by a file you specified, and it couldn't find the
     device.  This can mean that the device file was installed
     incorrectly, or that the physical device is missing or not
     correctly attached to the computer.

 -- Macro: int E2BIG
     Argument list too long; used when the arguments passed to a new
     program being executed with one of the `exec' functions (*note
     Executing a File::) occupy too much memory space.  This condition
     never arises in the GNU system.

 -- Macro: int ENOEXEC
     Invalid executable file format.  This condition is detected by the
     `exec' functions; see *Note Executing a File::.

 -- Macro: int EBADF
     Bad file descriptor; for example, I/O on a descriptor that has been
     closed or reading from a descriptor open only for writing (or vice
     versa).

 -- Macro: int ECHILD
     There are no child processes.  This error happens on operations
     that are supposed to manipulate child processes, when there aren't
     any processes to manipulate.

 -- Macro: int EDEADLK
     Deadlock avoided; allocating a system resource would have resulted
     in a deadlock situation.  The system does not guarantee that it
     will notice all such situations.  This error means you got lucky
     and the system noticed; it might just hang.  *Note File Locks::,
     for an example.

 -- Macro: int ENOMEM
     No memory available.  The system cannot allocate more virtual
     memory because its capacity is full.

 -- Macro: int EACCES
     Permission denied; the file permissions do not allow the attempted
     operation.

 -- Macro: int EFAULT
     Bad address; an invalid pointer was detected.  In the GNU system,
     this error never happens; you get a signal instead.

 -- Macro: int ENOTBLK
     A file that isn't a block special file was given in a situation
     that requires one.  For example, trying to mount an ordinary file
     as a file system in Unix gives this error.

 -- Macro: int EBUSY
     Resource busy; a system resource that can't be shared is already
     in use.  For example, if you try to delete a file that is the root
     of a currently mounted filesystem, you get this error.

 -- Macro: int EEXIST
     File exists; an existing file was specified in a context where it
     only makes sense to specify a new file.

 -- Macro: int EXDEV
     An attempt to make an improper link across file systems was
     detected.  This happens not only when you use `link' (*note Hard
     Links::) but also when you rename a file with `rename' (*note
     Renaming Files::).

 -- Macro: int ENODEV
     The wrong type of device was given to a function that expects a
     particular sort of device.

 -- Macro: int ENOTDIR
     A file that isn't a directory was specified when a directory is
     required.

 -- Macro: int EISDIR
     File is a directory; you cannot open a directory for writing, or
     create or remove hard links to it.

 -- Macro: int EINVAL
     Invalid argument.  This is used to indicate various kinds of
     problems with passing the wrong argument to a library function.

 -- Macro: int EMFILE
     The current process has too many files open and can't open any
     more.  Duplicate descriptors do count toward this limit.

     In BSD and GNU, the number of open files is controlled by a
     resource limit that can usually be increased.  If you get this
     error, you might want to increase the `RLIMIT_NOFILE' limit or
     make it unlimited; *note Limits on Resources::.

 -- Macro: int ENFILE
     There are too many distinct file openings in the entire system.
     Note that any number of linked channels count as just one file
     opening; see *Note Linked Channels::.  This error never occurs in
     the GNU system.

 -- Macro: int ENOTTY
     Inappropriate I/O control operation, such as trying to set terminal
     modes on an ordinary file.

 -- Macro: int ETXTBSY
     An attempt to execute a file that is currently open for writing, or
     write to a file that is currently being executed.  Often using a
     debugger to run a program is considered having it open for writing
     and will cause this error.  (The name stands for "text file
     busy".)  This is not an error in the GNU system; the text is
     copied as necessary.

 -- Macro: int EFBIG
     File too big; the size of a file would be larger than allowed by
     the system.

 -- Macro: int ENOSPC
     No space left on device; write operation on a file failed because
     the disk is full.

 -- Macro: int ESPIPE
     Invalid seek operation (such as on a pipe).

 -- Macro: int EROFS
     An attempt was made to modify something on a read-only file system.

 -- Macro: int EMLINK
     Too many links; the link count of a single file would become too
     large.  `rename' can cause this error if the file being renamed
     already has as many links as it can take (*note Renaming Files::).

 -- Macro: int EPIPE
     Broken pipe; there is no process reading from the other end of a
     pipe.  Every library function that returns this error code also
     generates a `SIGPIPE' signal; this signal terminates the program
     if not handled or blocked.  Thus, your program will never actually
     see `EPIPE' unless it has handled or blocked `SIGPIPE'.

 -- Macro: int EDOM
     Domain error; used by mathematical functions when an argument
     value does not fall into the domain over which the function is
     defined.

 -- Macro: int ERANGE
     Range error; used by mathematical functions when the result value
     is not representable because of overflow or underflow.

 -- Macro: int EAGAIN
     Resource temporarily unavailable; the call might work if you try
     again later.  The macro `EWOULDBLOCK' is another name for `EAGAIN';
     they are always the same in the GNU C library.

     This error can happen in a few different situations:

        * An operation that would block was attempted on an object that
          has non-blocking mode selected.  Trying the same operation
          again will block until some external condition makes it
          possible to read, write, or connect (whatever the operation).
          You can use `select' to find out when the operation will be
          possible; *note Waiting for I/O::.

          *Portability Note:* In many older Unix systems, this condition
          was indicated by `EWOULDBLOCK', which was a distinct error
          code different from `EAGAIN'.  To make your program portable,
          you should check for both codes and treat them the same.

        * A temporary resource shortage made an operation impossible.
          `fork' can return this error.  It indicates that the shortage
          is expected to pass, so your program can try the call again
          later and it may succeed.  It is probably a good idea to
          delay for a few seconds before trying it again, to allow time
          for other processes to release scarce resources.  Such
          shortages are usually fairly serious and affect the whole
          system, so usually an interactive program should report the
          error to the user and return to its command loop.

 -- Macro: int EWOULDBLOCK
     In the GNU C library, this is another name for `EAGAIN' (above).
     The values are always the same, on every operating system.

     C libraries in many older Unix systems have `EWOULDBLOCK' as a
     separate error code.

 -- Macro: int EINPROGRESS
     An operation that cannot complete immediately was initiated on an
     object that has non-blocking mode selected.  Some functions that
     must always block (such as `connect'; *note Connecting::) never
     return `EAGAIN'.  Instead, they return `EINPROGRESS' to indicate
     that the operation has begun and will take some time.  Attempts to
     manipulate the object before the call completes return `EALREADY'.
     You can use the `select' function to find out when the pending
     operation has completed; *note Waiting for I/O::.

 -- Macro: int EALREADY
     An operation is already in progress on an object that has
     non-blocking mode selected.

 -- Macro: int ENOTSOCK
     A file that isn't a socket was specified when a socket is required.

 -- Macro: int EMSGSIZE
     The size of a message sent on a socket was larger than the
     supported maximum size.

 -- Macro: int EPROTOTYPE
     The socket type does not support the requested communications
     protocol.

 -- Macro: int ENOPROTOOPT
     You specified a socket option that doesn't make sense for the
     particular protocol being used by the socket.  *Note Socket
     Options::.

 -- Macro: int EPROTONOSUPPORT
     The socket domain does not support the requested communications
     protocol (perhaps because the requested protocol is completely
     invalid).  *Note Creating a Socket::.

 -- Macro: int ESOCKTNOSUPPORT
     The socket type is not supported.

 -- Macro: int EOPNOTSUPP
     The operation you requested is not supported.  Some socket
     functions don't make sense for all types of sockets, and others
     may not be implemented for all communications protocols.  In the
     GNU system, this error can happen for many calls when the object
     does not support the particular operation; it is a generic
     indication that the server knows nothing to do for that call.

 -- Macro: int EPFNOSUPPORT
     The socket communications protocol family you requested is not
     supported.

 -- Macro: int EAFNOSUPPORT
     The address family specified for a socket is not supported; it is
     inconsistent with the protocol being used on the socket.  *Note
     Sockets::.

 -- Macro: int EADDRINUSE
     The requested socket address is already in use.  *Note Socket
     Addresses::.

 -- Macro: int EADDRNOTAVAIL
     The requested socket address is not available; for example, you
     tried to give a socket a name that doesn't match the local host
     name.  *Note Socket Addresses::.

 -- Macro: int ENETDOWN
     A socket operation failed because the network was down.

 -- Macro: int ENETUNREACH
     A socket operation failed because the subnet containing the remote
     host was unreachable.

 -- Macro: int ENETRESET
     A network connection was reset because the remote host crashed.

 -- Macro: int ECONNABORTED
     A network connection was aborted locally.

 -- Macro: int ECONNRESET
     A network connection was closed for reasons outside the control of
     the local host, such as by the remote machine rebooting or an
     unrecoverable protocol violation.

 -- Macro: int ENOBUFS
     The kernel's buffers for I/O operations are all in use.  In GNU,
     this error is always synonymous with `ENOMEM'; you may get one or
     the other from network operations.

 -- Macro: int EISCONN
     You tried to connect a socket that is already connected.  *Note
     Connecting::.

 -- Macro: int ENOTCONN
     The socket is not connected to anything.  You get this error when
     you try to transmit data over a socket, without first specifying a
     destination for the data.  For a connectionless socket (for
     datagram protocols, such as UDP), you get `EDESTADDRREQ' instead.

 -- Macro: int EDESTADDRREQ
     No default destination address was set for the socket.  You get
     this error when you try to transmit data over a connectionless
     socket, without first specifying a destination for the data with
     `connect'.

 -- Macro: int ESHUTDOWN
     The socket has already been shut down.

 -- Macro: int ETOOMANYREFS
     ???

 -- Macro: int ETIMEDOUT
     A socket operation with a specified timeout received no response
     during the timeout period.

 -- Macro: int ECONNREFUSED
     A remote host refused to allow the network connection (typically
     because it is not running the requested service).

 -- Macro: int ELOOP
     Too many levels of symbolic links were encountered in looking up a
     file name.  This often indicates a cycle of symbolic links.

 -- Macro: int ENAMETOOLONG
     Filename too long (longer than `PATH_MAX'; *note Limits for
     Files::) or host name too long (in `gethostname' or `sethostname';
     *note Host Identification::).

 -- Macro: int EHOSTDOWN
     The remote host for a requested network connection is down.

 -- Macro: int EHOSTUNREACH
     The remote host for a requested network connection is not
     reachable.

 -- Macro: int ENOTEMPTY
     Directory not empty, where an empty directory was expected.
     Typically, this error occurs when you are trying to delete a
     directory.

 -- Macro: int EPROCLIM
     This means that the per-user limit on new process would be
     exceeded by an attempted `fork'.  *Note Limits on Resources::, for
     details on the `RLIMIT_NPROC' limit.

 -- Macro: int EUSERS
     The file quota system is confused because there are too many users.

 -- Macro: int EDQUOT
     The user's disk quota was exceeded.

 -- Macro: int ESTALE
     Stale NFS file handle.  This indicates an internal confusion in
     the NFS system which is due to file system rearrangements on the
     server host.  Repairing this condition usually requires unmounting
     and remounting the NFS file system on the local host.

 -- Macro: int EREMOTE
     An attempt was made to NFS-mount a remote file system with a file
     name that already specifies an NFS-mounted file.  (This is an
     error on some operating systems, but we expect it to work properly
     on the GNU system, making this error code impossible.)

 -- Macro: int EBADRPC
     ???

 -- Macro: int ERPCMISMATCH
     ???

 -- Macro: int EPROGUNAVAIL
     ???

 -- Macro: int EPROGMISMATCH
     ???

 -- Macro: int EPROCUNAVAIL
     ???

 -- Macro: int ENOLCK
     No locks available.  This is used by the file locking facilities;
     see *Note File Locks::.  This error is never generated by the GNU
     system, but it can result from an operation to an NFS server
     running another operating system.

 -- Macro: int EFTYPE
     Inappropriate file type or format.  The file was the wrong type
     for the operation, or a data file had the wrong format.

     On some systems `chmod' returns this error if you try to set the
     sticky bit on a non-directory file; *note Setting Permissions::.

 -- Macro: int EAUTH
     ???

 -- Macro: int ENEEDAUTH
     ???

 -- Macro: int ENOSYS
     Function not implemented.  This indicates that the function called
     is not implemented at all, either in the C library itself or in the
     operating system.  When you get this error, you can be sure that
     this particular function will always fail with `ENOSYS' unless you
     install a new version of the C library or the operating system.

 -- Macro: int ENOTSUP
     Not supported.  A function returns this error when certain
     parameter values are valid, but the functionality they request is
     not available.  This can mean that the function does not implement
     a particular command or option value or flag bit at all.  For
     functions that operate on some object given in a parameter, such
     as a file descriptor or a port, it might instead mean that only
     _that specific object_ (file descriptor, port, etc.) is unable to
     support the other parameters given; different file descriptors
     might support different ranges of parameter values.

     If the entire function is not available at all in the
     implementation, it returns `ENOSYS' instead.

 -- Macro: int EILSEQ
     While decoding a multibyte character the function came along an
     invalid or an incomplete sequence of bytes or the given wide
     character is invalid.

 -- Macro: int EBACKGROUND
     In the GNU system, servers supporting the `term' protocol return
     this error for certain operations when the caller is not in the
     foreground process group of the terminal.  Users do not usually
     see this error because functions such as `read' and `write'
     translate it into a `SIGTTIN' or `SIGTTOU' signal.  *Note Job
     Control::, for information on process groups and these signals.

 -- Macro: int EDIED
     In the GNU system, opening a file returns this error when the file
     is translated by a program and the translator program dies while
     starting up, before it has connected to the file.

 -- Macro: int ED
     The experienced user will know what is wrong.

 -- Macro: int EGREGIOUS
     You did *what*?

 -- Macro: int EIEIO
     Go home and have a glass of warm, dairy-fresh milk.

 -- Macro: int EGRATUITOUS
     This error code has no purpose.

 -- Macro: int EBADMSG

 -- Macro: int EIDRM

 -- Macro: int EMULTIHOP

 -- Macro: int ENODATA

 -- Macro: int ENOLINK

 -- Macro: int ENOMSG

 -- Macro: int ENOSR

 -- Macro: int ENOSTR

 -- Macro: int EOVERFLOW

 -- Macro: int EPROTO

 -- Macro: int ETIME

 -- Macro: int ECANCELED
     Operation canceled; an asynchronous operation was canceled before
     it completed.  *Note Asynchronous I/O::.  When you call
     `aio_cancel', the normal result is for the operations affected to
     complete with this error; *note Cancel AIO Operations::.

   _The following error codes are defined by the Linux/i386 kernel.
They are not yet documented._

 -- Macro: int ERESTART

 -- Macro: int ECHRNG

 -- Macro: int EL2NSYNC

 -- Macro: int EL3HLT

 -- Macro: int EL3RST

 -- Macro: int ELNRNG

 -- Macro: int EUNATCH

 -- Macro: int ENOCSI

 -- Macro: int EL2HLT

 -- Macro: int EBADE

 -- Macro: int EBADR

 -- Macro: int EXFULL

 -- Macro: int ENOANO

 -- Macro: int EBADRQC

 -- Macro: int EBADSLT

 -- Macro: int EDEADLOCK

 -- Macro: int EBFONT

 -- Macro: int ENONET

 -- Macro: int ENOPKG

 -- Macro: int EADV

 -- Macro: int ESRMNT

 -- Macro: int ECOMM

 -- Macro: int EDOTDOT

 -- Macro: int ENOTUNIQ

 -- Macro: int EBADFD

 -- Macro: int EREMCHG

 -- Macro: int ELIBACC

 -- Macro: int ELIBBAD

 -- Macro: int ELIBSCN

 -- Macro: int ELIBMAX

 -- Macro: int ELIBEXEC

 -- Macro: int ESTRPIPE

 -- Macro: int EUCLEAN

 -- Macro: int ENOTNAM

 -- Macro: int ENAVAIL

 -- Macro: int EISNAM

 -- Macro: int EREMOTEIO

 -- Macro: int ENOMEDIUM

 -- Macro: int EMEDIUMTYPE

 -- Macro: int ENOKEY

 -- Macro: int EKEYEXPIRED

 -- Macro: int EKEYREVOKED

 -- Macro: int EKEYREJECTED

 -- Macro: int EOWNERDEAD

 -- Macro: int ENOTRECOVERABLE

 -- Macro: int ERFKILL


File: libc.info,  Node: Error Messages,  Prev: Error Codes,  Up: Error Reporting

2.3 Error Messages
==================

The library has functions and variables designed to make it easy for
your program to report informative error messages in the customary
format about the failure of a library call.  The functions `strerror'
and `perror' give you the standard error message for a given error
code; the variable `program_invocation_short_name' gives you convenient
access to the name of the program that encountered the error.

 -- Function: char * strerror (int ERRNUM)
     The `strerror' function maps the error code (*note Checking for
     Errors::) specified by the ERRNUM argument to a descriptive error
     message string.  The return value is a pointer to this string.

     The value ERRNUM normally comes from the variable `errno'.

     You should not modify the string returned by `strerror'.  Also, if
     you make subsequent calls to `strerror', the string might be
     overwritten.  (But it's guaranteed that no library function ever
     calls `strerror' behind your back.)

     The function `strerror' is declared in `string.h'.

 -- Function: char * strerror_r (int ERRNUM, char *BUF, size_t N)
     The `strerror_r' function works like `strerror' but instead of
     returning the error message in a statically allocated buffer
     shared by all threads in the process, it returns a private copy
     for the thread. This might be either some permanent global data or
     a message string in the user supplied buffer starting at BUF with
     the length of N bytes.

     At most N characters are written (including the NUL byte) so it is
     up to the user to select the buffer large enough.

     This function should always be used in multi-threaded programs
     since there is no way to guarantee the string returned by
     `strerror' really belongs to the last call of the current thread.

     This function `strerror_r' is a GNU extension and it is declared in
     `string.h'.

 -- Function: void perror (const char *MESSAGE)
     This function prints an error message to the stream `stderr'; see
     *Note Standard Streams::.  The orientation of `stderr' is not
     changed.

     If you call `perror' with a MESSAGE that is either a null pointer
     or an empty string, `perror' just prints the error message
     corresponding to `errno', adding a trailing newline.

     If you supply a non-null MESSAGE argument, then `perror' prefixes
     its output with this string.  It adds a colon and a space
     character to separate the MESSAGE from the error string
     corresponding to `errno'.

     The function `perror' is declared in `stdio.h'.

   `strerror' and `perror' produce the exact same message for any given
error code; the precise text varies from system to system.  On the GNU
system, the messages are fairly short; there are no multi-line messages
or embedded newlines.  Each error message begins with a capital letter
and does not include any terminating punctuation.

   *Compatibility Note:* The `strerror' function was introduced in
ISO C89.  Many older C systems do not support this function yet.

   Many programs that don't read input from the terminal are designed to
exit if any system call fails.  By convention, the error message from
such a program should start with the program's name, sans directories.
You can find that name in the variable `program_invocation_short_name';
the full file name is stored the variable `program_invocation_name'.

 -- Variable: char * program_invocation_name
     This variable's value is the name that was used to invoke the
     program running in the current process.  It is the same as
     `argv[0]'.  Note that this is not necessarily a useful file name;
     often it contains no directory names.  *Note Program Arguments::.

 -- Variable: char * program_invocation_short_name
     This variable's value is the name that was used to invoke the
     program running in the current process, with directory names
     removed.  (That is to say, it is the same as
     `program_invocation_name' minus everything up to the last slash,
     if any.)

   The library initialization code sets up both of these variables
before calling `main'.

   *Portability Note:* These two variables are GNU extensions.  If you
want your program to work with non-GNU libraries, you must save the
value of `argv[0]' in `main', and then strip off the directory names
yourself.  We added these extensions to make it possible to write
self-contained error-reporting subroutines that require no explicit
cooperation from `main'.

   Here is an example showing how to handle failure to open a file
correctly.  The function `open_sesame' tries to open the named file for
reading and returns a stream if successful.  The `fopen' library
function returns a null pointer if it couldn't open the file for some
reason.  In that situation, `open_sesame' constructs an appropriate
error message using the `strerror' function, and terminates the
program.  If we were going to make some other library calls before
passing the error code to `strerror', we'd have to save it in a local
variable instead, because those other library functions might overwrite
`errno' in the meantime.

     #include <errno.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>

     FILE *
     open_sesame (char *name)
     {
       FILE *stream;

       errno = 0;
       stream = fopen (name, "r");
       if (stream == NULL)
         {
           fprintf (stderr, "%s: Couldn't open file %s; %s\n",
                    program_invocation_short_name, name, strerror (errno));
           exit (EXIT_FAILURE);
         }
       else
         return stream;
     }

   Using `perror' has the advantage that the function is portable and
available on all systems implementing ISO C.  But often the text
`perror' generates is not what is wanted and there is no way to extend
or change what `perror' does.  The GNU coding standard, for instance,
requires error messages to be preceded by the program name and programs
which read some input files should provide information about the input
file name and the line number in case an error is encountered while
reading the file.  For these occasions there are two functions
available which are widely used throughout the GNU project.  These
functions are declared in `error.h'.

 -- Function: void error (int STATUS, int ERRNUM, const char *FORMAT,
          ...)
     The `error' function can be used to report general problems during
     program execution.  The FORMAT argument is a format string just
     like those given to the `printf' family of functions.  The
     arguments required for the format can follow the FORMAT parameter.
     Just like `perror', `error' also can report an error code in
     textual form.  But unlike `perror' the error value is explicitly
     passed to the function in the ERRNUM parameter.  This eliminates
     the problem mentioned above that the error reporting function must
     be called immediately after the function causing the error since
     otherwise `errno' might have a different value.

     The `error' prints first the program name.  If the application
     defined a global variable `error_print_progname' and points it to a
     function this function will be called to print the program name.
     Otherwise the string from the global variable `program_name' is
     used.  The program name is followed by a colon and a space which
     in turn is followed by the output produced by the format string.
     If the ERRNUM parameter is non-zero the format string output is
     followed by a colon and a space, followed by the error message for
     the error code ERRNUM.  In any case is the output terminated with
     a newline.

     The output is directed to the `stderr' stream.  If the `stderr'
     wasn't oriented before the call it will be narrow-oriented
     afterwards.

     The function will return unless the STATUS parameter has a
     non-zero value.  In this case the function will call `exit' with
     the STATUS value for its parameter and therefore never return.  If
     `error' returns the global variable `error_message_count' is
     incremented by one to keep track of the number of errors reported.

 -- Function: void error_at_line (int STATUS, int ERRNUM, const char
          *FNAME, unsigned int LINENO, const char *FORMAT, ...)
     The `error_at_line' function is very similar to the `error'
     function.  The only difference are the additional parameters FNAME
     and LINENO.  The handling of the other parameters is identical to
     that of `error' except that between the program name and the string
     generated by the format string additional text is inserted.

     Directly following the program name a colon, followed by the file
     name pointer to by FNAME, another colon, and a value of LINENO is
     printed.

     This additional output of course is meant to be used to locate an
     error in an input file (like a programming language source code
     file etc).

     If the global variable `error_one_per_line' is set to a non-zero
     value `error_at_line' will avoid printing consecutive messages for
     the same file and line.  Repetition which are not directly
     following each other are not caught.

     Just like `error' this function only returned if STATUS is zero.
     Otherwise `exit' is called with the non-zero value.  If `error'
     returns the global variable `error_message_count' is incremented
     by one to keep track of the number of errors reported.

   As mentioned above the `error' and `error_at_line' functions can be
customized by defining a variable named `error_print_progname'.

 -- Variable: void (*) error_print_progname  (void)
     If the `error_print_progname' variable is defined to a non-zero
     value the function pointed to is called by `error' or
     `error_at_line'.  It is expected to print the program name or do
     something similarly useful.

     The function is expected to be print to the `stderr' stream and
     must be able to handle whatever orientation the stream has.

     The variable is global and shared by all threads.

 -- Variable: unsigned int error_message_count
     The `error_message_count' variable is incremented whenever one of
     the functions `error' or `error_at_line' returns.  The variable is
     global and shared by all threads.

 -- Variable: int error_one_per_line
     The `error_one_per_line' variable influences only `error_at_line'.
     Normally the `error_at_line' function creates output for every
     invocation.  If `error_one_per_line' is set to a non-zero value
     `error_at_line' keeps track of the last file name and line number
     for which an error was reported and avoid directly following
     messages for the same file and line.  This variable is global and
     shared by all threads.

A program which read some input file and reports errors in it could look
like this:

     {
       char *line = NULL;
       size_t len = 0;
       unsigned int lineno = 0;

       error_message_count = 0;
       while (! feof_unlocked (fp))
         {
           ssize_t n = getline (&line, &len, fp);
           if (n <= 0)
             /* End of file or error.  */
             break;
           ++lineno;

           /* Process the line.  */
           ...

           if (Detect error in line)
             error_at_line (0, errval, filename, lineno,
                            "some error text %s", some_variable);
         }

       if (error_message_count != 0)
         error (EXIT_FAILURE, 0, "%u errors found", error_message_count);
     }

   `error' and `error_at_line' are clearly the functions of choice and
enable the programmer to write applications which follow the GNU coding
standard.  The GNU libc additionally contains functions which are used
in BSD for the same purpose.  These functions are declared in `err.h'.
It is generally advised to not use these functions.  They are included
only for compatibility.

 -- Function: void warn (const char *FORMAT, ...)
     The `warn' function is roughly equivalent to a call like
            error (0, errno, format, the parameters)
     except that the global variables `error' respects and modifies are
     not used.

 -- Function: void vwarn (const char *FORMAT, va_list)
     The `vwarn' function is just like `warn' except that the
     parameters for the handling of the format string FORMAT are passed
     in as an value of type `va_list'.

 -- Function: void warnx (const char *FORMAT, ...)
     The `warnx' function is roughly equivalent to a call like
            error (0, 0, format, the parameters)
     except that the global variables `error' respects and modifies are
     not used.  The difference to `warn' is that no error number string
     is printed.

 -- Function: void vwarnx (const char *FORMAT, va_list)
     The `vwarnx' function is just like `warnx' except that the
     parameters for the handling of the format string FORMAT are passed
     in as an value of type `va_list'.

 -- Function: void err (int STATUS, const char *FORMAT, ...)
     The `err' function is roughly equivalent to a call like
            error (status, errno, format, the parameters)
     except that the global variables `error' respects and modifies are
     not used and that the program is exited even if STATUS is zero.

 -- Function: void verr (int STATUS, const char *FORMAT, va_list)
     The `verr' function is just like `err' except that the parameters
     for the handling of the format string FORMAT are passed in as an
     value of type `va_list'.

 -- Function: void errx (int STATUS, const char *FORMAT, ...)
     The `errx' function is roughly equivalent to a call like
            error (status, 0, format, the parameters)
     except that the global variables `error' respects and modifies are
     not used and that the program is exited even if STATUS is zero.
     The difference to `err' is that no error number string is printed.

 -- Function: void verrx (int STATUS, const char *FORMAT, va_list)
     The `verrx' function is just like `errx' except that the
     parameters for the handling of the format string FORMAT are passed
     in as an value of type `va_list'.


File: libc.info,  Node: Memory,  Next: Character Handling,  Prev: Error Reporting,  Up: Top

3 Virtual Memory Allocation And Paging
**************************************

This chapter describes how processes manage and use memory in a system
that uses the GNU C library.

   The GNU C Library has several functions for dynamically allocating
virtual memory in various ways.  They vary in generality and in
efficiency.  The library also provides functions for controlling paging
and allocation of real memory.

* Menu:

* Memory Concepts::             An introduction to concepts and terminology.
* Memory Allocation::           Allocating storage for your program data
* Locking Pages::               Preventing page faults
* Resizing the Data Segment::   `brk', `sbrk'

   Memory mapped I/O is not discussed in this chapter.  *Note
Memory-mapped I/O::.


File: libc.info,  Node: Memory Concepts,  Next: Memory Allocation,  Up: Memory

3.1 Process Memory Concepts
===========================

One of the most basic resources a process has available to it is memory.
There are a lot of different ways systems organize memory, but in a
typical one, each process has one linear virtual address space, with
addresses running from zero to some huge maximum.  It need not be
contiguous; i.e., not all of these addresses actually can be used to
store data.

   The virtual memory is divided into pages (4 kilobytes is typical).
Backing each page of virtual memory is a page of real memory (called a
"frame") or some secondary storage, usually disk space.  The disk space
might be swap space or just some ordinary disk file.  Actually, a page
of all zeroes sometimes has nothing at all backing it - there's just a
flag saying it is all zeroes.  

   The same frame of real memory or backing store can back multiple
virtual pages belonging to multiple processes.  This is normally the
case, for example, with virtual memory occupied by GNU C library code.
The same real memory frame containing the `printf' function backs a
virtual memory page in each of the existing processes that has a
`printf' call in its program.

   In order for a program to access any part of a virtual page, the page
must at that moment be backed by ("connected to") a real frame.  But
because there is usually a lot more virtual memory than real memory, the
pages must move back and forth between real memory and backing store
regularly, coming into real memory when a process needs to access them
and then retreating to backing store when not needed anymore.  This
movement is called "paging".

   When a program attempts to access a page which is not at that moment
backed by real memory, this is known as a "page fault".  When a page
fault occurs, the kernel suspends the process, places the page into a
real page frame (this is called "paging in" or "faulting in"), then
resumes the process so that from the process' point of view, the page
was in real memory all along.  In fact, to the process, all pages always
seem to be in real memory.  Except for one thing: the elapsed execution
time of an instruction that would normally be a few nanoseconds is
suddenly much, much, longer (because the kernel normally has to do I/O
to complete the page-in).  For programs sensitive to that, the functions
described in *Note Locking Pages:: can control it.  

   Within each virtual address space, a process has to keep track of
what is at which addresses, and that process is called memory
allocation.  Allocation usually brings to mind meting out scarce
resources, but in the case of virtual memory, that's not a major goal,
because there is generally much more of it than anyone needs.  Memory
allocation within a process is mainly just a matter of making sure that
the same byte of memory isn't used to store two different things.

   Processes allocate memory in two major ways: by exec and
programmatically.  Actually, forking is a third way, but it's not very
interesting.  *Note Creating a Process::.

   Exec is the operation of creating a virtual address space for a
process, loading its basic program into it, and executing the program.
It is done by the "exec" family of functions (e.g. `execl').  The
operation takes a program file (an executable), it allocates space to
load all the data in the executable, loads it, and transfers control to
it.  That data is most notably the instructions of the program (the
"text"), but also literals and constants in the program and even some
variables: C variables with the static storage class (*note Memory
Allocation and C::).  

   Once that program begins to execute, it uses programmatic allocation
to gain additional memory.  In a C program with the GNU C library, there
are two kinds of programmatic allocation: automatic and dynamic.  *Note
Memory Allocation and C::.

   Memory-mapped I/O is another form of dynamic virtual memory
allocation.  Mapping memory to a file means declaring that the contents
of certain range of a process' addresses shall be identical to the
contents of a specified regular file.  The system makes the virtual
memory initially contain the contents of the file, and if you modify
the memory, the system writes the same modification to the file.  Note
that due to the magic of virtual memory and page faults, there is no
reason for the system to do I/O to read the file, or allocate real
memory for its contents, until the program accesses the virtual memory.
*Note Memory-mapped I/O::.  

   Just as it programmatically allocates memory, the program can
programmatically deallocate ("free") it.  You can't free the memory
that was allocated by exec.  When the program exits or execs, you might
say that all its memory gets freed, but since in both cases the address
space ceases to exist, the point is really moot.  *Note Program
Termination::.  

   A process' virtual address space is divided into segments.  A
segment is a contiguous range of virtual addresses.  Three important
segments are:

   *  The "text segment" contains a program's instructions and literals
     and static constants.  It is allocated by exec and stays the same
     size for the life of the virtual address space.

   * The "data segment" is working storage for the program.  It can be
     preallocated and preloaded by exec and the process can extend or
     shrink it by calling functions as described in *Note Resizing the
     Data Segment::.  Its lower end is fixed.

   * The "stack segment" contains a program stack.  It grows as the
     stack grows, but doesn't shrink when the stack shrinks.



File: libc.info,  Node: Memory Allocation,  Next: Locking Pages,  Prev: Memory Concepts,  Up: Memory

3.2 Allocating Storage For Program Data
=======================================

This section covers how ordinary programs manage storage for their data,
including the famous `malloc' function and some fancier facilities
special the GNU C library and GNU Compiler.

* Menu:

* Memory Allocation and C::     How to get different kinds of allocation in C.
* Unconstrained Allocation::    The `malloc' facility allows fully general
		 		 dynamic allocation.
* Allocation Debugging::        Finding memory leaks and not freed memory.
* Obstacks::                    Obstacks are less general than malloc
				 but more efficient and convenient.
* Variable Size Automatic::     Allocation of variable-sized blocks
				 of automatic storage that are freed when the
				 calling function returns.


File: libc.info,  Node: Memory Allocation and C,  Next: Unconstrained Allocation,  Up: Memory Allocation

3.2.1 Memory Allocation in C Programs
-------------------------------------

The C language supports two kinds of memory allocation through the
variables in C programs:

   * "Static allocation" is what happens when you declare a static or
     global variable.  Each static or global variable defines one block
     of space, of a fixed size.  The space is allocated once, when your
     program is started (part of the exec operation), and is never
     freed.  

   * "Automatic allocation" happens when you declare an automatic
     variable, such as a function argument or a local variable.  The
     space for an automatic variable is allocated when the compound
     statement containing the declaration is entered, and is freed when
     that compound statement is exited.  

     In GNU C, the size of the automatic storage can be an expression
     that varies.  In other C implementations, it must be a constant.

   A third important kind of memory allocation, "dynamic allocation",
is not supported by C variables but is available via GNU C library
functions.  

3.2.1.1 Dynamic Memory Allocation
.................................

"Dynamic memory allocation" is a technique in which programs determine
as they are running where to store some information.  You need dynamic
allocation when the amount of memory you need, or how long you continue
to need it, depends on factors that are not known before the program
runs.

   For example, you may need a block to store a line read from an input
file; since there is no limit to how long a line can be, you must
allocate the memory dynamically and make it dynamically larger as you
read more of the line.

   Or, you may need a block for each record or each definition in the
input data; since you can't know in advance how many there will be, you
must allocate a new block for each record or definition as you read it.

   When you use dynamic allocation, the allocation of a block of memory
is an action that the program requests explicitly.  You call a function
or macro when you want to allocate space, and specify the size with an
argument.  If you want to free the space, you do so by calling another
function or macro.  You can do these things whenever you want, as often
as you want.

   Dynamic allocation is not supported by C variables; there is no
storage class "dynamic", and there can never be a C variable whose
value is stored in dynamically allocated space.  The only way to get
dynamically allocated memory is via a system call (which is generally
via a GNU C library function call), and the only way to refer to
dynamically allocated space is through a pointer.  Because it is less
convenient, and because the actual process of dynamic allocation
requires more computation time, programmers generally use dynamic
allocation only when neither static nor automatic allocation will serve.

   For example, if you want to allocate dynamically some space to hold a
`struct foobar', you cannot declare a variable of type `struct foobar'
whose contents are the dynamically allocated space.  But you can
declare a variable of pointer type `struct foobar *' and assign it the
address of the space.  Then you can use the operators `*' and `->' on
this pointer variable to refer to the contents of the space:

     {
       struct foobar *ptr
          = (struct foobar *) malloc (sizeof (struct foobar));
       ptr->name = x;
       ptr->next = current_foobar;
       current_foobar = ptr;
     }


File: libc.info,  Node: Unconstrained Allocation,  Next: Allocation Debugging,  Prev: Memory Allocation and C,  Up: Memory Allocation

3.2.2 Unconstrained Allocation
------------------------------

The most general dynamic allocation facility is `malloc'.  It allows
you to allocate blocks of memory of any size at any time, make them
bigger or smaller at any time, and free the blocks individually at any
time (or never).

* Menu:

* Basic Allocation::            Simple use of `malloc'.
* Malloc Examples::             Examples of `malloc'.  `xmalloc'.
* Freeing after Malloc::        Use `free' to free a block you
				 got with `malloc'.
* Changing Block Size::         Use `realloc' to make a block
				 bigger or smaller.
* Allocating Cleared Space::    Use `calloc' to allocate a
				 block and clear it.
* Efficiency and Malloc::       Efficiency considerations in use of
				 these functions.
* Aligned Memory Blocks::       Allocating specially aligned memory.
* Malloc Tunable Parameters::   Use `mallopt' to adjust allocation
                                 parameters.
* Heap Consistency Checking::   Automatic checking for errors.
* Hooks for Malloc::            You can use these hooks for debugging
				 programs that use `malloc'.
* Statistics of Malloc::        Getting information about how much
				 memory your program is using.
* Summary of Malloc::           Summary of `malloc' and related functions.


File: libc.info,  Node: Basic Allocation,  Next: Malloc Examples,  Up: Unconstrained Allocation

3.2.2.1 Basic Memory Allocation
...............................

To allocate a block of memory, call `malloc'.  The prototype for this
function is in `stdlib.h'.  

 -- Function: void * malloc (size_t SIZE)
     This function returns a pointer to a newly allocated block SIZE
     bytes long, or a null pointer if the block could not be allocated.

   The contents of the block are undefined; you must initialize it
yourself (or use `calloc' instead; *note Allocating Cleared Space::).
Normally you would cast the value as a pointer to the kind of object
that you want to store in the block.  Here we show an example of doing
so, and of initializing the space with zeros using the library function
`memset' (*note Copying and Concatenation::):

     struct foo *ptr;
     ...
     ptr = (struct foo *) malloc (sizeof (struct foo));
     if (ptr == 0) abort ();
     memset (ptr, 0, sizeof (struct foo));

   You can store the result of `malloc' into any pointer variable
without a cast, because ISO C automatically converts the type `void *'
to another type of pointer when necessary.  But the cast is necessary
in contexts other than assignment operators or if you might want your
code to run in traditional C.

   Remember that when allocating space for a string, the argument to
`malloc' must be one plus the length of the string.  This is because a
string is terminated with a null character that doesn't count in the
"length" of the string but does need space.  For example:

     char *ptr;
     ...
     ptr = (char *) malloc (length + 1);

*Note Representation of Strings::, for more information about this.


File: libc.info,  Node: Malloc Examples,  Next: Freeing after Malloc,  Prev: Basic Allocation,  Up: Unconstrained Allocation

3.2.2.2 Examples of `malloc'
............................

If no more space is available, `malloc' returns a null pointer.  You
should check the value of _every_ call to `malloc'.  It is useful to
write a subroutine that calls `malloc' and reports an error if the
value is a null pointer, returning only if the value is nonzero.  This
function is conventionally called `xmalloc'.  Here it is:

     void *
     xmalloc (size_t size)
     {
       register void *value = malloc (size);
       if (value == 0)
         fatal ("virtual memory exhausted");
       return value;
     }

   Here is a real example of using `malloc' (by way of `xmalloc').  The
function `savestring' will copy a sequence of characters into a newly
allocated null-terminated string:

     char *
     savestring (const char *ptr, size_t len)
     {
       register char *value = (char *) xmalloc (len + 1);
       value[len] = '\0';
       return (char *) memcpy (value, ptr, len);
     }

   The block that `malloc' gives you is guaranteed to be aligned so
that it can hold any type of data.  In the GNU system, the address is
always a multiple of eight on most systems, and a multiple of 16 on
64-bit systems.  Only rarely is any higher boundary (such as a page
boundary) necessary; for those cases, use `memalign', `posix_memalign'
or `valloc' (*note Aligned Memory Blocks::).

   Note that the memory located after the end of the block is likely to
be in use for something else; perhaps a block already allocated by
another call to `malloc'.  If you attempt to treat the block as longer
than you asked for it to be, you are liable to destroy the data that
`malloc' uses to keep track of its blocks, or you may destroy the
contents of another block.  If you have already allocated a block and
discover you want it to be bigger, use `realloc' (*note Changing Block
Size::).


File: libc.info,  Node: Freeing after Malloc,  Next: Changing Block Size,  Prev: Malloc Examples,  Up: Unconstrained Allocation

3.2.2.3 Freeing Memory Allocated with `malloc'
..............................................

When you no longer need a block that you got with `malloc', use the
function `free' to make the block available to be allocated again.  The
prototype for this function is in `stdlib.h'.  

 -- Function: void free (void *PTR)
     The `free' function deallocates the block of memory pointed at by
     PTR.

 -- Function: void cfree (void *PTR)
     This function does the same thing as `free'.  It's provided for
     backward compatibility with SunOS; you should use `free' instead.

   Freeing a block alters the contents of the block.  *Do not expect to
find any data (such as a pointer to the next block in a chain of
blocks) in the block after freeing it.*  Copy whatever you need out of
the block before freeing it!  Here is an example of the proper way to
free all the blocks in a chain, and the strings that they point to:

     struct chain
       {
         struct chain *next;
         char *name;
       }

     void
     free_chain (struct chain *chain)
     {
       while (chain != 0)
         {
           struct chain *next = chain->next;
           free (chain->name);
           free (chain);
           chain = next;
         }
     }

   Occasionally, `free' can actually return memory to the operating
system and make the process smaller.  Usually, all it can do is allow a
later call to `malloc' to reuse the space.  In the meantime, the space
remains in your program as part of a free-list used internally by
`malloc'.

   There is no point in freeing blocks at the end of a program, because
all of the program's space is given back to the system when the process
terminates.


File: libc.info,  Node: Changing Block Size,  Next: Allocating Cleared Space,  Prev: Freeing after Malloc,  Up: Unconstrained Allocation

3.2.2.4 Changing the Size of a Block
....................................

Often you do not know for certain how big a block you will ultimately
need at the time you must begin to use the block.  For example, the
block might be a buffer that you use to hold a line being read from a
file; no matter how long you make the buffer initially, you may
encounter a line that is longer.

   You can make the block longer by calling `realloc'.  This function
is declared in `stdlib.h'.  

 -- Function: void * realloc (void *PTR, size_t NEWSIZE)
     The `realloc' function changes the size of the block whose address
     is PTR to be NEWSIZE.

     Since the space after the end of the block may be in use, `realloc'
     may find it necessary to copy the block to a new address where
     more free space is available.  The value of `realloc' is the new
     address of the block.  If the block needs to be moved, `realloc'
     copies the old contents.

     If you pass a null pointer for PTR, `realloc' behaves just like
     `malloc (NEWSIZE)'.  This can be convenient, but beware that older
     implementations (before ISO C) may not support this behavior, and
     will probably crash when `realloc' is passed a null pointer.

   Like `malloc', `realloc' may return a null pointer if no memory
space is available to make the block bigger.  When this happens, the
original block is untouched; it has not been modified or relocated.

   In most cases it makes no difference what happens to the original
block when `realloc' fails, because the application program cannot
continue when it is out of memory, and the only thing to do is to give
a fatal error message.  Often it is convenient to write and use a
subroutine, conventionally called `xrealloc', that takes care of the
error message as `xmalloc' does for `malloc':

     void *
     xrealloc (void *ptr, size_t size)
     {
       register void *value = realloc (ptr, size);
       if (value == 0)
         fatal ("Virtual memory exhausted");
       return value;
     }

   You can also use `realloc' to make a block smaller.  The reason you
would do this is to avoid tying up a lot of memory space when only a
little is needed.  In several allocation implementations, making a
block smaller sometimes necessitates copying it, so it can fail if no
other space is available.

   If the new size you specify is the same as the old size, `realloc'
is guaranteed to change nothing and return the same address that you
gave.


File: libc.info,  Node: Allocating Cleared Space,  Next: Efficiency and Malloc,  Prev: Changing Block Size,  Up: Unconstrained Allocation

3.2.2.5 Allocating Cleared Space
................................

The function `calloc' allocates memory and clears it to zero.  It is
declared in `stdlib.h'.  

 -- Function: void * calloc (size_t COUNT, size_t ELTSIZE)
     This function allocates a block long enough to contain a vector of
     COUNT elements, each of size ELTSIZE.  Its contents are cleared to
     zero before `calloc' returns.

   You could define `calloc' as follows:

     void *
     calloc (size_t count, size_t eltsize)
     {
       size_t size = count * eltsize;
       void *value = malloc (size);
       if (value != 0)
         memset (value, 0, size);
       return value;
     }

   But in general, it is not guaranteed that `calloc' calls `malloc'
internally.  Therefore, if an application provides its own
`malloc'/`realloc'/`free' outside the C library, it should always
define `calloc', too.


File: libc.info,  Node: Efficiency and Malloc,  Next: Aligned Memory Blocks,  Prev: Allocating Cleared Space,  Up: Unconstrained Allocation

3.2.2.6 Efficiency Considerations for `malloc'
..............................................

As opposed to other versions, the `malloc' in the GNU C Library does
not round up block sizes to powers of two, neither for large nor for
small sizes.  Neighboring chunks can be coalesced on a `free' no matter
what their size is.  This makes the implementation suitable for all
kinds of allocation patterns without generally incurring high memory
waste through fragmentation.

   Very large blocks (much larger than a page) are allocated with
`mmap' (anonymous or via `/dev/zero') by this implementation.  This has
the great advantage that these chunks are returned to the system
immediately when they are freed.  Therefore, it cannot happen that a
large chunk becomes "locked" in between smaller ones and even after
calling `free' wastes memory.  The size threshold for `mmap' to be used
can be adjusted with `mallopt'.  The use of `mmap' can also be disabled
completely.


File: libc.info,  Node: Aligned Memory Blocks,  Next: Malloc Tunable Parameters,  Prev: Efficiency and Malloc,  Up: Unconstrained Allocation

3.2.2.7 Allocating Aligned Memory Blocks
........................................

The address of a block returned by `malloc' or `realloc' in the GNU
system is always a multiple of eight (or sixteen on 64-bit systems).
If you need a block whose address is a multiple of a higher power of
two than that, use `memalign', `posix_memalign', or `valloc'.
`memalign' is declared in `malloc.h' and `posix_memalign' is declared
in `stdlib.h'.

   With the GNU library, you can use `free' to free the blocks that
`memalign', `posix_memalign', and `valloc' return.  That does not work
in BSD, however--BSD does not provide any way to free such blocks.

 -- Function: void * memalign (size_t BOUNDARY, size_t SIZE)
     The `memalign' function allocates a block of SIZE bytes whose
     address is a multiple of BOUNDARY.  The BOUNDARY must be a power
     of two!  The function `memalign' works by allocating a somewhat
     larger block, and then returning an address within the block that
     is on the specified boundary.

 -- Function: int posix_memalign (void **MEMPTR, size_t ALIGNMENT,
          size_t SIZE)
     The `posix_memalign' function is similar to the `memalign'
     function in that it returns a buffer of SIZE bytes aligned to a
     multiple of ALIGNMENT.  But it adds one requirement to the
     parameter ALIGNMENT: the value must be a power of two multiple of
     `sizeof (void *)'.

     If the function succeeds in allocation memory a pointer to the
     allocated memory is returned in `*MEMPTR' and the return value is
     zero.  Otherwise the function returns an error value indicating
     the problem.

     This function was introduced in POSIX 1003.1d.

 -- Function: void * valloc (size_t SIZE)
     Using `valloc' is like using `memalign' and passing the page size
     as the value of the second argument.  It is implemented like this:

          void *
          valloc (size_t size)
          {
            return memalign (getpagesize (), size);
          }

     *Note Query Memory Parameters:: for more information about the
     memory subsystem.


File: libc.info,  Node: Malloc Tunable Parameters,  Next: Heap Consistency Checking,  Prev: Aligned Memory Blocks,  Up: Unconstrained Allocation

3.2.2.8 Malloc Tunable Parameters
.................................

You can adjust some parameters for dynamic memory allocation with the
`mallopt' function.  This function is the general SVID/XPG interface,
defined in `malloc.h'.  

 -- Function: int mallopt (int PARAM, int VALUE)
     When calling `mallopt', the PARAM argument specifies the parameter
     to be set, and VALUE the new value to be set.  Possible choices
     for PARAM, as defined in `malloc.h', are:

    `M_TRIM_THRESHOLD'
          This is the minimum size (in bytes) of the top-most,
          releasable chunk that will cause `sbrk' to be called with a
          negative argument in order to return memory to the system.

    `M_TOP_PAD'
          This parameter determines the amount of extra memory to
          obtain from the system when a call to `sbrk' is required.  It
          also specifies the number of bytes to retain when shrinking
          the heap by calling `sbrk' with a negative argument.  This
          provides the necessary hysteresis in heap size such that
          excessive amounts of system calls can be avoided.

    `M_MMAP_THRESHOLD'
          All chunks larger than this value are allocated outside the
          normal heap, using the `mmap' system call.  This way it is
          guaranteed that the memory for these chunks can be returned
          to the system on `free'.  Note that requests smaller than
          this threshold might still be allocated via `mmap'.

    `M_MMAP_MAX'
          The maximum number of chunks to allocate with `mmap'.
          Setting this to zero disables all use of `mmap'.

    `M_PERTURB'
          If non-zero, memory blocks are filled with values depending
          on some low order bits of this parameter when they are
          allocated (except when allocated by `calloc') and freed.
          This can be used to debug the use of uninitialized or freed
          heap memory.



File: libc.info,  Node: Heap Consistency Checking,  Next: Hooks for Malloc,  Prev: Malloc Tunable Parameters,  Up: Unconstrained Allocation

3.2.2.9 Heap Consistency Checking
.................................

You can ask `malloc' to check the consistency of dynamic memory by
using the `mcheck' function.  This function is a GNU extension,
declared in `mcheck.h'.  

 -- Function: int mcheck (void (*ABORTFN) (enum mcheck_status STATUS))
     Calling `mcheck' tells `malloc' to perform occasional consistency
     checks.  These will catch things such as writing past the end of a
     block that was allocated with `malloc'.

     The ABORTFN argument is the function to call when an inconsistency
     is found.  If you supply a null pointer, then `mcheck' uses a
     default function which prints a message and calls `abort' (*note
     Aborting a Program::).  The function you supply is called with one
     argument, which says what sort of inconsistency was detected; its
     type is described below.

     It is too late to begin allocation checking once you have allocated
     anything with `malloc'.  So `mcheck' does nothing in that case.
     The function returns `-1' if you call it too late, and `0'
     otherwise (when it is successful).

     The easiest way to arrange to call `mcheck' early enough is to use
     the option `-lmcheck' when you link your program; then you don't
     need to modify your program source at all.  Alternatively you
     might use a debugger to insert a call to `mcheck' whenever the
     program is started, for example these gdb commands will
     automatically call `mcheck' whenever the program starts:

          (gdb) break main
          Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10
          (gdb) command 1
          Type commands for when breakpoint 1 is hit, one per line.
          End with a line saying just "end".
          >call mcheck(0)
          >continue
          >end
          (gdb) ...

     This will however only work if no initialization function of any
     object involved calls any of the `malloc' functions since `mcheck'
     must be called before the first such function.


 -- Function: enum mcheck_status mprobe (void *POINTER)
     The `mprobe' function lets you explicitly check for inconsistencies
     in a particular allocated block.  You must have already called
     `mcheck' at the beginning of the program, to do its occasional
     checks; calling `mprobe' requests an additional consistency check
     to be done at the time of the call.

     The argument POINTER must be a pointer returned by `malloc' or
     `realloc'.  `mprobe' returns a value that says what inconsistency,
     if any, was found.  The values are described below.

 -- Data Type: enum mcheck_status
     This enumerated type describes what kind of inconsistency was
     detected in an allocated block, if any.  Here are the possible
     values:

    `MCHECK_DISABLED'
          `mcheck' was not called before the first allocation.  No
          consistency checking can be done.

    `MCHECK_OK'
          No inconsistency detected.

    `MCHECK_HEAD'
          The data immediately before the block was modified.  This
          commonly happens when an array index or pointer is
          decremented too far.

    `MCHECK_TAIL'
          The data immediately after the block was modified.  This
          commonly happens when an array index or pointer is
          incremented too far.

    `MCHECK_FREE'
          The block was already freed.

   Another possibility to check for and guard against bugs in the use of
`malloc', `realloc' and `free' is to set the environment variable
`MALLOC_CHECK_'.  When `MALLOC_CHECK_' is set, a special (less
efficient) implementation is used which is designed to be tolerant
against simple errors, such as double calls of `free' with the same
argument, or overruns of a single byte (off-by-one bugs).  Not all such
errors can be protected against, however, and memory leaks can result.
If `MALLOC_CHECK_' is set to `0', any detected heap corruption is
silently ignored; if set to `1', a diagnostic is printed on `stderr';
if set to `2', `abort' is called immediately.  This can be useful
because otherwise a crash may happen much later, and the true cause for
the problem is then very hard to track down.

   There is one problem with `MALLOC_CHECK_': in SUID or SGID binaries
it could possibly be exploited since diverging from the normal programs
behavior it now writes something to the standard error descriptor.
Therefore the use of `MALLOC_CHECK_' is disabled by default for SUID
and SGID binaries.  It can be enabled again by the system administrator
by adding a file `/etc/suid-debug' (the content is not important it
could be empty).

   So, what's the difference between using `MALLOC_CHECK_' and linking
with `-lmcheck'?  `MALLOC_CHECK_' is orthogonal with respect to
`-lmcheck'.  `-lmcheck' has been added for backward compatibility.
Both `MALLOC_CHECK_' and `-lmcheck' should uncover the same bugs - but
using `MALLOC_CHECK_' you don't need to recompile your application.


File: libc.info,  Node: Hooks for Malloc,  Next: Statistics of Malloc,  Prev: Heap Consistency Checking,  Up: Unconstrained Allocation

3.2.2.10 Memory Allocation Hooks
................................

The GNU C library lets you modify the behavior of `malloc', `realloc',
and `free' by specifying appropriate hook functions.  You can use these
hooks to help you debug programs that use dynamic memory allocation,
for example.

   The hook variables are declared in `malloc.h'.  

 -- Variable: __malloc_hook
     The value of this variable is a pointer to the function that
     `malloc' uses whenever it is called.  You should define this
     function to look like `malloc'; that is, like:

          void *FUNCTION (size_t SIZE, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the `malloc' function was called.  This value allows you to trace
     the memory consumption of the program.

 -- Variable: __realloc_hook
     The value of this variable is a pointer to function that `realloc'
     uses whenever it is called.  You should define this function to
     look like `realloc'; that is, like:

          void *FUNCTION (void *PTR, size_t SIZE, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the `realloc' function was called.  This value allows you to trace
     the memory consumption of the program.

 -- Variable: __free_hook
     The value of this variable is a pointer to function that `free'
     uses whenever it is called.  You should define this function to
     look like `free'; that is, like:

          void FUNCTION (void *PTR, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the `free' function was called.  This value allows you to trace the
     memory consumption of the program.

 -- Variable: __memalign_hook
     The value of this variable is a pointer to function that `memalign'
     uses whenever it is called.  You should define this function to
     look like `memalign'; that is, like:

          void *FUNCTION (size_t ALIGNMENT, size_t SIZE, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the `memalign' function was called.  This value allows you to
     trace the memory consumption of the program.

   You must make sure that the function you install as a hook for one of
these functions does not call that function recursively without
restoring the old value of the hook first!  Otherwise, your program
will get stuck in an infinite recursion.  Before calling the function
recursively, one should make sure to restore all the hooks to their
previous value.  When coming back from the recursive call, all the
hooks should be resaved since a hook might modify itself.

 -- Variable: __malloc_initialize_hook
     The value of this variable is a pointer to a function that is
     called once when the malloc implementation is initialized.  This
     is a weak variable, so it can be overridden in the application
     with a definition like the following:

          void (*__MALLOC_INITIALIZE_HOOK) (void) = my_init_hook;

   An issue to look out for is the time at which the malloc hook
functions can be safely installed.  If the hook functions call the
malloc-related functions recursively, it is necessary that malloc has
already properly initialized itself at the time when `__malloc_hook'
etc. is assigned to.  On the other hand, if the hook functions provide a
complete malloc implementation of their own, it is vital that the hooks
are assigned to _before_ the very first `malloc' call has completed,
because otherwise a chunk obtained from the ordinary, un-hooked malloc
may later be handed to `__free_hook', for example.

   In both cases, the problem can be solved by setting up the hooks from
within a user-defined function pointed to by
`__malloc_initialize_hook'--then the hooks will be set up safely at the
right time.

   Here is an example showing how to use `__malloc_hook' and
`__free_hook' properly.  It installs a function that prints out
information every time `malloc' or `free' is called.  We just assume
here that `realloc' and `memalign' are not used in our program.

     /* Prototypes for __malloc_hook, __free_hook */
     #include <malloc.h>

     /* Prototypes for our hooks.  */
     static void my_init_hook (void);
     static void *my_malloc_hook (size_t, const void *);
     static void my_free_hook (void*, const void *);

     /* Override initializing hook from the C library. */
     void (*__malloc_initialize_hook) (void) = my_init_hook;

     static void
     my_init_hook (void)
     {
       old_malloc_hook = __malloc_hook;
       old_free_hook = __free_hook;
       __malloc_hook = my_malloc_hook;
       __free_hook = my_free_hook;
     }

     static void *
     my_malloc_hook (size_t size, const void *caller)
     {
       void *result;
       /* Restore all old hooks */
       __malloc_hook = old_malloc_hook;
       __free_hook = old_free_hook;
       /* Call recursively */
       result = malloc (size);
       /* Save underlying hooks */
       old_malloc_hook = __malloc_hook;
       old_free_hook = __free_hook;
       /* `printf' might call `malloc', so protect it too. */
       printf ("malloc (%u) returns %p\n", (unsigned int) size, result);
       /* Restore our own hooks */
       __malloc_hook = my_malloc_hook;
       __free_hook = my_free_hook;
       return result;
     }

     static void
     my_free_hook (void *ptr, const void *caller)
     {
       /* Restore all old hooks */
       __malloc_hook = old_malloc_hook;
       __free_hook = old_free_hook;
       /* Call recursively */
       free (ptr);
       /* Save underlying hooks */
       old_malloc_hook = __malloc_hook;
       old_free_hook = __free_hook;
       /* `printf' might call `free', so protect it too. */
       printf ("freed pointer %p\n", ptr);
       /* Restore our own hooks */
       __malloc_hook = my_malloc_hook;
       __free_hook = my_free_hook;
     }

     main ()
     {
       ...
     }

   The `mcheck' function (*note Heap Consistency Checking::) works by
installing such hooks.


File: libc.info,  Node: Statistics of Malloc,  Next: Summary of Malloc,  Prev: Hooks for Malloc,  Up: Unconstrained Allocation

3.2.2.11 Statistics for Memory Allocation with `malloc'
.......................................................

You can get information about dynamic memory allocation by calling the
`mallinfo' function.  This function and its associated data type are
declared in `malloc.h'; they are an extension of the standard SVID/XPG
version.  

 -- Data Type: struct mallinfo
     This structure type is used to return information about the dynamic
     memory allocator.  It contains the following members:

    `int arena'
          This is the total size of memory allocated with `sbrk' by
          `malloc', in bytes.

    `int ordblks'
          This is the number of chunks not in use.  (The memory
          allocator internally gets chunks of memory from the operating
          system, and then carves them up to satisfy individual
          `malloc' requests; see *Note Efficiency and Malloc::.)

    `int smblks'
          This field is unused.

    `int hblks'
          This is the total number of chunks allocated with `mmap'.

    `int hblkhd'
          This is the total size of memory allocated with `mmap', in
          bytes.

    `int usmblks'
          This field is unused.

    `int fsmblks'
          This field is unused.

    `int uordblks'
          This is the total size of memory occupied by chunks handed
          out by `malloc'.

    `int fordblks'
          This is the total size of memory occupied by free (not in
          use) chunks.

    `int keepcost'
          This is the size of the top-most releasable chunk that
          normally borders the end of the heap (i.e., the high end of
          the virtual address space's data segment).


 -- Function: struct mallinfo mallinfo (void)
     This function returns information about the current dynamic memory
     usage in a structure of type `struct mallinfo'.


File: libc.info,  Node: Summary of Malloc,  Prev: Statistics of Malloc,  Up: Unconstrained Allocation

3.2.2.12 Summary of `malloc'-Related Functions
..............................................

Here is a summary of the functions that work with `malloc':

`void *malloc (size_t SIZE)'
     Allocate a block of SIZE bytes.  *Note Basic Allocation::.

`void free (void *ADDR)'
     Free a block previously allocated by `malloc'.  *Note Freeing
     after Malloc::.

`void *realloc (void *ADDR, size_t SIZE)'
     Make a block previously allocated by `malloc' larger or smaller,
     possibly by copying it to a new location.  *Note Changing Block
     Size::.

`void *calloc (size_t COUNT, size_t ELTSIZE)'
     Allocate a block of COUNT * ELTSIZE bytes using `malloc', and set
     its contents to zero.  *Note Allocating Cleared Space::.

`void *valloc (size_t SIZE)'
     Allocate a block of SIZE bytes, starting on a page boundary.
     *Note Aligned Memory Blocks::.

`void *memalign (size_t SIZE, size_t BOUNDARY)'
     Allocate a block of SIZE bytes, starting on an address that is a
     multiple of BOUNDARY.  *Note Aligned Memory Blocks::.

`int mallopt (int PARAM, int VALUE)'
     Adjust a tunable parameter.  *Note Malloc Tunable Parameters::.

`int mcheck (void (*ABORTFN) (void))'
     Tell `malloc' to perform occasional consistency checks on
     dynamically allocated memory, and to call ABORTFN when an
     inconsistency is found.  *Note Heap Consistency Checking::.

`void *(*__malloc_hook) (size_t SIZE, const void *CALLER)'
     A pointer to a function that `malloc' uses whenever it is called.

`void *(*__realloc_hook) (void *PTR, size_t SIZE, const void *CALLER)'
     A pointer to a function that `realloc' uses whenever it is called.

`void (*__free_hook) (void *PTR, const void *CALLER)'
     A pointer to a function that `free' uses whenever it is called.

`void (*__memalign_hook) (size_t SIZE, size_t ALIGNMENT, const void *CALLER)'
     A pointer to a function that `memalign' uses whenever it is called.

`struct mallinfo mallinfo (void)'
     Return information about the current dynamic memory usage.  *Note
     Statistics of Malloc::.


File: libc.info,  Node: Allocation Debugging,  Next: Obstacks,  Prev: Unconstrained Allocation,  Up: Memory Allocation

3.2.3 Allocation Debugging
--------------------------

A complicated task when programming with languages which do not use
garbage collected dynamic memory allocation is to find memory leaks.
Long running programs must assure that dynamically allocated objects are
freed at the end of their lifetime.  If this does not happen the system
runs out of memory, sooner or later.

   The `malloc' implementation in the GNU C library provides some
simple means to detect such leaks and obtain some information to find
the location.  To do this the application must be started in a special
mode which is enabled by an environment variable.  There are no speed
penalties for the program if the debugging mode is not enabled.

* Menu:

* Tracing malloc::               How to install the tracing functionality.
* Using the Memory Debugger::    Example programs excerpts.
* Tips for the Memory Debugger:: Some more or less clever ideas.
* Interpreting the traces::      What do all these lines mean?


File: libc.info,  Node: Tracing malloc,  Next: Using the Memory Debugger,  Up: Allocation Debugging

3.2.3.1 How to install the tracing functionality
................................................

 -- Function: void mtrace (void)
     When the `mtrace' function is called it looks for an environment
     variable named `MALLOC_TRACE'.  This variable is supposed to
     contain a valid file name.  The user must have write access.  If
     the file already exists it is truncated.  If the environment
     variable is not set or it does not name a valid file which can be
     opened for writing nothing is done.  The behavior of `malloc' etc.
     is not changed.  For obvious reasons this also happens if the
     application is installed with the SUID or SGID bit set.

     If the named file is successfully opened, `mtrace' installs special
     handlers for the functions `malloc', `realloc', and `free' (*note
     Hooks for Malloc::).  From then on, all uses of these functions
     are traced and protocolled into the file.  There is now of course
     a speed penalty for all calls to the traced functions so tracing
     should not be enabled during normal use.

     This function is a GNU extension and generally not available on
     other systems.  The prototype can be found in `mcheck.h'.

 -- Function: void muntrace (void)
     The `muntrace' function can be called after `mtrace' was used to
     enable tracing the `malloc' calls.  If no (successful) call of
     `mtrace' was made `muntrace' does nothing.

     Otherwise it deinstalls the handlers for `malloc', `realloc', and
     `free' and then closes the protocol file.  No calls are
     protocolled anymore and the program runs again at full speed.

     This function is a GNU extension and generally not available on
     other systems.  The prototype can be found in `mcheck.h'.


File: libc.info,  Node: Using the Memory Debugger,  Next: Tips for the Memory Debugger,  Prev: Tracing malloc,  Up: Allocation Debugging

3.2.3.2 Example program excerpts
................................

Even though the tracing functionality does not influence the runtime
behavior of the program it is not a good idea to call `mtrace' in all
programs.  Just imagine that you debug a program using `mtrace' and all
other programs used in the debugging session also trace their `malloc'
calls.  The output file would be the same for all programs and thus is
unusable.  Therefore one should call `mtrace' only if compiled for
debugging.  A program could therefore start like this:

     #include <mcheck.h>

     int
     main (int argc, char *argv[])
     {
     #ifdef DEBUGGING
       mtrace ();
     #endif
       ...
     }

   This is all what is needed if you want to trace the calls during the
whole runtime of the program.  Alternatively you can stop the tracing at
any time with a call to `muntrace'.  It is even possible to restart the
tracing again with a new call to `mtrace'.  But this can cause
unreliable results since there may be calls of the functions which are
not called.  Please note that not only the application uses the traced
functions, also libraries (including the C library itself) use these
functions.

   This last point is also why it is no good idea to call `muntrace'
before the program terminated.  The libraries are informed about the
termination of the program only after the program returns from `main'
or calls `exit' and so cannot free the memory they use before this time.

   So the best thing one can do is to call `mtrace' as the very first
function in the program and never call `muntrace'.  So the program
traces almost all uses of the `malloc' functions (except those calls
which are executed by constructors of the program or used libraries).


File: libc.info,  Node: Tips for the Memory Debugger,  Next: Interpreting the traces,  Prev: Using the Memory Debugger,  Up: Allocation Debugging

3.2.3.3 Some more or less clever ideas
......................................

You know the situation.  The program is prepared for debugging and in
all debugging sessions it runs well.  But once it is started without
debugging the error shows up.  A typical example is a memory leak that
becomes visible only when we turn off the debugging.  If you foresee
such situations you can still win.  Simply use something equivalent to
the following little program:

     #include <mcheck.h>
     #include <signal.h>

     static void
     enable (int sig)
     {
       mtrace ();
       signal (SIGUSR1, enable);
     }

     static void
     disable (int sig)
     {
       muntrace ();
       signal (SIGUSR2, disable);
     }

     int
     main (int argc, char *argv[])
     {
       ...

       signal (SIGUSR1, enable);
       signal (SIGUSR2, disable);

       ...
     }

   I.e., the user can start the memory debugger any time s/he wants if
the program was started with `MALLOC_TRACE' set in the environment.
The output will of course not show the allocations which happened before
the first signal but if there is a memory leak this will show up
nevertheless.


File: libc.info,  Node: Interpreting the traces,  Prev: Tips for the Memory Debugger,  Up: Allocation Debugging

3.2.3.4 Interpreting the traces
...............................

If you take a look at the output it will look similar to this:

     = Start
      [0x8048209] - 0x8064cc8
      [0x8048209] - 0x8064ce0
      [0x8048209] - 0x8064cf8
      [0x80481eb] + 0x8064c48 0x14
      [0x80481eb] + 0x8064c60 0x14
      [0x80481eb] + 0x8064c78 0x14
      [0x80481eb] + 0x8064c90 0x14
     = End

   What this all means is not really important since the trace file is
not meant to be read by a human.  Therefore no attention is given to
readability.  Instead there is a program which comes with the GNU C
library which interprets the traces and outputs a summary in an
user-friendly way.  The program is called `mtrace' (it is in fact a
Perl script) and it takes one or two arguments.  In any case the name of
the file with the trace output must be specified.  If an optional
argument precedes the name of the trace file this must be the name of
the program which generated the trace.

     drepper$ mtrace tst-mtrace log
     No memory leaks.

   In this case the program `tst-mtrace' was run and it produced a
trace file `log'.  The message printed by `mtrace' shows there are no
problems with the code, all allocated memory was freed afterwards.

   If we call `mtrace' on the example trace given above we would get a
different outout:

     drepper$ mtrace errlog
     - 0x08064cc8 Free 2 was never alloc'd 0x8048209
     - 0x08064ce0 Free 3 was never alloc'd 0x8048209
     - 0x08064cf8 Free 4 was never alloc'd 0x8048209

     Memory not freed:
     -----------------
        Address     Size     Caller
     0x08064c48     0x14  at 0x80481eb
     0x08064c60     0x14  at 0x80481eb
     0x08064c78     0x14  at 0x80481eb
     0x08064c90     0x14  at 0x80481eb

   We have called `mtrace' with only one argument and so the script has
no chance to find out what is meant with the addresses given in the
trace.  We can do better:

     drepper$ mtrace tst errlog
     - 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39
     - 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39
     - 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39

     Memory not freed:
     -----------------
        Address     Size     Caller
     0x08064c48     0x14  at /home/drepper/tst.c:33
     0x08064c60     0x14  at /home/drepper/tst.c:33
     0x08064c78     0x14  at /home/drepper/tst.c:33
     0x08064c90     0x14  at /home/drepper/tst.c:33

   Suddenly the output makes much more sense and the user can see
immediately where the function calls causing the trouble can be found.

   Interpreting this output is not complicated.  There are at most two
different situations being detected.  First, `free' was called for
pointers which were never returned by one of the allocation functions.
This is usually a very bad problem and what this looks like is shown in
the first three lines of the output.  Situations like this are quite
rare and if they appear they show up very drastically: the program
normally crashes.

   The other situation which is much harder to detect are memory leaks.
As you can see in the output the `mtrace' function collects all this
information and so can say that the program calls an allocation function
from line 33 in the source file `/home/drepper/tst-mtrace.c' four times
without freeing this memory before the program terminates.  Whether
this is a real problem remains to be investigated.


File: libc.info,  Node: Obstacks,  Next: Variable Size Automatic,  Prev: Allocation Debugging,  Up: Memory Allocation

3.2.4 Obstacks
--------------

An "obstack" is a pool of memory containing a stack of objects.  You
can create any number of separate obstacks, and then allocate objects in
specified obstacks.  Within each obstack, the last object allocated must
always be the first one freed, but distinct obstacks are independent of
each other.

   Aside from this one constraint of order of freeing, obstacks are
totally general: an obstack can contain any number of objects of any
size.  They are implemented with macros, so allocation is usually very
fast as long as the objects are usually small.  And the only space
overhead per object is the padding needed to start each object on a
suitable boundary.

* Menu:

* Creating Obstacks::		How to declare an obstack in your program.
* Preparing for Obstacks::	Preparations needed before you can
				 use obstacks.
* Allocation in an Obstack::    Allocating objects in an obstack.
* Freeing Obstack Objects::     Freeing objects in an obstack.
* Obstack Functions::		The obstack functions are both
				 functions and macros.
* Growing Objects::             Making an object bigger by stages.
* Extra Fast Growing::		Extra-high-efficiency (though more
				 complicated) growing objects.
* Status of an Obstack::        Inquiries about the status of an obstack.
* Obstacks Data Alignment::     Controlling alignment of objects in obstacks.
* Obstack Chunks::              How obstacks obtain and release chunks;
				 efficiency considerations.
* Summary of Obstacks::


File: libc.info,  Node: Creating Obstacks,  Next: Preparing for Obstacks,  Up: Obstacks

3.2.4.1 Creating Obstacks
.........................

The utilities for manipulating obstacks are declared in the header file
`obstack.h'.  

 -- Data Type: struct obstack
     An obstack is represented by a data structure of type `struct
     obstack'.  This structure has a small fixed size; it records the
     status of the obstack and how to find the space in which objects
     are allocated.  It does not contain any of the objects themselves.
     You should not try to access the contents of the structure
     directly; use only the functions described in this chapter.

   You can declare variables of type `struct obstack' and use them as
obstacks, or you can allocate obstacks dynamically like any other kind
of object.  Dynamic allocation of obstacks allows your program to have a
variable number of different stacks.  (You can even allocate an obstack
structure in another obstack, but this is rarely useful.)

   All the functions that work with obstacks require you to specify
which obstack to use.  You do this with a pointer of type `struct
obstack *'.  In the following, we often say "an obstack" when strictly
speaking the object at hand is such a pointer.

   The objects in the obstack are packed into large blocks called
"chunks".  The `struct obstack' structure points to a chain of the
chunks currently in use.

   The obstack library obtains a new chunk whenever you allocate an
object that won't fit in the previous chunk.  Since the obstack library
manages chunks automatically, you don't need to pay much attention to
them, but you do need to supply a function which the obstack library
should use to get a chunk.  Usually you supply a function which uses
`malloc' directly or indirectly.  You must also supply a function to
free a chunk.  These matters are described in the following section.


File: libc.info,  Node: Preparing for Obstacks,  Next: Allocation in an Obstack,  Prev: Creating Obstacks,  Up: Obstacks

3.2.4.2 Preparing for Using Obstacks
....................................

Each source file in which you plan to use the obstack functions must
include the header file `obstack.h', like this:

     #include <obstack.h>

   Also, if the source file uses the macro `obstack_init', it must
declare or define two functions or macros that will be called by the
obstack library.  One, `obstack_chunk_alloc', is used to allocate the
chunks of memory into which objects are packed.  The other,
`obstack_chunk_free', is used to return chunks when the objects in them
are freed.  These macros should appear before any use of obstacks in
the source file.

   Usually these are defined to use `malloc' via the intermediary
`xmalloc' (*note Unconstrained Allocation::).  This is done with the
following pair of macro definitions:

     #define obstack_chunk_alloc xmalloc
     #define obstack_chunk_free free

Though the memory you get using obstacks really comes from `malloc',
using obstacks is faster because `malloc' is called less often, for
larger blocks of memory.  *Note Obstack Chunks::, for full details.

   At run time, before the program can use a `struct obstack' object as
an obstack, it must initialize the obstack by calling `obstack_init'.

 -- Function: int obstack_init (struct obstack *OBSTACK-PTR)
     Initialize obstack OBSTACK-PTR for allocation of objects.  This
     function calls the obstack's `obstack_chunk_alloc' function.  If
     allocation of memory fails, the function pointed to by
     `obstack_alloc_failed_handler' is called.  The `obstack_init'
     function always returns 1 (Compatibility notice: Former versions of
     obstack returned 0 if allocation failed).

   Here are two examples of how to allocate the space for an obstack and
initialize it.  First, an obstack that is a static variable:

     static struct obstack myobstack;
     ...
     obstack_init (&myobstack);

Second, an obstack that is itself dynamically allocated:

     struct obstack *myobstack_ptr
       = (struct obstack *) xmalloc (sizeof (struct obstack));

     obstack_init (myobstack_ptr);

 -- Variable: obstack_alloc_failed_handler
     The value of this variable is a pointer to a function that
     `obstack' uses when `obstack_chunk_alloc' fails to allocate
     memory.  The default action is to print a message and abort.  You
     should supply a function that either calls `exit' (*note Program
     Termination::) or `longjmp' (*note Non-Local Exits::) and doesn't
     return.

          void my_obstack_alloc_failed (void)
          ...
          obstack_alloc_failed_handler = &my_obstack_alloc_failed;



File: libc.info,  Node: Allocation in an Obstack,  Next: Freeing Obstack Objects,  Prev: Preparing for Obstacks,  Up: Obstacks

3.2.4.3 Allocation in an Obstack
................................

The most direct way to allocate an object in an obstack is with
`obstack_alloc', which is invoked almost like `malloc'.

 -- Function: void * obstack_alloc (struct obstack *OBSTACK-PTR, int
          SIZE)
     This allocates an uninitialized block of SIZE bytes in an obstack
     and returns its address.  Here OBSTACK-PTR specifies which obstack
     to allocate the block in; it is the address of the `struct obstack'
     object which represents the obstack.  Each obstack function or
     macro requires you to specify an OBSTACK-PTR as the first argument.

     This function calls the obstack's `obstack_chunk_alloc' function if
     it needs to allocate a new chunk of memory; it calls
     `obstack_alloc_failed_handler' if allocation of memory by
     `obstack_chunk_alloc' failed.

   For example, here is a function that allocates a copy of a string STR
in a specific obstack, which is in the variable `string_obstack':

     struct obstack string_obstack;

     char *
     copystring (char *string)
     {
       size_t len = strlen (string) + 1;
       char *s = (char *) obstack_alloc (&string_obstack, len);
       memcpy (s, string, len);
       return s;
     }

   To allocate a block with specified contents, use the function
`obstack_copy', declared like this:

 -- Function: void * obstack_copy (struct obstack *OBSTACK-PTR, void
          *ADDRESS, int SIZE)
     This allocates a block and initializes it by copying SIZE bytes of
     data starting at ADDRESS.  It calls `obstack_alloc_failed_handler'
     if allocation of memory by `obstack_chunk_alloc' failed.

 -- Function: void * obstack_copy0 (struct obstack *OBSTACK-PTR, void
          *ADDRESS, int SIZE)
     Like `obstack_copy', but appends an extra byte containing a null
     character.  This extra byte is not counted in the argument SIZE.

   The `obstack_copy0' function is convenient for copying a sequence of
characters into an obstack as a null-terminated string.  Here is an
example of its use:

     char *
     obstack_savestring (char *addr, int size)
     {
       return obstack_copy0 (&myobstack, addr, size);
     }

Contrast this with the previous example of `savestring' using `malloc'
(*note Basic Allocation::).


File: libc.info,  Node: Freeing Obstack Objects,  Next: Obstack Functions,  Prev: Allocation in an Obstack,  Up: Obstacks

3.2.4.4 Freeing Objects in an Obstack
.....................................

To free an object allocated in an obstack, use the function
`obstack_free'.  Since the obstack is a stack of objects, freeing one
object automatically frees all other objects allocated more recently in
the same obstack.

 -- Function: void obstack_free (struct obstack *OBSTACK-PTR, void
          *OBJECT)
     If OBJECT is a null pointer, everything allocated in the obstack
     is freed.  Otherwise, OBJECT must be the address of an object
     allocated in the obstack.  Then OBJECT is freed, along with
     everything allocated in OBSTACK since OBJECT.

   Note that if OBJECT is a null pointer, the result is an
uninitialized obstack.  To free all memory in an obstack but leave it
valid for further allocation, call `obstack_free' with the address of
the first object allocated on the obstack:

     obstack_free (obstack_ptr, first_object_allocated_ptr);

   Recall that the objects in an obstack are grouped into chunks.  When
all the objects in a chunk become free, the obstack library
automatically frees the chunk (*note Preparing for Obstacks::).  Then
other obstacks, or non-obstack allocation, can reuse the space of the
chunk.


File: libc.info,  Node: Obstack Functions,  Next: Growing Objects,  Prev: Freeing Obstack Objects,  Up: Obstacks

3.2.4.5 Obstack Functions and Macros
....................................

The interfaces for using obstacks may be defined either as functions or
as macros, depending on the compiler.  The obstack facility works with
all C compilers, including both ISO C and traditional C, but there are
precautions you must take if you plan to use compilers other than GNU C.

   If you are using an old-fashioned non-ISO C compiler, all the obstack
"functions" are actually defined only as macros.  You can call these
macros like functions, but you cannot use them in any other way (for
example, you cannot take their address).

   Calling the macros requires a special precaution: namely, the first
operand (the obstack pointer) may not contain any side effects, because
it may be computed more than once.  For example, if you write this:

     obstack_alloc (get_obstack (), 4);

you will find that `get_obstack' may be called several times.  If you
use `*obstack_list_ptr++' as the obstack pointer argument, you will get
very strange results since the incrementation may occur several times.

   In ISO C, each function has both a macro definition and a function
definition.  The function definition is used if you take the address of
the function without calling it.  An ordinary call uses the macro
definition by default, but you can request the function definition
instead by writing the function name in parentheses, as shown here:

     char *x;
     void *(*funcp) ();
     /* Use the macro.  */
     x = (char *) obstack_alloc (obptr, size);
     /* Call the function.  */
     x = (char *) (obstack_alloc) (obptr, size);
     /* Take the address of the function.  */
     funcp = obstack_alloc;

This is the same situation that exists in ISO C for the standard library
functions.  *Note Macro Definitions::.

   *Warning:* When you do use the macros, you must observe the
precaution of avoiding side effects in the first operand, even in ISO C.

   If you use the GNU C compiler, this precaution is not necessary,
because various language extensions in GNU C permit defining the macros
so as to compute each argument only once.


File: libc.info,  Node: Growing Objects,  Next: Extra Fast Growing,  Prev: Obstack Functions,  Up: Obstacks

3.2.4.6 Growing Objects
.......................

Because memory in obstack chunks is used sequentially, it is possible to
build up an object step by step, adding one or more bytes at a time to
the end of the object.  With this technique, you do not need to know
how much data you will put in the object until you come to the end of
it.  We call this the technique of "growing objects".  The special
functions for adding data to the growing object are described in this
section.

   You don't need to do anything special when you start to grow an
object.  Using one of the functions to add data to the object
automatically starts it.  However, it is necessary to say explicitly
when the object is finished.  This is done with the function
`obstack_finish'.

   The actual address of the object thus built up is not known until the
object is finished.  Until then, it always remains possible that you
will add so much data that the object must be copied into a new chunk.

   While the obstack is in use for a growing object, you cannot use it
for ordinary allocation of another object.  If you try to do so, the
space already added to the growing object will become part of the other
object.

 -- Function: void obstack_blank (struct obstack *OBSTACK-PTR, int SIZE)
     The most basic function for adding to a growing object is
     `obstack_blank', which adds space without initializing it.

 -- Function: void obstack_grow (struct obstack *OBSTACK-PTR, void
          *DATA, int SIZE)
     To add a block of initialized space, use `obstack_grow', which is
     the growing-object analogue of `obstack_copy'.  It adds SIZE bytes
     of data to the growing object, copying the contents from DATA.

 -- Function: void obstack_grow0 (struct obstack *OBSTACK-PTR, void
          *DATA, int SIZE)
     This is the growing-object analogue of `obstack_copy0'.  It adds
     SIZE bytes copied from DATA, followed by an additional null
     character.

 -- Function: void obstack_1grow (struct obstack *OBSTACK-PTR, char C)
     To add one character at a time, use the function `obstack_1grow'.
     It adds a single byte containing C to the growing object.

 -- Function: void obstack_ptr_grow (struct obstack *OBSTACK-PTR, void
          *DATA)
     Adding the value of a pointer one can use the function
     `obstack_ptr_grow'.  It adds `sizeof (void *)' bytes containing
     the value of DATA.

 -- Function: void obstack_int_grow (struct obstack *OBSTACK-PTR, int
          DATA)
     A single value of type `int' can be added by using the
     `obstack_int_grow' function.  It adds `sizeof (int)' bytes to the
     growing object and initializes them with the value of DATA.

 -- Function: void * obstack_finish (struct obstack *OBSTACK-PTR)
     When you are finished growing the object, use the function
     `obstack_finish' to close it off and return its final address.

     Once you have finished the object, the obstack is available for
     ordinary allocation or for growing another object.

     This function can return a null pointer under the same conditions
     as `obstack_alloc' (*note Allocation in an Obstack::).

   When you build an object by growing it, you will probably need to
know afterward how long it became.  You need not keep track of this as
you grow the object, because you can find out the length from the
obstack just before finishing the object with the function
`obstack_object_size', declared as follows:

 -- Function: int obstack_object_size (struct obstack *OBSTACK-PTR)
     This function returns the current size of the growing object, in
     bytes.  Remember to call this function _before_ finishing the
     object.  After it is finished, `obstack_object_size' will return
     zero.

   If you have started growing an object and wish to cancel it, you
should finish it and then free it, like this:

     obstack_free (obstack_ptr, obstack_finish (obstack_ptr));

This has no effect if no object was growing.

   You can use `obstack_blank' with a negative size argument to make
the current object smaller.  Just don't try to shrink it beyond zero
length--there's no telling what will happen if you do that.


File: libc.info,  Node: Extra Fast Growing,  Next: Status of an Obstack,  Prev: Growing Objects,  Up: Obstacks

3.2.4.7 Extra Fast Growing Objects
..................................

The usual functions for growing objects incur overhead for checking
whether there is room for the new growth in the current chunk.  If you
are frequently constructing objects in small steps of growth, this
overhead can be significant.

   You can reduce the overhead by using special "fast growth" functions
that grow the object without checking.  In order to have a robust
program, you must do the checking yourself.  If you do this checking in
the simplest way each time you are about to add data to the object, you
have not saved anything, because that is what the ordinary growth
functions do.  But if you can arrange to check less often, or check
more efficiently, then you make the program faster.

   The function `obstack_room' returns the amount of room available in
the current chunk.  It is declared as follows:

 -- Function: int obstack_room (struct obstack *OBSTACK-PTR)
     This returns the number of bytes that can be added safely to the
     current growing object (or to an object about to be started) in
     obstack OBSTACK using the fast growth functions.

   While you know there is room, you can use these fast growth functions
for adding data to a growing object:

 -- Function: void obstack_1grow_fast (struct obstack *OBSTACK-PTR,
          char C)
     The function `obstack_1grow_fast' adds one byte containing the
     character C to the growing object in obstack OBSTACK-PTR.

 -- Function: void obstack_ptr_grow_fast (struct obstack *OBSTACK-PTR,
          void *DATA)
     The function `obstack_ptr_grow_fast' adds `sizeof (void *)' bytes
     containing the value of DATA to the growing object in obstack
     OBSTACK-PTR.

 -- Function: void obstack_int_grow_fast (struct obstack *OBSTACK-PTR,
          int DATA)
     The function `obstack_int_grow_fast' adds `sizeof (int)' bytes
     containing the value of DATA to the growing object in obstack
     OBSTACK-PTR.

 -- Function: void obstack_blank_fast (struct obstack *OBSTACK-PTR, int
          SIZE)
     The function `obstack_blank_fast' adds SIZE bytes to the growing
     object in obstack OBSTACK-PTR without initializing them.

   When you check for space using `obstack_room' and there is not
enough room for what you want to add, the fast growth functions are not
safe.  In this case, simply use the corresponding ordinary growth
function instead.  Very soon this will copy the object to a new chunk;
then there will be lots of room available again.

   So, each time you use an ordinary growth function, check afterward
for sufficient space using `obstack_room'.  Once the object is copied
to a new chunk, there will be plenty of space again, so the program will
start using the fast growth functions again.

   Here is an example:

     void
     add_string (struct obstack *obstack, const char *ptr, int len)
     {
       while (len > 0)
         {
           int room = obstack_room (obstack);
           if (room == 0)
             {
               /* Not enough room. Add one character slowly,
                  which may copy to a new chunk and make room.  */
               obstack_1grow (obstack, *ptr++);
               len--;
             }
           else
             {
               if (room > len)
                 room = len;
               /* Add fast as much as we have room for. */
               len -= room;
               while (room-- > 0)
                 obstack_1grow_fast (obstack, *ptr++);
             }
         }
     }


File: libc.info,  Node: Status of an Obstack,  Next: Obstacks Data Alignment,  Prev: Extra Fast Growing,  Up: Obstacks

3.2.4.8 Status of an Obstack
............................

Here are functions that provide information on the current status of
allocation in an obstack.  You can use them to learn about an object
while still growing it.

 -- Function: void * obstack_base (struct obstack *OBSTACK-PTR)
     This function returns the tentative address of the beginning of the
     currently growing object in OBSTACK-PTR.  If you finish the object
     immediately, it will have that address.  If you make it larger
     first, it may outgrow the current chunk--then its address will
     change!

     If no object is growing, this value says where the next object you
     allocate will start (once again assuming it fits in the current
     chunk).

 -- Function: void * obstack_next_free (struct obstack *OBSTACK-PTR)
     This function returns the address of the first free byte in the
     current chunk of obstack OBSTACK-PTR.  This is the end of the
     currently growing object.  If no object is growing,
     `obstack_next_free' returns the same value as `obstack_base'.

 -- Function: int obstack_object_size (struct obstack *OBSTACK-PTR)
     This function returns the size in bytes of the currently growing
     object.  This is equivalent to

          obstack_next_free (OBSTACK-PTR) - obstack_base (OBSTACK-PTR)


File: libc.info,  Node: Obstacks Data Alignment,  Next: Obstack Chunks,  Prev: Status of an Obstack,  Up: Obstacks

3.2.4.9 Alignment of Data in Obstacks
.....................................

Each obstack has an "alignment boundary"; each object allocated in the
obstack automatically starts on an address that is a multiple of the
specified boundary.  By default, this boundary is aligned so that the
object can hold any type of data.

   To access an obstack's alignment boundary, use the macro
`obstack_alignment_mask', whose function prototype looks like this:

 -- Macro: int obstack_alignment_mask (struct obstack *OBSTACK-PTR)
     The value is a bit mask; a bit that is 1 indicates that the
     corresponding bit in the address of an object should be 0.  The
     mask value should be one less than a power of 2; the effect is
     that all object addresses are multiples of that power of 2.  The
     default value of the mask is a value that allows aligned objects
     to hold any type of data: for example, if its value is 3, any type
     of data can be stored at locations whose addresses are multiples
     of 4.  A mask value of 0 means an object can start on any multiple
     of 1 (that is, no alignment is required).

     The expansion of the macro `obstack_alignment_mask' is an lvalue,
     so you can alter the mask by assignment.  For example, this
     statement:

          obstack_alignment_mask (obstack_ptr) = 0;

     has the effect of turning off alignment processing in the
     specified obstack.

   Note that a change in alignment mask does not take effect until
_after_ the next time an object is allocated or finished in the
obstack.  If you are not growing an object, you can make the new
alignment mask take effect immediately by calling `obstack_finish'.
This will finish a zero-length object and then do proper alignment for
the next object.


File: libc.info,  Node: Obstack Chunks,  Next: Summary of Obstacks,  Prev: Obstacks Data Alignment,  Up: Obstacks

3.2.4.10 Obstack Chunks
.......................

Obstacks work by allocating space for themselves in large chunks, and
then parceling out space in the chunks to satisfy your requests.  Chunks
are normally 4096 bytes long unless you specify a different chunk size.
The chunk size includes 8 bytes of overhead that are not actually used
for storing objects.  Regardless of the specified size, longer chunks
will be allocated when necessary for long objects.

   The obstack library allocates chunks by calling the function
`obstack_chunk_alloc', which you must define.  When a chunk is no
longer needed because you have freed all the objects in it, the obstack
library frees the chunk by calling `obstack_chunk_free', which you must
also define.

   These two must be defined (as macros) or declared (as functions) in
each source file that uses `obstack_init' (*note Creating Obstacks::).
Most often they are defined as macros like this:

     #define obstack_chunk_alloc malloc
     #define obstack_chunk_free free

   Note that these are simple macros (no arguments).  Macro definitions
with arguments will not work!  It is necessary that
`obstack_chunk_alloc' or `obstack_chunk_free', alone, expand into a
function name if it is not itself a function name.

   If you allocate chunks with `malloc', the chunk size should be a
power of 2.  The default chunk size, 4096, was chosen because it is long
enough to satisfy many typical requests on the obstack yet short enough
not to waste too much memory in the portion of the last chunk not yet
used.

 -- Macro: int obstack_chunk_size (struct obstack *OBSTACK-PTR)
     This returns the chunk size of the given obstack.

   Since this macro expands to an lvalue, you can specify a new chunk
size by assigning it a new value.  Doing so does not affect the chunks
already allocated, but will change the size of chunks allocated for
that particular obstack in the future.  It is unlikely to be useful to
make the chunk size smaller, but making it larger might improve
efficiency if you are allocating many objects whose size is comparable
to the chunk size.  Here is how to do so cleanly:

     if (obstack_chunk_size (obstack_ptr) < NEW-CHUNK-SIZE)
       obstack_chunk_size (obstack_ptr) = NEW-CHUNK-SIZE;


File: libc.info,  Node: Summary of Obstacks,  Prev: Obstack Chunks,  Up: Obstacks

3.2.4.11 Summary of Obstack Functions
.....................................

Here is a summary of all the functions associated with obstacks.  Each
takes the address of an obstack (`struct obstack *') as its first
argument.

`void obstack_init (struct obstack *OBSTACK-PTR)'
     Initialize use of an obstack.  *Note Creating Obstacks::.

`void *obstack_alloc (struct obstack *OBSTACK-PTR, int SIZE)'
     Allocate an object of SIZE uninitialized bytes.  *Note Allocation
     in an Obstack::.

`void *obstack_copy (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)'
     Allocate an object of SIZE bytes, with contents copied from
     ADDRESS.  *Note Allocation in an Obstack::.

`void *obstack_copy0 (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)'
     Allocate an object of SIZE+1 bytes, with SIZE of them copied from
     ADDRESS, followed by a null character at the end.  *Note
     Allocation in an Obstack::.

`void obstack_free (struct obstack *OBSTACK-PTR, void *OBJECT)'
     Free OBJECT (and everything allocated in the specified obstack
     more recently than OBJECT).  *Note Freeing Obstack Objects::.

`void obstack_blank (struct obstack *OBSTACK-PTR, int SIZE)'
     Add SIZE uninitialized bytes to a growing object.  *Note Growing
     Objects::.

`void obstack_grow (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)'
     Add SIZE bytes, copied from ADDRESS, to a growing object.  *Note
     Growing Objects::.

`void obstack_grow0 (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)'
     Add SIZE bytes, copied from ADDRESS, to a growing object, and then
     add another byte containing a null character.  *Note Growing
     Objects::.

`void obstack_1grow (struct obstack *OBSTACK-PTR, char DATA-CHAR)'
     Add one byte containing DATA-CHAR to a growing object.  *Note
     Growing Objects::.

`void *obstack_finish (struct obstack *OBSTACK-PTR)'
     Finalize the object that is growing and return its permanent
     address.  *Note Growing Objects::.

`int obstack_object_size (struct obstack *OBSTACK-PTR)'
     Get the current size of the currently growing object.  *Note
     Growing Objects::.

`void obstack_blank_fast (struct obstack *OBSTACK-PTR, int SIZE)'
     Add SIZE uninitialized bytes to a growing object without checking
     that there is enough room.  *Note Extra Fast Growing::.

`void obstack_1grow_fast (struct obstack *OBSTACK-PTR, char DATA-CHAR)'
     Add one byte containing DATA-CHAR to a growing object without
     checking that there is enough room.  *Note Extra Fast Growing::.

`int obstack_room (struct obstack *OBSTACK-PTR)'
     Get the amount of room now available for growing the current
     object.  *Note Extra Fast Growing::.

`int obstack_alignment_mask (struct obstack *OBSTACK-PTR)'
     The mask used for aligning the beginning of an object.  This is an
     lvalue.  *Note Obstacks Data Alignment::.

`int obstack_chunk_size (struct obstack *OBSTACK-PTR)'
     The size for allocating chunks.  This is an lvalue.  *Note Obstack
     Chunks::.

`void *obstack_base (struct obstack *OBSTACK-PTR)'
     Tentative starting address of the currently growing object.  *Note
     Status of an Obstack::.

`void *obstack_next_free (struct obstack *OBSTACK-PTR)'
     Address just after the end of the currently growing object.  *Note
     Status of an Obstack::.


File: libc.info,  Node: Variable Size Automatic,  Prev: Obstacks,  Up: Memory Allocation

3.2.5 Automatic Storage with Variable Size
------------------------------------------

The function `alloca' supports a kind of half-dynamic allocation in
which blocks are allocated dynamically but freed automatically.

   Allocating a block with `alloca' is an explicit action; you can
allocate as many blocks as you wish, and compute the size at run time.
But all the blocks are freed when you exit the function that `alloca'
was called from, just as if they were automatic variables declared in
that function.  There is no way to free the space explicitly.

   The prototype for `alloca' is in `stdlib.h'.  This function is a BSD
extension.  

 -- Function: void * alloca (size_t SIZE);
     The return value of `alloca' is the address of a block of SIZE
     bytes of memory, allocated in the stack frame of the calling
     function.

   Do not use `alloca' inside the arguments of a function call--you
will get unpredictable results, because the stack space for the
`alloca' would appear on the stack in the middle of the space for the
function arguments.  An example of what to avoid is `foo (x, alloca
(4), y)'.

* Menu:

* Alloca Example::              Example of using `alloca'.
* Advantages of Alloca::        Reasons to use `alloca'.
* Disadvantages of Alloca::     Reasons to avoid `alloca'.
* GNU C Variable-Size Arrays::  Only in GNU C, here is an alternative
				 method of allocating dynamically and
				 freeing automatically.


File: libc.info,  Node: Alloca Example,  Next: Advantages of Alloca,  Up: Variable Size Automatic

3.2.5.1 `alloca' Example
........................

As an example of the use of `alloca', here is a function that opens a
file name made from concatenating two argument strings, and returns a
file descriptor or minus one signifying failure:

     int
     open2 (char *str1, char *str2, int flags, int mode)
     {
       char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
       stpcpy (stpcpy (name, str1), str2);
       return open (name, flags, mode);
     }

Here is how you would get the same results with `malloc' and `free':

     int
     open2 (char *str1, char *str2, int flags, int mode)
     {
       char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
       int desc;
       if (name == 0)
         fatal ("virtual memory exceeded");
       stpcpy (stpcpy (name, str1), str2);
       desc = open (name, flags, mode);
       free (name);
       return desc;
     }

   As you can see, it is simpler with `alloca'.  But `alloca' has
other, more important advantages, and some disadvantages.


File: libc.info,  Node: Advantages of Alloca,  Next: Disadvantages of Alloca,  Prev: Alloca Example,  Up: Variable Size Automatic

3.2.5.2 Advantages of `alloca'
..............................

Here are the reasons why `alloca' may be preferable to `malloc':

   * Using `alloca' wastes very little space and is very fast.  (It is
     open-coded by the GNU C compiler.)

   * Since `alloca' does not have separate pools for different sizes of
     block, space used for any size block can be reused for any other
     size.  `alloca' does not cause memory fragmentation.

   * Nonlocal exits done with `longjmp' (*note Non-Local Exits::)
     automatically free the space allocated with `alloca' when they exit
     through the function that called `alloca'.  This is the most
     important reason to use `alloca'.

     To illustrate this, suppose you have a function
     `open_or_report_error' which returns a descriptor, like `open', if
     it succeeds, but does not return to its caller if it fails.  If
     the file cannot be opened, it prints an error message and jumps
     out to the command level of your program using `longjmp'.  Let's
     change `open2' (*note Alloca Example::) to use this subroutine:

          int
          open2 (char *str1, char *str2, int flags, int mode)
          {
            char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
            stpcpy (stpcpy (name, str1), str2);
            return open_or_report_error (name, flags, mode);
          }

     Because of the way `alloca' works, the memory it allocates is
     freed even when an error occurs, with no special effort required.

     By contrast, the previous definition of `open2' (which uses
     `malloc' and `free') would develop a memory leak if it were
     changed in this way.  Even if you are willing to make more changes
     to fix it, there is no easy way to do so.


File: libc.info,  Node: Disadvantages of Alloca,  Next: GNU C Variable-Size Arrays,  Prev: Advantages of Alloca,  Up: Variable Size Automatic

3.2.5.3 Disadvantages of `alloca'
.................................

These are the disadvantages of `alloca' in comparison with `malloc':

   * If you try to allocate more memory than the machine can provide,
     you don't get a clean error message.  Instead you get a fatal
     signal like the one you would get from an infinite recursion;
     probably a segmentation violation (*note Program Error Signals::).

   * Some non-GNU systems fail to support `alloca', so it is less
     portable.  However, a slower emulation of `alloca' written in C is
     available for use on systems with this deficiency.


File: libc.info,  Node: GNU C Variable-Size Arrays,  Prev: Disadvantages of Alloca,  Up: Variable Size Automatic

3.2.5.4 GNU C Variable-Size Arrays
..................................

In GNU C, you can replace most uses of `alloca' with an array of
variable size.  Here is how `open2' would look then:

     int open2 (char *str1, char *str2, int flags, int mode)
     {
       char name[strlen (str1) + strlen (str2) + 1];
       stpcpy (stpcpy (name, str1), str2);
       return open (name, flags, mode);
     }

   But `alloca' is not always equivalent to a variable-sized array, for
several reasons:

   * A variable size array's space is freed at the end of the scope of
     the name of the array.  The space allocated with `alloca' remains
     until the end of the function.

   * It is possible to use `alloca' within a loop, allocating an
     additional block on each iteration.  This is impossible with
     variable-sized arrays.

   *NB:* If you mix use of `alloca' and variable-sized arrays within
one function, exiting a scope in which a variable-sized array was
declared frees all blocks allocated with `alloca' during the execution
of that scope.


File: libc.info,  Node: Resizing the Data Segment,  Prev: Locking Pages,  Up: Memory

3.3 Resizing the Data Segment
=============================

The symbols in this section are declared in `unistd.h'.

   You will not normally use the functions in this section, because the
functions described in *Note Memory Allocation:: are easier to use.
Those are interfaces to a GNU C Library memory allocator that uses the
functions below itself.  The functions below are simple interfaces to
system calls.

 -- Function: int brk (void *ADDR)
     `brk' sets the high end of the calling process' data segment to
     ADDR.

     The address of the end of a segment is defined to be the address
     of the last byte in the segment plus 1.

     The function has no effect if ADDR is lower than the low end of
     the data segment.  (This is considered success, by the way).

     The function fails if it would cause the data segment to overlap
     another segment or exceed the process' data storage limit (*note
     Limits on Resources::).

     The function is named for a common historical case where data
     storage and the stack are in the same segment.  Data storage
     allocation grows upward from the bottom of the segment while the
     stack grows downward toward it from the top of the segment and the
     curtain between them is called the "break".

     The return value is zero on success.  On failure, the return value
     is `-1' and `errno' is set accordingly.  The following `errno'
     values are specific to this function:

    `ENOMEM'
          The request would cause the data segment to overlap another
          segment or exceed the process' data storage limit.


 -- Function: void *sbrk (ptrdiff_t DELTA)
     This function is the same as `brk' except that you specify the new
     end of the data segment as an offset DELTA from the current end
     and on success the return value is the address of the resulting
     end of the data segment instead of zero.

     This means you can use `sbrk(0)' to find out what the current end
     of the data segment is.



File: libc.info,  Node: Locking Pages,  Next: Resizing the Data Segment,  Prev: Memory Allocation,  Up: Memory

3.4 Locking Pages
=================

You can tell the system to associate a particular virtual memory page
with a real page frame and keep it that way -- i.e., cause the page to
be paged in if it isn't already and mark it so it will never be paged
out and consequently will never cause a page fault.  This is called
"locking" a page.

   The functions in this chapter lock and unlock the calling process'
pages.

* Menu:

* Why Lock Pages::                Reasons to read this section.
* Locked Memory Details::         Everything you need to know locked
                                    memory
* Page Lock Functions::           Here's how to do it.


File: libc.info,  Node: Why Lock Pages,  Next: Locked Memory Details,  Up: Locking Pages

3.4.1 Why Lock Pages
--------------------

Because page faults cause paged out pages to be paged in transparently,
a process rarely needs to be concerned about locking pages.  However,
there are two reasons people sometimes are:

   * Speed.  A page fault is transparent only insofar as the process is
     not sensitive to how long it takes to do a simple memory access.
     Time-critical processes, especially realtime processes, may not be
     able to wait or may not be able to tolerate variance in execution
     speed.  

     A process that needs to lock pages for this reason probably also
     needs priority among other processes for use of the CPU.  *Note
     Priority::.

     In some cases, the programmer knows better than the system's demand
     paging allocator which pages should remain in real memory to
     optimize system performance.  In this case, locking pages can help.

   * Privacy.  If you keep secrets in virtual memory and that virtual
     memory gets paged out, that increases the chance that the secrets
     will get out.  If a password gets written out to disk swap space,
     for example, it might still be there long after virtual and real
     memory have been wiped clean.


   Be aware that when you lock a page, that's one fewer page frame that
can be used to back other virtual memory (by the same or other
processes), which can mean more page faults, which means the system
runs more slowly.  In fact, if you lock enough memory, some programs
may not be able to run at all for lack of real memory.


File: libc.info,  Node: Locked Memory Details,  Next: Page Lock Functions,  Prev: Why Lock Pages,  Up: Locking Pages

3.4.2 Locked Memory Details
---------------------------

A memory lock is associated with a virtual page, not a real frame.  The
paging rule is: If a frame backs at least one locked page, don't page it
out.

   Memory locks do not stack.  I.e., you can't lock a particular page
twice so that it has to be unlocked twice before it is truly unlocked.
It is either locked or it isn't.

   A memory lock persists until the process that owns the memory
explicitly unlocks it.  (But process termination and exec cause the
virtual memory to cease to exist, which you might say means it isn't
locked any more).

   Memory locks are not inherited by child processes.  (But note that
on a modern Unix system, immediately after a fork, the parent's and the
child's virtual address space are backed by the same real page frames,
so the child enjoys the parent's locks).  *Note Creating a Process::.

   Because of its ability to impact other processes, only the superuser
can lock a page.  Any process can unlock its own page.

   The system sets limits on the amount of memory a process can have
locked and the amount of real memory it can have dedicated to it.
*Note Limits on Resources::.

   In Linux, locked pages aren't as locked as you might think.  Two
virtual pages that are not shared memory can nonetheless be backed by
the same real frame.  The kernel does this in the name of efficiency
when it knows both virtual pages contain identical data, and does it
even if one or both of the virtual pages are locked.

   But when a process modifies one of those pages, the kernel must get
it a separate frame and fill it with the page's data.  This is known as
a "copy-on-write page fault".  It takes a small amount of time and in a
pathological case, getting that frame may require I/O.  

   To make sure this doesn't happen to your program, don't just lock the
pages.  Write to them as well, unless you know you won't write to them
ever.  And to make sure you have pre-allocated frames for your stack,
enter a scope that declares a C automatic variable larger than the
maximum stack size you will need, set it to something, then return from
its scope.


File: libc.info,  Node: Page Lock Functions,  Prev: Locked Memory Details,  Up: Locking Pages

3.4.3 Functions To Lock And Unlock Pages
----------------------------------------

The symbols in this section are declared in `sys/mman.h'.  These
functions are defined by POSIX.1b, but their availability depends on
your kernel.  If your kernel doesn't allow these functions, they exist
but always fail.  They _are_ available with a Linux kernel.

   *Portability Note:* POSIX.1b requires that when the `mlock' and
`munlock' functions are available, the file `unistd.h' define the macro
`_POSIX_MEMLOCK_RANGE' and the file `limits.h' define the macro
`PAGESIZE' to be the size of a memory page in bytes.  It requires that
when the `mlockall' and `munlockall' functions are available, the
`unistd.h' file define the macro `_POSIX_MEMLOCK'.  The GNU C library
conforms to this requirement.

 -- Function: int mlock (const void *ADDR, size_t LEN)
     `mlock' locks a range of the calling process' virtual pages.

     The range of memory starts at address ADDR and is LEN bytes long.
     Actually, since you must lock whole pages, it is the range of
     pages that include any part of the specified range.

     When the function returns successfully, each of those pages is
     backed by (connected to) a real frame (is resident) and is marked
     to stay that way.  This means the function may cause page-ins and
     have to wait for them.

     When the function fails, it does not affect the lock status of any
     pages.

     The return value is zero if the function succeeds.  Otherwise, it
     is `-1' and `errno' is set accordingly.  `errno' values specific
     to this function are:

    `ENOMEM'
             * At least some of the specified address range does not
               exist in the calling process' virtual address space.

             * The locking would cause the process to exceed its locked
               page limit.

    `EPERM'
          The calling process is not superuser.

    `EINVAL'
          LEN is not positive.

    `ENOSYS'
          The kernel does not provide `mlock' capability.


     You can lock _all_ a process' memory with `mlockall'.  You unlock
     memory with `munlock' or `munlockall'.

     To avoid all page faults in a C program, you have to use
     `mlockall', because some of the memory a program uses is hidden
     from the C code, e.g. the stack and automatic variables, and you
     wouldn't know what address to tell `mlock'.


 -- Function: int munlock (const void *ADDR, size_t LEN)
     `munlock' unlocks a range of the calling process' virtual pages.

     `munlock' is the inverse of `mlock' and functions completely
     analogously to `mlock', except that there is no `EPERM' failure.


 -- Function: int mlockall (int FLAGS)
     `mlockall' locks all the pages in a process' virtual memory address
     space, and/or any that are added to it in the future.  This
     includes the pages of the code, data and stack segment, as well as
     shared libraries, user space kernel data, shared memory, and
     memory mapped files.

     FLAGS is a string of single bit flags represented by the following
     macros.  They tell `mlockall' which of its functions you want.  All
     other bits must be zero.

    `MCL_CURRENT'
          Lock all pages which currently exist in the calling process'
          virtual address space.

    `MCL_FUTURE'
          Set a mode such that any pages added to the process' virtual
          address space in the future will be locked from birth.  This
          mode does not affect future address spaces owned by the same
          process so exec, which replaces a process' address space,
          wipes out `MCL_FUTURE'.  *Note Executing a File::.


     When the function returns successfully, and you specified
     `MCL_CURRENT', all of the process' pages are backed by (connected
     to) real frames (they are resident) and are marked to stay that
     way.  This means the function may cause page-ins and have to wait
     for them.

     When the process is in `MCL_FUTURE' mode because it successfully
     executed this function and specified `MCL_CURRENT', any system call
     by the process that requires space be added to its virtual address
     space fails with `errno' = `ENOMEM' if locking the additional space
     would cause the process to exceed its locked page limit.  In the
     case that the address space addition that can't be accommodated is
     stack expansion, the stack expansion fails and the kernel sends a
     `SIGSEGV' signal to the process.

     When the function fails, it does not affect the lock status of any
     pages or the future locking mode.

     The return value is zero if the function succeeds.  Otherwise, it
     is `-1' and `errno' is set accordingly.  `errno' values specific
     to this function are:

    `ENOMEM'
             * At least some of the specified address range does not
               exist in the calling process' virtual address space.

             * The locking would cause the process to exceed its locked
               page limit.

    `EPERM'
          The calling process is not superuser.

    `EINVAL'
          Undefined bits in FLAGS are not zero.

    `ENOSYS'
          The kernel does not provide `mlockall' capability.


     You can lock just specific pages with `mlock'.  You unlock pages
     with `munlockall' and `munlock'.


 -- Function: int munlockall (void)
     `munlockall' unlocks every page in the calling process' virtual
     address space and turn off `MCL_FUTURE' future locking mode.

     The return value is zero if the function succeeds.  Otherwise, it
     is `-1' and `errno' is set accordingly.  The only way this
     function can fail is for generic reasons that all functions and
     system calls can fail, so there are no specific `errno' values.



File: libc.info,  Node: Character Handling,  Next: String and Array Utilities,  Prev: Memory,  Up: Top

4 Character Handling
********************

Programs that work with characters and strings often need to classify a
character--is it alphabetic, is it a digit, is it whitespace, and so
on--and perform case conversion operations on characters.  The
functions in the header file `ctype.h' are provided for this purpose.  

   Since the choice of locale and character set can alter the
classifications of particular character codes, all of these functions
are affected by the current locale.  (More precisely, they are affected
by the locale currently selected for character classification--the
`LC_CTYPE' category; see *Note Locale Categories::.)

   The ISO C standard specifies two different sets of functions.  The
one set works on `char' type characters, the other one on `wchar_t'
wide characters (*note Extended Char Intro::).

* Menu:

* Classification of Characters::       Testing whether characters are
			                letters, digits, punctuation, etc.

* Case Conversion::                    Case mapping, and the like.
* Classification of Wide Characters::  Character class determination for
                                        wide characters.
* Using Wide Char Classes::            Notes on using the wide character
                                        classes.
* Wide Character Case Conversion::     Mapping of wide characters.


File: libc.info,  Node: Classification of Characters,  Next: Case Conversion,  Up: Character Handling

4.1 Classification of Characters
================================

This section explains the library functions for classifying characters.
For example, `isalpha' is the function to test for an alphabetic
character.  It takes one argument, the character to test, and returns a
nonzero integer if the character is alphabetic, and zero otherwise.  You
would use it like this:

     if (isalpha (c))
       printf ("The character `%c' is alphabetic.\n", c);

   Each of the functions in this section tests for membership in a
particular class of characters; each has a name starting with `is'.
Each of them takes one argument, which is a character to test, and
returns an `int' which is treated as a boolean value.  The character
argument is passed as an `int', and it may be the constant value `EOF'
instead of a real character.

   The attributes of any given character can vary between locales.
*Note Locales::, for more information on locales.

   These functions are declared in the header file `ctype.h'.  

 -- Function: int islower (int C)
     Returns true if C is a lower-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

 -- Function: int isupper (int C)
     Returns true if C is an upper-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

 -- Function: int isalpha (int C)
     Returns true if C is an alphabetic character (a letter).  If
     `islower' or `isupper' is true of a character, then `isalpha' is
     also true.

     In some locales, there may be additional characters for which
     `isalpha' is true--letters which are neither upper case nor lower
     case.  But in the standard `"C"' locale, there are no such
     additional characters.

 -- Function: int isdigit (int C)
     Returns true if C is a decimal digit (`0' through `9').

 -- Function: int isalnum (int C)
     Returns true if C is an alphanumeric character (a letter or
     number); in other words, if either `isalpha' or `isdigit' is true
     of a character, then `isalnum' is also true.

 -- Function: int isxdigit (int C)
     Returns true if C is a hexadecimal digit.  Hexadecimal digits
     include the normal decimal digits `0' through `9' and the letters
     `A' through `F' and `a' through `f'.

 -- Function: int ispunct (int C)
     Returns true if C is a punctuation character.  This means any
     printing character that is not alphanumeric or a space character.

 -- Function: int isspace (int C)
     Returns true if C is a "whitespace" character.  In the standard
     `"C"' locale, `isspace' returns true for only the standard
     whitespace characters:

    `' ''
          space

    `'\f''
          formfeed

    `'\n''
          newline

    `'\r''
          carriage return

    `'\t''
          horizontal tab

    `'\v''
          vertical tab

 -- Function: int isblank (int C)
     Returns true if C is a blank character; that is, a space or a tab.
     This function was originally a GNU extension, but was added in
     ISO C99.

 -- Function: int isgraph (int C)
     Returns true if C is a graphic character; that is, a character
     that has a glyph associated with it.  The whitespace characters
     are not considered graphic.

 -- Function: int isprint (int C)
     Returns true if C is a printing character.  Printing characters
     include all the graphic characters, plus the space (` ') character.

 -- Function: int iscntrl (int C)
     Returns true if C is a control character (that is, a character that
     is not a printing character).

 -- Function: int isascii (int C)
     Returns true if C is a 7-bit `unsigned char' value that fits into
     the US/UK ASCII character set.  This function is a BSD extension
     and is also an SVID extension.


File: libc.info,  Node: Case Conversion,  Next: Classification of Wide Characters,  Prev: Classification of Characters,  Up: Character Handling

4.2 Case Conversion
===================

This section explains the library functions for performing conversions
such as case mappings on characters.  For example, `toupper' converts
any character to upper case if possible.  If the character can't be
converted, `toupper' returns it unchanged.

   These functions take one argument of type `int', which is the
character to convert, and return the converted character as an `int'.
If the conversion is not applicable to the argument given, the argument
is returned unchanged.

   *Compatibility Note:* In pre-ISO C dialects, instead of returning
the argument unchanged, these functions may fail when the argument is
not suitable for the conversion.  Thus for portability, you may need to
write `islower(c) ? toupper(c) : c' rather than just `toupper(c)'.

   These functions are declared in the header file `ctype.h'.  

 -- Function: int tolower (int C)
     If C is an upper-case letter, `tolower' returns the corresponding
     lower-case letter.  If C is not an upper-case letter, C is
     returned unchanged.

 -- Function: int toupper (int C)
     If C is a lower-case letter, `toupper' returns the corresponding
     upper-case letter.  Otherwise C is returned unchanged.

 -- Function: int toascii (int C)
     This function converts C to a 7-bit `unsigned char' value that
     fits into the US/UK ASCII character set, by clearing the high-order
     bits.  This function is a BSD extension and is also an SVID
     extension.

 -- Function: int _tolower (int C)
     This is identical to `tolower', and is provided for compatibility
     with the SVID.  *Note SVID::.

 -- Function: int _toupper (int C)
     This is identical to `toupper', and is provided for compatibility
     with the SVID.


File: libc.info,  Node: Classification of Wide Characters,  Next: Using Wide Char Classes,  Prev: Case Conversion,  Up: Character Handling

4.3 Character class determination for wide characters
=====================================================

Amendment 1 to ISO C90 defines functions to classify wide characters.
Although the original ISO C90 standard already defined the type
`wchar_t', no functions operating on them were defined.

   The general design of the classification functions for wide
characters is more general.  It allows extensions to the set of
available classifications, beyond those which are always available.
The POSIX standard specifies how extensions can be made, and this is
already implemented in the GNU C library implementation of the
`localedef' program.

   The character class functions are normally implemented with bitsets,
with a bitset per character.  For a given character, the appropriate
bitset is read from a table and a test is performed as to whether a
certain bit is set.  Which bit is tested for is determined by the class.

   For the wide character classification functions this is made visible.
There is a type classification type defined, a function to retrieve this
value for a given class, and a function to test whether a given
character is in this class, using the classification value.  On top of
this the normal character classification functions as used for `char'
objects can be defined.

 -- Data type: wctype_t
     The `wctype_t' can hold a value which represents a character class.
     The only defined way to generate such a value is by using the
     `wctype' function.

     This type is defined in `wctype.h'.

 -- Function: wctype_t wctype (const char *PROPERTY)
     The `wctype' returns a value representing a class of wide
     characters which is identified by the string PROPERTY.  Beside
     some standard properties each locale can define its own ones.  In
     case no property with the given name is known for the current
     locale selected for the `LC_CTYPE' category, the function returns
     zero.

     The properties known in every locale are:

     `"alnum"'         `"alpha"'         `"cntrl"'         `"digit"'
     `"graph"'         `"lower"'         `"print"'         `"punct"'
     `"space"'         `"upper"'         `"xdigit"'        

     This function is declared in `wctype.h'.

   To test the membership of a character to one of the non-standard
classes the ISO C standard defines a completely new function.

 -- Function: int iswctype (wint_t WC, wctype_t DESC)
     This function returns a nonzero value if WC is in the character
     class specified by DESC.  DESC must previously be returned by a
     successful call to `wctype'.

     This function is declared in `wctype.h'.

   To make it easier to use the commonly-used classification functions,
they are defined in the C library.  There is no need to use `wctype' if
the property string is one of the known character classes.  In some
situations it is desirable to construct the property strings, and then
it is important that `wctype' can also handle the standard classes.

 -- Function: int iswalnum (wint_t WC)
     This function returns a nonzero value if WC is an alphanumeric
     character (a letter or number); in other words, if either
     `iswalpha' or `iswdigit' is true of a character, then `iswalnum'
     is also true.

     This function can be implemented using

          iswctype (wc, wctype ("alnum"))

     It is declared in `wctype.h'.

 -- Function: int iswalpha (wint_t WC)
     Returns true if WC is an alphabetic character (a letter).  If
     `iswlower' or `iswupper' is true of a character, then `iswalpha'
     is also true.

     In some locales, there may be additional characters for which
     `iswalpha' is true--letters which are neither upper case nor lower
     case.  But in the standard `"C"' locale, there are no such
     additional characters.

     This function can be implemented using

          iswctype (wc, wctype ("alpha"))

     It is declared in `wctype.h'.

 -- Function: int iswcntrl (wint_t WC)
     Returns true if WC is a control character (that is, a character
     that is not a printing character).

     This function can be implemented using

          iswctype (wc, wctype ("cntrl"))

     It is declared in `wctype.h'.

 -- Function: int iswdigit (wint_t WC)
     Returns true if WC is a digit (e.g., `0' through `9').  Please
     note that this function does not only return a nonzero value for
     _decimal_ digits, but for all kinds of digits.  A consequence is
     that code like the following will *not* work unconditionally for
     wide characters:

          n = 0;
          while (iswdigit (*wc))
            {
              n *= 10;
              n += *wc++ - L'0';
            }

     This function can be implemented using

          iswctype (wc, wctype ("digit"))

     It is declared in `wctype.h'.

 -- Function: int iswgraph (wint_t WC)
     Returns true if WC is a graphic character; that is, a character
     that has a glyph associated with it.  The whitespace characters
     are not considered graphic.

     This function can be implemented using

          iswctype (wc, wctype ("graph"))

     It is declared in `wctype.h'.

 -- Function: int iswlower (wint_t WC)
     Returns true if WC is a lower-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

     This function can be implemented using

          iswctype (wc, wctype ("lower"))

     It is declared in `wctype.h'.

 -- Function: int iswprint (wint_t WC)
     Returns true if WC is a printing character.  Printing characters
     include all the graphic characters, plus the space (` ') character.

     This function can be implemented using

          iswctype (wc, wctype ("print"))

     It is declared in `wctype.h'.

 -- Function: int iswpunct (wint_t WC)
     Returns true if WC is a punctuation character.  This means any
     printing character that is not alphanumeric or a space character.

     This function can be implemented using

          iswctype (wc, wctype ("punct"))

     It is declared in `wctype.h'.

 -- Function: int iswspace (wint_t WC)
     Returns true if WC is a "whitespace" character.  In the standard
     `"C"' locale, `iswspace' returns true for only the standard
     whitespace characters:

    `L' ''
          space

    `L'\f''
          formfeed

    `L'\n''
          newline

    `L'\r''
          carriage return

    `L'\t''
          horizontal tab

    `L'\v''
          vertical tab

     This function can be implemented using

          iswctype (wc, wctype ("space"))

     It is declared in `wctype.h'.

 -- Function: int iswupper (wint_t WC)
     Returns true if WC is an upper-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

     This function can be implemented using

          iswctype (wc, wctype ("upper"))

     It is declared in `wctype.h'.

 -- Function: int iswxdigit (wint_t WC)
     Returns true if WC is a hexadecimal digit.  Hexadecimal digits
     include the normal decimal digits `0' through `9' and the letters
     `A' through `F' and `a' through `f'.

     This function can be implemented using

          iswctype (wc, wctype ("xdigit"))

     It is declared in `wctype.h'.

   The GNU C library also provides a function which is not defined in
the ISO C standard but which is available as a version for single byte
characters as well.

 -- Function: int iswblank (wint_t WC)
     Returns true if WC is a blank character; that is, a space or a tab.
     This function was originally a GNU extension, but was added in
     ISO C99.  It is declared in `wchar.h'.


File: libc.info,  Node: Using Wide Char Classes,  Next: Wide Character Case Conversion,  Prev: Classification of Wide Characters,  Up: Character Handling

4.4 Notes on using the wide character classes
=============================================

The first note is probably not astonishing but still occasionally a
cause of problems.  The `iswXXX' functions can be implemented using
macros and in fact, the GNU C library does this.  They are still
available as real functions but when the `wctype.h' header is included
the macros will be used.  This is the same as the `char' type versions
of these functions.

   The second note covers something new.  It can be best illustrated by
a (real-world) example.  The first piece of code is an excerpt from the
original code.  It is truncated a bit but the intention should be clear.

     int
     is_in_class (int c, const char *class)
     {
       if (strcmp (class, "alnum") == 0)
         return isalnum (c);
       if (strcmp (class, "alpha") == 0)
         return isalpha (c);
       if (strcmp (class, "cntrl") == 0)
         return iscntrl (c);
       ...
       return 0;
     }

   Now, with the `wctype' and `iswctype' you can avoid the `if'
cascades, but rewriting the code as follows is wrong:

     int
     is_in_class (int c, const char *class)
     {
       wctype_t desc = wctype (class);
       return desc ? iswctype ((wint_t) c, desc) : 0;
     }

   The problem is that it is not guaranteed that the wide character
representation of a single-byte character can be found using casting.
In fact, usually this fails miserably.  The correct solution to this
problem is to write the code as follows:

     int
     is_in_class (int c, const char *class)
     {
       wctype_t desc = wctype (class);
       return desc ? iswctype (btowc (c), desc) : 0;
     }

   *Note Converting a Character::, for more information on `btowc'.
Note that this change probably does not improve the performance of the
program a lot since the `wctype' function still has to make the string
comparisons.  It gets really interesting if the `is_in_class' function
is called more than once for the same class name.  In this case the
variable DESC could be computed once and reused for all the calls.
Therefore the above form of the function is probably not the final one.


File: libc.info,  Node: Wide Character Case Conversion,  Prev: Using Wide Char Classes,  Up: Character Handling

4.5 Mapping of wide characters.
===============================

The classification functions are also generalized by the ISO C
standard.  Instead of just allowing the two standard mappings, a locale
can contain others.  Again, the `localedef' program already supports
generating such locale data files.

 -- Data Type: wctrans_t
     This data type is defined as a scalar type which can hold a value
     representing the locale-dependent character mapping.  There is no
     way to construct such a value apart from using the return value of
     the `wctrans' function.

     This type is defined in `wctype.h'.

 -- Function: wctrans_t wctrans (const char *PROPERTY)
     The `wctrans' function has to be used to find out whether a named
     mapping is defined in the current locale selected for the
     `LC_CTYPE' category.  If the returned value is non-zero, you can
     use it afterwards in calls to `towctrans'.  If the return value is
     zero no such mapping is known in the current locale.

     Beside locale-specific mappings there are two mappings which are
     guaranteed to be available in every locale:

     `"tolower"'                        `"toupper"'

     These functions are declared in `wctype.h'.

 -- Function: wint_t towctrans (wint_t WC, wctrans_t DESC)
     `towctrans' maps the input character WC according to the rules of
     the mapping for which DESC is a descriptor, and returns the value
     it finds.  DESC must be obtained by a successful call to `wctrans'.

     This function is declared in `wctype.h'.

   For the generally available mappings, the ISO C standard defines
convenient shortcuts so that it is not necessary to call `wctrans' for
them.

 -- Function: wint_t towlower (wint_t WC)
     If WC is an upper-case letter, `towlower' returns the corresponding
     lower-case letter.  If WC is not an upper-case letter, WC is
     returned unchanged.

     `towlower' can be implemented using

          towctrans (wc, wctrans ("tolower"))

     This function is declared in `wctype.h'.

 -- Function: wint_t towupper (wint_t WC)
     If WC is a lower-case letter, `towupper' returns the corresponding
     upper-case letter.  Otherwise WC is returned unchanged.

     `towupper' can be implemented using

          towctrans (wc, wctrans ("toupper"))

     This function is declared in `wctype.h'.

   The same warnings given in the last section for the use of the wide
character classification functions apply here.  It is not possible to
simply cast a `char' type value to a `wint_t' and use it as an argument
to `towctrans' calls.


File: libc.info,  Node: String and Array Utilities,  Next: Character Set Handling,  Prev: Character Handling,  Up: Top

5 String and Array Utilities
****************************

Operations on strings (or arrays of characters) are an important part of
many programs.  The GNU C library provides an extensive set of string
utility functions, including functions for copying, concatenating,
comparing, and searching strings.  Many of these functions can also
operate on arbitrary regions of storage; for example, the `memcpy'
function can be used to copy the contents of any kind of array.

   It's fairly common for beginning C programmers to "reinvent the
wheel" by duplicating this functionality in their own code, but it pays
to become familiar with the library functions and to make use of them,
since this offers benefits in maintenance, efficiency, and portability.

   For instance, you could easily compare one string to another in two
lines of C code, but if you use the built-in `strcmp' function, you're
less likely to make a mistake.  And, since these library functions are
typically highly optimized, your program may run faster too.

* Menu:

* Representation of Strings::   Introduction to basic concepts.
* String/Array Conventions::    Whether to use a string function or an
				 arbitrary array function.
* String Length::               Determining the length of a string.
* Copying and Concatenation::   Functions to copy the contents of strings
				 and arrays.
* String/Array Comparison::     Functions for byte-wise and character-wise
				 comparison.
* Collation Functions::         Functions for collating strings.
* Search Functions::            Searching for a specific element or substring.
* Finding Tokens in a String::  Splitting a string into tokens by looking
				 for delimiters.
* strfry::                      Function for flash-cooking a string.
* Trivial Encryption::          Obscuring data.
* Encode Binary Data::          Encoding and Decoding of Binary Data.
* Argz and Envz Vectors::       Null-separated string vectors.


File: libc.info,  Node: Representation of Strings,  Next: String/Array Conventions,  Up: String and Array Utilities

5.1 Representation of Strings
=============================

This section is a quick summary of string concepts for beginning C
programmers.  It describes how character strings are represented in C
and some common pitfalls.  If you are already familiar with this
material, you can skip this section.

   A "string" is an array of `char' objects.  But string-valued
variables are usually declared to be pointers of type `char *'.  Such
variables do not include space for the text of a string; that has to be
stored somewhere else--in an array variable, a string constant, or
dynamically allocated memory (*note Memory Allocation::).  It's up to
you to store the address of the chosen memory space into the pointer
variable.  Alternatively you can store a "null pointer" in the pointer
variable.  The null pointer does not point anywhere, so attempting to
reference the string it points to gets an error.

   "string" normally refers to multibyte character strings as opposed to
wide character strings.  Wide character strings are arrays of type
`wchar_t' and as for multibyte character strings usually pointers of
type `wchar_t *' are used.

   By convention, a "null character", `'\0'', marks the end of a
multibyte character string and the "null wide character", `L'\0'',
marks the end of a wide character string.  For example, in testing to
see whether the `char *' variable P points to a null character marking
the end of a string, you can write `!*P' or `*P == '\0''.

   A null character is quite different conceptually from a null pointer,
although both are represented by the integer `0'.

   "String literals" appear in C program source as strings of
characters between double-quote characters (`"') where the initial
double-quote character is immediately preceded by a capital `L' (ell)
character (as in `L"foo"').  In ISO C, string literals can also be
formed by "string concatenation": `"a" "b"' is the same as `"ab"'.  For
wide character strings one can either use `L"a" L"b"' or `L"a" "b"'.
Modification of string literals is not allowed by the GNU C compiler,
because literals are placed in read-only storage.

   Character arrays that are declared `const' cannot be modified
either.  It's generally good style to declare non-modifiable string
pointers to be of type `const char *', since this often allows the C
compiler to detect accidental modifications as well as providing some
amount of documentation about what your program intends to do with the
string.

   The amount of memory allocated for the character array may extend
past the null character that normally marks the end of the string.  In
this document, the term "allocated size" is always used to refer to the
total amount of memory allocated for the string, while the term
"length" refers to the number of characters up to (but not including)
the terminating null character.  

   A notorious source of program bugs is trying to put more characters
in a string than fit in its allocated size.  When writing code that
extends strings or moves characters into a pre-allocated array, you
should be very careful to keep track of the length of the text and make
explicit checks for overflowing the array.  Many of the library
functions _do not_ do this for you!  Remember also that you need to
allocate an extra byte to hold the null character that marks the end of
the string.

   Originally strings were sequences of bytes where each byte
represents a single character.  This is still true today if the strings
are encoded using a single-byte character encoding.  Things are
different if the strings are encoded using a multibyte encoding (for
more information on encodings see *Note Extended Char Intro::).  There
is no difference in the programming interface for these two kind of
strings; the programmer has to be aware of this and interpret the byte
sequences accordingly.

   But since there is no separate interface taking care of these
differences the byte-based string functions are sometimes hard to use.
Since the count parameters of these functions specify bytes a call to
`strncpy' could cut a multibyte character in the middle and put an
incomplete (and therefore unusable) byte sequence in the target buffer.

   To avoid these problems later versions of the ISO C standard
introduce a second set of functions which are operating on "wide
characters" (*note Extended Char Intro::).  These functions don't have
the problems the single-byte versions have since every wide character is
a legal, interpretable value.  This does not mean that cutting wide
character strings at arbitrary points is without problems.  It normally
is for alphabet-based languages (except for non-normalized text) but
languages based on syllables still have the problem that more than one
wide character is necessary to complete a logical unit.  This is a
higher level problem which the C library functions are not designed to
solve.  But it is at least good that no invalid byte sequences can be
created.  Also, the higher level functions can also much easier operate
on wide character than on multibyte characters so that a general advise
is to use wide characters internally whenever text is more than simply
copied.

   The remaining of this chapter will discuss the functions for handling
wide character strings in parallel with the discussion of the multibyte
character strings since there is almost always an exact equivalent
available.


File: libc.info,  Node: String/Array Conventions,  Next: String Length,  Prev: Representation of Strings,  Up: String and Array Utilities

5.2 String and Array Conventions
================================

This chapter describes both functions that work on arbitrary arrays or
blocks of memory, and functions that are specific to null-terminated
arrays of characters and wide characters.

   Functions that operate on arbitrary blocks of memory have names
beginning with `mem' and `wmem' (such as `memcpy' and `wmemcpy') and
invariably take an argument which specifies the size (in bytes and wide
characters respectively) of the block of memory to operate on.  The
array arguments and return values for these functions have type `void
*' or `wchar_t'.  As a matter of style, the elements of the arrays used
with the `mem' functions are referred to as "bytes".  You can pass any
kind of pointer to these functions, and the `sizeof' operator is useful
in computing the value for the size argument.  Parameters to the `wmem'
functions must be of type `wchar_t *'.  These functions are not really
usable with anything but arrays of this type.

   In contrast, functions that operate specifically on strings and wide
character strings have names beginning with `str' and `wcs'
respectively (such as `strcpy' and `wcscpy') and look for a null
character to terminate the string instead of requiring an explicit size
argument to be passed.  (Some of these functions accept a specified
maximum length, but they also check for premature termination with a
null character.)  The array arguments and return values for these
functions have type `char *' and `wchar_t *' respectively, and the
array elements are referred to as "characters" and "wide characters".

   In many cases, there are both `mem' and `str'/`wcs' versions of a
function.  The one that is more appropriate to use depends on the exact
situation.  When your program is manipulating arbitrary arrays or
blocks of storage, then you should always use the `mem' functions.  On
the other hand, when you are manipulating null-terminated strings it is
usually more convenient to use the `str'/`wcs' functions, unless you
already know the length of the string in advance.  The `wmem' functions
should be used for wide character arrays with known size.

   Some of the memory and string functions take single characters as
arguments.  Since a value of type `char' is automatically promoted into
an value of type `int' when used as a parameter, the functions are
declared with `int' as the type of the parameter in question.  In case
of the wide character function the situation is similarly: the
parameter type for a single wide character is `wint_t' and not
`wchar_t'.  This would for many implementations not be necessary since
the `wchar_t' is large enough to not be automatically promoted, but
since the ISO C standard does not require such a choice of types the
`wint_t' type is used.


File: libc.info,  Node: String Length,  Next: Copying and Concatenation,  Prev: String/Array Conventions,  Up: String and Array Utilities

5.3 String Length
=================

You can get the length of a string using the `strlen' function.  This
function is declared in the header file `string.h'.  

 -- Function: size_t strlen (const char *S)
     The `strlen' function returns the length of the null-terminated
     string S in bytes.  (In other words, it returns the offset of the
     terminating null character within the array.)

     For example,
          strlen ("hello, world")
              => 12

     When applied to a character array, the `strlen' function returns
     the length of the string stored there, not its allocated size.
     You can get the allocated size of the character array that holds a
     string using the `sizeof' operator:

          char string[32] = "hello, world";
          sizeof (string)
              => 32
          strlen (string)
              => 12

     But beware, this will not work unless STRING is the character
     array itself, not a pointer to it.  For example:

          char string[32] = "hello, world";
          char *ptr = string;
          sizeof (string)
              => 32
          sizeof (ptr)
              => 4  /* (on a machine with 4 byte pointers) */

     This is an easy mistake to make when you are working with
     functions that take string arguments; those arguments are always
     pointers, not arrays.

     It must also be noted that for multibyte encoded strings the return
     value does not have to correspond to the number of characters in
     the string.  To get this value the string can be converted to wide
     characters and `wcslen' can be used or something like the following
     code can be used:

          /* The input is in `string'.
             The length is expected in `n'.  */
          {
            mbstate_t t;
            char *scopy = string;
            /* In initial state.  */
            memset (&t, '\0', sizeof (t));
            /* Determine number of characters.  */
            n = mbsrtowcs (NULL, &scopy, strlen (scopy), &t);
          }

     This is cumbersome to do so if the number of characters (as
     opposed to bytes) is needed often it is better to work with wide
     characters.

   The wide character equivalent is declared in `wchar.h'.

 -- Function: size_t wcslen (const wchar_t *WS)
     The `wcslen' function is the wide character equivalent to
     `strlen'.  The return value is the number of wide characters in the
     wide character string pointed to by WS (this is also the offset of
     the terminating null wide character of WS).

     Since there are no multi wide character sequences making up one
     character the return value is not only the offset in the array, it
     is also the number of wide characters.

     This function was introduced in Amendment 1 to ISO C90.

 -- Function: size_t strnlen (const char *S, size_t MAXLEN)
     The `strnlen' function returns the length of the string S in bytes
     if this length is smaller than MAXLEN bytes.  Otherwise it returns
     MAXLEN.  Therefore this function is equivalent to `(strlen (S) < n
     ? strlen (S) : MAXLEN)' but it is more efficient and works even if
     the string S is not null-terminated.

          char string[32] = "hello, world";
          strnlen (string, 32)
              => 12
          strnlen (string, 5)
              => 5

     This function is a GNU extension and is declared in `string.h'.

 -- Function: size_t wcsnlen (const wchar_t *WS, size_t MAXLEN)
     `wcsnlen' is the wide character equivalent to `strnlen'.  The
     MAXLEN parameter specifies the maximum number of wide characters.

     This function is a GNU extension and is declared in `wchar.h'.


File: libc.info,  Node: Copying and Concatenation,  Next: String/Array Comparison,  Prev: String Length,  Up: String and Array Utilities

5.4 Copying and Concatenation
=============================

You can use the functions described in this section to copy the contents
of strings and arrays, or to append the contents of one string to
another.  The `str' and `mem' functions are declared in the header file
`string.h' while the `wstr' and `wmem' functions are declared in the
file `wchar.h'.  

   A helpful way to remember the ordering of the arguments to the
functions in this section is that it corresponds to an assignment
expression, with the destination array specified to the left of the
source array.  All of these functions return the address of the
destination array.

   Most of these functions do not work properly if the source and
destination arrays overlap.  For example, if the beginning of the
destination array overlaps the end of the source array, the original
contents of that part of the source array may get overwritten before it
is copied.  Even worse, in the case of the string functions, the null
character marking the end of the string may be lost, and the copy
function might get stuck in a loop trashing all the memory allocated to
your program.

   All functions that have problems copying between overlapping arrays
are explicitly identified in this manual.  In addition to functions in
this section, there are a few others like `sprintf' (*note Formatted
Output Functions::) and `scanf' (*note Formatted Input Functions::).

 -- Function: void * memcpy (void *restrict TO, const void *restrict
          FROM, size_t SIZE)
     The `memcpy' function copies SIZE bytes from the object beginning
     at FROM into the object beginning at TO.  The behavior of this
     function is undefined if the two arrays TO and FROM overlap; use
     `memmove' instead if overlapping is possible.

     The value returned by `memcpy' is the value of TO.

     Here is an example of how you might use `memcpy' to copy the
     contents of an array:

          struct foo *oldarray, *newarray;
          int arraysize;
          ...
          memcpy (new, old, arraysize * sizeof (struct foo));

 -- Function: wchar_t * wmemcpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)
     The `wmemcpy' function copies SIZE wide characters from the object
     beginning at WFROM into the object beginning at WTO.  The behavior
     of this function is undefined if the two arrays WTO and WFROM
     overlap; use `wmemmove' instead if overlapping is possible.

     The following is a possible implementation of `wmemcpy' but there
     are more optimizations possible.

          wchar_t *
          wmemcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                   size_t size)
          {
            return (wchar_t *) memcpy (wto, wfrom, size * sizeof (wchar_t));
          }

     The value returned by `wmemcpy' is the value of WTO.

     This function was introduced in Amendment 1 to ISO C90.

 -- Function: void * mempcpy (void *restrict TO, const void *restrict
          FROM, size_t SIZE)
     The `mempcpy' function is nearly identical to the `memcpy'
     function.  It copies SIZE bytes from the object beginning at
     `from' into the object pointed to by TO.  But instead of returning
     the value of TO it returns a pointer to the byte following the
     last written byte in the object beginning at TO.  I.e., the value
     is `((void *) ((char *) TO + SIZE))'.

     This function is useful in situations where a number of objects
     shall be copied to consecutive memory positions.

          void *
          combine (void *o1, size_t s1, void *o2, size_t s2)
          {
            void *result = malloc (s1 + s2);
            if (result != NULL)
              mempcpy (mempcpy (result, o1, s1), o2, s2);
            return result;
          }

     This function is a GNU extension.

 -- Function: wchar_t * wmempcpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)
     The `wmempcpy' function is nearly identical to the `wmemcpy'
     function.  It copies SIZE wide characters from the object
     beginning at `wfrom' into the object pointed to by WTO.  But
     instead of returning the value of WTO it returns a pointer to the
     wide character following the last written wide character in the
     object beginning at WTO.  I.e., the value is `WTO + SIZE'.

     This function is useful in situations where a number of objects
     shall be copied to consecutive memory positions.

     The following is a possible implementation of `wmemcpy' but there
     are more optimizations possible.

          wchar_t *
          wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                    size_t size)
          {
            return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
          }

     This function is a GNU extension.

 -- Function: void * memmove (void *TO, const void *FROM, size_t SIZE)
     `memmove' copies the SIZE bytes at FROM into the SIZE bytes at TO,
     even if those two blocks of space overlap.  In the case of
     overlap, `memmove' is careful to copy the original values of the
     bytes in the block at FROM, including those bytes which also
     belong to the block at TO.

     The value returned by `memmove' is the value of TO.

 -- Function: wchar_t * wmemmove (wchar *WTO, const wchar_t *WFROM,
          size_t SIZE)
     `wmemmove' copies the SIZE wide characters at WFROM into the SIZE
     wide characters at WTO, even if those two blocks of space overlap.
     In the case of overlap, `memmove' is careful to copy the original
     values of the wide characters in the block at WFROM, including
     those wide characters which also belong to the block at WTO.

     The following is a possible implementation of `wmemcpy' but there
     are more optimizations possible.

          wchar_t *
          wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                    size_t size)
          {
            return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
          }

     The value returned by `wmemmove' is the value of WTO.

     This function is a GNU extension.

 -- Function: void * memccpy (void *restrict TO, const void *restrict
          FROM, int C, size_t SIZE)
     This function copies no more than SIZE bytes from FROM to TO,
     stopping if a byte matching C is found.  The return value is a
     pointer into TO one byte past where C was copied, or a null
     pointer if no byte matching C appeared in the first SIZE bytes of
     FROM.

 -- Function: void * memset (void *BLOCK, int C, size_t SIZE)
     This function copies the value of C (converted to an `unsigned
     char') into each of the first SIZE bytes of the object beginning
     at BLOCK.  It returns the value of BLOCK.

 -- Function: wchar_t * wmemset (wchar_t *BLOCK, wchar_t WC, size_t
          SIZE)
     This function copies the value of WC into each of the first SIZE
     wide characters of the object beginning at BLOCK.  It returns the
     value of BLOCK.

 -- Function: char * strcpy (char *restrict TO, const char *restrict
          FROM)
     This copies characters from the string FROM (up to and including
     the terminating null character) into the string TO.  Like
     `memcpy', this function has undefined results if the strings
     overlap.  The return value is the value of TO.

 -- Function: wchar_t * wcscpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM)
     This copies wide characters from the string WFROM (up to and
     including the terminating null wide character) into the string
     WTO.  Like `wmemcpy', this function has undefined results if the
     strings overlap.  The return value is the value of WTO.

 -- Function: char * strncpy (char *restrict TO, const char *restrict
          FROM, size_t SIZE)
     This function is similar to `strcpy' but always copies exactly
     SIZE characters into TO.

     If the length of FROM is more than SIZE, then `strncpy' copies
     just the first SIZE characters.  Note that in this case there is
     no null terminator written into TO.

     If the length of FROM is less than SIZE, then `strncpy' copies all
     of FROM, followed by enough null characters to add up to SIZE
     characters in all.  This behavior is rarely useful, but it is
     specified by the ISO C standard.

     The behavior of `strncpy' is undefined if the strings overlap.

     Using `strncpy' as opposed to `strcpy' is a way to avoid bugs
     relating to writing past the end of the allocated space for TO.
     However, it can also make your program much slower in one common
     case: copying a string which is probably small into a potentially
     large buffer.  In this case, SIZE may be large, and when it is,
     `strncpy' will waste a considerable amount of time copying null
     characters.

 -- Function: wchar_t * wcsncpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)
     This function is similar to `wcscpy' but always copies exactly
     SIZE wide characters into WTO.

     If the length of WFROM is more than SIZE, then `wcsncpy' copies
     just the first SIZE wide characters.  Note that in this case there
     is no null terminator written into WTO.

     If the length of WFROM is less than SIZE, then `wcsncpy' copies
     all of WFROM, followed by enough null wide characters to add up to
     SIZE wide characters in all.  This behavior is rarely useful, but
     it is specified by the ISO C standard.

     The behavior of `wcsncpy' is undefined if the strings overlap.

     Using `wcsncpy' as opposed to `wcscpy' is a way to avoid bugs
     relating to writing past the end of the allocated space for WTO.
     However, it can also make your program much slower in one common
     case: copying a string which is probably small into a potentially
     large buffer.  In this case, SIZE may be large, and when it is,
     `wcsncpy' will waste a considerable amount of time copying null
     wide characters.

 -- Function: char * strdup (const char *S)
     This function copies the null-terminated string S into a newly
     allocated string.  The string is allocated using `malloc'; see
     *Note Unconstrained Allocation::.  If `malloc' cannot allocate
     space for the new string, `strdup' returns a null pointer.
     Otherwise it returns a pointer to the new string.

 -- Function: wchar_t * wcsdup (const wchar_t *WS)
     This function copies the null-terminated wide character string WS
     into a newly allocated string.  The string is allocated using
     `malloc'; see *Note Unconstrained Allocation::.  If `malloc'
     cannot allocate space for the new string, `wcsdup' returns a null
     pointer.  Otherwise it returns a pointer to the new wide character
     string.

     This function is a GNU extension.

 -- Function: char * strndup (const char *S, size_t SIZE)
     This function is similar to `strdup' but always copies at most
     SIZE characters into the newly allocated string.

     If the length of S is more than SIZE, then `strndup' copies just
     the first SIZE characters and adds a closing null terminator.
     Otherwise all characters are copied and the string is terminated.

     This function is different to `strncpy' in that it always
     terminates the destination string.

     `strndup' is a GNU extension.

 -- Function: char * stpcpy (char *restrict TO, const char *restrict
          FROM)
     This function is like `strcpy', except that it returns a pointer to
     the end of the string TO (that is, the address of the terminating
     null character `to + strlen (from)') rather than the beginning.

     For example, this program uses `stpcpy' to concatenate `foo' and
     `bar' to produce `foobar', which it then prints.

          #include <string.h>
          #include <stdio.h>

          int
          main (void)
          {
            char buffer[10];
            char *to = buffer;
            to = stpcpy (to, "foo");
            to = stpcpy (to, "bar");
            puts (buffer);
            return 0;
          }

     This function is not part of the ISO or POSIX standards, and is not
     customary on Unix systems, but we did not invent it either.
     Perhaps it comes from MS-DOG.

     Its behavior is undefined if the strings overlap.  The function is
     declared in `string.h'.

 -- Function: wchar_t * wcpcpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM)
     This function is like `wcscpy', except that it returns a pointer to
     the end of the string WTO (that is, the address of the terminating
     null character `wto + strlen (wfrom)') rather than the beginning.

     This function is not part of ISO or POSIX but was found useful
     while developing the GNU C Library itself.

     The behavior of `wcpcpy' is undefined if the strings overlap.

     `wcpcpy' is a GNU extension and is declared in `wchar.h'.

 -- Function: char * stpncpy (char *restrict TO, const char *restrict
          FROM, size_t SIZE)
     This function is similar to `stpcpy' but copies always exactly
     SIZE characters into TO.

     If the length of FROM is more then SIZE, then `stpncpy' copies
     just the first SIZE characters and returns a pointer to the
     character directly following the one which was copied last.  Note
     that in this case there is no null terminator written into TO.

     If the length of FROM is less than SIZE, then `stpncpy' copies all
     of FROM, followed by enough null characters to add up to SIZE
     characters in all.  This behavior is rarely useful, but it is
     implemented to be useful in contexts where this behavior of the
     `strncpy' is used.  `stpncpy' returns a pointer to the _first_
     written null character.

     This function is not part of ISO or POSIX but was found useful
     while developing the GNU C Library itself.

     Its behavior is undefined if the strings overlap.  The function is
     declared in `string.h'.

 -- Function: wchar_t * wcpncpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)
     This function is similar to `wcpcpy' but copies always exactly
     WSIZE characters into WTO.

     If the length of WFROM is more then SIZE, then `wcpncpy' copies
     just the first SIZE wide characters and returns a pointer to the
     wide character directly following the last non-null wide character
     which was copied last.  Note that in this case there is no null
     terminator written into WTO.

     If the length of WFROM is less than SIZE, then `wcpncpy' copies
     all of WFROM, followed by enough null characters to add up to SIZE
     characters in all.  This behavior is rarely useful, but it is
     implemented to be useful in contexts where this behavior of the
     `wcsncpy' is used.  `wcpncpy' returns a pointer to the _first_
     written null character.

     This function is not part of ISO or POSIX but was found useful
     while developing the GNU C Library itself.

     Its behavior is undefined if the strings overlap.

     `wcpncpy' is a GNU extension and is declared in `wchar.h'.

 -- Macro: char * strdupa (const char *S)
     This macro is similar to `strdup' but allocates the new string
     using `alloca' instead of `malloc' (*note Variable Size
     Automatic::).  This means of course the returned string has the
     same limitations as any block of memory allocated using `alloca'.

     For obvious reasons `strdupa' is implemented only as a macro; you
     cannot get the address of this function.  Despite this limitation
     it is a useful function.  The following code shows a situation
     where using `malloc' would be a lot more expensive.

          #include <paths.h>
          #include <string.h>
          #include <stdio.h>

          const char path[] = _PATH_STDPATH;

          int
          main (void)
          {
            char *wr_path = strdupa (path);
            char *cp = strtok (wr_path, ":");

            while (cp != NULL)
              {
                puts (cp);
                cp = strtok (NULL, ":");
              }
            return 0;
          }

     Please note that calling `strtok' using PATH directly is invalid.
     It is also not allowed to call `strdupa' in the argument list of
     `strtok' since `strdupa' uses `alloca' (*note Variable Size
     Automatic::) can interfere with the parameter passing.

     This function is only available if GNU CC is used.

 -- Macro: char * strndupa (const char *S, size_t SIZE)
     This function is similar to `strndup' but like `strdupa' it
     allocates the new string using `alloca' *note Variable Size
     Automatic::.  The same advantages and limitations of `strdupa' are
     valid for `strndupa', too.

     This function is implemented only as a macro, just like `strdupa'.
     Just as `strdupa' this macro also must not be used inside the
     parameter list in a function call.

     `strndupa' is only available if GNU CC is used.

 -- Function: char * strcat (char *restrict TO, const char *restrict
          FROM)
     The `strcat' function is similar to `strcpy', except that the
     characters from FROM are concatenated or appended to the end of
     TO, instead of overwriting it.  That is, the first character from
     FROM overwrites the null character marking the end of TO.

     An equivalent definition for `strcat' would be:

          char *
          strcat (char *restrict to, const char *restrict from)
          {
            strcpy (to + strlen (to), from);
            return to;
          }

     This function has undefined results if the strings overlap.

 -- Function: wchar_t * wcscat (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM)
     The `wcscat' function is similar to `wcscpy', except that the
     characters from WFROM are concatenated or appended to the end of
     WTO, instead of overwriting it.  That is, the first character from
     WFROM overwrites the null character marking the end of WTO.

     An equivalent definition for `wcscat' would be:

          wchar_t *
          wcscat (wchar_t *wto, const wchar_t *wfrom)
          {
            wcscpy (wto + wcslen (wto), wfrom);
            return wto;
          }

     This function has undefined results if the strings overlap.

   Programmers using the `strcat' or `wcscat' function (or the
following `strncat' or `wcsncar' functions for that matter) can easily
be recognized as lazy and reckless.  In almost all situations the
lengths of the participating strings are known (it better should be
since how can one otherwise ensure the allocated size of the buffer is
sufficient?)  Or at least, one could know them if one keeps track of the
results of the various function calls.  But then it is very inefficient
to use `strcat'/`wcscat'.  A lot of time is wasted finding the end of
the destination string so that the actual copying can start.  This is a
common example:

     /* This function concatenates arbitrarily many strings.  The last
        parameter must be `NULL'.  */
     char *
     concat (const char *str, ...)
     {
       va_list ap, ap2;
       size_t total = 1;
       const char *s;
       char *result;

       va_start (ap, str);
       /* Actually `va_copy', but this is the name more gcc versions
          understand.  */
       __va_copy (ap2, ap);

       /* Determine how much space we need.  */
       for (s = str; s != NULL; s = va_arg (ap, const char *))
         total += strlen (s);

       va_end (ap);

       result = (char *) malloc (total);
       if (result != NULL)
         {
           result[0] = '\0';

           /* Copy the strings.  */
           for (s = str; s != NULL; s = va_arg (ap2, const char *))
             strcat (result, s);
         }

       va_end (ap2);

       return result;
     }

   This looks quite simple, especially the second loop where the strings
are actually copied.  But these innocent lines hide a major performance
penalty.  Just imagine that ten strings of 100 bytes each have to be
concatenated.  For the second string we search the already stored 100
bytes for the end of the string so that we can append the next string.
For all strings in total the comparisons necessary to find the end of
the intermediate results sums up to 5500!  If we combine the copying
with the search for the allocation we can write this function more
efficient:

     char *
     concat (const char *str, ...)
     {
       va_list ap;
       size_t allocated = 100;
       char *result = (char *) malloc (allocated);

       if (result != NULL)
         {
           char *newp;
           char *wp;

           va_start (ap, str);

           wp = result;
           for (s = str; s != NULL; s = va_arg (ap, const char *))
             {
               size_t len = strlen (s);

               /* Resize the allocated memory if necessary.  */
               if (wp + len + 1 > result + allocated)
                 {
                   allocated = (allocated + len) * 2;
                   newp = (char *) realloc (result, allocated);
                   if (newp == NULL)
                     {
                       free (result);
                       return NULL;
                     }
                   wp = newp + (wp - result);
                   result = newp;
                 }

               wp = mempcpy (wp, s, len);
             }

           /* Terminate the result string.  */
           *wp++ = '\0';

           /* Resize memory to the optimal size.  */
           newp = realloc (result, wp - result);
           if (newp != NULL)
             result = newp;

           va_end (ap);
         }

       return result;
     }

   With a bit more knowledge about the input strings one could fine-tune
the memory allocation.  The difference we are pointing to here is that
we don't use `strcat' anymore.  We always keep track of the length of
the current intermediate result so we can safe us the search for the
end of the string and use `mempcpy'.  Please note that we also don't
use `stpcpy' which might seem more natural since we handle with
strings.  But this is not necessary since we already know the length of
the string and therefore can use the faster memory copying function.
The example would work for wide characters the same way.

   Whenever a programmer feels the need to use `strcat' she or he
should think twice and look through the program whether the code cannot
be rewritten to take advantage of already calculated results.  Again: it
is almost always unnecessary to use `strcat'.

 -- Function: char * strncat (char *restrict TO, const char *restrict
          FROM, size_t SIZE)
     This function is like `strcat' except that not more than SIZE
     characters from FROM are appended to the end of TO.  A single null
     character is also always appended to TO, so the total allocated
     size of TO must be at least `SIZE + 1' bytes longer than its
     initial length.

     The `strncat' function could be implemented like this:

          char *
          strncat (char *to, const char *from, size_t size)
          {
            to[strlen (to) + size] = '\0';
            strncpy (to + strlen (to), from, size);
            return to;
          }

     The behavior of `strncat' is undefined if the strings overlap.

 -- Function: wchar_t * wcsncat (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)
     This function is like `wcscat' except that not more than SIZE
     characters from FROM are appended to the end of TO.  A single null
     character is also always appended to TO, so the total allocated
     size of TO must be at least `SIZE + 1' bytes longer than its
     initial length.

     The `wcsncat' function could be implemented like this:

          wchar_t *
          wcsncat (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                   size_t size)
          {
            wto[wcslen (to) + size] = L'\0';
            wcsncpy (wto + wcslen (wto), wfrom, size);
            return wto;
          }

     The behavior of `wcsncat' is undefined if the strings overlap.

   Here is an example showing the use of `strncpy' and `strncat' (the
wide character version is equivalent).  Notice how, in the call to
`strncat', the SIZE parameter is computed to avoid overflowing the
character array `buffer'.

     #include <string.h>
     #include <stdio.h>

     #define SIZE 10

     static char buffer[SIZE];

     main ()
     {
       strncpy (buffer, "hello", SIZE);
       puts (buffer);
       strncat (buffer, ", world", SIZE - strlen (buffer) - 1);
       puts (buffer);
     }

The output produced by this program looks like:

     hello
     hello, wo

 -- Function: void bcopy (const void *FROM, void *TO, size_t SIZE)
     This is a partially obsolete alternative for `memmove', derived
     from BSD.  Note that it is not quite equivalent to `memmove',
     because the arguments are not in the same order and there is no
     return value.

 -- Function: void bzero (void *BLOCK, size_t SIZE)
     This is a partially obsolete alternative for `memset', derived from
     BSD.  Note that it is not as general as `memset', because the only
     value it can store is zero.


File: libc.info,  Node: String/Array Comparison,  Next: Collation Functions,  Prev: Copying and Concatenation,  Up: String and Array Utilities

5.5 String/Array Comparison
===========================

You can use the functions in this section to perform comparisons on the
contents of strings and arrays.  As well as checking for equality, these
functions can also be used as the ordering functions for sorting
operations.  *Note Searching and Sorting::, for an example of this.

   Unlike most comparison operations in C, the string comparison
functions return a nonzero value if the strings are _not_ equivalent
rather than if they are.  The sign of the value indicates the relative
ordering of the first characters in the strings that are not
equivalent:  a negative value indicates that the first string is "less"
than the second, while a positive value indicates that the first string
is "greater".

   The most common use of these functions is to check only for equality.
This is canonically done with an expression like `! strcmp (s1, s2)'.

   All of these functions are declared in the header file `string.h'.  

 -- Function: int memcmp (const void *A1, const void *A2, size_t SIZE)
     The function `memcmp' compares the SIZE bytes of memory beginning
     at A1 against the SIZE bytes of memory beginning at A2.  The value
     returned has the same sign as the difference between the first
     differing pair of bytes (interpreted as `unsigned char' objects,
     then promoted to `int').

     If the contents of the two blocks are equal, `memcmp' returns `0'.

 -- Function: int wmemcmp (const wchar_t *A1, const wchar_t *A2, size_t
          SIZE)
     The function `wmemcmp' compares the SIZE wide characters beginning
     at A1 against the SIZE wide characters beginning at A2.  The value
     returned is smaller than or larger than zero depending on whether
     the first differing wide character is A1 is smaller or larger than
     the corresponding character in A2.

     If the contents of the two blocks are equal, `wmemcmp' returns `0'.

   On arbitrary arrays, the `memcmp' function is mostly useful for
testing equality.  It usually isn't meaningful to do byte-wise ordering
comparisons on arrays of things other than bytes.  For example, a
byte-wise comparison on the bytes that make up floating-point numbers
isn't likely to tell you anything about the relationship between the
values of the floating-point numbers.

   `wmemcmp' is really only useful to compare arrays of type `wchar_t'
since the function looks at `sizeof (wchar_t)' bytes at a time and this
number of bytes is system dependent.

   You should also be careful about using `memcmp' to compare objects
that can contain "holes", such as the padding inserted into structure
objects to enforce alignment requirements, extra space at the end of
unions, and extra characters at the ends of strings whose length is less
than their allocated size.  The contents of these "holes" are
indeterminate and may cause strange behavior when performing byte-wise
comparisons.  For more predictable results, perform an explicit
component-wise comparison.

   For example, given a structure type definition like:

     struct foo
       {
         unsigned char tag;
         union
           {
             double f;
             long i;
             char *p;
           } value;
       };

you are better off writing a specialized comparison function to compare
`struct foo' objects instead of comparing them with `memcmp'.

 -- Function: int strcmp (const char *S1, const char *S2)
     The `strcmp' function compares the string S1 against S2, returning
     a value that has the same sign as the difference between the first
     differing pair of characters (interpreted as `unsigned char'
     objects, then promoted to `int').

     If the two strings are equal, `strcmp' returns `0'.

     A consequence of the ordering used by `strcmp' is that if S1 is an
     initial substring of S2, then S1 is considered to be "less than"
     S2.

     `strcmp' does not take sorting conventions of the language the
     strings are written in into account.  To get that one has to use
     `strcoll'.

 -- Function: int wcscmp (const wchar_t *WS1, const wchar_t *WS2)
     The `wcscmp' function compares the wide character string WS1
     against WS2.  The value returned is smaller than or larger than
     zero depending on whether the first differing wide character is
     WS1 is smaller or larger than the corresponding character in WS2.

     If the two strings are equal, `wcscmp' returns `0'.

     A consequence of the ordering used by `wcscmp' is that if WS1 is
     an initial substring of WS2, then WS1 is considered to be "less
     than" WS2.

     `wcscmp' does not take sorting conventions of the language the
     strings are written in into account.  To get that one has to use
     `wcscoll'.

 -- Function: int strcasecmp (const char *S1, const char *S2)
     This function is like `strcmp', except that differences in case are
     ignored.  How uppercase and lowercase characters are related is
     determined by the currently selected locale.  In the standard `"C"'
     locale the characters A" and a" do not match but in a locale which
     regards these characters as parts of the alphabet they do match.

     `strcasecmp' is derived from BSD.

 -- Function: int wcscasecmp (const wchar_t *WS1, const wchar_T *WS2)
     This function is like `wcscmp', except that differences in case are
     ignored.  How uppercase and lowercase characters are related is
     determined by the currently selected locale.  In the standard `"C"'
     locale the characters A" and a" do not match but in a locale which
     regards these characters as parts of the alphabet they do match.

     `wcscasecmp' is a GNU extension.

 -- Function: int strncmp (const char *S1, const char *S2, size_t SIZE)
     This function is the similar to `strcmp', except that no more than
     SIZE characters are compared.  In other words, if the two strings
     are the same in their first SIZE characters, the return value is
     zero.

 -- Function: int wcsncmp (const wchar_t *WS1, const wchar_t *WS2,
          size_t SIZE)
     This function is the similar to `wcscmp', except that no more than
     SIZE wide characters are compared.  In other words, if the two
     strings are the same in their first SIZE wide characters, the
     return value is zero.

 -- Function: int strncasecmp (const char *S1, const char *S2, size_t N)
     This function is like `strncmp', except that differences in case
     are ignored.  Like `strcasecmp', it is locale dependent how
     uppercase and lowercase characters are related.

     `strncasecmp' is a GNU extension.

 -- Function: int wcsncasecmp (const wchar_t *WS1, const wchar_t *S2,
          size_t N)
     This function is like `wcsncmp', except that differences in case
     are ignored.  Like `wcscasecmp', it is locale dependent how
     uppercase and lowercase characters are related.

     `wcsncasecmp' is a GNU extension.

   Here are some examples showing the use of `strcmp' and `strncmp'
(equivalent examples can be constructed for the wide character
functions).  These examples assume the use of the ASCII character set.
(If some other character set--say, EBCDIC--is used instead, then the
glyphs are associated with different numeric codes, and the return
values and ordering may differ.)

     strcmp ("hello", "hello")
         => 0    /* These two strings are the same. */
     strcmp ("hello", "Hello")
         => 32   /* Comparisons are case-sensitive. */
     strcmp ("hello", "world")
         => -15  /* The character `'h'' comes before `'w''. */
     strcmp ("hello", "hello, world")
         => -44  /* Comparing a null character against a comma. */
     strncmp ("hello", "hello, world", 5)
         => 0    /* The initial 5 characters are the same. */
     strncmp ("hello, world", "hello, stupid world!!!", 5)
         => 0    /* The initial 5 characters are the same. */

 -- Function: int strverscmp (const char *S1, const char *S2)
     The `strverscmp' function compares the string S1 against S2,
     considering them as holding indices/version numbers.  Return value
     follows the same conventions as found in the `strverscmp'
     function.  In fact, if S1 and S2 contain no digits, `strverscmp'
     behaves like `strcmp'.

     Basically, we compare strings normally (character by character),
     until we find a digit in each string - then we enter a special
     comparison mode, where each sequence of digits is taken as a
     whole.  If we reach the end of these two parts without noticing a
     difference, we return to the standard comparison mode.  There are
     two types of numeric parts: "integral" and "fractional" (those
     begin with a '0'). The types of the numeric parts affect the way
     we sort them:

        * integral/integral: we compare values as you would expect.

        * fractional/integral: the fractional part is less than the
          integral one.  Again, no surprise.

        * fractional/fractional: the things become a bit more complex.
          If the common prefix contains only leading zeroes, the
          longest part is less than the other one; else the comparison
          behaves normally.

          strverscmp ("no digit", "no digit")
              => 0    /* same behavior as strcmp. */
          strverscmp ("item#99", "item#100")
              => <0   /* same prefix, but 99 < 100. */
          strverscmp ("alpha1", "alpha001")
              => >0   /* fractional part inferior to integral one. */
          strverscmp ("part1_f012", "part1_f01")
              => >0   /* two fractional parts. */
          strverscmp ("foo.009", "foo.0")
              => <0   /* idem, but with leading zeroes only. */

     This function is especially useful when dealing with filename
     sorting, because filenames frequently hold indices/version numbers.

     `strverscmp' is a GNU extension.

 -- Function: int bcmp (const void *A1, const void *A2, size_t SIZE)
     This is an obsolete alias for `memcmp', derived from BSD.


File: libc.info,  Node: Collation Functions,  Next: Search Functions,  Prev: String/Array Comparison,  Up: String and Array Utilities

5.6 Collation Functions
=======================

In some locales, the conventions for lexicographic ordering differ from
the strict numeric ordering of character codes.  For example, in Spanish
most glyphs with diacritical marks such as accents are not considered
distinct letters for the purposes of collation.  On the other hand, the
two-character sequence `ll' is treated as a single letter that is
collated immediately after `l'.

   You can use the functions `strcoll' and `strxfrm' (declared in the
headers file `string.h') and `wcscoll' and `wcsxfrm' (declared in the
headers file `wchar') to compare strings using a collation ordering
appropriate for the current locale.  The locale used by these functions
in particular can be specified by setting the locale for the
`LC_COLLATE' category; see *Note Locales::.  

   In the standard C locale, the collation sequence for `strcoll' is
the same as that for `strcmp'.  Similarly, `wcscoll' and `wcscmp' are
the same in this situation.

   Effectively, the way these functions work is by applying a mapping to
transform the characters in a string to a byte sequence that represents
the string's position in the collating sequence of the current locale.
Comparing two such byte sequences in a simple fashion is equivalent to
comparing the strings with the locale's collating sequence.

   The functions `strcoll' and `wcscoll' perform this translation
implicitly, in order to do one comparison.  By contrast, `strxfrm' and
`wcsxfrm' perform the mapping explicitly.  If you are making multiple
comparisons using the same string or set of strings, it is likely to be
more efficient to use `strxfrm' or `wcsxfrm' to transform all the
strings just once, and subsequently compare the transformed strings
with `strcmp' or `wcscmp'.

 -- Function: int strcoll (const char *S1, const char *S2)
     The `strcoll' function is similar to `strcmp' but uses the
     collating sequence of the current locale for collation (the
     `LC_COLLATE' locale).

 -- Function: int wcscoll (const wchar_t *WS1, const wchar_t *WS2)
     The `wcscoll' function is similar to `wcscmp' but uses the
     collating sequence of the current locale for collation (the
     `LC_COLLATE' locale).

   Here is an example of sorting an array of strings, using `strcoll'
to compare them.  The actual sort algorithm is not written here; it
comes from `qsort' (*note Array Sort Function::).  The job of the code
shown here is to say how to compare the strings while sorting them.
(Later on in this section, we will show a way to do this more
efficiently using `strxfrm'.)

     /* This is the comparison function used with `qsort'. */

     int
     compare_elements (char **p1, char **p2)
     {
       return strcoll (*p1, *p2);
     }

     /* This is the entry point--the function to sort
        strings using the locale's collating sequence. */

     void
     sort_strings (char **array, int nstrings)
     {
       /* Sort `temp_array' by comparing the strings. */
       qsort (array, nstrings,
              sizeof (char *), compare_elements);
     }

 -- Function: size_t strxfrm (char *restrict TO, const char *restrict
          FROM, size_t SIZE)
     The function `strxfrm' transforms the string FROM using the
     collation transformation determined by the locale currently
     selected for collation, and stores the transformed string in the
     array TO.  Up to SIZE characters (including a terminating null
     character) are stored.

     The behavior is undefined if the strings TO and FROM overlap; see
     *Note Copying and Concatenation::.

     The return value is the length of the entire transformed string.
     This value is not affected by the value of SIZE, but if it is
     greater or equal than SIZE, it means that the transformed string
     did not entirely fit in the array TO.  In this case, only as much
     of the string as actually fits was stored.  To get the whole
     transformed string, call `strxfrm' again with a bigger output
     array.

     The transformed string may be longer than the original string, and
     it may also be shorter.

     If SIZE is zero, no characters are stored in TO.  In this case,
     `strxfrm' simply returns the number of characters that would be
     the length of the transformed string.  This is useful for
     determining what size the allocated array should be.  It does not
     matter what TO is if SIZE is zero; TO may even be a null pointer.

 -- Function: size_t wcsxfrm (wchar_t *restrict WTO, const wchar_t
          *WFROM, size_t SIZE)
     The function `wcsxfrm' transforms wide character string WFROM
     using the collation transformation determined by the locale
     currently selected for collation, and stores the transformed
     string in the array WTO.  Up to SIZE wide characters (including a
     terminating null character) are stored.

     The behavior is undefined if the strings WTO and WFROM overlap;
     see *Note Copying and Concatenation::.

     The return value is the length of the entire transformed wide
     character string.  This value is not affected by the value of
     SIZE, but if it is greater or equal than SIZE, it means that the
     transformed wide character string did not entirely fit in the
     array WTO.  In this case, only as much of the wide character
     string as actually fits was stored.  To get the whole transformed
     wide character string, call `wcsxfrm' again with a bigger output
     array.

     The transformed wide character string may be longer than the
     original wide character string, and it may also be shorter.

     If SIZE is zero, no characters are stored in TO.  In this case,
     `wcsxfrm' simply returns the number of wide characters that would
     be the length of the transformed wide character string.  This is
     useful for determining what size the allocated array should be
     (remember to multiply with `sizeof (wchar_t)').  It does not
     matter what WTO is if SIZE is zero; WTO may even be a null pointer.

   Here is an example of how you can use `strxfrm' when you plan to do
many comparisons.  It does the same thing as the previous example, but
much faster, because it has to transform each string only once, no
matter how many times it is compared with other strings.  Even the time
needed to allocate and free storage is much less than the time we save,
when there are many strings.

     struct sorter { char *input; char *transformed; };

     /* This is the comparison function used with `qsort'
        to sort an array of `struct sorter'. */

     int
     compare_elements (struct sorter *p1, struct sorter *p2)
     {
       return strcmp (p1->transformed, p2->transformed);
     }

     /* This is the entry point--the function to sort
        strings using the locale's collating sequence. */

     void
     sort_strings_fast (char **array, int nstrings)
     {
       struct sorter temp_array[nstrings];
       int i;

       /* Set up `temp_array'.  Each element contains
          one input string and its transformed string. */
       for (i = 0; i < nstrings; i++)
         {
           size_t length = strlen (array[i]) * 2;
           char *transformed;
           size_t transformed_length;

           temp_array[i].input = array[i];

           /* First try a buffer perhaps big enough.  */
           transformed = (char *) xmalloc (length);

           /* Transform `array[i]'.  */
           transformed_length = strxfrm (transformed, array[i], length);

           /* If the buffer was not large enough, resize it
              and try again.  */
           if (transformed_length >= length)
             {
               /* Allocate the needed space. +1 for terminating
                  `NUL' character.  */
               transformed = (char *) xrealloc (transformed,
                                                transformed_length + 1);

               /* The return value is not interesting because we know
                  how long the transformed string is.  */
               (void) strxfrm (transformed, array[i],
                               transformed_length + 1);
             }

           temp_array[i].transformed = transformed;
         }

       /* Sort `temp_array' by comparing transformed strings. */
       qsort (temp_array, sizeof (struct sorter),
              nstrings, compare_elements);

       /* Put the elements back in the permanent array
          in their sorted order. */
       for (i = 0; i < nstrings; i++)
         array[i] = temp_array[i].input;

       /* Free the strings we allocated. */
       for (i = 0; i < nstrings; i++)
         free (temp_array[i].transformed);
     }

   The interesting part of this code for the wide character version
would look like this:

     void
     sort_strings_fast (wchar_t **array, int nstrings)
     {
       ...
           /* Transform `array[i]'.  */
           transformed_length = wcsxfrm (transformed, array[i], length);

           /* If the buffer was not large enough, resize it
              and try again.  */
           if (transformed_length >= length)
             {
               /* Allocate the needed space. +1 for terminating
                  `NUL' character.  */
               transformed = (wchar_t *) xrealloc (transformed,
                                                   (transformed_length + 1)
                                                   * sizeof (wchar_t));

               /* The return value is not interesting because we know
                  how long the transformed string is.  */
               (void) wcsxfrm (transformed, array[i],
                               transformed_length + 1);
             }
       ...

Note the additional multiplication with `sizeof (wchar_t)' in the
`realloc' call.

   *Compatibility Note:* The string collation functions are a new
feature of ISO C90.  Older C dialects have no equivalent feature.  The
wide character versions were introduced in Amendment 1 to ISO C90.


File: libc.info,  Node: Search Functions,  Next: Finding Tokens in a String,  Prev: Collation Functions,  Up: String and Array Utilities

5.7 Search Functions
====================

This section describes library functions which perform various kinds of
searching operations on strings and arrays.  These functions are
declared in the header file `string.h'.  

 -- Function: void * memchr (const void *BLOCK, int C, size_t SIZE)
     This function finds the first occurrence of the byte C (converted
     to an `unsigned char') in the initial SIZE bytes of the object
     beginning at BLOCK.  The return value is a pointer to the located
     byte, or a null pointer if no match was found.

 -- Function: wchar_t * wmemchr (const wchar_t *BLOCK, wchar_t WC,
          size_t SIZE)
     This function finds the first occurrence of the wide character WC
     in the initial SIZE wide characters of the object beginning at
     BLOCK.  The return value is a pointer to the located wide
     character, or a null pointer if no match was found.

 -- Function: void * rawmemchr (const void *BLOCK, int C)
     Often the `memchr' function is used with the knowledge that the
     byte C is available in the memory block specified by the
     parameters.  But this means that the SIZE parameter is not really
     needed and that the tests performed with it at runtime (to check
     whether the end of the block is reached) are not needed.

     The `rawmemchr' function exists for just this situation which is
     surprisingly frequent.  The interface is similar to `memchr' except
     that the SIZE parameter is missing.  The function will look beyond
     the end of the block pointed to by BLOCK in case the programmer
     made an error in assuming that the byte C is present in the block.
     In this case the result is unspecified.  Otherwise the return
     value is a pointer to the located byte.

     This function is of special interest when looking for the end of a
     string.  Since all strings are terminated by a null byte a call
     like

             rawmemchr (str, '\0')

     will never go beyond the end of the string.

     This function is a GNU extension.

 -- Function: void * memrchr (const void *BLOCK, int C, size_t SIZE)
     The function `memrchr' is like `memchr', except that it searches
     backwards from the end of the block defined by BLOCK and SIZE
     (instead of forwards from the front).

     This function is a GNU extension.

 -- Function: char * strchr (const char *STRING, int C)
     The `strchr' function finds the first occurrence of the character
     C (converted to a `char') in the null-terminated string beginning
     at STRING.  The return value is a pointer to the located
     character, or a null pointer if no match was found.

     For example,
          strchr ("hello, world", 'l')
              => "llo, world"
          strchr ("hello, world", '?')
              => NULL

     The terminating null character is considered to be part of the
     string, so you can use this function get a pointer to the end of a
     string by specifying a null character as the value of the C
     argument.  It would be better (but less portable) to use
     `strchrnul' in this case, though.

 -- Function: wchar_t * wcschr (const wchar_t *WSTRING, int WC)
     The `wcschr' function finds the first occurrence of the wide
     character WC in the null-terminated wide character string
     beginning at WSTRING.  The return value is a pointer to the
     located wide character, or a null pointer if no match was found.

     The terminating null character is considered to be part of the wide
     character string, so you can use this function get a pointer to
     the end of a wide character string by specifying a null wude
     character as the value of the WC argument.  It would be better
     (but less portable) to use `wcschrnul' in this case, though.

 -- Function: char * strchrnul (const char *STRING, int C)
     `strchrnul' is the same as `strchr' except that if it does not
     find the character, it returns a pointer to string's terminating
     null character rather than a null pointer.

     This function is a GNU extension.

 -- Function: wchar_t * wcschrnul (const wchar_t *WSTRING, wchar_t WC)
     `wcschrnul' is the same as `wcschr' except that if it does not
     find the wide character, it returns a pointer to wide character
     string's terminating null wide character rather than a null
     pointer.

     This function is a GNU extension.

   One useful, but unusual, use of the `strchr' function is when one
wants to have a pointer pointing to the NUL byte terminating a string.
This is often written in this way:

       s += strlen (s);

This is almost optimal but the addition operation duplicated a bit of
the work already done in the `strlen' function.  A better solution is
this:

       s = strchr (s, '\0');

   There is no restriction on the second parameter of `strchr' so it
could very well also be the NUL character.  Those readers thinking very
hard about this might now point out that the `strchr' function is more
expensive than the `strlen' function since we have two abort criteria.
This is right.  But in the GNU C library the implementation of `strchr'
is optimized in a special way so that `strchr' actually is faster.

 -- Function: char * strrchr (const char *STRING, int C)
     The function `strrchr' is like `strchr', except that it searches
     backwards from the end of the string STRING (instead of forwards
     from the front).

     For example,
          strrchr ("hello, world", 'l')
              => "ld"

 -- Function: wchar_t * wcsrchr (const wchar_t *WSTRING, wchar_t C)
     The function `wcsrchr' is like `wcschr', except that it searches
     backwards from the end of the string WSTRING (instead of forwards
     from the front).

 -- Function: char * strstr (const char *HAYSTACK, const char *NEEDLE)
     This is like `strchr', except that it searches HAYSTACK for a
     substring NEEDLE rather than just a single character.  It returns
     a pointer into the string HAYSTACK that is the first character of
     the substring, or a null pointer if no match was found.  If NEEDLE
     is an empty string, the function returns HAYSTACK.

     For example,
          strstr ("hello, world", "l")
              => "llo, world"
          strstr ("hello, world", "wo")
              => "world"

 -- Function: wchar_t * wcsstr (const wchar_t *HAYSTACK, const wchar_t
          *NEEDLE)
     This is like `wcschr', except that it searches HAYSTACK for a
     substring NEEDLE rather than just a single wide character.  It
     returns a pointer into the string HAYSTACK that is the first wide
     character of the substring, or a null pointer if no match was
     found.  If NEEDLE is an empty string, the function returns
     HAYSTACK.

 -- Function: wchar_t * wcswcs (const wchar_t *HAYSTACK, const wchar_t
          *NEEDLE)
     `wcswcs' is an deprecated alias for `wcsstr'.  This is the name
     originally used in the X/Open Portability Guide before the
     Amendment 1 to ISO C90 was published.

 -- Function: char * strcasestr (const char *HAYSTACK, const char
          *NEEDLE)
     This is like `strstr', except that it ignores case in searching for
     the substring.   Like `strcasecmp', it is locale dependent how
     uppercase and lowercase characters are related.

     For example,
          strcasestr ("hello, world", "L")
              => "llo, world"
          strcasestr ("hello, World", "wo")
              => "World"

 -- Function: void * memmem (const void *HAYSTACK, size_t HAYSTACK-LEN,
          const void *NEEDLE, size_t NEEDLE-LEN)
     This is like `strstr', but NEEDLE and HAYSTACK are byte arrays
     rather than null-terminated strings.  NEEDLE-LEN is the length of
     NEEDLE and HAYSTACK-LEN is the length of HAYSTACK.

     This function is a GNU extension.

 -- Function: size_t strspn (const char *STRING, const char *SKIPSET)
     The `strspn' ("string span") function returns the length of the
     initial substring of STRING that consists entirely of characters
     that are members of the set specified by the string SKIPSET.  The
     order of the characters in SKIPSET is not important.

     For example,
          strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")
              => 5

     Note that "character" is here used in the sense of byte.  In a
     string using a multibyte character encoding (abstract) character
     consisting of more than one byte are not treated as an entity.
     Each byte is treated separately.  The function is not
     locale-dependent.

 -- Function: size_t wcsspn (const wchar_t *WSTRING, const wchar_t
          *SKIPSET)
     The `wcsspn' ("wide character string span") function returns the
     length of the initial substring of WSTRING that consists entirely
     of wide characters that are members of the set specified by the
     string SKIPSET.  The order of the wide characters in SKIPSET is not
     important.

 -- Function: size_t strcspn (const char *STRING, const char *STOPSET)
     The `strcspn' ("string complement span") function returns the
     length of the initial substring of STRING that consists entirely
     of characters that are _not_ members of the set specified by the
     string STOPSET.  (In other words, it returns the offset of the
     first character in STRING that is a member of the set STOPSET.)

     For example,
          strcspn ("hello, world", " \t\n,.;!?")
              => 5

     Note that "character" is here used in the sense of byte.  In a
     string using a multibyte character encoding (abstract) character
     consisting of more than one byte are not treated as an entity.
     Each byte is treated separately.  The function is not
     locale-dependent.

 -- Function: size_t wcscspn (const wchar_t *WSTRING, const wchar_t
          *STOPSET)
     The `wcscspn' ("wide character string complement span") function
     returns the length of the initial substring of WSTRING that
     consists entirely of wide characters that are _not_ members of the
     set specified by the string STOPSET.  (In other words, it returns
     the offset of the first character in STRING that is a member of
     the set STOPSET.)

 -- Function: char * strpbrk (const char *STRING, const char *STOPSET)
     The `strpbrk' ("string pointer break") function is related to
     `strcspn', except that it returns a pointer to the first character
     in STRING that is a member of the set STOPSET instead of the
     length of the initial substring.  It returns a null pointer if no
     such character from STOPSET is found.

     For example,

          strpbrk ("hello, world", " \t\n,.;!?")
              => ", world"

     Note that "character" is here used in the sense of byte.  In a
     string using a multibyte character encoding (abstract) character
     consisting of more than one byte are not treated as an entity.
     Each byte is treated separately.  The function is not
     locale-dependent.

 -- Function: wchar_t * wcspbrk (const wchar_t *WSTRING, const wchar_t
          *STOPSET)
     The `wcspbrk' ("wide character string pointer break") function is
     related to `wcscspn', except that it returns a pointer to the first
     wide character in WSTRING that is a member of the set STOPSET
     instead of the length of the initial substring.  It returns a null
     pointer if no such character from STOPSET is found.

5.7.1 Compatibility String Search Functions
-------------------------------------------

 -- Function: char * index (const char *STRING, int C)
     `index' is another name for `strchr'; they are exactly the same.
     New code should always use `strchr' since this name is defined in
     ISO C while `index' is a BSD invention which never was available
     on System V derived systems.

 -- Function: char * rindex (const char *STRING, int C)
     `rindex' is another name for `strrchr'; they are exactly the same.
     New code should always use `strrchr' since this name is defined in
     ISO C while `rindex' is a BSD invention which never was available
     on System V derived systems.


File: libc.info,  Node: Finding Tokens in a String,  Next: strfry,  Prev: Search Functions,  Up: String and Array Utilities

5.8 Finding Tokens in a String
==============================

It's fairly common for programs to have a need to do some simple kinds
of lexical analysis and parsing, such as splitting a command string up
into tokens.  You can do this with the `strtok' function, declared in
the header file `string.h'.  

 -- Function: char * strtok (char *restrict NEWSTRING, const char
          *restrict DELIMITERS)
     A string can be split into tokens by making a series of calls to
     the function `strtok'.

     The string to be split up is passed as the NEWSTRING argument on
     the first call only.  The `strtok' function uses this to set up
     some internal state information.  Subsequent calls to get
     additional tokens from the same string are indicated by passing a
     null pointer as the NEWSTRING argument.  Calling `strtok' with
     another non-null NEWSTRING argument reinitializes the state
     information.  It is guaranteed that no other library function ever
     calls `strtok' behind your back (which would mess up this internal
     state information).

     The DELIMITERS argument is a string that specifies a set of
     delimiters that may surround the token being extracted.  All the
     initial characters that are members of this set are discarded.
     The first character that is _not_ a member of this set of
     delimiters marks the beginning of the next token.  The end of the
     token is found by looking for the next character that is a member
     of the delimiter set.  This character in the original string
     NEWSTRING is overwritten by a null character, and the pointer to
     the beginning of the token in NEWSTRING is returned.

     On the next call to `strtok', the searching begins at the next
     character beyond the one that marked the end of the previous token.
     Note that the set of delimiters DELIMITERS do not have to be the
     same on every call in a series of calls to `strtok'.

     If the end of the string NEWSTRING is reached, or if the remainder
     of string consists only of delimiter characters, `strtok' returns
     a null pointer.

     Note that "character" is here used in the sense of byte.  In a
     string using a multibyte character encoding (abstract) character
     consisting of more than one byte are not treated as an entity.
     Each byte is treated separately.  The function is not
     locale-dependent.

 -- Function: wchar_t * wcstok (wchar_t *NEWSTRING, const char
          *DELIMITERS)
     A string can be split into tokens by making a series of calls to
     the function `wcstok'.

     The string to be split up is passed as the NEWSTRING argument on
     the first call only.  The `wcstok' function uses this to set up
     some internal state information.  Subsequent calls to get
     additional tokens from the same wide character string are
     indicated by passing a null pointer as the NEWSTRING argument.
     Calling `wcstok' with another non-null NEWSTRING argument
     reinitializes the state information.  It is guaranteed that no
     other library function ever calls `wcstok' behind your back (which
     would mess up this internal state information).

     The DELIMITERS argument is a wide character string that specifies
     a set of delimiters that may surround the token being extracted.
     All the initial wide characters that are members of this set are
     discarded.  The first wide character that is _not_ a member of
     this set of delimiters marks the beginning of the next token.  The
     end of the token is found by looking for the next wide character
     that is a member of the delimiter set.  This wide character in the
     original wide character string NEWSTRING is overwritten by a null
     wide character, and the pointer to the beginning of the token in
     NEWSTRING is returned.

     On the next call to `wcstok', the searching begins at the next
     wide character beyond the one that marked the end of the previous
     token.  Note that the set of delimiters DELIMITERS do not have to
     be the same on every call in a series of calls to `wcstok'.

     If the end of the wide character string NEWSTRING is reached, or
     if the remainder of string consists only of delimiter wide
     characters, `wcstok' returns a null pointer.

     Note that "character" is here used in the sense of byte.  In a
     string using a multibyte character encoding (abstract) character
     consisting of more than one byte are not treated as an entity.
     Each byte is treated separately.  The function is not
     locale-dependent.

   *Warning:* Since `strtok' and `wcstok' alter the string they is
parsing, you should always copy the string to a temporary buffer before
parsing it with `strtok'/`wcstok' (*note Copying and Concatenation::).
If you allow `strtok' or `wcstok' to modify a string that came from
another part of your program, you are asking for trouble; that string
might be used for other purposes after `strtok' or `wcstok' has
modified it, and it would not have the expected value.

   The string that you are operating on might even be a constant.  Then
when `strtok' or `wcstok' tries to modify it, your program will get a
fatal signal for writing in read-only memory.  *Note Program Error
Signals::.  Even if the operation of `strtok' or `wcstok' would not
require a modification of the string (e.g., if there is exactly one
token) the string can (and in the GNU libc case will) be modified.

   This is a special case of a general principle: if a part of a program
does not have as its purpose the modification of a certain data
structure, then it is error-prone to modify the data structure
temporarily.

   The functions `strtok' and `wcstok' are not reentrant.  *Note
Nonreentrancy::, for a discussion of where and why reentrancy is
important.

   Here is a simple example showing the use of `strtok'.

     #include <string.h>
     #include <stddef.h>

     ...

     const char string[] = "words separated by spaces -- and, punctuation!";
     const char delimiters[] = " .,;:!-";
     char *token, *cp;

     ...

     cp = strdupa (string);                /* Make writable copy.  */
     token = strtok (cp, delimiters);      /* token => "words" */
     token = strtok (NULL, delimiters);    /* token => "separated" */
     token = strtok (NULL, delimiters);    /* token => "by" */
     token = strtok (NULL, delimiters);    /* token => "spaces" */
     token = strtok (NULL, delimiters);    /* token => "and" */
     token = strtok (NULL, delimiters);    /* token => "punctuation" */
     token = strtok (NULL, delimiters);    /* token => NULL */

   The GNU C library contains two more functions for tokenizing a string
which overcome the limitation of non-reentrancy.  They are only
available for multibyte character strings.

 -- Function: char * strtok_r (char *NEWSTRING, const char *DELIMITERS,
          char **SAVE_PTR)
     Just like `strtok', this function splits the string into several
     tokens which can be accessed by successive calls to `strtok_r'.
     The difference is that the information about the next token is
     stored in the space pointed to by the third argument, SAVE_PTR,
     which is a pointer to a string pointer.  Calling `strtok_r' with a
     null pointer for NEWSTRING and leaving SAVE_PTR between the calls
     unchanged does the job without hindering reentrancy.

     This function is defined in POSIX.1 and can be found on many
     systems which support multi-threading.

 -- Function: char * strsep (char **STRING_PTR, const char *DELIMITER)
     This function has a similar functionality as `strtok_r' with the
     NEWSTRING argument replaced by the SAVE_PTR argument.  The
     initialization of the moving pointer has to be done by the user.
     Successive calls to `strsep' move the pointer along the tokens
     separated by DELIMITER, returning the address of the next token
     and updating STRING_PTR to point to the beginning of the next
     token.

     One difference between `strsep' and `strtok_r' is that if the
     input string contains more than one character from DELIMITER in a
     row `strsep' returns an empty string for each pair of characters
     from DELIMITER.  This means that a program normally should test
     for `strsep' returning an empty string before processing it.

     This function was introduced in 4.3BSD and therefore is widely
     available.

   Here is how the above example looks like when `strsep' is used.

     #include <string.h>
     #include <stddef.h>

     ...

     const char string[] = "words separated by spaces -- and, punctuation!";
     const char delimiters[] = " .,;:!-";
     char *running;
     char *token;

     ...

     running = strdupa (string);
     token = strsep (&running, delimiters);    /* token => "words" */
     token = strsep (&running, delimiters);    /* token => "separated" */
     token = strsep (&running, delimiters);    /* token => "by" */
     token = strsep (&running, delimiters);    /* token => "spaces" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "and" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "punctuation" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => NULL */

 -- Function: char * basename (const char *FILENAME)
     The GNU version of the `basename' function returns the last
     component of the path in FILENAME.  This function is the preferred
     usage, since it does not modify the argument, FILENAME, and
     respects trailing slashes.  The prototype for `basename' can be
     found in `string.h'.  Note, this function is overriden by the XPG
     version, if `libgen.h' is included.

     Example of using GNU `basename':

          #include <string.h>

          int
          main (int argc, char *argv[])
          {
            char *prog = basename (argv[0]);

            if (argc < 2)
              {
                fprintf (stderr, "Usage %s <arg>\n", prog);
                exit (1);
              }

            ...
          }

     *Portability Note:* This function may produce different results on
     different systems.


 -- Function: char * basename (char *PATH)
     This is the standard XPG defined `basename'. It is similar in
     spirit to the GNU version, but may modify the PATH by removing
     trailing '/' characters.  If the PATH is made up entirely of '/'
     characters, then "/" will be returned.  Also, if PATH is `NULL' or
     an empty string, then "." is returned.  The prototype for the XPG
     version can be found in `libgen.h'.

     Example of using XPG `basename':

          #include <libgen.h>

          int
          main (int argc, char *argv[])
          {
            char *prog;
            char *path = strdupa (argv[0]);

            prog = basename (path);

            if (argc < 2)
              {
                fprintf (stderr, "Usage %s <arg>\n", prog);
                exit (1);
              }

            ...

          }

 -- Function: char * dirname (char *PATH)
     The `dirname' function is the compliment to the XPG version of
     `basename'.  It returns the parent directory of the file specified
     by PATH.  If PATH is `NULL', an empty string, or contains no '/'
     characters, then "." is returned.  The prototype for this function
     can be found in `libgen.h'.


File: libc.info,  Node: strfry,  Next: Trivial Encryption,  Prev: Finding Tokens in a String,  Up: String and Array Utilities

5.9 strfry
==========

The function below addresses the perennial programming quandary: "How do
I take good data in string form and painlessly turn it into garbage?"
This is actually a fairly simple task for C programmers who do not use
the GNU C library string functions, but for programs based on the GNU C
library, the `strfry' function is the preferred method for destroying
string data.

   The prototype for this function is in `string.h'.

 -- Function: char * strfry (char *STRING)
     `strfry' creates a pseudorandom anagram of a string, replacing the
     input with the anagram in place.  For each position in the string,
     `strfry' swaps it with a position in the string selected at random
     (from a uniform distribution).  The two positions may be the same.

     The return value of `strfry' is always STRING.

     *Portability Note:*  This function is unique to the GNU C library.



File: libc.info,  Node: Trivial Encryption,  Next: Encode Binary Data,  Prev: strfry,  Up: String and Array Utilities

5.10 Trivial Encryption
=======================

The `memfrob' function converts an array of data to something
unrecognizable and back again.  It is not encryption in its usual sense
since it is easy for someone to convert the encrypted data back to clear
text.  The transformation is analogous to Usenet's "Rot13" encryption
method for obscuring offensive jokes from sensitive eyes and such.
Unlike Rot13, `memfrob' works on arbitrary binary data, not just text.  

   For true encryption, *Note Cryptographic Functions::.

   This function is declared in `string.h'.  

 -- Function: void * memfrob (void *MEM, size_t LENGTH)
     `memfrob' transforms (frobnicates) each byte of the data structure
     at MEM, which is LENGTH bytes long, by bitwise exclusive oring it
     with binary 00101010.  It does the transformation in place and its
     return value is always MEM.

     Note that `memfrob' a second time on the same data structure
     returns it to its original state.

     This is a good function for hiding information from someone who
     doesn't want to see it or doesn't want to see it very much.  To
     really prevent people from retrieving the information, use
     stronger encryption such as that described in *Note Cryptographic
     Functions::.

     *Portability Note:*  This function is unique to the GNU C library.



File: libc.info,  Node: Encode Binary Data,  Next: Argz and Envz Vectors,  Prev: Trivial Encryption,  Up: String and Array Utilities

5.11 Encode Binary Data
=======================

To store or transfer binary data in environments which only support text
one has to encode the binary data by mapping the input bytes to
characters in the range allowed for storing or transfering.  SVID
systems (and nowadays XPG compliant systems) provide minimal support for
this task.

 -- Function: char * l64a (long int N)
     This function encodes a 32-bit input value using characters from
     the basic character set.  It returns a pointer to a 7 character
     buffer which contains an encoded version of N.  To encode a series
     of bytes the user must copy the returned string to a destination
     buffer.  It returns the empty string if N is zero, which is
     somewhat bizarre but mandated by the standard.
     *Warning:* Since a static buffer is used this function should not
     be used in multi-threaded programs.  There is no thread-safe
     alternative to this function in the C library.
     *Compatibility Note:* The XPG standard states that the return
     value of `l64a' is undefined if N is negative.  In the GNU
     implementation, `l64a' treats its argument as unsigned, so it will
     return a sensible encoding for any nonzero N; however, portable
     programs should not rely on this.

     To encode a large buffer `l64a' must be called in a loop, once for
     each 32-bit word of the buffer.  For example, one could do
     something like this:

          char *
          encode (const void *buf, size_t len)
          {
            /* We know in advance how long the buffer has to be. */
            unsigned char *in = (unsigned char *) buf;
            char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);
            char *cp = out, *p;

            /* Encode the length. */
            /* Using `htonl' is necessary so that the data can be
               decoded even on machines with different byte order.
               `l64a' can return a string shorter than 6 bytes, so
               we pad it with encoding of 0 ('.') at the end by
               hand. */

            p = stpcpy (cp, l64a (htonl (len)));
            cp = mempcpy (p, "......", 6 - (p - cp));

            while (len > 3)
              {
                unsigned long int n = *in++;
                n = (n << 8) | *in++;
                n = (n << 8) | *in++;
                n = (n << 8) | *in++;
                len -= 4;
                p = stpcpy (cp, l64a (htonl (n)));
                cp = mempcpy (p, "......", 6 - (p - cp));
              }
            if (len > 0)
              {
                unsigned long int n = *in++;
                if (--len > 0)
                  {
                    n = (n << 8) | *in++;
                    if (--len > 0)
                      n = (n << 8) | *in;
                  }
                cp = stpcpy (cp, l64a (htonl (n)));
              }
            *cp = '\0';
            return out;
          }

     It is strange that the library does not provide the complete
     functionality needed but so be it.


   To decode data produced with `l64a' the following function should be
used.

 -- Function: long int a64l (const char *STRING)
     The parameter STRING should contain a string which was produced by
     a call to `l64a'.  The function processes at least 6 characters of
     this string, and decodes the characters it finds according to the
     table below.  It stops decoding when it finds a character not in
     the table, rather like `atoi'; if you have a buffer which has been
     broken into lines, you must be careful to skip over the
     end-of-line characters.

     The decoded number is returned as a `long int' value.

   The `l64a' and `a64l' functions use a base 64 encoding, in which
each character of an encoded string represents six bits of an input
word.  These symbols are used for the base 64 digits:

        0     1     2     3     4     5     6     7
0       `.'   `/'   `0'   `1'   `2'   `3'   `4'   `5'
8       `6'   `7'   `8'   `9'   `A'   `B'   `C'   `D'
16      `E'   `F'   `G'   `H'   `I'   `J'   `K'   `L'
24      `M'   `N'   `O'   `P'   `Q'   `R'   `S'   `T'
32      `U'   `V'   `W'   `X'   `Y'   `Z'   `a'   `b'
40      `c'   `d'   `e'   `f'   `g'   `h'   `i'   `j'
48      `k'   `l'   `m'   `n'   `o'   `p'   `q'   `r'
56      `s'   `t'   `u'   `v'   `w'   `x'   `y'   `z'

   This encoding scheme is not standard.  There are some other encoding
methods which are much more widely used (UU encoding, MIME encoding).
Generally, it is better to use one of these encodings.


File: libc.info,  Node: Argz and Envz Vectors,  Prev: Encode Binary Data,  Up: String and Array Utilities

5.12 Argz and Envz Vectors
==========================

"argz vectors" are vectors of strings in a contiguous block of memory,
each element separated from its neighbors by null-characters (`'\0'').

   "Envz vectors" are an extension of argz vectors where each element
is a name-value pair, separated by a `'='' character (as in a Unix
environment).

* Menu:

* Argz Functions::              Operations on argz vectors.
* Envz Functions::              Additional operations on environment vectors.


File: libc.info,  Node: Argz Functions,  Next: Envz Functions,  Up: Argz and Envz Vectors

5.12.1 Argz Functions
---------------------

Each argz vector is represented by a pointer to the first element, of
type `char *', and a size, of type `size_t', both of which can be
initialized to `0' to represent an empty argz vector.  All argz
functions accept either a pointer and a size argument, or pointers to
them, if they will be modified.

   The argz functions use `malloc'/`realloc' to allocate/grow argz
vectors, and so any argz vector creating using these functions may be
freed by using `free'; conversely, any argz function that may grow a
string expects that string to have been allocated using `malloc' (those
argz functions that only examine their arguments or modify them in
place will work on any sort of memory).  *Note Unconstrained
Allocation::.

   All argz functions that do memory allocation have a return type of
`error_t', and return `0' for success, and `ENOMEM' if an allocation
error occurs.

   These functions are declared in the standard include file `argz.h'.

 -- Function: error_t argz_create (char *const ARGV[], char **ARGZ,
          size_t *ARGZ_LEN)
     The `argz_create' function converts the Unix-style argument vector
     ARGV (a vector of pointers to normal C strings, terminated by
     `(char *)0'; *note Program Arguments::) into an argz vector with
     the same elements, which is returned in ARGZ and ARGZ_LEN.

 -- Function: error_t argz_create_sep (const char *STRING, int SEP,
          char **ARGZ, size_t *ARGZ_LEN)
     The `argz_create_sep' function converts the null-terminated string
     STRING into an argz vector (returned in ARGZ and ARGZ_LEN) by
     splitting it into elements at every occurrence of the character
     SEP.

 -- Function: size_t argz_count (const char *ARGZ, size_t ARG_LEN)
     Returns the number of elements in the argz vector ARGZ and
     ARGZ_LEN.

 -- Function: void argz_extract (char *ARGZ, size_t ARGZ_LEN, char
          **ARGV)
     The `argz_extract' function converts the argz vector ARGZ and
     ARGZ_LEN into a Unix-style argument vector stored in ARGV, by
     putting pointers to every element in ARGZ into successive
     positions in ARGV, followed by a terminator of `0'.  ARGV must be
     pre-allocated with enough space to hold all the elements in ARGZ
     plus the terminating `(char *)0' (`(argz_count (ARGZ, ARGZ_LEN) +
     1) * sizeof (char *)' bytes should be enough).  Note that the
     string pointers stored into ARGV point into ARGZ--they are not
     copies--and so ARGZ must be copied if it will be changed while
     ARGV is still active.  This function is useful for passing the
     elements in ARGZ to an exec function (*note Executing a File::).

 -- Function: void argz_stringify (char *ARGZ, size_t LEN, int SEP)
     The `argz_stringify' converts ARGZ into a normal string with the
     elements separated by the character SEP, by replacing each `'\0''
     inside ARGZ (except the last one, which terminates the string)
     with SEP.  This is handy for printing ARGZ in a readable manner.

 -- Function: error_t argz_add (char **ARGZ, size_t *ARGZ_LEN, const
          char *STR)
     The `argz_add' function adds the string STR to the end of the argz
     vector `*ARGZ', and updates `*ARGZ' and `*ARGZ_LEN' accordingly.

 -- Function: error_t argz_add_sep (char **ARGZ, size_t *ARGZ_LEN,
          const char *STR, int DELIM)
     The `argz_add_sep' function is similar to `argz_add', but STR is
     split into separate elements in the result at occurrences of the
     character DELIM.  This is useful, for instance, for adding the
     components of a Unix search path to an argz vector, by using a
     value of `':'' for DELIM.

 -- Function: error_t argz_append (char **ARGZ, size_t *ARGZ_LEN, const
          char *BUF, size_t BUF_LEN)
     The `argz_append' function appends BUF_LEN bytes starting at BUF
     to the argz vector `*ARGZ', reallocating `*ARGZ' to accommodate
     it, and adding BUF_LEN to `*ARGZ_LEN'.

 -- Function: void argz_delete (char **ARGZ, size_t *ARGZ_LEN, char
          *ENTRY)
     If ENTRY points to the beginning of one of the elements in the
     argz vector `*ARGZ', the `argz_delete' function will remove this
     entry and reallocate `*ARGZ', modifying `*ARGZ' and `*ARGZ_LEN'
     accordingly.  Note that as destructive argz functions usually
     reallocate their argz argument, pointers into argz vectors such as
     ENTRY will then become invalid.

 -- Function: error_t argz_insert (char **ARGZ, size_t *ARGZ_LEN, char
          *BEFORE, const char *ENTRY)
     The `argz_insert' function inserts the string ENTRY into the argz
     vector `*ARGZ' at a point just before the existing element pointed
     to by BEFORE, reallocating `*ARGZ' and updating `*ARGZ' and
     `*ARGZ_LEN'.  If BEFORE is `0', ENTRY is added to the end instead
     (as if by `argz_add').  Since the first element is in fact the
     same as `*ARGZ', passing in `*ARGZ' as the value of BEFORE will
     result in ENTRY being inserted at the beginning.

 -- Function: char * argz_next (char *ARGZ, size_t ARGZ_LEN, const char
          *ENTRY)
     The `argz_next' function provides a convenient way of iterating
     over the elements in the argz vector ARGZ.  It returns a pointer
     to the next element in ARGZ after the element ENTRY, or `0' if
     there are no elements following ENTRY.  If ENTRY is `0', the first
     element of ARGZ is returned.

     This behavior suggests two styles of iteration:

              char *entry = 0;
              while ((entry = argz_next (ARGZ, ARGZ_LEN, entry)))
                ACTION;

     (the double parentheses are necessary to make some C compilers
     shut up about what they consider a questionable `while'-test) and:

              char *entry;
              for (entry = ARGZ;
                   entry;
                   entry = argz_next (ARGZ, ARGZ_LEN, entry))
                ACTION;

     Note that the latter depends on ARGZ having a value of `0' if it
     is empty (rather than a pointer to an empty block of memory); this
     invariant is maintained for argz vectors created by the functions
     here.

 -- Function: error_t argz_replace (char **ARGZ, size_t *ARGZ_LEN,
          const char *STR, const char *WITH, unsigned *REPLACE_COUNT)
     Replace any occurrences of the string STR in ARGZ with WITH,
     reallocating ARGZ as necessary.  If REPLACE_COUNT is non-zero,
     `*REPLACE_COUNT' will be incremented by number of replacements
     performed.


File: libc.info,  Node: Envz Functions,  Prev: Argz Functions,  Up: Argz and Envz Vectors

5.12.2 Envz Functions
---------------------

Envz vectors are just argz vectors with additional constraints on the
form of each element; as such, argz functions can also be used on them,
where it makes sense.

   Each element in an envz vector is a name-value pair, separated by a
`'='' character; if multiple `'='' characters are present in an
element, those after the first are considered part of the value, and
treated like all other non-`'\0'' characters.

   If _no_ `'='' characters are present in an element, that element is
considered the name of a "null" entry, as distinct from an entry with an
empty value: `envz_get' will return `0' if given the name of null
entry, whereas an entry with an empty value would result in a value of
`""'; `envz_entry' will still find such entries, however.  Null entries
can be removed with `envz_strip' function.

   As with argz functions, envz functions that may allocate memory (and
thus fail) have a return type of `error_t', and return either `0' or
`ENOMEM'.

   These functions are declared in the standard include file `envz.h'.

 -- Function: char * envz_entry (const char *ENVZ, size_t ENVZ_LEN,
          const char *NAME)
     The `envz_entry' function finds the entry in ENVZ with the name
     NAME, and returns a pointer to the whole entry--that is, the argz
     element which begins with NAME followed by a `'='' character.  If
     there is no entry with that name, `0' is returned.

 -- Function: char * envz_get (const char *ENVZ, size_t ENVZ_LEN, const
          char *NAME)
     The `envz_get' function finds the entry in ENVZ with the name NAME
     (like `envz_entry'), and returns a pointer to the value portion of
     that entry (following the `'='').  If there is no entry with that
     name (or only a null entry), `0' is returned.

 -- Function: error_t envz_add (char **ENVZ, size_t *ENVZ_LEN, const
          char *NAME, const char *VALUE)
     The `envz_add' function adds an entry to `*ENVZ' (updating `*ENVZ'
     and `*ENVZ_LEN') with the name NAME, and value VALUE.  If an entry
     with the same name already exists in ENVZ, it is removed first.
     If VALUE is `0', then the new entry will the special null type of
     entry (mentioned above).

 -- Function: error_t envz_merge (char **ENVZ, size_t *ENVZ_LEN, const
          char *ENVZ2, size_t ENVZ2_LEN, int OVERRIDE)
     The `envz_merge' function adds each entry in ENVZ2 to ENVZ, as if
     with `envz_add', updating `*ENVZ' and `*ENVZ_LEN'.  If OVERRIDE is
     true, then values in ENVZ2 will supersede those with the same name
     in ENVZ, otherwise not.

     Null entries are treated just like other entries in this respect,
     so a null entry in ENVZ can prevent an entry of the same name in
     ENVZ2 from being added to ENVZ, if OVERRIDE is false.

 -- Function: void envz_strip (char **ENVZ, size_t *ENVZ_LEN)
     The `envz_strip' function removes any null entries from ENVZ,
     updating `*ENVZ' and `*ENVZ_LEN'.


File: libc.info,  Node: Character Set Handling,  Next: Locales,  Prev: String and Array Utilities,  Up: Top

6 Character Set Handling
************************

Character sets used in the early days of computing had only six, seven,
or eight bits for each character: there was never a case where more than
eight bits (one byte) were used to represent a single character.  The
limitations of this approach became more apparent as more people
grappled with non-Roman character sets, where not all the characters
that make up a language's character set can be represented by 2^8
choices.  This chapter shows the functionality that was added to the C
library to support multiple character sets.

* Menu:

* Extended Char Intro::              Introduction to Extended Characters.
* Charset Function Overview::        Overview about Character Handling
                                      Functions.
* Restartable multibyte conversion:: Restartable multibyte conversion
                                      Functions.
* Non-reentrant Conversion::         Non-reentrant Conversion Function.
* Generic Charset Conversion::       Generic Charset Conversion.


File: libc.info,  Node: Extended Char Intro,  Next: Charset Function Overview,  Up: Character Set Handling

6.1 Introduction to Extended Characters
=======================================

A variety of solutions is available to overcome the differences between
character sets with a 1:1 relation between bytes and characters and
character sets with ratios of 2:1 or 4:1.  The remainder of this
section gives a few examples to help understand the design decisions
made while developing the functionality of the C library.

   A distinction we have to make right away is between internal and
external representation.  "Internal representation" means the
representation used by a program while keeping the text in memory.
External representations are used when text is stored or transmitted
through some communication channel.  Examples of external
representations include files waiting in a directory to be read and
parsed.

   Traditionally there has been no difference between the two
representations.  It was equally comfortable and useful to use the same
single-byte representation internally and externally.  This comfort
level decreases with more and larger character sets.

   One of the problems to overcome with the internal representation is
handling text that is externally encoded using different character
sets.  Assume a program that reads two texts and compares them using
some metric.  The comparison can be usefully done only if the texts are
internally kept in a common format.

   For such a common format (= character set) eight bits are certainly
no longer enough.  So the smallest entity will have to grow: "wide
characters" will now be used.  Instead of one byte per character, two or
four will be used instead.  (Three are not good to address in memory and
more than four bytes seem not to be necessary).

   As shown in some other part of this manual, a completely new family
has been created of functions that can handle wide character texts in
memory.  The most commonly used character sets for such internal wide
character representations are Unicode and ISO 10646 (also known as UCS
for Universal Character Set).  Unicode was originally planned as a
16-bit character set; whereas, ISO 10646 was designed to be a 31-bit
large code space.  The two standards are practically identical.  They
have the same character repertoire and code table, but Unicode specifies
added semantics.  At the moment, only characters in the first `0x10000'
code positions (the so-called Basic Multilingual Plane, BMP) have been
assigned, but the assignment of more specialized characters outside this
16-bit space is already in progress.  A number of encodings have been
defined for Unicode and ISO 10646 characters: UCS-2 is a 16-bit word
that can only represent characters from the BMP, UCS-4 is a 32-bit word
than can represent any Unicode and ISO 10646 character, UTF-8 is an
ASCII compatible encoding where ASCII characters are represented by
ASCII bytes and non-ASCII characters by sequences of 2-6 non-ASCII
bytes, and finally UTF-16 is an extension of UCS-2 in which pairs of
certain UCS-2 words can be used to encode non-BMP characters up to
`0x10ffff'.

   To represent wide characters the `char' type is not suitable.  For
this reason the ISO C standard introduces a new type that is designed
to keep one character of a wide character string.  To maintain the
similarity there is also a type corresponding to `int' for those
functions that take a single wide character.

 -- Data type: wchar_t
     This data type is used as the base type for wide character strings.
     In other words, arrays of objects of this type are the equivalent
     of `char[]' for multibyte character strings.  The type is defined
     in `stddef.h'.

     The ISO C90 standard, where `wchar_t' was introduced, does not say
     anything specific about the representation.  It only requires that
     this type is capable of storing all elements of the basic
     character set.  Therefore it would be legitimate to define
     `wchar_t' as `char', which might make sense for embedded systems.

     But for GNU systems `wchar_t' is always 32 bits wide and,
     therefore, capable of representing all UCS-4 values and,
     therefore, covering all of ISO 10646.  Some Unix systems define
     `wchar_t' as a 16-bit type and thereby follow Unicode very
     strictly.  This definition is perfectly fine with the standard,
     but it also means that to represent all characters from Unicode
     and ISO 10646 one has to use UTF-16 surrogate characters, which is
     in fact a multi-wide-character encoding.  But resorting to
     multi-wide-character encoding contradicts the purpose of the
     `wchar_t' type.

 -- Data type: wint_t
     `wint_t' is a data type used for parameters and variables that
     contain a single wide character.  As the name suggests this type
     is the equivalent of `int' when using the normal `char' strings.
     The types `wchar_t' and `wint_t' often have the same
     representation if their size is 32 bits wide but if `wchar_t' is
     defined as `char' the type `wint_t' must be defined as `int' due
     to the parameter promotion.

     This type is defined in `wchar.h' and was introduced in
     Amendment 1 to ISO C90.

   As there are for the `char' data type macros are available for
specifying the minimum and maximum value representable in an object of
type `wchar_t'.

 -- Macro: wint_t WCHAR_MIN
     The macro `WCHAR_MIN' evaluates to the minimum value representable
     by an object of type `wint_t'.

     This macro was introduced in Amendment 1 to ISO C90.

 -- Macro: wint_t WCHAR_MAX
     The macro `WCHAR_MAX' evaluates to the maximum value representable
     by an object of type `wint_t'.

     This macro was introduced in Amendment 1 to ISO C90.

   Another special wide character value is the equivalent to `EOF'.

 -- Macro: wint_t WEOF
     The macro `WEOF' evaluates to a constant expression of type
     `wint_t' whose value is different from any member of the extended
     character set.

     `WEOF' need not be the same value as `EOF' and unlike `EOF' it
     also need _not_ be negative.  In other words, sloppy code like

          {
            int c;
            ...
            while ((c = getc (fp)) < 0)
              ...
          }

     has to be rewritten to use `WEOF' explicitly when wide characters
     are used:

          {
            wint_t c;
            ...
            while ((c = wgetc (fp)) != WEOF)
              ...
          }

     This macro was introduced in Amendment 1 to ISO C90 and is defined
     in `wchar.h'.

   These internal representations present problems when it comes to
storing and transmittal.  Because each single wide character consists
of more than one byte, they are effected by byte-ordering.  Thus,
machines with different endianesses would see different values when
accessing the same data.  This byte ordering concern also applies for
communication protocols that are all byte-based and therefore require
that the sender has to decide about splitting the wide character in
bytes.  A last (but not least important) point is that wide characters
often require more storage space than a customized byte-oriented
character set.

   For all the above reasons, an external encoding that is different
from the internal encoding is often used if the latter is UCS-2 or
UCS-4.  The external encoding is byte-based and can be chosen
appropriately for the environment and for the texts to be handled.  A
variety of different character sets can be used for this external
encoding (information that will not be exhaustively presented
here-instead, a description of the major groups will suffice).  All of
the ASCII-based character sets fulfill one requirement: they are
"filesystem safe."  This means that the character `'/'' is used in the
encoding _only_ to represent itself.  Things are a bit different for
character sets like EBCDIC (Extended Binary Coded Decimal Interchange
Code, a character set family used by IBM), but if the operation system
does not understand EBCDIC directly the parameters-to-system calls have
to be converted first anyhow.

   * The simplest character sets are single-byte character sets.  There
     can be only up to 256 characters (for 8 bit character sets), which
     is not sufficient to cover all languages but might be sufficient
     to handle a specific text.  Handling of a 8 bit character sets is
     simple.  This is not true for other kinds presented later, and
     therefore, the application one uses might require the use of 8 bit
     character sets.

   * The ISO 2022 standard defines a mechanism for extended character
     sets where one character _can_ be represented by more than one
     byte.  This is achieved by associating a state with the text.
     Characters that can be used to change the state can be embedded in
     the text.  Each byte in the text might have a different
     interpretation in each state.  The state might even influence
     whether a given byte stands for a character on its own or whether
     it has to be combined with some more bytes.

     In most uses of ISO 2022 the defined character sets do not allow
     state changes that cover more than the next character.  This has
     the big advantage that whenever one can identify the beginning of
     the byte sequence of a character one can interpret a text
     correctly.  Examples of character sets using this policy are the
     various EUC character sets (used by Sun's operations systems,
     EUC-JP, EUC-KR, EUC-TW, and EUC-CN) or Shift_JIS (SJIS, a Japanese
     encoding).

     But there are also character sets using a state that is valid for
     more than one character and has to be changed by another byte
     sequence.  Examples for this are ISO-2022-JP, ISO-2022-KR, and
     ISO-2022-CN.

   * Early attempts to fix 8 bit character sets for other languages
     using the Roman alphabet lead to character sets like ISO 6937.
     Here bytes representing characters like the acute accent do not
     produce output themselves: one has to combine them with other
     characters to get the desired result.  For example, the byte
     sequence `0xc2 0x61' (non-spacing acute accent, followed by
     lower-case `a') to get the "small a with  acute" character.  To
     get the acute accent character on its own, one has to write `0xc2
     0x20' (the non-spacing acute followed by a space).

     Character sets like ISO 6937 are used in some embedded systems such
     as teletex.

   * Instead of converting the Unicode or ISO 10646 text used
     internally, it is often also sufficient to simply use an encoding
     different than UCS-2/UCS-4.  The Unicode and ISO 10646 standards
     even specify such an encoding: UTF-8.  This encoding is able to
     represent all of ISO 10646 31 bits in a byte string of length one
     to six.

     There were a few other attempts to encode ISO 10646 such as UTF-7,
     but UTF-8 is today the only encoding that should be used.  In
     fact, with any luck UTF-8 will soon be the only external encoding
     that has to be supported.  It proves to be universally usable and
     its only disadvantage is that it favors Roman languages by making
     the byte string representation of other scripts (Cyrillic, Greek,
     Asian scripts) longer than necessary if using a specific character
     set for these scripts.  Methods like the Unicode compression
     scheme can alleviate these problems.

   The question remaining is: how to select the character set or
encoding to use.  The answer: you cannot decide about it yourself, it
is decided by the developers of the system or the majority of the
users.  Since the goal is interoperability one has to use whatever the
other people one works with use.  If there are no constraints, the
selection is based on the requirements the expected circle of users
will have.  In other words, if a project is expected to be used in
only, say, Russia it is fine to use KOI8-R or a similar character set.
But if at the same time people from, say, Greece are participating one
should use a character set that allows all people to collaborate.

   The most widely useful solution seems to be: go with the most general
character set, namely ISO 10646.  Use UTF-8 as the external encoding
and problems about users not being able to use their own language
adequately are a thing of the past.

   One final comment about the choice of the wide character
representation is necessary at this point.  We have said above that the
natural choice is using Unicode or ISO 10646.  This is not required,
but at least encouraged, by the ISO C standard.  The standard defines
at least a macro `__STDC_ISO_10646__' that is only defined on systems
where the `wchar_t' type encodes ISO 10646 characters.  If this symbol
is not defined one should avoid making assumptions about the wide
character representation.  If the programmer uses only the functions
provided by the C library to handle wide character strings there should
be no compatibility problems with other systems.


File: libc.info,  Node: Charset Function Overview,  Next: Restartable multibyte conversion,  Prev: Extended Char Intro,  Up: Character Set Handling

6.2 Overview about Character Handling Functions
===============================================

A Unix C library contains three different sets of functions in two
families to handle character set conversion.  One of the function
families (the most commonly used) is specified in the ISO C90 standard
and, therefore, is portable even beyond the Unix world.  Unfortunately
this family is the least useful one.  These functions should be avoided
whenever possible, especially when developing libraries (as opposed to
applications).

   The second family of functions got introduced in the early Unix
standards (XPG2) and is still part of the latest and greatest Unix
standard: Unix 98.  It is also the most powerful and useful set of
functions.  But we will start with the functions defined in Amendment 1
to ISO C90.


File: libc.info,  Node: Restartable multibyte conversion,  Next: Non-reentrant Conversion,  Prev: Charset Function Overview,  Up: Character Set Handling

6.3 Restartable Multibyte Conversion Functions
==============================================

The ISO C standard defines functions to convert strings from a
multibyte representation to wide character strings.  There are a number
of peculiarities:

   * The character set assumed for the multibyte encoding is not
     specified as an argument to the functions.  Instead the character
     set specified by the `LC_CTYPE' category of the current locale is
     used; see *Note Locale Categories::.

   * The functions handling more than one character at a time require
     NUL terminated strings as the argument (i.e., converting blocks of
     text does not work unless one can add a NUL byte at an appropriate
     place).  The GNU C library contains some extensions to the
     standard that allow specifying a size, but basically they also
     expect terminated strings.

   Despite these limitations the ISO C functions can be used in many
contexts.  In graphical user interfaces, for instance, it is not
uncommon to have functions that require text to be displayed in a wide
character string if the text is not simple ASCII.  The text itself might
come from a file with translations and the user should decide about the
current locale, which determines the translation and therefore also the
external encoding used.  In such a situation (and many others) the
functions described here are perfect.  If more freedom while performing
the conversion is necessary take a look at the `iconv' functions (*note
Generic Charset Conversion::).

* Menu:

* Selecting the Conversion::     Selecting the conversion and its properties.
* Keeping the state::            Representing the state of the conversion.
* Converting a Character::       Converting Single Characters.
* Converting Strings::           Converting Multibyte and Wide Character
                                  Strings.
* Multibyte Conversion Example:: A Complete Multibyte Conversion Example.


File: libc.info,  Node: Selecting the Conversion,  Next: Keeping the state,  Up: Restartable multibyte conversion

6.3.1 Selecting the conversion and its properties
-------------------------------------------------

We already said above that the currently selected locale for the
`LC_CTYPE' category decides about the conversion that is performed by
the functions we are about to describe.  Each locale uses its own
character set (given as an argument to `localedef') and this is the one
assumed as the external multibyte encoding.  The wide character set is
always UCS-4, at least on GNU systems.

   A characteristic of each multibyte character set is the maximum
number of bytes that can be necessary to represent one character.  This
information is quite important when writing code that uses the
conversion functions (as shown in the examples below).  The ISO C
standard defines two macros that provide this information.

 -- Macro: int MB_LEN_MAX
     `MB_LEN_MAX' specifies the maximum number of bytes in the multibyte
     sequence for a single character in any of the supported locales.
     It is a compile-time constant and is defined in `limits.h'.  

 -- Macro: int MB_CUR_MAX
     `MB_CUR_MAX' expands into a positive integer expression that is the
     maximum number of bytes in a multibyte character in the current
     locale.  The value is never greater than `MB_LEN_MAX'.  Unlike
     `MB_LEN_MAX' this macro need not be a compile-time constant, and in
     the GNU C library it is not.

     `MB_CUR_MAX' is defined in `stdlib.h'.

   Two different macros are necessary since strictly ISO C90 compilers
do not allow variable length array definitions, but still it is
desirable to avoid dynamic allocation.  This incomplete piece of code
shows the problem:

     {
       char buf[MB_LEN_MAX];
       ssize_t len = 0;

       while (! feof (fp))
         {
           fread (&buf[len], 1, MB_CUR_MAX - len, fp);
           /* ... process buf */
           len -= used;
         }
     }

   The code in the inner loop is expected to have always enough bytes in
the array BUF to convert one multibyte character.  The array BUF has to
be sized statically since many compilers do not allow a variable size.
The `fread' call makes sure that `MB_CUR_MAX' bytes are always
available in BUF.  Note that it isn't a problem if `MB_CUR_MAX' is not
a compile-time constant.


File: libc.info,  Node: Keeping the state,  Next: Converting a Character,  Prev: Selecting the Conversion,  Up: Restartable multibyte conversion

6.3.2 Representing the state of the conversion
----------------------------------------------

In the introduction of this chapter it was said that certain character
sets use a "stateful" encoding.  That is, the encoded values depend in
some way on the previous bytes in the text.

   Since the conversion functions allow converting a text in more than
one step we must have a way to pass this information from one call of
the functions to another.

 -- Data type: mbstate_t
     A variable of type `mbstate_t' can contain all the information
     about the "shift state" needed from one call to a conversion
     function to another.

     `mbstate_t' is defined in `wchar.h'.  It was introduced in
     Amendment 1 to ISO C90.

   To use objects of type `mbstate_t' the programmer has to define such
objects (normally as local variables on the stack) and pass a pointer to
the object to the conversion functions.  This way the conversion
function can update the object if the current multibyte character set
is stateful.

   There is no specific function or initializer to put the state object
in any specific state.  The rules are that the object should always
represent the initial state before the first use, and this is achieved
by clearing the whole variable with code such as follows:

     {
       mbstate_t state;
       memset (&state, '\0', sizeof (state));
       /* from now on STATE can be used.  */
       ...
     }

   When using the conversion functions to generate output it is often
necessary to test whether the current state corresponds to the initial
state.  This is necessary, for example, to decide whether to emit
escape sequences to set the state to the initial state at certain
sequence points.  Communication protocols often require this.

 -- Function: int mbsinit (const mbstate_t *PS)
     The `mbsinit' function determines whether the state object pointed
     to by PS is in the initial state.  If PS is a null pointer or the
     object is in the initial state the return value is nonzero.
     Otherwise it is zero.

     `mbsinit' was introduced in Amendment 1 to ISO C90 and is declared
     in `wchar.h'.

   Code using `mbsinit' often looks similar to this:

     {
       mbstate_t state;
       memset (&state, '\0', sizeof (state));
       /* Use STATE.  */
       ...
       if (! mbsinit (&state))
         {
           /* Emit code to return to initial state.  */
           const wchar_t empty[] = L"";
           const wchar_t *srcp = empty;
           wcsrtombs (outbuf, &srcp, outbuflen, &state);
         }
       ...
     }

   The code to emit the escape sequence to get back to the initial
state is interesting.  The `wcsrtombs' function can be used to
determine the necessary output code (*note Converting Strings::).
Please note that on GNU systems it is not necessary to perform this
extra action for the conversion from multibyte text to wide character
text since the wide character encoding is not stateful.  But there is
nothing mentioned in any standard that prohibits making `wchar_t' using
a stateful encoding.


File: libc.info,  Node: Converting a Character,  Next: Converting Strings,  Prev: Keeping the state,  Up: Restartable multibyte conversion

6.3.3 Converting Single Characters
----------------------------------

The most fundamental of the conversion functions are those dealing with
single characters.  Please note that this does not always mean single
bytes.  But since there is very often a subset of the multibyte
character set that consists of single byte sequences, there are
functions to help with converting bytes.  Frequently, ASCII is a subpart
of the multibyte character set.  In such a scenario, each ASCII
character stands for itself, and all other characters have at least a
first byte that is beyond the range 0 to 127.

 -- Function: wint_t btowc (int C)
     The `btowc' function ("byte to wide character") converts a valid
     single byte character C in the initial shift state into the wide
     character equivalent using the conversion rules from the currently
     selected locale of the `LC_CTYPE' category.

     If `(unsigned char) C' is no valid single byte multibyte character
     or if C is `EOF', the function returns `WEOF'.

     Please note the restriction of C being tested for validity only in
     the initial shift state.  No `mbstate_t' object is used from which
     the state information is taken, and the function also does not use
     any static state.

     The `btowc' function was introduced in Amendment 1 to ISO C90 and
     is declared in `wchar.h'.

   Despite the limitation that the single byte value is always
interpreted in the initial state, this function is actually useful most
of the time.  Most characters are either entirely single-byte character
sets or they are extension to ASCII.  But then it is possible to write
code like this (not that this specific example is very useful):

     wchar_t *
     itow (unsigned long int val)
     {
       static wchar_t buf[30];
       wchar_t *wcp = &buf[29];
       *wcp = L'\0';
       while (val != 0)
         {
           *--wcp = btowc ('0' + val % 10);
           val /= 10;
         }
       if (wcp == &buf[29])
         *--wcp = L'0';
       return wcp;
     }

   Why is it necessary to use such a complicated implementation and not
simply cast `'0' + val % 10' to a wide character?  The answer is that
there is no guarantee that one can perform this kind of arithmetic on
the character of the character set used for `wchar_t' representation.
In other situations the bytes are not constant at compile time and so
the compiler cannot do the work.  In situations like this, using
`btowc' is required.

There is also a function for the conversion in the other direction.

 -- Function: int wctob (wint_t C)
     The `wctob' function ("wide character to byte") takes as the
     parameter a valid wide character.  If the multibyte representation
     for this character in the initial state is exactly one byte long,
     the return value of this function is this character.  Otherwise
     the return value is `EOF'.

     `wctob' was introduced in Amendment 1 to ISO C90 and is declared
     in `wchar.h'.

   There are more general functions to convert single character from
multibyte representation to wide characters and vice versa.  These
functions pose no limit on the length of the multibyte representation
and they also do not require it to be in the initial state.

 -- Function: size_t mbrtowc (wchar_t *restrict PWC, const char
          *restrict S, size_t N, mbstate_t *restrict PS)
     The `mbrtowc' function ("multibyte restartable to wide character")
     converts the next multibyte character in the string pointed to by
     S into a wide character and stores it in the wide character string
     pointed to by PWC.  The conversion is performed according to the
     locale currently selected for the `LC_CTYPE' category.  If the
     conversion for the character set used in the locale requires a
     state, the multibyte string is interpreted in the state
     represented by the object pointed to by PS.  If PS is a null
     pointer, a static, internal state variable used only by the
     `mbrtowc' function is used.

     If the next multibyte character corresponds to the NUL wide
     character, the return value of the function is 0 and the state
     object is afterwards in the initial state.  If the next N or fewer
     bytes form a correct multibyte character, the return value is the
     number of bytes starting from S that form the multibyte character.
     The conversion state is updated according to the bytes consumed
     in the conversion.  In both cases the wide character (either the
     `L'\0'' or the one found in the conversion) is stored in the
     string pointed to by PWC if PWC is not null.

     If the first N bytes of the multibyte string possibly form a valid
     multibyte character but there are more than N bytes needed to
     complete it, the return value of the function is `(size_t) -2' and
     no value is stored.  Please note that this can happen even if N
     has a value greater than or equal to `MB_CUR_MAX' since the input
     might contain redundant shift sequences.

     If the first `n' bytes of the multibyte string cannot possibly form
     a valid multibyte character, no value is stored, the global
     variable `errno' is set to the value `EILSEQ', and the function
     returns `(size_t) -1'.  The conversion state is afterwards
     undefined.

     `mbrtowc' was introduced in Amendment 1 to ISO C90 and is declared
     in `wchar.h'.

   Use of `mbrtowc' is straightforward.  A function that copies a
multibyte string into a wide character string while at the same time
converting all lowercase characters into uppercase could look like this
(this is not the final version, just an example; it has no error
checking, and sometimes leaks memory):

     wchar_t *
     mbstouwcs (const char *s)
     {
       size_t len = strlen (s);
       wchar_t *result = malloc ((len + 1) * sizeof (wchar_t));
       wchar_t *wcp = result;
       wchar_t tmp[1];
       mbstate_t state;
       size_t nbytes;

       memset (&state, '\0', sizeof (state));
       while ((nbytes = mbrtowc (tmp, s, len, &state)) > 0)
         {
           if (nbytes >= (size_t) -2)
             /* Invalid input string.  */
             return NULL;
           *wcp++ = towupper (tmp[0]);
           len -= nbytes;
           s += nbytes;
         }
       return result;
     }

   The use of `mbrtowc' should be clear.  A single wide character is
stored in `TMP[0]', and the number of consumed bytes is stored in the
variable NBYTES.  If the conversion is successful, the uppercase
variant of the wide character is stored in the RESULT array and the
pointer to the input string and the number of available bytes is
adjusted.

   The only non-obvious thing about `mbrtowc' might be the way memory
is allocated for the result.  The above code uses the fact that there
can never be more wide characters in the converted results than there
are bytes in the multibyte input string.  This method yields a
pessimistic guess about the size of the result, and if many wide
character strings have to be constructed this way or if the strings are
long, the extra memory required to be allocated because the input
string contains multibyte characters might be significant.  The
allocated memory block can be resized to the correct size before
returning it, but a better solution might be to allocate just the right
amount of space for the result right away.  Unfortunately there is no
function to compute the length of the wide character string directly
from the multibyte string.  There is, however, a function that does
part of the work.

 -- Function: size_t mbrlen (const char *restrict S, size_t N,
          mbstate_t *PS)
     The `mbrlen' function ("multibyte restartable length") computes
     the number of at most N bytes starting at S, which form the next
     valid and complete multibyte character.

     If the next multibyte character corresponds to the NUL wide
     character, the return value is 0.  If the next N bytes form a valid
     multibyte character, the number of bytes belonging to this
     multibyte character byte sequence is returned.

     If the first N bytes possibly form a valid multibyte character but
     the character is incomplete, the return value is `(size_t) -2'.
     Otherwise the multibyte character sequence is invalid and the
     return value is `(size_t) -1'.

     The multibyte sequence is interpreted in the state represented by
     the object pointed to by PS.  If PS is a null pointer, a state
     object local to `mbrlen' is used.

     `mbrlen' was introduced in Amendment 1 to ISO C90 and is declared
     in `wchar.h'.

   The attentive reader now will note that `mbrlen' can be implemented
as

     mbrtowc (NULL, s, n, ps != NULL ? ps : &internal)

   This is true and in fact is mentioned in the official specification.
How can this function be used to determine the length of the wide
character string created from a multibyte character string?  It is not
directly usable, but we can define a function `mbslen' using it:

     size_t
     mbslen (const char *s)
     {
       mbstate_t state;
       size_t result = 0;
       size_t nbytes;
       memset (&state, '\0', sizeof (state));
       while ((nbytes = mbrlen (s, MB_LEN_MAX, &state)) > 0)
         {
           if (nbytes >= (size_t) -2)
             /* Something is wrong.  */
             return (size_t) -1;
           s += nbytes;
           ++result;
         }
       return result;
     }

   This function simply calls `mbrlen' for each multibyte character in
the string and counts the number of function calls.  Please note that
we here use `MB_LEN_MAX' as the size argument in the `mbrlen' call.
This is acceptable since a) this value is larger then the length of the
longest multibyte character sequence and b) we know that the string S
ends with a NUL byte, which cannot be part of any other multibyte
character sequence but the one representing the NUL wide character.
Therefore, the `mbrlen' function will never read invalid memory.

   Now that this function is available (just to make this clear, this
function is _not_ part of the GNU C library) we can compute the number
of wide character required to store the converted multibyte character
string S using

     wcs_bytes = (mbslen (s) + 1) * sizeof (wchar_t);

   Please note that the `mbslen' function is quite inefficient.  The
implementation of `mbstouwcs' with `mbslen' would have to perform the
conversion of the multibyte character input string twice, and this
conversion might be quite expensive.  So it is necessary to think about
the consequences of using the easier but imprecise method before doing
the work twice.

 -- Function: size_t wcrtomb (char *restrict S, wchar_t WC, mbstate_t
          *restrict PS)
     The `wcrtomb' function ("wide character restartable to multibyte")
     converts a single wide character into a multibyte string
     corresponding to that wide character.

     If S is a null pointer, the function resets the state stored in
     the objects pointed to by PS (or the internal `mbstate_t' object)
     to the initial state.  This can also be achieved by a call like
     this:

          wcrtombs (temp_buf, L'\0', ps)

     since, if S is a null pointer, `wcrtomb' performs as if it writes
     into an internal buffer, which is guaranteed to be large enough.

     If WC is the NUL wide character, `wcrtomb' emits, if necessary, a
     shift sequence to get the state PS into the initial state followed
     by a single NUL byte, which is stored in the string S.

     Otherwise a byte sequence (possibly including shift sequences) is
     written into the string S.  This only happens if WC is a valid wide
     character (i.e., it has a multibyte representation in the
     character set selected by locale of the `LC_CTYPE' category).  If
     WC is no valid wide character, nothing is stored in the strings S,
     `errno' is set to `EILSEQ', the conversion state in PS is
     undefined and the return value is `(size_t) -1'.

     If no error occurred the function returns the number of bytes
     stored in the string S.  This includes all bytes representing shift
     sequences.

     One word about the interface of the function: there is no parameter
     specifying the length of the array S.  Instead the function
     assumes that there are at least `MB_CUR_MAX' bytes available since
     this is the maximum length of any byte sequence representing a
     single character.  So the caller has to make sure that there is
     enough space available, otherwise buffer overruns can occur.

     `wcrtomb' was introduced in Amendment 1 to ISO C90 and is declared
     in `wchar.h'.

   Using `wcrtomb' is as easy as using `mbrtowc'.  The following
example appends a wide character string to a multibyte character string.
Again, the code is not really useful (or correct), it is simply here to
demonstrate the use and some problems.

     char *
     mbscatwcs (char *s, size_t len, const wchar_t *ws)
     {
       mbstate_t state;
       /* Find the end of the existing string.  */
       char *wp = strchr (s, '\0');
       len -= wp - s;
       memset (&state, '\0', sizeof (state));
       do
         {
           size_t nbytes;
           if (len < MB_CUR_LEN)
             {
               /* We cannot guarantee that the next
                  character fits into the buffer, so
                  return an error.  */
               errno = E2BIG;
               return NULL;
             }
           nbytes = wcrtomb (wp, *ws, &state);
           if (nbytes == (size_t) -1)
             /* Error in the conversion.  */
             return NULL;
           len -= nbytes;
           wp += nbytes;
         }
       while (*ws++ != L'\0');
       return s;
     }

   First the function has to find the end of the string currently in the
array S.  The `strchr' call does this very efficiently since a
requirement for multibyte character representations is that the NUL byte
is never used except to represent itself (and in this context, the end
of the string).

   After initializing the state object the loop is entered where the
first task is to make sure there is enough room in the array S.  We
abort if there are not at least `MB_CUR_LEN' bytes available.  This is
not always optimal but we have no other choice.  We might have less
than `MB_CUR_LEN' bytes available but the next multibyte character
might also be only one byte long.  At the time the `wcrtomb' call
returns it is too late to decide whether the buffer was large enough.
If this solution is unsuitable, there is a very slow but more accurate
solution.

       ...
       if (len < MB_CUR_LEN)
         {
           mbstate_t temp_state;
           memcpy (&temp_state, &state, sizeof (state));
           if (wcrtomb (NULL, *ws, &temp_state) > len)
             {
               /* We cannot guarantee that the next
                  character fits into the buffer, so
                  return an error.  */
               errno = E2BIG;
               return NULL;
             }
         }
       ...

   Here we perform the conversion that might overflow the buffer so that
we are afterwards in the position to make an exact decision about the
buffer size.  Please note the `NULL' argument for the destination
buffer in the new `wcrtomb' call; since we are not interested in the
converted text at this point, this is a nice way to express this.  The
most unusual thing about this piece of code certainly is the duplication
of the conversion state object, but if a change of the state is
necessary to emit the next multibyte character, we want to have the
same shift state change performed in the real conversion.  Therefore,
we have to preserve the initial shift state information.

   There are certainly many more and even better solutions to this
problem.  This example is only provided for educational purposes.


File: libc.info,  Node: Converting Strings,  Next: Multibyte Conversion Example,  Prev: Converting a Character,  Up: Restartable multibyte conversion

6.3.4 Converting Multibyte and Wide Character Strings
-----------------------------------------------------

The functions described in the previous section only convert a single
character at a time.  Most operations to be performed in real-world
programs include strings and therefore the ISO C standard also defines
conversions on entire strings.  However, the defined set of functions
is quite limited; therefore, the GNU C library contains a few
extensions that can help in some important situations.

 -- Function: size_t mbsrtowcs (wchar_t *restrict DST, const char
          **restrict SRC, size_t LEN, mbstate_t *restrict PS)
     The `mbsrtowcs' function ("multibyte string restartable to wide
     character string") converts an NUL-terminated multibyte character
     string at `*SRC' into an equivalent wide character string,
     including the NUL wide character at the end.  The conversion is
     started using the state information from the object pointed to by
     PS or from an internal object of `mbsrtowcs' if PS is a null
     pointer.  Before returning, the state object is updated to match
     the state after the last converted character.  The state is the
     initial state if the terminating NUL byte is reached and converted.

     If DST is not a null pointer, the result is stored in the array
     pointed to by DST; otherwise, the conversion result is not
     available since it is stored in an internal buffer.

     If LEN wide characters are stored in the array DST before reaching
     the end of the input string, the conversion stops and LEN is
     returned.  If DST is a null pointer, LEN is never checked.

     Another reason for a premature return from the function call is if
     the input string contains an invalid multibyte sequence.  In this
     case the global variable `errno' is set to `EILSEQ' and the
     function returns `(size_t) -1'.

     In all other cases the function returns the number of wide
     characters converted during this call.  If DST is not null,
     `mbsrtowcs' stores in the pointer pointed to by SRC either a null
     pointer (if the NUL byte in the input string was reached) or the
     address of the byte following the last converted multibyte
     character.

     `mbsrtowcs' was introduced in Amendment 1 to ISO C90 and is
     declared in `wchar.h'.

   The definition of the `mbsrtowcs' function has one important
limitation.  The requirement that DST has to be a NUL-terminated string
provides problems if one wants to convert buffers with text.  A buffer
is normally no collection of NUL-terminated strings but instead a
continuous collection of lines, separated by newline characters.  Now
assume that a function to convert one line from a buffer is needed.
Since the line is not NUL-terminated, the source pointer cannot
directly point into the unmodified text buffer.  This means, either one
inserts the NUL byte at the appropriate place for the time of the
`mbsrtowcs' function call (which is not doable for a read-only buffer
or in a multi-threaded application) or one copies the line in an extra
buffer where it can be terminated by a NUL byte.  Note that it is not
in general possible to limit the number of characters to convert by
setting the parameter LEN to any specific value.  Since it is not known
how many bytes each multibyte character sequence is in length, one can
only guess.

   There is still a problem with the method of NUL-terminating a line
right after the newline character, which could lead to very strange
results.  As said in the description of the `mbsrtowcs' function above
the conversion state is guaranteed to be in the initial shift state
after processing the NUL byte at the end of the input string.  But this
NUL byte is not really part of the text (i.e., the conversion state
after the newline in the original text could be something different
than the initial shift state and therefore the first character of the
next line is encoded using this state).  But the state in question is
never accessible to the user since the conversion stops after the NUL
byte (which resets the state).  Most stateful character sets in use
today require that the shift state after a newline be the initial
state-but this is not a strict guarantee.  Therefore, simply
NUL-terminating a piece of a running text is not always an adequate
solution and, therefore, should never be used in generally used code.

   The generic conversion interface (*note Generic Charset Conversion::)
does not have this limitation (it simply works on buffers, not
strings), and the GNU C library contains a set of functions that take
additional parameters specifying the maximal number of bytes that are
consumed from the input string.  This way the problem of `mbsrtowcs''s
example above could be solved by determining the line length and
passing this length to the function.

 -- Function: size_t wcsrtombs (char *restrict DST, const wchar_t
          **restrict SRC, size_t LEN, mbstate_t *restrict PS)
     The `wcsrtombs' function ("wide character string restartable to
     multibyte string") converts the NUL-terminated wide character
     string at `*SRC' into an equivalent multibyte character string and
     stores the result in the array pointed to by DST.  The NUL wide
     character is also converted.  The conversion starts in the state
     described in the object pointed to by PS or by a state object
     locally to `wcsrtombs' in case PS is a null pointer.  If DST is a
     null pointer, the conversion is performed as usual but the result
     is not available.  If all characters of the input string were
     successfully converted and if DST is not a null pointer, the
     pointer pointed to by SRC gets assigned a null pointer.

     If one of the wide characters in the input string has no valid
     multibyte character equivalent, the conversion stops early, sets
     the global variable `errno' to `EILSEQ', and returns `(size_t) -1'.

     Another reason for a premature stop is if DST is not a null
     pointer and the next converted character would require more than
     LEN bytes in total to the array DST.  In this case (and if DEST is
     not a null pointer) the pointer pointed to by SRC is assigned a
     value pointing to the wide character right after the last one
     successfully converted.

     Except in the case of an encoding error the return value of the
     `wcsrtombs' function is the number of bytes in all the multibyte
     character sequences stored in DST.  Before returning the state in
     the object pointed to by PS (or the internal object in case PS is
     a null pointer) is updated to reflect the state after the last
     conversion.  The state is the initial shift state in case the
     terminating NUL wide character was converted.

     The `wcsrtombs' function was introduced in Amendment 1 to ISO C90
     and is declared in `wchar.h'.

   The restriction mentioned above for the `mbsrtowcs' function applies
here also.  There is no possibility of directly controlling the number
of input characters.  One has to place the NUL wide character at the
correct place or control the consumed input indirectly via the
available output array size (the LEN parameter).

 -- Function: size_t mbsnrtowcs (wchar_t *restrict DST, const char
          **restrict SRC, size_t NMC, size_t LEN, mbstate_t *restrict
          PS)
     The `mbsnrtowcs' function is very similar to the `mbsrtowcs'
     function.  All the parameters are the same except for NMC, which is
     new.  The return value is the same as for `mbsrtowcs'.

     This new parameter specifies how many bytes at most can be used
     from the multibyte character string.  In other words, the
     multibyte character string `*SRC' need not be NUL-terminated.  But
     if a NUL byte is found within the NMC first bytes of the string,
     the conversion stops here.

     This function is a GNU extension.  It is meant to work around the
     problems mentioned above.  Now it is possible to convert a buffer
     with multibyte character text piece for piece without having to
     care about inserting NUL bytes and the effect of NUL bytes on the
     conversion state.

   A function to convert a multibyte string into a wide character string
and display it could be written like this (this is not a really useful
example):

     void
     showmbs (const char *src, FILE *fp)
     {
       mbstate_t state;
       int cnt = 0;
       memset (&state, '\0', sizeof (state));
       while (1)
         {
           wchar_t linebuf[100];
           const char *endp = strchr (src, '\n');
           size_t n;

           /* Exit if there is no more line.  */
           if (endp == NULL)
             break;

           n = mbsnrtowcs (linebuf, &src, endp - src, 99, &state);
           linebuf[n] = L'\0';
           fprintf (fp, "line %d: \"%S\"\n", linebuf);
         }
     }

   There is no problem with the state after a call to `mbsnrtowcs'.
Since we don't insert characters in the strings that were not in there
right from the beginning and we use STATE only for the conversion of
the given buffer, there is no problem with altering the state.

 -- Function: size_t wcsnrtombs (char *restrict DST, const wchar_t
          **restrict SRC, size_t NWC, size_t LEN, mbstate_t *restrict
          PS)
     The `wcsnrtombs' function implements the conversion from wide
     character strings to multibyte character strings.  It is similar to
     `wcsrtombs' but, just like `mbsnrtowcs', it takes an extra
     parameter, which specifies the length of the input string.

     No more than NWC wide characters from the input string `*SRC' are
     converted.  If the input string contains a NUL wide character in
     the first NWC characters, the conversion stops at this place.

     The `wcsnrtombs' function is a GNU extension and just like
     `mbsnrtowcs' helps in situations where no NUL-terminated input
     strings are available.


File: libc.info,  Node: Multibyte Conversion Example,  Prev: Converting Strings,  Up: Restartable multibyte conversion

6.3.5 A Complete Multibyte Conversion Example
---------------------------------------------

The example programs given in the last sections are only brief and do
not contain all the error checking, etc.  Presented here is a complete
and documented example.  It features the `mbrtowc' function but it
should be easy to derive versions using the other functions.

     int
     file_mbsrtowcs (int input, int output)
     {
       /* Note the use of `MB_LEN_MAX'.
          `MB_CUR_MAX' cannot portably be used here.  */
       char buffer[BUFSIZ + MB_LEN_MAX];
       mbstate_t state;
       int filled = 0;
       int eof = 0;

       /* Initialize the state.  */
       memset (&state, '\0', sizeof (state));

       while (!eof)
         {
           ssize_t nread;
           ssize_t nwrite;
           char *inp = buffer;
           wchar_t outbuf[BUFSIZ];
           wchar_t *outp = outbuf;

           /* Fill up the buffer from the input file.  */
           nread = read (input, buffer + filled, BUFSIZ);
           if (nread < 0)
             {
               perror ("read");
               return 0;
             }
           /* If we reach end of file, make a note to read no more. */
           if (nread == 0)
             eof = 1;

           /* `filled' is now the number of bytes in `buffer'. */
           filled += nread;

           /* Convert those bytes to wide characters-as many as we can. */
           while (1)
             {
               size_t thislen = mbrtowc (outp, inp, filled, &state);
               /* Stop converting at invalid character;
                  this can mean we have read just the first part
                  of a valid character.  */
               if (thislen == (size_t) -1)
                 break;
               /* We want to handle embedded NUL bytes
                  but the return value is 0.  Correct this.  */
               if (thislen == 0)
                 thislen = 1;
               /* Advance past this character. */
               inp += thislen;
               filled -= thislen;
               ++outp;
             }

           /* Write the wide characters we just made.  */
           nwrite = write (output, outbuf,
                           (outp - outbuf) * sizeof (wchar_t));
           if (nwrite < 0)
             {
               perror ("write");
               return 0;
             }

           /* See if we have a _real_ invalid character. */
           if ((eof && filled > 0) || filled >= MB_CUR_MAX)
             {
               error (0, 0, "invalid multibyte character");
               return 0;
             }

           /* If any characters must be carried forward,
              put them at the beginning of `buffer'. */
           if (filled > 0)
             memmove (buffer, inp, filled);
         }

       return 1;
     }


File: libc.info,  Node: Non-reentrant Conversion,  Next: Generic Charset Conversion,  Prev: Restartable multibyte conversion,  Up: Character Set Handling

6.4 Non-reentrant Conversion Function
=====================================

The functions described in the previous chapter are defined in
Amendment 1 to ISO C90, but the original ISO C90 standard also
contained functions for character set conversion.  The reason that
these original functions are not described first is that they are almost
entirely useless.

   The problem is that all the conversion functions described in the
original ISO C90 use a local state.  Using a local state implies that
multiple conversions at the same time (not only when using threads)
cannot be done, and that you cannot first convert single characters and
then strings since you cannot tell the conversion functions which state
to use.

   These original functions are therefore usable only in a very limited
set of situations.  One must complete converting the entire string
before starting a new one, and each string/text must be converted with
the same function (there is no problem with the library itself; it is
guaranteed that no library function changes the state of any of these
functions).  *For the above reasons it is highly requested that the
functions described in the previous section be used in place of
non-reentrant conversion functions.*

* Menu:

* Non-reentrant Character Conversion::  Non-reentrant Conversion of Single
                                         Characters.
* Non-reentrant String Conversion::     Non-reentrant Conversion of Strings.
* Shift State::                         States in Non-reentrant Functions.


File: libc.info,  Node: Non-reentrant Character Conversion,  Next: Non-reentrant String Conversion,  Up: Non-reentrant Conversion

6.4.1 Non-reentrant Conversion of Single Characters
---------------------------------------------------

 -- Function: int mbtowc (wchar_t *restrict RESULT, const char
          *restrict STRING, size_t SIZE)
     The `mbtowc' ("multibyte to wide character") function when called
     with non-null STRING converts the first multibyte character
     beginning at STRING to its corresponding wide character code.  It
     stores the result in `*RESULT'.

     `mbtowc' never examines more than SIZE bytes.  (The idea is to
     supply for SIZE the number of bytes of data you have in hand.)

     `mbtowc' with non-null STRING distinguishes three possibilities:
     the first SIZE bytes at STRING start with valid multibyte
     characters, they start with an invalid byte sequence or just part
     of a character, or STRING points to an empty string (a null
     character).

     For a valid multibyte character, `mbtowc' converts it to a wide
     character and stores that in `*RESULT', and returns the number of
     bytes in that character (always at least 1 and never more than
     SIZE).

     For an invalid byte sequence, `mbtowc' returns -1.  For an empty
     string, it returns 0, also storing `'\0'' in `*RESULT'.

     If the multibyte character code uses shift characters, then
     `mbtowc' maintains and updates a shift state as it scans.  If you
     call `mbtowc' with a null pointer for STRING, that initializes the
     shift state to its standard initial value.  It also returns
     nonzero if the multibyte character code in use actually has a
     shift state.  *Note Shift State::.

 -- Function: int wctomb (char *STRING, wchar_t WCHAR)
     The `wctomb' ("wide character to multibyte") function converts the
     wide character code WCHAR to its corresponding multibyte character
     sequence, and stores the result in bytes starting at STRING.  At
     most `MB_CUR_MAX' characters are stored.

     `wctomb' with non-null STRING distinguishes three possibilities
     for WCHAR: a valid wide character code (one that can be translated
     to a multibyte character), an invalid code, and `L'\0''.

     Given a valid code, `wctomb' converts it to a multibyte character,
     storing the bytes starting at STRING.  Then it returns the number
     of bytes in that character (always at least 1 and never more than
     `MB_CUR_MAX').

     If WCHAR is an invalid wide character code, `wctomb' returns -1.
     If WCHAR is `L'\0'', it returns `0', also storing `'\0'' in
     `*STRING'.

     If the multibyte character code uses shift characters, then
     `wctomb' maintains and updates a shift state as it scans.  If you
     call `wctomb' with a null pointer for STRING, that initializes the
     shift state to its standard initial value.  It also returns
     nonzero if the multibyte character code in use actually has a
     shift state.  *Note Shift State::.

     Calling this function with a WCHAR argument of zero when STRING is
     not null has the side-effect of reinitializing the stored shift
     state _as well as_ storing the multibyte character `'\0'' and
     returning 0.

   Similar to `mbrlen' there is also a non-reentrant function that
computes the length of a multibyte character.  It can be defined in
terms of `mbtowc'.

 -- Function: int mblen (const char *STRING, size_t SIZE)
     The `mblen' function with a non-null STRING argument returns the
     number of bytes that make up the multibyte character beginning at
     STRING, never examining more than SIZE bytes.  (The idea is to
     supply for SIZE the number of bytes of data you have in hand.)

     The return value of `mblen' distinguishes three possibilities: the
     first SIZE bytes at STRING start with valid multibyte characters,
     they start with an invalid byte sequence or just part of a
     character, or STRING points to an empty string (a null character).

     For a valid multibyte character, `mblen' returns the number of
     bytes in that character (always at least `1' and never more than
     SIZE).  For an invalid byte sequence, `mblen' returns -1.  For an
     empty string, it returns 0.

     If the multibyte character code uses shift characters, then `mblen'
     maintains and updates a shift state as it scans.  If you call
     `mblen' with a null pointer for STRING, that initializes the shift
     state to its standard initial value.  It also returns a nonzero
     value if the multibyte character code in use actually has a shift
     state.  *Note Shift State::.

     The function `mblen' is declared in `stdlib.h'.


File: libc.info,  Node: Non-reentrant String Conversion,  Next: Shift State,  Prev: Non-reentrant Character Conversion,  Up: Non-reentrant Conversion

6.4.2 Non-reentrant Conversion of Strings
-----------------------------------------

For convenience the ISO C90 standard also defines functions to convert
entire strings instead of single characters.  These functions suffer
from the same problems as their reentrant counterparts from Amendment 1
to ISO C90; see *Note Converting Strings::.

 -- Function: size_t mbstowcs (wchar_t *WSTRING, const char *STRING,
          size_t SIZE)
     The `mbstowcs' ("multibyte string to wide character string")
     function converts the null-terminated string of multibyte
     characters STRING to an array of wide character codes, storing not
     more than SIZE wide characters into the array beginning at WSTRING.
     The terminating null character counts towards the size, so if SIZE
     is less than the actual number of wide characters resulting from
     STRING, no terminating null character is stored.

     The conversion of characters from STRING begins in the initial
     shift state.

     If an invalid multibyte character sequence is found, the `mbstowcs'
     function returns a value of -1.  Otherwise, it returns the number
     of wide characters stored in the array WSTRING.  This number does
     not include the terminating null character, which is present if the
     number is less than SIZE.

     Here is an example showing how to convert a string of multibyte
     characters, allocating enough space for the result.

          wchar_t *
          mbstowcs_alloc (const char *string)
          {
            size_t size = strlen (string) + 1;
            wchar_t *buf = xmalloc (size * sizeof (wchar_t));

            size = mbstowcs (buf, string, size);
            if (size == (size_t) -1)
              return NULL;
            buf = xrealloc (buf, (size + 1) * sizeof (wchar_t));
            return buf;
          }


 -- Function: size_t wcstombs (char *STRING, const wchar_t *WSTRING,
          size_t SIZE)
     The `wcstombs' ("wide character string to multibyte string")
     function converts the null-terminated wide character array WSTRING
     into a string containing multibyte characters, storing not more
     than SIZE bytes starting at STRING, followed by a terminating null
     character if there is room.  The conversion of characters begins in
     the initial shift state.

     The terminating null character counts towards the size, so if SIZE
     is less than or equal to the number of bytes needed in WSTRING, no
     terminating null character is stored.

     If a code that does not correspond to a valid multibyte character
     is found, the `wcstombs' function returns a value of -1.
     Otherwise, the return value is the number of bytes stored in the
     array STRING.  This number does not include the terminating null
     character, which is present if the number is less than SIZE.


File: libc.info,  Node: Shift State,  Prev: Non-reentrant String Conversion,  Up: Non-reentrant Conversion

6.4.3 States in Non-reentrant Functions
---------------------------------------

In some multibyte character codes, the _meaning_ of any particular byte
sequence is not fixed; it depends on what other sequences have come
earlier in the same string.  Typically there are just a few sequences
that can change the meaning of other sequences; these few are called
"shift sequences" and we say that they set the "shift state" for other
sequences that follow.

   To illustrate shift state and shift sequences, suppose we decide that
the sequence `0200' (just one byte) enters Japanese mode, in which
pairs of bytes in the range from `0240' to `0377' are single
characters, while `0201' enters Latin-1 mode, in which single bytes in
the range from `0240' to `0377' are characters, and interpreted
according to the ISO Latin-1 character set.  This is a multibyte code
that has two alternative shift states ("Japanese mode" and "Latin-1
mode"), and two shift sequences that specify particular shift states.

   When the multibyte character code in use has shift states, then
`mblen', `mbtowc', and `wctomb' must maintain and update the current
shift state as they scan the string.  To make this work properly, you
must follow these rules:

   * Before starting to scan a string, call the function with a null
     pointer for the multibyte character address--for example, `mblen
     (NULL, 0)'.  This initializes the shift state to its standard
     initial value.

   * Scan the string one character at a time, in order.  Do not "back
     up" and rescan characters already scanned, and do not intersperse
     the processing of different strings.

   Here is an example of using `mblen' following these rules:

     void
     scan_string (char *s)
     {
       int length = strlen (s);

       /* Initialize shift state.  */
       mblen (NULL, 0);

       while (1)
         {
           int thischar = mblen (s, length);
           /* Deal with end of string and invalid characters.  */
           if (thischar == 0)
             break;
           if (thischar == -1)
             {
               error ("invalid multibyte character");
               break;
             }
           /* Advance past this character.  */
           s += thischar;
           length -= thischar;
         }
     }

   The functions `mblen', `mbtowc' and `wctomb' are not reentrant when
using a multibyte code that uses a shift state.  However, no other
library functions call these functions, so you don't have to worry that
the shift state will be changed mysteriously.


File: libc.info,  Node: Generic Charset Conversion,  Prev: Non-reentrant Conversion,  Up: Character Set Handling

6.5 Generic Charset Conversion
==============================

The conversion functions mentioned so far in this chapter all had in
common that they operate on character sets that are not directly
specified by the functions.  The multibyte encoding used is specified by
the currently selected locale for the `LC_CTYPE' category.  The wide
character set is fixed by the implementation (in the case of GNU C
library it is always UCS-4 encoded ISO 10646.

   This has of course several problems when it comes to general
character conversion:

   * For every conversion where neither the source nor the destination
     character set is the character set of the locale for the `LC_CTYPE'
     category, one has to change the `LC_CTYPE' locale using
     `setlocale'.

     Changing the `LC_TYPE' locale introduces major problems for the
     rest of the programs since several more functions (e.g., the
     character classification functions, *note Classification of
     Characters::) use the `LC_CTYPE' category.

   * Parallel conversions to and from different character sets are not
     possible since the `LC_CTYPE' selection is global and shared by all
     threads.

   * If neither the source nor the destination character set is the
     character set used for `wchar_t' representation, there is at least
     a two-step process necessary to convert a text using the functions
     above.  One would have to select the source character set as the
     multibyte encoding, convert the text into a `wchar_t' text, select
     the destination character set as the multibyte encoding, and
     convert the wide character text to the multibyte (= destination)
     character set.

     Even if this is possible (which is not guaranteed) it is a very
     tiring work.  Plus it suffers from the other two raised points
     even more due to the steady changing of the locale.

   The XPG2 standard defines a completely new set of functions, which
has none of these limitations.  They are not at all coupled to the
selected locales, and they have no constraints on the character sets
selected for source and destination.  Only the set of available
conversions limits them.  The standard does not specify that any
conversion at all must be available.  Such availability is a measure of
the quality of the implementation.

   In the following text first the interface to `iconv' and then the
conversion function, will be described.  Comparisons with other
implementations will show what obstacles stand in the way of portable
applications.  Finally, the implementation is described in so far as
might interest the advanced user who wants to extend conversion
capabilities.

* Menu:

* Generic Conversion Interface::    Generic Character Set Conversion Interface.
* iconv Examples::                  A complete `iconv' example.
* Other iconv Implementations::     Some Details about other `iconv'
                                     Implementations.
* glibc iconv Implementation::      The `iconv' Implementation in the GNU C
                                     library.


File: libc.info,  Node: Generic Conversion Interface,  Next: iconv Examples,  Up: Generic Charset Conversion

6.5.1 Generic Character Set Conversion Interface
------------------------------------------------

This set of functions follows the traditional cycle of using a resource:
open-use-close.  The interface consists of three functions, each of
which implements one step.

   Before the interfaces are described it is necessary to introduce a
data type.  Just like other open-use-close interfaces the functions
introduced here work using handles and the `iconv.h' header defines a
special type for the handles used.

 -- Data Type: iconv_t
     This data type is an abstract type defined in `iconv.h'.  The user
     must not assume anything about the definition of this type; it
     must be completely opaque.

     Objects of this type can get assigned handles for the conversions
     using the `iconv' functions.  The objects themselves need not be
     freed, but the conversions for which the handles stand for have to.

The first step is the function to create a handle.

 -- Function: iconv_t iconv_open (const char *TOCODE, const char
          *FROMCODE)
     The `iconv_open' function has to be used before starting a
     conversion.  The two parameters this function takes determine the
     source and destination character set for the conversion, and if the
     implementation has the possibility to perform such a conversion,
     the function returns a handle.

     If the wanted conversion is not available, the `iconv_open'
     function returns `(iconv_t) -1'. In this case the global variable
     `errno' can have the following values:

    `EMFILE'
          The process already has `OPEN_MAX' file descriptors open.

    `ENFILE'
          The system limit of open file is reached.

    `ENOMEM'
          Not enough memory to carry out the operation.

    `EINVAL'
          The conversion from FROMCODE to TOCODE is not supported.

     It is not possible to use the same descriptor in different threads
     to perform independent conversions.  The data structures associated
     with the descriptor include information about the conversion state.
     This must not be messed up by using it in different conversions.

     An `iconv' descriptor is like a file descriptor as for every use a
     new descriptor must be created.  The descriptor does not stand for
     all of the conversions from FROMSET to TOSET.

     The GNU C library implementation of `iconv_open' has one
     significant extension to other implementations.  To ease the
     extension of the set of available conversions, the implementation
     allows storing the necessary files with data and code in an
     arbitrary number of directories.  How this extension must be
     written will be explained below (*note glibc iconv
     Implementation::).  Here it is only important to say that all
     directories mentioned in the `GCONV_PATH' environment variable are
     considered only if they contain a file `gconv-modules'.  These
     directories need not necessarily be created by the system
     administrator.  In fact, this extension is introduced to help users
     writing and using their own, new conversions.  Of course, this
     does not work for security reasons in SUID binaries; in this case
     only the system directory is considered and this normally is
     `PREFIX/lib/gconv'.  The `GCONV_PATH' environment variable is
     examined exactly once at the first call of the `iconv_open'
     function.  Later modifications of the variable have no effect.

     The `iconv_open' function was introduced early in the X/Open
     Portability Guide, version 2.  It is supported by all commercial
     Unices as it is required for the Unix branding.  However, the
     quality and completeness of the implementation varies widely.  The
     `iconv_open' function is declared in `iconv.h'.

   The `iconv' implementation can associate large data structure with
the handle returned by `iconv_open'.  Therefore, it is crucial to free
all the resources once all conversions are carried out and the
conversion is not needed anymore.

 -- Function: int iconv_close (iconv_t CD)
     The `iconv_close' function frees all resources associated with the
     handle CD, which must have been returned by a successful call to
     the `iconv_open' function.

     If the function call was successful the return value is 0.
     Otherwise it is -1 and `errno' is set appropriately.  Defined
     error are:

    `EBADF'
          The conversion descriptor is invalid.

     The `iconv_close' function was introduced together with the rest
     of the `iconv' functions in XPG2 and is declared in `iconv.h'.

   The standard defines only one actual conversion function.  This has,
therefore, the most general interface: it allows conversion from one
buffer to another.  Conversion from a file to a buffer, vice versa, or
even file to file can be implemented on top of it.

 -- Function: size_t iconv (iconv_t CD, char **INBUF, size_t
          *INBYTESLEFT, char **OUTBUF, size_t *OUTBYTESLEFT)
     The `iconv' function converts the text in the input buffer
     according to the rules associated with the descriptor CD and
     stores the result in the output buffer.  It is possible to call the
     function for the same text several times in a row since for
     stateful character sets the necessary state information is kept in
     the data structures associated with the descriptor.

     The input buffer is specified by `*INBUF' and it contains
     `*INBYTESLEFT' bytes.  The extra indirection is necessary for
     communicating the used input back to the caller (see below).  It is
     important to note that the buffer pointer is of type `char' and the
     length is measured in bytes even if the input text is encoded in
     wide characters.

     The output buffer is specified in a similar way.  `*OUTBUF' points
     to the beginning of the buffer with at least `*OUTBYTESLEFT' bytes
     room for the result.  The buffer pointer again is of type `char'
     and the length is measured in bytes.  If OUTBUF or `*OUTBUF' is a
     null pointer, the conversion is performed but no output is
     available.

     If INBUF is a null pointer, the `iconv' function performs the
     necessary action to put the state of the conversion into the
     initial state.  This is obviously a no-op for non-stateful
     encodings, but if the encoding has a state, such a function call
     might put some byte sequences in the output buffer, which perform
     the necessary state changes.  The next call with INBUF not being a
     null pointer then simply goes on from the initial state.  It is
     important that the programmer never makes any assumption as to
     whether the conversion has to deal with states.  Even if the input
     and output character sets are not stateful, the implementation
     might still have to keep states.  This is due to the
     implementation chosen for the GNU C library as it is described
     below.  Therefore an `iconv' call to reset the state should always
     be performed if some protocol requires this for the output text.

     The conversion stops for one of three reasons. The first is that
     all characters from the input buffer are converted.  This actually
     can mean two things: either all bytes from the input buffer are
     consumed or there are some bytes at the end of the buffer that
     possibly can form a complete character but the input is
     incomplete.  The second reason for a stop is that the output
     buffer is full.  And the third reason is that the input contains
     invalid characters.

     In all of these cases the buffer pointers after the last successful
     conversion, for input and output buffer, are stored in INBUF and
     OUTBUF, and the available room in each buffer is stored in
     INBYTESLEFT and OUTBYTESLEFT.

     Since the character sets selected in the `iconv_open' call can be
     almost arbitrary, there can be situations where the input buffer
     contains valid characters, which have no identical representation
     in the output character set.  The behavior in this situation is
     undefined.  The _current_ behavior of the GNU C library in this
     situation is to return with an error immediately.  This certainly
     is not the most desirable solution; therefore, future versions
     will provide better ones, but they are not yet finished.

     If all input from the input buffer is successfully converted and
     stored in the output buffer, the function returns the number of
     non-reversible conversions performed.  In all other cases the
     return value is `(size_t) -1' and `errno' is set appropriately.
     In such cases the value pointed to by INBYTESLEFT is nonzero.

    `EILSEQ'
          The conversion stopped because of an invalid byte sequence in
          the input.  After the call, `*INBUF' points at the first byte
          of the invalid byte sequence.

    `E2BIG'
          The conversion stopped because it ran out of space in the
          output buffer.

    `EINVAL'
          The conversion stopped because of an incomplete byte sequence
          at the end of the input buffer.

    `EBADF'
          The CD argument is invalid.

     The `iconv' function was introduced in the XPG2 standard and is
     declared in the `iconv.h' header.

   The definition of the `iconv' function is quite good overall.  It
provides quite flexible functionality.  The only problems lie in the
boundary cases, which are incomplete byte sequences at the end of the
input buffer and invalid input.  A third problem, which is not really a
design problem, is the way conversions are selected.  The standard does
not say anything about the legitimate names, a minimal set of available
conversions.  We will see how this negatively impacts other
implementations, as demonstrated below.


File: libc.info,  Node: iconv Examples,  Next: Other iconv Implementations,  Prev: Generic Conversion Interface,  Up: Generic Charset Conversion

6.5.2 A complete `iconv' example
--------------------------------

The example below features a solution for a common problem.  Given that
one knows the internal encoding used by the system for `wchar_t'
strings, one often is in the position to read text from a file and store
it in wide character buffers.  One can do this using `mbsrtowcs', but
then we run into the problems discussed above.

     int
     file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
     {
       char inbuf[BUFSIZ];
       size_t insize = 0;
       char *wrptr = (char *) outbuf;
       int result = 0;
       iconv_t cd;

       cd = iconv_open ("WCHAR_T", charset);
       if (cd == (iconv_t) -1)
         {
           /* Something went wrong.  */
           if (errno == EINVAL)
             error (0, 0, "conversion from '%s' to wchar_t not available",
                    charset);
           else
             perror ("iconv_open");

           /* Terminate the output string.  */
           *outbuf = L'\0';

           return -1;
         }

       while (avail > 0)
         {
           size_t nread;
           size_t nconv;
           char *inptr = inbuf;

           /* Read more input.  */
           nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
           if (nread == 0)
             {
               /* When we come here the file is completely read.
                  This still could mean there are some unused
                  characters in the `inbuf'.  Put them back.  */
               if (lseek (fd, -insize, SEEK_CUR) == -1)
                 result = -1;

               /* Now write out the byte sequence to get into the
                  initial state if this is necessary.  */
               iconv (cd, NULL, NULL, &wrptr, &avail);

               break;
             }
           insize += nread;

           /* Do the conversion.  */
           nconv = iconv (cd, &inptr, &insize, &wrptr, &avail);
           if (nconv == (size_t) -1)
             {
               /* Not everything went right.  It might only be
                  an unfinished byte sequence at the end of the
                  buffer.  Or it is a real problem.  */
               if (errno == EINVAL)
                 /* This is harmless.  Simply move the unused
                    bytes to the beginning of the buffer so that
                    they can be used in the next round.  */
                 memmove (inbuf, inptr, insize);
               else
                 {
                   /* It is a real problem.  Maybe we ran out of
                      space in the output buffer or we have invalid
                      input.  In any case back the file pointer to
                      the position of the last processed byte.  */
                   lseek (fd, -insize, SEEK_CUR);
                   result = -1;
                   break;
                 }
             }
         }

       /* Terminate the output string.  */
       if (avail >= sizeof (wchar_t))
         *((wchar_t *) wrptr) = L'\0';

       if (iconv_close (cd) != 0)
         perror ("iconv_close");

       return (wchar_t *) wrptr - outbuf;
     }

   This example shows the most important aspects of using the `iconv'
functions.  It shows how successive calls to `iconv' can be used to
convert large amounts of text.  The user does not have to care about
stateful encodings as the functions take care of everything.

   An interesting point is the case where `iconv' returns an error and
`errno' is set to `EINVAL'.  This is not really an error in the
transformation.  It can happen whenever the input character set contains
byte sequences of more than one byte for some character and texts are
not processed in one piece.  In this case there is a chance that a
multibyte sequence is cut.  The caller can then simply read the
remainder of the takes and feed the offending bytes together with new
character from the input to `iconv' and continue the work.  The
internal state kept in the descriptor is _not_ unspecified after such
an event as is the case with the conversion functions from the ISO C
standard.

   The example also shows the problem of using wide character strings
with `iconv'.  As explained in the description of the `iconv' function
above, the function always takes a pointer to a `char' array and the
available space is measured in bytes.  In the example, the output
buffer is a wide character buffer; therefore, we use a local variable
WRPTR of type `char *', which is used in the `iconv' calls.

   This looks rather innocent but can lead to problems on platforms that
have tight restriction on alignment.  Therefore the caller of `iconv'
has to make sure that the pointers passed are suitable for access of
characters from the appropriate character set.  Since, in the above
case, the input parameter to the function is a `wchar_t' pointer, this
is the case (unless the user violates alignment when computing the
parameter).  But in other situations, especially when writing generic
functions where one does not know what type of character set one uses
and, therefore, treats text as a sequence of bytes, it might become
tricky.


File: libc.info,  Node: Other iconv Implementations,  Next: glibc iconv Implementation,  Prev: iconv Examples,  Up: Generic Charset Conversion

6.5.3 Some Details about other `iconv' Implementations
------------------------------------------------------

This is not really the place to discuss the `iconv' implementation of
other systems but it is necessary to know a bit about them to write
portable programs.  The above mentioned problems with the specification
of the `iconv' functions can lead to portability issues.

   The first thing to notice is that, due to the large number of
character sets in use, it is certainly not practical to encode the
conversions directly in the C library.  Therefore, the conversion
information must come from files outside the C library.  This is
usually done in one or both of the following ways:

   * The C library contains a set of generic conversion functions that
     can read the needed conversion tables and other information from
     data files.  These files get loaded when necessary.

     This solution is problematic as it requires a great deal of effort
     to apply to all character sets (potentially an infinite set).  The
     differences in the structure of the different character sets is so
     large that many different variants of the table-processing
     functions must be developed.  In addition, the generic nature of
     these functions make them slower than specifically implemented
     functions.

   * The C library only contains a framework that can dynamically load
     object files and execute the conversion functions contained
     therein.

     This solution provides much more flexibility.  The C library itself
     contains only very little code and therefore reduces the general
     memory footprint.  Also, with a documented interface between the C
     library and the loadable modules it is possible for third parties
     to extend the set of available conversion modules.  A drawback of
     this solution is that dynamic loading must be available.

   Some implementations in commercial Unices implement a mixture of
these possibilities; the majority implement only the second solution.
Using loadable modules moves the code out of the library itself and
keeps the door open for extensions and improvements, but this design is
also limiting on some platforms since not many platforms support dynamic
loading in statically linked programs.  On platforms without this
capability it is therefore not possible to use this interface in
statically linked programs.  The GNU C library has, on ELF platforms, no
problems with dynamic loading in these situations; therefore, this
point is moot.  The danger is that one gets acquainted with this
situation and forgets about the restrictions on other systems.

   A second thing to know about other `iconv' implementations is that
the number of available conversions is often very limited.  Some
implementations provide, in the standard release (not special
international or developer releases), at most 100 to 200 conversion
possibilities.  This does not mean 200 different character sets are
supported; for example, conversions from one character set to a set of
10 others might count as 10 conversions.  Together with the other
direction this makes 20 conversion possibilities used up by one
character set.  One can imagine the thin coverage these platform
provide.  Some Unix vendors even provide only a handful of conversions,
which renders them useless for almost all uses.

   This directly leads to a third and probably the most problematic
point.  The way the `iconv' conversion functions are implemented on all
known Unix systems and the availability of the conversion functions from
character set A to B and the conversion from B to C does _not_ imply
that the conversion from A to C is available.

   This might not seem unreasonable and problematic at first, but it is
a quite big problem as one will notice shortly after hitting it.  To
show the problem we assume to write a program that has to convert from
A to C.  A call like

     cd = iconv_open ("C", "A");

fails according to the assumption above.  But what does the program do
now?  The conversion is necessary; therefore, simply giving up is not
an option.

   This is a nuisance.  The `iconv' function should take care of this.
But how should the program proceed from here on?  If it tries to convert
to character set B, first the two `iconv_open' calls

     cd1 = iconv_open ("B", "A");

and

     cd2 = iconv_open ("C", "B");

will succeed, but how to find B?

   Unfortunately, the answer is: there is no general solution.  On some
systems guessing might help.  On those systems most character sets can
convert to and from UTF-8 encoded ISO 10646 or Unicode text. Beside
this only some very system-specific methods can help.  Since the
conversion functions come from loadable modules and these modules must
be stored somewhere in the filesystem, one _could_ try to find them and
determine from the available file which conversions are available and
whether there is an indirect route from A to C.

   This example shows one of the design errors of `iconv' mentioned
above.  It should at least be possible to determine the list of
available conversion programmatically so that if `iconv_open' says
there is no such conversion, one could make sure this also is true for
indirect routes.


File: libc.info,  Node: glibc iconv Implementation,  Prev: Other iconv Implementations,  Up: Generic Charset Conversion

6.5.4 The `iconv' Implementation in the GNU C library
-----------------------------------------------------

After reading about the problems of `iconv' implementations in the last
section it is certainly good to note that the implementation in the GNU
C library has none of the problems mentioned above.  What follows is a
step-by-step analysis of the points raised above.  The evaluation is
based on the current state of the development (as of January 1999).
The development of the `iconv' functions is not complete, but basic
functionality has solidified.

   The GNU C library's `iconv' implementation uses shared loadable
modules to implement the conversions.  A very small number of
conversions are built into the library itself but these are only rather
trivial conversions.

   All the benefits of loadable modules are available in the GNU C
library implementation.  This is especially appealing since the
interface is well documented (see below), and it, therefore, is easy to
write new conversion modules.  The drawback of using loadable objects
is not a problem in the GNU C library, at least on ELF systems.  Since
the library is able to load shared objects even in statically linked
binaries, static linking need not be forbidden in case one wants to use
`iconv'.

   The second mentioned problem is the number of supported conversions.
Currently, the GNU C library supports more than 150 character sets.  The
way the implementation is designed the number of supported conversions
is greater than 22350 (150 times 149).  If any conversion from or to a
character set is missing, it can be added easily.

   Particularly impressive as it may be, this high number is due to the
fact that the GNU C library implementation of `iconv' does not have the
third problem mentioned above (i.e., whenever there is a conversion
from a character set A to B and from B to C it is always possible to
convert from A to C directly).  If the `iconv_open' returns an error
and sets `errno' to `EINVAL', there is no known way, directly or
indirectly, to perform the wanted conversion.

   Triangulation is achieved by providing for each character set a
conversion from and to UCS-4 encoded ISO 10646.  Using ISO 10646 as an
intermediate representation it is possible to "triangulate" (i.e.,
convert with an intermediate representation).

   There is no inherent requirement to provide a conversion to
ISO 10646 for a new character set, and it is also possible to provide
other conversions where neither source nor destination character set is
ISO 10646.  The existing set of conversions is simply meant to cover all
conversions that might be of interest.

   All currently available conversions use the triangulation method
above, making conversion run unnecessarily slow.  If, for example,
somebody often needs the conversion from ISO-2022-JP to EUC-JP, a
quicker solution would involve direct conversion between the two
character sets, skipping the input to ISO 10646 first.  The two
character sets of interest are much more similar to each other than to
ISO 10646.

   In such a situation one easily can write a new conversion and
provide it as a better alternative.  The GNU C library `iconv'
implementation would automatically use the module implementing the
conversion if it is specified to be more efficient.

6.5.4.1 Format of `gconv-modules' files
.......................................

All information about the available conversions comes from a file named
`gconv-modules', which can be found in any of the directories along the
`GCONV_PATH'.  The `gconv-modules' files are line-oriented text files,
where each of the lines has one of the following formats:

   * If the first non-whitespace character is a `#' the line contains
     only comments and is ignored.

   * Lines starting with `alias' define an alias name for a character
     set.  Two more words are expected on the line.  The first word
     defines the alias name, and the second defines the original name
     of the character set.  The effect is that it is possible to use
     the alias name in the FROMSET or TOSET parameters of `iconv_open'
     and achieve the same result as when using the real character set
     name.

     This is quite important as a character set has often many different
     names.  There is normally an official name but this need not
     correspond to the most popular name.  Beside this many character
     sets have special names that are somehow constructed.  For
     example, all character sets specified by the ISO have an alias of
     the form `ISO-IR-NNN' where NNN is the registration number.  This
     allows programs that know about the registration number to
     construct character set names and use them in `iconv_open' calls.
     More on the available names and aliases follows below.

   * Lines starting with `module' introduce an available conversion
     module.  These lines must contain three or four more words.

     The first word specifies the source character set, the second word
     the destination character set of conversion implemented in this
     module, and the third word is the name of the loadable module.
     The filename is constructed by appending the usual shared object
     suffix (normally `.so') and this file is then supposed to be found
     in the same directory the `gconv-modules' file is in.  The last
     word on the line, which is optional, is a numeric value
     representing the cost of the conversion.  If this word is missing,
     a cost of 1 is assumed.  The numeric value itself does not matter
     that much; what counts are the relative values of the sums of
     costs for all possible conversion paths.  Below is a more precise
     description of the use of the cost value.

   Returning to the example above where one has written a module to
directly convert from ISO-2022-JP to EUC-JP and back.  All that has to
be done is to put the new module, let its name be ISO2022JP-EUCJP.so,
in a directory and add a file `gconv-modules' with the following
content in the same directory:

     module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
     module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1

   To see why this is sufficient, it is necessary to understand how the
conversion used by `iconv' (and described in the descriptor) is
selected.  The approach to this problem is quite simple.

   At the first call of the `iconv_open' function the program reads all
available `gconv-modules' files and builds up two tables: one
containing all the known aliases and another that contains the
information about the conversions and which shared object implements
them.

6.5.4.2 Finding the conversion path in `iconv'
..............................................

The set of available conversions form a directed graph with weighted
edges.  The weights on the edges are the costs specified in the
`gconv-modules' files.  The `iconv_open' function uses an algorithm
suitable for search for the best path in such a graph and so constructs
a list of conversions that must be performed in succession to get the
transformation from the source to the destination character set.

   Explaining why the above `gconv-modules' files allows the `iconv'
implementation to resolve the specific ISO-2022-JP to EUC-JP conversion
module instead of the conversion coming with the library itself is
straightforward.  Since the latter conversion takes two steps (from
ISO-2022-JP to ISO 10646 and then from ISO 10646 to EUC-JP), the cost
is 1+1 = 2.  The above `gconv-modules' file, however, specifies that
the new conversion modules can perform this conversion with only the
cost of 1.

   A mysterious item about the `gconv-modules' file above (and also the
file coming with the GNU C library) are the names of the character sets
specified in the `module' lines.  Why do almost all the names end in
`//'?  And this is not all: the names can actually be regular
expressions.  At this point in time this mystery should not be
revealed, unless you have the relevant spell-casting materials: ashes
from an original DOS 6.2 boot disk burnt in effigy, a crucifix blessed
by St. Emacs, assorted herbal roots from Central America, sand from
Cebu, etc.  Sorry!  *The part of the implementation where this is used
is not yet finished.  For now please simply follow the existing
examples.  It'll become clearer once it is. -drepper*

   A last remark about the `gconv-modules' is about the names not
ending with `//'.  A character set named `INTERNAL' is often mentioned.
From the discussion above and the chosen name it should have become
clear that this is the name for the representation used in the
intermediate step of the triangulation.  We have said that this is UCS-4
but actually that is not quite right.  The UCS-4 specification also
includes the specification of the byte ordering used.  Since a UCS-4
value consists of four bytes, a stored value is effected by byte
ordering.  The internal representation is _not_ the same as UCS-4 in
case the byte ordering of the processor (or at least the running
process) is not the same as the one required for UCS-4.  This is done
for performance reasons as one does not want to perform unnecessary
byte-swapping operations if one is not interested in actually seeing
the result in UCS-4.  To avoid trouble with endianness, the internal
representation consistently is named `INTERNAL' even on big-endian
systems where the representations are identical.

6.5.4.3 `iconv' module data structures
......................................

So far this section has described how modules are located and considered
to be used.  What remains to be described is the interface of the
modules so that one can write new ones. This section describes the
interface as it is in use in January 1999.  The interface will change a
bit in the future but, with luck, only in an upwardly compatible way.

   The definitions necessary to write new modules are publicly available
in the non-standard header `gconv.h'.  The following text, therefore,
describes the definitions from this header file.  First, however, it is
necessary to get an overview.

   From the perspective of the user of `iconv' the interface is quite
simple: the `iconv_open' function returns a handle that can be used in
calls to `iconv', and finally the handle is freed with a call to
`iconv_close'.  The problem is that the handle has to be able to
represent the possibly long sequences of conversion steps and also the
state of each conversion since the handle is all that is passed to the
`iconv' function.  Therefore, the data structures are really the
elements necessary to understanding the implementation.

   We need two different kinds of data structures.  The first describes
the conversion and the second describes the state etc.  There are
really two type definitions like this in `gconv.h'.  

 -- Data type: struct __gconv_step
     This data structure describes one conversion a module can perform.
     For each function in a loaded module with conversion functions
     there is exactly one object of this type.  This object is shared
     by all users of the conversion (i.e., this object does not contain
     any information corresponding to an actual conversion; it only
     describes the conversion itself).

    `struct __gconv_loaded_object *__shlib_handle'
    `const char *__modname'
    `int __counter'
          All these elements of the structure are used internally in
          the C library to coordinate loading and unloading the shared.
          One must not expect any of the other elements to be
          available or initialized.

    `const char *__from_name'
    `const char *__to_name'
          `__from_name' and `__to_name' contain the names of the source
          and destination character sets.  They can be used to identify
          the actual conversion to be carried out since one module
          might implement conversions for more than one character set
          and/or direction.

    `gconv_fct __fct'
    `gconv_init_fct __init_fct'
    `gconv_end_fct __end_fct'
          These elements contain pointers to the functions in the
          loadable module.  The interface will be explained below.

    `int __min_needed_from'
    `int __max_needed_from'
    `int __min_needed_to'
    `int __max_needed_to;'
          These values have to be supplied in the init function of the
          module.  The `__min_needed_from' value specifies how many
          bytes a character of the source character set at least needs.
          The `__max_needed_from' specifies the maximum value that
          also includes possible shift sequences.

          The `__min_needed_to' and `__max_needed_to' values serve the
          same purpose as `__min_needed_from' and `__max_needed_from'
          but this time for the destination character set.

          It is crucial that these values be accurate since otherwise
          the conversion functions will have problems or not work at
          all.

    `int __stateful'
          This element must also be initialized by the init function.
          `int __stateful' is nonzero if the source character set is
          stateful.  Otherwise it is zero.

    `void *__data'
          This element can be used freely by the conversion functions
          in the module.  `void *__data' can be used to communicate
          extra information from one call to another.  `void *__data'
          need not be initialized if not needed at all.  If `void
          *__data' element is assigned a pointer to dynamically
          allocated memory (presumably in the init function) it has to
          be made sure that the end function deallocates the memory.
          Otherwise the application will leak memory.

          It is important to be aware that this data structure is
          shared by all users of this specification conversion and
          therefore the `__data' element must not contain data specific
          to one specific use of the conversion function.

 -- Data type: struct __gconv_step_data
     This is the data structure that contains the information specific
     to each use of the conversion functions.

    `char *__outbuf'
    `char *__outbufend'
          These elements specify the output buffer for the conversion
          step.  The `__outbuf' element points to the beginning of the
          buffer, and `__outbufend' points to the byte following the
          last byte in the buffer.  The conversion function must not
          assume anything about the size of the buffer but it can be
          safely assumed the there is room for at least one complete
          character in the output buffer.

          Once the conversion is finished, if the conversion is the
          last step, the `__outbuf' element must be modified to point
          after the last byte written into the buffer to signal how
          much output is available.  If this conversion step is not the
          last one, the element must not be modified.  The
          `__outbufend' element must not be modified.

    `int __is_last'
          This element is nonzero if this conversion step is the last
          one.  This information is necessary for the recursion.  See
          the description of the conversion function internals below.
          This element must never be modified.

    `int __invocation_counter'
          The conversion function can use this element to see how many
          calls of the conversion function already happened.  Some
          character sets require a certain prolog when generating
          output, and by comparing this value with zero, one can find
          out whether it is the first call and whether, therefore, the
          prolog should be emitted.  This element must never be
          modified.

    `int __internal_use'
          This element is another one rarely used but needed in certain
          situations.  It is assigned a nonzero value in case the
          conversion functions are used to implement `mbsrtowcs' et.al.
          (i.e., the function is not used directly through the `iconv'
          interface).

          This sometimes makes a difference as it is expected that the
          `iconv' functions are used to translate entire texts while the
          `mbsrtowcs' functions are normally used only to convert single
          strings and might be used multiple times to convert entire
          texts.

          But in this situation we would have problem complying with
          some rules of the character set specification.  Some
          character sets require a prolog, which must appear exactly
          once for an entire text.  If a number of `mbsrtowcs' calls
          are used to convert the text, only the first call must add
          the prolog.  However, because there is no communication
          between the different calls of `mbsrtowcs', the conversion
          functions have no possibility to find this out.  The
          situation is different for sequences of `iconv' calls since
          the handle allows access to the needed information.

          The `int __internal_use' element is mostly used together with
          `__invocation_counter' as follows:

               if (!data->__internal_use
                    && data->__invocation_counter == 0)
                 /* Emit prolog.  */
                 ...

          This element must never be modified.

    `mbstate_t *__statep'
          The `__statep' element points to an object of type `mbstate_t'
          (*note Keeping the state::).  The conversion of a stateful
          character set must use the object pointed to by `__statep' to
          store information about the conversion state.  The `__statep'
          element itself must never be modified.

    `mbstate_t __state'
          This element must _never_ be used directly.  It is only part
          of this structure to have the needed space allocated.

6.5.4.4 `iconv' module interfaces
.................................

With the knowledge about the data structures we now can describe the
conversion function itself.  To understand the interface a bit of
knowledge is necessary about the functionality in the C library that
loads the objects with the conversions.

   It is often the case that one conversion is used more than once
(i.e., there are several `iconv_open' calls for the same set of
character sets during one program run).  The `mbsrtowcs' et.al.
functions in the GNU C library also use the `iconv' functionality, which
increases the number of uses of the same functions even more.

   Because of this multiple use of conversions, the modules do not get
loaded exclusively for one conversion.  Instead a module once loaded can
be used by an arbitrary number of `iconv' or `mbsrtowcs' calls at the
same time.  The splitting of the information between conversion-
function-specific information and conversion data makes this possible.
The last section showed the two data structures used to do this.

   This is of course also reflected in the interface and semantics of
the functions that the modules must provide.  There are three functions
that must have the following names:

`gconv_init'
     The `gconv_init' function initializes the conversion function
     specific data structure.  This very same object is shared by all
     conversions that use this conversion and, therefore, no state
     information about the conversion itself must be stored in here.
     If a module implements more than one conversion, the `gconv_init'
     function will be called multiple times.

`gconv_end'
     The `gconv_end' function is responsible for freeing all resources
     allocated by the `gconv_init' function.  If there is nothing to do,
     this function can be missing.  Special care must be taken if the
     module implements more than one conversion and the `gconv_init'
     function does not allocate the same resources for all conversions.

`gconv'
     This is the actual conversion function.  It is called to convert
     one block of text.  It gets passed the conversion step information
     initialized by `gconv_init' and the conversion data, specific to
     this use of the conversion functions.

   There are three data types defined for the three module interface
functions and these define the interface.

 -- Data type: int (*__gconv_init_fct) (struct __gconv_step *)
     This specifies the interface of the initialization function of the
     module.  It is called exactly once for each conversion the module
     implements.

     As explained in the description of the `struct __gconv_step' data
     structure above the initialization function has to initialize
     parts of it.

    `__min_needed_from'
    `__max_needed_from'
    `__min_needed_to'
    `__max_needed_to'
          These elements must be initialized to the exact numbers of
          the minimum and maximum number of bytes used by one character
          in the source and destination character sets, respectively.
          If the characters all have the same size, the minimum and
          maximum values are the same.

    `__stateful'
          This element must be initialized to an nonzero value if the
          source character set is stateful.  Otherwise it must be zero.

     If the initialization function needs to communicate some
     information to the conversion function, this communication can
     happen using the `__data' element of the `__gconv_step' structure.
     But since this data is shared by all the conversions, it must not
     be modified by the conversion function.  The example below shows
     how this can be used.

          #define MIN_NEEDED_FROM         1
          #define MAX_NEEDED_FROM         4
          #define MIN_NEEDED_TO           4
          #define MAX_NEEDED_TO           4

          int
          gconv_init (struct __gconv_step *step)
          {
            /* Determine which direction.  */
            struct iso2022jp_data *new_data;
            enum direction dir = illegal_dir;
            enum variant var = illegal_var;
            int result;

            if (__strcasecmp (step->__from_name, "ISO-2022-JP//") == 0)
              {
                dir = from_iso2022jp;
                var = iso2022jp;
              }
            else if (__strcasecmp (step->__to_name, "ISO-2022-JP//") == 0)
              {
                dir = to_iso2022jp;
                var = iso2022jp;
              }
            else if (__strcasecmp (step->__from_name, "ISO-2022-JP-2//") == 0)
              {
                dir = from_iso2022jp;
                var = iso2022jp2;
              }
            else if (__strcasecmp (step->__to_name, "ISO-2022-JP-2//") == 0)
              {
                dir = to_iso2022jp;
                var = iso2022jp2;
              }

            result = __GCONV_NOCONV;
            if (dir != illegal_dir)
              {
                new_data = (struct iso2022jp_data *)
                  malloc (sizeof (struct iso2022jp_data));

                result = __GCONV_NOMEM;
                if (new_data != NULL)
                  {
                    new_data->dir = dir;
                    new_data->var = var;
                    step->__data = new_data;

                    if (dir == from_iso2022jp)
                      {
                        step->__min_needed_from = MIN_NEEDED_FROM;
                        step->__max_needed_from = MAX_NEEDED_FROM;
                        step->__min_needed_to = MIN_NEEDED_TO;
                        step->__max_needed_to = MAX_NEEDED_TO;
                      }
                    else
                      {
                        step->__min_needed_from = MIN_NEEDED_TO;
                        step->__max_needed_from = MAX_NEEDED_TO;
                        step->__min_needed_to = MIN_NEEDED_FROM;
                        step->__max_needed_to = MAX_NEEDED_FROM + 2;
                      }

                    /* Yes, this is a stateful encoding.  */
                    step->__stateful = 1;

                    result = __GCONV_OK;
                  }
              }

            return result;
          }

     The function first checks which conversion is wanted.  The module
     from which this function is taken implements four different
     conversions; which one is selected can be determined by comparing
     the names.  The comparison should always be done without paying
     attention to the case.

     Next, a data structure, which contains the necessary information
     about which conversion is selected, is allocated.  The data
     structure `struct iso2022jp_data' is locally defined since,
     outside the module, this data is not used at all.  Please note
     that if all four conversions this modules supports are requested
     there are four data blocks.

     One interesting thing is the initialization of the `__min_' and
     `__max_' elements of the step data object.  A single ISO-2022-JP
     character can consist of one to four bytes.  Therefore the
     `MIN_NEEDED_FROM' and `MAX_NEEDED_FROM' macros are defined this
     way.  The output is always the `INTERNAL' character set (aka
     UCS-4) and therefore each character consists of exactly four
     bytes.  For the conversion from `INTERNAL' to ISO-2022-JP we have
     to take into account that escape sequences might be necessary to
     switch the character sets.  Therefore the `__max_needed_to'
     element for this direction gets assigned `MAX_NEEDED_FROM + 2'.
     This takes into account the two bytes needed for the escape
     sequences to single the switching.  The asymmetry in the maximum
     values for the two directions can be explained easily: when
     reading ISO-2022-JP text, escape sequences can be handled alone
     (i.e., it is not necessary to process a real character since the
     effect of the escape sequence can be recorded in the state
     information).  The situation is different for the other direction.
     Since it is in general not known which character comes next, one
     cannot emit escape sequences to change the state in advance.  This
     means the escape sequences that have to be emitted together with
     the next character.  Therefore one needs more room than only for
     the character itself.

     The possible return values of the initialization function are:

    `__GCONV_OK'
          The initialization succeeded

    `__GCONV_NOCONV'
          The requested conversion is not supported in the module.
          This can happen if the `gconv-modules' file has errors.

    `__GCONV_NOMEM'
          Memory required to store additional information could not be
          allocated.

   The function called before the module is unloaded is significantly
easier.  It often has nothing at all to do; in which case it can be left
out completely.

 -- Data type: void (*__gconv_end_fct) (struct gconv_step *)
     The task of this function is to free all resources allocated in the
     initialization function.  Therefore only the `__data' element of
     the object pointed to by the argument is of interest.  Continuing
     the example from the initialization function, the finalization
     function looks like this:

          void
          gconv_end (struct __gconv_step *data)
          {
            free (data->__data);
          }

   The most important function is the conversion function itself, which
can get quite complicated for complex character sets.  But since this
is not of interest here, we will only describe a possible skeleton for
the conversion function.

 -- Data type: int (*__gconv_fct) (struct __gconv_step *, struct
          __gconv_step_data *, const char **, const char *, size_t *,
          int)
     The conversion function can be called for two basic reason: to
     convert text or to reset the state.  From the description of the
     `iconv' function it can be seen why the flushing mode is
     necessary.  What mode is selected is determined by the sixth
     argument, an integer.  This argument being nonzero means that
     flushing is selected.

     Common to both modes is where the output buffer can be found.  The
     information about this buffer is stored in the conversion step
     data.  A pointer to this information is passed as the second
     argument to this function.  The description of the `struct
     __gconv_step_data' structure has more information on the
     conversion step data.

     What has to be done for flushing depends on the source character
     set.  If the source character set is not stateful, nothing has to
     be done.  Otherwise the function has to emit a byte sequence to
     bring the state object into the initial state.  Once this all
     happened the other conversion modules in the chain of conversions
     have to get the same chance.  Whether another step follows can be
     determined from the `__is_last' element of the step data structure
     to which the first parameter points.

     The more interesting mode is when actual text has to be converted.
     The first step in this case is to convert as much text as
     possible from the input buffer and store the result in the output
     buffer.  The start of the input buffer is determined by the third
     argument, which is a pointer to a pointer variable referencing the
     beginning of the buffer.  The fourth argument is a pointer to the
     byte right after the last byte in the buffer.

     The conversion has to be performed according to the current state
     if the character set is stateful.  The state is stored in an
     object pointed to by the `__statep' element of the step data
     (second argument).  Once either the input buffer is empty or the
     output buffer is full the conversion stops.  At this point, the
     pointer variable referenced by the third parameter must point to
     the byte following the last processed byte (i.e., if all of the
     input is consumed, this pointer and the fourth parameter have the
     same value).

     What now happens depends on whether this step is the last one.  If
     it is the last step, the only thing that has to be done is to
     update the `__outbuf' element of the step data structure to point
     after the last written byte.  This update gives the caller the
     information on how much text is available in the output buffer.
     In addition, the variable pointed to by the fifth parameter, which
     is of type `size_t', must be incremented by the number of
     characters (_not bytes_) that were converted in a non-reversible
     way.  Then, the function can return.

     In case the step is not the last one, the later conversion
     functions have to get a chance to do their work.  Therefore, the
     appropriate conversion function has to be called.  The information
     about the functions is stored in the conversion data structures,
     passed as the first parameter.  This information and the step data
     are stored in arrays, so the next element in both cases can be
     found by simple pointer arithmetic:

          int
          gconv (struct __gconv_step *step, struct __gconv_step_data *data,
                 const char **inbuf, const char *inbufend, size_t *written,
                 int do_flush)
          {
            struct __gconv_step *next_step = step + 1;
            struct __gconv_step_data *next_data = data + 1;
            ...

     The `next_step' pointer references the next step information and
     `next_data' the next data record.  The call of the next function
     therefore will look similar to this:

            next_step->__fct (next_step, next_data, &outerr, outbuf,
                              written, 0)

     But this is not yet all.  Once the function call returns the
     conversion function might have some more to do.  If the return
     value of the function is `__GCONV_EMPTY_INPUT', more room is
     available in the output buffer.  Unless the input buffer is empty
     the conversion, functions start all over again and process the
     rest of the input buffer.  If the return value is not
     `__GCONV_EMPTY_INPUT', something went wrong and we have to recover
     from this.

     A requirement for the conversion function is that the input buffer
     pointer (the third argument) always point to the last character
     that was put in converted form into the output buffer.  This is
     trivially true after the conversion performed in the current step,
     but if the conversion functions deeper downstream stop
     prematurely, not all characters from the output buffer are
     consumed and, therefore, the input buffer pointers must be backed
     off to the right position.

     Correcting the input buffers is easy to do if the input and output
     character sets have a fixed width for all characters.  In this
     situation we can compute how many characters are left in the
     output buffer and, therefore, can correct the input buffer pointer
     appropriately with a similar computation.  Things are getting
     tricky if either character set has characters represented with
     variable length byte sequences, and it gets even more complicated
     if the conversion has to take care of the state.  In these cases
     the conversion has to be performed once again, from the known
     state before the initial conversion (i.e., if necessary the state
     of the conversion has to be reset and the conversion loop has to be
     executed again).  The difference now is that it is known how much
     input must be created, and the conversion can stop before
     converting the first unused character.  Once this is done the
     input buffer pointers must be updated again and the function can
     return.

     One final thing should be mentioned.  If it is necessary for the
     conversion to know whether it is the first invocation (in case a
     prolog has to be emitted), the conversion function should
     increment the `__invocation_counter' element of the step data
     structure just before returning to the caller.  See the
     description of the `struct __gconv_step_data' structure above for
     more information on how this can be used.

     The return value must be one of the following values:

    `__GCONV_EMPTY_INPUT'
          All input was consumed and there is room left in the output
          buffer.

    `__GCONV_FULL_OUTPUT'
          No more room in the output buffer.  In case this is not the
          last step this value is propagated down from the call of the
          next conversion function in the chain.

    `__GCONV_INCOMPLETE_INPUT'
          The input buffer is not entirely empty since it contains an
          incomplete character sequence.

     The following example provides a framework for a conversion
     function.  In case a new conversion has to be written the holes in
     this implementation have to be filled and that is it.

          int
          gconv (struct __gconv_step *step, struct __gconv_step_data *data,
                 const char **inbuf, const char *inbufend, size_t *written,
                 int do_flush)
          {
            struct __gconv_step *next_step = step + 1;
            struct __gconv_step_data *next_data = data + 1;
            gconv_fct fct = next_step->__fct;
            int status;

            /* If the function is called with no input this means we have
               to reset to the initial state.  The possibly partly
               converted input is dropped.  */
            if (do_flush)
              {
                status = __GCONV_OK;

                /* Possible emit a byte sequence which put the state object
                   into the initial state.  */

                /* Call the steps down the chain if there are any but only
                   if we successfully emitted the escape sequence.  */
                if (status == __GCONV_OK && ! data->__is_last)
                  status = fct (next_step, next_data, NULL, NULL,
                                written, 1);
              }
            else
              {
                /* We preserve the initial values of the pointer variables.  */
                const char *inptr = *inbuf;
                char *outbuf = data->__outbuf;
                char *outend = data->__outbufend;
                char *outptr;

                do
                  {
                    /* Remember the start value for this round.  */
                    inptr = *inbuf;
                    /* The outbuf buffer is empty.  */
                    outptr = outbuf;

                    /* For stateful encodings the state must be safe here.  */

                    /* Run the conversion loop.  `status' is set
                       appropriately afterwards.  */

                    /* If this is the last step, leave the loop. There is
                       nothing we can do.  */
                    if (data->__is_last)
                      {
                        /* Store information about how many bytes are
                           available.  */
                        data->__outbuf = outbuf;

                       /* If any non-reversible conversions were performed,
                          add the number to `*written'.  */

                       break;
                     }

                    /* Write out all output that was produced.  */
                    if (outbuf > outptr)
                      {
                        const char *outerr = data->__outbuf;
                        int result;

                        result = fct (next_step, next_data, &outerr,
                                      outbuf, written, 0);

                        if (result != __GCONV_EMPTY_INPUT)
                          {
                            if (outerr != outbuf)
                              {
                                /* Reset the input buffer pointer.  We
                                   document here the complex case.  */
                                size_t nstatus;

                                /* Reload the pointers.  */
                                *inbuf = inptr;
                                outbuf = outptr;

                                /* Possibly reset the state.  */

                                /* Redo the conversion, but this time
                                   the end of the output buffer is at
                                   `outerr'.  */
                              }

                            /* Change the status.  */
                            status = result;
                          }
                        else
                          /* All the output is consumed, we can make
                              another run if everything was ok.  */
                          if (status == __GCONV_FULL_OUTPUT)
                            status = __GCONV_OK;
                     }
                  }
                while (status == __GCONV_OK);

                /* We finished one use of this step.  */
                ++data->__invocation_counter;
              }

            return status;
          }

   This information should be sufficient to write new modules.  Anybody
doing so should also take a look at the available source code in the GNU
C library sources.  It contains many examples of working and optimized
modules.


File: libc.info,  Node: Locales,  Next: Message Translation,  Prev: Character Set Handling,  Up: Top

7 Locales and Internationalization
**********************************

Different countries and cultures have varying conventions for how to
communicate.  These conventions range from very simple ones, such as the
format for representing dates and times, to very complex ones, such as
the language spoken.

   "Internationalization" of software means programming it to be able
to adapt to the user's favorite conventions.  In ISO C,
internationalization works by means of "locales".  Each locale
specifies a collection of conventions, one convention for each purpose.
The user chooses a set of conventions by specifying a locale (via
environment variables).

   All programs inherit the chosen locale as part of their environment.
Provided the programs are written to obey the choice of locale, they
will follow the conventions preferred by the user.

* Menu:

* Effects of Locale::           Actions affected by the choice of
                                 locale.
* Choosing Locale::             How the user specifies a locale.
* Locale Categories::           Different purposes for which you can
                                 select a locale.
* Setting the Locale::          How a program specifies the locale
                                 with library functions.
* Standard Locales::            Locale names available on all systems.
* Locale Information::          How to access the information for the locale.
* Formatting Numbers::          A dedicated function to format numbers.
* Yes-or-No Questions::         Check a Response against the locale.


File: libc.info,  Node: Effects of Locale,  Next: Choosing Locale,  Up: Locales

7.1 What Effects a Locale Has
=============================

Each locale specifies conventions for several purposes, including the
following:

   * What multibyte character sequences are valid, and how they are
     interpreted (*note Character Set Handling::).

   * Classification of which characters in the local character set are
     considered alphabetic, and upper- and lower-case conversion
     conventions (*note Character Handling::).

   * The collating sequence for the local language and character set
     (*note Collation Functions::).

   * Formatting of numbers and currency amounts (*note General
     Numeric::).

   * Formatting of dates and times (*note Formatting Calendar Time::).

   * What language to use for output, including error messages (*note
     Message Translation::).

   * What language to use for user answers to yes-or-no questions
     (*note Yes-or-No Questions::).

   * What language to use for more complex user input.  (The C library
     doesn't yet help you implement this.)

   Some aspects of adapting to the specified locale are handled
automatically by the library subroutines.  For example, all your program
needs to do in order to use the collating sequence of the chosen locale
is to use `strcoll' or `strxfrm' to compare strings.

   Other aspects of locales are beyond the comprehension of the library.
For example, the library can't automatically translate your program's
output messages into other languages.  The only way you can support
output in the user's favorite language is to program this more or less
by hand.  The C library provides functions to handle translations for
multiple languages easily.

   This chapter discusses the mechanism by which you can modify the
current locale.  The effects of the current locale on specific library
functions are discussed in more detail in the descriptions of those
functions.


File: libc.info,  Node: Choosing Locale,  Next: Locale Categories,  Prev: Effects of Locale,  Up: Locales

7.2 Choosing a Locale
=====================

The simplest way for the user to choose a locale is to set the
environment variable `LANG'.  This specifies a single locale to use for
all purposes.  For example, a user could specify a hypothetical locale
named `espana-castellano' to use the standard conventions of most of
Spain.

   The set of locales supported depends on the operating system you are
using, and so do their names.  We can't make any promises about what
locales will exist, except for one standard locale called `C' or
`POSIX'.  Later we will describe how to construct locales.

   A user also has the option of specifying different locales for
different purposes--in effect, choosing a mixture of multiple locales.

   For example, the user might specify the locale `espana-castellano'
for most purposes, but specify the locale `usa-english' for currency
formatting.  This might make sense if the user is a Spanish-speaking
American, working in Spanish, but representing monetary amounts in US
dollars.

   Note that both locales `espana-castellano' and `usa-english', like
all locales, would include conventions for all of the purposes to which
locales apply.  However, the user can choose to use each locale for a
particular subset of those purposes.


File: libc.info,  Node: Locale Categories,  Next: Setting the Locale,  Prev: Choosing Locale,  Up: Locales

7.3 Categories of Activities that Locales Affect
================================================

The purposes that locales serve are grouped into "categories", so that
a user or a program can choose the locale for each category
independently.  Here is a table of categories; each name is both an
environment variable that a user can set, and a macro name that you can
use as an argument to `setlocale'.

`LC_COLLATE'
     This category applies to collation of strings (functions `strcoll'
     and `strxfrm'); see *Note Collation Functions::.

`LC_CTYPE'
     This category applies to classification and conversion of
     characters, and to multibyte and wide characters; see *Note
     Character Handling::, and *Note Character Set Handling::.

`LC_MONETARY'
     This category applies to formatting monetary values; see *Note
     General Numeric::.

`LC_NUMERIC'
     This category applies to formatting numeric values that are not
     monetary; see *Note General Numeric::.

`LC_TIME'
     This category applies to formatting date and time values; see
     *Note Formatting Calendar Time::.

`LC_MESSAGES'
     This category applies to selecting the language used in the user
     interface for message translation (*note The Uniforum approach::;
     *note Message catalogs a la X/Open::)  and contains regular
     expressions for affirmative and negative responses.

`LC_ALL'
     This is not an environment variable; it is only a macro that you
     can use with `setlocale' to set a single locale for all purposes.
     Setting this environment variable overwrites all selections by the
     other `LC_*' variables or `LANG'.

`LANG'
     If this environment variable is defined, its value specifies the
     locale to use for all purposes except as overridden by the
     variables above.

   When developing the message translation functions it was felt that
the functionality provided by the variables above is not sufficient.
For example, it should be possible to specify more than one locale name.
Take a Swedish user who better speaks German than English, and a program
whose messages are output in English by default.  It should be possible
to specify that the first choice of language is Swedish, the second
German, and if this also fails to use English.  This is possible with
the variable `LANGUAGE'.  For further description of this GNU extension
see *Note Using gettextized software::.


File: libc.info,  Node: Setting the Locale,  Next: Standard Locales,  Prev: Locale Categories,  Up: Locales

7.4 How Programs Set the Locale
===============================

A C program inherits its locale environment variables when it starts up.
This happens automatically.  However, these variables do not
automatically control the locale used by the library functions, because
ISO C says that all programs start by default in the standard `C'
locale.  To use the locales specified by the environment, you must call
`setlocale'.  Call it as follows:

     setlocale (LC_ALL, "");

to select a locale based on the user choice of the appropriate
environment variables.

   You can also use `setlocale' to specify a particular locale, for
general use or for a specific category.

   The symbols in this section are defined in the header file
`locale.h'.

 -- Function: char * setlocale (int CATEGORY, const char *LOCALE)
     The function `setlocale' sets the current locale for category
     CATEGORY to LOCALE.  A list of all the locales the system provides
     can be created by running

            locale -a

     If CATEGORY is `LC_ALL', this specifies the locale for all
     purposes.  The other possible values of CATEGORY specify an single
     purpose (*note Locale Categories::).

     You can also use this function to find out the current locale by
     passing a null pointer as the LOCALE argument.  In this case,
     `setlocale' returns a string that is the name of the locale
     currently selected for category CATEGORY.

     The string returned by `setlocale' can be overwritten by subsequent
     calls, so you should make a copy of the string (*note Copying and
     Concatenation::) if you want to save it past any further calls to
     `setlocale'.  (The standard library is guaranteed never to call
     `setlocale' itself.)

     You should not modify the string returned by `setlocale'.  It might
     be the same string that was passed as an argument in a previous
     call to `setlocale'.  One requirement is that the CATEGORY must be
     the same in the call the string was returned and the one when the
     string is passed in as LOCALE parameter.

     When you read the current locale for category `LC_ALL', the value
     encodes the entire combination of selected locales for all
     categories.  In this case, the value is not just a single locale
     name.  In fact, we don't make any promises about what it looks
     like.  But if you specify the same "locale name" with `LC_ALL' in
     a subsequent call to `setlocale', it restores the same combination
     of locale selections.

     To be sure you can use the returned string encoding the currently
     selected locale at a later time, you must make a copy of the
     string.  It is not guaranteed that the returned pointer remains
     valid over time.

     When the LOCALE argument is not a null pointer, the string returned
     by `setlocale' reflects the newly-modified locale.

     If you specify an empty string for LOCALE, this means to read the
     appropriate environment variable and use its value to select the
     locale for CATEGORY.

     If a nonempty string is given for LOCALE, then the locale of that
     name is used if possible.

     If you specify an invalid locale name, `setlocale' returns a null
     pointer and leaves the current locale unchanged.

   Here is an example showing how you might use `setlocale' to
temporarily switch to a new locale.

     #include <stddef.h>
     #include <locale.h>
     #include <stdlib.h>
     #include <string.h>

     void
     with_other_locale (char *new_locale,
                        void (*subroutine) (int),
                        int argument)
     {
       char *old_locale, *saved_locale;

       /* Get the name of the current locale.  */
       old_locale = setlocale (LC_ALL, NULL);

       /* Copy the name so it won't be clobbered by `setlocale'. */
       saved_locale = strdup (old_locale);
       if (saved_locale == NULL)
         fatal ("Out of memory");

       /* Now change the locale and do some stuff with it. */
       setlocale (LC_ALL, new_locale);
       (*subroutine) (argument);

       /* Restore the original locale. */
       setlocale (LC_ALL, saved_locale);
       free (saved_locale);
     }

   *Portability Note:* Some ISO C systems may define additional locale
categories, and future versions of the library will do so.  For
portability, assume that any symbol beginning with `LC_' might be
defined in `locale.h'.


File: libc.info,  Node: Standard Locales,  Next: Locale Information,  Prev: Setting the Locale,  Up: Locales

7.5 Standard Locales
====================

The only locale names you can count on finding on all operating systems
are these three standard ones:

`"C"'
     This is the standard C locale.  The attributes and behavior it
     provides are specified in the ISO C standard.  When your program
     starts up, it initially uses this locale by default.

`"POSIX"'
     This is the standard POSIX locale.  Currently, it is an alias for
     the standard C locale.

`""'
     The empty name says to select a locale based on environment
     variables.  *Note Locale Categories::.

   Defining and installing named locales is normally a responsibility of
the system administrator at your site (or the person who installed the
GNU C library).  It is also possible for the user to create private
locales.  All this will be discussed later when describing the tool to
do so.

   If your program needs to use something other than the `C' locale, it
will be more portable if you use whatever locale the user specifies
with the environment, rather than trying to specify some non-standard
locale explicitly by name.  Remember, different machines might have
different sets of locales installed.


File: libc.info,  Node: Locale Information,  Next: Formatting Numbers,  Prev: Standard Locales,  Up: Locales

7.6 Accessing Locale Information
================================

There are several ways to access locale information.  The simplest way
is to let the C library itself do the work.  Several of the functions
in this library implicitly access the locale data, and use what
information is provided by the currently selected locale.  This is how
the locale model is meant to work normally.

   As an example take the `strftime' function, which is meant to nicely
format date and time information (*note Formatting Calendar Time::).
Part of the standard information contained in the `LC_TIME' category is
the names of the months.  Instead of requiring the programmer to take
care of providing the translations the `strftime' function does this
all by itself.  `%A' in the format string is replaced by the
appropriate weekday name of the locale currently selected by `LC_TIME'.
This is an easy example, and wherever possible functions do things
automatically in this way.

   But there are quite often situations when there is simply no function
to perform the task, or it is simply not possible to do the work
automatically.  For these cases it is necessary to access the
information in the locale directly.  To do this the C library provides
two functions: `localeconv' and `nl_langinfo'.  The former is part of
ISO C and therefore portable, but has a brain-damaged interface.  The
second is part of the Unix interface and is portable in as far as the
system follows the Unix standards.

* Menu:

* The Lame Way to Locale Data::   ISO C's `localeconv'.
* The Elegant and Fast Way::      X/Open's `nl_langinfo'.


File: libc.info,  Node: The Lame Way to Locale Data,  Next: The Elegant and Fast Way,  Up: Locale Information

7.6.1 `localeconv': It is portable but ...
------------------------------------------

Together with the `setlocale' function the ISO C people invented the
`localeconv' function.  It is a masterpiece of poor design.  It is
expensive to use, not extendable, and not generally usable as it
provides access to only `LC_MONETARY' and `LC_NUMERIC' related
information.  Nevertheless, if it is applicable to a given situation it
should be used since it is very portable.  The function `strfmon'
formats monetary amounts according to the selected locale using this
information.  

 -- Function: struct lconv * localeconv (void)
     The `localeconv' function returns a pointer to a structure whose
     components contain information about how numeric and monetary
     values should be formatted in the current locale.

     You should not modify the structure or its contents.  The
     structure might be overwritten by subsequent calls to
     `localeconv', or by calls to `setlocale', but no other function in
     the library overwrites this value.

 -- Data Type: struct lconv
     `localeconv''s return value is of this data type.  Its elements are
     described in the following subsections.

   If a member of the structure `struct lconv' has type `char', and the
value is `CHAR_MAX', it means that the current locale has no value for
that parameter.

* Menu:

* General Numeric::             Parameters for formatting numbers and
                                 currency amounts.
* Currency Symbol::             How to print the symbol that identifies an
                                 amount of money (e.g. `$').
* Sign of Money Amount::        How to print the (positive or negative) sign
                                 for a monetary amount, if one exists.


File: libc.info,  Node: General Numeric,  Next: Currency Symbol,  Up: The Lame Way to Locale Data

7.6.1.1 Generic Numeric Formatting Parameters
.............................................

These are the standard members of `struct lconv'; there may be others.

`char *decimal_point'
`char *mon_decimal_point'
     These are the decimal-point separators used in formatting
     non-monetary and monetary quantities, respectively.  In the `C'
     locale, the value of `decimal_point' is `"."', and the value of
     `mon_decimal_point' is `""'.  

`char *thousands_sep'
`char *mon_thousands_sep'
     These are the separators used to delimit groups of digits to the
     left of the decimal point in formatting non-monetary and monetary
     quantities, respectively.  In the `C' locale, both members have a
     value of `""' (the empty string).

`char *grouping'
`char *mon_grouping'
     These are strings that specify how to group the digits to the left
     of the decimal point.  `grouping' applies to non-monetary
     quantities and `mon_grouping' applies to monetary quantities.  Use
     either `thousands_sep' or `mon_thousands_sep' to separate the digit
     groups.  

     Each member of these strings is to be interpreted as an integer
     value of type `char'.  Successive numbers (from left to right)
     give the sizes of successive groups (from right to left, starting
     at the decimal point.)  The last member is either `0', in which
     case the previous member is used over and over again for all the
     remaining groups, or `CHAR_MAX', in which case there is no more
     grouping--or, put another way, any remaining digits form one large
     group without separators.

     For example, if `grouping' is `"\04\03\02"', the correct grouping
     for the number `123456787654321' is `12', `34', `56', `78', `765',
     `4321'.  This uses a group of 4 digits at the end, preceded by a
     group of 3 digits, preceded by groups of 2 digits (as many as
     needed).  With a separator of `,', the number would be printed as
     `12,34,56,78,765,4321'.

     A value of `"\03"' indicates repeated groups of three digits, as
     normally used in the U.S.

     In the standard `C' locale, both `grouping' and `mon_grouping'
     have a value of `""'.  This value specifies no grouping at all.

`char int_frac_digits'
`char frac_digits'
     These are small integers indicating how many fractional digits (to
     the right of the decimal point) should be displayed in a monetary
     value in international and local formats, respectively.  (Most
     often, both members have the same value.)

     In the standard `C' locale, both of these members have the value
     `CHAR_MAX', meaning "unspecified".  The ISO standard doesn't say
     what to do when you find this value; we recommend printing no
     fractional digits.  (This locale also specifies the empty string
     for `mon_decimal_point', so printing any fractional digits would be
     confusing!)


File: libc.info,  Node: Currency Symbol,  Next: Sign of Money Amount,  Prev: General Numeric,  Up: The Lame Way to Locale Data

7.6.1.2 Printing the Currency Symbol
....................................

These members of the `struct lconv' structure specify how to print the
symbol to identify a monetary value--the international analog of `$'
for US dollars.

   Each country has two standard currency symbols.  The "local currency
symbol" is used commonly within the country, while the "international
currency symbol" is used internationally to refer to that country's
currency when it is necessary to indicate the country unambiguously.

   For example, many countries use the dollar as their monetary unit,
and when dealing with international currencies it's important to specify
that one is dealing with (say) Canadian dollars instead of U.S. dollars
or Australian dollars.  But when the context is known to be Canada,
there is no need to make this explicit--dollar amounts are implicitly
assumed to be in Canadian dollars.

`char *currency_symbol'
     The local currency symbol for the selected locale.

     In the standard `C' locale, this member has a value of `""' (the
     empty string), meaning "unspecified".  The ISO standard doesn't
     say what to do when you find this value; we recommend you simply
     print the empty string as you would print any other string pointed
     to by this variable.

`char *int_curr_symbol'
     The international currency symbol for the selected locale.

     The value of `int_curr_symbol' should normally consist of a
     three-letter abbreviation determined by the international standard
     `ISO 4217 Codes for the Representation of Currency and Funds',
     followed by a one-character separator (often a space).

     In the standard `C' locale, this member has a value of `""' (the
     empty string), meaning "unspecified".  We recommend you simply
     print the empty string as you would print any other string pointed
     to by this variable.

`char p_cs_precedes'
`char n_cs_precedes'
`char int_p_cs_precedes'
`char int_n_cs_precedes'
     These members are `1' if the `currency_symbol' or
     `int_curr_symbol' strings should precede the value of a monetary
     amount, or `0' if the strings should follow the value.  The
     `p_cs_precedes' and `int_p_cs_precedes' members apply to positive
     amounts (or zero), and the `n_cs_precedes' and `int_n_cs_precedes'
     members apply to negative amounts.

     In the standard `C' locale, all of these members have a value of
     `CHAR_MAX', meaning "unspecified".  The ISO standard doesn't say
     what to do when you find this value.  We recommend printing the
     currency symbol before the amount, which is right for most
     countries.  In other words, treat all nonzero values alike in
     these members.

     The members with the `int_' prefix apply to the `int_curr_symbol'
     while the other two apply to `currency_symbol'.

`char p_sep_by_space'
`char n_sep_by_space'
`char int_p_sep_by_space'
`char int_n_sep_by_space'
     These members are `1' if a space should appear between the
     `currency_symbol' or `int_curr_symbol' strings and the amount, or
     `0' if no space should appear.  The `p_sep_by_space' and
     `int_p_sep_by_space' members apply to positive amounts (or zero),
     and the `n_sep_by_space' and `int_n_sep_by_space' members apply to
     negative amounts.

     In the standard `C' locale, all of these members have a value of
     `CHAR_MAX', meaning "unspecified".  The ISO standard doesn't say
     what you should do when you find this value; we suggest you treat
     it as 1 (print a space).  In other words, treat all nonzero values
     alike in these members.

     The members with the `int_' prefix apply to the `int_curr_symbol'
     while the other two apply to `currency_symbol'.  There is one
     specialty with the `int_curr_symbol', though.  Since all legal
     values contain a space at the end the string one either printf
     this space (if the currency symbol must appear in front and must
     be separated) or one has to avoid printing this character at all
     (especially when at the end of the string).


File: libc.info,  Node: Sign of Money Amount,  Prev: Currency Symbol,  Up: The Lame Way to Locale Data

7.6.1.3 Printing the Sign of a Monetary Amount
..............................................

These members of the `struct lconv' structure specify how to print the
sign (if any) of a monetary value.

`char *positive_sign'
`char *negative_sign'
     These are strings used to indicate positive (or zero) and negative
     monetary quantities, respectively.

     In the standard `C' locale, both of these members have a value of
     `""' (the empty string), meaning "unspecified".

     The ISO standard doesn't say what to do when you find this value;
     we recommend printing `positive_sign' as you find it, even if it is
     empty.  For a negative value, print `negative_sign' as you find it
     unless both it and `positive_sign' are empty, in which case print
     `-' instead.  (Failing to indicate the sign at all seems rather
     unreasonable.)

`char p_sign_posn'
`char n_sign_posn'
`char int_p_sign_posn'
`char int_n_sign_posn'
     These members are small integers that indicate how to position the
     sign for nonnegative and negative monetary quantities,
     respectively.  (The string used by the sign is what was specified
     with `positive_sign' or `negative_sign'.)  The possible values are
     as follows:

    `0'
          The currency symbol and quantity should be surrounded by
          parentheses.

    `1'
          Print the sign string before the quantity and currency symbol.

    `2'
          Print the sign string after the quantity and currency symbol.

    `3'
          Print the sign string right before the currency symbol.

    `4'
          Print the sign string right after the currency symbol.

    `CHAR_MAX'
          "Unspecified".  Both members have this value in the standard
          `C' locale.

     The ISO standard doesn't say what you should do when the value is
     `CHAR_MAX'.  We recommend you print the sign after the currency
     symbol.

     The members with the `int_' prefix apply to the `int_curr_symbol'
     while the other two apply to `currency_symbol'.


File: libc.info,  Node: The Elegant and Fast Way,  Prev: The Lame Way to Locale Data,  Up: Locale Information

7.6.2 Pinpoint Access to Locale Data
------------------------------------

When writing the X/Open Portability Guide the authors realized that the
`localeconv' function is not enough to provide reasonable access to
locale information.  The information which was meant to be available in
the locale (as later specified in the POSIX.1 standard) requires more
ways to access it.  Therefore the `nl_langinfo' function was introduced.

 -- Function: char * nl_langinfo (nl_item ITEM)
     The `nl_langinfo' function can be used to access individual
     elements of the locale categories.  Unlike the `localeconv'
     function, which returns all the information, `nl_langinfo' lets
     the caller select what information it requires.  This is very fast
     and it is not a problem to call this function multiple times.

     A second advantage is that in addition to the numeric and monetary
     formatting information, information from the `LC_TIME' and
     `LC_MESSAGES' categories is available.

     The type `nl_type' is defined in `nl_types.h'.  The argument ITEM
     is a numeric value defined in the header `langinfo.h'.  The X/Open
     standard defines the following values:

    `CODESET'
          `nl_langinfo' returns a string with the name of the coded
          character set used in the selected locale.

    `ABDAY_1'
    `ABDAY_2'
    `ABDAY_3'
    `ABDAY_4'
    `ABDAY_5'
    `ABDAY_6'
    `ABDAY_7'
          `nl_langinfo' returns the abbreviated weekday name.  `ABDAY_1'
          corresponds to Sunday.

    `DAY_1'
    `DAY_2'
    `DAY_3'
    `DAY_4'
    `DAY_5'
    `DAY_6'
    `DAY_7'
          Similar to `ABDAY_1' etc., but here the return value is the
          unabbreviated weekday name.

    `ABMON_1'
    `ABMON_2'
    `ABMON_3'
    `ABMON_4'
    `ABMON_5'
    `ABMON_6'
    `ABMON_7'
    `ABMON_8'
    `ABMON_9'
    `ABMON_10'
    `ABMON_11'
    `ABMON_12'
          The return value is abbreviated name of the month.  `ABMON_1'
          corresponds to January.

    `MON_1'
    `MON_2'
    `MON_3'
    `MON_4'
    `MON_5'
    `MON_6'
    `MON_7'
    `MON_8'
    `MON_9'
    `MON_10'
    `MON_11'
    `MON_12'
          Similar to `ABMON_1' etc., but here the month names are not
          abbreviated.  Here the first value `MON_1' also corresponds
          to January.

    `AM_STR'
    `PM_STR'
          The return values are strings which can be used in the
          representation of time as an hour from 1 to 12 plus an am/pm
          specifier.

          Note that in locales which do not use this time representation
          these strings might be empty, in which case the am/pm format
          cannot be used at all.

    `D_T_FMT'
          The return value can be used as a format string for
          `strftime' to represent time and date in a locale-specific
          way.

    `D_FMT'
          The return value can be used as a format string for
          `strftime' to represent a date in a locale-specific way.

    `T_FMT'
          The return value can be used as a format string for
          `strftime' to represent time in a locale-specific way.

    `T_FMT_AMPM'
          The return value can be used as a format string for
          `strftime' to represent time in the am/pm format.

          Note that if the am/pm format does not make any sense for the
          selected locale, the return value might be the same as the
          one for `T_FMT'.

    `ERA'
          The return value represents the era used in the current
          locale.

          Most locales do not define this value.  An example of a
          locale which does define this value is the Japanese one.  In
          Japan, the traditional representation of dates includes the
          name of the era corresponding to the then-emperor's reign.

          Normally it should not be necessary to use this value
          directly.  Specifying the `E' modifier in their format
          strings causes the `strftime' functions to use this
          information.  The format of the returned string is not
          specified, and therefore you should not assume knowledge of
          it on different systems.

    `ERA_YEAR'
          The return value gives the year in the relevant era of the
          locale.  As for `ERA' it should not be necessary to use this
          value directly.

    `ERA_D_T_FMT'
          This return value can be used as a format string for
          `strftime' to represent dates and times in a locale-specific
          era-based way.

    `ERA_D_FMT'
          This return value can be used as a format string for
          `strftime' to represent a date in a locale-specific era-based
          way.

    `ERA_T_FMT'
          This return value can be used as a format string for
          `strftime' to represent time in a locale-specific era-based
          way.

    `ALT_DIGITS'
          The return value is a representation of up to 100 values used
          to represent the values 0 to 99.  As for `ERA' this value is
          not intended to be used directly, but instead indirectly
          through the `strftime' function.  When the modifier `O' is
          used in a format which would otherwise use numerals to
          represent hours, minutes, seconds, weekdays, months, or
          weeks, the appropriate value for the locale is used instead.

    `INT_CURR_SYMBOL'
          The same as the value returned by `localeconv' in the
          `int_curr_symbol' element of the `struct lconv'.

    `CURRENCY_SYMBOL'
    `CRNCYSTR'
          The same as the value returned by `localeconv' in the
          `currency_symbol' element of the `struct lconv'.

          `CRNCYSTR' is a deprecated alias still required by Unix98.

    `MON_DECIMAL_POINT'
          The same as the value returned by `localeconv' in the
          `mon_decimal_point' element of the `struct lconv'.

    `MON_THOUSANDS_SEP'
          The same as the value returned by `localeconv' in the
          `mon_thousands_sep' element of the `struct lconv'.

    `MON_GROUPING'
          The same as the value returned by `localeconv' in the
          `mon_grouping' element of the `struct lconv'.

    `POSITIVE_SIGN'
          The same as the value returned by `localeconv' in the
          `positive_sign' element of the `struct lconv'.

    `NEGATIVE_SIGN'
          The same as the value returned by `localeconv' in the
          `negative_sign' element of the `struct lconv'.

    `INT_FRAC_DIGITS'
          The same as the value returned by `localeconv' in the
          `int_frac_digits' element of the `struct lconv'.

    `FRAC_DIGITS'
          The same as the value returned by `localeconv' in the
          `frac_digits' element of the `struct lconv'.

    `P_CS_PRECEDES'
          The same as the value returned by `localeconv' in the
          `p_cs_precedes' element of the `struct lconv'.

    `P_SEP_BY_SPACE'
          The same as the value returned by `localeconv' in the
          `p_sep_by_space' element of the `struct lconv'.

    `N_CS_PRECEDES'
          The same as the value returned by `localeconv' in the
          `n_cs_precedes' element of the `struct lconv'.

    `N_SEP_BY_SPACE'
          The same as the value returned by `localeconv' in the
          `n_sep_by_space' element of the `struct lconv'.

    `P_SIGN_POSN'
          The same as the value returned by `localeconv' in the
          `p_sign_posn' element of the `struct lconv'.

    `N_SIGN_POSN'
          The same as the value returned by `localeconv' in the
          `n_sign_posn' element of the `struct lconv'.

    `INT_P_CS_PRECEDES'
          The same as the value returned by `localeconv' in the
          `int_p_cs_precedes' element of the `struct lconv'.

    `INT_P_SEP_BY_SPACE'
          The same as the value returned by `localeconv' in the
          `int_p_sep_by_space' element of the `struct lconv'.

    `INT_N_CS_PRECEDES'
          The same as the value returned by `localeconv' in the
          `int_n_cs_precedes' element of the `struct lconv'.

    `INT_N_SEP_BY_SPACE'
          The same as the value returned by `localeconv' in the
          `int_n_sep_by_space' element of the `struct lconv'.

    `INT_P_SIGN_POSN'
          The same as the value returned by `localeconv' in the
          `int_p_sign_posn' element of the `struct lconv'.

    `INT_N_SIGN_POSN'
          The same as the value returned by `localeconv' in the
          `int_n_sign_posn' element of the `struct lconv'.

    `DECIMAL_POINT'
    `RADIXCHAR'
          The same as the value returned by `localeconv' in the
          `decimal_point' element of the `struct lconv'.

          The name `RADIXCHAR' is a deprecated alias still used in
          Unix98.

    `THOUSANDS_SEP'
    `THOUSEP'
          The same as the value returned by `localeconv' in the
          `thousands_sep' element of the `struct lconv'.

          The name `THOUSEP' is a deprecated alias still used in Unix98.

    `GROUPING'
          The same as the value returned by `localeconv' in the
          `grouping' element of the `struct lconv'.

    `YESEXPR'
          The return value is a regular expression which can be used
          with the `regex' function to recognize a positive response to
          a yes/no question.  The GNU C library provides the `rpmatch'
          function for easier handling in applications.

    `NOEXPR'
          The return value is a regular expression which can be used
          with the `regex' function to recognize a negative response to
          a yes/no question.

    `YESSTR'
          The return value is a locale-specific translation of the
          positive response to a yes/no question.

          Using this value is deprecated since it is a very special
          case of message translation, and is better handled by the
          message translation functions (*note Message Translation::).

          The use of this symbol is deprecated.  Instead message
          translation should be used.

    `NOSTR'
          The return value is a locale-specific translation of the
          negative response to a yes/no question.  What is said for
          `YESSTR' is also true here.

          The use of this symbol is deprecated.  Instead message
          translation should be used.

     The file `langinfo.h' defines a lot more symbols but none of them
     is official.  Using them is not portable, and the format of the
     return values might change.  Therefore we recommended you not use
     them.

     Note that the return value for any valid argument can be used for
     in all situations (with the possible exception of the am/pm time
     formatting codes).  If the user has not selected any locale for the
     appropriate category, `nl_langinfo' returns the information from
     the `"C"' locale.  It is therefore possible to use this function as
     shown in the example below.

     If the argument ITEM is not valid, a pointer to an empty string is
     returned.

   An example of `nl_langinfo' usage is a function which has to print a
given date and time in a locale-specific way.  At first one might think
that, since `strftime' internally uses the locale information, writing
something like the following is enough:

     size_t
     i18n_time_n_data (char *s, size_t len, const struct tm *tp)
     {
       return strftime (s, len, "%X %D", tp);
     }

   The format contains no weekday or month names and therefore is
internationally usable.  Wrong!  The output produced is something like
`"hh:mm:ss MM/DD/YY"'.  This format is only recognizable in the USA.
Other countries use different formats.  Therefore the function should
be rewritten like this:

     size_t
     i18n_time_n_data (char *s, size_t len, const struct tm *tp)
     {
       return strftime (s, len, nl_langinfo (D_T_FMT), tp);
     }

   Now it uses the date and time format of the locale selected when the
program runs.  If the user selects the locale correctly there should
never be a misunderstanding over the time and date format.


File: libc.info,  Node: Formatting Numbers,  Next: Yes-or-No Questions,  Prev: Locale Information,  Up: Locales

7.7 A dedicated function to format numbers
==========================================

We have seen that the structure returned by `localeconv' as well as the
values given to `nl_langinfo' allow you to retrieve the various pieces
of locale-specific information to format numbers and monetary amounts.
We have also seen that the underlying rules are quite complex.

   Therefore the X/Open standards introduce a function which uses such
locale information, making it easier for the user to format numbers
according to these rules.

 -- Function: ssize_t strfmon (char *S, size_t MAXSIZE, const char
          *FORMAT, ...)
     The `strfmon' function is similar to the `strftime' function in
     that it takes a buffer, its size, a format string, and values to
     write into the buffer as text in a form specified by the format
     string.  Like `strftime', the function also returns the number of
     bytes written into the buffer.

     There are two differences: `strfmon' can take more than one
     argument, and, of course, the format specification is different.
     Like `strftime', the format string consists of normal text, which
     is output as is, and format specifiers, which are indicated by a
     `%'.  Immediately after the `%', you can optionally specify
     various flags and formatting information before the main
     formatting character, in a similar way to `printf':

        * Immediately following the `%' there can be one or more of the
          following flags:
         `=F'
               The single byte character F is used for this field as
               the numeric fill character.  By default this character
               is a space character.  Filling with this character is
               only performed if a left precision is specified.  It is
               not just to fill to the given field width.

         `^'
               The number is printed without grouping the digits
               according to the rules of the current locale.  By
               default grouping is enabled.

         `+', `('
               At most one of these flags can be used.  They select
               which format to represent the sign of a currency amount.
               By default, and if `+' is given, the locale equivalent
               of +/- is used.  If `(' is given, negative amounts are
               enclosed in parentheses.  The exact format is determined
               by the values of the `LC_MONETARY' category of the
               locale selected at program runtime.

         `!'
               The output will not contain the currency symbol.

         `-'
               The output will be formatted left-justified instead of
               right-justified if it does not fill the entire field
               width.

     The next part of a specification is an optional field width.  If no
     width is specified 0 is taken.  During output, the function first
     determines how much space is required.  If it requires at least as
     many characters as given by the field width, it is output using as
     much space as necessary.  Otherwise, it is extended to use the
     full width by filling with the space character.  The presence or
     absence of the `-' flag determines the side at which such padding
     occurs.  If present, the spaces are added at the right making the
     output left-justified, and vice versa.

     So far the format looks familiar, being similar to the `printf' and
     `strftime' formats.  However, the next two optional fields
     introduce something new.  The first one is a `#' character followed
     by a decimal digit string.  The value of the digit string
     specifies the number of _digit_ positions to the left of the
     decimal point (or equivalent).  This does _not_ include the
     grouping character when the `^' flag is not given.  If the space
     needed to print the number does not fill the whole width, the
     field is padded at the left side with the fill character, which
     can be selected using the `=' flag and by default is a space.  For
     example, if the field width is selected as 6 and the number is
     123, the fill character is `*' the result will be `***123'.

     The second optional field starts with a `.' (period) and consists
     of another decimal digit string.  Its value describes the number of
     characters printed after the decimal point.  The default is
     selected from the current locale (`frac_digits',
     `int_frac_digits', see *note General Numeric::).  If the exact
     representation needs more digits than given by the field width,
     the displayed value is rounded.  If the number of fractional
     digits is selected to be zero, no decimal point is printed.

     As a GNU extension, the `strfmon' implementation in the GNU libc
     allows an optional `L' next as a format modifier.  If this modifier
     is given, the argument is expected to be a `long double' instead of
     a `double' value.

     Finally, the last component is a format specifier.  There are three
     specifiers defined:

    `i'
          Use the locale's rules for formatting an international
          currency value.

    `n'
          Use the locale's rules for formatting a national currency
          value.

    `%'
          Place a `%' in the output.  There must be no flag, width
          specifier or modifier given, only `%%' is allowed.

     As for `printf', the function reads the format string from left to
     right and uses the values passed to the function following the
     format string.  The values are expected to be either of type
     `double' or `long double', depending on the presence of the
     modifier `L'.  The result is stored in the buffer pointed to by S.
     At most MAXSIZE characters are stored.

     The return value of the function is the number of characters
     stored in S, including the terminating `NULL' byte.  If the number
     of characters stored would exceed MAXSIZE, the function returns -1
     and the content of the buffer S is unspecified.  In this case
     `errno' is set to `E2BIG'.

   A few examples should make clear how the function works.  It is
assumed that all the following pieces of code are executed in a program
which uses the USA locale (`en_US').  The simplest form of the format
is this:

     strfmon (buf, 100, "@%n@%n@%n@", 123.45, -567.89, 12345.678);

The output produced is
     "@$123.45@-$567.89@$12,345.68@"

   We can notice several things here.  First, the widths of the output
numbers are different.  We have not specified a width in the format
string, and so this is no wonder.  Second, the third number is printed
using thousands separators.  The thousands separator for the `en_US'
locale is a comma.  The number is also rounded.  .678 is rounded to .68
since the format does not specify a precision and the default value in
the locale is 2.  Finally, note that the national currency symbol is
printed since `%n' was used, not `i'.  The next example shows how we
can align the output.

     strfmon (buf, 100, "@%=*11n@%=*11n@%=*11n@", 123.45, -567.89, 12345.678);

The output this time is:

     "@    $123.45@   -$567.89@ $12,345.68@"

   Two things stand out.  Firstly, all fields have the same width
(eleven characters) since this is the width given in the format and
since no number required more characters to be printed.  The second
important point is that the fill character is not used.  This is
correct since the white space was not used to achieve a precision given
by a `#' modifier, but instead to fill to the given width.  The
difference becomes obvious if we now add a width specification.

     strfmon (buf, 100, "@%=*11#5n@%=*11#5n@%=*11#5n@",
              123.45, -567.89, 12345.678);

The output is

     "@ $***123.45@-$***567.89@ $12,456.68@"

   Here we can see that all the currency symbols are now aligned, and
that the space between the currency sign and the number is filled with
the selected fill character.  Note that although the width is selected
to be 5 and 123.45 has three digits left of the decimal point, the
space is filled with three asterisks.  This is correct since, as
explained above, the width does not include the positions used to store
thousands separators.  One last example should explain the remaining
functionality.

     strfmon (buf, 100, "@%=0(16#5.3i@%=0(16#5.3i@%=0(16#5.3i@",
              123.45, -567.89, 12345.678);

This rather complex format string produces the following output:

     "@ USD 000123,450 @(USD 000567.890)@ USD 12,345.678 @"

   The most noticeable change is the alternative way of representing
negative numbers.  In financial circles this is often done using
parentheses, and this is what the `(' flag selected.  The fill
character is now `0'.  Note that this `0' character is not regarded as
a numeric zero, and therefore the first and second numbers are not
printed using a thousands separator.  Since we used the format
specifier `i' instead of `n', the international form of the currency
symbol is used.  This is a four letter string, in this case `"USD "'.
The last point is that since the precision right of the decimal point
is selected to be three, the first and second numbers are printed with
an extra zero at the end and the third number is printed without
rounding.


File: libc.info,  Node: Yes-or-No Questions,  Prev: Formatting Numbers,  Up: Locales

7.8 Yes-or-No Questions
=======================

Some non GUI programs ask a yes-or-no question.  If the messages
(especially the questions) are translated into foreign languages, be
sure that you localize the answers too.  It would be very bad habit to
ask a question in one language and request the answer in another, often
English.

   The GNU C library contains `rpmatch' to give applications easy
access to the corresponding locale definitions.

 -- Function: int rpmatch (const char *RESPONSE)
     The function `rpmatch' checks the string in RESPONSE whether or
     not it is a correct yes-or-no answer and if yes, which one.  The
     check uses the `YESEXPR' and `NOEXPR' data in the `LC_MESSAGES'
     category of the currently selected locale.  The return value is as
     follows:

    `1'
          The user entered an affirmative answer.

    `0'
          The user entered a negative answer.

    `-1'
          The answer matched neither the `YESEXPR' nor the `NOEXPR'
          regular expression.

     This function is not standardized but available beside in GNU libc
     at least also in the IBM AIX library.

This function would normally be used like this:

       ...
       /* Use a safe default.  */
       _Bool doit = false;

       fputs (gettext ("Do you really want to do this? "), stdout);
       fflush (stdout);
       /* Prepare the `getline' call.  */
       line = NULL;
       len = 0;
       while (getline (&line, &len, stdin) >= 0)
         {
           /* Check the response.  */
           int res = rpmatch (line);
           if (res >= 0)
             {
               /* We got a definitive answer.  */
               if (res > 0)
                 doit = true;
               break;
             }
         }
       /* Free what `getline' allocated.  */
       free (line);

   Note that the loop continues until an read error is detected or
until a definitive (positive or negative) answer is read.


File: libc.info,  Node: Message Translation,  Next: Searching and Sorting,  Prev: Locales,  Up: Top

8 Message Translation
*********************

The program's interface with the human should be designed in a way to
ease the human the task.  One of the possibilities is to use messages in
whatever language the user prefers.

   Printing messages in different languages can be implemented in
different ways.  One could add all the different languages in the
source code and add among the variants every time a message has to be
printed.  This is certainly no good solution since extending the set of
languages is difficult (the code must be changed) and the code itself
can become really big with dozens of message sets.

   A better solution is to keep the message sets for each language are
kept in separate files which are loaded at runtime depending on the
language selection of the user.

   The GNU C Library provides two different sets of functions to support
message translation.  The problem is that neither of the interfaces is
officially defined by the POSIX standard.  The `catgets' family of
functions is defined in the X/Open standard but this is derived from
industry decisions and therefore not necessarily based on reasonable
decisions.

   As mentioned above the message catalog handling provides easy
extendibility by using external data files which contain the message
translations.  I.e., these files contain for each of the messages used
in the program a translation for the appropriate language.  So the tasks
of the message handling functions are

   * locate the external data file with the appropriate translations.

   * load the data and make it possible to address the messages

   * map a given key to the translated message

   The two approaches mainly differ in the implementation of this last
step.  The design decisions made for this influences the whole rest.

* Menu:

* Message catalogs a la X/Open::  The `catgets' family of functions.
* The Uniforum approach::         The `gettext' family of functions.


File: libc.info,  Node: Message catalogs a la X/Open,  Next: The Uniforum approach,  Up: Message Translation

8.1 X/Open Message Catalog Handling
===================================

The `catgets' functions are based on the simple scheme:

     Associate every message to translate in the source code with a
     unique identifier.  To retrieve a message from a catalog file
     solely the identifier is used.

   This means for the author of the program that s/he will have to make
sure the meaning of the identifier in the program code and in the
message catalogs are always the same.

   Before a message can be translated the catalog file must be located.
The user of the program must be able to guide the responsible function
to find whatever catalog the user wants.  This is separated from what
the programmer had in mind.

   All the types, constants and functions for the `catgets' functions
are defined/declared in the `nl_types.h' header file.

* Menu:

* The catgets Functions::      The `catgets' function family.
* The message catalog files::  Format of the message catalog files.
* The gencat program::         How to generate message catalogs files which
                                can be used by the functions.
* Common Usage::               How to use the `catgets' interface.


File: libc.info,  Node: The catgets Functions,  Next: The message catalog files,  Up: Message catalogs a la X/Open

8.1.1 The `catgets' function family
-----------------------------------

 -- Function: nl_catd catopen (const char *CAT_NAME, int FLAG)
     The `catgets' function tries to locate the message data file names
     CAT_NAME and loads it when found.  The return value is of an
     opaque type and can be used in calls to the other functions to
     refer to this loaded catalog.

     The return value is `(nl_catd) -1' in case the function failed and
     no catalog was loaded.  The global variable ERRNO contains a code
     for the error causing the failure.  But even if the function call
     succeeded this does not mean that all messages can be translated.

     Locating the catalog file must happen in a way which lets the user
     of the program influence the decision.  It is up to the user to
     decide about the language to use and sometimes it is useful to use
     alternate catalog files.  All this can be specified by the user by
     setting some environment variables.

     The first problem is to find out where all the message catalogs are
     stored.  Every program could have its own place to keep all the
     different files but usually the catalog files are grouped by
     languages and the catalogs for all programs are kept in the same
     place.

     To tell the `catopen' function where the catalog for the program
     can be found the user can set the environment variable `NLSPATH' to
     a value which describes her/his choice.  Since this value must be
     usable for different languages and locales it cannot be a simple
     string.  Instead it is a format string (similar to `printf''s).
     An example is

          /usr/share/locale/%L/%N:/usr/share/locale/%L/LC_MESSAGES/%N

     First one can see that more than one directory can be specified
     (with the usual syntax of separating them by colons).  The next
     things to observe are the format string, `%L' and `%N' in this
     case.  The `catopen' function knows about several of them and the
     replacement for all of them is of course different.

    `%N'
          This format element is substituted with the name of the
          catalog file.  This is the value of the CAT_NAME argument
          given to `catgets'.

    `%L'
          This format element is substituted with the name of the
          currently selected locale for translating messages.  How this
          is determined is explained below.

    `%l'
          (This is the lowercase ell.) This format element is
          substituted with the language element of the locale name.
          The string describing the selected locale is expected to have
          the form `LANG[_TERR[.CODESET]]' and this format uses the
          first part LANG.

    `%t'
          This format element is substituted by the territory part TERR
          of the name of the currently selected locale.  See the
          explanation of the format above.

    `%c'
          This format element is substituted by the codeset part
          CODESET of the name of the currently selected locale.  See
          the explanation of the format above.

    `%%'
          Since `%' is used in a meta character there must be a way to
          express the `%' character in the result itself.  Using `%%'
          does this just like it works for `printf'.

     Using `NLSPATH' allows arbitrary directories to be searched for
     message catalogs while still allowing different languages to be
     used.  If the `NLSPATH' environment variable is not set, the
     default value is

          PREFIX/share/locale/%L/%N:PREFIX/share/locale/%L/LC_MESSAGES/%N

     where PREFIX is given to `configure' while installing the GNU C
     Library (this value is in many cases `/usr' or the empty string).

     The remaining problem is to decide which must be used.  The value
     decides about the substitution of the format elements mentioned
     above.  First of all the user can specify a path in the message
     catalog name (i.e., the name contains a slash character).  In this
     situation the `NLSPATH' environment variable is not used.  The
     catalog must exist as specified in the program, perhaps relative
     to the current working directory.  This situation in not desirable
     and catalogs names never should be written this way.  Beside this,
     this behavior is not portable to all other platforms providing the
     `catgets' interface.

     Otherwise the values of environment variables from the standard
     environment are examined (*note Standard Environment::).  Which
     variables are examined is decided by the FLAG parameter of
     `catopen'.  If the value is `NL_CAT_LOCALE' (which is defined in
     `nl_types.h') then the `catopen' function use the name of the
     locale currently selected for the `LC_MESSAGES' category.

     If FLAG is zero the `LANG' environment variable is examined.  This
     is a left-over from the early days where the concept of the locales
     had not even reached the level of POSIX locales.

     The environment variable and the locale name should have a value
     of the form `LANG[_TERR[.CODESET]]' as explained above.  If no
     environment variable is set the `"C"' locale is used which
     prevents any translation.

     The return value of the function is in any case a valid string.
     Either it is a translation from a message catalog or it is the
     same as the STRING parameter.  So a piece of code to decide
     whether a translation actually happened must look like this:

          {
            char *trans = catgets (desc, set, msg, input_string);
            if (trans == input_string)
              {
                /* Something went wrong.  */
              }
          }

     When an error occurred the global variable ERRNO is set to

    EBADF
          The catalog does not exist.

    ENOMSG
          The set/message tuple does not name an existing element in the
          message catalog.

     While it sometimes can be useful to test for errors programs
     normally will avoid any test.  If the translation is not available
     it is no big problem if the original, untranslated message is
     printed.  Either the user understands this as well or s/he will
     look for the reason why the messages are not translated.

   Please note that the currently selected locale does not depend on a
call to the `setlocale' function.  It is not necessary that the locale
data files for this locale exist and calling `setlocale' succeeds.  The
`catopen' function directly reads the values of the environment
variables.

 -- Function: char * catgets (nl_catd CATALOG_DESC, int SET, int
          MESSAGE, const char *STRING)
     The function `catgets' has to be used to access the massage catalog
     previously opened using the `catopen' function.  The CATALOG_DESC
     parameter must be a value previously returned by `catopen'.

     The next two parameters, SET and MESSAGE, reflect the internal
     organization of the message catalog files.  This will be explained
     in detail below.  For now it is interesting to know that a catalog
     can consists of several set and the messages in each thread are
     individually numbered using numbers.  Neither the set number nor
     the message number must be consecutive.  They can be arbitrarily
     chosen.  But each message (unless equal to another one) must have
     its own unique pair of set and message number.

     Since it is not guaranteed that the message catalog for the
     language selected by the user exists the last parameter STRING
     helps to handle this case gracefully.  If no matching string can
     be found STRING is returned.  This means for the programmer that

        * the STRING parameters should contain reasonable text (this
          also helps to understand the program seems otherwise there
          would be no hint on the string which is expected to be
          returned.

        * all STRING arguments should be written in the same language.

   It is somewhat uncomfortable to write a program using the `catgets'
functions if no supporting functionality is available.  Since each
set/message number tuple must be unique the programmer must keep lists
of the messages at the same time the code is written.  And the work
between several people working on the same project must be coordinated.
We will see some how these problems can be relaxed a bit (*note Common
Usage::).

 -- Function: int catclose (nl_catd CATALOG_DESC)
     The `catclose' function can be used to free the resources
     associated with a message catalog which previously was opened by a
     call to `catopen'.  If the resources can be successfully freed the
     function returns `0'.  Otherwise it return `-1' and the global
     variable ERRNO is set.  Errors can occur if the catalog descriptor
     CATALOG_DESC is not valid in which case ERRNO is set to `EBADF'.


File: libc.info,  Node: The message catalog files,  Next: The gencat program,  Prev: The catgets Functions,  Up: Message catalogs a la X/Open

8.1.2 Format of the message catalog files
-----------------------------------------

The only reasonable way the translate all the messages of a function and
store the result in a message catalog file which can be read by the
`catopen' function is to write all the message text to the translator
and let her/him translate them all.  I.e., we must have a file with
entries which associate the set/message tuple with a specific
translation.  This file format is specified in the X/Open standard and
is as follows:

   * Lines containing only whitespace characters or empty lines are
     ignored.

   * Lines which contain as the first non-whitespace character a `$'
     followed by a whitespace character are comment and are also
     ignored.

   * If a line contains as the first non-whitespace characters the
     sequence `$set' followed by a whitespace character an additional
     argument is required to follow.  This argument can either be:

        - a number.  In this case the value of this number determines
          the set to which the following messages are added.

        - an identifier consisting of alphanumeric characters plus the
          underscore character.  In this case the set get automatically
          a number assigned.  This value is one added to the largest
          set number which so far appeared.

          How to use the symbolic names is explained in section *Note
          Common Usage::.

          It is an error if a symbol name appears more than once.  All
          following messages are placed in a set with this number.

   * If a line contains as the first non-whitespace characters the
     sequence `$delset' followed by a whitespace character an
     additional argument is required to follow.  This argument can
     either be:

        - a number.  In this case the value of this number determines
          the set which will be deleted.

        - an identifier consisting of alphanumeric characters plus the
          underscore character.  This symbolic identifier must match a
          name for a set which previously was defined.  It is an error
          if the name is unknown.

     In both cases all messages in the specified set will be removed.
     They will not appear in the output.  But if this set is later
     again selected with a `$set' command again messages could be added
     and these messages will appear in the output.

   * If a line contains after leading whitespaces the sequence
     `$quote', the quoting character used for this input file is
     changed to the first non-whitespace character following the
     `$quote'.  If no non-whitespace character is present before the
     line ends quoting is disable.

     By default no quoting character is used.  In this mode strings are
     terminated with the first unescaped line break.  If there is a
     `$quote' sequence present newline need not be escaped.  Instead a
     string is terminated with the first unescaped appearance of the
     quote character.

     A common usage of this feature would be to set the quote character
     to `"'.  Then any appearance of the `"' in the strings must be
     escaped using the backslash (i.e., `\"' must be written).

   * Any other line must start with a number or an alphanumeric
     identifier (with the underscore character included).  The
     following characters (starting after the first whitespace
     character) will form the string which gets associated with the
     currently selected set and the message number represented by the
     number and identifier respectively.

     If the start of the line is a number the message number is
     obvious.  It is an error if the same message number already
     appeared for this set.

     If the leading token was an identifier the message number gets
     automatically assigned.  The value is the current maximum messages
     number for this set plus one.  It is an error if the identifier was
     already used for a message in this set.  It is OK to reuse the
     identifier for a message in another thread.  How to use the
     symbolic identifiers will be explained below (*note Common
     Usage::).  There is one limitation with the identifier: it must
     not be `Set'.  The reason will be explained below.

     The text of the messages can contain escape characters.  The usual
     bunch of characters known from the ISO C language are recognized
     (`\n', `\t', `\v', `\b', `\r', `\f', `\\', and `\NNN', where NNN
     is the octal coding of a character code).

   *Important:* The handling of identifiers instead of numbers for the
set and messages is a GNU extension.  Systems strictly following the
X/Open specification do not have this feature.  An example for a message
catalog file is this:

     $ This is a leading comment.
     $quote "

     $set SetOne
     1 Message with ID 1.
     two "   Message with ID \"two\", which gets the value 2 assigned"

     $set SetTwo
     $ Since the last set got the number 1 assigned this set has number 2.
     4000 "The numbers can be arbitrary, they need not start at one."

   This small example shows various aspects:
   * Lines 1 and 9 are comments since they start with `$' followed by a
     whitespace.

   * The quoting character is set to `"'.  Otherwise the quotes in the
     message definition would have to be left away and in this case the
     message with the identifier `two' would loose its leading
     whitespace.

   * Mixing numbered messages with message having symbolic names is no
     problem and the numbering happens automatically.

   While this file format is pretty easy it is not the best possible for
use in a running program.  The `catopen' function would have to parser
the file and handle syntactic errors gracefully.  This is not so easy
and the whole process is pretty slow.  Therefore the `catgets'
functions expect the data in another more compact and ready-to-use file
format.  There is a special program `gencat' which is explained in
detail in the next section.

   Files in this other format are not human readable.  To be easy to
use by programs it is a binary file.  But the format is byte order
independent so translation files can be shared by systems of arbitrary
architecture (as long as they use the GNU C Library).

   Details about the binary file format are not important to know since
these files are always created by the `gencat' program.  The sources of
the GNU C Library also provide the sources for the `gencat' program and
so the interested reader can look through these source files to learn
about the file format.


File: libc.info,  Node: The gencat program,  Next: Common Usage,  Prev: The message catalog files,  Up: Message catalogs a la X/Open

8.1.3 Generate Message Catalogs files
-------------------------------------

The `gencat' program is specified in the X/Open standard and the GNU
implementation follows this specification and so processes all
correctly formed input files.  Additionally some extension are
implemented which help to work in a more reasonable way with the
`catgets' functions.

   The `gencat' program can be invoked in two ways:

     `gencat [OPTION]... [OUTPUT-FILE [INPUT-FILE]...]`

   This is the interface defined in the X/Open standard.  If no
INPUT-FILE parameter is given input will be read from standard input.
Multiple input files will be read as if they are concatenated.  If
OUTPUT-FILE is also missing, the output will be written to standard
output.  To provide the interface one is used to from other programs a
second interface is provided.

     `gencat [OPTION]... -o OUTPUT-FILE [INPUT-FILE]...`

   The option `-o' is used to specify the output file and all file
arguments are used as input files.

   Beside this one can use `-' or `/dev/stdin' for INPUT-FILE to denote
the standard input.  Corresponding one can use `-' and `/dev/stdout'
for OUTPUT-FILE to denote standard output.  Using `-' as a file name is
allowed in X/Open while using the device names is a GNU extension.

   The `gencat' program works by concatenating all input files and then
*merge* the resulting collection of message sets with a possibly
existing output file.  This is done by removing all messages with
set/message number tuples matching any of the generated messages from
the output file and then adding all the new messages.  To regenerate a
catalog file while ignoring the old contents therefore requires to
remove the output file if it exists.  If the output is written to
standard output no merging takes place.

The following table shows the options understood by the `gencat'
program.  The X/Open standard does not specify any option for the
program so all of these are GNU extensions.

`-V'
`--version'
     Print the version information and exit.

`-h'
`--help'
     Print a usage message listing all available options, then exit
     successfully.

`--new'
     Do never merge the new messages from the input files with the old
     content of the output files.  The old content of the output file
     is discarded.

`-H'
`--header=name'
     This option is used to emit the symbolic names given to sets and
     messages in the input files for use in the program.  Details about
     how to use this are given in the next section.  The NAME parameter
     to this option specifies the name of the output file.  It will
     contain a number of C preprocessor `#define's to associate a name
     with a number.

     Please note that the generated file only contains the symbols from
     the input files.  If the output is merged with the previous
     content of the output file the possibly existing symbols from the
     file(s) which generated the old output files are not in the
     generated header file.


File: libc.info,  Node: Common Usage,  Prev: The gencat program,  Up: Message catalogs a la X/Open

8.1.4 How to use the `catgets' interface
----------------------------------------

The `catgets' functions can be used in two different ways.  By
following slavishly the X/Open specs and not relying on the extension
and by using the GNU extensions.  We will take a look at the former
method first to understand the benefits of extensions.

8.1.4.1 Not using symbolic names
................................

Since the X/Open format of the message catalog files does not allow
symbol names we have to work with numbers all the time.  When we start
writing a program we have to replace all appearances of translatable
strings with something like

     catgets (catdesc, set, msg, "string")

CATGETS is retrieved from a call to `catopen' which is normally done
once at the program start.  The `"string"' is the string we want to
translate.  The problems start with the set and message numbers.

   In a bigger program several programmers usually work at the same
time on the program and so coordinating the number allocation is
crucial.  Though no two different strings must be indexed by the same
tuple of numbers it is highly desirable to reuse the numbers for equal
strings with equal translations (please note that there might be
strings which are equal in one language but have different translations
due to difference contexts).

   The allocation process can be relaxed a bit by different set numbers
for different parts of the program.  So the number of developers who
have to coordinate the allocation can be reduced.  But still lists must
be keep track of the allocation and errors can easily happen.  These
errors cannot be discovered by the compiler or the `catgets' functions.
Only the user of the program might see wrong messages printed.  In the
worst cases the messages are so irritating that they cannot be
recognized as wrong.  Think about the translations for `"true"' and
`"false"' being exchanged.  This could result in a disaster.

8.1.4.2 Using symbolic names
............................

The problems mentioned in the last section derive from the fact that:

  1. the numbers are allocated once and due to the possibly frequent
     use of them it is difficult to change a number later.

  2. the numbers do not allow to guess anything about the string and
     therefore collisions can easily happen.

   By constantly using symbolic names and by providing a method which
maps the string content to a symbolic name (however this will happen)
one can prevent both problems above.  The cost of this is that the
programmer has to write a complete message catalog file while s/he is
writing the program itself.

   This is necessary since the symbolic names must be mapped to numbers
before the program sources can be compiled.  In the last section it was
described how to generate a header containing the mapping of the names.
E.g., for the example message file given in the last section we could
call the `gencat' program as follow (assume `ex.msg' contains the
sources).

     gencat -H ex.h -o ex.cat ex.msg

This generates a header file with the following content:

     #define SetTwoSet 0x2   /* ex.msg:8 */

     #define SetOneSet 0x1   /* ex.msg:4 */
     #define SetOnetwo 0x2   /* ex.msg:6 */

   As can be seen the various symbols given in the source file are
mangled to generate unique identifiers and these identifiers get numbers
assigned.  Reading the source file and knowing about the rules will
allow to predict the content of the header file (it is deterministic)
but this is not necessary.  The `gencat' program can take care for
everything.  All the programmer has to do is to put the generated header
file in the dependency list of the source files of her/his project and
to add a rules to regenerate the header of any of the input files
change.

   One word about the symbol mangling.  Every symbol consists of two
parts: the name of the message set plus the name of the message or the
special string `Set'.  So `SetOnetwo' means this macro can be used to
access the translation with identifier `two' in the message set
`SetOne'.

   The other names denote the names of the message sets.  The special
string `Set' is used in the place of the message identifier.

   If in the code the second string of the set `SetOne' is used the C
code should look like this:

     catgets (catdesc, SetOneSet, SetOnetwo,
              "   Message with ID \"two\", which gets the value 2 assigned")

   Writing the function this way will allow to change the message number
and even the set number without requiring any change in the C source
code.  (The text of the string is normally not the same; this is only
for this example.)

8.1.4.3 How does to this allow to develop
.........................................

To illustrate the usual way to work with the symbolic version numbers
here is a little example.  Assume we want to write the very complex and
famous greeting program.  We start by writing the code as usual:

     #include <stdio.h>
     int
     main (void)
     {
       printf ("Hello, world!\n");
       return 0;
     }

   Now we want to internationalize the message and therefore replace the
message with whatever the user wants.

     #include <nl_types.h>
     #include <stdio.h>
     #include "msgnrs.h"
     int
     main (void)
     {
       nl_catd catdesc = catopen ("hello.cat", NL_CAT_LOCALE);
       printf (catgets (catdesc, SetMainSet, SetMainHello,
                        "Hello, world!\n"));
       catclose (catdesc);
       return 0;
     }

   We see how the catalog object is opened and the returned descriptor
used in the other function calls.  It is not really necessary to check
for failure of any of the functions since even in these situations the
functions will behave reasonable.  They simply will be return a
translation.

   What remains unspecified here are the constants `SetMainSet' and
`SetMainHello'.  These are the symbolic names describing the message.
To get the actual definitions which match the information in the
catalog file we have to create the message catalog source file and
process it using the `gencat' program.

     $ Messages for the famous greeting program.
     $quote "

     $set Main
     Hello "Hallo, Welt!\n"

   Now we can start building the program (assume the message catalog
source file is named `hello.msg' and the program source file `hello.c'):

     % gencat -H msgnrs.h -o hello.cat hello.msg
     % cat msgnrs.h
     #define MainSet 0x1     /* hello.msg:4 */
     #define MainHello 0x1   /* hello.msg:5 */
     % gcc -o hello hello.c -I.
     % cp hello.cat /usr/share/locale/de/LC_MESSAGES
     % echo $LC_ALL
     de
     % ./hello
     Hallo, Welt!
     %

   The call of the `gencat' program creates the missing header file
`msgnrs.h' as well as the message catalog binary.  The former is used
in the compilation of `hello.c' while the later is placed in a
directory in which the `catopen' function will try to locate it.
Please check the `LC_ALL' environment variable and the default path for
`catopen' presented in the description above.


File: libc.info,  Node: The Uniforum approach,  Prev: Message catalogs a la X/Open,  Up: Message Translation

8.2 The Uniforum approach to Message Translation
================================================

Sun Microsystems tried to standardize a different approach to message
translation in the Uniforum group.  There never was a real standard
defined but still the interface was used in Sun's operation systems.
Since this approach fits better in the development process of free
software it is also used throughout the GNU project and the GNU
`gettext' package provides support for this outside the GNU C Library.

   The code of the `libintl' from GNU `gettext' is the same as the code
in the GNU C Library.  So the documentation in the GNU `gettext' manual
is also valid for the functionality here.  The following text will
describe the library functions in detail.  But the numerous helper
programs are not described in this manual.  Instead people should read
the GNU `gettext' manual (*note GNU gettext utilities: (gettext)Top.).
We will only give a short overview.

   Though the `catgets' functions are available by default on more
systems the `gettext' interface is at least as portable as the former.
The GNU `gettext' package can be used wherever the functions are not
available.

* Menu:

* Message catalogs with gettext::  The `gettext' family of functions.
* Helper programs for gettext::    Programs to handle message catalogs
                                    for `gettext'.


File: libc.info,  Node: Message catalogs with gettext,  Next: Helper programs for gettext,  Up: The Uniforum approach

8.2.1 The `gettext' family of functions
---------------------------------------

The paradigms underlying the `gettext' approach to message translations
is different from that of the `catgets' functions the basic
functionally is equivalent.  There are functions of the following
categories:

* Menu:

* Translation with gettext::       What has to be done to translate a message.
* Locating gettext catalog::       How to determine which catalog to be used.
* Advanced gettext functions::     Additional functions for more complicated
                                    situations.
* Charset conversion in gettext::  How to specify the output character set
                                    `gettext' uses.
* GUI program problems::           How to use `gettext' in GUI programs.
* Using gettextized software::     The possibilities of the user to influence
                                    the way `gettext' works.


File: libc.info,  Node: Translation with gettext,  Next: Locating gettext catalog,  Up: Message catalogs with gettext

8.2.1.1 What has to be done to translate a message?
...................................................

The `gettext' functions have a very simple interface.  The most basic
function just takes the string which shall be translated as the
argument and it returns the translation.  This is fundamentally
different from the `catgets' approach where an extra key is necessary
and the original string is only used for the error case.

   If the string which has to be translated is the only argument this of
course means the string itself is the key.  I.e., the translation will
be selected based on the original string.  The message catalogs must
therefore contain the original strings plus one translation for any such
string.  The task of the `gettext' function is it to compare the
argument string with the available strings in the catalog and return the
appropriate translation.  Of course this process is optimized so that
this process is not more expensive than an access using an atomic key
like in `catgets'.

   The `gettext' approach has some advantages but also some
disadvantages.  Please see the GNU `gettext' manual for a detailed
discussion of the pros and cons.

   All the definitions and declarations for `gettext' can be found in
the `libintl.h' header file.  On systems where these functions are not
part of the C library they can be found in a separate library named
`libintl.a' (or accordingly different for shared libraries).

 -- Function: char * gettext (const char *MSGID)
     The `gettext' function searches the currently selected message
     catalogs for a string which is equal to MSGID.  If there is such a
     string available it is returned.  Otherwise the argument string
     MSGID is returned.

     Please note that all though the return value is `char *' the
     returned string must not be changed.  This broken type results
     from the history of the function and does not reflect the way the
     function should be used.

     Please note that above we wrote "message catalogs" (plural).  This
     is a specialty of the GNU implementation of these functions and we
     will say more about this when we talk about the ways message
     catalogs are selected (*note Locating gettext catalog::).

     The `gettext' function does not modify the value of the global
     ERRNO variable.  This is necessary to make it possible to write
     something like

            printf (gettext ("Operation failed: %m\n"));

     Here the ERRNO value is used in the `printf' function while
     processing the `%m' format element and if the `gettext' function
     would change this value (it is called before `printf' is called)
     we would get a wrong message.

     So there is no easy way to detect a missing message catalog beside
     comparing the argument string with the result.  But it is normally
     the task of the user to react on missing catalogs.  The program
     cannot guess when a message catalog is really necessary since for
     a user who speaks the language the program was developed in does
     not need any translation.

   The remaining two functions to access the message catalog add some
functionality to select a message catalog which is not the default one.
This is important if parts of the program are developed independently.
Every part can have its own message catalog and all of them can be used
at the same time.  The C library itself is an example: internally it
uses the `gettext' functions but since it must not depend on a
currently selected default message catalog it must specify all ambiguous
information.

 -- Function: char * dgettext (const char *DOMAINNAME, const char
          *MSGID)
     The `dgettext' functions acts just like the `gettext' function.
     It only takes an additional first argument DOMAINNAME which guides
     the selection of the message catalogs which are searched for the
     translation.  If the DOMAINNAME parameter is the null pointer the
     `dgettext' function is exactly equivalent to `gettext' since the
     default value for the domain name is used.

     As for `gettext' the return value type is `char *' which is an
     anachronism.  The returned string must never be modified.

 -- Function: char * dcgettext (const char *DOMAINNAME, const char
          *MSGID, int CATEGORY)
     The `dcgettext' adds another argument to those which `dgettext'
     takes.  This argument CATEGORY specifies the last piece of
     information needed to localize the message catalog.  I.e., the
     domain name and the locale category exactly specify which message
     catalog has to be used (relative to a given directory, see below).

     The `dgettext' function can be expressed in terms of `dcgettext'
     by using

          dcgettext (domain, string, LC_MESSAGES)

     instead of

          dgettext (domain, string)

     This also shows which values are expected for the third parameter.
     One has to use the available selectors for the categories
     available in `locale.h'.  Normally the available values are
     `LC_CTYPE', `LC_COLLATE', `LC_MESSAGES', `LC_MONETARY',
     `LC_NUMERIC', and `LC_TIME'.  Please note that `LC_ALL' must not
     be used and even though the names might suggest this, there is no
     relation to the environments variables of this name.

     The `dcgettext' function is only implemented for compatibility with
     other systems which have `gettext' functions.  There is not really
     any situation where it is necessary (or useful) to use a different
     value but `LC_MESSAGES' in for the CATEGORY parameter.  We are
     dealing with messages here and any other choice can only be
     irritating.

     As for `gettext' the return value type is `char *' which is an
     anachronism.  The returned string must never be modified.

   When using the three functions above in a program it is a frequent
case that the MSGID argument is a constant string.  So it is worth to
optimize this case.  Thinking shortly about this one will realize that
as long as no new message catalog is loaded the translation of a message
will not change.  This optimization is actually implemented by the
`gettext', `dgettext' and `dcgettext' functions.


File: libc.info,  Node: Locating gettext catalog,  Next: Advanced gettext functions,  Prev: Translation with gettext,  Up: Message catalogs with gettext

8.2.1.2 How to determine which catalog to be used
.................................................

The functions to retrieve the translations for a given message have a
remarkable simple interface.  But to provide the user of the program
still the opportunity to select exactly the translation s/he wants and
also to provide the programmer the possibility to influence the way to
locate the search for catalogs files there is a quite complicated
underlying mechanism which controls all this.  The code is complicated
the use is easy.

   Basically we have two different tasks to perform which can also be
performed by the `catgets' functions:

  1. Locate the set of message catalogs.  There are a number of files
     for different languages and which all belong to the package.
     Usually they are all stored in the filesystem below a certain
     directory.

     There can be arbitrary many packages installed and they can follow
     different guidelines for the placement of their files.

  2. Relative to the location specified by the package the actual
     translation files must be searched, based on the wishes of the
     user.  I.e., for each language the user selects the program should
     be able to locate the appropriate file.

   This is the functionality required by the specifications for
`gettext' and this is also what the `catgets' functions are able to do.
But there are some problems unresolved:

   * The language to be used can be specified in several different ways.
     There is no generally accepted standard for this and the user
     always expects the program understand what s/he means.  E.g., to
     select the German translation one could write `de', `german', or
     `deutsch' and the program should always react the same.

   * Sometimes the specification of the user is too detailed.  If s/he,
     e.g., specifies `de_DE.ISO-8859-1' which means German, spoken in
     Germany, coded using the ISO 8859-1 character set there is the
     possibility that a message catalog matching this exactly is not
     available.  But there could be a catalog matching `de' and if the
     character set used on the machine is always ISO 8859-1 there is no
     reason why this later message catalog should not be used.  (We
     call this "message inheritance".)

   * If a catalog for a wanted language is not available it is not
     always the second best choice to fall back on the language of the
     developer and simply not translate any message.  Instead a user
     might be better able to read the messages in another language and
     so the user of the program should be able to define an precedence
     order of languages.

   We can divide the configuration actions in two parts: the one is
performed by the programmer, the other by the user.  We will start with
the functions the programmer can use since the user configuration will
be based on this.

   As the functions described in the last sections already mention
separate sets of messages can be selected by a "domain name".  This is a
simple string which should be unique for each program part with uses a
separate domain.  It is possible to use in one program arbitrary many
domains at the same time.  E.g., the GNU C Library itself uses a domain
named `libc' while the program using the C Library could use a domain
named `foo'.  The important point is that at any time exactly one
domain is active.  This is controlled with the following function.

 -- Function: char * textdomain (const char *DOMAINNAME)
     The `textdomain' function sets the default domain, which is used in
     all future `gettext' calls, to DOMAINNAME.  Please note that
     `dgettext' and `dcgettext' calls are not influenced if the
     DOMAINNAME parameter of these functions is not the null pointer.

     Before the first call to `textdomain' the default domain is
     `messages'.  This is the name specified in the specification of
     the `gettext' API.  This name is as good as any other name.  No
     program should ever really use a domain with this name since this
     can only lead to problems.

     The function returns the value which is from now on taken as the
     default domain.  If the system went out of memory the returned
     value is `NULL' and the global variable ERRNO is set to `ENOMEM'.
     Despite the return value type being `char *' the return string must
     not be changed.  It is allocated internally by the `textdomain'
     function.

     If the DOMAINNAME parameter is the null pointer no new default
     domain is set.  Instead the currently selected default domain is
     returned.

     If the DOMAINNAME parameter is the empty string the default domain
     is reset to its initial value, the domain with the name `messages'.
     This possibility is questionable to use since the domain `messages'
     really never should be used.

 -- Function: char * bindtextdomain (const char *DOMAINNAME, const char
          *DIRNAME)
     The `bindtextdomain' function can be used to specify the directory
     which contains the message catalogs for domain DOMAINNAME for the
     different languages.  To be correct, this is the directory where
     the hierarchy of directories is expected.  Details are explained
     below.

     For the programmer it is important to note that the translations
     which come with the program have be placed in a directory
     hierarchy starting at, say, `/foo/bar'.  Then the program should
     make a `bindtextdomain' call to bind the domain for the current
     program to this directory.  So it is made sure the catalogs are
     found.  A correctly running program does not depend on the user
     setting an environment variable.

     The `bindtextdomain' function can be used several times and if the
     DOMAINNAME argument is different the previously bound domains will
     not be overwritten.

     If the program which wish to use `bindtextdomain' at some point of
     time use the `chdir' function to change the current working
     directory it is important that the DIRNAME strings ought to be an
     absolute pathname.  Otherwise the addressed directory might vary
     with the time.

     If the DIRNAME parameter is the null pointer `bindtextdomain'
     returns the currently selected directory for the domain with the
     name DOMAINNAME.

     The `bindtextdomain' function returns a pointer to a string
     containing the name of the selected directory name.  The string is
     allocated internally in the function and must not be changed by the
     user.  If the system went out of core during the execution of
     `bindtextdomain' the return value is `NULL' and the global
     variable ERRNO is set accordingly.


File: libc.info,  Node: Advanced gettext functions,  Next: Charset conversion in gettext,  Prev: Locating gettext catalog,  Up: Message catalogs with gettext

8.2.1.3 Additional functions for more complicated situations
............................................................

The functions of the `gettext' family described so far (and all the
`catgets' functions as well) have one problem in the real world which
have been neglected completely in all existing approaches.  What is
meant here is the handling of plural forms.

   Looking through Unix source code before the time anybody thought
about internationalization (and, sadly, even afterwards) one can often
find code similar to the following:

        printf ("%d file%s deleted", n, n == 1 ? "" : "s");

After the first complaints from people internationalizing the code
people either completely avoided formulations like this or used strings
like `"file(s)"'.  Both look unnatural and should be avoided.  First
tries to solve the problem correctly looked like this:

        if (n == 1)
          printf ("%d file deleted", n);
        else
          printf ("%d files deleted", n);

   But this does not solve the problem.  It helps languages where the
plural form of a noun is not simply constructed by adding an `s' but
that is all.  Once again people fell into the trap of believing the
rules their language is using are universal.  But the handling of plural
forms differs widely between the language families.  There are two
things we can differ between (and even inside language families);

   * The form how plural forms are build differs.  This is a problem
     with language which have many irregularities.  German, for
     instance, is a drastic case.  Though English and German are part
     of the same language family (Germanic), the almost regular forming
     of plural noun forms (appending an `s') is hardly found in German.

   * The number of plural forms differ.  This is somewhat surprising for
     those who only have experiences with Romanic and Germanic languages
     since here the number is the same (there are two).

     But other language families have only one form or many forms.  More
     information on this in an extra section.

   The consequence of this is that application writers should not try to
solve the problem in their code.  This would be localization since it is
only usable for certain, hardcoded language environments.  Instead the
extended `gettext' interface should be used.

   These extra functions are taking instead of the one key string two
strings and an numerical argument.  The idea behind this is that using
the numerical argument and the first string as a key, the implementation
can select using rules specified by the translator the right plural
form.  The two string arguments then will be used to provide a return
value in case no message catalog is found (similar to the normal
`gettext' behavior).  In this case the rules for Germanic language is
used and it is assumed that the first string argument is the singular
form, the second the plural form.

   This has the consequence that programs without language catalogs can
display the correct strings only if the program itself is written using
a Germanic language.  This is a limitation but since the GNU C library
(as well as the GNU `gettext' package) are written as part of the GNU
package and the coding standards for the GNU project require program
being written in English, this solution nevertheless fulfills its
purpose.

 -- Function: char * ngettext (const char *MSGID1, const char *MSGID2,
          unsigned long int N)
     The `ngettext' function is similar to the `gettext' function as it
     finds the message catalogs in the same way.  But it takes two
     extra arguments.  The MSGID1 parameter must contain the singular
     form of the string to be converted.  It is also used as the key
     for the search in the catalog.  The MSGID2 parameter is the plural
     form.  The parameter N is used to determine the plural form.  If no
     message catalog is found MSGID1 is returned if `n == 1', otherwise
     `msgid2'.

     An example for the us of this function is:

            printf (ngettext ("%d file removed", "%d files removed", n), n);

     Please note that the numeric value N has to be passed to the
     `printf' function as well.  It is not sufficient to pass it only to
     `ngettext'.

 -- Function: char * dngettext (const char *DOMAIN, const char *MSGID1,
          const char *MSGID2, unsigned long int N)
     The `dngettext' is similar to the `dgettext' function in the way
     the message catalog is selected.  The difference is that it takes
     two extra parameter to provide the correct plural form.  These two
     parameters are handled in the same way `ngettext' handles them.

 -- Function: char * dcngettext (const char *DOMAIN, const char
          *MSGID1, const char *MSGID2, unsigned long int N, int
          CATEGORY)
     The `dcngettext' is similar to the `dcgettext' function in the way
     the message catalog is selected.  The difference is that it takes
     two extra parameter to provide the correct plural form.  These two
     parameters are handled in the same way `ngettext' handles them.

The problem of plural forms
...........................

A description of the problem can be found at the beginning of the last
section.  Now there is the question how to solve it.  Without the input
of linguists (which was not available) it was not possible to determine
whether there are only a few different forms in which plural forms are
formed or whether the number can increase with every new supported
language.

   Therefore the solution implemented is to allow the translator to
specify the rules of how to select the plural form.  Since the formula
varies with every language this is the only viable solution except for
hardcoding the information in the code (which still would require the
possibility of extensions to not prevent the use of new languages).  The
details are explained in the GNU `gettext' manual.  Here only a bit of
information is provided.

   The information about the plural form selection has to be stored in
the header entry (the one with the empty (`msgid' string).  It looks
like this:

     Plural-Forms: nplurals=2; plural=n == 1 ? 0 : 1;

   The `nplurals' value must be a decimal number which specifies how
many different plural forms exist for this language.  The string
following `plural' is an expression which is using the C language
syntax.  Exceptions are that no negative number are allowed, numbers
must be decimal, and the only variable allowed is `n'.  This expression
will be evaluated whenever one of the functions `ngettext',
`dngettext', or `dcngettext' is called.  The numeric value passed to
these functions is then substituted for all uses of the variable `n' in
the expression.  The resulting value then must be greater or equal to
zero and smaller than the value given as the value of `nplurals'.

The following rules are known at this point.  The language with families
are listed.  But this does not necessarily mean the information can be
generalized for the whole family (as can be easily seen in the table
below).(1)

Only one form:
     Some languages only require one single form.  There is no
     distinction between the singular and plural form.  An appropriate
     header entry would look like this:

          Plural-Forms: nplurals=1; plural=0;

     Languages with this property include:

    Finno-Ugric family
          Hungarian

    Asian family
          Japanese, Korean

    Turkic/Altaic family
          Turkish

Two forms, singular used for one only
     This is the form used in most existing programs since it is what
     English is using.  A header entry would look like this:

          Plural-Forms: nplurals=2; plural=n != 1;

     (Note: this uses the feature of C expressions that boolean
     expressions have to value zero or one.)

     Languages with this property include:

    Germanic family
          Danish, Dutch, English, German, Norwegian, Swedish

    Finno-Ugric family
          Estonian, Finnish

    Latin/Greek family
          Greek

    Semitic family
          Hebrew

    Romance family
          Italian, Portuguese, Spanish

    Artificial
          Esperanto

Two forms, singular used for zero and one
     Exceptional case in the language family.  The header entry would
     be:

          Plural-Forms: nplurals=2; plural=n>1;

     Languages with this property include:

    Romanic family
          French, Brazilian Portuguese

Three forms, special case for zero
     The header entry would be:

          Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n != 0 ? 1 : 2;

     Languages with this property include:

    Baltic family
          Latvian

Three forms, special cases for one and two
     The header entry would be:

          Plural-Forms: nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2;

     Languages with this property include:

    Celtic
          Gaeilge (Irish)

Three forms, special case for numbers ending in 1[2-9]
     The header entry would look like this:

          Plural-Forms: nplurals=3; \
              plural=n%10==1 && n%100!=11 ? 0 : \
                     n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2;

     Languages with this property include:

    Baltic family
          Lithuanian

Three forms, special cases for numbers ending in 1 and 2, 3, 4, except those ending in 1[1-4]
     The header entry would look like this:

          Plural-Forms: nplurals=3; \
              plural=n%100/10==1 ? 2 : n%10==1 ? 0 : (n+9)%10>3 ? 2 : 1;

     Languages with this property include:

    Slavic family
          Croatian, Czech, Russian, Ukrainian

Three forms, special cases for 1 and 2, 3, 4
     The header entry would look like this:

          Plural-Forms: nplurals=3; \
              plural=(n==1) ? 1 : (n>=2 && n<=4) ? 2 : 0;

     Languages with this property include:

    Slavic family
          Slovak

Three forms, special case for one and some numbers ending in 2, 3, or 4
     The header entry would look like this:

          Plural-Forms: nplurals=3; \
              plural=n==1 ? 0 : \
                     n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;

     Languages with this property include:

    Slavic family
          Polish

Four forms, special case for one and all numbers ending in 02, 03, or 04
     The header entry would look like this:

          Plural-Forms: nplurals=4; \
              plural=n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3;

     Languages with this property include:

    Slavic family
          Slovenian

   ---------- Footnotes ----------

   (1) Additions are welcome.  Send appropriate information to
<bug-glibc-manual@gnu.org>.


File: libc.info,  Node: Charset conversion in gettext,  Next: GUI program problems,  Prev: Advanced gettext functions,  Up: Message catalogs with gettext

8.2.1.4 How to specify the output character set `gettext' uses
..............................................................

`gettext' not only looks up a translation in a message catalog.  It
also converts the translation on the fly to the desired output character
set.  This is useful if the user is working in a different character set
than the translator who created the message catalog, because it avoids
distributing variants of message catalogs which differ only in the
character set.

   The output character set is, by default, the value of `nl_langinfo
(CODESET)', which depends on the `LC_CTYPE' part of the current locale.
But programs which store strings in a locale independent way (e.g.
UTF-8) can request that `gettext' and related functions return the
translations in that encoding, by use of the `bind_textdomain_codeset'
function.

   Note that the MSGID argument to `gettext' is not subject to
character set conversion.  Also, when `gettext' does not find a
translation for MSGID, it returns MSGID unchanged - independently of
the current output character set.  It is therefore recommended that all
MSGIDs be US-ASCII strings.

 -- Function: char * bind_textdomain_codeset (const char *DOMAINNAME,
          const char *CODESET)
     The `bind_textdomain_codeset' function can be used to specify the
     output character set for message catalogs for domain DOMAINNAME.
     The CODESET argument must be a valid codeset name which can be used
     for the `iconv_open' function, or a null pointer.

     If the CODESET parameter is the null pointer,
     `bind_textdomain_codeset' returns the currently selected codeset
     for the domain with the name DOMAINNAME. It returns `NULL' if no
     codeset has yet been selected.

     The `bind_textdomain_codeset' function can be used several times.
     If used multiple times with the same DOMAINNAME argument, the
     later call overrides the settings made by the earlier one.

     The `bind_textdomain_codeset' function returns a pointer to a
     string containing the name of the selected codeset.  The string is
     allocated internally in the function and must not be changed by the
     user.  If the system went out of core during the execution of
     `bind_textdomain_codeset', the return value is `NULL' and the
     global variable ERRNO is set accordingly.


File: libc.info,  Node: GUI program problems,  Next: Using gettextized software,  Prev: Charset conversion in gettext,  Up: Message catalogs with gettext

8.2.1.5 How to use `gettext' in GUI programs
............................................

One place where the `gettext' functions, if used normally, have big
problems is within programs with graphical user interfaces (GUIs).  The
problem is that many of the strings which have to be translated are very
short.  They have to appear in pull-down menus which restricts the
length.  But strings which are not containing entire sentences or at
least large fragments of a sentence may appear in more than one
situation in the program but might have different translations.  This is
especially true for the one-word strings which are frequently used in
GUI programs.

   As a consequence many people say that the `gettext' approach is
wrong and instead `catgets' should be used which indeed does not have
this problem.  But there is a very simple and powerful method to handle
these kind of problems with the `gettext' functions.

As an example consider the following fictional situation.  A GUI program
has a menu bar with the following entries:

     +------------+------------+--------------------------------------+
     | File       | Printer    |                                      |
     +------------+------------+--------------------------------------+
     | Open     | | Select   |
     | New      | | Open     |
     +----------+ | Connect  |
                  +----------+

   To have the strings `File', `Printer', `Open', `New', `Select', and
`Connect' translated there has to be at some point in the code a call
to a function of the `gettext' family.  But in two places the string
passed into the function would be `Open'.  The translations might not
be the same and therefore we are in the dilemma described above.

   One solution to this problem is to artificially enlengthen the
strings to make them unambiguous.  But what would the program do if no
translation is available?  The enlengthened string is not what should be
printed.  So we should use a little bit modified version of the
functions.

   To enlengthen the strings a uniform method should be used.  E.g., in
the example above the strings could be chosen as

     Menu|File
     Menu|Printer
     Menu|File|Open
     Menu|File|New
     Menu|Printer|Select
     Menu|Printer|Open
     Menu|Printer|Connect

   Now all the strings are different and if now instead of `gettext'
the following little wrapper function is used, everything works just
fine:

       char *
       sgettext (const char *msgid)
       {
         char *msgval = gettext (msgid);
         if (msgval == msgid)
           msgval = strrchr (msgid, '|') + 1;
         return msgval;
       }

   What this little function does is to recognize the case when no
translation is available.  This can be done very efficiently by a
pointer comparison since the return value is the input value.  If there
is no translation we know that the input string is in the format we used
for the Menu entries and therefore contains a `|' character.  We simply
search for the last occurrence of this character and return a pointer
to the character following it.  That's it!

   If one now consistently uses the enlengthened string form and
replaces the `gettext' calls with calls to `sgettext' (this is normally
limited to very few places in the GUI implementation) then it is
possible to produce a program which can be internationalized.

   With advanced compilers (such as GNU C) one can write the `sgettext'
functions as an inline function or as a macro like this:

     #define sgettext(msgid) \
       ({ const char *__msgid = (msgid);            \
          char *__msgstr = gettext (__msgid);       \
          if (__msgval == __msgid)                  \
            __msgval = strrchr (__msgid, '|') + 1;  \
          __msgval; })

   The other `gettext' functions (`dgettext', `dcgettext' and the
`ngettext' equivalents) can and should have corresponding functions as
well which look almost identical, except for the parameters and the
call to the underlying function.

   Now there is of course the question why such functions do not exist
in the GNU C library?  There are two parts of the answer to this
question.

   * They are easy to write and therefore can be provided by the
     project they are used in.  This is not an answer by itself and
     must be seen together with the second part which is:

   * There is no way the C library can contain a version which can work
     everywhere.  The problem is the selection of the character to
     separate the prefix from the actual string in the enlenghtened
     string.  The examples above used `|' which is a quite good choice
     because it resembles a notation frequently used in this context
     and it also is a character not often used in message strings.

     But what if the character is used in message strings.  Or if the
     chose character is not available in the character set on the
     machine one compiles (e.g., `|' is not required to exist for
     ISO C; this is why the `iso646.h' file exists in ISO C programming
     environments).

   There is only one more comment to make left.  The wrapper function
above require that the translations strings are not enlengthened
themselves.  This is only logical.  There is no need to disambiguate
the strings (since they are never used as keys for a search) and one
also saves quite some memory and disk space by doing this.


File: libc.info,  Node: Using gettextized software,  Prev: GUI program problems,  Up: Message catalogs with gettext

8.2.1.6 User influence on `gettext'
...................................

The last sections described what the programmer can do to
internationalize the messages of the program.  But it is finally up to
the user to select the message s/he wants to see.  S/He must understand
them.

   The POSIX locale model uses the environment variables `LC_COLLATE',
`LC_CTYPE', `LC_MESSAGES', `LC_MONETARY', `LC_NUMERIC', and `LC_TIME'
to select the locale which is to be used.  This way the user can
influence lots of functions.  As we mentioned above the `gettext'
functions also take advantage of this.

   To understand how this happens it is necessary to take a look at the
various components of the filename which gets computed to locate a
message catalog.  It is composed as follows:

     DIR_NAME/LOCALE/LC_CATEGORY/DOMAIN_NAME.mo

   The default value for DIR_NAME is system specific.  It is computed
from the value given as the prefix while configuring the C library.
This value normally is `/usr' or `/'.  For the former the complete
DIR_NAME is:

     /usr/share/locale

   We can use `/usr/share' since the `.mo' files containing the message
catalogs are system independent, so all systems can use the same files.
If the program executed the `bindtextdomain' function for the message
domain that is currently handled, the `dir_name' component is exactly
the value which was given to the function as the second parameter.
I.e., `bindtextdomain' allows overwriting the only system dependent and
fixed value to make it possible to address files anywhere in the
filesystem.

   The CATEGORY is the name of the locale category which was selected
in the program code.  For `gettext' and `dgettext' this is always
`LC_MESSAGES', for `dcgettext' this is selected by the value of the
third parameter.  As said above it should be avoided to ever use a
category other than `LC_MESSAGES'.

   The LOCALE component is computed based on the category used.  Just
like for the `setlocale' function here comes the user selection into
the play.  Some environment variables are examined in a fixed order and
the first environment variable set determines the return value of the
lookup process.  In detail, for the category `LC_xxx' the following
variables in this order are examined:

`LANGUAGE'

`LC_ALL'

`LC_xxx'

`LANG'

   This looks very familiar.  With the exception of the `LANGUAGE'
environment variable this is exactly the lookup order the `setlocale'
function uses.  But why introducing the `LANGUAGE' variable?

   The reason is that the syntax of the values these variables can have
is different to what is expected by the `setlocale' function.  If we
would set `LC_ALL' to a value following the extended syntax that would
mean the `setlocale' function will never be able to use the value of
this variable as well.  An additional variable removes this problem
plus we can select the language independently of the locale setting
which sometimes is useful.

   While for the `LC_xxx' variables the value should consist of exactly
one specification of a locale the `LANGUAGE' variable's value can
consist of a colon separated list of locale names.  The attentive
reader will realize that this is the way we manage to implement one of
our additional demands above: we want to be able to specify an ordered
list of language.

   Back to the constructed filename we have only one component missing.
The DOMAIN_NAME part is the name which was either registered using the
`textdomain' function or which was given to `dgettext' or `dcgettext'
as the first parameter.  Now it becomes obvious that a good choice for
the domain name in the program code is a string which is closely
related to the program/package name.  E.g., for the GNU C Library the
domain name is `libc'.

A limit piece of example code should show how the programmer is supposed
to work:

     {
       setlocale (LC_ALL, "");
       textdomain ("test-package");
       bindtextdomain ("test-package", "/usr/local/share/locale");
       puts (gettext ("Hello, world!"));
     }

   At the program start the default domain is `messages', and the
default locale is "C".  The `setlocale' call sets the locale according
to the user's environment variables; remember that correct functioning
of `gettext' relies on the correct setting of the `LC_MESSAGES' locale
(for looking up the message catalog) and of the `LC_CTYPE' locale (for
the character set conversion).  The `textdomain' call changes the
default domain to `test-package'.  The `bindtextdomain' call specifies
that the message catalogs for the domain `test-package' can be found
below the directory `/usr/local/share/locale'.

   If now the user set in her/his environment the variable `LANGUAGE'
to `de' the `gettext' function will try to use the translations from
the file

     /usr/local/share/locale/de/LC_MESSAGES/test-package.mo

   From the above descriptions it should be clear which component of
this filename is determined by which source.

   In the above example we assumed that the `LANGUAGE' environment
variable to `de'.  This might be an appropriate selection but what
happens if the user wants to use `LC_ALL' because of the wider
usability and here the required value is `de_DE.ISO-8859-1'?  We
already mentioned above that a situation like this is not infrequent.
E.g., a person might prefer reading a dialect and if this is not
available fall back on the standard language.

   The `gettext' functions know about situations like this and can
handle them gracefully.  The functions recognize the format of the value
of the environment variable.  It can split the value is different pieces
and by leaving out the only or the other part it can construct new
values.  This happens of course in a predictable way.  To understand
this one must know the format of the environment variable value.  There
is one more or less standardized form, originally from the X/Open
specification:

   `language[_territory[.codeset]][@modifier]'

   Less specific locale names will be stripped of in the order of the
following list:

  1. `codeset'

  2. `normalized codeset'

  3. `territory'

  4. `modifier'

   The `language' field will never be dropped for obvious reasons.

   The only new thing is the `normalized codeset' entry.  This is
another goodie which is introduced to help reducing the chaos which
derives from the inability of the people to standardize the names of
character sets.  Instead of ISO-8859-1 one can often see 8859-1, 88591,
iso8859-1, or iso_8859-1.  The `normalized codeset' value is generated
from the user-provided character set name by applying the following
rules:

  1. Remove all characters beside numbers and letters.

  2. Fold letters to lowercase.

  3. If the same only contains digits prepend the string `"iso"'.

So all of the above name will be normalized to `iso88591'.  This allows
the program user much more freely choosing the locale name.

   Even this extended functionality still does not help to solve the
problem that completely different names can be used to denote the same
locale (e.g., `de' and `german').  To be of help in this situation the
locale implementation and also the `gettext' functions know about
aliases.

   The file `/usr/share/locale/locale.alias' (replace `/usr' with
whatever prefix you used for configuring the C library) contains a
mapping of alternative names to more regular names.  The system manager
is free to add new entries to fill her/his own needs.  The selected
locale from the environment is compared with the entries in the first
column of this file ignoring the case.  If they match the value of the
second column is used instead for the further handling.

   In the description of the format of the environment variables we
already mentioned the character set as a factor in the selection of the
message catalog.  In fact, only catalogs which contain text written
using the character set of the system/program can be used (directly;
there will come a solution for this some day).  This means for the user
that s/he will always have to take care for this.  If in the collection
of the message catalogs there are files for the same language but coded
using different character sets the user has to be careful.


File: libc.info,  Node: Helper programs for gettext,  Prev: Message catalogs with gettext,  Up: The Uniforum approach

8.2.2 Programs to handle message catalogs for `gettext'
-------------------------------------------------------

The GNU C Library does not contain the source code for the programs to
handle message catalogs for the `gettext' functions.  As part of the
GNU project the GNU gettext package contains everything the developer
needs.  The functionality provided by the tools in this package by far
exceeds the abilities of the `gencat' program described above for the
`catgets' functions.

   There is a program `msgfmt' which is the equivalent program to the
`gencat' program.  It generates from the human-readable and -editable
form of the message catalog a binary file which can be used by the
`gettext' functions.  But there are several more programs available.

   The `xgettext' program can be used to automatically extract the
translatable messages from a source file.  I.e., the programmer need not
take care for the translations and the list of messages which have to be
translated.  S/He will simply wrap the translatable string in calls to
`gettext' et.al and the rest will be done by `xgettext'.  This program
has a lot of option which help to customize the output or do help to
understand the input better.

   Other programs help to manage development cycle when new messages
appear in the source files or when a new translation of the messages
appear.  Here it should only be noted that using all the tools in GNU
gettext it is possible to _completely_ automate the handling of message
catalog.  Beside marking the translatable string in the source code and
generating the translations the developers do not have anything to do
themselves.


File: libc.info,  Node: Searching and Sorting,  Next: Pattern Matching,  Prev: Message Translation,  Up: Top

9 Searching and Sorting
***********************

This chapter describes functions for searching and sorting arrays of
arbitrary objects.  You pass the appropriate comparison function to be
applied as an argument, along with the size of the objects in the array
and the total number of elements.

* Menu:

* Comparison Functions::        Defining how to compare two objects.
				 Since the sort and search facilities
                                 are general, you have to specify the
                                 ordering.
* Array Search Function::       The `bsearch' function.
* Array Sort Function::         The `qsort' function.
* Search/Sort Example::         An example program.
* Hash Search Function::        The `hsearch' function.
* Tree Search Function::        The `tsearch' function.


File: libc.info,  Node: Comparison Functions,  Next: Array Search Function,  Up: Searching and Sorting

9.1 Defining the Comparison Function
====================================

In order to use the sorted array library functions, you have to describe
how to compare the elements of the array.

   To do this, you supply a comparison function to compare two elements
of the array.  The library will call this function, passing as arguments
pointers to two array elements to be compared.  Your comparison function
should return a value the way `strcmp' (*note String/Array
Comparison::) does: negative if the first argument is "less" than the
second, zero if they are "equal", and positive if the first argument is
"greater".

   Here is an example of a comparison function which works with an
array of numbers of type `double':

     int
     compare_doubles (const void *a, const void *b)
     {
       const double *da = (const double *) a;
       const double *db = (const double *) b;

       return (*da > *db) - (*da < *db);
     }

   The header file `stdlib.h' defines a name for the data type of
comparison functions.  This type is a GNU extension.

     int comparison_fn_t (const void *, const void *);


File: libc.info,  Node: Array Search Function,  Next: Array Sort Function,  Prev: Comparison Functions,  Up: Searching and Sorting

9.2 Array Search Function
=========================

Generally searching for a specific element in an array means that
potentially all elements must be checked.  The GNU C library contains
functions to perform linear search.  The prototypes for the following
two functions can be found in `search.h'.

 -- Function: void * lfind (const void *KEY, void *BASE, size_t *NMEMB,
          size_t SIZE, comparison_fn_t COMPAR)
     The `lfind' function searches in the array with `*NMEMB' elements
     of SIZE bytes pointed to by BASE for an element which matches the
     one pointed to by KEY.  The function pointed to by COMPAR is used
     decide whether two elements match.

     The return value is a pointer to the matching element in the array
     starting at BASE if it is found.  If no matching element is
     available `NULL' is returned.

     The mean runtime of this function is `*NMEMB'/2.  This function
     should only be used if elements often get added to or deleted from
     the array in which case it might not be useful to sort the array
     before searching.

 -- Function: void * lsearch (const void *KEY, void *BASE, size_t
          *NMEMB, size_t SIZE, comparison_fn_t COMPAR)
     The `lsearch' function is similar to the `lfind' function.  It
     searches the given array for an element and returns it if found.
     The difference is that if no matching element is found the
     `lsearch' function adds the object pointed to by KEY (with a size
     of SIZE bytes) at the end of the array and it increments the value
     of `*NMEMB' to reflect this addition.

     This means for the caller that if it is not sure that the array
     contains the element one is searching for the memory allocated for
     the array starting at BASE must have room for at least SIZE more
     bytes.  If one is sure the element is in the array it is better to
     use `lfind' so having more room in the array is always necessary
     when calling `lsearch'.

   To search a sorted array for an element matching the key, use the
`bsearch' function.  The prototype for this function is in the header
file `stdlib.h'.  

 -- Function: void * bsearch (const void *KEY, const void *ARRAY,
          size_t COUNT, size_t SIZE, comparison_fn_t COMPARE)
     The `bsearch' function searches the sorted array ARRAY for an
     object that is equivalent to KEY.  The array contains COUNT
     elements, each of which is of size SIZE bytes.

     The COMPARE function is used to perform the comparison.  This
     function is called with two pointer arguments and should return an
     integer less than, equal to, or greater than zero corresponding to
     whether its first argument is considered less than, equal to, or
     greater than its second argument.  The elements of the ARRAY must
     already be sorted in ascending order according to this comparison
     function.

     The return value is a pointer to the matching array element, or a
     null pointer if no match is found.  If the array contains more
     than one element that matches, the one that is returned is
     unspecified.

     This function derives its name from the fact that it is implemented
     using the binary search algorithm.


File: libc.info,  Node: Array Sort Function,  Next: Search/Sort Example,  Prev: Array Search Function,  Up: Searching and Sorting

9.3 Array Sort Function
=======================

To sort an array using an arbitrary comparison function, use the
`qsort' function.  The prototype for this function is in `stdlib.h'.  

 -- Function: void qsort (void *ARRAY, size_t COUNT, size_t SIZE,
          comparison_fn_t COMPARE)
     The QSORT function sorts the array ARRAY.  The array contains
     COUNT elements, each of which is of size SIZE.

     The COMPARE function is used to perform the comparison on the
     array elements.  This function is called with two pointer
     arguments and should return an integer less than, equal to, or
     greater than zero corresponding to whether its first argument is
     considered less than, equal to, or greater than its second
     argument.

     *Warning:* If two objects compare as equal, their order after
     sorting is unpredictable.  That is to say, the sorting is not
     stable.  This can make a difference when the comparison considers
     only part of the elements.  Two elements with the same sort key
     may differ in other respects.

     If you want the effect of a stable sort, you can get this result by
     writing the comparison function so that, lacking other reason
     distinguish between two elements, it compares them by their
     addresses.  Note that doing this may make the sorting algorithm
     less efficient, so do it only if necessary.

     Here is a simple example of sorting an array of doubles in
     numerical order, using the comparison function defined above
     (*note Comparison Functions::):

          {
            double *array;
            int size;
            ...
            qsort (array, size, sizeof (double), compare_doubles);
          }

     The `qsort' function derives its name from the fact that it was
     originally implemented using the "quick sort" algorithm.

     The implementation of `qsort' in this library might not be an
     in-place sort and might thereby use an extra amount of memory to
     store the array.


File: libc.info,  Node: Search/Sort Example,  Next: Hash Search Function,  Prev: Array Sort Function,  Up: Searching and Sorting

9.4 Searching and Sorting Example
=================================

Here is an example showing the use of `qsort' and `bsearch' with an
array of structures.  The objects in the array are sorted by comparing
their `name' fields with the `strcmp' function.  Then, we can look up
individual objects based on their names.

     #include <stdlib.h>
     #include <stdio.h>
     #include <string.h>

     /* Define an array of critters to sort. */

     struct critter
       {
         const char *name;
         const char *species;
       };

     struct critter muppets[] =
       {
         {"Kermit", "frog"},
         {"Piggy", "pig"},
         {"Gonzo", "whatever"},
         {"Fozzie", "bear"},
         {"Sam", "eagle"},
         {"Robin", "frog"},
         {"Animal", "animal"},
         {"Camilla", "chicken"},
         {"Sweetums", "monster"},
         {"Dr. Strangepork", "pig"},
         {"Link Hogthrob", "pig"},
         {"Zoot", "human"},
         {"Dr. Bunsen Honeydew", "human"},
         {"Beaker", "human"},
         {"Swedish Chef", "human"}
       };

     int count = sizeof (muppets) / sizeof (struct critter);



     /* This is the comparison function used for sorting and searching. */

     int
     critter_cmp (const struct critter *c1, const struct critter *c2)
     {
       return strcmp (c1->name, c2->name);
     }


     /* Print information about a critter. */

     void
     print_critter (const struct critter *c)
     {
       printf ("%s, the %s\n", c->name, c->species);
     }


     /* Do the lookup into the sorted array. */

     void
     find_critter (const char *name)
     {
       struct critter target, *result;
       target.name = name;
       result = bsearch (&target, muppets, count, sizeof (struct critter),
                         critter_cmp);
       if (result)
         print_critter (result);
       else
         printf ("Couldn't find %s.\n", name);
     }

     /* Main program. */

     int
     main (void)
     {
       int i;

       for (i = 0; i < count; i++)
         print_critter (&muppets[i]);
       printf ("\n");

       qsort (muppets, count, sizeof (struct critter), critter_cmp);

       for (i = 0; i < count; i++)
         print_critter (&muppets[i]);
       printf ("\n");

       find_critter ("Kermit");
       find_critter ("Gonzo");
       find_critter ("Janice");

       return 0;
     }

   The output from this program looks like:

     Kermit, the frog
     Piggy, the pig
     Gonzo, the whatever
     Fozzie, the bear
     Sam, the eagle
     Robin, the frog
     Animal, the animal
     Camilla, the chicken
     Sweetums, the monster
     Dr. Strangepork, the pig
     Link Hogthrob, the pig
     Zoot, the human
     Dr. Bunsen Honeydew, the human
     Beaker, the human
     Swedish Chef, the human

     Animal, the animal
     Beaker, the human
     Camilla, the chicken
     Dr. Bunsen Honeydew, the human
     Dr. Strangepork, the pig
     Fozzie, the bear
     Gonzo, the whatever
     Kermit, the frog
     Link Hogthrob, the pig
     Piggy, the pig
     Robin, the frog
     Sam, the eagle
     Swedish Chef, the human
     Sweetums, the monster
     Zoot, the human

     Kermit, the frog
     Gonzo, the whatever
     Couldn't find Janice.


File: libc.info,  Node: Hash Search Function,  Next: Tree Search Function,  Prev: Search/Sort Example,  Up: Searching and Sorting

9.5 The `hsearch' function.
===========================

The functions mentioned so far in this chapter are for searching in a
sorted or unsorted array.  There are other methods to organize
information which later should be searched.  The costs of insert,
delete and search differ.  One possible implementation is using hashing
tables.  The following functions are declared in the header file
`search.h'.

 -- Function: int hcreate (size_t NEL)
     The `hcreate' function creates a hashing table which can contain at
     least NEL elements.  There is no possibility to grow this table so
     it is necessary to choose the value for NEL wisely.  The method
     used to implement this function might make it necessary to make the
     number of elements in the hashing table larger than the expected
     maximal number of elements.  Hashing tables usually work
     inefficiently if they are filled 80% or more.  The constant access
     time guaranteed by hashing can only be achieved if few collisions
     exist.  See Knuth's "The Art of Computer Programming, Part 3:
     Searching and Sorting" for more information.

     The weakest aspect of this function is that there can be at most
     one hashing table used through the whole program.  The table is
     allocated in local memory out of control of the programmer.  As an
     extension the GNU C library provides an additional set of
     functions with an reentrant interface which provide a similar
     interface but which allow to keep arbitrarily many hashing tables.

     It is possible to use more than one hashing table in the program
     run if the former table is first destroyed by a call to `hdestroy'.

     The function returns a non-zero value if successful.  If it return
     zero something went wrong.  This could either mean there is
     already a hashing table in use or the program runs out of memory.

 -- Function: void hdestroy (void)
     The `hdestroy' function can be used to free all the resources
     allocated in a previous call of `hcreate'.  After a call to this
     function it is again possible to call `hcreate' and allocate a new
     table with possibly different size.

     It is important to remember that the elements contained in the
     hashing table at the time `hdestroy' is called are _not_ freed by
     this function.  It is the responsibility of the program code to
     free those strings (if necessary at all).  Freeing all the element
     memory is not possible without extra, separately kept information
     since there is no function to iterate through all available
     elements in the hashing table.  If it is really necessary to free
     a table and all elements the programmer has to keep a list of all
     table elements and before calling `hdestroy' s/he has to free all
     element's data using this list.  This is a very unpleasant
     mechanism and it also shows that this kind of hashing tables is
     mainly meant for tables which are created once and used until the
     end of the program run.

   Entries of the hashing table and keys for the search are defined
using this type:

 -- Data type: struct ENTRY
     Both elements of this structure are pointers to zero-terminated
     strings.  This is a limiting restriction of the functionality of
     the `hsearch' functions.  They can only be used for data sets
     which use the NUL character always and solely to terminate the
     records.  It is not possible to handle general binary data.

    `char *key'
          Pointer to a zero-terminated string of characters describing
          the key for the search or the element in the hashing table.

    `char *data'
          Pointer to a zero-terminated string of characters describing
          the data.  If the functions will be called only for searching
          an existing entry this element might stay undefined since it
          is not used.

 -- Function: ENTRY * hsearch (ENTRY ITEM, ACTION ACTION)
     To search in a hashing table created using `hcreate' the `hsearch'
     function must be used.  This function can perform simple search
     for an element (if ACTION has the `FIND') or it can alternatively
     insert the key element into the hashing table.  Entries are never
     replaced.

     The key is denoted by a pointer to an object of type `ENTRY'.  For
     locating the corresponding position in the hashing table only the
     `key' element of the structure is used.

     If an entry with matching key is found the ACTION parameter is
     irrelevant.  The found entry is returned.  If no matching entry is
     found and the ACTION parameter has the value `FIND' the function
     returns a `NULL' pointer.  If no entry is found and the ACTION
     parameter has the value `ENTER' a new entry is added to the
     hashing table which is initialized with the parameter ITEM.  A
     pointer to the newly added entry is returned.

   As mentioned before the hashing table used by the functions
described so far is global and there can be at any time at most one
hashing table in the program.  A solution is to use the following
functions which are a GNU extension.  All have in common that they
operate on a hashing table which is described by the content of an
object of the type `struct hsearch_data'.  This type should be treated
as opaque, none of its members should be changed directly.

 -- Function: int hcreate_r (size_t NEL, struct hsearch_data *HTAB)
     The `hcreate_r' function initializes the object pointed to by HTAB
     to contain a hashing table with at least NEL elements.  So this
     function is equivalent to the `hcreate' function except that the
     initialized data structure is controlled by the user.

     This allows having more than one hashing table at one time.  The
     memory necessary for the `struct hsearch_data' object can be
     allocated dynamically.  It must be initialized with zero before
     calling this function.

     The return value is non-zero if the operation was successful.  If
     the return value is zero, something went wrong, which probably
     means the programs ran out of memory.

 -- Function: void hdestroy_r (struct hsearch_data *HTAB)
     The `hdestroy_r' function frees all resources allocated by the
     `hcreate_r' function for this very same object HTAB.  As for
     `hdestroy' it is the programs responsibility to free the strings
     for the elements of the table.

 -- Function: int hsearch_r (ENTRY ITEM, ACTION ACTION, ENTRY **RETVAL,
          struct hsearch_data *HTAB)
     The `hsearch_r' function is equivalent to `hsearch'.  The meaning
     of the first two arguments is identical.  But instead of operating
     on a single global hashing table the function works on the table
     described by the object pointed to by HTAB (which is initialized
     by a call to `hcreate_r').

     Another difference to `hcreate' is that the pointer to the found
     entry in the table is not the return value of the functions.  It is
     returned by storing it in a pointer variables pointed to by the
     RETVAL parameter.  The return value of the function is an integer
     value indicating success if it is non-zero and failure if it is
     zero.  In the latter case the global variable ERRNO signals the
     reason for the failure.

    `ENOMEM'
          The table is filled and `hsearch_r' was called with an so far
          unknown key and ACTION set to `ENTER'.

    `ESRCH'
          The ACTION parameter is `FIND' and no corresponding element
          is found in the table.


File: libc.info,  Node: Tree Search Function,  Prev: Hash Search Function,  Up: Searching and Sorting

9.6 The `tsearch' function.
===========================

Another common form to organize data for efficient search is to use
trees.  The `tsearch' function family provides a nice interface to
functions to organize possibly large amounts of data by providing a mean
access time proportional to the logarithm of the number of elements.
The GNU C library implementation even guarantees that this bound is
never exceeded even for input data which cause problems for simple
binary tree implementations.

   The functions described in the chapter are all described in the
System V and X/Open specifications and are therefore quite portable.

   In contrast to the `hsearch' functions the `tsearch' functions can
be used with arbitrary data and not only zero-terminated strings.

   The `tsearch' functions have the advantage that no function to
initialize data structures is necessary.  A simple pointer of type
`void *' initialized to `NULL' is a valid tree and can be extended or
searched.  The prototypes for these functions can be found in the
header file `search.h'.

 -- Function: void * tsearch (const void *KEY, void **ROOTP,
          comparison_fn_t COMPAR)
     The `tsearch' function searches in the tree pointed to by `*ROOTP'
     for an element matching KEY.  The function pointed to by COMPAR is
     used to determine whether two elements match.  *Note Comparison
     Functions::, for a specification of the functions which can be
     used for the COMPAR parameter.

     If the tree does not contain a matching entry the KEY value will
     be added to the tree.  `tsearch' does not make a copy of the object
     pointed to by KEY (how could it since the size is unknown).
     Instead it adds a reference to this object which means the object
     must be available as long as the tree data structure is used.

     The tree is represented by a pointer to a pointer since it is
     sometimes necessary to change the root node of the tree.  So it
     must not be assumed that the variable pointed to by ROOTP has the
     same value after the call.  This also shows that it is not safe to
     call the `tsearch' function more than once at the same time using
     the same tree.  It is no problem to run it more than once at a
     time on different trees.

     The return value is a pointer to the matching element in the tree.
     If a new element was created the pointer points to the new data
     (which is in fact KEY).  If an entry had to be created and the
     program ran out of space `NULL' is returned.

 -- Function: void * tfind (const void *KEY, void *const *ROOTP,
          comparison_fn_t COMPAR)
     The `tfind' function is similar to the `tsearch' function.  It
     locates an element matching the one pointed to by KEY and returns
     a pointer to this element.  But if no matching element is
     available no new element is entered (note that the ROOTP parameter
     points to a constant pointer).  Instead the function returns
     `NULL'.

   Another advantage of the `tsearch' function in contrast to the
`hsearch' functions is that there is an easy way to remove elements.

 -- Function: void * tdelete (const void *KEY, void **ROOTP,
          comparison_fn_t COMPAR)
     To remove a specific element matching KEY from the tree `tdelete'
     can be used.  It locates the matching element using the same
     method as `tfind'.  The corresponding element is then removed and
     a pointer to the parent of the deleted node is returned by the
     function.  If there is no matching entry in the tree nothing can be
     deleted and the function returns `NULL'.  If the root of the tree
     is deleted `tdelete' returns some unspecified value not equal to
     `NULL'.

 -- Function: void tdestroy (void *VROOT, __free_fn_t FREEFCT)
     If the complete search tree has to be removed one can use
     `tdestroy'.  It frees all resources allocated by the `tsearch'
     function to generate the tree pointed to by VROOT.

     For the data in each tree node the function FREEFCT is called.
     The pointer to the data is passed as the argument to the function.
     If no such work is necessary FREEFCT must point to a function
     doing nothing.  It is called in any case.

     This function is a GNU extension and not covered by the System V or
     X/Open specifications.

   In addition to the function to create and destroy the tree data
structure, there is another function which allows you to apply a
function to all elements of the tree.  The function must have this type:

     void __action_fn_t (const void *nodep, VISIT value, int level);

   The NODEP is the data value of the current node (once given as the
KEY argument to `tsearch').  LEVEL is a numeric value which corresponds
to the depth of the current node in the tree.  The root node has the
depth 0 and its children have a depth of 1 and so on.  The `VISIT' type
is an enumeration type.

 -- Data Type: VISIT
     The `VISIT' value indicates the status of the current node in the
     tree and how the function is called.  The status of a node is
     either `leaf' or `internal node'.  For each leaf node the function
     is called exactly once, for each internal node it is called three
     times: before the first child is processed, after the first child
     is processed and after both children are processed.  This makes it
     possible to handle all three methods of tree traversal (or even a
     combination of them).

    `preorder'
          The current node is an internal node and the function is
          called before the first child was processed.

    `postorder'
          The current node is an internal node and the function is
          called after the first child was processed.

    `endorder'
          The current node is an internal node and the function is
          called after the second child was processed.

    `leaf'
          The current node is a leaf.

 -- Function: void twalk (const void *ROOT, __action_fn_t ACTION)
     For each node in the tree with a node pointed to by ROOT, the
     `twalk' function calls the function provided by the parameter
     ACTION.  For leaf nodes the function is called exactly once with
     VALUE set to `leaf'.  For internal nodes the function is called
     three times, setting the VALUE parameter or ACTION to the
     appropriate value.  The LEVEL argument for the ACTION function is
     computed while descending the tree with increasing the value by
     one for the descend to a child, starting with the value 0 for the
     root node.

     Since the functions used for the ACTION parameter to `twalk' must
     not modify the tree data, it is safe to run `twalk' in more than
     one thread at the same time, working on the same tree.  It is also
     safe to call `tfind' in parallel.  Functions which modify the tree
     must not be used, otherwise the behavior is undefined.


File: libc.info,  Node: Pattern Matching,  Next: I/O Overview,  Prev: Searching and Sorting,  Up: Top

10 Pattern Matching
*******************

The GNU C Library provides pattern matching facilities for two kinds of
patterns: regular expressions and file-name wildcards.  The library also
provides a facility for expanding variable and command references and
parsing text into words in the way the shell does.

* Menu:

* Wildcard Matching::    Matching a wildcard pattern against a single string.
* Globbing::             Finding the files that match a wildcard pattern.
* Regular Expressions::  Matching regular expressions against strings.
* Word Expansion::       Expanding shell variables, nested commands,
			    arithmetic, and wildcards.
			    This is what the shell does with shell commands.


File: libc.info,  Node: Wildcard Matching,  Next: Globbing,  Up: Pattern Matching

10.1 Wildcard Matching
======================

This section describes how to match a wildcard pattern against a
particular string.  The result is a yes or no answer: does the string
fit the pattern or not.  The symbols described here are all declared in
`fnmatch.h'.

 -- Function: int fnmatch (const char *PATTERN, const char *STRING, int
          FLAGS)
     This function tests whether the string STRING matches the pattern
     PATTERN.  It returns `0' if they do match; otherwise, it returns
     the nonzero value `FNM_NOMATCH'.  The arguments PATTERN and STRING
     are both strings.

     The argument FLAGS is a combination of flag bits that alter the
     details of matching.  See below for a list of the defined flags.

     In the GNU C Library, `fnmatch' cannot experience an "error"--it
     always returns an answer for whether the match succeeds.  However,
     other implementations of `fnmatch' might sometimes report "errors".
     They would do so by returning nonzero values that are not equal to
     `FNM_NOMATCH'.

   These are the available flags for the FLAGS argument:

`FNM_FILE_NAME'
     Treat the `/' character specially, for matching file names.  If
     this flag is set, wildcard constructs in PATTERN cannot match `/'
     in STRING.  Thus, the only way to match `/' is with an explicit
     `/' in PATTERN.

`FNM_PATHNAME'
     This is an alias for `FNM_FILE_NAME'; it comes from POSIX.2.  We
     don't recommend this name because we don't use the term "pathname"
     for file names.

`FNM_PERIOD'
     Treat the `.' character specially if it appears at the beginning of
     STRING.  If this flag is set, wildcard constructs in PATTERN
     cannot match `.' as the first character of STRING.

     If you set both `FNM_PERIOD' and `FNM_FILE_NAME', then the special
     treatment applies to `.' following `/' as well as to `.' at the
     beginning of STRING.  (The shell uses the `FNM_PERIOD' and
     `FNM_FILE_NAME' flags together for matching file names.)

`FNM_NOESCAPE'
     Don't treat the `\' character specially in patterns.  Normally,
     `\' quotes the following character, turning off its special meaning
     (if any) so that it matches only itself.  When quoting is enabled,
     the pattern `\?' matches only the string `?', because the question
     mark in the pattern acts like an ordinary character.

     If you use `FNM_NOESCAPE', then `\' is an ordinary character.

`FNM_LEADING_DIR'
     Ignore a trailing sequence of characters starting with a `/' in
     STRING; that is to say, test whether STRING starts with a
     directory name that PATTERN matches.

     If this flag is set, either `foo*' or `foobar' as a pattern would
     match the string `foobar/frobozz'.

`FNM_CASEFOLD'
     Ignore case in comparing STRING to PATTERN.

`FNM_EXTMATCH'
     Recognize beside the normal patterns also the extended patterns
     introduced in `ksh'.  The patterns are written in the form
     explained in the following table where PATTERN-LIST is a `|'
     separated list of patterns.

    `?(PATTERN-LIST)'
          The pattern matches if zero or one occurrences of any of the
          patterns in the PATTERN-LIST allow matching the input string.

    `*(PATTERN-LIST)'
          The pattern matches if zero or more occurrences of any of the
          patterns in the PATTERN-LIST allow matching the input string.

    `+(PATTERN-LIST)'
          The pattern matches if one or more occurrences of any of the
          patterns in the PATTERN-LIST allow matching the input string.

    `@(PATTERN-LIST)'
          The pattern matches if exactly one occurrence of any of the
          patterns in the PATTERN-LIST allows matching the input string.

    `!(PATTERN-LIST)'
          The pattern matches if the input string cannot be matched
          with any of the patterns in the PATTERN-LIST.


File: libc.info,  Node: Globbing,  Next: Regular Expressions,  Prev: Wildcard Matching,  Up: Pattern Matching

10.2 Globbing
=============

The archetypal use of wildcards is for matching against the files in a
directory, and making a list of all the matches.  This is called
"globbing".

   You could do this using `fnmatch', by reading the directory entries
one by one and testing each one with `fnmatch'.  But that would be slow
(and complex, since you would have to handle subdirectories by hand).

   The library provides a function `glob' to make this particular use
of wildcards convenient.  `glob' and the other symbols in this section
are declared in `glob.h'.

* Menu:

* Calling Glob::             Basic use of `glob'.
* Flags for Globbing::       Flags that enable various options in `glob'.
* More Flags for Globbing::  GNU specific extensions to `glob'.


File: libc.info,  Node: Calling Glob,  Next: Flags for Globbing,  Up: Globbing

10.2.1 Calling `glob'
---------------------

The result of globbing is a vector of file names (strings).  To return
this vector, `glob' uses a special data type, `glob_t', which is a
structure.  You pass `glob' the address of the structure, and it fills
in the structure's fields to tell you about the results.

 -- Data Type: glob_t
     This data type holds a pointer to a word vector.  More precisely,
     it records both the address of the word vector and its size.  The
     GNU implementation contains some more fields which are non-standard
     extensions.

    `gl_pathc'
          The number of elements in the vector, excluding the initial
          null entries if the GLOB_DOOFFS flag is used (see gl_offs
          below).

    `gl_pathv'
          The address of the vector.  This field has type `char **'.

    `gl_offs'
          The offset of the first real element of the vector, from its
          nominal address in the `gl_pathv' field.  Unlike the other
          fields, this is always an input to `glob', rather than an
          output from it.

          If you use a nonzero offset, then that many elements at the
          beginning of the vector are left empty.  (The `glob' function
          fills them with null pointers.)

          The `gl_offs' field is meaningful only if you use the
          `GLOB_DOOFFS' flag.  Otherwise, the offset is always zero
          regardless of what is in this field, and the first real
          element comes at the beginning of the vector.

    `gl_closedir'
          The address of an alternative implementation of the `closedir'
          function.  It is used if the `GLOB_ALTDIRFUNC' bit is set in
          the flag parameter.  The type of this field is
          `void (*) (void *)'.

          This is a GNU extension.

    `gl_readdir'
          The address of an alternative implementation of the `readdir'
          function used to read the contents of a directory.  It is
          used if the `GLOB_ALTDIRFUNC' bit is set in the flag
          parameter.  The type of this field is
          `struct dirent *(*) (void *)'.

          This is a GNU extension.

    `gl_opendir'
          The address of an alternative implementation of the `opendir'
          function.  It is used if the `GLOB_ALTDIRFUNC' bit is set in
          the flag parameter.  The type of this field is
          `void *(*) (const char *)'.

          This is a GNU extension.

    `gl_stat'
          The address of an alternative implementation of the `stat'
          function to get information about an object in the
          filesystem.  It is used if the `GLOB_ALTDIRFUNC' bit is set
          in the flag parameter.  The type of this field is
          `int (*) (const char *, struct stat *)'.

          This is a GNU extension.

    `gl_lstat'
          The address of an alternative implementation of the `lstat'
          function to get information about an object in the
          filesystems, not following symbolic links.  It is used if the
          `GLOB_ALTDIRFUNC' bit is set in the flag parameter.  The type
          of this field is `int (*) (const char *, struct stat *)'.

          This is a GNU extension.

   For use in the `glob64' function `glob.h' contains another
definition for a very similar type.  `glob64_t' differs from `glob_t'
only in the types of the members `gl_readdir', `gl_stat', and
`gl_lstat'.

 -- Data Type: glob64_t
     This data type holds a pointer to a word vector.  More precisely,
     it records both the address of the word vector and its size.  The
     GNU implementation contains some more fields which are non-standard
     extensions.

    `gl_pathc'
          The number of elements in the vector, excluding the initial
          null entries if the GLOB_DOOFFS flag is used (see gl_offs
          below).

    `gl_pathv'
          The address of the vector.  This field has type `char **'.

    `gl_offs'
          The offset of the first real element of the vector, from its
          nominal address in the `gl_pathv' field.  Unlike the other
          fields, this is always an input to `glob', rather than an
          output from it.

          If you use a nonzero offset, then that many elements at the
          beginning of the vector are left empty.  (The `glob' function
          fills them with null pointers.)

          The `gl_offs' field is meaningful only if you use the
          `GLOB_DOOFFS' flag.  Otherwise, the offset is always zero
          regardless of what is in this field, and the first real
          element comes at the beginning of the vector.

    `gl_closedir'
          The address of an alternative implementation of the `closedir'
          function.  It is used if the `GLOB_ALTDIRFUNC' bit is set in
          the flag parameter.  The type of this field is
          `void (*) (void *)'.

          This is a GNU extension.

    `gl_readdir'
          The address of an alternative implementation of the
          `readdir64' function used to read the contents of a
          directory.  It is used if the `GLOB_ALTDIRFUNC' bit is set in
          the flag parameter.  The type of this field is
          `struct dirent64 *(*) (void *)'.

          This is a GNU extension.

    `gl_opendir'
          The address of an alternative implementation of the `opendir'
          function.  It is used if the `GLOB_ALTDIRFUNC' bit is set in
          the flag parameter.  The type of this field is
          `void *(*) (const char *)'.

          This is a GNU extension.

    `gl_stat'
          The address of an alternative implementation of the `stat64'
          function to get information about an object in the
          filesystem.  It is used if the `GLOB_ALTDIRFUNC' bit is set
          in the flag parameter.  The type of this field is
          `int (*) (const char *, struct stat64 *)'.

          This is a GNU extension.

    `gl_lstat'
          The address of an alternative implementation of the `lstat64'
          function to get information about an object in the
          filesystems, not following symbolic links.  It is used if the
          `GLOB_ALTDIRFUNC' bit is set in the flag parameter.  The type
          of this field is `int (*) (const char *, struct stat64 *)'.

          This is a GNU extension.

 -- Function: int glob (const char *PATTERN, int FLAGS, int (*ERRFUNC)
          (const char *FILENAME, int ERROR-CODE), glob_t *VECTOR-PTR)
     The function `glob' does globbing using the pattern PATTERN in the
     current directory.  It puts the result in a newly allocated
     vector, and stores the size and address of this vector into
     `*VECTOR-PTR'.  The argument FLAGS is a combination of bit flags;
     see *Note Flags for Globbing::, for details of the flags.

     The result of globbing is a sequence of file names.  The function
     `glob' allocates a string for each resulting word, then allocates
     a vector of type `char **' to store the addresses of these
     strings.  The last element of the vector is a null pointer.  This
     vector is called the "word vector".

     To return this vector, `glob' stores both its address and its
     length (number of elements, not counting the terminating null
     pointer) into `*VECTOR-PTR'.

     Normally, `glob' sorts the file names alphabetically before
     returning them.  You can turn this off with the flag `GLOB_NOSORT'
     if you want to get the information as fast as possible.  Usually
     it's a good idea to let `glob' sort them--if you process the files
     in alphabetical order, the users will have a feel for the rate of
     progress that your application is making.

     If `glob' succeeds, it returns 0.  Otherwise, it returns one of
     these error codes:

    `GLOB_ABORTED'
          There was an error opening a directory, and you used the flag
          `GLOB_ERR' or your specified ERRFUNC returned a nonzero value.
          *Note Flags for Globbing::, for an explanation of the
          `GLOB_ERR' flag and ERRFUNC.

    `GLOB_NOMATCH'
          The pattern didn't match any existing files.  If you use the
          `GLOB_NOCHECK' flag, then you never get this error code,
          because that flag tells `glob' to _pretend_ that the pattern
          matched at least one file.

    `GLOB_NOSPACE'
          It was impossible to allocate memory to hold the result.

     In the event of an error, `glob' stores information in
     `*VECTOR-PTR' about all the matches it has found so far.

     It is important to notice that the `glob' function will not fail if
     it encounters directories or files which cannot be handled without
     the LFS interfaces.  The implementation of `glob' is supposed to
     use these functions internally.  This at least is the assumptions
     made by the Unix standard.  The GNU extension of allowing the user
     to provide own directory handling and `stat' functions complicates
     things a bit.  If these callback functions are used and a large
     file or directory is encountered `glob' _can_ fail.

 -- Function: int glob64 (const char *PATTERN, int FLAGS, int
          (*ERRFUNC) (const char *FILENAME, int ERROR-CODE), glob64_t
          *VECTOR-PTR)
     The `glob64' function was added as part of the Large File Summit
     extensions but is not part of the original LFS proposal.  The
     reason for this is simple: it is not necessary.  The necessity for
     a `glob64' function is added by the extensions of the GNU `glob'
     implementation which allows the user to provide own directory
     handling and `stat' functions.  The `readdir' and `stat' functions
     do depend on the choice of `_FILE_OFFSET_BITS' since the definition
     of the types `struct dirent' and `struct stat' will change
     depending on the choice.

     Beside this difference the `glob64' works just like `glob' in all
     aspects.

     This function is a GNU extension.


File: libc.info,  Node: Flags for Globbing,  Next: More Flags for Globbing,  Prev: Calling Glob,  Up: Globbing

10.2.2 Flags for Globbing
-------------------------

This section describes the flags that you can specify in the FLAGS
argument to `glob'.  Choose the flags you want, and combine them with
the C bitwise OR operator `|'.

`GLOB_APPEND'
     Append the words from this expansion to the vector of words
     produced by previous calls to `glob'.  This way you can
     effectively expand several words as if they were concatenated with
     spaces between them.

     In order for appending to work, you must not modify the contents
     of the word vector structure between calls to `glob'.  And, if you
     set `GLOB_DOOFFS' in the first call to `glob', you must also set
     it when you append to the results.

     Note that the pointer stored in `gl_pathv' may no longer be valid
     after you call `glob' the second time, because `glob' might have
     relocated the vector.  So always fetch `gl_pathv' from the
     `glob_t' structure after each `glob' call; *never* save the
     pointer across calls.

`GLOB_DOOFFS'
     Leave blank slots at the beginning of the vector of words.  The
     `gl_offs' field says how many slots to leave.  The blank slots
     contain null pointers.

`GLOB_ERR'
     Give up right away and report an error if there is any difficulty
     reading the directories that must be read in order to expand
     PATTERN fully.  Such difficulties might include a directory in
     which you don't have the requisite access.  Normally, `glob' tries
     its best to keep on going despite any errors, reading whatever
     directories it can.

     You can exercise even more control than this by specifying an
     error-handler function ERRFUNC when you call `glob'.  If ERRFUNC
     is not a null pointer, then `glob' doesn't give up right away when
     it can't read a directory; instead, it calls ERRFUNC with two
     arguments, like this:

          (*ERRFUNC) (FILENAME, ERROR-CODE)

     The argument FILENAME is the name of the directory that `glob'
     couldn't open or couldn't read, and ERROR-CODE is the `errno'
     value that was reported to `glob'.

     If the error handler function returns nonzero, then `glob' gives up
     right away.  Otherwise, it continues.

`GLOB_MARK'
     If the pattern matches the name of a directory, append `/' to the
     directory's name when returning it.

`GLOB_NOCHECK'
     If the pattern doesn't match any file names, return the pattern
     itself as if it were a file name that had been matched.
     (Normally, when the pattern doesn't match anything, `glob' returns
     that there were no matches.)

`GLOB_NOSORT'
     Don't sort the file names; return them in no particular order.
     (In practice, the order will depend on the order of the entries in
     the directory.)  The only reason _not_ to sort is to save time.

`GLOB_NOESCAPE'
     Don't treat the `\' character specially in patterns.  Normally,
     `\' quotes the following character, turning off its special meaning
     (if any) so that it matches only itself.  When quoting is enabled,
     the pattern `\?' matches only the string `?', because the question
     mark in the pattern acts like an ordinary character.

     If you use `GLOB_NOESCAPE', then `\' is an ordinary character.

     `glob' does its work by calling the function `fnmatch' repeatedly.
     It handles the flag `GLOB_NOESCAPE' by turning on the
     `FNM_NOESCAPE' flag in calls to `fnmatch'.


File: libc.info,  Node: More Flags for Globbing,  Prev: Flags for Globbing,  Up: Globbing

10.2.3 More Flags for Globbing
------------------------------

Beside the flags described in the last section, the GNU implementation
of `glob' allows a few more flags which are also defined in the
`glob.h' file.  Some of the extensions implement functionality which is
available in modern shell implementations.

`GLOB_PERIOD'
     The `.' character (period) is treated special.  It cannot be
     matched by wildcards.  *Note Wildcard Matching::, `FNM_PERIOD'.

`GLOB_MAGCHAR'
     The `GLOB_MAGCHAR' value is not to be given to `glob' in the FLAGS
     parameter.  Instead, `glob' sets this bit in the GL_FLAGS element
     of the GLOB_T structure provided as the result if the pattern used
     for matching contains any wildcard character.

`GLOB_ALTDIRFUNC'
     Instead of the using the using the normal functions for accessing
     the filesystem the `glob' implementation uses the user-supplied
     functions specified in the structure pointed to by PGLOB
     parameter.  For more information about the functions refer to the
     sections about directory handling see *Note Accessing
     Directories::, and *Note Reading Attributes::.

`GLOB_BRACE'
     If this flag is given the handling of braces in the pattern is
     changed.  It is now required that braces appear correctly grouped.
     I.e., for each opening brace there must be a closing one.  Braces
     can be used recursively.  So it is possible to define one brace
     expression in another one.  It is important to note that the range
     of each brace expression is completely contained in the outer
     brace expression (if there is one).

     The string between the matching braces is separated into single
     expressions by splitting at `,' (comma) characters.  The commas
     themselves are discarded.  Please note what we said above about
     recursive brace expressions.  The commas used to separate the
     subexpressions must be at the same level.  Commas in brace
     subexpressions are not matched.  They are used during expansion of
     the brace expression of the deeper level.  The example below shows
     this

          glob ("{foo/{,bar,biz},baz}", GLOB_BRACE, NULL, &result)

     is equivalent to the sequence

          glob ("foo/", GLOB_BRACE, NULL, &result)
          glob ("foo/bar", GLOB_BRACE|GLOB_APPEND, NULL, &result)
          glob ("foo/biz", GLOB_BRACE|GLOB_APPEND, NULL, &result)
          glob ("baz", GLOB_BRACE|GLOB_APPEND, NULL, &result)

     if we leave aside error handling.

`GLOB_NOMAGIC'
     If the pattern contains no wildcard constructs (it is a literal
     file name), return it as the sole "matching" word, even if no file
     exists by that name.

`GLOB_TILDE'
     If this flag is used the character `~' (tilde) is handled special
     if it appears at the beginning of the pattern.  Instead of being
     taken verbatim it is used to represent the home directory of a
     known user.

     If `~' is the only character in pattern or it is followed by a `/'
     (slash), the home directory of the process owner is substituted.
     Using `getlogin' and `getpwnam' the information is read from the
     system databases.  As an example take user `bart' with his home
     directory at `/home/bart'.  For him a call like

          glob ("~/bin/*", GLOB_TILDE, NULL, &result)

     would return the contents of the directory `/home/bart/bin'.
     Instead of referring to the own home directory it is also possible
     to name the home directory of other users.  To do so one has to
     append the user name after the tilde character.  So the contents
     of user `homer''s `bin' directory can be retrieved by

          glob ("~homer/bin/*", GLOB_TILDE, NULL, &result)

     If the user name is not valid or the home directory cannot be
     determined for some reason the pattern is left untouched and
     itself used as the result.  I.e., if in the last example `home' is
     not available the tilde expansion yields to `"~homer/bin/*"' and
     `glob' is not looking for a directory named `~homer'.

     This functionality is equivalent to what is available in C-shells
     if the `nonomatch' flag is set.

`GLOB_TILDE_CHECK'
     If this flag is used `glob' behaves like as if `GLOB_TILDE' is
     given.  The only difference is that if the user name is not
     available or the home directory cannot be determined for other
     reasons this leads to an error.  `glob' will return `GLOB_NOMATCH'
     instead of using the pattern itself as the name.

     This functionality is equivalent to what is available in C-shells
     if `nonomatch' flag is not set.

`GLOB_ONLYDIR'
     If this flag is used the globbing function takes this as a *hint*
     that the caller is only interested in directories matching the
     pattern.  If the information about the type of the file is easily
     available non-directories will be rejected but no extra work will
     be done to determine the information for each file.  I.e., the
     caller must still be able to filter directories out.

     This functionality is only available with the GNU `glob'
     implementation.  It is mainly used internally to increase the
     performance but might be useful for a user as well and therefore is
     documented here.

   Calling `glob' will in most cases allocate resources which are used
to represent the result of the function call.  If the same object of
type `glob_t' is used in multiple call to `glob' the resources are
freed or reused so that no leaks appear.  But this does not include the
time when all `glob' calls are done.

 -- Function: void globfree (glob_t *PGLOB)
     The `globfree' function frees all resources allocated by previous
     calls to `glob' associated with the object pointed to by PGLOB.
     This function should be called whenever the currently used
     `glob_t' typed object isn't used anymore.

 -- Function: void globfree64 (glob64_t *PGLOB)
     This function is equivalent to `globfree' but it frees records of
     type `glob64_t' which were allocated by `glob64'.


File: libc.info,  Node: Regular Expressions,  Next: Word Expansion,  Prev: Globbing,  Up: Pattern Matching

10.3 Regular Expression Matching
================================

The GNU C library supports two interfaces for matching regular
expressions.  One is the standard POSIX.2 interface, and the other is
what the GNU system has had for many years.

   Both interfaces are declared in the header file `regex.h'.  If you
define `_POSIX_C_SOURCE', then only the POSIX.2 functions, structures,
and constants are declared.

* Menu:

* POSIX Regexp Compilation::    Using `regcomp' to prepare to match.
* Flags for POSIX Regexps::     Syntax variations for `regcomp'.
* Matching POSIX Regexps::      Using `regexec' to match the compiled
				   pattern that you get from `regcomp'.
* Regexp Subexpressions::       Finding which parts of the string were matched.
* Subexpression Complications:: Find points of which parts were matched.
* Regexp Cleanup::		Freeing storage; reporting errors.


File: libc.info,  Node: POSIX Regexp Compilation,  Next: Flags for POSIX Regexps,  Up: Regular Expressions

10.3.1 POSIX Regular Expression Compilation
-------------------------------------------

Before you can actually match a regular expression, you must "compile"
it.  This is not true compilation--it produces a special data
structure, not machine instructions.  But it is like ordinary
compilation in that its purpose is to enable you to "execute" the
pattern fast.  (*Note Matching POSIX Regexps::, for how to use the
compiled regular expression for matching.)

   There is a special data type for compiled regular expressions:

 -- Data Type: regex_t
     This type of object holds a compiled regular expression.  It is
     actually a structure.  It has just one field that your programs
     should look at:

    `re_nsub'
          This field holds the number of parenthetical subexpressions
          in the regular expression that was compiled.

     There are several other fields, but we don't describe them here,
     because only the functions in the library should use them.

   After you create a `regex_t' object, you can compile a regular
expression into it by calling `regcomp'.

 -- Function: int regcomp (regex_t *restrict COMPILED, const char
          *restrict PATTERN, int CFLAGS)
     The function `regcomp' "compiles" a regular expression into a data
     structure that you can use with `regexec' to match against a
     string.  The compiled regular expression format is designed for
     efficient matching.  `regcomp' stores it into `*COMPILED'.

     It's up to you to allocate an object of type `regex_t' and pass its
     address to `regcomp'.

     The argument CFLAGS lets you specify various options that control
     the syntax and semantics of regular expressions.  *Note Flags for
     POSIX Regexps::.

     If you use the flag `REG_NOSUB', then `regcomp' omits from the
     compiled regular expression the information necessary to record
     how subexpressions actually match.  In this case, you might as well
     pass `0' for the MATCHPTR and NMATCH arguments when you call
     `regexec'.

     If you don't use `REG_NOSUB', then the compiled regular expression
     does have the capacity to record how subexpressions match.  Also,
     `regcomp' tells you how many subexpressions PATTERN has, by
     storing the number in `COMPILED->re_nsub'.  You can use that value
     to decide how long an array to allocate to hold information about
     subexpression matches.

     `regcomp' returns `0' if it succeeds in compiling the regular
     expression; otherwise, it returns a nonzero error code (see the
     table below).  You can use `regerror' to produce an error message
     string describing the reason for a nonzero value; see *Note Regexp
     Cleanup::.


   Here are the possible nonzero values that `regcomp' can return:

`REG_BADBR'
     There was an invalid `\{...\}' construct in the regular
     expression.  A valid `\{...\}' construct must contain either a
     single number, or two numbers in increasing order separated by a
     comma.

`REG_BADPAT'
     There was a syntax error in the regular expression.

`REG_BADRPT'
     A repetition operator such as `?' or `*' appeared in a bad
     position (with no preceding subexpression to act on).

`REG_ECOLLATE'
     The regular expression referred to an invalid collating element
     (one not defined in the current locale for string collation).
     *Note Locale Categories::.

`REG_ECTYPE'
     The regular expression referred to an invalid character class name.

`REG_EESCAPE'
     The regular expression ended with `\'.

`REG_ESUBREG'
     There was an invalid number in the `\DIGIT' construct.

`REG_EBRACK'
     There were unbalanced square brackets in the regular expression.

`REG_EPAREN'
     An extended regular expression had unbalanced parentheses, or a
     basic regular expression had unbalanced `\(' and `\)'.

`REG_EBRACE'
     The regular expression had unbalanced `\{' and `\}'.

`REG_ERANGE'
     One of the endpoints in a range expression was invalid.

`REG_ESPACE'
     `regcomp' ran out of memory.


File: libc.info,  Node: Flags for POSIX Regexps,  Next: Matching POSIX Regexps,  Prev: POSIX Regexp Compilation,  Up: Regular Expressions

10.3.2 Flags for POSIX Regular Expressions
------------------------------------------

These are the bit flags that you can use in the CFLAGS operand when
compiling a regular expression with `regcomp'.

`REG_EXTENDED'
     Treat the pattern as an extended regular expression, rather than
     as a basic regular expression.

`REG_ICASE'
     Ignore case when matching letters.

`REG_NOSUB'
     Don't bother storing the contents of the MATCHES-PTR array.

`REG_NEWLINE'
     Treat a newline in STRING as dividing STRING into multiple lines,
     so that `$' can match before the newline and `^' can match after.
     Also, don't permit `.' to match a newline, and don't permit
     `[^...]' to match a newline.

     Otherwise, newline acts like any other ordinary character.


File: libc.info,  Node: Matching POSIX Regexps,  Next: Regexp Subexpressions,  Prev: Flags for POSIX Regexps,  Up: Regular Expressions

10.3.3 Matching a Compiled POSIX Regular Expression
---------------------------------------------------

Once you have compiled a regular expression, as described in *Note
POSIX Regexp Compilation::, you can match it against strings using
`regexec'.  A match anywhere inside the string counts as success,
unless the regular expression contains anchor characters (`^' or `$').

 -- Function: int regexec (const regex_t *restrict COMPILED, const char
          *restrict STRING, size_t NMATCH, regmatch_t
          MATCHPTR[restrict], int EFLAGS)
     This function tries to match the compiled regular expression
     `*COMPILED' against STRING.

     `regexec' returns `0' if the regular expression matches;
     otherwise, it returns a nonzero value.  See the table below for
     what nonzero values mean.  You can use `regerror' to produce an
     error message string describing the reason for a nonzero value;
     see *Note Regexp Cleanup::.

     The argument EFLAGS is a word of bit flags that enable various
     options.

     If you want to get information about what part of STRING actually
     matched the regular expression or its subexpressions, use the
     arguments MATCHPTR and NMATCH.  Otherwise, pass `0' for NMATCH,
     and `NULL' for MATCHPTR.  *Note Regexp Subexpressions::.

   You must match the regular expression with the same set of current
locales that were in effect when you compiled the regular expression.

   The function `regexec' accepts the following flags in the EFLAGS
argument:

`REG_NOTBOL'
     Do not regard the beginning of the specified string as the
     beginning of a line; more generally, don't make any assumptions
     about what text might precede it.

`REG_NOTEOL'
     Do not regard the end of the specified string as the end of a
     line; more generally, don't make any assumptions about what text
     might follow it.

   Here are the possible nonzero values that `regexec' can return:

`REG_NOMATCH'
     The pattern didn't match the string.  This isn't really an error.

`REG_ESPACE'
     `regexec' ran out of memory.


File: libc.info,  Node: Regexp Subexpressions,  Next: Subexpression Complications,  Prev: Matching POSIX Regexps,  Up: Regular Expressions

10.3.4 Match Results with Subexpressions
----------------------------------------

When `regexec' matches parenthetical subexpressions of PATTERN, it
records which parts of STRING they match.  It returns that information
by storing the offsets into an array whose elements are structures of
type `regmatch_t'.  The first element of the array (index `0') records
the part of the string that matched the entire regular expression.
Each other element of the array records the beginning and end of the
part that matched a single parenthetical subexpression.

 -- Data Type: regmatch_t
     This is the data type of the MATCHARRAY array that you pass to
     `regexec'.  It contains two structure fields, as follows:

    `rm_so'
          The offset in STRING of the beginning of a substring.  Add
          this value to STRING to get the address of that part.

    `rm_eo'
          The offset in STRING of the end of the substring.

 -- Data Type: regoff_t
     `regoff_t' is an alias for another signed integer type.  The
     fields of `regmatch_t' have type `regoff_t'.

   The `regmatch_t' elements correspond to subexpressions positionally;
the first element (index `1') records where the first subexpression
matched, the second element records the second subexpression, and so
on.  The order of the subexpressions is the order in which they begin.

   When you call `regexec', you specify how long the MATCHPTR array is,
with the NMATCH argument.  This tells `regexec' how many elements to
store.  If the actual regular expression has more than NMATCH
subexpressions, then you won't get offset information about the rest of
them.  But this doesn't alter whether the pattern matches a particular
string or not.

   If you don't want `regexec' to return any information about where
the subexpressions matched, you can either supply `0' for NMATCH, or
use the flag `REG_NOSUB' when you compile the pattern with `regcomp'.


File: libc.info,  Node: Subexpression Complications,  Next: Regexp Cleanup,  Prev: Regexp Subexpressions,  Up: Regular Expressions

10.3.5 Complications in Subexpression Matching
----------------------------------------------

Sometimes a subexpression matches a substring of no characters.  This
happens when `f\(o*\)' matches the string `fum'.  (It really matches
just the `f'.)  In this case, both of the offsets identify the point in
the string where the null substring was found.  In this example, the
offsets are both `1'.

   Sometimes the entire regular expression can match without using some
of its subexpressions at all--for example, when `ba\(na\)*' matches the
string `ba', the parenthetical subexpression is not used.  When this
happens, `regexec' stores `-1' in both fields of the element for that
subexpression.

   Sometimes matching the entire regular expression can match a
particular subexpression more than once--for example, when `ba\(na\)*'
matches the string `bananana', the parenthetical subexpression matches
three times.  When this happens, `regexec' usually stores the offsets
of the last part of the string that matched the subexpression.  In the
case of `bananana', these offsets are `6' and `8'.

   But the last match is not always the one that is chosen.  It's more
accurate to say that the last _opportunity_ to match is the one that
takes precedence.  What this means is that when one subexpression
appears within another, then the results reported for the inner
subexpression reflect whatever happened on the last match of the outer
subexpression.  For an example, consider `\(ba\(na\)*s \)*' matching
the string `bananas bas '.  The last time the inner expression actually
matches is near the end of the first word.  But it is _considered_
again in the second word, and fails to match there.  `regexec' reports
nonuse of the "na" subexpression.

   Another place where this rule applies is when the regular expression
     \(ba\(na\)*s \|nefer\(ti\)* \)*
   matches `bananas nefertiti'.  The "na" subexpression does match in
the first word, but it doesn't match in the second word because the
other alternative is used there.  Once again, the second repetition of
the outer subexpression overrides the first, and within that second
repetition, the "na" subexpression is not used.  So `regexec' reports
nonuse of the "na" subexpression.


File: libc.info,  Node: Regexp Cleanup,  Prev: Subexpression Complications,  Up: Regular Expressions

10.3.6 POSIX Regexp Matching Cleanup
------------------------------------

When you are finished using a compiled regular expression, you can free
the storage it uses by calling `regfree'.

 -- Function: void regfree (regex_t *COMPILED)
     Calling `regfree' frees all the storage that `*COMPILED' points
     to.  This includes various internal fields of the `regex_t'
     structure that aren't documented in this manual.

     `regfree' does not free the object `*COMPILED' itself.

   You should always free the space in a `regex_t' structure with
`regfree' before using the structure to compile another regular
expression.

   When `regcomp' or `regexec' reports an error, you can use the
function `regerror' to turn it into an error message string.

 -- Function: size_t regerror (int ERRCODE, const regex_t *restrict
          COMPILED, char *restrict BUFFER, size_t LENGTH)
     This function produces an error message string for the error code
     ERRCODE, and stores the string in LENGTH bytes of memory starting
     at BUFFER.  For the COMPILED argument, supply the same compiled
     regular expression structure that `regcomp' or `regexec' was
     working with when it got the error.  Alternatively, you can supply
     `NULL' for COMPILED; you will still get a meaningful error
     message, but it might not be as detailed.

     If the error message can't fit in LENGTH bytes (including a
     terminating null character), then `regerror' truncates it.  The
     string that `regerror' stores is always null-terminated even if it
     has been truncated.

     The return value of `regerror' is the minimum length needed to
     store the entire error message.  If this is less than LENGTH, then
     the error message was not truncated, and you can use it.
     Otherwise, you should call `regerror' again with a larger buffer.

     Here is a function which uses `regerror', but always dynamically
     allocates a buffer for the error message:

          char *get_regerror (int errcode, regex_t *compiled)
          {
            size_t length = regerror (errcode, compiled, NULL, 0);
            char *buffer = xmalloc (length);
            (void) regerror (errcode, compiled, buffer, length);
            return buffer;
          }


File: libc.info,  Node: Word Expansion,  Prev: Regular Expressions,  Up: Pattern Matching

10.4 Shell-Style Word Expansion
===============================

"Word expansion" means the process of splitting a string into "words"
and substituting for variables, commands, and wildcards just as the
shell does.

   For example, when you write `ls -l foo.c', this string is split into
three separate words--`ls', `-l' and `foo.c'.  This is the most basic
function of word expansion.

   When you write `ls *.c', this can become many words, because the
word `*.c' can be replaced with any number of file names.  This is
called "wildcard expansion", and it is also a part of word expansion.

   When you use `echo $PATH' to print your path, you are taking
advantage of "variable substitution", which is also part of word
expansion.

   Ordinary programs can perform word expansion just like the shell by
calling the library function `wordexp'.

* Menu:

* Expansion Stages::            What word expansion does to a string.
* Calling Wordexp::             How to call `wordexp'.
* Flags for Wordexp::           Options you can enable in `wordexp'.
* Wordexp Example::             A sample program that does word expansion.
* Tilde Expansion::             Details of how tilde expansion works.
* Variable Substitution::       Different types of variable substitution.


File: libc.info,  Node: Expansion Stages,  Next: Calling Wordexp,  Up: Word Expansion

10.4.1 The Stages of Word Expansion
-----------------------------------

When word expansion is applied to a sequence of words, it performs the
following transformations in the order shown here:

  1. "Tilde expansion": Replacement of `~foo' with the name of the home
     directory of `foo'.

  2. Next, three different transformations are applied in the same step,
     from left to right:

        * "Variable substitution": Environment variables are
          substituted for references such as `$foo'.

        * "Command substitution": Constructs such as ``cat foo`' and
          the equivalent `$(cat foo)' are replaced with the output from
          the inner command.

        * "Arithmetic expansion": Constructs such as `$(($x-1))' are
          replaced with the result of the arithmetic computation.

  3. "Field splitting": subdivision of the text into "words".

  4. "Wildcard expansion": The replacement of a construct such as `*.c'
     with a list of `.c' file names.  Wildcard expansion applies to an
     entire word at a time, and replaces that word with 0 or more file
     names that are themselves words.

  5. "Quote removal": The deletion of string-quotes, now that they have
     done their job by inhibiting the above transformations when
     appropriate.

   For the details of these transformations, and how to write the
constructs that use them, see `The BASH Manual' (to appear).


File: libc.info,  Node: Calling Wordexp,  Next: Flags for Wordexp,  Prev: Expansion Stages,  Up: Word Expansion

10.4.2 Calling `wordexp'
------------------------

All the functions, constants and data types for word expansion are
declared in the header file `wordexp.h'.

   Word expansion produces a vector of words (strings).  To return this
vector, `wordexp' uses a special data type, `wordexp_t', which is a
structure.  You pass `wordexp' the address of the structure, and it
fills in the structure's fields to tell you about the results.

 -- Data Type: wordexp_t
     This data type holds a pointer to a word vector.  More precisely,
     it records both the address of the word vector and its size.

    `we_wordc'
          The number of elements in the vector.

    `we_wordv'
          The address of the vector.  This field has type `char **'.

    `we_offs'
          The offset of the first real element of the vector, from its
          nominal address in the `we_wordv' field.  Unlike the other
          fields, this is always an input to `wordexp', rather than an
          output from it.

          If you use a nonzero offset, then that many elements at the
          beginning of the vector are left empty.  (The `wordexp'
          function fills them with null pointers.)

          The `we_offs' field is meaningful only if you use the
          `WRDE_DOOFFS' flag.  Otherwise, the offset is always zero
          regardless of what is in this field, and the first real
          element comes at the beginning of the vector.

 -- Function: int wordexp (const char *WORDS, wordexp_t
          *WORD-VECTOR-PTR, int FLAGS)
     Perform word expansion on the string WORDS, putting the result in
     a newly allocated vector, and store the size and address of this
     vector into `*WORD-VECTOR-PTR'.  The argument FLAGS is a
     combination of bit flags; see *Note Flags for Wordexp::, for
     details of the flags.

     You shouldn't use any of the characters `|&;<>' in the string
     WORDS unless they are quoted; likewise for newline.  If you use
     these characters unquoted, you will get the `WRDE_BADCHAR' error
     code.  Don't use parentheses or braces unless they are quoted or
     part of a word expansion construct.  If you use quotation
     characters `'"`', they should come in pairs that balance.

     The results of word expansion are a sequence of words.  The
     function `wordexp' allocates a string for each resulting word, then
     allocates a vector of type `char **' to store the addresses of
     these strings.  The last element of the vector is a null pointer.
     This vector is called the "word vector".

     To return this vector, `wordexp' stores both its address and its
     length (number of elements, not counting the terminating null
     pointer) into `*WORD-VECTOR-PTR'.

     If `wordexp' succeeds, it returns 0.  Otherwise, it returns one of
     these error codes:

    `WRDE_BADCHAR'
          The input string WORDS contains an unquoted invalid character
          such as `|'.

    `WRDE_BADVAL'
          The input string refers to an undefined shell variable, and
          you used the flag `WRDE_UNDEF' to forbid such references.

    `WRDE_CMDSUB'
          The input string uses command substitution, and you used the
          flag `WRDE_NOCMD' to forbid command substitution.

    `WRDE_NOSPACE'
          It was impossible to allocate memory to hold the result.  In
          this case, `wordexp' can store part of the results--as much
          as it could allocate room for.

    `WRDE_SYNTAX'
          There was a syntax error in the input string.  For example,
          an unmatched quoting character is a syntax error.

 -- Function: void wordfree (wordexp_t *WORD-VECTOR-PTR)
     Free the storage used for the word-strings and vector that
     `*WORD-VECTOR-PTR' points to.  This does not free the structure
     `*WORD-VECTOR-PTR' itself--only the other data it points to.


File: libc.info,  Node: Flags for Wordexp,  Next: Wordexp Example,  Prev: Calling Wordexp,  Up: Word Expansion

10.4.3 Flags for Word Expansion
-------------------------------

This section describes the flags that you can specify in the FLAGS
argument to `wordexp'.  Choose the flags you want, and combine them
with the C operator `|'.

`WRDE_APPEND'
     Append the words from this expansion to the vector of words
     produced by previous calls to `wordexp'.  This way you can
     effectively expand several words as if they were concatenated with
     spaces between them.

     In order for appending to work, you must not modify the contents
     of the word vector structure between calls to `wordexp'.  And, if
     you set `WRDE_DOOFFS' in the first call to `wordexp', you must also
     set it when you append to the results.

`WRDE_DOOFFS'
     Leave blank slots at the beginning of the vector of words.  The
     `we_offs' field says how many slots to leave.  The blank slots
     contain null pointers.

`WRDE_NOCMD'
     Don't do command substitution; if the input requests command
     substitution, report an error.

`WRDE_REUSE'
     Reuse a word vector made by a previous call to `wordexp'.  Instead
     of allocating a new vector of words, this call to `wordexp' will
     use the vector that already exists (making it larger if necessary).

     Note that the vector may move, so it is not safe to save an old
     pointer and use it again after calling `wordexp'.  You must fetch
     `we_pathv' anew after each call.

`WRDE_SHOWERR'
     Do show any error messages printed by commands run by command
     substitution.  More precisely, allow these commands to inherit the
     standard error output stream of the current process.  By default,
     `wordexp' gives these commands a standard error stream that
     discards all output.

`WRDE_UNDEF'
     If the input refers to a shell variable that is not defined,
     report an error.


File: libc.info,  Node: Wordexp Example,  Next: Tilde Expansion,  Prev: Flags for Wordexp,  Up: Word Expansion

10.4.4 `wordexp' Example
------------------------

Here is an example of using `wordexp' to expand several strings and use
the results to run a shell command.  It also shows the use of
`WRDE_APPEND' to concatenate the expansions and of `wordfree' to free
the space allocated by `wordexp'.

     int
     expand_and_execute (const char *program, const char **options)
     {
       wordexp_t result;
       pid_t pid
       int status, i;

       /* Expand the string for the program to run.  */
       switch (wordexp (program, &result, 0))
         {
         case 0:			/* Successful.  */
           break;
         case WRDE_NOSPACE:
           /* If the error was `WRDE_NOSPACE',
              then perhaps part of the result was allocated.  */
           wordfree (&result);
         default:                    /* Some other error.  */
           return -1;
         }

       /* Expand the strings specified for the arguments.  */
       for (i = 0; options[i] != NULL; i++)
         {
           if (wordexp (options[i], &result, WRDE_APPEND))
             {
               wordfree (&result);
               return -1;
             }
         }

       pid = fork ();
       if (pid == 0)
         {
           /* This is the child process.  Execute the command. */
           execv (result.we_wordv[0], result.we_wordv);
           exit (EXIT_FAILURE);
         }
       else if (pid < 0)
         /* The fork failed.  Report failure.  */
         status = -1;
       else
         /* This is the parent process.  Wait for the child to complete.  */
         if (waitpid (pid, &status, 0) != pid)
           status = -1;

       wordfree (&result);
       return status;
     }


File: libc.info,  Node: Tilde Expansion,  Next: Variable Substitution,  Prev: Wordexp Example,  Up: Word Expansion

10.4.5 Details of Tilde Expansion
---------------------------------

It's a standard part of shell syntax that you can use `~' at the
beginning of a file name to stand for your own home directory.  You can
use `~USER' to stand for USER's home directory.

   "Tilde expansion" is the process of converting these abbreviations
to the directory names that they stand for.

   Tilde expansion applies to the `~' plus all following characters up
to whitespace or a slash.  It takes place only at the beginning of a
word, and only if none of the characters to be transformed is quoted in
any way.

   Plain `~' uses the value of the environment variable `HOME' as the
proper home directory name.  `~' followed by a user name uses
`getpwname' to look up that user in the user database, and uses
whatever directory is recorded there.  Thus, `~' followed by your own
name can give different results from plain `~', if the value of `HOME'
is not really your home directory.


File: libc.info,  Node: Variable Substitution,  Prev: Tilde Expansion,  Up: Word Expansion

10.4.6 Details of Variable Substitution
---------------------------------------

Part of ordinary shell syntax is the use of `$VARIABLE' to substitute
the value of a shell variable into a command.  This is called "variable
substitution", and it is one part of doing word expansion.

   There are two basic ways you can write a variable reference for
substitution:

`${VARIABLE}'
     If you write braces around the variable name, then it is completely
     unambiguous where the variable name ends.  You can concatenate
     additional letters onto the end of the variable value by writing
     them immediately after the close brace.  For example, `${foo}s'
     expands into `tractors'.

`$VARIABLE'
     If you do not put braces around the variable name, then the
     variable name consists of all the alphanumeric characters and
     underscores that follow the `$'.  The next punctuation character
     ends the variable name.  Thus, `$foo-bar' refers to the variable
     `foo' and expands into `tractor-bar'.

   When you use braces, you can also use various constructs to modify
the value that is substituted, or test it in various ways.

`${VARIABLE:-DEFAULT}'
     Substitute the value of VARIABLE, but if that is empty or
     undefined, use DEFAULT instead.

`${VARIABLE:=DEFAULT}'
     Substitute the value of VARIABLE, but if that is empty or
     undefined, use DEFAULT instead and set the variable to DEFAULT.

`${VARIABLE:?MESSAGE}'
     If VARIABLE is defined and not empty, substitute its value.

     Otherwise, print MESSAGE as an error message on the standard error
     stream, and consider word expansion a failure.

`${VARIABLE:+REPLACEMENT}'
     Substitute REPLACEMENT, but only if VARIABLE is defined and
     nonempty.  Otherwise, substitute nothing for this construct.

`${#VARIABLE}'
     Substitute a numeral which expresses in base ten the number of
     characters in the value of VARIABLE.  `${#foo}' stands for `7',
     because `tractor' is seven characters.

   These variants of variable substitution let you remove part of the
variable's value before substituting it.  The PREFIX and SUFFIX are not
mere strings; they are wildcard patterns, just like the patterns that
you use to match multiple file names.  But in this context, they match
against parts of the variable value rather than against file names.

`${VARIABLE%%SUFFIX}'
     Substitute the value of VARIABLE, but first discard from that
     variable any portion at the end that matches the pattern SUFFIX.

     If there is more than one alternative for how to match against
     SUFFIX, this construct uses the longest possible match.

     Thus, `${foo%%r*}' substitutes `t', because the largest match for
     `r*' at the end of `tractor' is `ractor'.

`${VARIABLE%SUFFIX}'
     Substitute the value of VARIABLE, but first discard from that
     variable any portion at the end that matches the pattern SUFFIX.

     If there is more than one alternative for how to match against
     SUFFIX, this construct uses the shortest possible alternative.

     Thus, `${foo%r*}' substitutes `tracto', because the shortest match
     for `r*' at the end of `tractor' is just `r'.

`${VARIABLE##PREFIX}'
     Substitute the value of VARIABLE, but first discard from that
     variable any portion at the beginning that matches the pattern
     PREFIX.

     If there is more than one alternative for how to match against
     PREFIX, this construct uses the longest possible match.

     Thus, `${foo##*t}' substitutes `or', because the largest match for
     `*t' at the beginning of `tractor' is `tract'.

`${VARIABLE#PREFIX}'
     Substitute the value of VARIABLE, but first discard from that
     variable any portion at the beginning that matches the pattern
     PREFIX.

     If there is more than one alternative for how to match against
     PREFIX, this construct uses the shortest possible alternative.

     Thus, `${foo#*t}' substitutes `ractor', because the shortest match
     for `*t' at the beginning of `tractor' is just `t'.



File: libc.info,  Node: I/O Overview,  Next: I/O on Streams,  Prev: Pattern Matching,  Up: Top

11 Input/Output Overview
************************

Most programs need to do either input (reading data) or output (writing
data), or most frequently both, in order to do anything useful.  The GNU
C library provides such a large selection of input and output functions
that the hardest part is often deciding which function is most
appropriate!

   This chapter introduces concepts and terminology relating to input
and output.  Other chapters relating to the GNU I/O facilities are:

   * *Note I/O on Streams::, which covers the high-level functions that
     operate on streams, including formatted input and output.

   * *Note Low-Level I/O::, which covers the basic I/O and control
     functions on file descriptors.

   * *Note File System Interface::, which covers functions for
     operating on directories and for manipulating file attributes such
     as access modes and ownership.

   * *Note Pipes and FIFOs::, which includes information on the basic
     interprocess communication facilities.

   * *Note Sockets::, which covers a more complicated interprocess
     communication facility with support for networking.

   * *Note Low-Level Terminal Interface::, which covers functions for
     changing how input and output to terminals or other serial devices
     are processed.

* Menu:

* I/O Concepts::       Some basic information and terminology.
* File Names::         How to refer to a file.


File: libc.info,  Node: I/O Concepts,  Next: File Names,  Up: I/O Overview

11.1 Input/Output Concepts
==========================

Before you can read or write the contents of a file, you must establish
a connection or communications channel to the file.  This process is
called "opening" the file.  You can open a file for reading, writing,
or both.  

   The connection to an open file is represented either as a stream or
as a file descriptor.  You pass this as an argument to the functions
that do the actual read or write operations, to tell them which file to
operate on.  Certain functions expect streams, and others are designed
to operate on file descriptors.

   When you have finished reading to or writing from the file, you can
terminate the connection by "closing" the file.  Once you have closed a
stream or file descriptor, you cannot do any more input or output
operations on it.

* Menu:

* Streams and File Descriptors::    The GNU Library provides two ways
			             to access the contents of files.
* File Position::                   The number of bytes from the
                                     beginning of the file.


File: libc.info,  Node: Streams and File Descriptors,  Next: File Position,  Up: I/O Concepts

11.1.1 Streams and File Descriptors
-----------------------------------

When you want to do input or output to a file, you have a choice of two
basic mechanisms for representing the connection between your program
and the file: file descriptors and streams.  File descriptors are
represented as objects of type `int', while streams are represented as
`FILE *' objects.

   File descriptors provide a primitive, low-level interface to input
and output operations.  Both file descriptors and streams can represent
a connection to a device (such as a terminal), or a pipe or socket for
communicating with another process, as well as a normal file.  But, if
you want to do control operations that are specific to a particular kind
of device, you must use a file descriptor; there are no facilities to
use streams in this way.  You must also use file descriptors if your
program needs to do input or output in special modes, such as
nonblocking (or polled) input (*note File Status Flags::).

   Streams provide a higher-level interface, layered on top of the
primitive file descriptor facilities.  The stream interface treats all
kinds of files pretty much alike--the sole exception being the three
styles of buffering that you can choose (*note Stream Buffering::).

   The main advantage of using the stream interface is that the set of
functions for performing actual input and output operations (as opposed
to control operations) on streams is much richer and more powerful than
the corresponding facilities for file descriptors.  The file descriptor
interface provides only simple functions for transferring blocks of
characters, but the stream interface also provides powerful formatted
input and output functions (`printf' and `scanf') as well as functions
for character- and line-oriented input and output.

   Since streams are implemented in terms of file descriptors, you can
extract the file descriptor from a stream and perform low-level
operations directly on the file descriptor.  You can also initially open
a connection as a file descriptor and then make a stream associated with
that file descriptor.

   In general, you should stick with using streams rather than file
descriptors, unless there is some specific operation you want to do that
can only be done on a file descriptor.  If you are a beginning
programmer and aren't sure what functions to use, we suggest that you
concentrate on the formatted input functions (*note Formatted Input::)
and formatted output functions (*note Formatted Output::).

   If you are concerned about portability of your programs to systems
other than GNU, you should also be aware that file descriptors are not
as portable as streams.  You can expect any system running ISO C to
support streams, but non-GNU systems may not support file descriptors at
all, or may only implement a subset of the GNU functions that operate on
file descriptors.  Most of the file descriptor functions in the GNU
library are included in the POSIX.1 standard, however.


File: libc.info,  Node: File Position,  Prev: Streams and File Descriptors,  Up: I/O Concepts

11.1.2 File Position
--------------------

One of the attributes of an open file is its "file position" that keeps
track of where in the file the next character is to be read or written.
In the GNU system, and all POSIX.1 systems, the file position is
simply an integer representing the number of bytes from the beginning
of the file.

   The file position is normally set to the beginning of the file when
it is opened, and each time a character is read or written, the file
position is incremented.  In other words, access to the file is normally
"sequential".  

   Ordinary files permit read or write operations at any position within
the file.  Some other kinds of files may also permit this.  Files which
do permit this are sometimes referred to as "random-access" files.  You
can change the file position using the `fseek' function on a stream
(*note File Positioning::) or the `lseek' function on a file descriptor
(*note I/O Primitives::).  If you try to change the file position on a
file that doesn't support random access, you get the `ESPIPE' error.  

   Streams and descriptors that are opened for "append access" are
treated specially for output: output to such files is _always_ appended
sequentially to the _end_ of the file, regardless of the file position.
However, the file position is still used to control where in the file
reading is done.  

   If you think about it, you'll realize that several programs can read
a given file at the same time.  In order for each program to be able to
read the file at its own pace, each program must have its own file
pointer, which is not affected by anything the other programs do.

   In fact, each opening of a file creates a separate file position.
Thus, if you open a file twice even in the same program, you get two
streams or descriptors with independent file positions.

   By contrast, if you open a descriptor and then duplicate it to get
another descriptor, these two descriptors share the same file position:
changing the file position of one descriptor will affect the other.


File: libc.info,  Node: File Names,  Prev: I/O Concepts,  Up: I/O Overview

11.2 File Names
===============

In order to open a connection to a file, or to perform other operations
such as deleting a file, you need some way to refer to the file.  Nearly
all files have names that are strings--even files which are actually
devices such as tape drives or terminals.  These strings are called
"file names".  You specify the file name to say which file you want to
open or operate on.

   This section describes the conventions for file names and how the
operating system works with them.  

* Menu:

* Directories::                 Directories contain entries for files.
* File Name Resolution::        A file name specifies how to look up a file.
* File Name Errors::            Error conditions relating to file names.
* File Name Portability::       File name portability and syntax issues.


File: libc.info,  Node: Directories,  Next: File Name Resolution,  Up: File Names

11.2.1 Directories
------------------

In order to understand the syntax of file names, you need to understand
how the file system is organized into a hierarchy of directories.

   A "directory" is a file that contains information to associate other
files with names; these associations are called "links" or "directory
entries".  Sometimes, people speak of "files in a directory", but in
reality, a directory only contains pointers to files, not the files
themselves.

   The name of a file contained in a directory entry is called a "file
name component".  In general, a file name consists of a sequence of one
or more such components, separated by the slash character (`/').  A
file name which is just one component names a file with respect to its
directory.  A file name with multiple components names a directory, and
then a file in that directory, and so on.

   Some other documents, such as the POSIX standard, use the term
"pathname" for what we call a file name, and either "filename" or
"pathname component" for what this manual calls a file name component.
We don't use this terminology because a "path" is something completely
different (a list of directories to search), and we think that
"pathname" used for something else will confuse users.  We always use
"file name" and "file name component" (or sometimes just "component",
where the context is obvious) in GNU documentation.  Some macros use
the POSIX terminology in their names, such as `PATH_MAX'.  These macros
are defined by the POSIX standard, so we cannot change their names.

   You can find more detailed information about operations on
directories in *Note File System Interface::.


File: libc.info,  Node: File Name Resolution,  Next: File Name Errors,  Prev: Directories,  Up: File Names

11.2.2 File Name Resolution
---------------------------

A file name consists of file name components separated by slash (`/')
characters.  On the systems that the GNU C library supports, multiple
successive `/' characters are equivalent to a single `/' character.

   The process of determining what file a file name refers to is called
"file name resolution".  This is performed by examining the components
that make up a file name in left-to-right order, and locating each
successive component in the directory named by the previous component.
Of course, each of the files that are referenced as directories must
actually exist, be directories instead of regular files, and have the
appropriate permissions to be accessible by the process; otherwise the
file name resolution fails.

   If a file name begins with a `/', the first component in the file
name is located in the "root directory" of the process (usually all
processes on the system have the same root directory).  Such a file name
is called an "absolute file name".

   Otherwise, the first component in the file name is located in the
current working directory (*note Working Directory::).  This kind of
file name is called a "relative file name".

   The file name components `.' ("dot") and `..' ("dot-dot") have
special meanings.  Every directory has entries for these file name
components.  The file name component `.' refers to the directory
itself, while the file name component `..' refers to its "parent
directory" (the directory that contains the link for the directory in
question).  As a special case, `..' in the root directory refers to the
root directory itself, since it has no parent; thus `/..' is the same
as `/'.

   Here are some examples of file names:

`/a'
     The file named `a', in the root directory.

`/a/b'
     The file named `b', in the directory named `a' in the root
     directory.

`a'
     The file named `a', in the current working directory.

`/a/./b'
     This is the same as `/a/b'.

`./a'
     The file named `a', in the current working directory.

`../a'
     The file named `a', in the parent directory of the current working
     directory.

   A file name that names a directory may optionally end in a `/'.  You
can specify a file name of `/' to refer to the root directory, but the
empty string is not a meaningful file name.  If you want to refer to
the current working directory, use a file name of `.' or `./'.

   Unlike some other operating systems, the GNU system doesn't have any
built-in support for file types (or extensions) or file versions as part
of its file name syntax.  Many programs and utilities use conventions
for file names--for example, files containing C source code usually
have names suffixed with `.c'--but there is nothing in the file system
itself that enforces this kind of convention.


File: libc.info,  Node: File Name Errors,  Next: File Name Portability,  Prev: File Name Resolution,  Up: File Names

11.2.3 File Name Errors
-----------------------

Functions that accept file name arguments usually detect these `errno'
error conditions relating to the file name syntax or trouble finding
the named file.  These errors are referred to throughout this manual as
the "usual file name errors".

`EACCES'
     The process does not have search permission for a directory
     component of the file name.

`ENAMETOOLONG'
     This error is used when either the total length of a file name is
     greater than `PATH_MAX', or when an individual file name component
     has a length greater than `NAME_MAX'.  *Note Limits for Files::.

     In the GNU system, there is no imposed limit on overall file name
     length, but some file systems may place limits on the length of a
     component.

`ENOENT'
     This error is reported when a file referenced as a directory
     component in the file name doesn't exist, or when a component is a
     symbolic link whose target file does not exist.  *Note Symbolic
     Links::.

`ENOTDIR'
     A file that is referenced as a directory component in the file name
     exists, but it isn't a directory.

`ELOOP'
     Too many symbolic links were resolved while trying to look up the
     file name.  The system has an arbitrary limit on the number of
     symbolic links that may be resolved in looking up a single file
     name, as a primitive way to detect loops.  *Note Symbolic Links::.


File: libc.info,  Node: File Name Portability,  Prev: File Name Errors,  Up: File Names

11.2.4 Portability of File Names
--------------------------------

The rules for the syntax of file names discussed in *Note File Names::,
are the rules normally used by the GNU system and by other POSIX
systems.  However, other operating systems may use other conventions.

   There are two reasons why it can be important for you to be aware of
file name portability issues:

   * If your program makes assumptions about file name syntax, or
     contains embedded literal file name strings, it is more difficult
     to get it to run under other operating systems that use different
     syntax conventions.

   * Even if you are not concerned about running your program on
     machines that run other operating systems, it may still be
     possible to access files that use different naming conventions.
     For example, you may be able to access file systems on another
     computer running a different operating system over a network, or
     read and write disks in formats used by other operating systems.

   The ISO C standard says very little about file name syntax, only that
file names are strings.  In addition to varying restrictions on the
length of file names and what characters can validly appear in a file
name, different operating systems use different conventions and syntax
for concepts such as structured directories and file types or
extensions.  Some concepts such as file versions might be supported in
some operating systems and not by others.

   The POSIX.1 standard allows implementations to put additional
restrictions on file name syntax, concerning what characters are
permitted in file names and on the length of file name and file name
component strings.  However, in the GNU system, you do not need to worry
about these restrictions; any character except the null character is
permitted in a file name string, and there are no limits on the length
of file name strings.


File: libc.info,  Node: I/O on Streams,  Next: Low-Level I/O,  Prev: I/O Overview,  Up: Top

12 Input/Output on Streams
**************************

This chapter describes the functions for creating streams and performing
input and output operations on them.  As discussed in *Note I/O
Overview::, a stream is a fairly abstract, high-level concept
representing a communications channel to a file, device, or process.

* Menu:

* Streams::                     About the data type representing a stream.
* Standard Streams::            Streams to the standard input and output
                                 devices are created for you.
* Opening Streams::             How to create a stream to talk to a file.
* Closing Streams::             Close a stream when you are finished with it.
* Streams and Threads::         Issues with streams in threaded programs.
* Streams and I18N::            Streams in internationalized applications.
* Simple Output::               Unformatted output by characters and lines.
* Character Input::             Unformatted input by characters and words.
* Line Input::                  Reading a line or a record from a stream.
* Unreading::                   Peeking ahead/pushing back input just read.
* Block Input/Output::          Input and output operations on blocks of data.
* Formatted Output::            `printf' and related functions.
* Customizing Printf::          You can define new conversion specifiers for
                                 `printf' and friends.
* Formatted Input::             `scanf' and related functions.
* EOF and Errors::              How you can tell if an I/O error happens.
* Error Recovery::		What you can do about errors.
* Binary Streams::              Some systems distinguish between text files
                                 and binary files.
* File Positioning::            About random-access streams.
* Portable Positioning::        Random access on peculiar ISO C systems.
* Stream Buffering::            How to control buffering of streams.
* Other Kinds of Streams::      Streams that do not necessarily correspond
                                 to an open file.
* Formatted Messages::          Print strictly formatted messages.


File: libc.info,  Node: Streams,  Next: Standard Streams,  Up: I/O on Streams

12.1 Streams
============

For historical reasons, the type of the C data structure that represents
a stream is called `FILE' rather than "stream".  Since most of the
library functions deal with objects of type `FILE *', sometimes the
term "file pointer" is also used to mean "stream".  This leads to
unfortunate confusion over terminology in many books on C.  This
manual, however, is careful to use the terms "file" and "stream" only
in the technical sense.  

   The `FILE' type is declared in the header file `stdio.h'.

 -- Data Type: FILE
     This is the data type used to represent stream objects.  A `FILE'
     object holds all of the internal state information about the
     connection to the associated file, including such things as the
     file position indicator and buffering information.  Each stream
     also has error and end-of-file status indicators that can be
     tested with the `ferror' and `feof' functions; see *Note EOF and
     Errors::.

   `FILE' objects are allocated and managed internally by the
input/output library functions.  Don't try to create your own objects of
type `FILE'; let the library do it.  Your programs should deal only
with pointers to these objects (that is, `FILE *' values) rather than
the objects themselves.


File: libc.info,  Node: Standard Streams,  Next: Opening Streams,  Prev: Streams,  Up: I/O on Streams

12.2 Standard Streams
=====================

When the `main' function of your program is invoked, it already has
three predefined streams open and available for use.  These represent
the "standard" input and output channels that have been established for
the process.

   These streams are declared in the header file `stdio.h'.  

 -- Variable: FILE * stdin
     The "standard input" stream, which is the normal source of input
     for the program.
   
 -- Variable: FILE * stdout
     The "standard output" stream, which is used for normal output from
     the program.
   
 -- Variable: FILE * stderr
     The "standard error" stream, which is used for error messages and
     diagnostics issued by the program.
   
   In the GNU system, you can specify what files or processes
correspond to these streams using the pipe and redirection facilities
provided by the shell.  (The primitives shells use to implement these
facilities are described in *Note File System Interface::.)  Most other
operating systems provide similar mechanisms, but the details of how to
use them can vary.

   In the GNU C library, `stdin', `stdout', and `stderr' are normal
variables which you can set just like any others.  For example, to
redirect the standard output to a file, you could do:

     fclose (stdout);
     stdout = fopen ("standard-output-file", "w");

   Note however, that in other systems `stdin', `stdout', and `stderr'
are macros that you cannot assign to in the normal way.  But you can
use `freopen' to get the effect of closing one and reopening it.  *Note
Opening Streams::.

   The three streams `stdin', `stdout', and `stderr' are not unoriented
at program start (*note Streams and I18N::).


File: libc.info,  Node: Opening Streams,  Next: Closing Streams,  Prev: Standard Streams,  Up: I/O on Streams

12.3 Opening Streams
====================

Opening a file with the `fopen' function creates a new stream and
establishes a connection between the stream and a file.  This may
involve creating a new file.

   Everything described in this section is declared in the header file
`stdio.h'.

 -- Function: FILE * fopen (const char *FILENAME, const char *OPENTYPE)
     The `fopen' function opens a stream for I/O to the file FILENAME,
     and returns a pointer to the stream.

     The OPENTYPE argument is a string that controls how the file is
     opened and specifies attributes of the resulting stream.  It must
     begin with one of the following sequences of characters:

    `r'
          Open an existing file for reading only.

    `w'
          Open the file for writing only.  If the file already exists,
          it is truncated to zero length.  Otherwise a new file is
          created.

    `a'
          Open a file for append access; that is, writing at the end of
          file only.  If the file already exists, its initial contents
          are unchanged and output to the stream is appended to the end
          of the file.  Otherwise, a new, empty file is created.

    `r+'
          Open an existing file for both reading and writing.  The
          initial contents of the file are unchanged and the initial
          file position is at the beginning of the file.

    `w+'
          Open a file for both reading and writing.  If the file
          already exists, it is truncated to zero length.  Otherwise, a
          new file is created.

    `a+'
          Open or create file for both reading and appending.  If the
          file exists, its initial contents are unchanged.  Otherwise,
          a new file is created.  The initial file position for reading
          is at the beginning of the file, but output is always
          appended to the end of the file.

     As you can see, `+' requests a stream that can do both input and
     output.  The ISO standard says that when using such a stream, you
     must call `fflush' (*note Stream Buffering::) or a file positioning
     function such as `fseek' (*note File Positioning::) when switching
     from reading to writing or vice versa.  Otherwise, internal buffers
     might not be emptied properly.  The GNU C library does not have
     this limitation; you can do arbitrary reading and writing
     operations on a stream in whatever order.

     Additional characters may appear after these to specify flags for
     the call.  Always put the mode (`r', `w+', etc.) first; that is
     the only part you are guaranteed will be understood by all systems.

     The GNU C library defines one additional character for use in
     OPENTYPE: the character `x' insists on creating a new file--if a
     file FILENAME already exists, `fopen' fails rather than opening
     it.  If you use `x' you are guaranteed that you will not clobber
     an existing file.  This is equivalent to the `O_EXCL' option to
     the `open' function (*note Opening and Closing Files::).

     The character `b' in OPENTYPE has a standard meaning; it requests
     a binary stream rather than a text stream.  But this makes no
     difference in POSIX systems (including the GNU system).  If both
     `+' and `b' are specified, they can appear in either order.  *Note
     Binary Streams::.

     If the OPENTYPE string contains the sequence `,ccs=STRING' then
     STRING is taken as the name of a coded character set and `fopen'
     will mark the stream as wide-oriented which appropriate conversion
     functions in place to convert from and to the character set STRING
     is place.  Any other stream is opened initially unoriented and the
     orientation is decided with the first file operation.  If the
     first operation is a wide character operation, the stream is not
     only marked as wide-oriented, also the conversion functions to
     convert to the coded character set used for the current locale are
     loaded.  This will not change anymore from this point on even if
     the locale selected for the `LC_CTYPE' category is changed.

     Any other characters in OPENTYPE are simply ignored.  They may be
     meaningful in other systems.

     If the open fails, `fopen' returns a null pointer.

     When the sources are compiling with `_FILE_OFFSET_BITS == 64' on a
     32 bit machine this function is in fact `fopen64' since the LFS
     interface replaces transparently the old interface.

   You can have multiple streams (or file descriptors) pointing to the
same file open at the same time.  If you do only input, this works
straightforwardly, but you must be careful if any output streams are
included.  *Note Stream/Descriptor Precautions::.  This is equally true
whether the streams are in one program (not usual) or in several
programs (which can easily happen).  It may be advantageous to use the
file locking facilities to avoid simultaneous access.  *Note File
Locks::.

 -- Function: FILE * fopen64 (const char *FILENAME, const char
          *OPENTYPE)
     This function is similar to `fopen' but the stream it returns a
     pointer for is opened using `open64'.  Therefore this stream can be
     used even on files larger then 2^31 bytes on 32 bit machines.

     Please note that the return type is still `FILE *'.  There is no
     special `FILE' type for the LFS interface.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a 32
     bits machine this function is available under the name `fopen' and
     so transparently replaces the old interface.

 -- Macro: int FOPEN_MAX
     The value of this macro is an integer constant expression that
     represents the minimum number of streams that the implementation
     guarantees can be open simultaneously.  You might be able to open
     more than this many streams, but that is not guaranteed.  The
     value of this constant is at least eight, which includes the three
     standard streams `stdin', `stdout', and `stderr'.  In POSIX.1
     systems this value is determined by the `OPEN_MAX' parameter;
     *note General Limits::.  In BSD and GNU, it is controlled by the
     `RLIMIT_NOFILE' resource limit; *note Limits on Resources::.

 -- Function: FILE * freopen (const char *FILENAME, const char
          *OPENTYPE, FILE *STREAM)
     This function is like a combination of `fclose' and `fopen'.  It
     first closes the stream referred to by STREAM, ignoring any errors
     that are detected in the process.  (Because errors are ignored,
     you should not use `freopen' on an output stream if you have
     actually done any output using the stream.)  Then the file named by
     FILENAME is opened with mode OPENTYPE as for `fopen', and
     associated with the same stream object STREAM.

     If the operation fails, a null pointer is returned; otherwise,
     `freopen' returns STREAM.

     `freopen' has traditionally been used to connect a standard stream
     such as `stdin' with a file of your own choice.  This is useful in
     programs in which use of a standard stream for certain purposes is
     hard-coded.  In the GNU C library, you can simply close the
     standard streams and open new ones with `fopen'.  But other
     systems lack this ability, so using `freopen' is more portable.

     When the sources are compiling with `_FILE_OFFSET_BITS == 64' on a
     32 bit machine this function is in fact `freopen64' since the LFS
     interface replaces transparently the old interface.

 -- Function: FILE * freopen64 (const char *FILENAME, const char
          *OPENTYPE, FILE *STREAM)
     This function is similar to `freopen'.  The only difference is that
     on 32 bit machine the stream returned is able to read beyond the
     2^31 bytes limits imposed by the normal interface.  It should be
     noted that the stream pointed to by STREAM need not be opened
     using `fopen64' or `freopen64' since its mode is not important for
     this function.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a 32
     bits machine this function is available under the name `freopen'
     and so transparently replaces the old interface.

   In some situations it is useful to know whether a given stream is
available for reading or writing.  This information is normally not
available and would have to be remembered separately.  Solaris
introduced a few functions to get this information from the stream
descriptor and these functions are also available in the GNU C library.

 -- Function: int __freadable (FILE *STREAM)
     The `__freadable' function determines whether the stream STREAM
     was opened to allow reading.  In this case the return value is
     nonzero.  For write-only streams the function returns zero.

     This function is declared in `stdio_ext.h'.

 -- Function: int __fwritable (FILE *STREAM)
     The `__fwritable' function determines whether the stream STREAM
     was opened to allow writing.  In this case the return value is
     nonzero.  For read-only streams the function returns zero.

     This function is declared in `stdio_ext.h'.

   For slightly different kind of problems there are two more functions.
They provide even finer-grained information.

 -- Function: int __freading (FILE *STREAM)
     The `__freading' function determines whether the stream STREAM was
     last read from or whether it is opened read-only.  In this case
     the return value is nonzero, otherwise it is zero.  Determining
     whether a stream opened for reading and writing was last used for
     writing allows to draw conclusions about the content about the
     buffer, among other things.

     This function is declared in `stdio_ext.h'.

 -- Function: int __fwriting (FILE *STREAM)
     The `__fwriting' function determines whether the stream STREAM was
     last written to or whether it is opened write-only.  In this case
     the return value is nonzero, otherwise it is zero.

     This function is declared in `stdio_ext.h'.


File: libc.info,  Node: Closing Streams,  Next: Streams and Threads,  Prev: Opening Streams,  Up: I/O on Streams

12.4 Closing Streams
====================

When a stream is closed with `fclose', the connection between the
stream and the file is canceled.  After you have closed a stream, you
cannot perform any additional operations on it.

 -- Function: int fclose (FILE *STREAM)
     This function causes STREAM to be closed and the connection to the
     corresponding file to be broken.  Any buffered output is written
     and any buffered input is discarded.  The `fclose' function returns
     a value of `0' if the file was closed successfully, and `EOF' if
     an error was detected.

     It is important to check for errors when you call `fclose' to close
     an output stream, because real, everyday errors can be detected at
     this time.  For example, when `fclose' writes the remaining
     buffered output, it might get an error because the disk is full.
     Even if you know the buffer is empty, errors can still occur when
     closing a file if you are using NFS.

     The function `fclose' is declared in `stdio.h'.

   To close all streams currently available the GNU C Library provides
another function.

 -- Function: int fcloseall (void)
     This function causes all open streams of the process to be closed
     and the connection to corresponding files to be broken.  All
     buffered data is written and any buffered input is discarded.  The
     `fcloseall' function returns a value of `0' if all the files were
     closed successfully, and `EOF' if an error was detected.

     This function should be used only in special situations, e.g.,
     when an error occurred and the program must be aborted.  Normally
     each single stream should be closed separately so that problems
     with individual streams can be identified.  It is also problematic
     since the standard streams (*note Standard Streams::) will also be
     closed.

     The function `fcloseall' is declared in `stdio.h'.

   If the `main' function to your program returns, or if you call the
`exit' function (*note Normal Termination::), all open streams are
automatically closed properly.  If your program terminates in any other
manner, such as by calling the `abort' function (*note Aborting a
Program::) or from a fatal signal (*note Signal Handling::), open
streams might not be closed properly.  Buffered output might not be
flushed and files may be incomplete.  For more information on buffering
of streams, see *Note Stream Buffering::.


File: libc.info,  Node: Streams and Threads,  Next: Streams and I18N,  Prev: Closing Streams,  Up: I/O on Streams

12.5 Streams and Threads
========================

Streams can be used in multi-threaded applications in the same way they
are used in single-threaded applications.  But the programmer must be
aware of the possible complications.  It is important to know about
these also if the program one writes never use threads since the design
and implementation of many stream functions is heavily influenced by the
requirements added by multi-threaded programming.

   The POSIX standard requires that by default the stream operations are
atomic.  I.e., issuing two stream operations for the same stream in two
threads at the same time will cause the operations to be executed as if
they were issued sequentially.  The buffer operations performed while
reading or writing are protected from other uses of the same stream.  To
do this each stream has an internal lock object which has to be
(implicitly) acquired before any work can be done.

   But there are situations where this is not enough and there are also
situations where this is not wanted.  The implicit locking is not enough
if the program requires more than one stream function call to happen
atomically.  One example would be if an output line a program wants to
generate is created by several function calls.  The functions by
themselves would ensure only atomicity of their own operation, but not
atomicity over all the function calls.  For this it is necessary to
perform the stream locking in the application code.

 -- Function: void flockfile (FILE *STREAM)
     The `flockfile' function acquires the internal locking object
     associated with the stream STREAM.  This ensures that no other
     thread can explicitly through `flockfile'/`ftrylockfile' or
     implicit through a call of a stream function lock the stream.  The
     thread will block until the lock is acquired.  An explicit call to
     `funlockfile' has to be used to release the lock.

 -- Function: int ftrylockfile (FILE *STREAM)
     The `ftrylockfile' function tries to acquire the internal locking
     object associated with the stream STREAM just like `flockfile'.
     But unlike `flockfile' this function does not block if the lock is
     not available.  `ftrylockfile' returns zero if the lock was
     successfully acquired.  Otherwise the stream is locked by another
     thread.

 -- Function: void funlockfile (FILE *STREAM)
     The `funlockfile' function releases the internal locking object of
     the stream STREAM. The stream must have been locked before by a
     call to `flockfile' or a successful call of `ftrylockfile'.  The
     implicit locking performed by the stream operations do not count.
     The `funlockfile' function does not return an error status and the
     behavior of a call for a stream which is not locked by the current
     thread is undefined.

   The following example shows how the functions above can be used to
generate an output line atomically even in multi-threaded applications
(yes, the same job could be done with one `fprintf' call but it is
sometimes not possible):

     FILE *fp;
     {
        ...
        flockfile (fp);
        fputs ("This is test number ", fp);
        fprintf (fp, "%d\n", test);
        funlockfile (fp)
     }

   Without the explicit locking it would be possible for another thread
to use the stream FP after the `fputs' call return and before `fprintf'
was called with the result that the number does not follow the word
`number'.

   From this description it might already be clear that the locking
objects in streams are no simple mutexes.  Since locking the same
stream twice in the same thread is allowed the locking objects must be
equivalent to recursive mutexes.  These mutexes keep track of the owner
and the number of times the lock is acquired.  The same number of
`funlockfile' calls by the same threads is necessary to unlock the
stream completely.  For instance:

     void
     foo (FILE *fp)
     {
       ftrylockfile (fp);
       fputs ("in foo\n", fp);
       /* This is very wrong!!!  */
       funlockfile (fp);
     }

   It is important here that the `funlockfile' function is only called
if the `ftrylockfile' function succeeded in locking the stream.  It is
therefore always wrong to ignore the result of `ftrylockfile'.  And it
makes no sense since otherwise one would use `flockfile'.  The result
of code like that above is that either `funlockfile' tries to free a
stream that hasn't been locked by the current thread or it frees the
stream prematurely.  The code should look like this:

     void
     foo (FILE *fp)
     {
       if (ftrylockfile (fp) == 0)
         {
           fputs ("in foo\n", fp);
           funlockfile (fp);
         }
     }

   Now that we covered why it is necessary to have these locking it is
necessary to talk about situations when locking is unwanted and what can
be done.  The locking operations (explicit or implicit) don't come for
free.  Even if a lock is not taken the cost is not zero.  The operations
which have to be performed require memory operations that are safe in
multi-processor environments.  With the many local caches involved in
such systems this is quite costly.  So it is best to avoid the locking
completely if it is not needed - because the code in question is never
used in a context where two or more threads may use a stream at a time.
This can be determined most of the time for application code; for
library code which can be used in many contexts one should default to be
conservative and use locking.

   There are two basic mechanisms to avoid locking.  The first is to use
the `_unlocked' variants of the stream operations.  The POSIX standard
defines quite a few of those and the GNU library adds a few more.
These variants of the functions behave just like the functions with the
name without the suffix except that they do not lock the stream.  Using
these functions is very desirable since they are potentially much
faster.  This is not only because the locking operation itself is
avoided.  More importantly, functions like `putc' and `getc' are very
simple and traditionally (before the introduction of threads) were
implemented as macros which are very fast if the buffer is not empty.
With the addition of locking requirements these functions are no longer
implemented as macros since they would expand to too much code.  But
these macros are still available with the same functionality under the
new names `putc_unlocked' and `getc_unlocked'.  This possibly huge
difference of speed also suggests the use of the `_unlocked' functions
even if locking is required.  The difference is that the locking then
has to be performed in the program:

     void
     foo (FILE *fp, char *buf)
     {
       flockfile (fp);
       while (*buf != '/')
         putc_unlocked (*buf++, fp);
       funlockfile (fp);
     }

   If in this example the `putc' function would be used and the
explicit locking would be missing the `putc' function would have to
acquire the lock in every call, potentially many times depending on when
the loop terminates.  Writing it the way illustrated above allows the
`putc_unlocked' macro to be used which means no locking and direct
manipulation of the buffer of the stream.

   A second way to avoid locking is by using a non-standard function
which was introduced in Solaris and is available in the GNU C library
as well.

 -- Function: int __fsetlocking (FILE *STREAM, int TYPE)
     The `__fsetlocking' function can be used to select whether the
     stream operations will implicitly acquire the locking object of the
     stream STREAM.  By default this is done but it can be disabled and
     reinstated using this function.  There are three values defined
     for the TYPE parameter.

    `FSETLOCKING_INTERNAL'
          The stream `stream' will from now on use the default internal
          locking.  Every stream operation with exception of the
          `_unlocked' variants will implicitly lock the stream.

    `FSETLOCKING_BYCALLER'
          After the `__fsetlocking' function returns the user is
          responsible for locking the stream.  None of the stream
          operations will implicitly do this anymore until the state is
          set back to `FSETLOCKING_INTERNAL'.

    `FSETLOCKING_QUERY'
          `__fsetlocking' only queries the current locking state of the
          stream.  The return value will be `FSETLOCKING_INTERNAL' or
          `FSETLOCKING_BYCALLER' depending on the state.

     The return value of `__fsetlocking' is either
     `FSETLOCKING_INTERNAL' or `FSETLOCKING_BYCALLER' depending on the
     state of the stream before the call.

     This function and the values for the TYPE parameter are declared
     in `stdio_ext.h'.

   This function is especially useful when program code has to be used
which is written without knowledge about the `_unlocked' functions (or
if the programmer was too lazy to use them).


File: libc.info,  Node: Streams and I18N,  Next: Simple Output,  Prev: Streams and Threads,  Up: I/O on Streams

12.6 Streams in Internationalized Applications
==============================================

ISO C90 introduced the new type `wchar_t' to allow handling larger
character sets.  What was missing was a possibility to output strings
of `wchar_t' directly.  One had to convert them into multibyte strings
using `mbstowcs' (there was no `mbsrtowcs' yet) and then use the normal
stream functions.  While this is doable it is very cumbersome since
performing the conversions is not trivial and greatly increases program
complexity and size.

   The Unix standard early on (I think in XPG4.2) introduced two
additional format specifiers for the `printf' and `scanf' families of
functions.  Printing and reading of single wide characters was made
possible using the `%C' specifier and wide character strings can be
handled with `%S'.  These modifiers behave just like `%c' and `%s' only
that they expect the corresponding argument to have the wide character
type and that the wide character and string are transformed into/from
multibyte strings before being used.

   This was a beginning but it is still not good enough.  Not always is
it desirable to use `printf' and `scanf'.  The other, smaller and
faster functions cannot handle wide characters.  Second, it is not
possible to have a format string for `printf' and `scanf' consisting of
wide characters.  The result is that format strings would have to be
generated if they have to contain non-basic characters.

   In the Amendment 1 to ISO C90 a whole new set of functions was added
to solve the problem.  Most of the stream functions got a counterpart
which take a wide character or wide character string instead of a
character or string respectively.  The new functions operate on the
same streams (like `stdout').  This is different from the model of the
C++ runtime library where separate streams for wide and normal I/O are
used.

   Being able to use the same stream for wide and normal operations
comes with a restriction: a stream can be used either for wide
operations or for normal operations.  Once it is decided there is no
way back.  Only a call to `freopen' or `freopen64' can reset the
"orientation".  The orientation can be decided in three ways:

   * If any of the normal character functions is used (this includes the
     `fread' and `fwrite' functions) the stream is marked as not wide
     oriented.

   * If any of the wide character functions is used the stream is
     marked as wide oriented.

   * The `fwide' function can be used to set the orientation either way.

   It is important to never mix the use of wide and not wide operations
on a stream.  There are no diagnostics issued.  The application behavior
will simply be strange or the application will simply crash.  The
`fwide' function can help avoiding this.

 -- Function: int fwide (FILE *STREAM, int MODE)
     The `fwide' function can be used to set and query the state of the
     orientation of the stream STREAM.  If the MODE parameter has a
     positive value the streams get wide oriented, for negative values
     narrow oriented.  It is not possible to overwrite previous
     orientations with `fwide'.  I.e., if the stream STREAM was already
     oriented before the call nothing is done.

     If MODE is zero the current orientation state is queried and
     nothing is changed.

     The `fwide' function returns a negative value, zero, or a positive
     value if the stream is narrow, not at all, or wide oriented
     respectively.

     This function was introduced in Amendment 1 to ISO C90 and is
     declared in `wchar.h'.

   It is generally a good idea to orient a stream as early as possible.
This can prevent surprise especially for the standard streams `stdin',
`stdout', and `stderr'.  If some library function in some situations
uses one of these streams and this use orients the stream in a
different way the rest of the application expects it one might end up
with hard to reproduce errors.  Remember that no errors are signal if
the streams are used incorrectly.  Leaving a stream unoriented after
creation is normally only necessary for library functions which create
streams which can be used in different contexts.

   When writing code which uses streams and which can be used in
different contexts it is important to query the orientation of the
stream before using it (unless the rules of the library interface
demand a specific orientation).  The following little, silly function
illustrates this.

     void
     print_f (FILE *fp)
     {
       if (fwide (fp, 0) > 0)
         /* Positive return value means wide orientation.  */
         fputwc (L'f', fp);
       else
         fputc ('f', fp);
     }

   Note that in this case the function `print_f' decides about the
orientation of the stream if it was unoriented before (will not happen
if the advise above is followed).

   The encoding used for the `wchar_t' values is unspecified and the
user must not make any assumptions about it.  For I/O of `wchar_t'
values this means that it is impossible to write these values directly
to the stream.  This is not what follows from the ISO C locale model
either.  What happens instead is that the bytes read from or written to
the underlying media are first converted into the internal encoding
chosen by the implementation for `wchar_t'.  The external encoding is
determined by the `LC_CTYPE' category of the current locale or by the
`ccs' part of the mode specification given to `fopen', `fopen64',
`freopen', or `freopen64'.  How and when the conversion happens is
unspecified and it happens invisible to the user.

   Since a stream is created in the unoriented state it has at that
point no conversion associated with it.  The conversion which will be
used is determined by the `LC_CTYPE' category selected at the time the
stream is oriented.  If the locales are changed at the runtime this
might produce surprising results unless one pays attention.  This is
just another good reason to orient the stream explicitly as soon as
possible, perhaps with a call to `fwide'.


File: libc.info,  Node: Simple Output,  Next: Character Input,  Prev: Streams and I18N,  Up: I/O on Streams

12.7 Simple Output by Characters or Lines
=========================================

This section describes functions for performing character- and
line-oriented output.

   These narrow streams functions are declared in the header file
`stdio.h' and the wide stream functions in `wchar.h'.  

 -- Function: int fputc (int C, FILE *STREAM)
     The `fputc' function converts the character C to type `unsigned
     char', and writes it to the stream STREAM.  `EOF' is returned if a
     write error occurs; otherwise the character C is returned.

 -- Function: wint_t fputwc (wchar_t WC, FILE *STREAM)
     The `fputwc' function writes the wide character WC to the stream
     STREAM.  `WEOF' is returned if a write error occurs; otherwise the
     character WC is returned.

 -- Function: int fputc_unlocked (int C, FILE *STREAM)
     The `fputc_unlocked' function is equivalent to the `fputc'
     function except that it does not implicitly lock the stream.

 -- Function: wint_t fputwc_unlocked (wint_t WC, FILE *STREAM)
     The `fputwc_unlocked' function is equivalent to the `fputwc'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: int putc (int C, FILE *STREAM)
     This is just like `fputc', except that most systems implement it as
     a macro, making it faster.  One consequence is that it may
     evaluate the STREAM argument more than once, which is an exception
     to the general rule for macros.  `putc' is usually the best
     function to use for writing a single character.

 -- Function: wint_t putwc (wchar_t WC, FILE *STREAM)
     This is just like `fputwc', except that it can be implement as a
     macro, making it faster.  One consequence is that it may evaluate
     the STREAM argument more than once, which is an exception to the
     general rule for macros.  `putwc' is usually the best function to
     use for writing a single wide character.

 -- Function: int putc_unlocked (int C, FILE *STREAM)
     The `putc_unlocked' function is equivalent to the `putc' function
     except that it does not implicitly lock the stream.

 -- Function: wint_t putwc_unlocked (wchar_t WC, FILE *STREAM)
     The `putwc_unlocked' function is equivalent to the `putwc'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: int putchar (int C)
     The `putchar' function is equivalent to `putc' with `stdout' as
     the value of the STREAM argument.

 -- Function: wint_t putwchar (wchar_t WC)
     The `putwchar' function is equivalent to `putwc' with `stdout' as
     the value of the STREAM argument.

 -- Function: int putchar_unlocked (int C)
     The `putchar_unlocked' function is equivalent to the `putchar'
     function except that it does not implicitly lock the stream.

 -- Function: wint_t putwchar_unlocked (wchar_t WC)
     The `putwchar_unlocked' function is equivalent to the `putwchar'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: int fputs (const char *S, FILE *STREAM)
     The function `fputs' writes the string S to the stream STREAM.
     The terminating null character is not written.  This function does
     _not_ add a newline character, either.  It outputs only the
     characters in the string.

     This function returns `EOF' if a write error occurs, and otherwise
     a non-negative value.

     For example:

          fputs ("Are ", stdout);
          fputs ("you ", stdout);
          fputs ("hungry?\n", stdout);

     outputs the text `Are you hungry?' followed by a newline.

 -- Function: int fputws (const wchar_t *WS, FILE *STREAM)
     The function `fputws' writes the wide character string WS to the
     stream STREAM.  The terminating null character is not written.
     This function does _not_ add a newline character, either.  It
     outputs only the characters in the string.

     This function returns `WEOF' if a write error occurs, and otherwise
     a non-negative value.

 -- Function: int fputs_unlocked (const char *S, FILE *STREAM)
     The `fputs_unlocked' function is equivalent to the `fputs'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: int fputws_unlocked (const wchar_t *WS, FILE *STREAM)
     The `fputws_unlocked' function is equivalent to the `fputws'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: int puts (const char *S)
     The `puts' function writes the string S to the stream `stdout'
     followed by a newline.  The terminating null character of the
     string is not written.  (Note that `fputs' does _not_ write a
     newline as this function does.)

     `puts' is the most convenient function for printing simple
     messages.  For example:

          puts ("This is a message.");

     outputs the text `This is a message.' followed by a newline.

 -- Function: int putw (int W, FILE *STREAM)
     This function writes the word W (that is, an `int') to STREAM.  It
     is provided for compatibility with SVID, but we recommend you use
     `fwrite' instead (*note Block Input/Output::).


File: libc.info,  Node: Character Input,  Next: Line Input,  Prev: Simple Output,  Up: I/O on Streams

12.8 Character Input
====================

This section describes functions for performing character-oriented
input.  These narrow streams functions are declared in the header file
`stdio.h' and the wide character functions are declared in `wchar.h'.  

   These functions return an `int' or `wint_t' value (for narrow and
wide stream functions respectively) that is either a character of
input, or the special value `EOF'/`WEOF' (usually -1).  For the narrow
stream functions it is important to store the result of these functions
in a variable of type `int' instead of `char', even when you plan to
use it only as a character.  Storing `EOF' in a `char' variable
truncates its value to the size of a character, so that it is no longer
distinguishable from the valid character `(char) -1'.  So always use an
`int' for the result of `getc' and friends, and check for `EOF' after
the call; once you've verified that the result is not `EOF', you can be
sure that it will fit in a `char' variable without loss of information.

 -- Function: int fgetc (FILE *STREAM)
     This function reads the next character as an `unsigned char' from
     the stream STREAM and returns its value, converted to an `int'.
     If an end-of-file condition or read error occurs, `EOF' is
     returned instead.

 -- Function: wint_t fgetwc (FILE *STREAM)
     This function reads the next wide character from the stream STREAM
     and returns its value.  If an end-of-file condition or read error
     occurs, `WEOF' is returned instead.

 -- Function: int fgetc_unlocked (FILE *STREAM)
     The `fgetc_unlocked' function is equivalent to the `fgetc'
     function except that it does not implicitly lock the stream.

 -- Function: wint_t fgetwc_unlocked (FILE *STREAM)
     The `fgetwc_unlocked' function is equivalent to the `fgetwc'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: int getc (FILE *STREAM)
     This is just like `fgetc', except that it is permissible (and
     typical) for it to be implemented as a macro that evaluates the
     STREAM argument more than once.  `getc' is often highly optimized,
     so it is usually the best function to use to read a single
     character.

 -- Function: wint_t getwc (FILE *STREAM)
     This is just like `fgetwc', except that it is permissible for it to
     be implemented as a macro that evaluates the STREAM argument more
     than once.  `getwc' can be highly optimized, so it is usually the
     best function to use to read a single wide character.

 -- Function: int getc_unlocked (FILE *STREAM)
     The `getc_unlocked' function is equivalent to the `getc' function
     except that it does not implicitly lock the stream.

 -- Function: wint_t getwc_unlocked (FILE *STREAM)
     The `getwc_unlocked' function is equivalent to the `getwc'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: int getchar (void)
     The `getchar' function is equivalent to `getc' with `stdin' as the
     value of the STREAM argument.

 -- Function: wint_t getwchar (void)
     The `getwchar' function is equivalent to `getwc' with `stdin' as
     the value of the STREAM argument.

 -- Function: int getchar_unlocked (void)
     The `getchar_unlocked' function is equivalent to the `getchar'
     function except that it does not implicitly lock the stream.

 -- Function: wint_t getwchar_unlocked (void)
     The `getwchar_unlocked' function is equivalent to the `getwchar'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

   Here is an example of a function that does input using `fgetc'.  It
would work just as well using `getc' instead, or using `getchar ()'
instead of `fgetc (stdin)'.  The code would also work the same for the
wide character stream functions.

     int
     y_or_n_p (const char *question)
     {
       fputs (question, stdout);
       while (1)
         {
           int c, answer;
           /* Write a space to separate answer from question. */
           fputc (' ', stdout);
           /* Read the first character of the line.
              This should be the answer character, but might not be. */
           c = tolower (fgetc (stdin));
           answer = c;
           /* Discard rest of input line. */
           while (c != '\n' && c != EOF)
             c = fgetc (stdin);
           /* Obey the answer if it was valid. */
           if (answer == 'y')
             return 1;
           if (answer == 'n')
             return 0;
           /* Answer was invalid: ask for valid answer. */
           fputs ("Please answer y or n:", stdout);
         }
     }

 -- Function: int getw (FILE *STREAM)
     This function reads a word (that is, an `int') from STREAM.  It's
     provided for compatibility with SVID.  We recommend you use
     `fread' instead (*note Block Input/Output::).  Unlike `getc', any
     `int' value could be a valid result.  `getw' returns `EOF' when it
     encounters end-of-file or an error, but there is no way to
     distinguish this from an input word with value -1.


File: libc.info,  Node: Line Input,  Next: Unreading,  Prev: Character Input,  Up: I/O on Streams

12.9 Line-Oriented Input
========================

Since many programs interpret input on the basis of lines, it is
convenient to have functions to read a line of text from a stream.

   Standard C has functions to do this, but they aren't very safe: null
characters and even (for `gets') long lines can confuse them.  So the
GNU library provides the nonstandard `getline' function that makes it
easy to read lines reliably.

   Another GNU extension, `getdelim', generalizes `getline'.  It reads
a delimited record, defined as everything through the next occurrence
of a specified delimiter character.

   All these functions are declared in `stdio.h'.

 -- Function: ssize_t getline (char **LINEPTR, size_t *N, FILE *STREAM)
     This function reads an entire line from STREAM, storing the text
     (including the newline and a terminating null character) in a
     buffer and storing the buffer address in `*LINEPTR'.

     Before calling `getline', you should place in `*LINEPTR' the
     address of a buffer `*N' bytes long, allocated with `malloc'.  If
     this buffer is long enough to hold the line, `getline' stores the
     line in this buffer.  Otherwise, `getline' makes the buffer bigger
     using `realloc', storing the new buffer address back in `*LINEPTR'
     and the increased size back in `*N'.  *Note Unconstrained
     Allocation::.

     If you set `*LINEPTR' to a null pointer, and `*N' to zero, before
     the call, then `getline' allocates the initial buffer for you by
     calling `malloc'.

     In either case, when `getline' returns,  `*LINEPTR' is a `char *'
     which points to the text of the line.

     When `getline' is successful, it returns the number of characters
     read (including the newline, but not including the terminating
     null).  This value enables you to distinguish null characters that
     are part of the line from the null character inserted as a
     terminator.

     This function is a GNU extension, but it is the recommended way to
     read lines from a stream.  The alternative standard functions are
     unreliable.

     If an error occurs or end of file is reached without any bytes
     read, `getline' returns `-1'.

 -- Function: ssize_t getdelim (char **LINEPTR, size_t *N, int
          DELIMITER, FILE *STREAM)
     This function is like `getline' except that the character which
     tells it to stop reading is not necessarily newline.  The argument
     DELIMITER specifies the delimiter character; `getdelim' keeps
     reading until it sees that character (or end of file).

     The text is stored in LINEPTR, including the delimiter character
     and a terminating null.  Like `getline', `getdelim' makes LINEPTR
     bigger if it isn't big enough.

     `getline' is in fact implemented in terms of `getdelim', just like
     this:

          ssize_t
          getline (char **lineptr, size_t *n, FILE *stream)
          {
            return getdelim (lineptr, n, '\n', stream);
          }

 -- Function: char * fgets (char *S, int COUNT, FILE *STREAM)
     The `fgets' function reads characters from the stream STREAM up to
     and including a newline character and stores them in the string S,
     adding a null character to mark the end of the string.  You must
     supply COUNT characters worth of space in S, but the number of
     characters read is at most COUNT - 1.  The extra character space
     is used to hold the null character at the end of the string.

     If the system is already at end of file when you call `fgets', then
     the contents of the array S are unchanged and a null pointer is
     returned.  A null pointer is also returned if a read error occurs.
     Otherwise, the return value is the pointer S.

     *Warning:*  If the input data has a null character, you can't tell.
     So don't use `fgets' unless you know the data cannot contain a
     null.  Don't use it to read files edited by the user because, if
     the user inserts a null character, you should either handle it
     properly or print a clear error message.  We recommend using
     `getline' instead of `fgets'.

 -- Function: wchar_t * fgetws (wchar_t *WS, int COUNT, FILE *STREAM)
     The `fgetws' function reads wide characters from the stream STREAM
     up to and including a newline character and stores them in the
     string WS, adding a null wide character to mark the end of the
     string.  You must supply COUNT wide characters worth of space in
     WS, but the number of characters read is at most COUNT - 1.  The
     extra character space is used to hold the null wide character at
     the end of the string.

     If the system is already at end of file when you call `fgetws',
     then the contents of the array WS are unchanged and a null pointer
     is returned.  A null pointer is also returned if a read error
     occurs.  Otherwise, the return value is the pointer WS.

     *Warning:* If the input data has a null wide character (which are
     null bytes in the input stream), you can't tell.  So don't use
     `fgetws' unless you know the data cannot contain a null.  Don't use
     it to read files edited by the user because, if the user inserts a
     null character, you should either handle it properly or print a
     clear error message.

 -- Function: char * fgets_unlocked (char *S, int COUNT, FILE *STREAM)
     The `fgets_unlocked' function is equivalent to the `fgets'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: wchar_t * fgetws_unlocked (wchar_t *WS, int COUNT, FILE
          *STREAM)
     The `fgetws_unlocked' function is equivalent to the `fgetws'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Deprecated function: char * gets (char *S)
     The function `gets' reads characters from the stream `stdin' up to
     the next newline character, and stores them in the string S.  The
     newline character is discarded (note that this differs from the
     behavior of `fgets', which copies the newline character into the
     string).  If `gets' encounters a read error or end-of-file, it
     returns a null pointer; otherwise it returns S.

     *Warning:* The `gets' function is *very dangerous* because it
     provides no protection against overflowing the string S.  The GNU
     library includes it for compatibility only.  You should *always*
     use `fgets' or `getline' instead.  To remind you of this, the
     linker (if using GNU `ld') will issue a warning whenever you use
     `gets'.


File: libc.info,  Node: Unreading,  Next: Block Input/Output,  Prev: Line Input,  Up: I/O on Streams

12.10 Unreading
===============

In parser programs it is often useful to examine the next character in
the input stream without removing it from the stream.  This is called
"peeking ahead" at the input because your program gets a glimpse of the
input it will read next.

   Using stream I/O, you can peek ahead at input by first reading it and
then "unreading" it (also called  "pushing it back" on the stream).
Unreading a character makes it available to be input again from the
stream, by  the next call to `fgetc' or other input function on that
stream.

* Menu:

* Unreading Idea::              An explanation of unreading with pictures.
* How Unread::                  How to call `ungetc' to do unreading.


File: libc.info,  Node: Unreading Idea,  Next: How Unread,  Up: Unreading

12.10.1 What Unreading Means
----------------------------

Here is a pictorial explanation of unreading.  Suppose you have a
stream reading a file that contains just six characters, the letters
`foobar'.  Suppose you have read three characters so far.  The
situation looks like this:

     f  o  o  b  a  r
              ^

so the next input character will be `b'.

   If instead of reading `b' you unread the letter `o', you get a
situation like this:

     f  o  o  b  a  r
              |
           o--
           ^

so that the next input characters will be `o' and `b'.

   If you unread `9' instead of `o', you get this situation:

     f  o  o  b  a  r
              |
           9--
           ^

so that the next input characters will be `9' and `b'.


File: libc.info,  Node: How Unread,  Prev: Unreading Idea,  Up: Unreading

12.10.2 Using `ungetc' To Do Unreading
--------------------------------------

The function to unread a character is called `ungetc', because it
reverses the action of `getc'.

 -- Function: int ungetc (int C, FILE *STREAM)
     The `ungetc' function pushes back the character C onto the input
     stream STREAM.  So the next input from STREAM will read C before
     anything else.

     If C is `EOF', `ungetc' does nothing and just returns `EOF'.  This
     lets you call `ungetc' with the return value of `getc' without
     needing to check for an error from `getc'.

     The character that you push back doesn't have to be the same as
     the last character that was actually read from the stream.  In
     fact, it isn't necessary to actually read any characters from the
     stream before unreading them with `ungetc'!  But that is a strange
     way to write a program; usually `ungetc' is used only to unread a
     character that was just read from the same stream.  The GNU C
     library supports this even on files opened in binary mode, but
     other systems might not.

     The GNU C library only supports one character of pushback--in other
     words, it does not work to call `ungetc' twice without doing input
     in between.  Other systems might let you push back multiple
     characters; then reading from the stream retrieves the characters
     in the reverse order that they were pushed.

     Pushing back characters doesn't alter the file; only the internal
     buffering for the stream is affected.  If a file positioning
     function (such as `fseek', `fseeko' or `rewind'; *note File
     Positioning::) is called, any pending pushed-back characters are
     discarded.

     Unreading a character on a stream that is at end of file clears the
     end-of-file indicator for the stream, because it makes the
     character of input available.  After you read that character,
     trying to read again will encounter end of file.

 -- Function: wint_t ungetwc (wint_t WC, FILE *STREAM)
     The `ungetwc' function behaves just like `ungetc' just that it
     pushes back a wide character.

   Here is an example showing the use of `getc' and `ungetc' to skip
over whitespace characters.  When this function reaches a
non-whitespace character, it unreads that character to be seen again on
the next read operation on the stream.

     #include <stdio.h>
     #include <ctype.h>

     void
     skip_whitespace (FILE *stream)
     {
       int c;
       do
         /* No need to check for `EOF' because it is not
            `isspace', and `ungetc' ignores `EOF'.  */
         c = getc (stream);
       while (isspace (c));
       ungetc (c, stream);
     }


File: libc.info,  Node: Block Input/Output,  Next: Formatted Output,  Prev: Unreading,  Up: I/O on Streams

12.11 Block Input/Output
========================

This section describes how to do input and output operations on blocks
of data.  You can use these functions to read and write binary data, as
well as to read and write text in fixed-size blocks instead of by
characters or lines.  

   Binary files are typically used to read and write blocks of data in
the same format as is used to represent the data in a running program.
In other words, arbitrary blocks of memory--not just character or string
objects--can be written to a binary file, and meaningfully read in
again by the same program.

   Storing data in binary form is often considerably more efficient than
using the formatted I/O functions.  Also, for floating-point numbers,
the binary form avoids possible loss of precision in the conversion
process.  On the other hand, binary files can't be examined or modified
easily using many standard file utilities (such as text editors), and
are not portable between different implementations of the language, or
different kinds of computers.

   These functions are declared in `stdio.h'.  

 -- Function: size_t fread (void *DATA, size_t SIZE, size_t COUNT, FILE
          *STREAM)
     This function reads up to COUNT objects of size SIZE into the
     array DATA, from the stream STREAM.  It returns the number of
     objects actually read, which might be less than COUNT if a read
     error occurs or the end of the file is reached.  This function
     returns a value of zero (and doesn't read anything) if either SIZE
     or COUNT is zero.

     If `fread' encounters end of file in the middle of an object, it
     returns the number of complete objects read, and discards the
     partial object.  Therefore, the stream remains at the actual end
     of the file.

 -- Function: size_t fread_unlocked (void *DATA, size_t SIZE, size_t
          COUNT, FILE *STREAM)
     The `fread_unlocked' function is equivalent to the `fread'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

 -- Function: size_t fwrite (const void *DATA, size_t SIZE, size_t
          COUNT, FILE *STREAM)
     This function writes up to COUNT objects of size SIZE from the
     array DATA, to the stream STREAM.  The return value is normally
     COUNT, if the call succeeds.  Any other value indicates some sort
     of error, such as running out of space.

 -- Function: size_t fwrite_unlocked (const void *DATA, size_t SIZE,
          size_t COUNT, FILE *STREAM)
     The `fwrite_unlocked' function is equivalent to the `fwrite'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.


File: libc.info,  Node: Formatted Output,  Next: Customizing Printf,  Prev: Block Input/Output,  Up: I/O on Streams

12.12 Formatted Output
======================

The functions described in this section (`printf' and related
functions) provide a convenient way to perform formatted output.  You
call `printf' with a "format string" or "template string" that
specifies how to format the values of the remaining arguments.

   Unless your program is a filter that specifically performs line- or
character-oriented processing, using `printf' or one of the other
related functions described in this section is usually the easiest and
most concise way to perform output.  These functions are especially
useful for printing error messages, tables of data, and the like.

* Menu:

* Formatted Output Basics::     Some examples to get you started.
* Output Conversion Syntax::    General syntax of conversion
                                 specifications.
* Table of Output Conversions:: Summary of output conversions and
                                 what they do.
* Integer Conversions::         Details about formatting of integers.
* Floating-Point Conversions::  Details about formatting of
                                 floating-point numbers.
* Other Output Conversions::    Details about formatting of strings,
                                 characters, pointers, and the like.
* Formatted Output Functions::  Descriptions of the actual functions.
* Dynamic Output::		Functions that allocate memory for the output.
* Variable Arguments Output::   `vprintf' and friends.
* Parsing a Template String::   What kinds of args does a given template
                                 call for?
* Example of Parsing::          Sample program using `parse_printf_format'.


File: libc.info,  Node: Formatted Output Basics,  Next: Output Conversion Syntax,  Up: Formatted Output

12.12.1 Formatted Output Basics
-------------------------------

The `printf' function can be used to print any number of arguments.
The template string argument you supply in a call provides information
not only about the number of additional arguments, but also about their
types and what style should be used for printing them.

   Ordinary characters in the template string are simply written to the
output stream as-is, while "conversion specifications" introduced by a
`%' character in the template cause subsequent arguments to be
formatted and written to the output stream.  For example, 

     int pct = 37;
     char filename[] = "foo.txt";
     printf ("Processing of `%s' is %d%% finished.\nPlease be patient.\n",
             filename, pct);

produces output like

     Processing of `foo.txt' is 37% finished.
     Please be patient.

   This example shows the use of the `%d' conversion to specify that an
`int' argument should be printed in decimal notation, the `%s'
conversion to specify printing of a string argument, and the `%%'
conversion to print a literal `%' character.

   There are also conversions for printing an integer argument as an
unsigned value in octal, decimal, or hexadecimal radix (`%o', `%u', or
`%x', respectively); or as a character value (`%c').

   Floating-point numbers can be printed in normal, fixed-point notation
using the `%f' conversion or in exponential notation using the `%e'
conversion.  The `%g' conversion uses either `%e' or `%f' format,
depending on what is more appropriate for the magnitude of the
particular number.

   You can control formatting more precisely by writing "modifiers"
between the `%' and the character that indicates which conversion to
apply.  These slightly alter the ordinary behavior of the conversion.
For example, most conversion specifications permit you to specify a
minimum field width and a flag indicating whether you want the result
left- or right-justified within the field.

   The specific flags and modifiers that are permitted and their
interpretation vary depending on the particular conversion.  They're all
described in more detail in the following sections.  Don't worry if this
all seems excessively complicated at first; you can almost always get
reasonable free-format output without using any of the modifiers at all.
The modifiers are mostly used to make the output look "prettier" in
tables.


File: libc.info,  Node: Output Conversion Syntax,  Next: Table of Output Conversions,  Prev: Formatted Output Basics,  Up: Formatted Output

12.12.2 Output Conversion Syntax
--------------------------------

This section provides details about the precise syntax of conversion
specifications that can appear in a `printf' template string.

   Characters in the template string that are not part of a conversion
specification are printed as-is to the output stream.  Multibyte
character sequences (*note Character Set Handling::) are permitted in a
template string.

   The conversion specifications in a `printf' template string have the
general form:

     % [ PARAM-NO $] FLAGS WIDTH [ . PRECISION ] TYPE CONVERSION

or

     % [ PARAM-NO $] FLAGS WIDTH . * [ PARAM-NO $] TYPE CONVERSION

   For example, in the conversion specifier `%-10.8ld', the `-' is a
flag, `10' specifies the field width, the precision is `8', the letter
`l' is a type modifier, and `d' specifies the conversion style.  (This
particular type specifier says to print a `long int' argument in
decimal notation, with a minimum of 8 digits left-justified in a field
at least 10 characters wide.)

   In more detail, output conversion specifications consist of an
initial `%' character followed in sequence by:

   * An optional specification of the parameter used for this format.
     Normally the parameters to the `printf' function are assigned to
     the formats in the order of appearance in the format string.  But
     in some situations (such as message translation) this is not
     desirable and this extension allows an explicit parameter to be
     specified.

     The PARAM-NO parts of the format must be integers in the range of
     1 to the maximum number of arguments present to the function call.
     Some implementations limit this number to a certainly upper
     bound.  The exact limit can be retrieved by the following constant.

      -- Macro: NL_ARGMAX
          The value of `NL_ARGMAX' is the maximum value allowed for the
          specification of an positional parameter in a `printf' call.
          The actual value in effect at runtime can be retrieved by
          using `sysconf' using the `_SC_NL_ARGMAX' parameter *note
          Sysconf Definition::.

          Some system have a quite low limit such as 9 for System V
          systems.  The GNU C library has no real limit.

     If any of the formats has a specification for the parameter
     position all of them in the format string shall have one.
     Otherwise the behavior is undefined.

   * Zero or more "flag characters" that modify the normal behavior of
     the conversion specification.  

   * An optional decimal integer specifying the "minimum field width".
     If the normal conversion produces fewer characters than this, the
     field is padded with spaces to the specified width.  This is a
     _minimum_ value; if the normal conversion produces more characters
     than this, the field is _not_ truncated.  Normally, the output is
     right-justified within the field.  

     You can also specify a field width of `*'.  This means that the
     next argument in the argument list (before the actual value to be
     printed) is used as the field width.  The value must be an `int'.
     If the value is negative, this means to set the `-' flag (see
     below) and to use the absolute value as the field width.

   * An optional "precision" to specify the number of digits to be
     written for the numeric conversions.  If the precision is
     specified, it consists of a period (`.') followed optionally by a
     decimal integer (which defaults to zero if omitted).  

     You can also specify a precision of `*'.  This means that the next
     argument in the argument list (before the actual value to be
     printed) is used as the precision.  The value must be an `int',
     and is ignored if it is negative.  If you specify `*' for both the
     field width and precision, the field width argument precedes the
     precision argument.  Other C library versions may not recognize
     this syntax.

   * An optional "type modifier character", which is used to specify the
     data type of the corresponding argument if it differs from the
     default type.  (For example, the integer conversions assume a type
     of `int', but you can specify `h', `l', or `L' for other integer
     types.)  

   * A character that specifies the conversion to be applied.

   The exact options that are permitted and how they are interpreted
vary between the different conversion specifiers.  See the descriptions
of the individual conversions for information about the particular
options that they use.

   With the `-Wformat' option, the GNU C compiler checks calls to
`printf' and related functions.  It examines the format string and
verifies that the correct number and types of arguments are supplied.
There is also a GNU C syntax to tell the compiler that a function you
write uses a `printf'-style format string.  *Note Declaring Attributes
of Functions: (gcc.info)Function Attributes, for more information.


File: libc.info,  Node: Table of Output Conversions,  Next: Integer Conversions,  Prev: Output Conversion Syntax,  Up: Formatted Output

12.12.3 Table of Output Conversions
-----------------------------------

Here is a table summarizing what all the different conversions do:

`%d', `%i'
     Print an integer as a signed decimal number.  *Note Integer
     Conversions::, for details.  `%d' and `%i' are synonymous for
     output, but are different when used with `scanf' for input (*note
     Table of Input Conversions::).

`%o'
     Print an integer as an unsigned octal number.  *Note Integer
     Conversions::, for details.

`%u'
     Print an integer as an unsigned decimal number.  *Note Integer
     Conversions::, for details.

`%x', `%X'
     Print an integer as an unsigned hexadecimal number.  `%x' uses
     lower-case letters and `%X' uses upper-case.  *Note Integer
     Conversions::, for details.

`%f'
     Print a floating-point number in normal (fixed-point) notation.
     *Note Floating-Point Conversions::, for details.

`%e', `%E'
     Print a floating-point number in exponential notation.  `%e' uses
     lower-case letters and `%E' uses upper-case.  *Note Floating-Point
     Conversions::, for details.

`%g', `%G'
     Print a floating-point number in either normal or exponential
     notation, whichever is more appropriate for its magnitude.  `%g'
     uses lower-case letters and `%G' uses upper-case.  *Note
     Floating-Point Conversions::, for details.

`%a', `%A'
     Print a floating-point number in a hexadecimal fractional notation
     which the exponent to base 2 represented in decimal digits.  `%a'
     uses lower-case letters and `%A' uses upper-case.  *Note
     Floating-Point Conversions::, for details.

`%c'
     Print a single character.  *Note Other Output Conversions::.

`%C'
     This is an alias for `%lc' which is supported for compatibility
     with the Unix standard.

`%s'
     Print a string.  *Note Other Output Conversions::.

`%S'
     This is an alias for `%ls' which is supported for compatibility
     with the Unix standard.

`%p'
     Print the value of a pointer.  *Note Other Output Conversions::.

`%n'
     Get the number of characters printed so far.  *Note Other Output
     Conversions::.  Note that this conversion specification never
     produces any output.

`%m'
     Print the string corresponding to the value of `errno'.  (This is
     a GNU extension.)  *Note Other Output Conversions::.

`%%'
     Print a literal `%' character.  *Note Other Output Conversions::.

   If the syntax of a conversion specification is invalid, unpredictable
things will happen, so don't do this.  If there aren't enough function
arguments provided to supply values for all the conversion
specifications in the template string, or if the arguments are not of
the correct types, the results are unpredictable.  If you supply more
arguments than conversion specifications, the extra argument values are
simply ignored; this is sometimes useful.


File: libc.info,  Node: Integer Conversions,  Next: Floating-Point Conversions,  Prev: Table of Output Conversions,  Up: Formatted Output

12.12.4 Integer Conversions
---------------------------

This section describes the options for the `%d', `%i', `%o', `%u',
`%x', and `%X' conversion specifications.  These conversions print
integers in various formats.

   The `%d' and `%i' conversion specifications both print an `int'
argument as a signed decimal number; while `%o', `%u', and `%x' print
the argument as an unsigned octal, decimal, or hexadecimal number
(respectively).  The `%X' conversion specification is just like `%x'
except that it uses the characters `ABCDEF' as digits instead of
`abcdef'.

   The following flags are meaningful:

`-'
     Left-justify the result in the field (instead of the normal
     right-justification).

`+'
     For the signed `%d' and `%i' conversions, print a plus sign if the
     value is positive.

` '
     For the signed `%d' and `%i' conversions, if the result doesn't
     start with a plus or minus sign, prefix it with a space character
     instead.  Since the `+' flag ensures that the result includes a
     sign, this flag is ignored if you supply both of them.

`#'
     For the `%o' conversion, this forces the leading digit to be `0',
     as if by increasing the precision.  For `%x' or `%X', this
     prefixes a leading `0x' or `0X' (respectively) to the result.
     This doesn't do anything useful for the `%d', `%i', or `%u'
     conversions.  Using this flag produces output which can be parsed
     by the `strtoul' function (*note Parsing of Integers::) and
     `scanf' with the `%i' conversion (*note Numeric Input
     Conversions::).

`''
     Separate the digits into groups as specified by the locale
     specified for the `LC_NUMERIC' category; *note General Numeric::.
     This flag is a GNU extension.

`0'
     Pad the field with zeros instead of spaces.  The zeros are placed
     after any indication of sign or base.  This flag is ignored if the
     `-' flag is also specified, or if a precision is specified.

   If a precision is supplied, it specifies the minimum number of
digits to appear; leading zeros are produced if necessary.  If you
don't specify a precision, the number is printed with as many digits as
it needs.  If you convert a value of zero with an explicit precision of
zero, then no characters at all are produced.

   Without a type modifier, the corresponding argument is treated as an
`int' (for the signed conversions `%i' and `%d') or `unsigned int' (for
the unsigned conversions `%o', `%u', `%x', and `%X').  Recall that
since `printf' and friends are variadic, any `char' and `short'
arguments are automatically converted to `int' by the default argument
promotions.  For arguments of other integer types, you can use these
modifiers:

`hh'
     Specifies that the argument is a `signed char' or `unsigned char',
     as appropriate.  A `char' argument is converted to an `int' or
     `unsigned int' by the default argument promotions anyway, but the
     `h' modifier says to convert it back to a `char' again.

     This modifier was introduced in ISO C99.

`h'
     Specifies that the argument is a `short int' or `unsigned short
     int', as appropriate.  A `short' argument is converted to an `int'
     or `unsigned int' by the default argument promotions anyway, but
     the `h' modifier says to convert it back to a `short' again.

`j'
     Specifies that the argument is a `intmax_t' or `uintmax_t', as
     appropriate.

     This modifier was introduced in ISO C99.

`l'
     Specifies that the argument is a `long int' or `unsigned long
     int', as appropriate.  Two `l' characters is like the `L'
     modifier, below.

     If used with `%c' or `%s' the corresponding parameter is
     considered as a wide character or wide character string
     respectively.  This use of `l' was introduced in Amendment 1 to
     ISO C90.

`L'
`ll'
`q'
     Specifies that the argument is a `long long int'.  (This type is
     an extension supported by the GNU C compiler.  On systems that
     don't support extra-long integers, this is the same as `long int'.)

     The `q' modifier is another name for the same thing, which comes
     from 4.4 BSD; a `long long int' is sometimes called a "quad" `int'.

`t'
     Specifies that the argument is a `ptrdiff_t'.

     This modifier was introduced in ISO C99.

`z'
`Z'
     Specifies that the argument is a `size_t'.

     `z' was introduced in ISO C99.  `Z' is a GNU extension predating
     this addition and should not be used in new code.

   Here is an example.  Using the template string:

     "|%5d|%-5d|%+5d|%+-5d|% 5d|%05d|%5.0d|%5.2d|%d|\n"

to print numbers using the different options for the `%d' conversion
gives results like:

     |    0|0    |   +0|+0   |    0|00000|     |   00|0|
     |    1|1    |   +1|+1   |    1|00001|    1|   01|1|
     |   -1|-1   |   -1|-1   |   -1|-0001|   -1|  -01|-1|
     |100000|100000|+100000|+100000| 100000|100000|100000|100000|100000|

   In particular, notice what happens in the last case where the number
is too large to fit in the minimum field width specified.

   Here are some more examples showing how unsigned integers print under
various format options, using the template string:

     "|%5u|%5o|%5x|%5X|%#5o|%#5x|%#5X|%#10.8x|\n"

     |    0|    0|    0|    0|    0|    0|    0|  00000000|
     |    1|    1|    1|    1|   01|  0x1|  0X1|0x00000001|
     |100000|303240|186a0|186A0|0303240|0x186a0|0X186A0|0x000186a0|


File: libc.info,  Node: Floating-Point Conversions,  Next: Other Output Conversions,  Prev: Integer Conversions,  Up: Formatted Output

12.12.5 Floating-Point Conversions
----------------------------------

This section discusses the conversion specifications for floating-point
numbers: the `%f', `%e', `%E', `%g', and `%G' conversions.

   The `%f' conversion prints its argument in fixed-point notation,
producing output of the form [`-']DDD`.'DDD, where the number of digits
following the decimal point is controlled by the precision you specify.

   The `%e' conversion prints its argument in exponential notation,
producing output of the form [`-']D`.'DDD`e'[`+'|`-']DD.  Again, the
number of digits following the decimal point is controlled by the
precision.  The exponent always contains at least two digits.  The `%E'
conversion is similar but the exponent is marked with the letter `E'
instead of `e'.

   The `%g' and `%G' conversions print the argument in the style of
`%e' or `%E' (respectively) if the exponent would be less than -4 or
greater than or equal to the precision; otherwise they use the `%f'
style.  A precision of `0', is taken as 1.  Trailing zeros are removed
from the fractional portion of the result and a decimal-point character
appears only if it is followed by a digit.

   The `%a' and `%A' conversions are meant for representing
floating-point numbers exactly in textual form so that they can be
exchanged as texts between different programs and/or machines.  The
numbers are represented is the form [`-']`0x'H`.'HHH`p'[`+'|`-']DD.  At
the left of the decimal-point character exactly one digit is print.
This character is only `0' if the number is denormalized.  Otherwise
the value is unspecified; it is implementation dependent how many bits
are used.  The number of hexadecimal digits on the right side of the
decimal-point character is equal to the precision.  If the precision is
zero it is determined to be large enough to provide an exact
representation of the number (or it is large enough to distinguish two
adjacent values if the `FLT_RADIX' is not a power of 2, *note Floating
Point Parameters::).  For the `%a' conversion lower-case characters are
used to represent the hexadecimal number and the prefix and exponent
sign are printed as `0x' and `p' respectively.  Otherwise upper-case
characters are used and `0X' and `P' are used for the representation of
prefix and exponent string.  The exponent to the base of two is printed
as a decimal number using at least one digit but at most as many digits
as necessary to represent the value exactly.

   If the value to be printed represents infinity or a NaN, the output
is [`-']`inf' or `nan' respectively if the conversion specifier is
`%a', `%e', `%f', or `%g' and it is [`-']`INF' or `NAN' respectively if
the conversion is `%A', `%E', or `%G'.

   The following flags can be used to modify the behavior:

`-'
     Left-justify the result in the field.  Normally the result is
     right-justified.

`+'
     Always include a plus or minus sign in the result.

` '
     If the result doesn't start with a plus or minus sign, prefix it
     with a space instead.  Since the `+' flag ensures that the result
     includes a sign, this flag is ignored if you supply both of them.

`#'
     Specifies that the result should always include a decimal point,
     even if no digits follow it.  For the `%g' and `%G' conversions,
     this also forces trailing zeros after the decimal point to be left
     in place where they would otherwise be removed.

`''
     Separate the digits of the integer part of the result into groups
     as specified by the locale specified for the `LC_NUMERIC' category;
     *note General Numeric::.  This flag is a GNU extension.

`0'
     Pad the field with zeros instead of spaces; the zeros are placed
     after any sign.  This flag is ignored if the `-' flag is also
     specified.

   The precision specifies how many digits follow the decimal-point
character for the `%f', `%e', and `%E' conversions.  For these
conversions, the default precision is `6'.  If the precision is
explicitly `0', this suppresses the decimal point character entirely.
For the `%g' and `%G' conversions, the precision specifies how many
significant digits to print.  Significant digits are the first digit
before the decimal point, and all the digits after it.  If the
precision is `0' or not specified for `%g' or `%G', it is treated like
a value of `1'.  If the value being printed cannot be expressed
accurately in the specified number of digits, the value is rounded to
the nearest number that fits.

   Without a type modifier, the floating-point conversions use an
argument of type `double'.  (By the default argument promotions, any
`float' arguments are automatically converted to `double'.)  The
following type modifier is supported:

`L'
     An uppercase `L' specifies that the argument is a `long double'.

   Here are some examples showing how numbers print using the various
floating-point conversions.  All of the numbers were printed using this
template string:

     "|%13.4a|%13.4f|%13.4e|%13.4g|\n"

   Here is the output:

     |  0x0.0000p+0|       0.0000|   0.0000e+00|            0|
     |  0x1.0000p-1|       0.5000|   5.0000e-01|          0.5|
     |  0x1.0000p+0|       1.0000|   1.0000e+00|            1|
     | -0x1.0000p+0|      -1.0000|  -1.0000e+00|           -1|
     |  0x1.9000p+6|     100.0000|   1.0000e+02|          100|
     |  0x1.f400p+9|    1000.0000|   1.0000e+03|         1000|
     | 0x1.3880p+13|   10000.0000|   1.0000e+04|        1e+04|
     | 0x1.81c8p+13|   12345.0000|   1.2345e+04|    1.234e+04|
     | 0x1.86a0p+16|  100000.0000|   1.0000e+05|        1e+05|
     | 0x1.e240p+16|  123456.0000|   1.2346e+05|    1.235e+05|

   Notice how the `%g' conversion drops trailing zeros.


File: libc.info,  Node: Other Output Conversions,  Next: Formatted Output Functions,  Prev: Floating-Point Conversions,  Up: Formatted Output

12.12.6 Other Output Conversions
--------------------------------

This section describes miscellaneous conversions for `printf'.

   The `%c' conversion prints a single character.  In case there is no
`l' modifier the `int' argument is first converted to an `unsigned
char'.  Then, if used in a wide stream function, the character is
converted into the corresponding wide character.  The `-' flag can be
used to specify left-justification in the field, but no other flags are
defined, and no precision or type modifier can be given.  For example:

     printf ("%c%c%c%c%c", 'h', 'e', 'l', 'l', 'o');

prints `hello'.

   If there is a `l' modifier present the argument is expected to be of
type `wint_t'.  If used in a multibyte function the wide character is
converted into a multibyte character before being added to the output.
In this case more than one output byte can be produced.

   The `%s' conversion prints a string.  If no `l' modifier is present
the corresponding argument must be of type `char *' (or `const char
*').  If used in a wide stream function the string is first converted
in a wide character string.  A precision can be specified to indicate
the maximum number of characters to write; otherwise characters in the
string up to but not including the terminating null character are
written to the output stream.  The `-' flag can be used to specify
left-justification in the field, but no other flags or type modifiers
are defined for this conversion.  For example:

     printf ("%3s%-6s", "no", "where");

prints ` nowhere '.

   If there is a `l' modifier present the argument is expected to be of
type `wchar_t' (or `const wchar_t *').

   If you accidentally pass a null pointer as the argument for a `%s'
conversion, the GNU library prints it as `(null)'.  We think this is
more useful than crashing.  But it's not good practice to pass a null
argument intentionally.

   The `%m' conversion prints the string corresponding to the error
code in `errno'.  *Note Error Messages::.  Thus:

     fprintf (stderr, "can't open `%s': %m\n", filename);

is equivalent to:

     fprintf (stderr, "can't open `%s': %s\n", filename, strerror (errno));

The `%m' conversion is a GNU C library extension.

   The `%p' conversion prints a pointer value.  The corresponding
argument must be of type `void *'.  In practice, you can use any type
of pointer.

   In the GNU system, non-null pointers are printed as unsigned
integers, as if a `%#x' conversion were used.  Null pointers print as
`(nil)'.  (Pointers might print differently in other systems.)

   For example:

     printf ("%p", "testing");

prints `0x' followed by a hexadecimal number--the address of the string
constant `"testing"'.  It does not print the word `testing'.

   You can supply the `-' flag with the `%p' conversion to specify
left-justification, but no other flags, precision, or type modifiers
are defined.

   The `%n' conversion is unlike any of the other output conversions.
It uses an argument which must be a pointer to an `int', but instead of
printing anything it stores the number of characters printed so far by
this call at that location.  The `h' and `l' type modifiers are
permitted to specify that the argument is of type `short int *' or
`long int *' instead of `int *', but no flags, field width, or
precision are permitted.

   For example,

     int nchar;
     printf ("%d %s%n\n", 3, "bears", &nchar);

prints:

     3 bears

and sets `nchar' to `7', because `3 bears' is seven characters.

   The `%%' conversion prints a literal `%' character.  This conversion
doesn't use an argument, and no flags, field width, precision, or type
modifiers are permitted.


File: libc.info,  Node: Formatted Output Functions,  Next: Dynamic Output,  Prev: Other Output Conversions,  Up: Formatted Output

12.12.7 Formatted Output Functions
----------------------------------

This section describes how to call `printf' and related functions.
Prototypes for these functions are in the header file `stdio.h'.
Because these functions take a variable number of arguments, you _must_
declare prototypes for them before using them.  Of course, the easiest
way to make sure you have all the right prototypes is to just include
`stdio.h'.  

 -- Function: int printf (const char *TEMPLATE, ...)
     The `printf' function prints the optional arguments under the
     control of the template string TEMPLATE to the stream `stdout'.
     It returns the number of characters printed, or a negative value
     if there was an output error.

 -- Function: int wprintf (const wchar_t *TEMPLATE, ...)
     The `wprintf' function prints the optional arguments under the
     control of the wide template string TEMPLATE to the stream
     `stdout'.  It returns the number of wide characters printed, or a
     negative value if there was an output error.

 -- Function: int fprintf (FILE *STREAM, const char *TEMPLATE, ...)
     This function is just like `printf', except that the output is
     written to the stream STREAM instead of `stdout'.

 -- Function: int fwprintf (FILE *STREAM, const wchar_t *TEMPLATE, ...)
     This function is just like `wprintf', except that the output is
     written to the stream STREAM instead of `stdout'.

 -- Function: int sprintf (char *S, const char *TEMPLATE, ...)
     This is like `printf', except that the output is stored in the
     character array S instead of written to a stream.  A null
     character is written to mark the end of the string.

     The `sprintf' function returns the number of characters stored in
     the array S, not including the terminating null character.

     The behavior of this function is undefined if copying takes place
     between objects that overlap--for example, if S is also given as
     an argument to be printed under control of the `%s' conversion.
     *Note Copying and Concatenation::.

     *Warning:* The `sprintf' function can be *dangerous* because it
     can potentially output more characters than can fit in the
     allocation size of the string S.  Remember that the field width
     given in a conversion specification is only a _minimum_ value.

     To avoid this problem, you can use `snprintf' or `asprintf',
     described below.

 -- Function: int swprintf (wchar_t *S, size_t SIZE, const wchar_t
          *TEMPLATE, ...)
     This is like `wprintf', except that the output is stored in the
     wide character array WS instead of written to a stream.  A null
     wide character is written to mark the end of the string.  The SIZE
     argument specifies the maximum number of characters to produce.
     The trailing null character is counted towards this limit, so you
     should allocate at least SIZE wide characters for the string WS.

     The return value is the number of characters generated for the
     given input, excluding the trailing null.  If not all output fits
     into the provided buffer a negative value is returned.  You should
     try again with a bigger output string.  _Note:_ this is different
     from how `snprintf' handles this situation.

     Note that the corresponding narrow stream function takes fewer
     parameters.  `swprintf' in fact corresponds to the `snprintf'
     function.  Since the `sprintf' function can be dangerous and should
     be avoided the ISO C committee refused to make the same mistake
     again and decided to not define an function exactly corresponding
     to `sprintf'.

 -- Function: int snprintf (char *S, size_t SIZE, const char *TEMPLATE,
          ...)
     The `snprintf' function is similar to `sprintf', except that the
     SIZE argument specifies the maximum number of characters to
     produce.  The trailing null character is counted towards this
     limit, so you should allocate at least SIZE characters for the
     string S.

     The return value is the number of characters which would be
     generated for the given input, excluding the trailing null.  If
     this value is greater or equal to SIZE, not all characters from
     the result have been stored in S.  You should try again with a
     bigger output string.  Here is an example of doing this:

          /* Construct a message describing the value of a variable
             whose name is NAME and whose value is VALUE. */
          char *
          make_message (char *name, char *value)
          {
            /* Guess we need no more than 100 chars of space. */
            int size = 100;
            char *buffer = (char *) xmalloc (size);
            int nchars;
            if (buffer == NULL)
              return NULL;

           /* Try to print in the allocated space. */
            nchars = snprintf (buffer, size, "value of %s is %s",
                               name, value);
            if (nchars >= size)
              {
                /* Reallocate buffer now that we know
                   how much space is needed. */
                size = nchars + 1;
                buffer = (char *) xrealloc (buffer, size);

                if (buffer != NULL)
                  /* Try again. */
                  snprintf (buffer, size, "value of %s is %s",
                            name, value);
              }
            /* The last call worked, return the string. */
            return buffer;
          }

     In practice, it is often easier just to use `asprintf', below.

     *Attention:* In versions of the GNU C library prior to 2.1 the
     return value is the number of characters stored, not including the
     terminating null; unless there was not enough space in S to store
     the result in which case `-1' is returned.  This was changed in
     order to comply with the ISO C99 standard.


File: libc.info,  Node: Dynamic Output,  Next: Variable Arguments Output,  Prev: Formatted Output Functions,  Up: Formatted Output

12.12.8 Dynamically Allocating Formatted Output
-----------------------------------------------

The functions in this section do formatted output and place the results
in dynamically allocated memory.

 -- Function: int asprintf (char **PTR, const char *TEMPLATE, ...)
     This function is similar to `sprintf', except that it dynamically
     allocates a string (as with `malloc'; *note Unconstrained
     Allocation::) to hold the output, instead of putting the output in
     a buffer you allocate in advance.  The PTR argument should be the
     address of a `char *' object, and a successful call to `asprintf'
     stores a pointer to the newly allocated string at that location.

     The return value is the number of characters allocated for the
     buffer, or less than zero if an error occurred. Usually this means
     that the buffer could not be allocated.

     Here is how to use `asprintf' to get the same result as the
     `snprintf' example, but more easily:

          /* Construct a message describing the value of a variable
             whose name is NAME and whose value is VALUE. */
          char *
          make_message (char *name, char *value)
          {
            char *result;
            if (asprintf (&result, "value of %s is %s", name, value) < 0)
              return NULL;
            return result;
          }

 -- Function: int obstack_printf (struct obstack *OBSTACK, const char
          *TEMPLATE, ...)
     This function is similar to `asprintf', except that it uses the
     obstack OBSTACK to allocate the space.  *Note Obstacks::.

     The characters are written onto the end of the current object.  To
     get at them, you must finish the object with `obstack_finish'
     (*note Growing Objects::).


File: libc.info,  Node: Variable Arguments Output,  Next: Parsing a Template String,  Prev: Dynamic Output,  Up: Formatted Output

12.12.9 Variable Arguments Output Functions
-------------------------------------------

The functions `vprintf' and friends are provided so that you can define
your own variadic `printf'-like functions that make use of the same
internals as the built-in formatted output functions.

   The most natural way to define such functions would be to use a
language construct to say, "Call `printf' and pass this template plus
all of my arguments after the first five."  But there is no way to do
this in C, and it would be hard to provide a way, since at the C
language level there is no way to tell how many arguments your function
received.

   Since that method is impossible, we provide alternative functions,
the `vprintf' series, which lets you pass a `va_list' to describe "all
of my arguments after the first five."

   When it is sufficient to define a macro rather than a real function,
the GNU C compiler provides a way to do this much more easily with
macros.  For example:

     #define myprintf(a, b, c, d, e, rest...) \
                 printf (mytemplate , ## rest)

*Note Variadic Macros: (cpp)Variadic Macros, for details.  But this is
limited to macros, and does not apply to real functions at all.

   Before calling `vprintf' or the other functions listed in this
section, you _must_ call `va_start' (*note Variadic Functions::) to
initialize a pointer to the variable arguments.  Then you can call
`va_arg' to fetch the arguments that you want to handle yourself.  This
advances the pointer past those arguments.

   Once your `va_list' pointer is pointing at the argument of your
choice, you are ready to call `vprintf'.  That argument and all
subsequent arguments that were passed to your function are used by
`vprintf' along with the template that you specified separately.

   In some other systems, the `va_list' pointer may become invalid
after the call to `vprintf', so you must not use `va_arg' after you
call `vprintf'.  Instead, you should call `va_end' to retire the
pointer from service.  However, you can safely call `va_start' on
another pointer variable and begin fetching the arguments again through
that pointer.  Calling `vprintf' does not destroy the argument list of
your function, merely the particular pointer that you passed to it.

   GNU C does not have such restrictions.  You can safely continue to
fetch arguments from a `va_list' pointer after passing it to `vprintf',
and `va_end' is a no-op.  (Note, however, that subsequent `va_arg'
calls will fetch the same arguments which `vprintf' previously used.)

   Prototypes for these functions are declared in `stdio.h'.  

 -- Function: int vprintf (const char *TEMPLATE, va_list AP)
     This function is similar to `printf' except that, instead of taking
     a variable number of arguments directly, it takes an argument list
     pointer AP.

 -- Function: int vwprintf (const wchar_t *TEMPLATE, va_list AP)
     This function is similar to `wprintf' except that, instead of
     taking a variable number of arguments directly, it takes an
     argument list pointer AP.

 -- Function: int vfprintf (FILE *STREAM, const char *TEMPLATE, va_list
          AP)
     This is the equivalent of `fprintf' with the variable argument list
     specified directly as for `vprintf'.

 -- Function: int vfwprintf (FILE *STREAM, const wchar_t *TEMPLATE,
          va_list AP)
     This is the equivalent of `fwprintf' with the variable argument
     list specified directly as for `vwprintf'.

 -- Function: int vsprintf (char *S, const char *TEMPLATE, va_list AP)
     This is the equivalent of `sprintf' with the variable argument list
     specified directly as for `vprintf'.

 -- Function: int vswprintf (wchar_t *S, size_t SIZE, const wchar_t
          *TEMPLATE, va_list AP)
     This is the equivalent of `swprintf' with the variable argument
     list specified directly as for `vwprintf'.

 -- Function: int vsnprintf (char *S, size_t SIZE, const char
          *TEMPLATE, va_list AP)
     This is the equivalent of `snprintf' with the variable argument
     list specified directly as for `vprintf'.

 -- Function: int vasprintf (char **PTR, const char *TEMPLATE, va_list
          AP)
     The `vasprintf' function is the equivalent of `asprintf' with the
     variable argument list specified directly as for `vprintf'.

 -- Function: int obstack_vprintf (struct obstack *OBSTACK, const char
          *TEMPLATE, va_list AP)
     The `obstack_vprintf' function is the equivalent of
     `obstack_printf' with the variable argument list specified directly
     as for `vprintf'.

   Here's an example showing how you might use `vfprintf'.  This is a
function that prints error messages to the stream `stderr', along with
a prefix indicating the name of the program (*note Error Messages::,
for a description of `program_invocation_short_name').

     #include <stdio.h>
     #include <stdarg.h>

     void
     eprintf (const char *template, ...)
     {
       va_list ap;
       extern char *program_invocation_short_name;

       fprintf (stderr, "%s: ", program_invocation_short_name);
       va_start (ap, template);
       vfprintf (stderr, template, ap);
       va_end (ap);
     }

You could call `eprintf' like this:

     eprintf ("file `%s' does not exist\n", filename);

   In GNU C, there is a special construct you can use to let the
compiler know that a function uses a `printf'-style format string.
Then it can check the number and types of arguments in each call to the
function, and warn you when they do not match the format string.  For
example, take this declaration of `eprintf':

     void eprintf (const char *template, ...)
             __attribute__ ((format (printf, 1, 2)));

This tells the compiler that `eprintf' uses a format string like
`printf' (as opposed to `scanf'; *note Formatted Input::); the format
string appears as the first argument; and the arguments to satisfy the
format begin with the second.  *Note Declaring Attributes of Functions:
(gcc.info)Function Attributes, for more information.


File: libc.info,  Node: Parsing a Template String,  Next: Example of Parsing,  Prev: Variable Arguments Output,  Up: Formatted Output

12.12.10 Parsing a Template String
----------------------------------

You can use the function `parse_printf_format' to obtain information
about the number and types of arguments that are expected by a given
template string.  This function permits interpreters that provide
interfaces to `printf' to avoid passing along invalid arguments from
the user's program, which could cause a crash.

   All the symbols described in this section are declared in the header
file `printf.h'.

 -- Function: size_t parse_printf_format (const char *TEMPLATE, size_t
          N, int *ARGTYPES)
     This function returns information about the number and types of
     arguments expected by the `printf' template string TEMPLATE.  The
     information is stored in the array ARGTYPES; each element of this
     array describes one argument.  This information is encoded using
     the various `PA_' macros, listed below.

     The argument N specifies the number of elements in the array
     ARGTYPES.  This is the maximum number of elements that
     `parse_printf_format' will try to write.

     `parse_printf_format' returns the total number of arguments
     required by TEMPLATE.  If this number is greater than N, then the
     information returned describes only the first N arguments.  If you
     want information about additional arguments, allocate a bigger
     array and call `parse_printf_format' again.

   The argument types are encoded as a combination of a basic type and
modifier flag bits.

 -- Macro: int PA_FLAG_MASK
     This macro is a bitmask for the type modifier flag bits.  You can
     write the expression `(argtypes[i] & PA_FLAG_MASK)' to extract
     just the flag bits for an argument, or `(argtypes[i] &
     ~PA_FLAG_MASK)' to extract just the basic type code.

   Here are symbolic constants that represent the basic types; they
stand for integer values.

`PA_INT'
     This specifies that the base type is `int'.

`PA_CHAR'
     This specifies that the base type is `int', cast to `char'.

`PA_STRING'
     This specifies that the base type is `char *', a null-terminated
     string.

`PA_POINTER'
     This specifies that the base type is `void *', an arbitrary
     pointer.

`PA_FLOAT'
     This specifies that the base type is `float'.

`PA_DOUBLE'
     This specifies that the base type is `double'.

`PA_LAST'
     You can define additional base types for your own programs as
     offsets from `PA_LAST'.  For example, if you have data types `foo'
     and `bar' with their own specialized `printf' conversions, you
     could define encodings for these types as:

          #define PA_FOO  PA_LAST
          #define PA_BAR  (PA_LAST + 1)

   Here are the flag bits that modify a basic type.  They are combined
with the code for the basic type using inclusive-or.

`PA_FLAG_PTR'
     If this bit is set, it indicates that the encoded type is a
     pointer to the base type, rather than an immediate value.  For
     example, `PA_INT|PA_FLAG_PTR' represents the type `int *'.

`PA_FLAG_SHORT'
     If this bit is set, it indicates that the base type is modified
     with `short'.  (This corresponds to the `h' type modifier.)

`PA_FLAG_LONG'
     If this bit is set, it indicates that the base type is modified
     with `long'.  (This corresponds to the `l' type modifier.)

`PA_FLAG_LONG_LONG'
     If this bit is set, it indicates that the base type is modified
     with `long long'.  (This corresponds to the `L' type modifier.)

`PA_FLAG_LONG_DOUBLE'
     This is a synonym for `PA_FLAG_LONG_LONG', used by convention with
     a base type of `PA_DOUBLE' to indicate a type of `long double'.

   For an example of using these facilities, see *Note Example of
Parsing::.


File: libc.info,  Node: Example of Parsing,  Prev: Parsing a Template String,  Up: Formatted Output

12.12.11 Example of Parsing a Template String
---------------------------------------------

Here is an example of decoding argument types for a format string.  We
assume this is part of an interpreter which contains arguments of type
`NUMBER', `CHAR', `STRING' and `STRUCTURE' (and perhaps others which
are not valid here).

     /* Test whether the NARGS specified objects
        in the vector ARGS are valid
        for the format string FORMAT:
        if so, return 1.
        If not, return 0 after printing an error message.  */

     int
     validate_args (char *format, int nargs, OBJECT *args)
     {
       int *argtypes;
       int nwanted;

       /* Get the information about the arguments.
          Each conversion specification must be at least two characters
          long, so there cannot be more specifications than half the
          length of the string.  */

       argtypes = (int *) alloca (strlen (format) / 2 * sizeof (int));
       nwanted = parse_printf_format (string, nelts, argtypes);

       /* Check the number of arguments.  */
       if (nwanted > nargs)
         {
           error ("too few arguments (at least %d required)", nwanted);
           return 0;
         }

       /* Check the C type wanted for each argument
          and see if the object given is suitable.  */
       for (i = 0; i < nwanted; i++)
         {
           int wanted;

           if (argtypes[i] & PA_FLAG_PTR)
             wanted = STRUCTURE;
           else
             switch (argtypes[i] & ~PA_FLAG_MASK)
               {
               case PA_INT:
               case PA_FLOAT:
               case PA_DOUBLE:
                 wanted = NUMBER;
                 break;
               case PA_CHAR:
                 wanted = CHAR;
                 break;
               case PA_STRING:
                 wanted = STRING;
                 break;
               case PA_POINTER:
                 wanted = STRUCTURE;
                 break;
               }
           if (TYPE (args[i]) != wanted)
             {
               error ("type mismatch for arg number %d", i);
               return 0;
             }
         }
       return 1;
     }


File: libc.info,  Node: Customizing Printf,  Next: Formatted Input,  Prev: Formatted Output,  Up: I/O on Streams

12.13 Customizing `printf'
==========================

The GNU C library lets you define your own custom conversion specifiers
for `printf' template strings, to teach `printf' clever ways to print
the important data structures of your program.

   The way you do this is by registering the conversion with the
function `register_printf_function'; see *Note Registering New
Conversions::.  One of the arguments you pass to this function is a
pointer to a handler function that produces the actual output; see
*Note Defining the Output Handler::, for information on how to write
this function.

   You can also install a function that just returns information about
the number and type of arguments expected by the conversion specifier.
*Note Parsing a Template String::, for information about this.

   The facilities of this section are declared in the header file
`printf.h'.

* Menu:

* Registering New Conversions::         Using `register_printf_function'
                                         to register a new output conversion.
* Conversion Specifier Options::        The handler must be able to get
                                         the options specified in the
                                         template when it is called.
* Defining the Output Handler::         Defining the handler and arginfo
                                         functions that are passed as arguments
                                         to `register_printf_function'.
* Printf Extension Example::            How to define a `printf'
                                         handler function.
* Predefined Printf Handlers::          Predefined `printf' handlers.

   *Portability Note:* The ability to extend the syntax of `printf'
template strings is a GNU extension.  ISO standard C has nothing
similar.


File: libc.info,  Node: Registering New Conversions,  Next: Conversion Specifier Options,  Up: Customizing Printf

12.13.1 Registering New Conversions
-----------------------------------

The function to register a new output conversion is
`register_printf_function', declared in `printf.h'.  

 -- Function: int register_printf_function (int SPEC, printf_function
          HANDLER-FUNCTION, printf_arginfo_function ARGINFO-FUNCTION)
     This function defines the conversion specifier character SPEC.
     Thus, if SPEC is `'Y'', it defines the conversion `%Y'.  You can
     redefine the built-in conversions like `%s', but flag characters
     like `#' and type modifiers like `l' can never be used as
     conversions; calling `register_printf_function' for those
     characters has no effect.  It is advisable not to use lowercase
     letters, since the ISO C standard warns that additional lowercase
     letters may be standardized in future editions of the standard.

     The HANDLER-FUNCTION is the function called by `printf' and
     friends when this conversion appears in a template string.  *Note
     Defining the Output Handler::, for information about how to define
     a function to pass as this argument.  If you specify a null
     pointer, any existing handler function for SPEC is removed.

     The ARGINFO-FUNCTION is the function called by
     `parse_printf_format' when this conversion appears in a template
     string.  *Note Parsing a Template String::, for information about
     this.

     *Attention:* In the GNU C library versions before 2.0 the
     ARGINFO-FUNCTION function did not need to be installed unless the
     user used the `parse_printf_format' function.  This has changed.
     Now a call to any of the `printf' functions will call this
     function when this format specifier appears in the format string.

     The return value is `0' on success, and `-1' on failure (which
     occurs if SPEC is out of range).

     You can redefine the standard output conversions, but this is
     probably not a good idea because of the potential for confusion.
     Library routines written by other people could break if you do
     this.


File: libc.info,  Node: Conversion Specifier Options,  Next: Defining the Output Handler,  Prev: Registering New Conversions,  Up: Customizing Printf

12.13.2 Conversion Specifier Options
------------------------------------

If you define a meaning for `%A', what if the template contains `%+23A'
or `%-#A'?  To implement a sensible meaning for these, the handler when
called needs to be able to get the options specified in the template.

   Both the HANDLER-FUNCTION and ARGINFO-FUNCTION accept an argument
that points to a `struct printf_info', which contains information about
the options appearing in an instance of the conversion specifier.  This
data type is declared in the header file `printf.h'.  

 -- Type: struct printf_info
     This structure is used to pass information about the options
     appearing in an instance of a conversion specifier in a `printf'
     template string to the handler and arginfo functions for that
     specifier.  It contains the following members:

    `int prec'
          This is the precision specified.  The value is `-1' if no
          precision was specified.  If the precision was given as `*',
          the `printf_info' structure passed to the handler function
          contains the actual value retrieved from the argument list.
          But the structure passed to the arginfo function contains a
          value of `INT_MIN', since the actual value is not known.

    `int width'
          This is the minimum field width specified.  The value is `0'
          if no width was specified.  If the field width was given as
          `*', the `printf_info' structure passed to the handler
          function contains the actual value retrieved from the
          argument list.  But the structure passed to the arginfo
          function contains a value of `INT_MIN', since the actual
          value is not known.

    `wchar_t spec'
          This is the conversion specifier character specified.  It's
          stored in the structure so that you can register the same
          handler function for multiple characters, but still have a
          way to tell them apart when the handler function is called.

    `unsigned int is_long_double'
          This is a boolean that is true if the `L', `ll', or `q' type
          modifier was specified.  For integer conversions, this
          indicates `long long int', as opposed to `long double' for
          floating point conversions.

    `unsigned int is_char'
          This is a boolean that is true if the `hh' type modifier was
          specified.

    `unsigned int is_short'
          This is a boolean that is true if the `h' type modifier was
          specified.

    `unsigned int is_long'
          This is a boolean that is true if the `l' type modifier was
          specified.

    `unsigned int alt'
          This is a boolean that is true if the `#' flag was specified.

    `unsigned int space'
          This is a boolean that is true if the ` ' flag was specified.

    `unsigned int left'
          This is a boolean that is true if the `-' flag was specified.

    `unsigned int showsign'
          This is a boolean that is true if the `+' flag was specified.

    `unsigned int group'
          This is a boolean that is true if the `'' flag was specified.

    `unsigned int extra'
          This flag has a special meaning depending on the context.  It
          could be used freely by the user-defined handlers but when
          called from the `printf' function this variable always
          contains the value `0'.

    `unsigned int wide'
          This flag is set if the stream is wide oriented.

    `wchar_t pad'
          This is the character to use for padding the output to the
          minimum field width.  The value is `'0'' if the `0' flag was
          specified, and `' '' otherwise.


File: libc.info,  Node: Defining the Output Handler,  Next: Printf Extension Example,  Prev: Conversion Specifier Options,  Up: Customizing Printf

12.13.3 Defining the Output Handler
-----------------------------------

Now let's look at how to define the handler and arginfo functions which
are passed as arguments to `register_printf_function'.

   *Compatibility Note:* The interface changed in GNU libc version 2.0.
Previously the third argument was of type `va_list *'.

   You should define your handler functions with a prototype like:

     int FUNCTION (FILE *stream, const struct printf_info *info,
                         const void *const *args)

   The STREAM argument passed to the handler function is the stream to
which it should write output.

   The INFO argument is a pointer to a structure that contains
information about the various options that were included with the
conversion in the template string.  You should not modify this structure
inside your handler function.  *Note Conversion Specifier Options::, for
a description of this data structure.

   The ARGS is a vector of pointers to the arguments data.  The number
of arguments was determined by calling the argument information
function provided by the user.

   Your handler function should return a value just like `printf' does:
it should return the number of characters it has written, or a negative
value to indicate an error.

 -- Data Type: printf_function
     This is the data type that a handler function should have.

   If you are going to use `parse_printf_format' in your application,
you must also define a function to pass as the ARGINFO-FUNCTION
argument for each new conversion you install with
`register_printf_function'.

   You have to define these functions with a prototype like:

     int FUNCTION (const struct printf_info *info,
                         size_t n, int *argtypes)

   The return value from the function should be the number of arguments
the conversion expects.  The function should also fill in no more than
N elements of the ARGTYPES array with information about the types of
each of these arguments.  This information is encoded using the various
`PA_' macros.  (You will notice that this is the same calling
convention `parse_printf_format' itself uses.)

 -- Data Type: printf_arginfo_function
     This type is used to describe functions that return information
     about the number and type of arguments used by a conversion
     specifier.


File: libc.info,  Node: Printf Extension Example,  Next: Predefined Printf Handlers,  Prev: Defining the Output Handler,  Up: Customizing Printf

12.13.4 `printf' Extension Example
----------------------------------

Here is an example showing how to define a `printf' handler function.
This program defines a data structure called a `Widget' and defines the
`%W' conversion to print information about `Widget *' arguments,
including the pointer value and the name stored in the data structure.
The `%W' conversion supports the minimum field width and
left-justification options, but ignores everything else.

     #include <stdio.h>
     #include <stdlib.h>
     #include <printf.h>

     typedef struct
     {
       char *name;
     }
     Widget;

     int
     print_widget (FILE *stream,
                   const struct printf_info *info,
                   const void *const *args)
     {
       const Widget *w;
       char *buffer;
       int len;

       /* Format the output into a string. */
       w = *((const Widget **) (args[0]));
       len = asprintf (&buffer, "<Widget %p: %s>", w, w->name);
       if (len == -1)
         return -1;

       /* Pad to the minimum field width and print to the stream. */
       len = fprintf (stream, "%*s",
                      (info->left ? -info->width : info->width),
                      buffer);

       /* Clean up and return. */
       free (buffer);
       return len;
     }


     int
     print_widget_arginfo (const struct printf_info *info, size_t n,
                           int *argtypes)
     {
       /* We always take exactly one argument and this is a pointer to the
          structure.. */
       if (n > 0)
         argtypes[0] = PA_POINTER;
       return 1;
     }


     int
     main (void)
     {
       /* Make a widget to print. */
       Widget mywidget;
       mywidget.name = "mywidget";

       /* Register the print function for widgets. */
       register_printf_function ('W', print_widget, print_widget_arginfo);

       /* Now print the widget. */
       printf ("|%W|\n", &mywidget);
       printf ("|%35W|\n", &mywidget);
       printf ("|%-35W|\n", &mywidget);

       return 0;
     }

   The output produced by this program looks like:

     |<Widget 0xffeffb7c: mywidget>|
     |      <Widget 0xffeffb7c: mywidget>|
     |<Widget 0xffeffb7c: mywidget>      |


File: libc.info,  Node: Predefined Printf Handlers,  Prev: Printf Extension Example,  Up: Customizing Printf

12.13.5 Predefined `printf' Handlers
------------------------------------

The GNU libc also contains a concrete and useful application of the
`printf' handler extension.  There are two functions available which
implement a special way to print floating-point numbers.

 -- Function: int printf_size (FILE *FP, const struct printf_info
          *INFO, const void *const *ARGS)
     Print a given floating point number as for the format `%f' except
     that there is a postfix character indicating the divisor for the
     number to make this less than 1000.  There are two possible
     divisors: powers of 1024 or powers of 1000.  Which one is used
     depends on the format character specified while registered this
     handler.  If the character is of lower case, 1024 is used.  For
     upper case characters, 1000 is used.

     The postfix tag corresponds to bytes, kilobytes, megabytes,
     gigabytes, etc.  The full table is:

     +------+--------------+--------+--------+---------------+
     |low|Multiplier|From|Upper|Multiplier|
     |' '|1||' '|1|
     |k|2^10 (1024)|kilo|K|10^3 (1000)|
     |m|2^20|mega|M|10^6|
     |g|2^30|giga|G|10^9|
     |t|2^40|tera|T|10^12|
     |p|2^50|peta|P|10^15|
     |e|2^60|exa|E|10^18|
     |z|2^70|zetta|Z|10^21|
     |y|2^80|yotta|Y|10^24|

     The default precision is 3, i.e., 1024 is printed with a lower-case
     format character as if it were `%.3fk' and will yield `1.000k'.

   Due to the requirements of `register_printf_function' we must also
provide the function which returns information about the arguments.

 -- Function: int printf_size_info (const struct printf_info *INFO,
          size_t N, int *ARGTYPES)
     This function will return in ARGTYPES the information about the
     used parameters in the way the `vfprintf' implementation expects
     it.  The format always takes one argument.

   To use these functions both functions must be registered with a call
like

     register_printf_function ('B', printf_size, printf_size_info);

   Here we register the functions to print numbers as powers of 1000
since the format character `'B'' is an upper-case character.  If we
would additionally use `'b'' in a line like

     register_printf_function ('b', printf_size, printf_size_info);

we could also print using a power of 1024.  Please note that all that is
different in these two lines is the format specifier.  The
`printf_size' function knows about the difference between lower and
upper case format specifiers.

   The use of `'B'' and `'b'' is no coincidence.  Rather it is the
preferred way to use this functionality since it is available on some
other systems which also use format specifiers.


File: libc.info,  Node: Formatted Input,  Next: EOF and Errors,  Prev: Customizing Printf,  Up: I/O on Streams

12.14 Formatted Input
=====================

The functions described in this section (`scanf' and related functions)
provide facilities for formatted input analogous to the formatted
output facilities.  These functions provide a mechanism for reading
arbitrary values under the control of a "format string" or "template
string".

* Menu:

* Formatted Input Basics::      Some basics to get you started.
* Input Conversion Syntax::     Syntax of conversion specifications.
* Table of Input Conversions::  Summary of input conversions and what they do.
* Numeric Input Conversions::   Details of conversions for reading numbers.
* String Input Conversions::    Details of conversions for reading strings.
* Dynamic String Input::	String conversions that `malloc' the buffer.
* Other Input Conversions::     Details of miscellaneous other conversions.
* Formatted Input Functions::   Descriptions of the actual functions.
* Variable Arguments Input::    `vscanf' and friends.


File: libc.info,  Node: Formatted Input Basics,  Next: Input Conversion Syntax,  Up: Formatted Input

12.14.1 Formatted Input Basics
------------------------------

Calls to `scanf' are superficially similar to calls to `printf' in that
arbitrary arguments are read under the control of a template string.
While the syntax of the conversion specifications in the template is
very similar to that for `printf', the interpretation of the template
is oriented more towards free-format input and simple pattern matching,
rather than fixed-field formatting.  For example, most `scanf'
conversions skip over any amount of "white space" (including spaces,
tabs, and newlines) in the input file, and there is no concept of
precision for the numeric input conversions as there is for the
corresponding output conversions.  Ordinarily, non-whitespace
characters in the template are expected to match characters in the
input stream exactly, but a matching failure is distinct from an input
error on the stream.  

   Another area of difference between `scanf' and `printf' is that you
must remember to supply pointers rather than immediate values as the
optional arguments to `scanf'; the values that are read are stored in
the objects that the pointers point to.  Even experienced programmers
tend to forget this occasionally, so if your program is getting strange
errors that seem to be related to `scanf', you might want to
double-check this.

   When a "matching failure" occurs, `scanf' returns immediately,
leaving the first non-matching character as the next character to be
read from the stream.  The normal return value from `scanf' is the
number of values that were assigned, so you can use this to determine if
a matching error happened before all the expected values were read.  

   The `scanf' function is typically used for things like reading in
the contents of tables.  For example, here is a function that uses
`scanf' to initialize an array of `double':

     void
     readarray (double *array, int n)
     {
       int i;
       for (i=0; i<n; i++)
         if (scanf (" %lf", &(array[i])) != 1)
           invalid_input_error ();
     }

   The formatted input functions are not used as frequently as the
formatted output functions.  Partly, this is because it takes some care
to use them properly.  Another reason is that it is difficult to recover
from a matching error.

   If you are trying to read input that doesn't match a single, fixed
pattern, you may be better off using a tool such as Flex to generate a
lexical scanner, or Bison to generate a parser, rather than using
`scanf'.  For more information about these tools, see *Note Top:
(flex.info)Top, and *Note Top: (bison.info)Top.


File: libc.info,  Node: Input Conversion Syntax,  Next: Table of Input Conversions,  Prev: Formatted Input Basics,  Up: Formatted Input

12.14.2 Input Conversion Syntax
-------------------------------

A `scanf' template string is a string that contains ordinary multibyte
characters interspersed with conversion specifications that start with
`%'.

   Any whitespace character (as defined by the `isspace' function;
*note Classification of Characters::) in the template causes any number
of whitespace characters in the input stream to be read and discarded.
The whitespace characters that are matched need not be exactly the same
whitespace characters that appear in the template string.  For example,
write ` , ' in the template to recognize a comma with optional
whitespace before and after.

   Other characters in the template string that are not part of
conversion specifications must match characters in the input stream
exactly; if this is not the case, a matching failure occurs.

   The conversion specifications in a `scanf' template string have the
general form:

     % FLAGS WIDTH TYPE CONVERSION

   In more detail, an input conversion specification consists of an
initial `%' character followed in sequence by:

   * An optional "flag character" `*', which says to ignore the text
     read for this specification.  When `scanf' finds a conversion
     specification that uses this flag, it reads input as directed by
     the rest of the conversion specification, but it discards this
     input, does not use a pointer argument, and does not increment the
     count of successful assignments.  

   * An optional flag character `a' (valid with string conversions only)
     which requests allocation of a buffer long enough to store the
     string in.  (This is a GNU extension.)  *Note Dynamic String
     Input::.

   * An optional decimal integer that specifies the "maximum field
     width".  Reading of characters from the input stream stops either
     when this maximum is reached or when a non-matching character is
     found, whichever happens first.  Most conversions discard initial
     whitespace characters (those that don't are explicitly
     documented), and these discarded characters don't count towards
     the maximum field width.  String input conversions store a null
     character to mark the end of the input; the maximum field width
     does not include this terminator.  

   * An optional "type modifier character".  For example, you can
     specify a type modifier of `l' with integer conversions such as
     `%d' to specify that the argument is a pointer to a `long int'
     rather than a pointer to an `int'.  

   * A character that specifies the conversion to be applied.

   The exact options that are permitted and how they are interpreted
vary between the different conversion specifiers.  See the descriptions
of the individual conversions for information about the particular
options that they allow.

   With the `-Wformat' option, the GNU C compiler checks calls to
`scanf' and related functions.  It examines the format string and
verifies that the correct number and types of arguments are supplied.
There is also a GNU C syntax to tell the compiler that a function you
write uses a `scanf'-style format string.  *Note Declaring Attributes
of Functions: (gcc.info)Function Attributes, for more information.


File: libc.info,  Node: Table of Input Conversions,  Next: Numeric Input Conversions,  Prev: Input Conversion Syntax,  Up: Formatted Input

12.14.3 Table of Input Conversions
----------------------------------

Here is a table that summarizes the various conversion specifications:

`%d'
     Matches an optionally signed integer written in decimal.  *Note
     Numeric Input Conversions::.

`%i'
     Matches an optionally signed integer in any of the formats that
     the C language defines for specifying an integer constant.  *Note
     Numeric Input Conversions::.

`%o'
     Matches an unsigned integer written in octal radix.  *Note Numeric
     Input Conversions::.

`%u'
     Matches an unsigned integer written in decimal radix.  *Note
     Numeric Input Conversions::.

`%x', `%X'
     Matches an unsigned integer written in hexadecimal radix.  *Note
     Numeric Input Conversions::.

`%e', `%f', `%g', `%E', `%G'
     Matches an optionally signed floating-point number.  *Note Numeric
     Input Conversions::.

`%s'
     Matches a string containing only non-whitespace characters.  *Note
     String Input Conversions::.  The presence of the `l' modifier
     determines whether the output is stored as a wide character string
     or a multibyte string.  If `%s' is used in a wide character
     function the string is converted as with multiple calls to
     `wcrtomb' into a multibyte string.  This means that the buffer
     must provide room for `MB_CUR_MAX' bytes for each wide character
     read.  In case `%ls' is used in a multibyte function the result is
     converted into wide characters as with multiple calls of `mbrtowc'
     before being stored in the user provided buffer.

`%S'
     This is an alias for `%ls' which is supported for compatibility
     with the Unix standard.

`%['
     Matches a string of characters that belong to a specified set.
     *Note String Input Conversions::.  The presence of the `l' modifier
     determines whether the output is stored as a wide character string
     or a multibyte string.  If `%[' is used in a wide character
     function the string is converted as with multiple calls to
     `wcrtomb' into a multibyte string.  This means that the buffer
     must provide room for `MB_CUR_MAX' bytes for each wide character
     read.  In case `%l[' is used in a multibyte function the result is
     converted into wide characters as with multiple calls of `mbrtowc'
     before being stored in the user provided buffer.

`%c'
     Matches a string of one or more characters; the number of
     characters read is controlled by the maximum field width given for
     the conversion.  *Note String Input Conversions::.

     If the `%c' is used in a wide stream function the read value is
     converted from a wide character to the corresponding multibyte
     character before storing it.  Note that this conversion can
     produce more than one byte of output and therefore the provided
     buffer be large enough for up to `MB_CUR_MAX' bytes for each
     character.  If `%lc' is used in a multibyte function the input is
     treated as a multibyte sequence (and not bytes) and the result is
     converted as with calls to `mbrtowc'.

`%C'
     This is an alias for `%lc' which is supported for compatibility
     with the Unix standard.

`%p'
     Matches a pointer value in the same implementation-defined format
     used by the `%p' output conversion for `printf'.  *Note Other
     Input Conversions::.

`%n'
     This conversion doesn't read any characters; it records the number
     of characters read so far by this call.  *Note Other Input
     Conversions::.

`%%'
     This matches a literal `%' character in the input stream.  No
     corresponding argument is used.  *Note Other Input Conversions::.

   If the syntax of a conversion specification is invalid, the behavior
is undefined.  If there aren't enough function arguments provided to
supply addresses for all the conversion specifications in the template
strings that perform assignments, or if the arguments are not of the
correct types, the behavior is also undefined.  On the other hand, extra
arguments are simply ignored.


File: libc.info,  Node: Numeric Input Conversions,  Next: String Input Conversions,  Prev: Table of Input Conversions,  Up: Formatted Input

12.14.4 Numeric Input Conversions
---------------------------------

This section describes the `scanf' conversions for reading numeric
values.

   The `%d' conversion matches an optionally signed integer in decimal
radix.  The syntax that is recognized is the same as that for the
`strtol' function (*note Parsing of Integers::) with the value `10' for
the BASE argument.

   The `%i' conversion matches an optionally signed integer in any of
the formats that the C language defines for specifying an integer
constant.  The syntax that is recognized is the same as that for the
`strtol' function (*note Parsing of Integers::) with the value `0' for
the BASE argument.  (You can print integers in this syntax with
`printf' by using the `#' flag character with the `%x', `%o', or `%d'
conversion.  *Note Integer Conversions::.)

   For example, any of the strings `10', `0xa', or `012' could be read
in as integers under the `%i' conversion.  Each of these specifies a
number with decimal value `10'.

   The `%o', `%u', and `%x' conversions match unsigned integers in
octal, decimal, and hexadecimal radices, respectively.  The syntax that
is recognized is the same as that for the `strtoul' function (*note
Parsing of Integers::) with the appropriate value (`8', `10', or `16')
for the BASE argument.

   The `%X' conversion is identical to the `%x' conversion.  They both
permit either uppercase or lowercase letters to be used as digits.

   The default type of the corresponding argument for the `%d' and `%i'
conversions is `int *', and `unsigned int *' for the other integer
conversions.  You can use the following type modifiers to specify other
sizes of integer:

`hh'
     Specifies that the argument is a `signed char *' or `unsigned char
     *'.

     This modifier was introduced in ISO C99.

`h'
     Specifies that the argument is a `short int *' or `unsigned short
     int *'.

`j'
     Specifies that the argument is a `intmax_t *' or `uintmax_t *'.

     This modifier was introduced in ISO C99.

`l'
     Specifies that the argument is a `long int *' or `unsigned long
     int *'.  Two `l' characters is like the `L' modifier, below.

     If used with `%c' or `%s' the corresponding parameter is
     considered as a pointer to a wide character or wide character
     string respectively.  This use of `l' was introduced in
     Amendment 1 to ISO C90.

`ll'
`L'
`q'
     Specifies that the argument is a `long long int *' or `unsigned
     long long int *'.  (The `long long' type is an extension supported
     by the GNU C compiler.  For systems that don't provide extra-long
     integers, this is the same as `long int'.)

     The `q' modifier is another name for the same thing, which comes
     from 4.4 BSD; a `long long int' is sometimes called a "quad" `int'.

`t'
     Specifies that the argument is a `ptrdiff_t *'.

     This modifier was introduced in ISO C99.

`z'
     Specifies that the argument is a `size_t *'.

     This modifier was introduced in ISO C99.

   All of the `%e', `%f', `%g', `%E', and `%G' input conversions are
interchangeable.  They all match an optionally signed floating point
number, in the same syntax as for the `strtod' function (*note Parsing
of Floats::).

   For the floating-point input conversions, the default argument type
is `float *'.  (This is different from the corresponding output
conversions, where the default type is `double'; remember that `float'
arguments to `printf' are converted to `double' by the default argument
promotions, but `float *' arguments are not promoted to `double *'.)
You can specify other sizes of float using these type modifiers:

`l'
     Specifies that the argument is of type `double *'.

`L'
     Specifies that the argument is of type `long double *'.

   For all the above number parsing formats there is an additional
optional flag `''.  When this flag is given the `scanf' function
expects the number represented in the input string to be formatted
according to the grouping rules of the currently selected locale (*note
General Numeric::).

   If the `"C"' or `"POSIX"' locale is selected there is no difference.
But for a locale which specifies values for the appropriate fields in
the locale the input must have the correct form in the input.
Otherwise the longest prefix with a correct form is processed.


File: libc.info,  Node: String Input Conversions,  Next: Dynamic String Input,  Prev: Numeric Input Conversions,  Up: Formatted Input

12.14.5 String Input Conversions
--------------------------------

This section describes the `scanf' input conversions for reading string
and character values: `%s', `%S', `%[', `%c', and `%C'.

   You have two options for how to receive the input from these
conversions:

   * Provide a buffer to store it in.  This is the default.  You should
     provide an argument of type `char *' or `wchar_t *' (the latter of
     the `l' modifier is present).

     *Warning:* To make a robust program, you must make sure that the
     input (plus its terminating null) cannot possibly exceed the size
     of the buffer you provide.  In general, the only way to do this is
     to specify a maximum field width one less than the buffer size.
     *If you provide the buffer, always specify a maximum field width
     to prevent overflow.*

   * Ask `scanf' to allocate a big enough buffer, by specifying the `a'
     flag character.  This is a GNU extension.  You should provide an
     argument of type `char **' for the buffer address to be stored in.
     *Note Dynamic String Input::.

   The `%c' conversion is the simplest: it matches a fixed number of
characters, always.  The maximum field width says how many characters to
read; if you don't specify the maximum, the default is 1.  This
conversion doesn't append a null character to the end of the text it
reads.  It also does not skip over initial whitespace characters.  It
reads precisely the next N characters, and fails if it cannot get that
many.  Since there is always a maximum field width with `%c' (whether
specified, or 1 by default), you can always prevent overflow by making
the buffer long enough.

   If the format is `%lc' or `%C' the function stores wide characters
which are converted using the conversion determined at the time the
stream was opened from the external byte stream.  The number of bytes
read from the medium is limited by `MB_CUR_LEN * N' but at most N wide
character get stored in the output string.

   The `%s' conversion matches a string of non-whitespace characters.
It skips and discards initial whitespace, but stops when it encounters
more whitespace after having read something.  It stores a null character
at the end of the text that it reads.

   For example, reading the input:

      hello, world

with the conversion `%10c' produces `" hello, wo"', but reading the
same input with the conversion `%10s' produces `"hello,"'.

   *Warning:* If you do not specify a field width for `%s', then the
number of characters read is limited only by where the next whitespace
character appears.  This almost certainly means that invalid input can
make your program crash--which is a bug.

   The `%ls' and `%S' format are handled just like `%s' except that the
external byte sequence is converted using the conversion associated
with the stream to wide characters with their own encoding.  A width or
precision specified with the format do not directly determine how many
bytes are read from the stream since they measure wide characters.  But
an upper limit can be computed by multiplying the value of the width or
precision by `MB_CUR_MAX'.

   To read in characters that belong to an arbitrary set of your choice,
use the `%[' conversion.  You specify the set between the `[' character
and a following `]' character, using the same syntax used in regular
expressions.  As special cases:

   * A literal `]' character can be specified as the first character of
     the set.

   * An embedded `-' character (that is, one that is not the first or
     last character of the set) is used to specify a range of
     characters.

   * If a caret character `^' immediately follows the initial `[', then
     the set of allowed input characters is the everything _except_ the
     characters listed.

   The `%[' conversion does not skip over initial whitespace characters.

   Here are some examples of `%[' conversions and what they mean:

`%25[1234567890]'
     Matches a string of up to 25 digits.

`%25[][]'
     Matches a string of up to 25 square brackets.

`%25[^ \f\n\r\t\v]'
     Matches a string up to 25 characters long that doesn't contain any
     of the standard whitespace characters.  This is slightly different
     from `%s', because if the input begins with a whitespace character,
     `%[' reports a matching failure while `%s' simply discards the
     initial whitespace.

`%25[a-z]'
     Matches up to 25 lowercase characters.

   As for `%c' and `%s' the `%[' format is also modified to produce
wide characters if the `l' modifier is present.  All what is said about
`%ls' above is true for `%l['.

   One more reminder: the `%s' and `%[' conversions are *dangerous* if
you don't specify a maximum width or use the `a' flag, because input
too long would overflow whatever buffer you have provided for it.  No
matter how long your buffer is, a user could supply input that is
longer.  A well-written program reports invalid input with a
comprehensible error message, not with a crash.


File: libc.info,  Node: Dynamic String Input,  Next: Other Input Conversions,  Prev: String Input Conversions,  Up: Formatted Input

12.14.6 Dynamically Allocating String Conversions
-------------------------------------------------

A GNU extension to formatted input lets you safely read a string with no
maximum size.  Using this feature, you don't supply a buffer; instead,
`scanf' allocates a buffer big enough to hold the data and gives you
its address.  To use this feature, write `a' as a flag character, as in
`%as' or `%a[0-9a-z]'.

   The pointer argument you supply for where to store the input should
have type `char **'.  The `scanf' function allocates a buffer and
stores its address in the word that the argument points to.  You should
free the buffer with `free' when you no longer need it.

   Here is an example of using the `a' flag with the `%[...]'
conversion specification to read a "variable assignment" of the form
`VARIABLE = VALUE'.

     {
       char *variable, *value;

       if (2 > scanf ("%a[a-zA-Z0-9] = %a[^\n]\n",
                      &variable, &value))
         {
           invalid_input_error ();
           return 0;
         }

       ...
     }


File: libc.info,  Node: Other Input Conversions,  Next: Formatted Input Functions,  Prev: Dynamic String Input,  Up: Formatted Input

12.14.7 Other Input Conversions
-------------------------------

This section describes the miscellaneous input conversions.

   The `%p' conversion is used to read a pointer value.  It recognizes
the same syntax used by the `%p' output conversion for `printf' (*note
Other Output Conversions::); that is, a hexadecimal number just as the
`%x' conversion accepts.  The corresponding argument should be of type
`void **'; that is, the address of a place to store a pointer.

   The resulting pointer value is not guaranteed to be valid if it was
not originally written during the same program execution that reads it
in.

   The `%n' conversion produces the number of characters read so far by
this call.  The corresponding argument should be of type `int *'.  This
conversion works in the same way as the `%n' conversion for `printf';
see *Note Other Output Conversions::, for an example.

   The `%n' conversion is the only mechanism for determining the
success of literal matches or conversions with suppressed assignments.
If the `%n' follows the locus of a matching failure, then no value is
stored for it since `scanf' returns before processing the `%n'.  If you
store `-1' in that argument slot before calling `scanf', the presence
of `-1' after `scanf' indicates an error occurred before the `%n' was
reached.

   Finally, the `%%' conversion matches a literal `%' character in the
input stream, without using an argument.  This conversion does not
permit any flags, field width, or type modifier to be specified.


File: libc.info,  Node: Formatted Input Functions,  Next: Variable Arguments Input,  Prev: Other Input Conversions,  Up: Formatted Input

12.14.8 Formatted Input Functions
---------------------------------

Here are the descriptions of the functions for performing formatted
input.  Prototypes for these functions are in the header file `stdio.h'.  

 -- Function: int scanf (const char *TEMPLATE, ...)
     The `scanf' function reads formatted input from the stream `stdin'
     under the control of the template string TEMPLATE.  The optional
     arguments are pointers to the places which receive the resulting
     values.

     The return value is normally the number of successful assignments.
     If an end-of-file condition is detected before any matches are
     performed, including matches against whitespace and literal
     characters in the template, then `EOF' is returned.

 -- Function: int wscanf (const wchar_t *TEMPLATE, ...)
     The `wscanf' function reads formatted input from the stream
     `stdin' under the control of the template string TEMPLATE.  The
     optional arguments are pointers to the places which receive the
     resulting values.

     The return value is normally the number of successful assignments.
     If an end-of-file condition is detected before any matches are
     performed, including matches against whitespace and literal
     characters in the template, then `WEOF' is returned.

 -- Function: int fscanf (FILE *STREAM, const char *TEMPLATE, ...)
     This function is just like `scanf', except that the input is read
     from the stream STREAM instead of `stdin'.

 -- Function: int fwscanf (FILE *STREAM, const wchar_t *TEMPLATE, ...)
     This function is just like `wscanf', except that the input is read
     from the stream STREAM instead of `stdin'.

 -- Function: int sscanf (const char *S, const char *TEMPLATE, ...)
     This is like `scanf', except that the characters are taken from the
     null-terminated string S instead of from a stream.  Reaching the
     end of the string is treated as an end-of-file condition.

     The behavior of this function is undefined if copying takes place
     between objects that overlap--for example, if S is also given as
     an argument to receive a string read under control of the `%s',
     `%S', or `%[' conversion.

 -- Function: int swscanf (const wchar_t *WS, const char *TEMPLATE, ...)
     This is like `wscanf', except that the characters are taken from
     the null-terminated string WS instead of from a stream.  Reaching
     the end of the string is treated as an end-of-file condition.

     The behavior of this function is undefined if copying takes place
     between objects that overlap--for example, if WS is also given as
     an argument to receive a string read under control of the `%s',
     `%S', or `%[' conversion.


File: libc.info,  Node: Variable Arguments Input,  Prev: Formatted Input Functions,  Up: Formatted Input

12.14.9 Variable Arguments Input Functions
------------------------------------------

The functions `vscanf' and friends are provided so that you can define
your own variadic `scanf'-like functions that make use of the same
internals as the built-in formatted output functions.  These functions
are analogous to the `vprintf' series of output functions.  *Note
Variable Arguments Output::, for important information on how to use
them.

   *Portability Note:* The functions listed in this section were
introduced in ISO C99 and were before available as GNU extensions.

 -- Function: int vscanf (const char *TEMPLATE, va_list AP)
     This function is similar to `scanf', but instead of taking a
     variable number of arguments directly, it takes an argument list
     pointer AP of type `va_list' (*note Variadic Functions::).

 -- Function: int vwscanf (const wchar_t *TEMPLATE, va_list AP)
     This function is similar to `wscanf', but instead of taking a
     variable number of arguments directly, it takes an argument list
     pointer AP of type `va_list' (*note Variadic Functions::).

 -- Function: int vfscanf (FILE *STREAM, const char *TEMPLATE, va_list
          AP)
     This is the equivalent of `fscanf' with the variable argument list
     specified directly as for `vscanf'.

 -- Function: int vfwscanf (FILE *STREAM, const wchar_t *TEMPLATE,
          va_list AP)
     This is the equivalent of `fwscanf' with the variable argument list
     specified directly as for `vwscanf'.

 -- Function: int vsscanf (const char *S, const char *TEMPLATE, va_list
          AP)
     This is the equivalent of `sscanf' with the variable argument list
     specified directly as for `vscanf'.

 -- Function: int vswscanf (const wchar_t *S, const wchar_t *TEMPLATE,
          va_list AP)
     This is the equivalent of `swscanf' with the variable argument list
     specified directly as for `vwscanf'.

   In GNU C, there is a special construct you can use to let the
compiler know that a function uses a `scanf'-style format string.  Then
it can check the number and types of arguments in each call to the
function, and warn you when they do not match the format string.  For
details, see *Note Declaring Attributes of Functions:
(gcc.info)Function Attributes.


File: libc.info,  Node: EOF and Errors,  Next: Error Recovery,  Prev: Formatted Input,  Up: I/O on Streams

12.15 End-Of-File and Errors
============================

Many of the functions described in this chapter return the value of the
macro `EOF' to indicate unsuccessful completion of the operation.
Since `EOF' is used to report both end of file and random errors, it's
often better to use the `feof' function to check explicitly for end of
file and `ferror' to check for errors.  These functions check
indicators that are part of the internal state of the stream object,
indicators set if the appropriate condition was detected by a previous
I/O operation on that stream.

 -- Macro: int EOF
     This macro is an integer value that is returned by a number of
     narrow stream functions to indicate an end-of-file condition, or
     some other error situation.  With the GNU library, `EOF' is `-1'.
     In other libraries, its value may be some other negative number.

     This symbol is declared in `stdio.h'.

 -- Macro: int WEOF
     This macro is an integer value that is returned by a number of wide
     stream functions to indicate an end-of-file condition, or some
     other error situation.  With the GNU library, `WEOF' is `-1'.  In
     other libraries, its value may be some other negative number.

     This symbol is declared in `wchar.h'.

 -- Function: int feof (FILE *STREAM)
     The `feof' function returns nonzero if and only if the end-of-file
     indicator for the stream STREAM is set.

     This symbol is declared in `stdio.h'.

 -- Function: int feof_unlocked (FILE *STREAM)
     The `feof_unlocked' function is equivalent to the `feof' function
     except that it does not implicitly lock the stream.

     This function is a GNU extension.

     This symbol is declared in `stdio.h'.

 -- Function: int ferror (FILE *STREAM)
     The `ferror' function returns nonzero if and only if the error
     indicator for the stream STREAM is set, indicating that an error
     has occurred on a previous operation on the stream.

     This symbol is declared in `stdio.h'.

 -- Function: int ferror_unlocked (FILE *STREAM)
     The `ferror_unlocked' function is equivalent to the `ferror'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

     This symbol is declared in `stdio.h'.

   In addition to setting the error indicator associated with the
stream, the functions that operate on streams also set `errno' in the
same way as the corresponding low-level functions that operate on file
descriptors.  For example, all of the functions that perform output to a
stream--such as `fputc', `printf', and `fflush'--are implemented in
terms of `write', and all of the `errno' error conditions defined for
`write' are meaningful for these functions.  For more information about
the descriptor-level I/O functions, see *Note Low-Level I/O::.


File: libc.info,  Node: Error Recovery,  Next: Binary Streams,  Prev: EOF and Errors,  Up: I/O on Streams

12.16 Recovering from errors
============================

You may explicitly clear the error and EOF flags with the `clearerr'
function.

 -- Function: void clearerr (FILE *STREAM)
     This function clears the end-of-file and error indicators for the
     stream STREAM.

     The file positioning functions (*note File Positioning::) also
     clear the end-of-file indicator for the stream.

 -- Function: void clearerr_unlocked (FILE *STREAM)
     The `clearerr_unlocked' function is equivalent to the `clearerr'
     function except that it does not implicitly lock the stream.

     This function is a GNU extension.

   Note that it is _not_ correct to just clear the error flag and retry
a failed stream operation.  After a failed write, any number of
characters since the last buffer flush may have been committed to the
file, while some buffered data may have been discarded.  Merely retrying
can thus cause lost or repeated data.

   A failed read may leave the file pointer in an inappropriate
position for a second try.  In both cases, you should seek to a known
position before retrying.

   Most errors that can happen are not recoverable -- a second try will
always fail again in the same way.  So usually it is best to give up and
report the error to the user, rather than install complicated recovery
logic.

   One important exception is `EINTR' (*note Interrupted Primitives::).
Many stream I/O implementations will treat it as an ordinary error,
which can be quite inconvenient.  You can avoid this hassle by
installing all signals with the `SA_RESTART' flag.

   For similar reasons, setting nonblocking I/O on a stream's file
descriptor is not usually advisable.


File: libc.info,  Node: Binary Streams,  Next: File Positioning,  Prev: Error Recovery,  Up: I/O on Streams

12.17 Text and Binary Streams
=============================

The GNU system and other POSIX-compatible operating systems organize all
files as uniform sequences of characters.  However, some other systems
make a distinction between files containing text and files containing
binary data, and the input and output facilities of ISO C provide for
this distinction.  This section tells you how to write programs portable
to such systems.

   When you open a stream, you can specify either a "text stream" or a
"binary stream".  You indicate that you want a binary stream by
specifying the `b' modifier in the OPENTYPE argument to `fopen'; see
*Note Opening Streams::.  Without this option, `fopen' opens the file
as a text stream.

   Text and binary streams differ in several ways:

   * The data read from a text stream is divided into "lines" which are
     terminated by newline (`'\n'') characters, while a binary stream is
     simply a long series of characters.  A text stream might on some
     systems fail to handle lines more than 254 characters long
     (including the terminating newline character).  

   * On some systems, text files can contain only printing characters,
     horizontal tab characters, and newlines, and so text streams may
     not support other characters.  However, binary streams can handle
     any character value.

   * Space characters that are written immediately preceding a newline
     character in a text stream may disappear when the file is read in
     again.

   * More generally, there need not be a one-to-one mapping between
     characters that are read from or written to a text stream, and the
     characters in the actual file.

   Since a binary stream is always more capable and more predictable
than a text stream, you might wonder what purpose text streams serve.
Why not simply always use binary streams?  The answer is that on these
operating systems, text and binary streams use different file formats,
and the only way to read or write "an ordinary file of text" that can
work with other text-oriented programs is through a text stream.

   In the GNU library, and on all POSIX systems, there is no difference
between text streams and binary streams.  When you open a stream, you
get the same kind of stream regardless of whether you ask for binary.
This stream can handle any file content, and has none of the
restrictions that text streams sometimes have.


File: libc.info,  Node: File Positioning,  Next: Portable Positioning,  Prev: Binary Streams,  Up: I/O on Streams

12.18 File Positioning
======================

The "file position" of a stream describes where in the file the stream
is currently reading or writing.  I/O on the stream advances the file
position through the file.  In the GNU system, the file position is
represented as an integer, which counts the number of bytes from the
beginning of the file.  *Note File Position::.

   During I/O to an ordinary disk file, you can change the file position
whenever you wish, so as to read or write any portion of the file.  Some
other kinds of files may also permit this.  Files which support changing
the file position are sometimes referred to as "random-access" files.

   You can use the functions in this section to examine or modify the
file position indicator associated with a stream.  The symbols listed
below are declared in the header file `stdio.h'.  

 -- Function: long int ftell (FILE *STREAM)
     This function returns the current file position of the stream
     STREAM.

     This function can fail if the stream doesn't support file
     positioning, or if the file position can't be represented in a
     `long int', and possibly for other reasons as well.  If a failure
     occurs, a value of `-1' is returned.

 -- Function: off_t ftello (FILE *STREAM)
     The `ftello' function is similar to `ftell', except that it
     returns a value of type `off_t'.  Systems which support this type
     use it to describe all file positions, unlike the POSIX
     specification which uses a long int.  The two are not necessarily
     the same size.  Therefore, using ftell can lead to problems if the
     implementation is written on top of a POSIX compliant low-level
     I/O implementation, and using `ftello' is preferable whenever it
     is available.

     If this function fails it returns `(off_t) -1'.  This can happen
     due to missing support for file positioning or internal errors.
     Otherwise the return value is the current file position.

     The function is an extension defined in the Unix Single
     Specification version 2.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32 bit system this function is in fact `ftello64'.  I.e., the LFS
     interface transparently replaces the old interface.

 -- Function: off64_t ftello64 (FILE *STREAM)
     This function is similar to `ftello' with the only difference that
     the return value is of type `off64_t'.  This also requires that the
     stream STREAM was opened using either `fopen64', `freopen64', or
     `tmpfile64' since otherwise the underlying file operations to
     position the file pointer beyond the 2^31 bytes limit might fail.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a 32
     bits machine this function is available under the name `ftello'
     and so transparently replaces the old interface.

 -- Function: int fseek (FILE *STREAM, long int OFFSET, int WHENCE)
     The `fseek' function is used to change the file position of the
     stream STREAM.  The value of WHENCE must be one of the constants
     `SEEK_SET', `SEEK_CUR', or `SEEK_END', to indicate whether the
     OFFSET is relative to the beginning of the file, the current file
     position, or the end of the file, respectively.

     This function returns a value of zero if the operation was
     successful, and a nonzero value to indicate failure.  A successful
     call also clears the end-of-file indicator of STREAM and discards
     any characters that were "pushed back" by the use of `ungetc'.

     `fseek' either flushes any buffered output before setting the file
     position or else remembers it so it will be written later in its
     proper place in the file.

 -- Function: int fseeko (FILE *STREAM, off_t OFFSET, int WHENCE)
     This function is similar to `fseek' but it corrects a problem with
     `fseek' in a system with POSIX types.  Using a value of type `long
     int' for the offset is not compatible with POSIX.  `fseeko' uses
     the correct type `off_t' for the OFFSET parameter.

     For this reason it is a good idea to prefer `ftello' whenever it is
     available since its functionality is (if different at all) closer
     the underlying definition.

     The functionality and return value is the same as for `fseek'.

     The function is an extension defined in the Unix Single
     Specification version 2.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32 bit system this function is in fact `fseeko64'.  I.e., the LFS
     interface transparently replaces the old interface.

 -- Function: int fseeko64 (FILE *STREAM, off64_t OFFSET, int WHENCE)
     This function is similar to `fseeko' with the only difference that
     the OFFSET parameter is of type `off64_t'.  This also requires
     that the stream STREAM was opened using either `fopen64',
     `freopen64', or `tmpfile64' since otherwise the underlying file
     operations to position the file pointer beyond the 2^31 bytes
     limit might fail.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a 32
     bits machine this function is available under the name `fseeko'
     and so transparently replaces the old interface.

   *Portability Note:* In non-POSIX systems, `ftell', `ftello', `fseek'
and `fseeko' might work reliably only on binary streams.  *Note Binary
Streams::.

   The following symbolic constants are defined for use as the WHENCE
argument to `fseek'.  They are also used with the `lseek' function
(*note I/O Primitives::) and to specify offsets for file locks (*note
Control Operations::).

 -- Macro: int SEEK_SET
     This is an integer constant which, when used as the WHENCE
     argument to the `fseek' or `fseeko' function, specifies that the
     offset provided is relative to the beginning of the file.

 -- Macro: int SEEK_CUR
     This is an integer constant which, when used as the WHENCE
     argument to the `fseek' or `fseeko' function, specifies that the
     offset provided is relative to the current file position.

 -- Macro: int SEEK_END
     This is an integer constant which, when used as the WHENCE
     argument to the `fseek' or `fseeko' function, specifies that the
     offset provided is relative to the end of the file.

 -- Function: void rewind (FILE *STREAM)
     The `rewind' function positions the stream STREAM at the beginning
     of the file.  It is equivalent to calling `fseek' or `fseeko' on
     the STREAM with an OFFSET argument of `0L' and a WHENCE argument
     of `SEEK_SET', except that the return value is discarded and the
     error indicator for the stream is reset.

   These three aliases for the `SEEK_...' constants exist for the sake
of compatibility with older BSD systems.  They are defined in two
different header files: `fcntl.h' and `sys/file.h'.

`L_SET'
     An alias for `SEEK_SET'.

`L_INCR'
     An alias for `SEEK_CUR'.

`L_XTND'
     An alias for `SEEK_END'.


File: libc.info,  Node: Portable Positioning,  Next: Stream Buffering,  Prev: File Positioning,  Up: I/O on Streams

12.19 Portable File-Position Functions
======================================

On the GNU system, the file position is truly a character count.  You
can specify any character count value as an argument to `fseek' or
`fseeko' and get reliable results for any random access file.  However,
some ISO C systems do not represent file positions in this way.

   On some systems where text streams truly differ from binary streams,
it is impossible to represent the file position of a text stream as a
count of characters from the beginning of the file.  For example, the
file position on some systems must encode both a record offset within
the file, and a character offset within the record.

   As a consequence, if you want your programs to be portable to these
systems, you must observe certain rules:

   * The value returned from `ftell' on a text stream has no predictable
     relationship to the number of characters you have read so far.
     The only thing you can rely on is that you can use it subsequently
     as the OFFSET argument to `fseek' or `fseeko' to move back to the
     same file position.

   * In a call to `fseek' or `fseeko' on a text stream, either the
     OFFSET must be zero, or WHENCE must be `SEEK_SET' and and the
     OFFSET must be the result of an earlier call to `ftell' on the
     same stream.

   * The value of the file position indicator of a text stream is
     undefined while there are characters that have been pushed back
     with `ungetc' that haven't been read or discarded.  *Note
     Unreading::.

   But even if you observe these rules, you may still have trouble for
long files, because `ftell' and `fseek' use a `long int' value to
represent the file position.  This type may not have room to encode all
the file positions in a large file.  Using the `ftello' and `fseeko'
functions might help here since the `off_t' type is expected to be able
to hold all file position values but this still does not help to handle
additional information which must be associated with a file position.

   So if you do want to support systems with peculiar encodings for the
file positions, it is better to use the functions `fgetpos' and
`fsetpos' instead.  These functions represent the file position using
the data type `fpos_t', whose internal representation varies from
system to system.

   These symbols are declared in the header file `stdio.h'.  

 -- Data Type: fpos_t
     This is the type of an object that can encode information about the
     file position of a stream, for use by the functions `fgetpos' and
     `fsetpos'.

     In the GNU system, `fpos_t' is an opaque data structure that
     contains internal data to represent file offset and conversion
     state information.  In other systems, it might have a different
     internal representation.

     When compiling with `_FILE_OFFSET_BITS == 64' on a 32 bit machine
     this type is in fact equivalent to `fpos64_t' since the LFS
     interface transparently replaces the old interface.

 -- Data Type: fpos64_t
     This is the type of an object that can encode information about the
     file position of a stream, for use by the functions `fgetpos64' and
     `fsetpos64'.

     In the GNU system, `fpos64_t' is an opaque data structure that
     contains internal data to represent file offset and conversion
     state information.  In other systems, it might have a different
     internal representation.

 -- Function: int fgetpos (FILE *STREAM, fpos_t *POSITION)
     This function stores the value of the file position indicator for
     the stream STREAM in the `fpos_t' object pointed to by POSITION.
     If successful, `fgetpos' returns zero; otherwise it returns a
     nonzero value and stores an implementation-defined positive value
     in `errno'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32 bit system the function is in fact `fgetpos64'.  I.e., the LFS
     interface transparently replaces the old interface.

 -- Function: int fgetpos64 (FILE *STREAM, fpos64_t *POSITION)
     This function is similar to `fgetpos' but the file position is
     returned in a variable of type `fpos64_t' to which POSITION points.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a 32
     bits machine this function is available under the name `fgetpos'
     and so transparently replaces the old interface.

 -- Function: int fsetpos (FILE *STREAM, const fpos_t *POSITION)
     This function sets the file position indicator for the stream
     STREAM to the position POSITION, which must have been set by a
     previous call to `fgetpos' on the same stream.  If successful,
     `fsetpos' clears the end-of-file indicator on the stream, discards
     any characters that were "pushed back" by the use of `ungetc', and
     returns a value of zero.  Otherwise, `fsetpos' returns a nonzero
     value and stores an implementation-defined positive value in
     `errno'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32 bit system the function is in fact `fsetpos64'.  I.e., the LFS
     interface transparently replaces the old interface.

 -- Function: int fsetpos64 (FILE *STREAM, const fpos64_t *POSITION)
     This function is similar to `fsetpos' but the file position used
     for positioning is provided in a variable of type `fpos64_t' to
     which POSITION points.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a 32
     bits machine this function is available under the name `fsetpos'
     and so transparently replaces the old interface.


File: libc.info,  Node: Stream Buffering,  Next: Other Kinds of Streams,  Prev: Portable Positioning,  Up: I/O on Streams

12.20 Stream Buffering
======================

Characters that are written to a stream are normally accumulated and
transmitted asynchronously to the file in a block, instead of appearing
as soon as they are output by the application program.  Similarly,
streams often retrieve input from the host environment in blocks rather
than on a character-by-character basis.  This is called "buffering".

   If you are writing programs that do interactive input and output
using streams, you need to understand how buffering works when you
design the user interface to your program.  Otherwise, you might find
that output (such as progress or prompt messages) doesn't appear when
you intended it to, or displays some other unexpected behavior.

   This section deals only with controlling when characters are
transmitted between the stream and the file or device, and _not_ with
how things like echoing, flow control, and the like are handled on
specific classes of devices.  For information on common control
operations on terminal devices, see *Note Low-Level Terminal
Interface::.

   You can bypass the stream buffering facilities altogether by using
the low-level input and output functions that operate on file
descriptors instead.  *Note Low-Level I/O::.

* Menu:

* Buffering Concepts::          Terminology is defined here.
* Flushing Buffers::            How to ensure that output buffers are flushed.
* Controlling Buffering::       How to specify what kind of buffering to use.


File: libc.info,  Node: Buffering Concepts,  Next: Flushing Buffers,  Up: Stream Buffering

12.20.1 Buffering Concepts
--------------------------

There are three different kinds of buffering strategies:

   * Characters written to or read from an "unbuffered" stream are
     transmitted individually to or from the file as soon as possible.  

   * Characters written to a "line buffered" stream are transmitted to
     the file in blocks when a newline character is encountered.  

   * Characters written to or read from a "fully buffered" stream are
     transmitted to or from the file in blocks of arbitrary size.  

   Newly opened streams are normally fully buffered, with one
exception: a stream connected to an interactive device such as a
terminal is initially line buffered.  *Note Controlling Buffering::,
for information on how to select a different kind of buffering.
Usually the automatic selection gives you the most convenient kind of
buffering for the file or device you open.

   The use of line buffering for interactive devices implies that output
messages ending in a newline will appear immediately--which is usually
what you want.  Output that doesn't end in a newline might or might not
show up immediately, so if you want them to appear immediately, you
should flush buffered output explicitly with `fflush', as described in
*Note Flushing Buffers::.


File: libc.info,  Node: Flushing Buffers,  Next: Controlling Buffering,  Prev: Buffering Concepts,  Up: Stream Buffering

12.20.2 Flushing Buffers
------------------------

"Flushing" output on a buffered stream means transmitting all
accumulated characters to the file.  There are many circumstances when
buffered output on a stream is flushed automatically:

   * When you try to do output and the output buffer is full.

   * When the stream is closed.  *Note Closing Streams::.

   * When the program terminates by calling `exit'.  *Note Normal
     Termination::.

   * When a newline is written, if the stream is line buffered.

   * Whenever an input operation on _any_ stream actually reads data
     from its file.

   If you want to flush the buffered output at another time, call
`fflush', which is declared in the header file `stdio.h'.  

 -- Function: int fflush (FILE *STREAM)
     This function causes any buffered output on STREAM to be delivered
     to the file.  If STREAM is a null pointer, then `fflush' causes
     buffered output on _all_ open output streams to be flushed.

     This function returns `EOF' if a write error occurs, or zero
     otherwise.

 -- Function: int fflush_unlocked (FILE *STREAM)
     The `fflush_unlocked' function is equivalent to the `fflush'
     function except that it does not implicitly lock the stream.

   The `fflush' function can be used to flush all streams currently
opened.  While this is useful in some situations it does often more than
necessary since it might be done in situations when terminal input is
required and the program wants to be sure that all output is visible on
the terminal.  But this means that only line buffered streams have to be
flushed.  Solaris introduced a function especially for this.  It was
always available in the GNU C library in some form but never officially
exported.

 -- Function: void _flushlbf (void)
     The `_flushlbf' function flushes all line buffered streams
     currently opened.

     This function is declared in the `stdio_ext.h' header.

   *Compatibility Note:* Some brain-damaged operating systems have been
known to be so thoroughly fixated on line-oriented input and output
that flushing a line buffered stream causes a newline to be written!
Fortunately, this "feature" seems to be becoming less common.  You do
not need to worry about this in the GNU system.

   In some situations it might be useful to not flush the output pending
for a stream but instead simply forget it.  If transmission is costly
and the output is not needed anymore this is valid reasoning.  In this
situation a non-standard function introduced in Solaris and available in
the GNU C library can be used.

 -- Function: void __fpurge (FILE *STREAM)
     The `__fpurge' function causes the buffer of the stream STREAM to
     be emptied.  If the stream is currently in read mode all input in
     the buffer is lost.  If the stream is in output mode the buffered
     output is not written to the device (or whatever other underlying
     storage) and the buffer the cleared.

     This function is declared in `stdio_ext.h'.


File: libc.info,  Node: Controlling Buffering,  Prev: Flushing Buffers,  Up: Stream Buffering

12.20.3 Controlling Which Kind of Buffering
-------------------------------------------

After opening a stream (but before any other operations have been
performed on it), you can explicitly specify what kind of buffering you
want it to have using the `setvbuf' function.  

   The facilities listed in this section are declared in the header
file `stdio.h'.  

 -- Function: int setvbuf (FILE *STREAM, char *BUF, int MODE, size_t
          SIZE)
     This function is used to specify that the stream STREAM should
     have the buffering mode MODE, which can be either `_IOFBF' (for
     full buffering), `_IOLBF' (for line buffering), or `_IONBF' (for
     unbuffered input/output).

     If you specify a null pointer as the BUF argument, then `setvbuf'
     allocates a buffer itself using `malloc'.  This buffer will be
     freed when you close the stream.

     Otherwise, BUF should be a character array that can hold at least
     SIZE characters.  You should not free the space for this array as
     long as the stream remains open and this array remains its buffer.
     You should usually either allocate it statically, or `malloc'
     (*note Unconstrained Allocation::) the buffer.  Using an automatic
     array is not a good idea unless you close the file before exiting
     the block that declares the array.

     While the array remains a stream buffer, the stream I/O functions
     will use the buffer for their internal purposes.  You shouldn't
     try to access the values in the array directly while the stream is
     using it for buffering.

     The `setvbuf' function returns zero on success, or a nonzero value
     if the value of MODE is not valid or if the request could not be
     honored.

 -- Macro: int _IOFBF
     The value of this macro is an integer constant expression that can
     be used as the MODE argument to the `setvbuf' function to specify
     that the stream should be fully buffered.

 -- Macro: int _IOLBF
     The value of this macro is an integer constant expression that can
     be used as the MODE argument to the `setvbuf' function to specify
     that the stream should be line buffered.

 -- Macro: int _IONBF
     The value of this macro is an integer constant expression that can
     be used as the MODE argument to the `setvbuf' function to specify
     that the stream should be unbuffered.

 -- Macro: int BUFSIZ
     The value of this macro is an integer constant expression that is
     good to use for the SIZE argument to `setvbuf'.  This value is
     guaranteed to be at least `256'.

     The value of `BUFSIZ' is chosen on each system so as to make stream
     I/O efficient.  So it is a good idea to use `BUFSIZ' as the size
     for the buffer when you call `setvbuf'.

     Actually, you can get an even better value to use for the buffer
     size by means of the `fstat' system call: it is found in the
     `st_blksize' field of the file attributes.  *Note Attribute
     Meanings::.

     Sometimes people also use `BUFSIZ' as the allocation size of
     buffers used for related purposes, such as strings used to receive
     a line of input with `fgets' (*note Character Input::).  There is
     no particular reason to use `BUFSIZ' for this instead of any other
     integer, except that it might lead to doing I/O in chunks of an
     efficient size.

 -- Function: void setbuf (FILE *STREAM, char *BUF)
     If BUF is a null pointer, the effect of this function is
     equivalent to calling `setvbuf' with a MODE argument of `_IONBF'.
     Otherwise, it is equivalent to calling `setvbuf' with BUF, and a
     MODE of `_IOFBF' and a SIZE argument of `BUFSIZ'.

     The `setbuf' function is provided for compatibility with old code;
     use `setvbuf' in all new programs.

 -- Function: void setbuffer (FILE *STREAM, char *BUF, size_t SIZE)
     If BUF is a null pointer, this function makes STREAM unbuffered.
     Otherwise, it makes STREAM fully buffered using BUF as the buffer.
     The SIZE argument specifies the length of BUF.

     This function is provided for compatibility with old BSD code.  Use
     `setvbuf' instead.

 -- Function: void setlinebuf (FILE *STREAM)
     This function makes STREAM be line buffered, and allocates the
     buffer for you.

     This function is provided for compatibility with old BSD code.  Use
     `setvbuf' instead.

   It is possible to query whether a given stream is line buffered or
not using a non-standard function introduced in Solaris and available
in the GNU C library.

 -- Function: int __flbf (FILE *STREAM)
     The `__flbf' function will return a nonzero value in case the
     stream STREAM is line buffered.  Otherwise the return value is
     zero.

     This function is declared in the `stdio_ext.h' header.

   Two more extensions allow to determine the size of the buffer and how
much of it is used.  These functions were also introduced in Solaris.

 -- Function: size_t __fbufsize (FILE *STREAM)
     The `__fbufsize' function return the size of the buffer in the
     stream STREAM.  This value can be used to optimize the use of the
     stream.

     This function is declared in the `stdio_ext.h' header.

 -- Function: size_t __fpending (FILE *STREAM) The `__fpending'
     function returns the number of bytes currently in the output
     buffer.  For wide-oriented stream the measuring unit is wide
     characters.  This function should not be used on buffers in read
     mode or opened read-only.

     This function is declared in the `stdio_ext.h' header.


File: libc.info,  Node: Other Kinds of Streams,  Next: Formatted Messages,  Prev: Stream Buffering,  Up: I/O on Streams

12.21 Other Kinds of Streams
============================

The GNU library provides ways for you to define additional kinds of
streams that do not necessarily correspond to an open file.

   One such type of stream takes input from or writes output to a
string.  These kinds of streams are used internally to implement the
`sprintf' and `sscanf' functions.  You can also create such a stream
explicitly, using the functions described in *Note String Streams::.

   More generally, you can define streams that do input/output to
arbitrary objects using functions supplied by your program.  This
protocol is discussed in *Note Custom Streams::.

   *Portability Note:* The facilities described in this section are
specific to GNU.  Other systems or C implementations might or might not
provide equivalent functionality.

* Menu:

* String Streams::              Streams that get data from or put data in
                                 a string or memory buffer.
* Obstack Streams::		Streams that store data in an obstack.
* Custom Streams::              Defining your own streams with an arbitrary
                                 input data source and/or output data sink.


File: libc.info,  Node: String Streams,  Next: Obstack Streams,  Up: Other Kinds of Streams

12.21.1 String Streams
----------------------

The `fmemopen' and `open_memstream' functions allow you to do I/O to a
string or memory buffer.  These facilities are declared in `stdio.h'.  

 -- Function: FILE * fmemopen (void *BUF, size_t SIZE, const char
          *OPENTYPE)
     This function opens a stream that allows the access specified by
     the OPENTYPE argument, that reads from or writes to the buffer
     specified by the argument BUF.  This array must be at least SIZE
     bytes long.

     If you specify a null pointer as the BUF argument, `fmemopen'
     dynamically allocates an array SIZE bytes long (as with `malloc';
     *note Unconstrained Allocation::).  This is really only useful if
     you are going to write things to the buffer and then read them back
     in again, because you have no way of actually getting a pointer to
     the buffer (for this, try `open_memstream', below).  The buffer is
     freed when the stream is closed.

     The argument OPENTYPE is the same as in `fopen' (*note Opening
     Streams::).  If the OPENTYPE specifies append mode, then the
     initial file position is set to the first null character in the
     buffer.  Otherwise the initial file position is at the beginning
     of the buffer.

     When a stream open for writing is flushed or closed, a null
     character (zero byte) is written at the end of the buffer if it
     fits.  You should add an extra byte to the SIZE argument to
     account for this.  Attempts to write more than SIZE bytes to the
     buffer result in an error.

     For a stream open for reading, null characters (zero bytes) in the
     buffer do not count as "end of file".  Read operations indicate
     end of file only when the file position advances past SIZE bytes.
     So, if you want to read characters from a null-terminated string,
     you should supply the length of the string as the SIZE argument.

   Here is an example of using `fmemopen' to create a stream for
reading from a string:

     #include <stdio.h>

     static char buffer[] = "foobar";

     int
     main (void)
     {
       int ch;
       FILE *stream;

       stream = fmemopen (buffer, strlen (buffer), "r");
       while ((ch = fgetc (stream)) != EOF)
         printf ("Got %c\n", ch);
       fclose (stream);

       return 0;
     }

   This program produces the following output:

     Got f
     Got o
     Got o
     Got b
     Got a
     Got r

 -- Function: FILE * open_memstream (char **PTR, size_t *SIZELOC)
     This function opens a stream for writing to a buffer.  The buffer
     is allocated dynamically and grown as necessary, using `malloc'.
     After you've closed the stream, this buffer is your responsibility
     to clean up using `free' or `realloc'.  *Note Unconstrained
     Allocation::.

     When the stream is closed with `fclose' or flushed with `fflush',
     the locations PTR and SIZELOC are updated to contain the pointer
     to the buffer and its size.  The values thus stored remain valid
     only as long as no further output on the stream takes place.  If
     you do more output, you must flush the stream again to store new
     values before you use them again.

     A null character is written at the end of the buffer.  This null
     character is _not_ included in the size value stored at SIZELOC.

     You can move the stream's file position with `fseek' or `fseeko'
     (*note File Positioning::).  Moving the file position past the end
     of the data already written fills the intervening space with
     zeroes.

   Here is an example of using `open_memstream':

     #include <stdio.h>

     int
     main (void)
     {
       char *bp;
       size_t size;
       FILE *stream;

       stream = open_memstream (&bp, &size);
       fprintf (stream, "hello");
       fflush (stream);
       printf ("buf = `%s', size = %d\n", bp, size);
       fprintf (stream, ", world");
       fclose (stream);
       printf ("buf = `%s', size = %d\n", bp, size);

       return 0;
     }

   This program produces the following output:

     buf = `hello', size = 5
     buf = `hello, world', size = 12


File: libc.info,  Node: Obstack Streams,  Next: Custom Streams,  Prev: String Streams,  Up: Other Kinds of Streams

12.21.2 Obstack Streams
-----------------------

You can open an output stream that puts it data in an obstack.  *Note
Obstacks::.

 -- Function: FILE * open_obstack_stream (struct obstack *OBSTACK)
     This function opens a stream for writing data into the obstack
     OBSTACK.  This starts an object in the obstack and makes it grow
     as data is written (*note Growing Objects::).

     Calling `fflush' on this stream updates the current size of the
     object to match the amount of data that has been written.  After a
     call to `fflush', you can examine the object temporarily.

     You can move the file position of an obstack stream with `fseek' or
     `fseeko' (*note File Positioning::).  Moving the file position past
     the end of the data written fills the intervening space with zeros.

     To make the object permanent, update the obstack with `fflush', and
     then use `obstack_finish' to finalize the object and get its
     address.  The following write to the stream starts a new object in
     the obstack, and later writes add to that object until you do
     another `fflush' and `obstack_finish'.

     But how do you find out how long the object is?  You can get the
     length in bytes by calling `obstack_object_size' (*note Status of
     an Obstack::), or you can null-terminate the object like this:

          obstack_1grow (OBSTACK, 0);

     Whichever one you do, you must do it _before_ calling
     `obstack_finish'.  (You can do both if you wish.)

   Here is a sample function that uses `open_obstack_stream':

     char *
     make_message_string (const char *a, int b)
     {
       FILE *stream = open_obstack_stream (&message_obstack);
       output_task (stream);
       fprintf (stream, ": ");
       fprintf (stream, a, b);
       fprintf (stream, "\n");
       fclose (stream);
       obstack_1grow (&message_obstack, 0);
       return obstack_finish (&message_obstack);
     }


File: libc.info,  Node: Custom Streams,  Prev: Obstack Streams,  Up: Other Kinds of Streams

12.21.3 Programming Your Own Custom Streams
-------------------------------------------

This section describes how you can make a stream that gets input from an
arbitrary data source or writes output to an arbitrary data sink
programmed by you.  We call these "custom streams".  The functions and
types described here are all GNU extensions.

* Menu:

* Streams and Cookies::         The "cookie" records where to fetch or
                                 store data that is read or written.
* Hook Functions::              How you should define the four "hook
                                 functions" that a custom stream needs.


File: libc.info,  Node: Streams and Cookies,  Next: Hook Functions,  Up: Custom Streams

12.21.3.1 Custom Streams and Cookies
....................................

Inside every custom stream is a special object called the "cookie".
This is an object supplied by you which records where to fetch or store
the data read or written.  It is up to you to define a data type to use
for the cookie.  The stream functions in the library never refer
directly to its contents, and they don't even know what the type is;
they record its address with type `void *'.

   To implement a custom stream, you must specify _how_ to fetch or
store the data in the specified place.  You do this by defining "hook
functions" to read, write, change "file position", and close the
stream.  All four of these functions will be passed the stream's cookie
so they can tell where to fetch or store the data.  The library
functions don't know what's inside the cookie, but your functions will
know.

   When you create a custom stream, you must specify the cookie pointer,
and also the four hook functions stored in a structure of type
`cookie_io_functions_t'.

   These facilities are declared in `stdio.h'.  

 -- Data Type: cookie_io_functions_t
     This is a structure type that holds the functions that define the
     communications protocol between the stream and its cookie.  It has
     the following members:

    `cookie_read_function_t *read'
          This is the function that reads data from the cookie.  If the
          value is a null pointer instead of a function, then read
          operations on this stream always return `EOF'.

    `cookie_write_function_t *write'
          This is the function that writes data to the cookie.  If the
          value is a null pointer instead of a function, then data
          written to the stream is discarded.

    `cookie_seek_function_t *seek'
          This is the function that performs the equivalent of file
          positioning on the cookie.  If the value is a null pointer
          instead of a function, calls to `fseek' or `fseeko' on this
          stream can only seek to locations within the buffer; any
          attempt to seek outside the buffer will return an `ESPIPE'
          error.

    `cookie_close_function_t *close'
          This function performs any appropriate cleanup on the cookie
          when closing the stream.  If the value is a null pointer
          instead of a function, nothing special is done to close the
          cookie when the stream is closed.

 -- Function: FILE * fopencookie (void *COOKIE, const char *OPENTYPE,
          cookie_io_functions_t IO-FUNCTIONS)
     This function actually creates the stream for communicating with
     the COOKIE using the functions in the IO-FUNCTIONS argument.  The
     OPENTYPE argument is interpreted as for `fopen'; see *Note Opening
     Streams::.  (But note that the "truncate on open" option is
     ignored.)  The new stream is fully buffered.

     The `fopencookie' function returns the newly created stream, or a
     null pointer in case of an error.


File: libc.info,  Node: Hook Functions,  Prev: Streams and Cookies,  Up: Custom Streams

12.21.3.2 Custom Stream Hook Functions
......................................

Here are more details on how you should define the four hook functions
that a custom stream needs.

   You should define the function to read data from the cookie as:

     ssize_t READER (void *COOKIE, char *BUFFER, size_t SIZE)

   This is very similar to the `read' function; see *Note I/O
Primitives::.  Your function should transfer up to SIZE bytes into the
BUFFER, and return the number of bytes read, or zero to indicate
end-of-file.  You can return a value of `-1' to indicate an error.

   You should define the function to write data to the cookie as:

     ssize_t WRITER (void *COOKIE, const char *BUFFER, size_t SIZE)

   This is very similar to the `write' function; see *Note I/O
Primitives::.  Your function should transfer up to SIZE bytes from the
buffer, and return the number of bytes written.  You can return a value
of `-1' to indicate an error.

   You should define the function to perform seek operations on the
cookie as:

     int SEEKER (void *COOKIE, off64_t *POSITION, int WHENCE)

   For this function, the POSITION and WHENCE arguments are interpreted
as for `fgetpos'; see *Note Portable Positioning::.

   After doing the seek operation, your function should store the
resulting file position relative to the beginning of the file in
POSITION.  Your function should return a value of `0' on success and
`-1' to indicate an error.

   You should define the function to do cleanup operations on the cookie
appropriate for closing the stream as:

     int CLEANER (void *COOKIE)

   Your function should return `-1' to indicate an error, and `0'
otherwise.

 -- Data Type: cookie_read_function
     This is the data type that the read function for a custom stream
     should have.  If you declare the function as shown above, this is
     the type it will have.

 -- Data Type: cookie_write_function
     The data type of the write function for a custom stream.

 -- Data Type: cookie_seek_function
     The data type of the seek function for a custom stream.

 -- Data Type: cookie_close_function
     The data type of the close function for a custom stream.


File: libc.info,  Node: Formatted Messages,  Prev: Other Kinds of Streams,  Up: I/O on Streams

12.22 Formatted Messages
========================

On systems which are based on System V messages of programs (especially
the system tools) are printed in a strict form using the `fmtmsg'
function.  The uniformity sometimes helps the user to interpret messages
and the strictness tests of the `fmtmsg' function ensure that the
programmer follows some minimal requirements.

* Menu:

* Printing Formatted Messages::   The `fmtmsg' function.
* Adding Severity Classes::       Add more severity classes.
* Example::                       How to use `fmtmsg' and `addseverity'.


File: libc.info,  Node: Printing Formatted Messages,  Next: Adding Severity Classes,  Up: Formatted Messages

12.22.1 Printing Formatted Messages
-----------------------------------

Messages can be printed to standard error and/or to the console.  To
select the destination the programmer can use the following two values,
bitwise OR combined if wanted, for the CLASSIFICATION parameter of
`fmtmsg':

`MM_PRINT'
     Display the message in standard error.

`MM_CONSOLE'
     Display the message on the system console.

   The erroneous piece of the system can be signalled by exactly one of
the following values which also is bitwise ORed with the CLASSIFICATION
parameter to `fmtmsg':

`MM_HARD'
     The source of the condition is some hardware.

`MM_SOFT'
     The source of the condition is some software.

`MM_FIRM'
     The source of the condition is some firmware.

   A third component of the CLASSIFICATION parameter to `fmtmsg' can
describe the part of the system which detects the problem.  This is
done by using exactly one of the following values:

`MM_APPL'
     The erroneous condition is detected by the application.

`MM_UTIL'
     The erroneous condition is detected by a utility.

`MM_OPSYS'
     The erroneous condition is detected by the operating system.

   A last component of CLASSIFICATION can signal the results of this
message.  Exactly one of the following values can be used:

`MM_RECOVER'
     It is a recoverable error.

`MM_NRECOV'
     It is a non-recoverable error.

 -- Function: int fmtmsg (long int CLASSIFICATION, const char *LABEL,
          int SEVERITY, const char *TEXT, const char *ACTION, const
          char *TAG)
     Display a message described by its parameters on the device(s)
     specified in the CLASSIFICATION parameter.  The LABEL parameter
     identifies the source of the message.  The string should consist
     of two colon separated parts where the first part has not more
     than 10 and the second part not more than 14 characters.  The TEXT
     parameter describes the condition of the error, the ACTION
     parameter possible steps to recover from the error and the TAG
     parameter is a reference to the online documentation where more
     information can be found.  It should contain the LABEL value and a
     unique identification number.

     Each of the parameters can be a special value which means this
     value is to be omitted.  The symbolic names for these values are:

    `MM_NULLLBL'
          Ignore LABEL parameter.

    `MM_NULLSEV'
          Ignore SEVERITY parameter.

    `MM_NULLMC'
          Ignore CLASSIFICATION parameter.  This implies that nothing is
          actually printed.

    `MM_NULLTXT'
          Ignore TEXT parameter.

    `MM_NULLACT'
          Ignore ACTION parameter.

    `MM_NULLTAG'
          Ignore TAG parameter.

     There is another way certain fields can be omitted from the output
     to standard error.  This is described below in the description of
     environment variables influencing the behavior.

     The SEVERITY parameter can have one of the values in the following
     table: 

    `MM_NOSEV'
          Nothing is printed, this value is the same as `MM_NULLSEV'.

    `MM_HALT'
          This value is printed as `HALT'.

    `MM_ERROR'
          This value is printed as `ERROR'.

    `MM_WARNING'
          This value is printed as `WARNING'.

    `MM_INFO'
          This value is printed as `INFO'.

     The numeric value of these five macros are between `0' and `4'.
     Using the environment variable `SEV_LEVEL' or using the
     `addseverity' function one can add more severity levels with their
     corresponding string to print.  This is described below (*note
     Adding Severity Classes::).

     If no parameter is ignored the output looks like this:

          LABEL: SEVERITY-STRING: TEXT
          TO FIX: ACTION TAG

     The colons, new line characters and the `TO FIX' string are
     inserted if necessary, i.e., if the corresponding parameter is not
     ignored.

     This function is specified in the X/Open Portability Guide.  It is
     also available on all systems derived from System V.

     The function returns the value `MM_OK' if no error occurred.  If
     only the printing to standard error failed, it returns `MM_NOMSG'.
     If printing to the console fails, it returns `MM_NOCON'.  If
     nothing is printed `MM_NOTOK' is returned.  Among situations where
     all outputs fail this last value is also returned if a parameter
     value is incorrect.

   There are two environment variables which influence the behavior of
`fmtmsg'.  The first is `MSGVERB'.  It is used to control the output
actually happening on standard error (_not_ the console output).  Each
of the five fields can explicitly be enabled.  To do this the user has
to put the `MSGVERB' variable with a format like the following in the
environment before calling the `fmtmsg' function the first time:

     MSGVERB=KEYWORD[:KEYWORD[:...]]

   Valid KEYWORDs are `label', `severity', `text', `action', and `tag'.
If the environment variable is not given or is the empty string, a not
supported keyword is given or the value is somehow else invalid, no
part of the message is masked out.

   The second environment variable which influences the behavior of
`fmtmsg' is `SEV_LEVEL'.  This variable and the change in the behavior
of `fmtmsg' is not specified in the X/Open Portability Guide.  It is
available in System V systems, though.  It can be used to introduce new
severity levels.  By default, only the five severity levels described
above are available.  Any other numeric value would make `fmtmsg' print
nothing.

   If the user puts `SEV_LEVEL' with a format like

     SEV_LEVEL=[DESCRIPTION[:DESCRIPTION[:...]]]

in the environment of the process before the first call to `fmtmsg',
where DESCRIPTION has a value of the form

     SEVERITY-KEYWORD,LEVEL,PRINTSTRING

   The SEVERITY-KEYWORD part is not used by `fmtmsg' but it has to be
present.  The LEVEL part is a string representation of a number.  The
numeric value must be a number greater than 4.  This value must be used
in the SEVERITY parameter of `fmtmsg' to select this class.  It is not
possible to overwrite any of the predefined classes.  The PRINTSTRING
is the string printed when a message of this class is processed by
`fmtmsg' (see above, `fmtsmg' does not print the numeric value but
instead the string representation).


File: libc.info,  Node: Adding Severity Classes,  Next: Example,  Prev: Printing Formatted Messages,  Up: Formatted Messages

12.22.2 Adding Severity Classes
-------------------------------

There is another possibility to introduce severity classes besides using
the environment variable `SEV_LEVEL'.  This simplifies the task of
introducing new classes in a running program.  One could use the
`setenv' or `putenv' function to set the environment variable, but this
is toilsome.

 -- Function: int addseverity (int SEVERITY, const char *STRING)
     This function allows the introduction of new severity classes
     which can be addressed by the SEVERITY parameter of the `fmtmsg'
     function.  The SEVERITY parameter of `addseverity' must match the
     value for the parameter with the same name of `fmtmsg', and STRING
     is the string printed in the actual messages instead of the numeric
     value.

     If STRING is `NULL' the severity class with the numeric value
     according to SEVERITY is removed.

     It is not possible to overwrite or remove one of the default
     severity classes.  All calls to `addseverity' with SEVERITY set to
     one of the values for the default classes will fail.

     The return value is `MM_OK' if the task was successfully performed.
     If the return value is `MM_NOTOK' something went wrong.  This could
     mean that no more memory is available or a class is not available
     when it has to be removed.

     This function is not specified in the X/Open Portability Guide
     although the `fmtsmg' function is.  It is available on System V
     systems.


File: libc.info,  Node: Example,  Prev: Adding Severity Classes,  Up: Formatted Messages

12.22.3 How to use `fmtmsg' and `addseverity'
---------------------------------------------

Here is a simple example program to illustrate the use of the both
functions described in this section.

     #include <fmtmsg.h>

     int
     main (void)
     {
       addseverity (5, "NOTE2");
       fmtmsg (MM_PRINT, "only1field", MM_INFO, "text2", "action2", "tag2");
       fmtmsg (MM_PRINT, "UX:cat", 5, "invalid syntax", "refer to manual",
               "UX:cat:001");
       fmtmsg (MM_PRINT, "label:foo", 6, "text", "action", "tag");
       return 0;
     }

   The second call to `fmtmsg' illustrates a use of this function as it
usually occurs on System V systems, which heavily use this function.
It seems worthwhile to give a short explanation here of how this system
works on System V.  The value of the LABEL field (`UX:cat') says that
the error occurred in the Unix program `cat'.  The explanation of the
error follows and the value for the ACTION parameter is `"refer to
manual"'.  One could be more specific here, if necessary.  The TAG
field contains, as proposed above, the value of the string given for
the LABEL parameter, and additionally a unique ID (`001' in this case).
For a GNU environment this string could contain a reference to the
corresponding node in the Info page for the program.

Running this program without specifying the `MSGVERB' and `SEV_LEVEL'
function produces the following output:

     UX:cat: NOTE2: invalid syntax
     TO FIX: refer to manual UX:cat:001

   We see the different fields of the message and how the extra glue
(the colons and the `TO FIX' string) are printed.  But only one of the
three calls to `fmtmsg' produced output.  The first call does not print
anything because the LABEL parameter is not in the correct form.  The
string must contain two fields, separated by a colon (*note Printing
Formatted Messages::).  The third `fmtmsg' call produced no output
since the class with the numeric value `6' is not defined.  Although a
class with numeric value `5' is also not defined by default, the call
to `addseverity' introduces it and the second call to `fmtmsg' produces
the above output.

   When we change the environment of the program to contain
`SEV_LEVEL=XXX,6,NOTE' when running it we get a different result:

     UX:cat: NOTE2: invalid syntax
     TO FIX: refer to manual UX:cat:001
     label:foo: NOTE: text
     TO FIX: action tag

   Now the third call to `fmtmsg' produced some output and we see how
the string `NOTE' from the environment variable appears in the message.

   Now we can reduce the output by specifying which fields we are
interested in.  If we additionally set the environment variable
`MSGVERB' to the value `severity:label:action' we get the following
output:

     UX:cat: NOTE2
     TO FIX: refer to manual
     label:foo: NOTE
     TO FIX: action

I.e., the output produced by the TEXT and the TAG parameters to
`fmtmsg' vanished.  Please also note that now there is no colon after
the `NOTE' and `NOTE2' strings in the output.  This is not necessary
since there is no more output on this line because the text is missing.


File: libc.info,  Node: Low-Level I/O,  Next: File System Interface,  Prev: I/O on Streams,  Up: Top

13 Low-Level Input/Output
*************************

This chapter describes functions for performing low-level input/output
operations on file descriptors.  These functions include the primitives
for the higher-level I/O functions described in *Note I/O on Streams::,
as well as functions for performing low-level control operations for
which there are no equivalents on streams.

   Stream-level I/O is more flexible and usually more convenient;
therefore, programmers generally use the descriptor-level functions only
when necessary.  These are some of the usual reasons:

   * For reading binary files in large chunks.

   * For reading an entire file into core before parsing it.

   * To perform operations other than data transfer, which can only be
     done with a descriptor.  (You can use `fileno' to get the
     descriptor corresponding to a stream.)

   * To pass descriptors to a child process.  (The child can create its
     own stream to use a descriptor that it inherits, but cannot
     inherit a stream directly.)

* Menu:

* Opening and Closing Files::           How to open and close file
                                         descriptors.
* I/O Primitives::                      Reading and writing data.
* File Position Primitive::             Setting a descriptor's file
                                         position.
* Descriptors and Streams::             Converting descriptor to stream
                                         or vice-versa.
* Stream/Descriptor Precautions::       Precautions needed if you use both
                                         descriptors and streams.
* Scatter-Gather::                      Fast I/O to discontinuous buffers.
* Memory-mapped I/O::                   Using files like memory.
* Waiting for I/O::                     How to check for input or output
					 on multiple file descriptors.
* Synchronizing I/O::                   Making sure all I/O actions completed.
* Asynchronous I/O::                    Perform I/O in parallel.
* Control Operations::                  Various other operations on file
					 descriptors.
* Duplicating Descriptors::             Fcntl commands for duplicating
                                         file descriptors.
* Descriptor Flags::                    Fcntl commands for manipulating
                                         flags associated with file
                                         descriptors.
* File Status Flags::                   Fcntl commands for manipulating
                                         flags associated with open files.
* File Locks::                          Fcntl commands for implementing
                                         file locking.
* Interrupt Input::                     Getting an asynchronous signal when
                                         input arrives.
* IOCTLs::                              Generic I/O Control operations.


File: libc.info,  Node: Opening and Closing Files,  Next: I/O Primitives,  Up: Low-Level I/O

13.1 Opening and Closing Files
==============================

This section describes the primitives for opening and closing files
using file descriptors.  The `open' and `creat' functions are declared
in the header file `fcntl.h', while `close' is declared in `unistd.h'.  

 -- Function: int open (const char *FILENAME, int FLAGS[, mode_t MODE])
     The `open' function creates and returns a new file descriptor for
     the file named by FILENAME.  Initially, the file position
     indicator for the file is at the beginning of the file.  The
     argument MODE is used only when a file is created, but it doesn't
     hurt to supply the argument in any case.

     The FLAGS argument controls how the file is to be opened.  This is
     a bit mask; you create the value by the bitwise OR of the
     appropriate parameters (using the `|' operator in C).  *Note File
     Status Flags::, for the parameters available.

     The normal return value from `open' is a non-negative integer file
     descriptor.  In the case of an error, a value of -1 is returned
     instead.  In addition to the usual file name errors (*note File
     Name Errors::), the following `errno' error conditions are defined
     for this function:

    `EACCES'
          The file exists but is not readable/writable as requested by
          the FLAGS argument, the file does not exist and the directory
          is unwritable so it cannot be created.

    `EEXIST'
          Both `O_CREAT' and `O_EXCL' are set, and the named file
          already exists.

    `EINTR'
          The `open' operation was interrupted by a signal.  *Note
          Interrupted Primitives::.

    `EISDIR'
          The FLAGS argument specified write access, and the file is a
          directory.

    `EMFILE'
          The process has too many files open.  The maximum number of
          file descriptors is controlled by the `RLIMIT_NOFILE'
          resource limit; *note Limits on Resources::.

    `ENFILE'
          The entire system, or perhaps the file system which contains
          the directory, cannot support any additional open files at
          the moment.  (This problem cannot happen on the GNU system.)

    `ENOENT'
          The named file does not exist, and `O_CREAT' is not specified.

    `ENOSPC'
          The directory or file system that would contain the new file
          cannot be extended, because there is no disk space left.

    `ENXIO'
          `O_NONBLOCK' and `O_WRONLY' are both set in the FLAGS
          argument, the file named by FILENAME is a FIFO (*note Pipes
          and FIFOs::), and no process has the file open for reading.

    `EROFS'
          The file resides on a read-only file system and any of
          `O_WRONLY', `O_RDWR', and `O_TRUNC' are set in the FLAGS
          argument, or `O_CREAT' is set and the file does not already
          exist.

     If on a 32 bit machine the sources are translated with
     `_FILE_OFFSET_BITS == 64' the function `open' returns a file
     descriptor opened in the large file mode which enables the file
     handling functions to use files up to 2^63 bytes in size and
     offset from -2^63 to 2^63.  This happens transparently for the user
     since all of the lowlevel file handling functions are equally
     replaced.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `open' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `open' should be protected using cancellation handlers.

     The `open' function is the underlying primitive for the `fopen'
     and `freopen' functions, that create streams.

 -- Function: int open64 (const char *FILENAME, int FLAGS[, mode_t
          MODE])
     This function is similar to `open'.  It returns a file descriptor
     which can be used to access the file named by FILENAME.  The only
     difference is that on 32 bit systems the file is opened in the
     large file mode.  I.e., file length and file offsets can exceed 31
     bits.

     When the sources are translated with `_FILE_OFFSET_BITS == 64' this
     function is actually available under the name `open'.  I.e., the
     new, extended API using 64 bit file sizes and offsets transparently
     replaces the old API.

 -- Obsolete function: int creat (const char *FILENAME, mode_t MODE)
     This function is obsolete.  The call:

          creat (FILENAME, MODE)

     is equivalent to:

          open (FILENAME, O_WRONLY | O_CREAT | O_TRUNC, MODE)

     If on a 32 bit machine the sources are translated with
     `_FILE_OFFSET_BITS == 64' the function `creat' returns a file
     descriptor opened in the large file mode which enables the file
     handling functions to use files up to 2^63 in size and offset from
     -2^63 to 2^63.  This happens transparently for the user since all
     of the lowlevel file handling functions are equally replaced.

 -- Obsolete function: int creat64 (const char *FILENAME, mode_t MODE)
     This function is similar to `creat'.  It returns a file descriptor
     which can be used to access the file named by FILENAME.  The only
     the difference is that on 32 bit systems the file is opened in the
     large file mode.  I.e., file length and file offsets can exceed 31
     bits.

     To use this file descriptor one must not use the normal operations
     but instead the counterparts named `*64', e.g., `read64'.

     When the sources are translated with `_FILE_OFFSET_BITS == 64' this
     function is actually available under the name `open'.  I.e., the
     new, extended API using 64 bit file sizes and offsets transparently
     replaces the old API.

 -- Function: int close (int FILEDES)
     The function `close' closes the file descriptor FILEDES.  Closing
     a file has the following consequences:

        * The file descriptor is deallocated.

        * Any record locks owned by the process on the file are
          unlocked.

        * When all file descriptors associated with a pipe or FIFO have
          been closed, any unread data is discarded.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `close' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this, calls to
     `close' should be protected using cancellation handlers.

     The normal return value from `close' is 0; a value of -1 is
     returned in case of failure.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINTR'
          The `close' call was interrupted by a signal.  *Note
          Interrupted Primitives::.  Here is an example of how to
          handle `EINTR' properly:

               TEMP_FAILURE_RETRY (close (desc));

    `ENOSPC'
    `EIO'
    `EDQUOT'
          When the file is accessed by NFS, these errors from `write'
          can sometimes not be detected until `close'.  *Note I/O
          Primitives::, for details on their meaning.

     Please note that there is _no_ separate `close64' function.  This
     is not necessary since this function does not determine nor depend
     on the mode of the file.  The kernel which performs the `close'
     operation knows which mode the descriptor is used for and can
     handle this situation.

   To close a stream, call `fclose' (*note Closing Streams::) instead
of trying to close its underlying file descriptor with `close'.  This
flushes any buffered output and updates the stream object to indicate
that it is closed.


File: libc.info,  Node: I/O Primitives,  Next: File Position Primitive,  Prev: Opening and Closing Files,  Up: Low-Level I/O

13.2 Input and Output Primitives
================================

This section describes the functions for performing primitive input and
output operations on file descriptors: `read', `write', and `lseek'.
These functions are declared in the header file `unistd.h'.  

 -- Data Type: ssize_t
     This data type is used to represent the sizes of blocks that can be
     read or written in a single operation.  It is similar to `size_t',
     but must be a signed type.

 -- Function: ssize_t read (int FILEDES, void *BUFFER, size_t SIZE)
     The `read' function reads up to SIZE bytes from the file with
     descriptor FILEDES, storing the results in the BUFFER.  (This is
     not necessarily a character string, and no terminating null
     character is added.)

     The return value is the number of bytes actually read.  This might
     be less than SIZE; for example, if there aren't that many bytes
     left in the file or if there aren't that many bytes immediately
     available.  The exact behavior depends on what kind of file it is.
     Note that reading less than SIZE bytes is not an error.

     A value of zero indicates end-of-file (except if the value of the
     SIZE argument is also zero).  This is not considered an error.  If
     you keep calling `read' while at end-of-file, it will keep
     returning zero and doing nothing else.

     If `read' returns at least one character, there is no way you can
     tell whether end-of-file was reached.  But if you did reach the
     end, the next read will return zero.

     In case of an error, `read' returns -1.  The following `errno'
     error conditions are defined for this function:

    `EAGAIN'
          Normally, when no input is immediately available, `read'
          waits for some input.  But if the `O_NONBLOCK' flag is set
          for the file (*note File Status Flags::), `read' returns
          immediately without reading any data, and reports this error.

          *Compatibility Note:* Most versions of BSD Unix use a
          different error code for this: `EWOULDBLOCK'.  In the GNU
          library, `EWOULDBLOCK' is an alias for `EAGAIN', so it
          doesn't matter which name you use.

          On some systems, reading a large amount of data from a
          character special file can also fail with `EAGAIN' if the
          kernel cannot find enough physical memory to lock down the
          user's pages.  This is limited to devices that transfer with
          direct memory access into the user's memory, which means it
          does not include terminals, since they always use separate
          buffers inside the kernel.  This problem never happens in the
          GNU system.

          Any condition that could result in `EAGAIN' can instead
          result in a successful `read' which returns fewer bytes than
          requested.  Calling `read' again immediately would result in
          `EAGAIN'.

    `EBADF'
          The FILEDES argument is not a valid file descriptor, or is
          not open for reading.

    `EINTR'
          `read' was interrupted by a signal while it was waiting for
          input.  *Note Interrupted Primitives::.  A signal will not
          necessary cause `read' to return `EINTR'; it may instead
          result in a successful `read' which returns fewer bytes than
          requested.

    `EIO'
          For many devices, and for disk files, this error code
          indicates a hardware error.

          `EIO' also occurs when a background process tries to read
          from the controlling terminal, and the normal action of
          stopping the process by sending it a `SIGTTIN' signal isn't
          working.  This might happen if the signal is being blocked or
          ignored, or because the process group is orphaned.  *Note Job
          Control::, for more information about job control, and *Note
          Signal Handling::, for information about signals.

    `EINVAL'
          In some systems, when reading from a character or block
          device, position and size offsets must be aligned to a
          particular block size.  This error indicates that the offsets
          were not properly aligned.

     Please note that there is no function named `read64'.  This is not
     necessary since this function does not directly modify or handle
     the possibly wide file offset.  Since the kernel handles this state
     internally, the `read' function can be used for all cases.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `read' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this, calls to
     `read' should be protected using cancellation handlers.

     The `read' function is the underlying primitive for all of the
     functions that read from streams, such as `fgetc'.

 -- Function: ssize_t pread (int FILEDES, void *BUFFER, size_t SIZE,
          off_t OFFSET)
     The `pread' function is similar to the `read' function.  The first
     three arguments are identical, and the return values and error
     codes also correspond.

     The difference is the fourth argument and its handling.  The data
     block is not read from the current position of the file descriptor
     `filedes'.  Instead the data is read from the file starting at
     position OFFSET.  The position of the file descriptor itself is
     not affected by the operation.  The value is the same as before
     the call.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' the
     `pread' function is in fact `pread64' and the type `off_t' has 64
     bits, which makes it possible to handle files up to 2^63 bytes in
     length.

     The return value of `pread' describes the number of bytes read.
     In the error case it returns -1 like `read' does and the error
     codes are also the same, with these additions:

    `EINVAL'
          The value given for OFFSET is negative and therefore illegal.

    `ESPIPE'
          The file descriptor FILEDES is associate with a pipe or a
          FIFO and this device does not allow positioning of the file
          pointer.

     The function is an extension defined in the Unix Single
     Specification version 2.

 -- Function: ssize_t pread64 (int FILEDES, void *BUFFER, size_t SIZE,
          off64_t OFFSET)
     This function is similar to the `pread' function.  The difference
     is that the OFFSET parameter is of type `off64_t' instead of
     `off_t' which makes it possible on 32 bit machines to address
     files larger than 2^31 bytes and up to 2^63 bytes.  The file
     descriptor `filedes' must be opened using `open64' since otherwise
     the large offsets possible with `off64_t' will lead to errors with
     a descriptor in small file mode.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' on
     a 32 bit machine this function is actually available under the name
     `pread' and so transparently replaces the 32 bit interface.

 -- Function: ssize_t write (int FILEDES, const void *BUFFER, size_t
          SIZE)
     The `write' function writes up to SIZE bytes from BUFFER to the
     file with descriptor FILEDES.  The data in BUFFER is not
     necessarily a character string and a null character is output like
     any other character.

     The return value is the number of bytes actually written.  This
     may be SIZE, but can always be smaller.  Your program should
     always call `write' in a loop, iterating until all the data is
     written.

     Once `write' returns, the data is enqueued to be written and can be
     read back right away, but it is not necessarily written out to
     permanent storage immediately.  You can use `fsync' when you need
     to be sure your data has been permanently stored before
     continuing.  (It is more efficient for the system to batch up
     consecutive writes and do them all at once when convenient.
     Normally they will always be written to disk within a minute or
     less.)  Modern systems provide another function `fdatasync' which
     guarantees integrity only for the file data and is therefore
     faster.  You can use the `O_FSYNC' open mode to make `write' always
     store the data to disk before returning; *note Operating Modes::.

     In the case of an error, `write' returns -1.  The following
     `errno' error conditions are defined for this function:

    `EAGAIN'
          Normally, `write' blocks until the write operation is
          complete.  But if the `O_NONBLOCK' flag is set for the file
          (*note Control Operations::), it returns immediately without
          writing any data and reports this error.  An example of a
          situation that might cause the process to block on output is
          writing to a terminal device that supports flow control,
          where output has been suspended by receipt of a STOP
          character.

          *Compatibility Note:* Most versions of BSD Unix use a
          different error code for this: `EWOULDBLOCK'.  In the GNU
          library, `EWOULDBLOCK' is an alias for `EAGAIN', so it
          doesn't matter which name you use.

          On some systems, writing a large amount of data from a
          character special file can also fail with `EAGAIN' if the
          kernel cannot find enough physical memory to lock down the
          user's pages.  This is limited to devices that transfer with
          direct memory access into the user's memory, which means it
          does not include terminals, since they always use separate
          buffers inside the kernel.  This problem does not arise in the
          GNU system.

    `EBADF'
          The FILEDES argument is not a valid file descriptor, or is
          not open for writing.

    `EFBIG'
          The size of the file would become larger than the
          implementation can support.

    `EINTR'
          The `write' operation was interrupted by a signal while it was
          blocked waiting for completion.  A signal will not
          necessarily cause `write' to return `EINTR'; it may instead
          result in a successful `write' which writes fewer bytes than
          requested.  *Note Interrupted Primitives::.

    `EIO'
          For many devices, and for disk files, this error code
          indicates a hardware error.

    `ENOSPC'
          The device containing the file is full.

    `EPIPE'
          This error is returned when you try to write to a pipe or
          FIFO that isn't open for reading by any process.  When this
          happens, a `SIGPIPE' signal is also sent to the process; see
          *Note Signal Handling::.

    `EINVAL'
          In some systems, when writing to a character or block device,
          position and size offsets must be aligned to a particular
          block size.  This error indicates that the offsets were not
          properly aligned.

     Unless you have arranged to prevent `EINTR' failures, you should
     check `errno' after each failing call to `write', and if the error
     was `EINTR', you should simply repeat the call.  *Note Interrupted
     Primitives::.  The easy way to do this is with the macro
     `TEMP_FAILURE_RETRY', as follows:

          nbytes = TEMP_FAILURE_RETRY (write (desc, buffer, count));

     Please note that there is no function named `write64'.  This is not
     necessary since this function does not directly modify or handle
     the possibly wide file offset.  Since the kernel handles this state
     internally the `write' function can be used for all cases.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `write' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this, calls to
     `write' should be protected using cancellation handlers.

     The `write' function is the underlying primitive for all of the
     functions that write to streams, such as `fputc'.

 -- Function: ssize_t pwrite (int FILEDES, const void *BUFFER, size_t
          SIZE, off_t OFFSET)
     The `pwrite' function is similar to the `write' function.  The
     first three arguments are identical, and the return values and
     error codes also correspond.

     The difference is the fourth argument and its handling.  The data
     block is not written to the current position of the file descriptor
     `filedes'.  Instead the data is written to the file starting at
     position OFFSET.  The position of the file descriptor itself is
     not affected by the operation.  The value is the same as before
     the call.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' the
     `pwrite' function is in fact `pwrite64' and the type `off_t' has
     64 bits, which makes it possible to handle files up to 2^63 bytes
     in length.

     The return value of `pwrite' describes the number of written bytes.
     In the error case it returns -1 like `write' does and the error
     codes are also the same, with these additions:

    `EINVAL'
          The value given for OFFSET is negative and therefore illegal.

    `ESPIPE'
          The file descriptor FILEDES is associated with a pipe or a
          FIFO and this device does not allow positioning of the file
          pointer.

     The function is an extension defined in the Unix Single
     Specification version 2.

 -- Function: ssize_t pwrite64 (int FILEDES, const void *BUFFER, size_t
          SIZE, off64_t OFFSET)
     This function is similar to the `pwrite' function.  The difference
     is that the OFFSET parameter is of type `off64_t' instead of
     `off_t' which makes it possible on 32 bit machines to address
     files larger than 2^31 bytes and up to 2^63 bytes.  The file
     descriptor `filedes' must be opened using `open64' since otherwise
     the large offsets possible with `off64_t' will lead to errors with
     a descriptor in small file mode.

     When the source file is compiled using `_FILE_OFFSET_BITS == 64'
     on a 32 bit machine this function is actually available under the
     name `pwrite' and so transparently replaces the 32 bit interface.


File: libc.info,  Node: File Position Primitive,  Next: Descriptors and Streams,  Prev: I/O Primitives,  Up: Low-Level I/O

13.3 Setting the File Position of a Descriptor
==============================================

Just as you can set the file position of a stream with `fseek', you can
set the file position of a descriptor with `lseek'.  This specifies the
position in the file for the next `read' or `write' operation.  *Note
File Positioning::, for more information on the file position and what
it means.

   To read the current file position value from a descriptor, use
`lseek (DESC, 0, SEEK_CUR)'.

 -- Function: off_t lseek (int FILEDES, off_t OFFSET, int WHENCE)
     The `lseek' function is used to change the file position of the
     file with descriptor FILEDES.

     The WHENCE argument specifies how the OFFSET should be
     interpreted, in the same way as for the `fseek' function, and it
     must be one of the symbolic constants `SEEK_SET', `SEEK_CUR', or
     `SEEK_END'.

    `SEEK_SET'
          Specifies that WHENCE is a count of characters from the
          beginning of the file.

    `SEEK_CUR'
          Specifies that WHENCE is a count of characters from the
          current file position.  This count may be positive or
          negative.

    `SEEK_END'
          Specifies that WHENCE is a count of characters from the end of
          the file.  A negative count specifies a position within the
          current extent of the file; a positive count specifies a
          position past the current end.  If you set the position past
          the current end, and actually write data, you will extend the
          file with zeros up to that position.

     The return value from `lseek' is normally the resulting file
     position, measured in bytes from the beginning of the file.  You
     can use this feature together with `SEEK_CUR' to read the current
     file position.

     If you want to append to the file, setting the file position to the
     current end of file with `SEEK_END' is not sufficient.  Another
     process may write more data after you seek but before you write,
     extending the file so the position you write onto clobbers their
     data.  Instead, use the `O_APPEND' operating mode; *note Operating
     Modes::.

     You can set the file position past the current end of the file.
     This does not by itself make the file longer; `lseek' never
     changes the file.  But subsequent output at that position will
     extend the file.  Characters between the previous end of file and
     the new position are filled with zeros.  Extending the file in
     this way can create a "hole": the blocks of zeros are not actually
     allocated on disk, so the file takes up less space than it appears
     to; it is then called a "sparse file".  

     If the file position cannot be changed, or the operation is in
     some way invalid, `lseek' returns a value of -1.  The following
     `errno' error conditions are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `EINVAL'
          The WHENCE argument value is not valid, or the resulting file
          offset is not valid.  A file offset is invalid.

    `ESPIPE'
          The FILEDES corresponds to an object that cannot be
          positioned, such as a pipe, FIFO or terminal device.
          (POSIX.1 specifies this error only for pipes and FIFOs, but
          in the GNU system, you always get `ESPIPE' if the object is
          not seekable.)

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' the
     `lseek' function is in fact `lseek64' and the type `off_t' has 64
     bits which makes it possible to handle files up to 2^63 bytes in
     length.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `lseek' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `lseek' should be protected using cancellation handlers.

     The `lseek' function is the underlying primitive for the `fseek',
     `fseeko', `ftell', `ftello' and `rewind' functions, which operate
     on streams instead of file descriptors.

 -- Function: off64_t lseek64 (int FILEDES, off64_t OFFSET, int WHENCE)
     This function is similar to the `lseek' function.  The difference
     is that the OFFSET parameter is of type `off64_t' instead of
     `off_t' which makes it possible on 32 bit machines to address
     files larger than 2^31 bytes and up to 2^63 bytes.  The file
     descriptor `filedes' must be opened using `open64' since otherwise
     the large offsets possible with `off64_t' will lead to errors with
     a descriptor in small file mode.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' on
     a 32 bits machine this function is actually available under the
     name `lseek' and so transparently replaces the 32 bit interface.

   You can have multiple descriptors for the same file if you open the
file more than once, or if you duplicate a descriptor with `dup'.
Descriptors that come from separate calls to `open' have independent
file positions; using `lseek' on one descriptor has no effect on the
other.  For example,

     {
       int d1, d2;
       char buf[4];
       d1 = open ("foo", O_RDONLY);
       d2 = open ("foo", O_RDONLY);
       lseek (d1, 1024, SEEK_SET);
       read (d2, buf, 4);
     }

will read the first four characters of the file `foo'.  (The
error-checking code necessary for a real program has been omitted here
for brevity.)

   By contrast, descriptors made by duplication share a common file
position with the original descriptor that was duplicated.  Anything
which alters the file position of one of the duplicates, including
reading or writing data, affects all of them alike.  Thus, for example,

     {
       int d1, d2, d3;
       char buf1[4], buf2[4];
       d1 = open ("foo", O_RDONLY);
       d2 = dup (d1);
       d3 = dup (d2);
       lseek (d3, 1024, SEEK_SET);
       read (d1, buf1, 4);
       read (d2, buf2, 4);
     }

will read four characters starting with the 1024'th character of `foo',
and then four more characters starting with the 1028'th character.

 -- Data Type: off_t
     This is an arithmetic data type used to represent file sizes.  In
     the GNU system, this is equivalent to `fpos_t' or `long int'.

     If the source is compiled with `_FILE_OFFSET_BITS == 64' this type
     is transparently replaced by `off64_t'.

 -- Data Type: off64_t
     This type is used similar to `off_t'.  The difference is that even
     on 32 bit machines, where the `off_t' type would have 32 bits,
     `off64_t' has 64 bits and so is able to address files up to 2^63
     bytes in length.

     When compiling with `_FILE_OFFSET_BITS == 64' this type is
     available under the name `off_t'.

   These aliases for the `SEEK_...' constants exist for the sake of
compatibility with older BSD systems.  They are defined in two
different header files: `fcntl.h' and `sys/file.h'.

`L_SET'
     An alias for `SEEK_SET'.

`L_INCR'
     An alias for `SEEK_CUR'.

`L_XTND'
     An alias for `SEEK_END'.


File: libc.info,  Node: Descriptors and Streams,  Next: Stream/Descriptor Precautions,  Prev: File Position Primitive,  Up: Low-Level I/O

13.4 Descriptors and Streams
============================

Given an open file descriptor, you can create a stream for it with the
`fdopen' function.  You can get the underlying file descriptor for an
existing stream with the `fileno' function.  These functions are
declared in the header file `stdio.h'.  

 -- Function: FILE * fdopen (int FILEDES, const char *OPENTYPE)
     The `fdopen' function returns a new stream for the file descriptor
     FILEDES.

     The OPENTYPE argument is interpreted in the same way as for the
     `fopen' function (*note Opening Streams::), except that the `b'
     option is not permitted; this is because GNU makes no distinction
     between text and binary files.  Also, `"w"' and `"w+"' do not
     cause truncation of the file; these have an effect only when
     opening a file, and in this case the file has already been opened.
     You must make sure that the OPENTYPE argument matches the actual
     mode of the open file descriptor.

     The return value is the new stream.  If the stream cannot be
     created (for example, if the modes for the file indicated by the
     file descriptor do not permit the access specified by the OPENTYPE
     argument), a null pointer is returned instead.

     In some other systems, `fdopen' may fail to detect that the modes
     for file descriptor do not permit the access specified by
     `opentype'.  The GNU C library always checks for this.

   For an example showing the use of the `fdopen' function, see *Note
Creating a Pipe::.

 -- Function: int fileno (FILE *STREAM)
     This function returns the file descriptor associated with the
     stream STREAM.  If an error is detected (for example, if the STREAM
     is not valid) or if STREAM does not do I/O to a file, `fileno'
     returns -1.

 -- Function: int fileno_unlocked (FILE *STREAM)
     The `fileno_unlocked' function is equivalent to the `fileno'
     function except that it does not implicitly lock the stream if the
     state is `FSETLOCKING_INTERNAL'.

     This function is a GNU extension.

   There are also symbolic constants defined in `unistd.h' for the file
descriptors belonging to the standard streams `stdin', `stdout', and
`stderr'; see *Note Standard Streams::.  

`STDIN_FILENO'
     This macro has value `0', which is the file descriptor for
     standard input.  

`STDOUT_FILENO'
     This macro has value `1', which is the file descriptor for
     standard output.  

`STDERR_FILENO'
     This macro has value `2', which is the file descriptor for
     standard error output.
   

File: libc.info,  Node: Stream/Descriptor Precautions,  Next: Scatter-Gather,  Prev: Descriptors and Streams,  Up: Low-Level I/O

13.5 Dangers of Mixing Streams and Descriptors
==============================================

You can have multiple file descriptors and streams (let's call both
streams and descriptors "channels" for short) connected to the same
file, but you must take care to avoid confusion between channels.  There
are two cases to consider: "linked" channels that share a single file
position value, and "independent" channels that have their own file
positions.

   It's best to use just one channel in your program for actual data
transfer to any given file, except when all the access is for input.
For example, if you open a pipe (something you can only do at the file
descriptor level), either do all I/O with the descriptor, or construct a
stream from the descriptor with `fdopen' and then do all I/O with the
stream.

* Menu:

* Linked Channels::	   Dealing with channels sharing a file position.
* Independent Channels::   Dealing with separately opened, unlinked channels.
* Cleaning Streams::	   Cleaning a stream makes it safe to use
                            another channel.


File: libc.info,  Node: Linked Channels,  Next: Independent Channels,  Up: Stream/Descriptor Precautions

13.5.1 Linked Channels
----------------------

Channels that come from a single opening share the same file position;
we call them "linked" channels.  Linked channels result when you make a
stream from a descriptor using `fdopen', when you get a descriptor from
a stream with `fileno', when you copy a descriptor with `dup' or
`dup2', and when descriptors are inherited during `fork'.  For files
that don't support random access, such as terminals and pipes, _all_
channels are effectively linked.  On random-access files, all
append-type output streams are effectively linked to each other.

   If you have been using a stream for I/O (or have just opened the
stream), and you want to do I/O using another channel (either a stream
or a descriptor) that is linked to it, you must first "clean up" the
stream that you have been using.  *Note Cleaning Streams::.

   Terminating a process, or executing a new program in the process,
destroys all the streams in the process.  If descriptors linked to these
streams persist in other processes, their file positions become
undefined as a result.  To prevent this, you must clean up the streams
before destroying them.


File: libc.info,  Node: Independent Channels,  Next: Cleaning Streams,  Prev: Linked Channels,  Up: Stream/Descriptor Precautions

13.5.2 Independent Channels
---------------------------

When you open channels (streams or descriptors) separately on a seekable
file, each channel has its own file position.  These are called
"independent channels".

   The system handles each channel independently.  Most of the time,
this is quite predictable and natural (especially for input): each
channel can read or write sequentially at its own place in the file.
However, if some of the channels are streams, you must take these
precautions:

   * You should clean an output stream after use, before doing anything
     else that might read or write from the same part of the file.

   * You should clean an input stream before reading data that may have
     been modified using an independent channel.  Otherwise, you might
     read obsolete data that had been in the stream's buffer.

   If you do output to one channel at the end of the file, this will
certainly leave the other independent channels positioned somewhere
before the new end.  You cannot reliably set their file positions to the
new end of file before writing, because the file can always be extended
by another process between when you set the file position and when you
write the data.  Instead, use an append-type descriptor or stream; they
always output at the current end of the file.  In order to make the
end-of-file position accurate, you must clean the output channel you
were using, if it is a stream.

   It's impossible for two channels to have separate file pointers for a
file that doesn't support random access.  Thus, channels for reading or
writing such files are always linked, never independent.  Append-type
channels are also always linked.  For these channels, follow the rules
for linked channels; see *Note Linked Channels::.


File: libc.info,  Node: Cleaning Streams,  Prev: Independent Channels,  Up: Stream/Descriptor Precautions

13.5.3 Cleaning Streams
-----------------------

On the GNU system, you can clean up any stream with `fclean':

 -- Function: int fclean (FILE *STREAM)
     Clean up the stream STREAM so that its buffer is empty.  If STREAM
     is doing output, force it out.  If STREAM is doing input, give the
     data in the buffer back to the system, arranging to reread it.

   On other systems, you can use `fflush' to clean a stream in most
cases.

   You can skip the `fclean' or `fflush' if you know the stream is
already clean.  A stream is clean whenever its buffer is empty.  For
example, an unbuffered stream is always clean.  An input stream that is
at end-of-file is clean.  A line-buffered stream is clean when the last
character output was a newline.  However, a just-opened input stream
might not be clean, as its input buffer might not be empty.

   There is one case in which cleaning a stream is impossible on most
systems.  This is when the stream is doing input from a file that is not
random-access.  Such streams typically read ahead, and when the file is
not random access, there is no way to give back the excess data already
read.  When an input stream reads from a random-access file, `fflush'
does clean the stream, but leaves the file pointer at an unpredictable
place; you must set the file pointer before doing any further I/O.  On
the GNU system, using `fclean' avoids both of these problems.

   Closing an output-only stream also does `fflush', so this is a valid
way of cleaning an output stream.  On the GNU system, closing an input
stream does `fclean'.

   You need not clean a stream before using its descriptor for control
operations such as setting terminal modes; these operations don't affect
the file position and are not affected by it.  You can use any
descriptor for these operations, and all channels are affected
simultaneously.  However, text already "output" to a stream but still
buffered by the stream will be subject to the new terminal modes when
subsequently flushed.  To make sure "past" output is covered by the
terminal settings that were in effect at the time, flush the output
streams for that terminal before setting the modes.  *Note Terminal
Modes::.


File: libc.info,  Node: Scatter-Gather,  Next: Memory-mapped I/O,  Prev: Stream/Descriptor Precautions,  Up: Low-Level I/O

13.6 Fast Scatter-Gather I/O
============================

Some applications may need to read or write data to multiple buffers,
which are separated in memory.  Although this can be done easily enough
with multiple calls to `read' and `write', it is inefficient because
there is overhead associated with each kernel call.

   Instead, many platforms provide special high-speed primitives to
perform these "scatter-gather" operations in a single kernel call.  The
GNU C library will provide an emulation on any system that lacks these
primitives, so they are not a portability threat.  They are defined in
`sys/uio.h'.

   These functions are controlled with arrays of `iovec' structures,
which describe the location and size of each buffer.

 -- Data Type: struct iovec
     The `iovec' structure describes a buffer. It contains two fields:

    `void *iov_base'
          Contains the address of a buffer.

    `size_t iov_len'
          Contains the length of the buffer.


 -- Function: ssize_t readv (int FILEDES, const struct iovec *VECTOR,
          int COUNT)
     The `readv' function reads data from FILEDES and scatters it into
     the buffers described in VECTOR, which is taken to be COUNT
     structures long.  As each buffer is filled, data is sent to the
     next.

     Note that `readv' is not guaranteed to fill all the buffers.  It
     may stop at any point, for the same reasons `read' would.

     The return value is a count of bytes (_not_ buffers) read, 0
     indicating end-of-file, or -1 indicating an error.  The possible
     errors are the same as in `read'.


 -- Function: ssize_t writev (int FILEDES, const struct iovec *VECTOR,
          int COUNT)
     The `writev' function gathers data from the buffers described in
     VECTOR, which is taken to be COUNT structures long, and writes
     them to `filedes'.  As each buffer is written, it moves on to the
     next.

     Like `readv', `writev' may stop midstream under the same
     conditions `write' would.

     The return value is a count of bytes written, or -1 indicating an
     error.  The possible errors are the same as in `write'.


   Note that if the buffers are small (under about 1kB), high-level
streams may be easier to use than these functions.  However, `readv' and
`writev' are more efficient when the individual buffers themselves (as
opposed to the total output), are large.  In that case, a high-level
stream would not be able to cache the data effectively.


File: libc.info,  Node: Memory-mapped I/O,  Next: Waiting for I/O,  Prev: Scatter-Gather,  Up: Low-Level I/O

13.7 Memory-mapped I/O
======================

On modern operating systems, it is possible to "mmap" (pronounced
"em-map") a file to a region of memory.  When this is done, the file can
be accessed just like an array in the program.

   This is more efficient than `read' or `write', as only the regions
of the file that a program actually accesses are loaded.  Accesses to
not-yet-loaded parts of the mmapped region are handled in the same way
as swapped out pages.

   Since mmapped pages can be stored back to their file when physical
memory is low, it is possible to mmap files orders of magnitude larger
than both the physical memory _and_ swap space.  The only limit is
address space.  The theoretical limit is 4GB on a 32-bit machine -
however, the actual limit will be smaller since some areas will be
reserved for other purposes.  If the LFS interface is used the file size
on 32-bit systems is not limited to 2GB (offsets are signed which
reduces the addressable area of 4GB by half); the full 64-bit are
available.

   Memory mapping only works on entire pages of memory.  Thus, addresses
for mapping must be page-aligned, and length values will be rounded up.
To determine the size of a page the machine uses one should use

     size_t page_size = (size_t) sysconf (_SC_PAGESIZE);

These functions are declared in `sys/mman.h'.

 -- Function: void * mmap (void *ADDRESS, size_t LENGTH,int PROTECT,
          int FLAGS, int FILEDES, off_t OFFSET)
     The `mmap' function creates a new mapping, connected to bytes
     (OFFSET) to (OFFSET + LENGTH - 1) in the file open on FILEDES.  A
     new reference for the file specified by FILEDES is created, which
     is not removed by closing the file.

     ADDRESS gives a preferred starting address for the mapping.
     `NULL' expresses no preference. Any previous mapping at that
     address is automatically removed. The address you give may still be
     changed, unless you use the `MAP_FIXED' flag.

     PROTECT contains flags that control what kind of access is
     permitted.  They include `PROT_READ', `PROT_WRITE', and
     `PROT_EXEC', which permit reading, writing, and execution,
     respectively.  Inappropriate access will cause a segfault (*note
     Program Error Signals::).

     Note that most hardware designs cannot support write permission
     without read permission, and many do not distinguish read and
     execute permission.  Thus, you may receive wider permissions than
     you ask for, and mappings of write-only files may be denied even
     if you do not use `PROT_READ'.

     FLAGS contains flags that control the nature of the map.  One of
     `MAP_SHARED' or `MAP_PRIVATE' must be specified.

     They include:

    `MAP_PRIVATE'
          This specifies that writes to the region should never be
          written back to the attached file.  Instead, a copy is made
          for the process, and the region will be swapped normally if
          memory runs low.  No other process will see the changes.

          Since private mappings effectively revert to ordinary memory
          when written to, you must have enough virtual memory for a
          copy of the entire mmapped region if you use this mode with
          `PROT_WRITE'.

    `MAP_SHARED'
          This specifies that writes to the region will be written back
          to the file.  Changes made will be shared immediately with
          other processes mmaping the same file.

          Note that actual writing may take place at any time.  You
          need to use `msync', described below, if it is important that
          other processes using conventional I/O get a consistent view
          of the file.

    `MAP_FIXED'
          This forces the system to use the exact mapping address
          specified in ADDRESS and fail if it can't.

    `MAP_ANONYMOUS'
    `MAP_ANON'
          This flag tells the system to create an anonymous mapping,
          not connected to a file.  FILEDES and OFF are ignored, and
          the region is initialized with zeros.

          Anonymous maps are used as the basic primitive to extend the
          heap on some systems.  They are also useful to share data
          between multiple tasks without creating a file.

          On some systems using private anonymous mmaps is more
          efficient than using `malloc' for large blocks.  This is not
          an issue with the GNU C library, as the included `malloc'
          automatically uses `mmap' where appropriate.


     `mmap' returns the address of the new mapping, or -1 for an error.

     Possible errors include:

    `EINVAL'
          Either ADDRESS was unusable, or inconsistent FLAGS were given.

    `EACCES'
          FILEDES was not open for the type of access specified in
          PROTECT.

    `ENOMEM'
          Either there is not enough memory for the operation, or the
          process is out of address space.

    `ENODEV'
          This file is of a type that doesn't support mapping.

    `ENOEXEC'
          The file is on a filesystem that doesn't support mapping.



 -- Function: void * mmap64 (void *ADDRESS, size_t LENGTH,int PROTECT,
          int FLAGS, int FILEDES, off64_t OFFSET)
     The `mmap64' function is equivalent to the `mmap' function but the
     OFFSET parameter is of type `off64_t'.  On 32-bit systems this
     allows the file associated with the FILEDES descriptor to be
     larger than 2GB.  FILEDES must be a descriptor returned from a
     call to `open64' or `fopen64' and `freopen64' where the descriptor
     is retrieved with `fileno'.

     When the sources are translated with `_FILE_OFFSET_BITS == 64' this
     function is actually available under the name `mmap'.  I.e., the
     new, extended API using 64 bit file sizes and offsets transparently
     replaces the old API.

 -- Function: int munmap (void *ADDR, size_t LENGTH)
     `munmap' removes any memory maps from (ADDR) to (ADDR + LENGTH).
     LENGTH should be the length of the mapping.

     It is safe to unmap multiple mappings in one command, or include
     unmapped space in the range.  It is also possible to unmap only
     part of an existing mapping.  However, only entire pages can be
     removed.  If LENGTH is not an even number of pages, it will be
     rounded up.

     It returns 0 for success and -1 for an error.

     One error is possible:

    `EINVAL'
          The memory range given was outside the user mmap range or
          wasn't page aligned.



 -- Function: int msync (void *ADDRESS, size_t LENGTH, int FLAGS)
     When using shared mappings, the kernel can write the file at any
     time before the mapping is removed.  To be certain data has
     actually been written to the file and will be accessible to
     non-memory-mapped I/O, it is necessary to use this function.

     It operates on the region ADDRESS to (ADDRESS + LENGTH).  It may
     be used on part of a mapping or multiple mappings, however the
     region given should not contain any unmapped space.

     FLAGS can contain some options:

    `MS_SYNC'
          This flag makes sure the data is actually written _to disk_.
          Normally `msync' only makes sure that accesses to a file with
          conventional I/O reflect the recent changes.

    `MS_ASYNC'
          This tells `msync' to begin the synchronization, but not to
          wait for it to complete.


     `msync' returns 0 for success and -1 for error.  Errors include:

    `EINVAL'
          An invalid region was given, or the FLAGS were invalid.

    `EFAULT'
          There is no existing mapping in at least part of the given
          region.



 -- Function: void * mremap (void *ADDRESS, size_t LENGTH, size_t
          NEW_LENGTH, int FLAG)
     This function can be used to change the size of an existing memory
     area. ADDRESS and LENGTH must cover a region entirely mapped in
     the same `mmap' statement. A new mapping with the same
     characteristics will be returned with the length NEW_LENGTH.

     One option is possible, `MREMAP_MAYMOVE'. If it is given in FLAGS,
     the system may remove the existing mapping and create a new one of
     the desired length in another location.

     The address of the resulting mapping is returned, or -1. Possible
     error codes include:

    `EFAULT'
          There is no existing mapping in at least part of the original
          region, or the region covers two or more distinct mappings.

    `EINVAL'
          The address given is misaligned or inappropriate.

    `EAGAIN'
          The region has pages locked, and if extended it would exceed
          the process's resource limit for locked pages.  *Note Limits
          on Resources::.

    `ENOMEM'
          The region is private writable, and insufficient virtual
          memory is available to extend it.  Also, this error will
          occur if `MREMAP_MAYMOVE' is not given and the extension
          would collide with another mapped region.


   This function is only available on a few systems.  Except for
performing optional optimizations one should not rely on this function.

   Not all file descriptors may be mapped.  Sockets, pipes, and most
devices only allow sequential access and do not fit into the mapping
abstraction.  In addition, some regular files may not be mmapable, and
older kernels may not support mapping at all.  Thus, programs using
`mmap' should have a fallback method to use should it fail. *Note Mmap:
(standards)Mmap.

 -- Function: int madvise (void *ADDR, size_t LENGTH, int ADVICE)
     This function can be used to provide the system with ADVICE about
     the intended usage patterns of the memory region starting at ADDR
     and extending LENGTH bytes.

     The valid BSD values for ADVICE are:

    `MADV_NORMAL'
          The region should receive no further special treatment.

    `MADV_RANDOM'
          The region will be accessed via random page references. The
          kernel should page-in the minimal number of pages for each
          page fault.

    `MADV_SEQUENTIAL'
          The region will be accessed via sequential page references.
          This may cause the kernel to aggressively read-ahead,
          expecting further sequential references after any page fault
          within this region.

    `MADV_WILLNEED'
          The region will be needed.  The pages within this region may
          be pre-faulted in by the kernel.

    `MADV_DONTNEED'
          The region is no longer needed.  The kernel may free these
          pages, causing any changes to the pages to be lost, as well
          as swapped out pages to be discarded.


     The POSIX names are slightly different, but with the same meanings:

    `POSIX_MADV_NORMAL'
          This corresponds with BSD's `MADV_NORMAL'.

    `POSIX_MADV_RANDOM'
          This corresponds with BSD's `MADV_RANDOM'.

    `POSIX_MADV_SEQUENTIAL'
          This corresponds with BSD's `MADV_SEQUENTIAL'.

    `POSIX_MADV_WILLNEED'
          This corresponds with BSD's `MADV_WILLNEED'.

    `POSIX_MADV_DONTNEED'
          This corresponds with BSD's `MADV_DONTNEED'.


     `msync' returns 0 for success and -1 for error.  Errors include:
    `EINVAL'
          An invalid region was given, or the ADVICE was invalid.

    `EFAULT'
          There is no existing mapping in at least part of the given
          region.



File: libc.info,  Node: Waiting for I/O,  Next: Synchronizing I/O,  Prev: Memory-mapped I/O,  Up: Low-Level I/O

13.8 Waiting for Input or Output
================================

Sometimes a program needs to accept input on multiple input channels
whenever input arrives.  For example, some workstations may have devices
such as a digitizing tablet, function button box, or dial box that are
connected via normal asynchronous serial interfaces; good user interface
style requires responding immediately to input on any device.  Another
example is a program that acts as a server to several other processes
via pipes or sockets.

   You cannot normally use `read' for this purpose, because this blocks
the program until input is available on one particular file descriptor;
input on other channels won't wake it up.  You could set nonblocking
mode and poll each file descriptor in turn, but this is very
inefficient.

   A better solution is to use the `select' function.  This blocks the
program until input or output is ready on a specified set of file
descriptors, or until a timer expires, whichever comes first.  This
facility is declared in the header file `sys/types.h'.  

   In the case of a server socket (*note Listening::), we say that
"input" is available when there are pending connections that could be
accepted (*note Accepting Connections::).  `accept' for server sockets
blocks and interacts with `select' just as `read' does for normal input.

   The file descriptor sets for the `select' function are specified as
`fd_set' objects.  Here is the description of the data type and some
macros for manipulating these objects.

 -- Data Type: fd_set
     The `fd_set' data type represents file descriptor sets for the
     `select' function.  It is actually a bit array.

 -- Macro: int FD_SETSIZE
     The value of this macro is the maximum number of file descriptors
     that a `fd_set' object can hold information about.  On systems
     with a fixed maximum number, `FD_SETSIZE' is at least that number.
     On some systems, including GNU, there is no absolute limit on the
     number of descriptors open, but this macro still has a constant
     value which controls the number of bits in an `fd_set'; if you get
     a file descriptor with a value as high as `FD_SETSIZE', you cannot
     put that descriptor into an `fd_set'.

 -- Macro: void FD_ZERO (fd_set *SET)
     This macro initializes the file descriptor set SET to be the empty
     set.

 -- Macro: void FD_SET (int FILEDES, fd_set *SET)
     This macro adds FILEDES to the file descriptor set SET.

     The FILEDES parameter must not have side effects since it is
     evaluated more than once.

 -- Macro: void FD_CLR (int FILEDES, fd_set *SET)
     This macro removes FILEDES from the file descriptor set SET.

     The FILEDES parameter must not have side effects since it is
     evaluated more than once.

 -- Macro: int FD_ISSET (int FILEDES, const fd_set *SET)
     This macro returns a nonzero value (true) if FILEDES is a member
     of the file descriptor set SET, and zero (false) otherwise.

     The FILEDES parameter must not have side effects since it is
     evaluated more than once.

   Next, here is the description of the `select' function itself.

 -- Function: int select (int NFDS, fd_set *READ-FDS, fd_set
          *WRITE-FDS, fd_set *EXCEPT-FDS, struct timeval *TIMEOUT)
     The `select' function blocks the calling process until there is
     activity on any of the specified sets of file descriptors, or
     until the timeout period has expired.

     The file descriptors specified by the READ-FDS argument are
     checked to see if they are ready for reading; the WRITE-FDS file
     descriptors are checked to see if they are ready for writing; and
     the EXCEPT-FDS file descriptors are checked for exceptional
     conditions.  You can pass a null pointer for any of these
     arguments if you are not interested in checking for that kind of
     condition.

     A file descriptor is considered ready for reading if a `read' call
     will not block.  This usually includes the read offset being at
     the end of the file or there is an error to report.  A server
     socket is considered ready for reading if there is a pending
     connection which can be accepted with `accept'; *note Accepting
     Connections::.  A client socket is ready for writing when its
     connection is fully established; *note Connecting::.

     "Exceptional conditions" does not mean errors--errors are reported
     immediately when an erroneous system call is executed, and do not
     constitute a state of the descriptor.  Rather, they include
     conditions such as the presence of an urgent message on a socket.
     (*Note Sockets::, for information on urgent messages.)

     The `select' function checks only the first NFDS file descriptors.
     The usual thing is to pass `FD_SETSIZE' as the value of this
     argument.

     The TIMEOUT specifies the maximum time to wait.  If you pass a
     null pointer for this argument, it means to block indefinitely
     until one of the file descriptors is ready.  Otherwise, you should
     provide the time in `struct timeval' format; see *Note
     High-Resolution Calendar::.  Specify zero as the time (a `struct
     timeval' containing all zeros) if you want to find out which
     descriptors are ready without waiting if none are ready.

     The normal return value from `select' is the total number of ready
     file descriptors in all of the sets.  Each of the argument sets is
     overwritten with information about the descriptors that are ready
     for the corresponding operation.  Thus, to see if a particular
     descriptor DESC has input, use `FD_ISSET (DESC, READ-FDS)' after
     `select' returns.

     If `select' returns because the timeout period expires, it returns
     a value of zero.

     Any signal will cause `select' to return immediately.  So if your
     program uses signals, you can't rely on `select' to keep waiting
     for the full time specified.  If you want to be sure of waiting
     for a particular amount of time, you must check for `EINTR' and
     repeat the `select' with a newly calculated timeout based on the
     current time.  See the example below.  See also *Note Interrupted
     Primitives::.

     If an error occurs, `select' returns `-1' and does not modify the
     argument file descriptor sets.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          One of the file descriptor sets specified an invalid file
          descriptor.

    `EINTR'
          The operation was interrupted by a signal.  *Note Interrupted
          Primitives::.

    `EINVAL'
          The TIMEOUT argument is invalid; one of the components is
          negative or too large.

   *Portability Note:*  The `select' function is a BSD Unix feature.

   Here is an example showing how you can use `select' to establish a
timeout period for reading from a file descriptor.  The `input_timeout'
function blocks the calling process until input is available on the
file descriptor, or until the timeout period expires.

     #include <errno.h>
     #include <stdio.h>
     #include <unistd.h>
     #include <sys/types.h>
     #include <sys/time.h>

     int
     input_timeout (int filedes, unsigned int seconds)
     {
       fd_set set;
       struct timeval timeout;

       /* Initialize the file descriptor set. */
       FD_ZERO (&set);
       FD_SET (filedes, &set);

       /* Initialize the timeout data structure. */
       timeout.tv_sec = seconds;
       timeout.tv_usec = 0;

       /* `select' returns 0 if timeout, 1 if input available, -1 if error. */
       return TEMP_FAILURE_RETRY (select (FD_SETSIZE,
                                          &set, NULL, NULL,
                                          &timeout));
     }

     int
     main (void)
     {
       fprintf (stderr, "select returned %d.\n",
                input_timeout (STDIN_FILENO, 5));
       return 0;
     }

   There is another example showing the use of `select' to multiplex
input from multiple sockets in *Note Server Example::.


File: libc.info,  Node: Synchronizing I/O,  Next: Asynchronous I/O,  Prev: Waiting for I/O,  Up: Low-Level I/O

13.9 Synchronizing I/O operations
=================================

In most modern operating systems, the normal I/O operations are not
executed synchronously.  I.e., even if a `write' system call returns,
this does not mean the data is actually written to the media, e.g., the
disk.

   In situations where synchronization points are necessary, you can use
special functions which ensure that all operations finish before they
return.

 -- Function: int sync (void)
     A call to this function will not return as long as there is data
     which has not been written to the device.  All dirty buffers in
     the kernel will be written and so an overall consistent system can
     be achieved (if no other process in parallel writes data).

     A prototype for `sync' can be found in `unistd.h'.

     The return value is zero to indicate no error.

   Programs more often want to ensure that data written to a given file
is committed, rather than all data in the system.  For this, `sync' is
overkill.

 -- Function: int fsync (int FILDES)
     The `fsync' function can be used to make sure all data associated
     with the open file FILDES is written to the device associated with
     the descriptor.  The function call does not return unless all
     actions have finished.

     A prototype for `fsync' can be found in `unistd.h'.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `fsync' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this, calls to
     `fsync' should be protected using cancellation handlers.

     The return value of the function is zero if no error occurred.
     Otherwise it is -1 and the global variable ERRNO is set to the
     following values:
    `EBADF'
          The descriptor FILDES is not valid.

    `EINVAL'
          No synchronization is possible since the system does not
          implement this.

   Sometimes it is not even necessary to write all data associated with
a file descriptor.  E.g., in database files which do not change in size
it is enough to write all the file content data to the device.
Meta-information, like the modification time etc., are not that
important and leaving such information uncommitted does not prevent a
successful recovering of the file in case of a problem.

 -- Function: int fdatasync (int FILDES)
     When a call to the `fdatasync' function returns, it is ensured
     that all of the file data is written to the device.  For all
     pending I/O operations, the parts guaranteeing data integrity
     finished.

     Not all systems implement the `fdatasync' operation.  On systems
     missing this functionality `fdatasync' is emulated by a call to
     `fsync' since the performed actions are a superset of those
     required by `fdatasync'.

     The prototype for `fdatasync' is in `unistd.h'.

     The return value of the function is zero if no error occurred.
     Otherwise it is -1 and the global variable ERRNO is set to the
     following values:
    `EBADF'
          The descriptor FILDES is not valid.

    `EINVAL'
          No synchronization is possible since the system does not
          implement this.


File: libc.info,  Node: Asynchronous I/O,  Next: Control Operations,  Prev: Synchronizing I/O,  Up: Low-Level I/O

13.10 Perform I/O Operations in Parallel
========================================

The POSIX.1b standard defines a new set of I/O operations which can
significantly reduce the time an application spends waiting at I/O.  The
new functions allow a program to initiate one or more I/O operations and
then immediately resume normal work while the I/O operations are
executed in parallel.  This functionality is available if the
`unistd.h' file defines the symbol `_POSIX_ASYNCHRONOUS_IO'.

   These functions are part of the library with realtime functions named
`librt'.  They are not actually part of the `libc' binary.  The
implementation of these functions can be done using support in the
kernel (if available) or using an implementation based on threads at
userlevel.  In the latter case it might be necessary to link
applications with the thread library `libpthread' in addition to
`librt'.

   All AIO operations operate on files which were opened previously.
There might be arbitrarily many operations running for one file.  The
asynchronous I/O operations are controlled using a data structure named
`struct aiocb' ("AIO control block").  It is defined in `aio.h' as
follows.

 -- Data Type: struct aiocb
     The POSIX.1b standard mandates that the `struct aiocb' structure
     contains at least the members described in the following table.
     There might be more elements which are used by the implementation,
     but depending upon these elements is not portable and is highly
     deprecated.

    `int aio_fildes'
          This element specifies the file descriptor to be used for the
          operation.  It must be a legal descriptor, otherwise the
          operation will fail.

          The device on which the file is opened must allow the seek
          operation.  I.e., it is not possible to use any of the AIO
          operations on devices like terminals where an `lseek' call
          would lead to an error.

    `off_t aio_offset'
          This element specifies the offset in the file at which the
          operation (input or output) is performed.  Since the
          operations are carried out in arbitrary order and more than
          one operation for one file descriptor can be started, one
          cannot expect a current read/write position of the file
          descriptor.

    `volatile void *aio_buf'
          This is a pointer to the buffer with the data to be written
          or the place where the read data is stored.

    `size_t aio_nbytes'
          This element specifies the length of the buffer pointed to by
          `aio_buf'.

    `int aio_reqprio'
          If the platform has defined `_POSIX_PRIORITIZED_IO' and
          `_POSIX_PRIORITY_SCHEDULING', the AIO requests are processed
          based on the current scheduling priority.  The `aio_reqprio'
          element can then be used to lower the priority of the AIO
          operation.

    `struct sigevent aio_sigevent'
          This element specifies how the calling process is notified
          once the operation terminates.  If the `sigev_notify' element
          is `SIGEV_NONE', no notification is sent.  If it is
          `SIGEV_SIGNAL', the signal determined by `sigev_signo' is
          sent.  Otherwise, `sigev_notify' must be `SIGEV_THREAD'.  In
          this case, a thread is created which starts executing the
          function pointed to by `sigev_notify_function'.

    `int aio_lio_opcode'
          This element is only used by the `lio_listio' and
          `lio_listio64' functions.  Since these functions allow an
          arbitrary number of operations to start at once, and each
          operation can be input or output (or nothing), the
          information must be stored in the control block.  The
          possible values are:

         `LIO_READ'
               Start a read operation.  Read from the file at position
               `aio_offset' and store the next `aio_nbytes' bytes in the
               buffer pointed to by `aio_buf'.

         `LIO_WRITE'
               Start a write operation.  Write `aio_nbytes' bytes
               starting at `aio_buf' into the file starting at position
               `aio_offset'.

         `LIO_NOP'
               Do nothing for this control block.  This value is useful
               sometimes when an array of `struct aiocb' values
               contains holes, i.e., some of the values must not be
               handled although the whole array is presented to the
               `lio_listio' function.

     When the sources are compiled using `_FILE_OFFSET_BITS == 64' on a
     32 bit machine, this type is in fact `struct aiocb64', since the
     LFS interface transparently replaces the `struct aiocb' definition.

   For use with the AIO functions defined in the LFS, there is a
similar type defined which replaces the types of the appropriate
members with larger types but otherwise is equivalent to `struct
aiocb'.  Particularly, all member names are the same.

 -- Data Type: struct aiocb64
    `int aio_fildes'
          This element specifies the file descriptor which is used for
          the operation.  It must be a legal descriptor since otherwise
          the operation fails for obvious reasons.

          The device on which the file is opened must allow the seek
          operation.  I.e., it is not possible to use any of the AIO
          operations on devices like terminals where an `lseek' call
          would lead to an error.

    `off64_t aio_offset'
          This element specifies at which offset in the file the
          operation (input or output) is performed.  Since the
          operation are carried in arbitrary order and more than one
          operation for one file descriptor can be started, one cannot
          expect a current read/write position of the file descriptor.

    `volatile void *aio_buf'
          This is a pointer to the buffer with the data to be written
          or the place where the read data is stored.

    `size_t aio_nbytes'
          This element specifies the length of the buffer pointed to by
          `aio_buf'.

    `int aio_reqprio'
          If for the platform `_POSIX_PRIORITIZED_IO' and
          `_POSIX_PRIORITY_SCHEDULING' are defined the AIO requests are
          processed based on the current scheduling priority.  The
          `aio_reqprio' element can then be used to lower the priority
          of the AIO operation.

    `struct sigevent aio_sigevent'
          This element specifies how the calling process is notified
          once the operation terminates.  If the `sigev_notify',
          element is `SIGEV_NONE' no notification is sent.  If it is
          `SIGEV_SIGNAL', the signal determined by `sigev_signo' is
          sent.  Otherwise, `sigev_notify' must be `SIGEV_THREAD' in
          which case a thread which starts executing the function
          pointed to by `sigev_notify_function'.

    `int aio_lio_opcode'
          This element is only used by the `lio_listio' and
          `[lio_listio64' functions.  Since these functions allow an
          arbitrary number of operations to start at once, and since
          each operation can be input or output (or nothing), the
          information must be stored in the control block.  See the
          description of `struct aiocb' for a description of the
          possible values.

     When the sources are compiled using `_FILE_OFFSET_BITS == 64' on a
     32 bit machine, this type is available under the name `struct
     aiocb64', since the LFS transparently replaces the old interface.

* Menu:

* Asynchronous Reads/Writes::    Asynchronous Read and Write Operations.
* Status of AIO Operations::     Getting the Status of AIO Operations.
* Synchronizing AIO Operations:: Getting into a consistent state.
* Cancel AIO Operations::        Cancellation of AIO Operations.
* Configuration of AIO::         How to optimize the AIO implementation.


File: libc.info,  Node: Asynchronous Reads/Writes,  Next: Status of AIO Operations,  Up: Asynchronous I/O

13.10.1 Asynchronous Read and Write Operations
----------------------------------------------

 -- Function: int aio_read (struct aiocb *AIOCBP)
     This function initiates an asynchronous read operation.  It
     immediately returns after the operation was enqueued or when an
     error was encountered.

     The first `aiocbp->aio_nbytes' bytes of the file for which
     `aiocbp->aio_fildes' is a descriptor are written to the buffer
     starting at `aiocbp->aio_buf'.  Reading starts at the absolute
     position `aiocbp->aio_offset' in the file.

     If prioritized I/O is supported by the platform the
     `aiocbp->aio_reqprio' value is used to adjust the priority before
     the request is actually enqueued.

     The calling process is notified about the termination of the read
     request according to the `aiocbp->aio_sigevent' value.

     When `aio_read' returns, the return value is zero if no error
     occurred that can be found before the process is enqueued.  If
     such an early error is found, the function returns -1 and sets
     `errno' to one of the following values:

    `EAGAIN'
          The request was not enqueued due to (temporarily) exceeded
          resource limitations.

    `ENOSYS'
          The `aio_read' function is not implemented.

    `EBADF'
          The `aiocbp->aio_fildes' descriptor is not valid.  This
          condition need not be recognized before enqueueing the
          request and so this error might also be signaled
          asynchronously.

    `EINVAL'
          The `aiocbp->aio_offset' or `aiocbp->aio_reqpiro' value is
          invalid.  This condition need not be recognized before
          enqueueing the request and so this error might also be
          signaled asynchronously.

     If `aio_read' returns zero, the current status of the request can
     be queried using `aio_error' and `aio_return' functions.  As long
     as the value returned by `aio_error' is `EINPROGRESS' the
     operation has not yet completed.  If `aio_error' returns zero, the
     operation successfully terminated, otherwise the value is to be
     interpreted as an error code.  If the function terminated, the
     result of the operation can be obtained using a call to
     `aio_return'.  The returned value is the same as an equivalent
     call to `read' would have returned.  Possible error codes returned
     by `aio_error' are:

    `EBADF'
          The `aiocbp->aio_fildes' descriptor is not valid.

    `ECANCELED'
          The operation was canceled before the operation was finished
          (*note Cancel AIO Operations::)

    `EINVAL'
          The `aiocbp->aio_offset' value is invalid.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `aio_read64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int aio_read64 (struct aiocb *AIOCBP)
     This function is similar to the `aio_read' function.  The only
     difference is that on 32 bit machines, the file descriptor should
     be opened in the large file mode.  Internally, `aio_read64' uses
     functionality equivalent to `lseek64' (*note File Position
     Primitive::) to position the file descriptor correctly for the
     reading, as opposed to `lseek' functionality used in `aio_read'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64', this
     function is available under the name `aio_read' and so
     transparently replaces the interface for small files on 32 bit
     machines.

   To write data asynchronously to a file, there exists an equivalent
pair of functions with a very similar interface.

 -- Function: int aio_write (struct aiocb *AIOCBP)
     This function initiates an asynchronous write operation.  The
     function call immediately returns after the operation was enqueued
     or if before this happens an error was encountered.

     The first `aiocbp->aio_nbytes' bytes from the buffer starting at
     `aiocbp->aio_buf' are written to the file for which
     `aiocbp->aio_fildes' is an descriptor, starting at the absolute
     position `aiocbp->aio_offset' in the file.

     If prioritized I/O is supported by the platform, the
     `aiocbp->aio_reqprio' value is used to adjust the priority before
     the request is actually enqueued.

     The calling process is notified about the termination of the read
     request according to the `aiocbp->aio_sigevent' value.

     When `aio_write' returns, the return value is zero if no error
     occurred that can be found before the process is enqueued.  If
     such an early error is found the function returns -1 and sets
     `errno' to one of the following values.

    `EAGAIN'
          The request was not enqueued due to (temporarily) exceeded
          resource limitations.

    `ENOSYS'
          The `aio_write' function is not implemented.

    `EBADF'
          The `aiocbp->aio_fildes' descriptor is not valid.  This
          condition may not be recognized before enqueueing the
          request, and so this error might also be signaled
          asynchronously.

    `EINVAL'
          The `aiocbp->aio_offset' or `aiocbp->aio_reqprio' value is
          invalid.  This condition may not be recognized before
          enqueueing the request and so this error might also be
          signaled asynchronously.

     In the case `aio_write' returns zero, the current status of the
     request can be queried using `aio_error' and `aio_return'
     functions.  As long as the value returned by `aio_error' is
     `EINPROGRESS' the operation has not yet completed.  If `aio_error'
     returns zero, the operation successfully terminated, otherwise the
     value is to be interpreted as an error code.  If the function
     terminated, the result of the operation can be get using a call to
     `aio_return'.  The returned value is the same as an equivalent
     call to `read' would have returned.  Possible error codes returned
     by `aio_error' are:

    `EBADF'
          The `aiocbp->aio_fildes' descriptor is not valid.

    `ECANCELED'
          The operation was canceled before the operation was finished.
          (*note Cancel AIO Operations::)

    `EINVAL'
          The `aiocbp->aio_offset' value is invalid.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64', this
     function is in fact `aio_write64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int aio_write64 (struct aiocb *AIOCBP)
     This function is similar to the `aio_write' function.  The only
     difference is that on 32 bit machines the file descriptor should
     be opened in the large file mode.  Internally `aio_write64' uses
     functionality equivalent to `lseek64' (*note File Position
     Primitive::) to position the file descriptor correctly for the
     writing, as opposed to `lseek' functionality used in `aio_write'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64', this
     function is available under the name `aio_write' and so
     transparently replaces the interface for small files on 32 bit
     machines.

   Besides these functions with the more or less traditional interface,
POSIX.1b also defines a function which can initiate more than one
operation at a time, and which can handle freely mixed read and write
operations.  It is therefore similar to a combination of `readv' and
`writev'.

 -- Function: int lio_listio (int MODE, struct aiocb *const LIST[], int
          NENT, struct sigevent *SIG)
     The `lio_listio' function can be used to enqueue an arbitrary
     number of read and write requests at one time.  The requests can
     all be meant for the same file, all for different files or every
     solution in between.

     `lio_listio' gets the NENT requests from the array pointed to by
     LIST.  The operation to be performed is determined by the
     `aio_lio_opcode' member in each element of LIST.  If this field is
     `LIO_READ' a read operation is enqueued, similar to a call of
     `aio_read' for this element of the array (except that the way the
     termination is signalled is different, as we will see below).  If
     the `aio_lio_opcode' member is `LIO_WRITE' a write operation is
     enqueued.  Otherwise the `aio_lio_opcode' must be `LIO_NOP' in
     which case this element of LIST is simply ignored.  This
     "operation" is useful in situations where one has a fixed array of
     `struct aiocb' elements from which only a few need to be handled at
     a time.  Another situation is where the `lio_listio' call was
     canceled before all requests are processed (*note Cancel AIO
     Operations::) and the remaining requests have to be reissued.

     The other members of each element of the array pointed to by
     `list' must have values suitable for the operation as described in
     the documentation for `aio_read' and `aio_write' above.

     The MODE argument determines how `lio_listio' behaves after having
     enqueued all the requests.  If MODE is `LIO_WAIT' it waits until
     all requests terminated.  Otherwise MODE must be `LIO_NOWAIT' and
     in this case the function returns immediately after having
     enqueued all the requests.  In this case the caller gets a
     notification of the termination of all requests according to the
     SIG parameter.  If SIG is `NULL' no notification is send.
     Otherwise a signal is sent or a thread is started, just as
     described in the description for `aio_read' or `aio_write'.

     If MODE is `LIO_WAIT', the return value of `lio_listio' is 0 when
     all requests completed successfully.  Otherwise the function
     return -1 and `errno' is set accordingly.  To find out which
     request or requests failed one has to use the `aio_error' function
     on all the elements of the array LIST.

     In case MODE is `LIO_NOWAIT', the function returns 0 if all
     requests were enqueued correctly.  The current state of the
     requests can be found using `aio_error' and `aio_return' as
     described above.  If `lio_listio' returns -1 in this mode, the
     global variable `errno' is set accordingly.  If a request did not
     yet terminate, a call to `aio_error' returns `EINPROGRESS'.  If
     the value is different, the request is finished and the error
     value (or 0) is returned and the result of the operation can be
     retrieved using `aio_return'.

     Possible values for `errno' are:

    `EAGAIN'
          The resources necessary to queue all the requests are not
          available at the moment.  The error status for each element
          of LIST must be checked to determine which request failed.

          Another reason could be that the system wide limit of AIO
          requests is exceeded.  This cannot be the case for the
          implementation on GNU systems since no arbitrary limits exist.

    `EINVAL'
          The MODE parameter is invalid or NENT is larger than
          `AIO_LISTIO_MAX'.

    `EIO'
          One or more of the request's I/O operations failed.  The
          error status of each request should be checked to determine
          which one failed.

    `ENOSYS'
          The `lio_listio' function is not supported.

     If the MODE parameter is `LIO_NOWAIT' and the caller cancels a
     request, the error status for this request returned by `aio_error'
     is `ECANCELED'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64', this
     function is in fact `lio_listio64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int lio_listio64 (int MODE, struct aiocb *const LIST, int
          NENT, struct sigevent *SIG)
     This function is similar to the `lio_listio' function.  The only
     difference is that on 32 bit machines, the file descriptor should
     be opened in the large file mode.  Internally, `lio_listio64' uses
     functionality equivalent to `lseek64' (*note File Position
     Primitive::) to position the file descriptor correctly for the
     reading or writing, as opposed to `lseek' functionality used in
     `lio_listio'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64', this
     function is available under the name `lio_listio' and so
     transparently replaces the interface for small files on 32 bit
     machines.


File: libc.info,  Node: Status of AIO Operations,  Next: Synchronizing AIO Operations,  Prev: Asynchronous Reads/Writes,  Up: Asynchronous I/O

13.10.2 Getting the Status of AIO Operations
--------------------------------------------

As already described in the documentation of the functions in the last
section, it must be possible to get information about the status of an
I/O request.  When the operation is performed truly asynchronously (as
with `aio_read' and `aio_write' and with `lio_listio' when the mode is
`LIO_NOWAIT'), one sometimes needs to know whether a specific request
already terminated and if so, what the result was.  The following two
functions allow you to get this kind of information.

 -- Function: int aio_error (const struct aiocb *AIOCBP)
     This function determines the error state of the request described
     by the `struct aiocb' variable pointed to by AIOCBP.  If the
     request has not yet terminated the value returned is always
     `EINPROGRESS'.  Once the request has terminated the value
     `aio_error' returns is either 0 if the request completed
     successfully or it returns the value which would be stored in the
     `errno' variable if the request would have been done using `read',
     `write', or `fsync'.

     The function can return `ENOSYS' if it is not implemented.  It
     could also return `EINVAL' if the AIOCBP parameter does not refer
     to an asynchronous operation whose return status is not yet known.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `aio_error64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int aio_error64 (const struct aiocb64 *AIOCBP)
     This function is similar to `aio_error' with the only difference
     that the argument is a reference to a variable of type `struct
     aiocb64'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is available under the name `aio_error' and so
     transparently replaces the interface for small files on 32 bit
     machines.

 -- Function: ssize_t aio_return (const struct aiocb *AIOCBP)
     This function can be used to retrieve the return status of the
     operation carried out by the request described in the variable
     pointed to by AIOCBP.  As long as the error status of this request
     as returned by `aio_error' is `EINPROGRESS' the return of this
     function is undefined.

     Once the request is finished this function can be used exactly
     once to retrieve the return value.  Following calls might lead to
     undefined behavior.  The return value itself is the value which
     would have been returned by the `read', `write', or `fsync' call.

     The function can return `ENOSYS' if it is not implemented.  It
     could also return `EINVAL' if the AIOCBP parameter does not refer
     to an asynchronous operation whose return status is not yet known.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `aio_return64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int aio_return64 (const struct aiocb64 *AIOCBP)
     This function is similar to `aio_return' with the only difference
     that the argument is a reference to a variable of type `struct
     aiocb64'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is available under the name `aio_return' and so
     transparently replaces the interface for small files on 32 bit
     machines.


File: libc.info,  Node: Synchronizing AIO Operations,  Next: Cancel AIO Operations,  Prev: Status of AIO Operations,  Up: Asynchronous I/O

13.10.3 Getting into a Consistent State
---------------------------------------

When dealing with asynchronous operations it is sometimes necessary to
get into a consistent state.  This would mean for AIO that one wants to
know whether a certain request or a group of request were processed.
This could be done by waiting for the notification sent by the system
after the operation terminated, but this sometimes would mean wasting
resources (mainly computation time).  Instead POSIX.1b defines two
functions which will help with most kinds of consistency.

   The `aio_fsync' and `aio_fsync64' functions are only available if
the symbol `_POSIX_SYNCHRONIZED_IO' is defined in `unistd.h'.

 -- Function: int aio_fsync (int OP, struct aiocb *AIOCBP)
     Calling this function forces all I/O operations operating queued
     at the time of the function call operating on the file descriptor
     `aiocbp->aio_fildes' into the synchronized I/O completion state
     (*note Synchronizing I/O::).  The `aio_fsync' function returns
     immediately but the notification through the method described in
     `aiocbp->aio_sigevent' will happen only after all requests for this
     file descriptor have terminated and the file is synchronized.
     This also means that requests for this very same file descriptor
     which are queued after the synchronization request are not
     affected.

     If OP is `O_DSYNC' the synchronization happens as with a call to
     `fdatasync'.  Otherwise OP should be `O_SYNC' and the
     synchronization happens as with `fsync'.

     As long as the synchronization has not happened, a call to
     `aio_error' with the reference to the object pointed to by AIOCBP
     returns `EINPROGRESS'.  Once the synchronization is done
     `aio_error' return 0 if the synchronization was not successful.
     Otherwise the value returned is the value to which the `fsync' or
     `fdatasync' function would have set the `errno' variable.  In this
     case nothing can be assumed about the consistency for the data
     written to this file descriptor.

     The return value of this function is 0 if the request was
     successfully enqueued.  Otherwise the return value is -1 and
     `errno' is set to one of the following values:

    `EAGAIN'
          The request could not be enqueued due to temporary lack of
          resources.

    `EBADF'
          The file descriptor `aiocbp->aio_fildes' is not valid or not
          open for writing.

    `EINVAL'
          The implementation does not support I/O synchronization or
          the OP parameter is other than `O_DSYNC' and `O_SYNC'.

    `ENOSYS'
          This function is not implemented.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `aio_fsync64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int aio_fsync64 (int OP, struct aiocb64 *AIOCBP)
     This function is similar to `aio_fsync' with the only difference
     that the argument is a reference to a variable of type `struct
     aiocb64'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is available under the name `aio_fsync' and so
     transparently replaces the interface for small files on 32 bit
     machines.

   Another method of synchronization is to wait until one or more
requests of a specific set terminated.  This could be achieved by the
`aio_*' functions to notify the initiating process about the
termination but in some situations this is not the ideal solution.  In
a program which constantly updates clients somehow connected to the
server it is not always the best solution to go round robin since some
connections might be slow.  On the other hand letting the `aio_*'
function notify the caller might also be not the best solution since
whenever the process works on preparing data for on client it makes no
sense to be interrupted by a notification since the new client will not
be handled before the current client is served.  For situations like
this `aio_suspend' should be used.

 -- Function: int aio_suspend (const struct aiocb *const LIST[], int
          NENT, const struct timespec *TIMEOUT)
     When calling this function, the calling thread is suspended until
     at least one of the requests pointed to by the NENT elements of the
     array LIST has completed.  If any of the requests has already
     completed at the time `aio_suspend' is called, the function returns
     immediately.  Whether a request has terminated or not is
     determined by comparing the error status of the request with
     `EINPROGRESS'.  If an element of LIST is `NULL', the entry is
     simply ignored.

     If no request has finished, the calling process is suspended.  If
     TIMEOUT is `NULL', the process is not woken until a request has
     finished.  If TIMEOUT is not `NULL', the process remains suspended
     at least as long as specified in TIMEOUT.  In this case,
     `aio_suspend' returns with an error.

     The return value of the function is 0 if one or more requests from
     the LIST have terminated.  Otherwise the function returns -1 and
     `errno' is set to one of the following values:

    `EAGAIN'
          None of the requests from the LIST completed in the time
          specified by TIMEOUT.

    `EINTR'
          A signal interrupted the `aio_suspend' function.  This signal
          might also be sent by the AIO implementation while signalling
          the termination of one of the requests.

    `ENOSYS'
          The `aio_suspend' function is not implemented.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `aio_suspend64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int aio_suspend64 (const struct aiocb64 *const LIST[],
          int NENT, const struct timespec *TIMEOUT)
     This function is similar to `aio_suspend' with the only difference
     that the argument is a reference to a variable of type `struct
     aiocb64'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is available under the name `aio_suspend' and so
     transparently replaces the interface for small files on 32 bit
     machines.


File: libc.info,  Node: Cancel AIO Operations,  Next: Configuration of AIO,  Prev: Synchronizing AIO Operations,  Up: Asynchronous I/O

13.10.4 Cancellation of AIO Operations
--------------------------------------

When one or more requests are asynchronously processed, it might be
useful in some situations to cancel a selected operation, e.g., if it
becomes obvious that the written data is no longer accurate and would
have to be overwritten soon.  As an example, assume an application,
which writes data in files in a situation where new incoming data would
have to be written in a file which will be updated by an enqueued
request.  The POSIX AIO implementation provides such a function, but
this function is not capable of forcing the cancellation of the
request.  It is up to the implementation to decide whether it is
possible to cancel the operation or not.  Therefore using this function
is merely a hint.

 -- Function: int aio_cancel (int FILDES, struct aiocb *AIOCBP)
     The `aio_cancel' function can be used to cancel one or more
     outstanding requests.  If the AIOCBP parameter is `NULL', the
     function tries to cancel all of the outstanding requests which
     would process the file descriptor FILDES (i.e., whose `aio_fildes'
     member is FILDES).  If AIOCBP is not `NULL', `aio_cancel' attempts
     to cancel the specific request pointed to by AIOCBP.

     For requests which were successfully canceled, the normal
     notification about the termination of the request should take
     place.  I.e., depending on the `struct sigevent' object which
     controls this, nothing happens, a signal is sent or a thread is
     started.  If the request cannot be canceled, it terminates the
     usual way after performing the operation.

     After a request is successfully canceled, a call to `aio_error'
     with a reference to this request as the parameter will return
     `ECANCELED' and a call to `aio_return' will return -1.  If the
     request wasn't canceled and is still running the error status is
     still `EINPROGRESS'.

     The return value of the function is `AIO_CANCELED' if there were
     requests which haven't terminated and which were successfully
     canceled.  If there is one or more requests left which couldn't be
     canceled, the return value is `AIO_NOTCANCELED'.  In this case
     `aio_error' must be used to find out which of the, perhaps
     multiple, requests (in AIOCBP is `NULL') weren't successfully
     canceled.  If all requests already terminated at the time
     `aio_cancel' is called the return value is `AIO_ALLDONE'.

     If an error occurred during the execution of `aio_cancel' the
     function returns -1 and sets `errno' to one of the following
     values.

    `EBADF'
          The file descriptor FILDES is not valid.

    `ENOSYS'
          `aio_cancel' is not implemented.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64', this
     function is in fact `aio_cancel64' since the LFS interface
     transparently replaces the normal implementation.

 -- Function: int aio_cancel64 (int FILDES, struct aiocb64 *AIOCBP)
     This function is similar to `aio_cancel' with the only difference
     that the argument is a reference to a variable of type `struct
     aiocb64'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64', this
     function is available under the name `aio_cancel' and so
     transparently replaces the interface for small files on 32 bit
     machines.


File: libc.info,  Node: Configuration of AIO,  Prev: Cancel AIO Operations,  Up: Asynchronous I/O

13.10.5 How to optimize the AIO implementation
----------------------------------------------

The POSIX standard does not specify how the AIO functions are
implemented.  They could be system calls, but it is also possible to
emulate them at userlevel.

   At the point of this writing, the available implementation is a
userlevel implementation which uses threads for handling the enqueued
requests.  While this implementation requires making some decisions
about limitations, hard limitations are something which is best avoided
in the GNU C library.  Therefore, the GNU C library provides a means
for tuning the AIO implementation according to the individual use.

 -- Data Type: struct aioinit
     This data type is used to pass the configuration or tunable
     parameters to the implementation.  The program has to initialize
     the members of this struct and pass it to the implementation using
     the `aio_init' function.

    `int aio_threads'
          This member specifies the maximal number of threads which may
          be used at any one time.

    `int aio_num'
          This number provides an estimate on the maximal number of
          simultaneously enqueued requests.

    `int aio_locks'
          Unused.

    `int aio_usedba'
          Unused.

    `int aio_debug'
          Unused.

    `int aio_numusers'
          Unused.

    `int aio_reserved[2]'
          Unused.

 -- Function: void aio_init (const struct aioinit *INIT)
     This function must be called before any other AIO function.
     Calling it is completely voluntary, as it is only meant to help
     the AIO implementation perform better.

     Before calling the `aio_init', function the members of a variable
     of type `struct aioinit' must be initialized.  Then a reference to
     this variable is passed as the parameter to `aio_init' which itself
     may or may not pay attention to the hints.

     The function has no return value and no error cases are defined.
     It is a extension which follows a proposal from the SGI
     implementation in Irix 6.  It is not covered by POSIX.1b or Unix98.


File: libc.info,  Node: Control Operations,  Next: Duplicating Descriptors,  Prev: Asynchronous I/O,  Up: Low-Level I/O

13.11 Control Operations on Files
=================================

This section describes how you can perform various other operations on
file descriptors, such as inquiring about or setting flags describing
the status of the file descriptor, manipulating record locks, and the
like.  All of these operations are performed by the function `fcntl'.

   The second argument to the `fcntl' function is a command that
specifies which operation to perform.  The function and macros that name
various flags that are used with it are declared in the header file
`fcntl.h'.  Many of these flags are also used by the `open' function;
see *Note Opening and Closing Files::.  

 -- Function: int fcntl (int FILEDES, int COMMAND, ...)
     The `fcntl' function performs the operation specified by COMMAND
     on the file descriptor FILEDES.  Some commands require additional
     arguments to be supplied.  These additional arguments and the
     return value and error conditions are given in the detailed
     descriptions of the individual commands.

     Briefly, here is a list of what the various commands are.

    `F_DUPFD'
          Duplicate the file descriptor (return another file descriptor
          pointing to the same open file).  *Note Duplicating
          Descriptors::.

    `F_GETFD'
          Get flags associated with the file descriptor.  *Note
          Descriptor Flags::.

    `F_SETFD'
          Set flags associated with the file descriptor.  *Note
          Descriptor Flags::.

    `F_GETFL'
          Get flags associated with the open file.  *Note File Status
          Flags::.

    `F_SETFL'
          Set flags associated with the open file.  *Note File Status
          Flags::.

    `F_GETLK'
          Get a file lock.  *Note File Locks::.

    `F_SETLK'
          Set or clear a file lock.  *Note File Locks::.

    `F_SETLKW'
          Like `F_SETLK', but wait for completion.  *Note File Locks::.

    `F_GETOWN'
          Get process or process group ID to receive `SIGIO' signals.
          *Note Interrupt Input::.

    `F_SETOWN'
          Set process or process group ID to receive `SIGIO' signals.
          *Note Interrupt Input::.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `fcntl' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `fcntl' should be protected using cancellation handlers.


File: libc.info,  Node: Duplicating Descriptors,  Next: Descriptor Flags,  Prev: Control Operations,  Up: Low-Level I/O

13.12 Duplicating Descriptors
=============================

You can "duplicate" a file descriptor, or allocate another file
descriptor that refers to the same open file as the original.  Duplicate
descriptors share one file position and one set of file status flags
(*note File Status Flags::), but each has its own set of file descriptor
flags (*note Descriptor Flags::).

   The major use of duplicating a file descriptor is to implement
"redirection" of input or output:  that is, to change the file or pipe
that a particular file descriptor corresponds to.

   You can perform this operation using the `fcntl' function with the
`F_DUPFD' command, but there are also convenient functions `dup' and
`dup2' for duplicating descriptors.

   The `fcntl' function and flags are declared in `fcntl.h', while
prototypes for `dup' and `dup2' are in the header file `unistd.h'.

 -- Function: int dup (int OLD)
     This function copies descriptor OLD to the first available
     descriptor number (the first number not currently open).  It is
     equivalent to `fcntl (OLD, F_DUPFD, 0)'.

 -- Function: int dup2 (int OLD, int NEW)
     This function copies the descriptor OLD to descriptor number NEW.

     If OLD is an invalid descriptor, then `dup2' does nothing; it does
     not close NEW.  Otherwise, the new duplicate of OLD replaces any
     previous meaning of descriptor NEW, as if NEW were closed first.

     If OLD and NEW are different numbers, and OLD is a valid
     descriptor number, then `dup2' is equivalent to:

          close (NEW);
          fcntl (OLD, F_DUPFD, NEW)

     However, `dup2' does this atomically; there is no instant in the
     middle of calling `dup2' at which NEW is closed and not yet a
     duplicate of OLD.

 -- Macro: int F_DUPFD
     This macro is used as the COMMAND argument to `fcntl', to copy the
     file descriptor given as the first argument.

     The form of the call in this case is:

          fcntl (OLD, F_DUPFD, NEXT-FILEDES)

     The NEXT-FILEDES argument is of type `int' and specifies that the
     file descriptor returned should be the next available one greater
     than or equal to this value.

     The return value from `fcntl' with this command is normally the
     value of the new file descriptor.  A return value of -1 indicates
     an error.  The following `errno' error conditions are defined for
     this command:

    `EBADF'
          The OLD argument is invalid.

    `EINVAL'
          The NEXT-FILEDES argument is invalid.

    `EMFILE'
          There are no more file descriptors available--your program is
          already using the maximum.  In BSD and GNU, the maximum is
          controlled by a resource limit that can be changed; *note
          Limits on Resources::, for more information about the
          `RLIMIT_NOFILE' limit.

     `ENFILE' is not a possible error code for `dup2' because `dup2'
     does not create a new opening of a file; duplicate descriptors do
     not count toward the limit which `ENFILE' indicates.  `EMFILE' is
     possible because it refers to the limit on distinct descriptor
     numbers in use in one process.

   Here is an example showing how to use `dup2' to do redirection.
Typically, redirection of the standard streams (like `stdin') is done
by a shell or shell-like program before calling one of the `exec'
functions (*note Executing a File::) to execute a new program in a
child process.  When the new program is executed, it creates and
initializes the standard streams to point to the corresponding file
descriptors, before its `main' function is invoked.

   So, to redirect standard input to a file, the shell could do
something like:

     pid = fork ();
     if (pid == 0)
       {
         char *filename;
         char *program;
         int file;
         ...
         file = TEMP_FAILURE_RETRY (open (filename, O_RDONLY));
         dup2 (file, STDIN_FILENO);
         TEMP_FAILURE_RETRY (close (file));
         execv (program, NULL);
       }

   There is also a more detailed example showing how to implement
redirection in the context of a pipeline of processes in *Note
Launching Jobs::.


File: libc.info,  Node: Descriptor Flags,  Next: File Status Flags,  Prev: Duplicating Descriptors,  Up: Low-Level I/O

13.13 File Descriptor Flags
===========================

"File descriptor flags" are miscellaneous attributes of a file
descriptor.  These flags are associated with particular file
descriptors, so that if you have created duplicate file descriptors
from a single opening of a file, each descriptor has its own set of
flags.

   Currently there is just one file descriptor flag: `FD_CLOEXEC',
which causes the descriptor to be closed if you use any of the
`exec...' functions (*note Executing a File::).

   The symbols in this section are defined in the header file `fcntl.h'.  

 -- Macro: int F_GETFD
     This macro is used as the COMMAND argument to `fcntl', to specify
     that it should return the file descriptor flags associated with
     the FILEDES argument.

     The normal return value from `fcntl' with this command is a
     nonnegative number which can be interpreted as the bitwise OR of
     the individual flags (except that currently there is only one flag
     to use).

     In case of an error, `fcntl' returns -1.  The following `errno'
     error conditions are defined for this command:

    `EBADF'
          The FILEDES argument is invalid.

 -- Macro: int F_SETFD
     This macro is used as the COMMAND argument to `fcntl', to specify
     that it should set the file descriptor flags associated with the
     FILEDES argument.  This requires a third `int' argument to specify
     the new flags, so the form of the call is:

          fcntl (FILEDES, F_SETFD, NEW-FLAGS)

     The normal return value from `fcntl' with this command is an
     unspecified value other than -1, which indicates an error.  The
     flags and error conditions are the same as for the `F_GETFD'
     command.

   The following macro is defined for use as a file descriptor flag with
the `fcntl' function.  The value is an integer constant usable as a bit
mask value.

 -- Macro: int FD_CLOEXEC
     This flag specifies that the file descriptor should be closed when
     an `exec' function is invoked; see *Note Executing a File::.  When
     a file descriptor is allocated (as with `open' or `dup'), this bit
     is initially cleared on the new file descriptor, meaning that
     descriptor will survive into the new program after `exec'.

   If you want to modify the file descriptor flags, you should get the
current flags with `F_GETFD' and modify the value.  Don't assume that
the flags listed here are the only ones that are implemented; your
program may be run years from now and more flags may exist then.  For
example, here is a function to set or clear the flag `FD_CLOEXEC'
without altering any other flags:

     /* Set the `FD_CLOEXEC' flag of DESC if VALUE is nonzero,
        or clear the flag if VALUE is 0.
        Return 0 on success, or -1 on error with `errno' set. */

     int
     set_cloexec_flag (int desc, int value)
     {
       int oldflags = fcntl (desc, F_GETFD, 0);
       /* If reading the flags failed, return error indication now. */
       if (oldflags < 0)
         return oldflags;
       /* Set just the flag we want to set. */
       if (value != 0)
         oldflags |= FD_CLOEXEC;
       else
         oldflags &= ~FD_CLOEXEC;
       /* Store modified flag word in the descriptor. */
       return fcntl (desc, F_SETFD, oldflags);
     }


File: libc.info,  Node: File Status Flags,  Next: File Locks,  Prev: Descriptor Flags,  Up: Low-Level I/O

13.14 File Status Flags
=======================

"File status flags" are used to specify attributes of the opening of a
file.  Unlike the file descriptor flags discussed in *Note Descriptor
Flags::, the file status flags are shared by duplicated file descriptors
resulting from a single opening of the file.  The file status flags are
specified with the FLAGS argument to `open'; *note Opening and Closing
Files::.

   File status flags fall into three categories, which are described in
the following sections.

   * *Note Access Modes::, specify what type of access is allowed to the
     file: reading, writing, or both.  They are set by `open' and are
     returned by `fcntl', but cannot be changed.

   * *Note Open-time Flags::, control details of what `open' will do.
     These flags are not preserved after the `open' call.

   * *Note Operating Modes::, affect how operations such as `read' and
     `write' are done.  They are set by `open', and can be fetched or
     changed with `fcntl'.

   The symbols in this section are defined in the header file `fcntl.h'.  

* Menu:

* Access Modes::                Whether the descriptor can read or write.
* Open-time Flags::             Details of `open'.
* Operating Modes::             Special modes to control I/O operations.
* Getting File Status Flags::   Fetching and changing these flags.


File: libc.info,  Node: Access Modes,  Next: Open-time Flags,  Up: File Status Flags

13.14.1 File Access Modes
-------------------------

The file access modes allow a file descriptor to be used for reading,
writing, or both.  (In the GNU system, they can also allow none of
these, and allow execution of the file as a program.)  The access modes
are chosen when the file is opened, and never change.

 -- Macro: int O_RDONLY
     Open the file for read access.

 -- Macro: int O_WRONLY
     Open the file for write access.

 -- Macro: int O_RDWR
     Open the file for both reading and writing.

   In the GNU system (and not in other systems), `O_RDONLY' and
`O_WRONLY' are independent bits that can be bitwise-ORed together, and
it is valid for either bit to be set or clear.  This means that
`O_RDWR' is the same as `O_RDONLY|O_WRONLY'.  A file access mode of
zero is permissible; it allows no operations that do input or output to
the file, but does allow other operations such as `fchmod'.  On the GNU
system, since "read-only" or "write-only" is a misnomer, `fcntl.h'
defines additional names for the file access modes.  These names are
preferred when writing GNU-specific code.  But most programs will want
to be portable to other POSIX.1 systems and should use the POSIX.1
names above instead.

 -- Macro: int O_READ
     Open the file for reading.  Same as `O_RDONLY'; only defined on
     GNU.

 -- Macro: int O_WRITE
     Open the file for writing.  Same as `O_WRONLY'; only defined on
     GNU.

 -- Macro: int O_EXEC
     Open the file for executing.  Only defined on GNU.

   To determine the file access mode with `fcntl', you must extract the
access mode bits from the retrieved file status flags.  In the GNU
system, you can just test the `O_READ' and `O_WRITE' bits in the flags
word.  But in other POSIX.1 systems, reading and writing access modes
are not stored as distinct bit flags.  The portable way to extract the
file access mode bits is with `O_ACCMODE'.

 -- Macro: int O_ACCMODE
     This macro stands for a mask that can be bitwise-ANDed with the
     file status flag value to produce a value representing the file
     access mode.  The mode will be `O_RDONLY', `O_WRONLY', or `O_RDWR'.
     (In the GNU system it could also be zero, and it never includes the
     `O_EXEC' bit.)


File: libc.info,  Node: Open-time Flags,  Next: Operating Modes,  Prev: Access Modes,  Up: File Status Flags

13.14.2 Open-time Flags
-----------------------

The open-time flags specify options affecting how `open' will behave.
These options are not preserved once the file is open.  The exception to
this is `O_NONBLOCK', which is also an I/O operating mode and so it
_is_ saved.  *Note Opening and Closing Files::, for how to call `open'.

   There are two sorts of options specified by open-time flags.

   * "File name translation flags" affect how `open' looks up the file
     name to locate the file, and whether the file can be created.  

   * "Open-time action flags" specify extra operations that `open' will
     perform on the file once it is open.  

   Here are the file name translation flags.

 -- Macro: int O_CREAT
     If set, the file will be created if it doesn't already exist.  

 -- Macro: int O_EXCL
     If both `O_CREAT' and `O_EXCL' are set, then `open' fails if the
     specified file already exists.  This is guaranteed to never
     clobber an existing file.

 -- Macro: int O_NONBLOCK
     This prevents `open' from blocking for a "long time" to open the
     file.  This is only meaningful for some kinds of files, usually
     devices such as serial ports; when it is not meaningful, it is
     harmless and ignored.  Often opening a port to a modem blocks
     until the modem reports carrier detection; if `O_NONBLOCK' is
     specified, `open' will return immediately without a carrier.

     Note that the `O_NONBLOCK' flag is overloaded as both an I/O
     operating mode and a file name translation flag.  This means that
     specifying `O_NONBLOCK' in `open' also sets nonblocking I/O mode;
     *note Operating Modes::.  To open the file without blocking but do
     normal I/O that blocks, you must call `open' with `O_NONBLOCK' set
     and then call `fcntl' to turn the bit off.

 -- Macro: int O_NOCTTY
     If the named file is a terminal device, don't make it the
     controlling terminal for the process.  *Note Job Control::, for
     information about what it means to be the controlling terminal.

     In the GNU system and 4.4 BSD, opening a file never makes it the
     controlling terminal and `O_NOCTTY' is zero.  However, other
     systems may use a nonzero value for `O_NOCTTY' and set the
     controlling terminal when you open a file that is a terminal
     device; so to be portable, use `O_NOCTTY' when it is important to
     avoid this.  

   The following three file name translation flags exist only in the
GNU system.

 -- Macro: int O_IGNORE_CTTY
     Do not recognize the named file as the controlling terminal, even
     if it refers to the process's existing controlling terminal
     device.  Operations on the new file descriptor will never induce
     job control signals.  *Note Job Control::.

 -- Macro: int O_NOLINK
     If the named file is a symbolic link, open the link itself instead
     of the file it refers to.  (`fstat' on the new file descriptor will
     return the information returned by `lstat' on the link's name.)  

 -- Macro: int O_NOTRANS
     If the named file is specially translated, do not invoke the
     translator.  Open the bare file the translator itself sees.

   The open-time action flags tell `open' to do additional operations
which are not really related to opening the file.  The reason to do them
as part of `open' instead of in separate calls is that `open' can do
them atomically.

 -- Macro: int O_TRUNC
     Truncate the file to zero length.  This option is only useful for
     regular files, not special files such as directories or FIFOs.
     POSIX.1 requires that you open the file for writing to use
     `O_TRUNC'.  In BSD and GNU you must have permission to write the
     file to truncate it, but you need not open for write access.

     This is the only open-time action flag specified by POSIX.1.
     There is no good reason for truncation to be done by `open',
     instead of by calling `ftruncate' afterwards.  The `O_TRUNC' flag
     existed in Unix before `ftruncate' was invented, and is retained
     for backward compatibility.

   The remaining operating modes are BSD extensions.  They exist only
on some systems.  On other systems, these macros are not defined.

 -- Macro: int O_SHLOCK
     Acquire a shared lock on the file, as with `flock'.  *Note File
     Locks::.

     If `O_CREAT' is specified, the locking is done atomically when
     creating the file.  You are guaranteed that no other process will
     get the lock on the new file first.

 -- Macro: int O_EXLOCK
     Acquire an exclusive lock on the file, as with `flock'.  *Note
     File Locks::.  This is atomic like `O_SHLOCK'.


File: libc.info,  Node: Operating Modes,  Next: Getting File Status Flags,  Prev: Open-time Flags,  Up: File Status Flags

13.14.3 I/O Operating Modes
---------------------------

The operating modes affect how input and output operations using a file
descriptor work.  These flags are set by `open' and can be fetched and
changed with `fcntl'.

 -- Macro: int O_APPEND
     The bit that enables append mode for the file.  If set, then all
     `write' operations write the data at the end of the file, extending
     it, regardless of the current file position.  This is the only
     reliable way to append to a file.  In append mode, you are
     guaranteed that the data you write will always go to the current
     end of the file, regardless of other processes writing to the
     file.  Conversely, if you simply set the file position to the end
     of file and write, then another process can extend the file after
     you set the file position but before you write, resulting in your
     data appearing someplace before the real end of file.

 -- Macro: int O_NONBLOCK
     The bit that enables nonblocking mode for the file.  If this bit
     is set, `read' requests on the file can return immediately with a
     failure status if there is no input immediately available, instead
     of blocking.  Likewise, `write' requests can also return
     immediately with a failure status if the output can't be written
     immediately.

     Note that the `O_NONBLOCK' flag is overloaded as both an I/O
     operating mode and a file name translation flag; *note Open-time
     Flags::.

 -- Macro: int O_NDELAY
     This is an obsolete name for `O_NONBLOCK', provided for
     compatibility with BSD.  It is not defined by the POSIX.1 standard.

   The remaining operating modes are BSD and GNU extensions.  They
exist only on some systems.  On other systems, these macros are not
defined.

 -- Macro: int O_ASYNC
     The bit that enables asynchronous input mode.  If set, then `SIGIO'
     signals will be generated when input is available.  *Note
     Interrupt Input::.

     Asynchronous input mode is a BSD feature.

 -- Macro: int O_FSYNC
     The bit that enables synchronous writing for the file.  If set,
     each `write' call will make sure the data is reliably stored on
     disk before returning.  Synchronous writing is a BSD feature.

 -- Macro: int O_SYNC
     This is another name for `O_FSYNC'.  They have the same value.

 -- Macro: int O_NOATIME
     If this bit is set, `read' will not update the access time of the
     file.  *Note File Times::.  This is used by programs that do
     backups, so that backing a file up does not count as reading it.
     Only the owner of the file or the superuser may use this bit.

     This is a GNU extension.


File: libc.info,  Node: Getting File Status Flags,  Prev: Operating Modes,  Up: File Status Flags

13.14.4 Getting and Setting File Status Flags
---------------------------------------------

The `fcntl' function can fetch or change file status flags.

 -- Macro: int F_GETFL
     This macro is used as the COMMAND argument to `fcntl', to read the
     file status flags for the open file with descriptor FILEDES.

     The normal return value from `fcntl' with this command is a
     nonnegative number which can be interpreted as the bitwise OR of
     the individual flags.  Since the file access modes are not
     single-bit values, you can mask off other bits in the returned
     flags with `O_ACCMODE' to compare them.

     In case of an error, `fcntl' returns -1.  The following `errno'
     error conditions are defined for this command:

    `EBADF'
          The FILEDES argument is invalid.

 -- Macro: int F_SETFL
     This macro is used as the COMMAND argument to `fcntl', to set the
     file status flags for the open file corresponding to the FILEDES
     argument.  This command requires a third `int' argument to specify
     the new flags, so the call looks like this:

          fcntl (FILEDES, F_SETFL, NEW-FLAGS)

     You can't change the access mode for the file in this way; that is,
     whether the file descriptor was opened for reading or writing.

     The normal return value from `fcntl' with this command is an
     unspecified value other than -1, which indicates an error.  The
     error conditions are the same as for the `F_GETFL' command.

   If you want to modify the file status flags, you should get the
current flags with `F_GETFL' and modify the value.  Don't assume that
the flags listed here are the only ones that are implemented; your
program may be run years from now and more flags may exist then.  For
example, here is a function to set or clear the flag `O_NONBLOCK'
without altering any other flags:

     /* Set the `O_NONBLOCK' flag of DESC if VALUE is nonzero,
        or clear the flag if VALUE is 0.
        Return 0 on success, or -1 on error with `errno' set. */

     int
     set_nonblock_flag (int desc, int value)
     {
       int oldflags = fcntl (desc, F_GETFL, 0);
       /* If reading the flags failed, return error indication now. */
       if (oldflags == -1)
         return -1;
       /* Set just the flag we want to set. */
       if (value != 0)
         oldflags |= O_NONBLOCK;
       else
         oldflags &= ~O_NONBLOCK;
       /* Store modified flag word in the descriptor. */
       return fcntl (desc, F_SETFL, oldflags);
     }


File: libc.info,  Node: File Locks,  Next: Interrupt Input,  Prev: File Status Flags,  Up: Low-Level I/O

13.15 File Locks
================

The remaining `fcntl' commands are used to support "record locking",
which permits multiple cooperating programs to prevent each other from
simultaneously accessing parts of a file in error-prone ways.

   An "exclusive" or "write" lock gives a process exclusive access for
writing to the specified part of the file.  While a write lock is in
place, no other process can lock that part of the file.

   A "shared" or "read" lock prohibits any other process from
requesting a write lock on the specified part of the file.  However,
other processes can request read locks.

   The `read' and `write' functions do not actually check to see
whether there are any locks in place.  If you want to implement a
locking protocol for a file shared by multiple processes, your
application must do explicit `fcntl' calls to request and clear locks
at the appropriate points.

   Locks are associated with processes.  A process can only have one
kind of lock set for each byte of a given file.  When any file
descriptor for that file is closed by the process, all of the locks
that process holds on that file are released, even if the locks were
made using other descriptors that remain open.  Likewise, locks are
released when a process exits, and are not inherited by child processes
created using `fork' (*note Creating a Process::).

   When making a lock, use a `struct flock' to specify what kind of
lock and where.  This data type and the associated macros for the
`fcntl' function are declared in the header file `fcntl.h'.  

 -- Data Type: struct flock
     This structure is used with the `fcntl' function to describe a file
     lock.  It has these members:

    `short int l_type'
          Specifies the type of the lock; one of `F_RDLCK', `F_WRLCK',
          or `F_UNLCK'.

    `short int l_whence'
          This corresponds to the WHENCE argument to `fseek' or
          `lseek', and specifies what the offset is relative to.  Its
          value can be one of `SEEK_SET', `SEEK_CUR', or `SEEK_END'.

    `off_t l_start'
          This specifies the offset of the start of the region to which
          the lock applies, and is given in bytes relative to the point
          specified by `l_whence' member.

    `off_t l_len'
          This specifies the length of the region to be locked.  A
          value of `0' is treated specially; it means the region
          extends to the end of the file.

    `pid_t l_pid'
          This field is the process ID (*note Process Creation
          Concepts::) of the process holding the lock.  It is filled in
          by calling `fcntl' with the `F_GETLK' command, but is ignored
          when making a lock.

 -- Macro: int F_GETLK
     This macro is used as the COMMAND argument to `fcntl', to specify
     that it should get information about a lock.  This command
     requires a third argument of type `struct flock *' to be passed to
     `fcntl', so that the form of the call is:

          fcntl (FILEDES, F_GETLK, LOCKP)

     If there is a lock already in place that would block the lock
     described by the LOCKP argument, information about that lock
     overwrites `*LOCKP'.  Existing locks are not reported if they are
     compatible with making a new lock as specified.  Thus, you should
     specify a lock type of `F_WRLCK' if you want to find out about both
     read and write locks, or `F_RDLCK' if you want to find out about
     write locks only.

     There might be more than one lock affecting the region specified
     by the LOCKP argument, but `fcntl' only returns information about
     one of them.  The `l_whence' member of the LOCKP structure is set
     to `SEEK_SET' and the `l_start' and `l_len' fields set to identify
     the locked region.

     If no lock applies, the only change to the LOCKP structure is to
     update the `l_type' to a value of `F_UNLCK'.

     The normal return value from `fcntl' with this command is an
     unspecified value other than -1, which is reserved to indicate an
     error.  The following `errno' error conditions are defined for
     this command:

    `EBADF'
          The FILEDES argument is invalid.

    `EINVAL'
          Either the LOCKP argument doesn't specify valid lock
          information, or the file associated with FILEDES doesn't
          support locks.

 -- Macro: int F_SETLK
     This macro is used as the COMMAND argument to `fcntl', to specify
     that it should set or clear a lock.  This command requires a third
     argument of type `struct flock *' to be passed to `fcntl', so that
     the form of the call is:

          fcntl (FILEDES, F_SETLK, LOCKP)

     If the process already has a lock on any part of the region, the
     old lock on that part is replaced with the new lock.  You can
     remove a lock by specifying a lock type of `F_UNLCK'.

     If the lock cannot be set, `fcntl' returns immediately with a value
     of -1.  This function does not block waiting for other processes
     to release locks.  If `fcntl' succeeds, it return a value other
     than -1.

     The following `errno' error conditions are defined for this
     function:

    `EAGAIN'
    `EACCES'
          The lock cannot be set because it is blocked by an existing
          lock on the file.  Some systems use `EAGAIN' in this case,
          and other systems use `EACCES'; your program should treat
          them alike, after `F_SETLK'.  (The GNU system always uses
          `EAGAIN'.)

    `EBADF'
          Either: the FILEDES argument is invalid; you requested a read
          lock but the FILEDES is not open for read access; or, you
          requested a write lock but the FILEDES is not open for write
          access.

    `EINVAL'
          Either the LOCKP argument doesn't specify valid lock
          information, or the file associated with FILEDES doesn't
          support locks.

    `ENOLCK'
          The system has run out of file lock resources; there are
          already too many file locks in place.

          Well-designed file systems never report this error, because
          they have no limitation on the number of locks.  However, you
          must still take account of the possibility of this error, as
          it could result from network access to a file system on
          another machine.

 -- Macro: int F_SETLKW
     This macro is used as the COMMAND argument to `fcntl', to specify
     that it should set or clear a lock.  It is just like the `F_SETLK'
     command, but causes the process to block (or wait) until the
     request can be specified.

     This command requires a third argument of type `struct flock *', as
     for the `F_SETLK' command.

     The `fcntl' return values and errors are the same as for the
     `F_SETLK' command, but these additional `errno' error conditions
     are defined for this command:

    `EINTR'
          The function was interrupted by a signal while it was waiting.
          *Note Interrupted Primitives::.

    `EDEADLK'
          The specified region is being locked by another process.  But
          that process is waiting to lock a region which the current
          process has locked, so waiting for the lock would result in
          deadlock.  The system does not guarantee that it will detect
          all such conditions, but it lets you know if it notices one.

   The following macros are defined for use as values for the `l_type'
member of the `flock' structure.  The values are integer constants.

`F_RDLCK'
     This macro is used to specify a read (or shared) lock.

`F_WRLCK'
     This macro is used to specify a write (or exclusive) lock.

`F_UNLCK'
     This macro is used to specify that the region is unlocked.

   As an example of a situation where file locking is useful, consider a
program that can be run simultaneously by several different users, that
logs status information to a common file.  One example of such a program
might be a game that uses a file to keep track of high scores.  Another
example might be a program that records usage or accounting information
for billing purposes.

   Having multiple copies of the program simultaneously writing to the
file could cause the contents of the file to become mixed up.  But you
can prevent this kind of problem by setting a write lock on the file
before actually writing to the file.

   If the program also needs to read the file and wants to make sure
that the contents of the file are in a consistent state, then it can
also use a read lock.  While the read lock is set, no other process can
lock that part of the file for writing.

   Remember that file locks are only a _voluntary_ protocol for
controlling access to a file.  There is still potential for access to
the file by programs that don't use the lock protocol.


File: libc.info,  Node: Interrupt Input,  Next: IOCTLs,  Prev: File Locks,  Up: Low-Level I/O

13.16 Interrupt-Driven Input
============================

If you set the `O_ASYNC' status flag on a file descriptor (*note File
Status Flags::), a `SIGIO' signal is sent whenever input or output
becomes possible on that file descriptor.  The process or process group
to receive the signal can be selected by using the `F_SETOWN' command
to the `fcntl' function.  If the file descriptor is a socket, this also
selects the recipient of `SIGURG' signals that are delivered when
out-of-band data arrives on that socket; see *Note Out-of-Band Data::.
(`SIGURG' is sent in any situation where `select' would report the
socket as having an "exceptional condition".  *Note Waiting for I/O::.)

   If the file descriptor corresponds to a terminal device, then `SIGIO'
signals are sent to the foreground process group of the terminal.
*Note Job Control::.

   The symbols in this section are defined in the header file `fcntl.h'.

 -- Macro: int F_GETOWN
     This macro is used as the COMMAND argument to `fcntl', to specify
     that it should get information about the process or process group
     to which `SIGIO' signals are sent.  (For a terminal, this is
     actually the foreground process group ID, which you can get using
     `tcgetpgrp'; see *Note Terminal Access Functions::.)

     The return value is interpreted as a process ID; if negative, its
     absolute value is the process group ID.

     The following `errno' error condition is defined for this command:

    `EBADF'
          The FILEDES argument is invalid.

 -- Macro: int F_SETOWN
     This macro is used as the COMMAND argument to `fcntl', to specify
     that it should set the process or process group to which `SIGIO'
     signals are sent.  This command requires a third argument of type
     `pid_t' to be passed to `fcntl', so that the form of the call is:

          fcntl (FILEDES, F_SETOWN, PID)

     The PID argument should be a process ID.  You can also pass a
     negative number whose absolute value is a process group ID.

     The return value from `fcntl' with this command is -1 in case of
     error and some other value if successful.  The following `errno'
     error conditions are defined for this command:

    `EBADF'
          The FILEDES argument is invalid.

    `ESRCH'
          There is no process or process group corresponding to PID.


File: libc.info,  Node: IOCTLs,  Prev: Interrupt Input,  Up: Low-Level I/O

13.17 Generic I/O Control operations
====================================

The GNU system can handle most input/output operations on many different
devices and objects in terms of a few file primitives - `read', `write'
and `lseek'.  However, most devices also have a few peculiar operations
which do not fit into this model. Such as:

   * Changing the character font used on a terminal.

   * Telling a magnetic tape system to rewind or fast forward.  (Since
     they cannot move in byte increments, `lseek' is inapplicable).

   * Ejecting a disk from a drive.

   * Playing an audio track from a CD-ROM drive.

   * Maintaining routing tables for a network.


   Although some such objects such as sockets and terminals (1) have
special functions of their own, it would not be practical to create
functions for all these cases.

   Instead these minor operations, known as "IOCTL"s, are assigned code
numbers and multiplexed through the `ioctl' function, defined in
`sys/ioctl.h'.  The code numbers themselves are defined in many
different headers.

 -- Function: int ioctl (int FILEDES, int COMMAND, ...)
     The `ioctl' function performs the generic I/O operation COMMAND on
     FILEDES.

     A third argument is usually present, either a single number or a
     pointer to a structure.  The meaning of this argument, the
     returned value, and any error codes depends upon the command used.
     Often -1 is returned for a failure.


   On some systems, IOCTLs used by different devices share the same
numbers.  Thus, although use of an inappropriate IOCTL _usually_ only
produces an error, you should not attempt to use device-specific IOCTLs
on an unknown device.

   Most IOCTLs are OS-specific and/or only used in special system
utilities, and are thus beyond the scope of this document.  For an
example of the use of an IOCTL, see *Note Out-of-Band Data::.

   ---------- Footnotes ----------

   (1) Actually, the terminal-specific functions are implemented with
IOCTLs on many platforms.


File: libc.info,  Node: File System Interface,  Next: Pipes and FIFOs,  Prev: Low-Level I/O,  Up: Top

14 File System Interface
************************

This chapter describes the GNU C library's functions for manipulating
files.  Unlike the input and output functions (*note I/O on Streams::;
*note Low-Level I/O::), these functions are concerned with operating on
the files themselves rather than on their contents.

   Among the facilities described in this chapter are functions for
examining or modifying directories, functions for renaming and deleting
files, and functions for examining and setting file attributes such as
access permissions and modification times.

* Menu:

* Working Directory::           This is used to resolve relative
				 file names.
* Accessing Directories::       Finding out what files a directory
				 contains.
* Working with Directory Trees:: Apply actions to all files or a selectable
                                 subset of a directory hierarchy.
* Hard Links::                  Adding alternate names to a file.
* Symbolic Links::              A file that ``points to'' a file name.
* Deleting Files::              How to delete a file, and what that means.
* Renaming Files::              Changing a file's name.
* Creating Directories::        A system call just for creating a directory.
* File Attributes::             Attributes of individual files.
* Making Special Files::        How to create special files.
* Temporary Files::             Naming and creating temporary files.


File: libc.info,  Node: Working Directory,  Next: Accessing Directories,  Up: File System Interface

14.1 Working Directory
======================

Each process has associated with it a directory, called its "current
working directory" or simply "working directory", that is used in the
resolution of relative file names (*note File Name Resolution::).

   When you log in and begin a new session, your working directory is
initially set to the home directory associated with your login account
in the system user database.  You can find any user's home directory
using the `getpwuid' or `getpwnam' functions; see *Note User Database::.

   Users can change the working directory using shell commands like
`cd'.  The functions described in this section are the primitives used
by those commands and by other programs for examining and changing the
working directory.  

   Prototypes for these functions are declared in the header file
`unistd.h'.  

 -- Function: char * getcwd (char *BUFFER, size_t SIZE)
     The `getcwd' function returns an absolute file name representing
     the current working directory, storing it in the character array
     BUFFER that you provide.  The SIZE argument is how you tell the
     system the allocation size of BUFFER.

     The GNU library version of this function also permits you to
     specify a null pointer for the BUFFER argument.  Then `getcwd'
     allocates a buffer automatically, as with `malloc' (*note
     Unconstrained Allocation::).  If the SIZE is greater than zero,
     then the buffer is that large; otherwise, the buffer is as large
     as necessary to hold the result.

     The return value is BUFFER on success and a null pointer on
     failure.  The following `errno' error conditions are defined for
     this function:

    `EINVAL'
          The SIZE argument is zero and BUFFER is not a null pointer.

    `ERANGE'
          The SIZE argument is less than the length of the working
          directory name.  You need to allocate a bigger array and try
          again.

    `EACCES'
          Permission to read or search a component of the file name was
          denied.

   You could implement the behavior of GNU's `getcwd (NULL, 0)' using
only the standard behavior of `getcwd':

     char *
     gnu_getcwd ()
     {
       size_t size = 100;

       while (1)
         {
           char *buffer = (char *) xmalloc (size);
           if (getcwd (buffer, size) == buffer)
             return buffer;
           free (buffer);
           if (errno != ERANGE)
             return 0;
           size *= 2;
         }
     }

*Note Malloc Examples::, for information about `xmalloc', which is not
a library function but is a customary name used in most GNU software.

 -- Deprecated Function: char * getwd (char *BUFFER)
     This is similar to `getcwd', but has no way to specify the size of
     the buffer.  The GNU library provides `getwd' only for backwards
     compatibility with BSD.

     The BUFFER argument should be a pointer to an array at least
     `PATH_MAX' bytes long (*note Limits for Files::).  In the GNU
     system there is no limit to the size of a file name, so this is not
     necessarily enough space to contain the directory name.  That is
     why this function is deprecated.

 -- Function: char * get_current_dir_name (void)
     This `get_current_dir_name' function is basically equivalent to
     `getcwd (NULL, 0)'.  The only difference is that the value of the
     `PWD' variable is returned if this value is correct.  This is a
     subtle difference which is visible if the path described by the
     `PWD' value is using one or more symbol links in which case the
     value returned by `getcwd' can resolve the symbol links and
     therefore yield a different result.

     This function is a GNU extension.

 -- Function: int chdir (const char *FILENAME)
     This function is used to set the process's working directory to
     FILENAME.

     The normal, successful return value from `chdir' is `0'.  A value
     of `-1' is returned to indicate an error.  The `errno' error
     conditions defined for this function are the usual file name
     syntax errors (*note File Name Errors::), plus `ENOTDIR' if the
     file FILENAME is not a directory.

 -- Function: int fchdir (int FILEDES)
     This function is used to set the process's working directory to
     directory associated with the file descriptor FILEDES.

     The normal, successful return value from `fchdir' is `0'.  A value
     of `-1' is returned to indicate an error.  The following `errno'
     error conditions are defined for this function:

    `EACCES'
          Read permission is denied for the directory named by
          `dirname'.

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTDIR'
          The file descriptor FILEDES is not associated with a
          directory.

    `EINTR'
          The function call was interrupt by a signal.

    `EIO'
          An I/O error occurred.


File: libc.info,  Node: Accessing Directories,  Next: Working with Directory Trees,  Prev: Working Directory,  Up: File System Interface

14.2 Accessing Directories
==========================

The facilities described in this section let you read the contents of a
directory file.  This is useful if you want your program to list all the
files in a directory, perhaps as part of a menu.

   The `opendir' function opens a "directory stream" whose elements are
directory entries.  Alternatively `fdopendir' can be used which can
have advantages if the program needs to have more control over the way
the directory is opened for reading.  This allows, for instance, to
pass the `O_NOATIME' flag to `open'.

   You use the `readdir' function on the directory stream to retrieve
these entries, represented as `struct dirent' objects.  The name of the
file for each entry is stored in the `d_name' member of this structure.
There are obvious parallels here to the stream facilities for ordinary
files, described in *Note I/O on Streams::.

* Menu:

* Directory Entries::           Format of one directory entry.
* Opening a Directory::         How to open a directory stream.
* Reading/Closing Directory::   How to read directory entries from the stream.
* Simple Directory Lister::     A very simple directory listing program.
* Random Access Directory::     Rereading part of the directory
                                 already read with the same stream.
* Scanning Directory Content::  Get entries for user selected subset of
                                 contents in given directory.
* Simple Directory Lister Mark II::  Revised version of the program.


File: libc.info,  Node: Directory Entries,  Next: Opening a Directory,  Up: Accessing Directories

14.2.1 Format of a Directory Entry
----------------------------------

This section describes what you find in a single directory entry, as you
might obtain it from a directory stream.  All the symbols are declared
in the header file `dirent.h'.

 -- Data Type: struct dirent
     This is a structure type used to return information about directory
     entries.  It contains the following fields:

    `char d_name[]'
          This is the null-terminated file name component.  This is the
          only field you can count on in all POSIX systems.

    `ino_t d_fileno'
          This is the file serial number.  For BSD compatibility, you
          can also refer to this member as `d_ino'.  In the GNU system
          and most POSIX systems, for most files this the same as the
          `st_ino' member that `stat' will return for the file.  *Note
          File Attributes::.

    `unsigned char d_namlen'
          This is the length of the file name, not including the
          terminating null character.  Its type is `unsigned char'
          because that is the integer type of the appropriate size

    `unsigned char d_type'
          This is the type of the file, possibly unknown.  The
          following constants are defined for its value:

         `DT_UNKNOWN'
               The type is unknown.  On some systems this is the only
               value returned.

         `DT_REG'
               A regular file.

         `DT_DIR'
               A directory.

         `DT_FIFO'
               A named pipe, or FIFO.  *Note FIFO Special Files::.

         `DT_SOCK'
               A local-domain socket.

         `DT_CHR'
               A character device.

         `DT_BLK'
               A block device.

          This member is a BSD extension.  The symbol
          `_DIRENT_HAVE_D_TYPE' is defined if this member is available.
          On systems where it is used, it corresponds to the file type
          bits in the `st_mode' member of `struct statbuf'.  If the
          value cannot be determine the member value is DT_UNKNOWN.
          These two macros convert between `d_type' values and
          `st_mode' values:

           -- Function: int IFTODT (mode_t MODE)
               This returns the `d_type' value corresponding to MODE.

           -- Function: mode_t DTTOIF (int DTYPE)
               This returns the `st_mode' value corresponding to DTYPE.

     This structure may contain additional members in the future.  Their
     availability is always announced in the compilation environment by
     a macro names `_DIRENT_HAVE_D_XXX' where XXX is replaced by the
     name of the new member.  For instance, the member `d_reclen'
     available on some systems is announced through the macro
     `_DIRENT_HAVE_D_RECLEN'.

     When a file has multiple names, each name has its own directory
     entry.  The only way you can tell that the directory entries
     belong to a single file is that they have the same value for the
     `d_fileno' field.

     File attributes such as size, modification times etc., are part of
     the file itself, not of any particular directory entry.  *Note
     File Attributes::.


File: libc.info,  Node: Opening a Directory,  Next: Reading/Closing Directory,  Prev: Directory Entries,  Up: Accessing Directories

14.2.2 Opening a Directory Stream
---------------------------------

This section describes how to open a directory stream.  All the symbols
are declared in the header file `dirent.h'.

 -- Data Type: DIR
     The `DIR' data type represents a directory stream.

   You shouldn't ever allocate objects of the `struct dirent' or `DIR'
data types, since the directory access functions do that for you.
Instead, you refer to these objects using the pointers returned by the
following functions.

 -- Function: DIR * opendir (const char *DIRNAME)
     The `opendir' function opens and returns a directory stream for
     reading the directory whose file name is DIRNAME.  The stream has
     type `DIR *'.

     If unsuccessful, `opendir' returns a null pointer.  In addition to
     the usual file name errors (*note File Name Errors::), the
     following `errno' error conditions are defined for this function:

    `EACCES'
          Read permission is denied for the directory named by
          `dirname'.

    `EMFILE'
          The process has too many files open.

    `ENFILE'
          The entire system, or perhaps the file system which contains
          the directory, cannot support any additional open files at
          the moment.  (This problem cannot happen on the GNU system.)

    `ENOMEM'
          Not enough memory available.

     The `DIR' type is typically implemented using a file descriptor,
     and the `opendir' function in terms of the `open' function.  *Note
     Low-Level I/O::.  Directory streams and the underlying file
     descriptors are closed on `exec' (*note Executing a File::).

   The directory which is opened for reading by `opendir' is identified
by the name.  In some situations this is not sufficient.  Or the way
`opendir' implicitly creates a file descriptor for the directory is not
the way a program might want it.  In these cases an alternative
interface can be used.

 -- Function: DIR * fdopendir (int FD)
     The `fdopendir' function works just like `opendir' but instead of
     taking a file name and opening a file descriptor for the directory
     the caller is required to provide a file descriptor.  This file
     descriptor is then used in subsequent uses of the returned
     directory stream object.

     The caller must make sure the file descriptor is associated with a
     directory and it allows reading.

     If the `fdopendir' call returns successfully the file descriptor
     is now under the control of the system.  It can be used in the same
     way the descriptor implicitly created by `opendir' can be used but
     the program must not close the descriptor.

     In case the function is unsuccessful it returns a null pointer and
     the file descriptor remains to be usable by the program.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          The file descriptor is not valid.

    `ENOTDIR'
          The file descriptor is not associated with a directory.

    `EINVAL'
          The descriptor does not allow reading the directory content.

    `ENOMEM'
          Not enough memory available.

   In some situations it can be desirable to get hold of the file
descriptor which is created by the `opendir' call.  For instance, to
switch the current working directory to the directory just read the
`fchdir' function could be used.  Historically the `DIR' type was
exposed and programs could access the fields.  This does not happen in
the GNU C library.  Instead a separate function is provided to allow
access.

 -- Function: int dirfd (DIR *DIRSTREAM)
     The function `dirfd' returns the file descriptor associated with
     the directory stream DIRSTREAM.  This descriptor can be used until
     the directory is closed with `closedir'.  If the directory stream
     implementation is not using file descriptors the return value is
     `-1'.


File: libc.info,  Node: Reading/Closing Directory,  Next: Simple Directory Lister,  Prev: Opening a Directory,  Up: Accessing Directories

14.2.3 Reading and Closing a Directory Stream
---------------------------------------------

This section describes how to read directory entries from a directory
stream, and how to close the stream when you are done with it.  All the
symbols are declared in the header file `dirent.h'.

 -- Function: struct dirent * readdir (DIR *DIRSTREAM)
     This function reads the next entry from the directory.  It normally
     returns a pointer to a structure containing information about the
     file.  This structure is statically allocated and can be rewritten
     by a subsequent call.

     *Portability Note:* On some systems `readdir' may not return
     entries for `.' and `..', even though these are always valid file
     names in any directory.  *Note File Name Resolution::.

     If there are no more entries in the directory or an error is
     detected, `readdir' returns a null pointer.  The following `errno'
     error conditions are defined for this function:

    `EBADF'
          The DIRSTREAM argument is not valid.

     `readdir' is not thread safe.  Multiple threads using `readdir' on
     the same DIRSTREAM may overwrite the return value.  Use
     `readdir_r' when this is critical.

 -- Function: int readdir_r (DIR *DIRSTREAM, struct dirent *ENTRY,
          struct dirent **RESULT)
     This function is the reentrant version of `readdir'.  Like
     `readdir' it returns the next entry from the directory.  But to
     prevent conflicts between simultaneously running threads the
     result is not stored in statically allocated memory.  Instead the
     argument ENTRY points to a place to store the result.

     Normally `readdir_r' returns zero and sets `*RESULT' to ENTRY.  If
     there are no more entries in the directory or an error is
     detected, `readdir_r' sets `*RESULT' to a null pointer and returns
     a nonzero error code, also stored in `errno', as described for
     `readdir'.

     *Portability Note:* On some systems `readdir_r' may not return a
     NUL terminated string for the file name, even when there is no
     `d_reclen' field in `struct dirent' and the file name is the
     maximum allowed size.  Modern systems all have the `d_reclen'
     field, and on old systems multi-threading is not critical.  In any
     case there is no such problem with the `readdir' function, so that
     even on systems without the `d_reclen' member one could use
     multiple threads by using external locking.

     It is also important to look at the definition of the `struct
     dirent' type.  Simply passing a pointer to an object of this type
     for the second parameter of `readdir_r' might not be enough.  Some
     systems don't define the `d_name' element sufficiently long.  In
     this case the user has to provide additional space.  There must be
     room for at least `NAME_MAX + 1' characters in the `d_name' array.
     Code to call `readdir_r' could look like this:

            union
            {
              struct dirent d;
              char b[offsetof (struct dirent, d_name) + NAME_MAX + 1];
            } u;

            if (readdir_r (dir, &u.d, &res) == 0)
              ...

   To support large filesystems on 32-bit machines there are LFS
variants of the last two functions.

 -- Function: struct dirent64 * readdir64 (DIR *DIRSTREAM)
     The `readdir64' function is just like the `readdir' function
     except that it returns a pointer to a record of type `struct
     dirent64'.  Some of the members of this data type (notably `d_ino')
     might have a different size to allow large filesystems.

     In all other aspects this function is equivalent to `readdir'.

 -- Function: int readdir64_r (DIR *DIRSTREAM, struct dirent64 *ENTRY,
          struct dirent64 **RESULT)
     The `readdir64_r' function is equivalent to the `readdir_r'
     function except that it takes parameters of base type `struct
     dirent64' instead of `struct dirent' in the second and third
     position.  The same precautions mentioned in the documentation of
     `readdir_r' also apply here.

 -- Function: int closedir (DIR *DIRSTREAM)
     This function closes the directory stream DIRSTREAM.  It returns
     `0' on success and `-1' on failure.

     The following `errno' error conditions are defined for this
     function:

    `EBADF'
          The DIRSTREAM argument is not valid.


File: libc.info,  Node: Simple Directory Lister,  Next: Random Access Directory,  Prev: Reading/Closing Directory,  Up: Accessing Directories

14.2.4 Simple Program to List a Directory
-----------------------------------------

Here's a simple program that prints the names of the files in the
current working directory:

     #include <stdio.h>
     #include <sys/types.h>
     #include <dirent.h>

     int
     main (void)
     {
       DIR *dp;
       struct dirent *ep;

       dp = opendir ("./");
       if (dp != NULL)
         {
           while (ep = readdir (dp))
             puts (ep->d_name);
           (void) closedir (dp);
         }
       else
         perror ("Couldn't open the directory");

       return 0;
     }

   The order in which files appear in a directory tends to be fairly
random.  A more useful program would sort the entries (perhaps by
alphabetizing them) before printing them; see *Note Scanning Directory
Content::, and *Note Array Sort Function::.


File: libc.info,  Node: Random Access Directory,  Next: Scanning Directory Content,  Prev: Simple Directory Lister,  Up: Accessing Directories

14.2.5 Random Access in a Directory Stream
------------------------------------------

This section describes how to reread parts of a directory that you have
already read from an open directory stream.  All the symbols are
declared in the header file `dirent.h'.

 -- Function: void rewinddir (DIR *DIRSTREAM)
     The `rewinddir' function is used to reinitialize the directory
     stream DIRSTREAM, so that if you call `readdir' it returns
     information about the first entry in the directory again.  This
     function also notices if files have been added or removed to the
     directory since it was opened with `opendir'.  (Entries for these
     files might or might not be returned by `readdir' if they were
     added or removed since you last called `opendir' or `rewinddir'.)

 -- Function: long int telldir (DIR *DIRSTREAM)
     The `telldir' function returns the file position of the directory
     stream DIRSTREAM.  You can use this value with `seekdir' to
     restore the directory stream to that position.

 -- Function: void seekdir (DIR *DIRSTREAM, long int POS)
     The `seekdir' function sets the file position of the directory
     stream DIRSTREAM to POS.  The value POS must be the result of a
     previous call to `telldir' on this particular stream; closing and
     reopening the directory can invalidate values returned by
     `telldir'.


File: libc.info,  Node: Scanning Directory Content,  Next: Simple Directory Lister Mark II,  Prev: Random Access Directory,  Up: Accessing Directories

14.2.6 Scanning the Content of a Directory
------------------------------------------

A higher-level interface to the directory handling functions is the
`scandir' function.  With its help one can select a subset of the
entries in a directory, possibly sort them and get a list of names as
the result.

 -- Function: int scandir (const char *DIR, struct dirent ***NAMELIST,
          int (*SELECTOR) (const struct dirent *), int (*CMP) (const
          void *, const void *))
     The `scandir' function scans the contents of the directory selected
     by DIR.  The result in *NAMELIST is an array of pointers to
     structure of type `struct dirent' which describe all selected
     directory entries and which is allocated using `malloc'.  Instead
     of always getting all directory entries returned, the user supplied
     function SELECTOR can be used to decide which entries are in the
     result.  Only the entries for which SELECTOR returns a non-zero
     value are selected.

     Finally the entries in *NAMELIST are sorted using the
     user-supplied function CMP.  The arguments passed to the CMP
     function are of type `struct dirent **', therefore one cannot
     directly use the `strcmp' or `strcoll' functions; instead see the
     functions `alphasort' and `versionsort' below.

     The return value of the function is the number of entries placed in
     *NAMELIST.  If it is `-1' an error occurred (either the directory
     could not be opened for reading or the malloc call failed) and the
     global variable `errno' contains more information on the error.

   As described above the fourth argument to the `scandir' function
must be a pointer to a sorting function.  For the convenience of the
programmer the GNU C library contains implementations of functions which
are very helpful for this purpose.

 -- Function: int alphasort (const void *A, const void *B)
     The `alphasort' function behaves like the `strcoll' function
     (*note String/Array Comparison::).  The difference is that the
     arguments are not string pointers but instead they are of type
     `struct dirent **'.

     The return value of `alphasort' is less than, equal to, or greater
     than zero depending on the order of the two entries A and B.

 -- Function: int versionsort (const void *A, const void *B)
     The `versionsort' function is like `alphasort' except that it uses
     the `strverscmp' function internally.

   If the filesystem supports large files we cannot use the `scandir'
anymore since the `dirent' structure might not able to contain all the
information.  The LFS provides the new type `struct dirent64'.  To use
this we need a new function.

 -- Function: int scandir64 (const char *DIR, struct dirent64
          ***NAMELIST, int (*SELECTOR) (const struct dirent64 *), int
          (*CMP) (const void *, const void *))
     The `scandir64' function works like the `scandir' function except
     that the directory entries it returns are described by elements of
     type `struct dirent64'.  The function pointed to by SELECTOR is
     again used to select the desired entries, except that SELECTOR now
     must point to a function which takes a `struct dirent64 *'
     parameter.

     Similarly the CMP function should expect its two arguments to be
     of type `struct dirent64 **'.

   As CMP is now a function of a different type, the functions
`alphasort' and `versionsort' cannot be supplied for that argument.
Instead we provide the two replacement functions below.

 -- Function: int alphasort64 (const void *A, const void *B)
     The `alphasort64' function behaves like the `strcoll' function
     (*note String/Array Comparison::).  The difference is that the
     arguments are not string pointers but instead they are of type
     `struct dirent64 **'.

     Return value of `alphasort64' is less than, equal to, or greater
     than zero depending on the order of the two entries A and B.

 -- Function: int versionsort64 (const void *A, const void *B)
     The `versionsort64' function is like `alphasort64', excepted that
     it uses the `strverscmp' function internally.

   It is important not to mix the use of `scandir' and the 64-bit
comparison functions or vice versa.  There are systems on which this
works but on others it will fail miserably.


File: libc.info,  Node: Simple Directory Lister Mark II,  Prev: Scanning Directory Content,  Up: Accessing Directories

14.2.7 Simple Program to List a Directory, Mark II
--------------------------------------------------

Here is a revised version of the directory lister found above (*note
Simple Directory Lister::).  Using the `scandir' function we can avoid
the functions which work directly with the directory contents.  After
the call the returned entries are available for direct use.

     #include <stdio.h>
     #include <dirent.h>

     static int
     one (const struct dirent *unused)
     {
       return 1;
     }

     int
     main (void)
     {
       struct dirent **eps;
       int n;

       n = scandir ("./", &eps, one, alphasort);
       if (n >= 0)
         {
           int cnt;
           for (cnt = 0; cnt < n; ++cnt)
             puts (eps[cnt]->d_name);
         }
       else
         perror ("Couldn't open the directory");

       return 0;
     }

   Note the simple selector function in this example.  Since we want to
see all directory entries we always return `1'.


File: libc.info,  Node: Working with Directory Trees,  Next: Hard Links,  Prev: Accessing Directories,  Up: File System Interface

14.3 Working with Directory Trees
=================================

The functions described so far for handling the files in a directory
have allowed you to either retrieve the information bit by bit, or to
process all the files as a group (see `scandir').  Sometimes it is
useful to process whole hierarchies of directories and their contained
files.  The X/Open specification defines two functions to do this.  The
simpler form is derived from an early definition in System V systems
and therefore this function is available on SVID-derived systems.  The
prototypes and required definitions can be found in the `ftw.h' header.

   There are four functions in this family: `ftw', `nftw' and their
64-bit counterparts `ftw64' and `nftw64'.  These functions take as one
of their arguments a pointer to a callback function of the appropriate
type.

 -- Data Type: __ftw_func_t
          int (*) (const char *, const struct stat *, int)

     The type of callback functions given to the `ftw' function.  The
     first parameter points to the file name, the second parameter to an
     object of type `struct stat' which is filled in for the file named
     in the first parameter.

     The last parameter is a flag giving more information about the
     current file.  It can have the following values:

    `FTW_F'
          The item is either a normal file or a file which does not fit
          into one of the following categories.  This could be special
          files, sockets etc.

    `FTW_D'
          The item is a directory.

    `FTW_NS'
          The `stat' call failed and so the information pointed to by
          the second paramater is invalid.

    `FTW_DNR'
          The item is a directory which cannot be read.

    `FTW_SL'
          The item is a symbolic link.  Since symbolic links are
          normally followed seeing this value in a `ftw' callback
          function means the referenced file does not exist.  The
          situation for `nftw' is different.

          This value is only available if the program is compiled with
          `_BSD_SOURCE' or `_XOPEN_EXTENDED' defined before including
          the first header.  The original SVID systems do not have
          symbolic links.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     type is in fact `__ftw64_func_t' since this mode changes `struct
     stat' to be `struct stat64'.

   For the LFS interface and for use in the function `ftw64', the
header `ftw.h' defines another function type.

 -- Data Type: __ftw64_func_t
          int (*) (const char *, const struct stat64 *, int)

     This type is used just like `__ftw_func_t' for the callback
     function, but this time is called from `ftw64'.  The second
     parameter to the function is a pointer to a variable of type
     `struct stat64' which is able to represent the larger values.

 -- Data Type: __nftw_func_t
          int (*) (const char *, const struct stat *, int, struct FTW *)

     The first three arguments are the same as for the `__ftw_func_t'
     type.  However for the third argument some additional values are
     defined to allow finer differentiation:
    `FTW_DP'
          The current item is a directory and all subdirectories have
          already been visited and reported.  This flag is returned
          instead of `FTW_D' if the `FTW_DEPTH' flag is passed to
          `nftw' (see below).

    `FTW_SLN'
          The current item is a stale symbolic link.  The file it
          points to does not exist.

     The last parameter of the callback function is a pointer to a
     structure with some extra information as described below.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     type is in fact `__nftw64_func_t' since this mode changes `struct
     stat' to be `struct stat64'.

   For the LFS interface there is also a variant of this data type
available which has to be used with the `nftw64' function.

 -- Data Type: __nftw64_func_t
          int (*) (const char *, const struct stat64 *, int, struct FTW *)

     This type is used just like `__nftw_func_t' for the callback
     function, but this time is called from `nftw64'.  The second
     parameter to the function is this time a pointer to a variable of
     type `struct stat64' which is able to represent the larger values.

 -- Data Type: struct FTW
     The information contained in this structure helps in interpreting
     the name parameter and gives some information about the current
     state of the traversal of the directory hierarchy.

    `int base'
          The value is the offset into the string passed in the first
          parameter to the callback function of the beginning of the
          file name.  The rest of the string is the path of the file.
          This information is especially important if the `FTW_CHDIR'
          flag was set in calling `nftw' since then the current
          directory is the one the current item is found in.

    `int level'
          Whilst processing, the code tracks how many directories down
          it has gone to find the current file.  This nesting level
          starts at 0 for files in the initial directory (or is zero
          for the initial file if a file was passed).

 -- Function: int ftw (const char *FILENAME, __ftw_func_t FUNC, int
          DESCRIPTORS)
     The `ftw' function calls the callback function given in the
     parameter FUNC for every item which is found in the directory
     specified by FILENAME and all directories below.  The function
     follows symbolic links if necessary but does not process an item
     twice.  If FILENAME is not a directory then it itself is the only
     object returned to the callback function.

     The file name passed to the callback function is constructed by
     taking the FILENAME parameter and appending the names of all passed
     directories and then the local file name.  So the callback
     function can use this parameter to access the file.  `ftw' also
     calls `stat' for the file and passes that information on to the
     callback function.  If this `stat' call was not successful the
     failure is indicated by setting the third argument of the callback
     function to `FTW_NS'.  Otherwise it is set according to the
     description given in the account of `__ftw_func_t' above.

     The callback function is expected to return 0 to indicate that no
     error occurred and that processing should continue.  If an error
     occurred in the callback function or it wants `ftw' to return
     immediately, the callback function can return a value other than
     0.  This is the only correct way to stop the function.  The
     program must not use `setjmp' or similar techniques to continue
     from another place.  This would leave resources allocated by the
     `ftw' function unfreed.

     The DESCRIPTORS parameter to `ftw' specifies how many file
     descriptors it is allowed to consume.  The function runs faster
     the more descriptors it can use.  For each level in the directory
     hierarchy at most one descriptor is used, but for very deep ones
     any limit on open file descriptors for the process or the system
     may be exceeded.  Moreover, file descriptor limits in a
     multi-threaded program apply to all the threads as a group, and
     therefore it is a good idea to supply a reasonable limit to the
     number of open descriptors.

     The return value of the `ftw' function is 0 if all callback
     function calls returned 0 and all actions performed by the `ftw'
     succeeded.  If a function call failed (other than calling `stat'
     on an item) the function returns -1.  If a callback function
     returns a value other than 0 this value is returned as the return
     value of `ftw'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit system this function is in fact `ftw64', i.e., the LFS
     interface transparently replaces the old interface.

 -- Function: int ftw64 (const char *FILENAME, __ftw64_func_t FUNC, int
          DESCRIPTORS)
     This function is similar to `ftw' but it can work on filesystems
     with large files.  File information is reported using a variable
     of type `struct stat64' which is passed by reference to the
     callback function.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit system this function is available under the name `ftw' and
     transparently replaces the old implementation.

 -- Function: int nftw (const char *FILENAME, __nftw_func_t FUNC, int
          DESCRIPTORS, int FLAG)
     The `nftw' function works like the `ftw' functions.  They call the
     callback function FUNC for all items found in the directory
     FILENAME and below.  At most DESCRIPTORS file descriptors are
     consumed during the `nftw' call.

     One difference is that the callback function is of a different
     type.  It is of type `struct FTW *' and provides the callback
     function with the extra information described above.

     A second difference is that `nftw' takes a fourth argument, which
     is 0 or a bitwise-OR combination of any of the following values.

    `FTW_PHYS'
          While traversing the directory symbolic links are not
          followed.  Instead symbolic links are reported using the
          `FTW_SL' value for the type parameter to the callback
          function.  If the file referenced by a symbolic link does not
          exist `FTW_SLN' is returned instead.

    `FTW_MOUNT'
          The callback function is only called for items which are on
          the same mounted filesystem as the directory given by the
          FILENAME parameter to `nftw'.

    `FTW_CHDIR'
          If this flag is given the current working directory is
          changed to the directory of the reported object before the
          callback function is called.  When `ntfw' finally returns the
          current directory is restored to its original value.

    `FTW_DEPTH'
          If this option is specified then all subdirectories and files
          within them are processed before processing the top directory
          itself (depth-first processing).  This also means the type
          flag given to the callback function is `FTW_DP' and not
          `FTW_D'.

    `FTW_ACTIONRETVAL'
          If this option is specified then return values from callbacks
          are handled differently.  If the callback returns
          `FTW_CONTINUE', walking continues normally.  `FTW_STOP' means
          walking stops and `FTW_STOP' is returned to the caller.  If
          `FTW_SKIP_SUBTREE' is returned by the callback with `FTW_D'
          argument, the subtree is skipped and walking continues with
          next sibling of the directory.  If `FTW_SKIP_SIBLINGS' is
          returned by the callback, all siblings of the current entry
          are skipped and walking continues in its parent.  No other
          return values should be returned from the callbacks if this
          option is set.  This option is a GNU extension.

     The return value is computed in the same way as for `ftw'.  `nftw'
     returns 0 if no failures occurred and all callback functions
     returned 0.  In case of internal errors, such as memory problems,
     the return value is -1 and ERRNO is set accordingly.  If the
     return value of a callback invocation was non-zero then that value
     is returned.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit system this function is in fact `nftw64', i.e., the LFS
     interface transparently replaces the old interface.

 -- Function: int nftw64 (const char *FILENAME, __nftw64_func_t FUNC,
          int DESCRIPTORS, int FLAG)
     This function is similar to `nftw' but it can work on filesystems
     with large files.  File information is reported using a variable
     of type `struct stat64' which is passed by reference to the
     callback function.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit system this function is available under the name `nftw' and
     transparently replaces the old implementation.


File: libc.info,  Node: Hard Links,  Next: Symbolic Links,  Prev: Working with Directory Trees,  Up: File System Interface

14.4 Hard Links
===============

In POSIX systems, one file can have many names at the same time.  All of
the names are equally real, and no one of them is preferred to the
others.

   To add a name to a file, use the `link' function.  (The new name is
also called a "hard link" to the file.)  Creating a new link to a file
does not copy the contents of the file; it simply makes a new name by
which the file can be known, in addition to the file's existing name or
names.

   One file can have names in several directories, so the organization
of the file system is not a strict hierarchy or tree.

   In most implementations, it is not possible to have hard links to the
same file in multiple file systems.  `link' reports an error if you try
to make a hard link to the file from another file system when this
cannot be done.

   The prototype for the `link' function is declared in the header file
`unistd.h'.  

 -- Function: int link (const char *OLDNAME, const char *NEWNAME)
     The `link' function makes a new link to the existing file named by
     OLDNAME, under the new name NEWNAME.

     This function returns a value of `0' if it is successful and `-1'
     on failure.  In addition to the usual file name errors (*note File
     Name Errors::) for both OLDNAME and NEWNAME, the following `errno'
     error conditions are defined for this function:

    `EACCES'
          You are not allowed to write to the directory in which the
          new link is to be written.

    `EEXIST'
          There is already a file named NEWNAME.  If you want to replace
          this link with a new link, you must remove the old link
          explicitly first.

    `EMLINK'
          There are already too many links to the file named by OLDNAME.
          (The maximum number of links to a file is `LINK_MAX'; see
          *Note Limits for Files::.)

    `ENOENT'
          The file named by OLDNAME doesn't exist.  You can't make a
          link to a file that doesn't exist.

    `ENOSPC'
          The directory or file system that would contain the new link
          is full and cannot be extended.

    `EPERM'
          In the GNU system and some others, you cannot make links to
          directories.  Many systems allow only privileged users to do
          so.  This error is used to report the problem.

    `EROFS'
          The directory containing the new link can't be modified
          because it's on a read-only file system.

    `EXDEV'
          The directory specified in NEWNAME is on a different file
          system than the existing file.

    `EIO'
          A hardware error occurred while trying to read or write the
          to filesystem.


File: libc.info,  Node: Symbolic Links,  Next: Deleting Files,  Prev: Hard Links,  Up: File System Interface

14.5 Symbolic Links
===================

The GNU system supports "soft links" or "symbolic links".  This is a
kind of "file" that is essentially a pointer to another file name.
Unlike hard links, symbolic links can be made to directories or across
file systems with no restrictions.  You can also make a symbolic link
to a name which is not the name of any file.  (Opening this link will
fail until a file by that name is created.)  Likewise, if the symbolic
link points to an existing file which is later deleted, the symbolic
link continues to point to the same file name even though the name no
longer names any file.

   The reason symbolic links work the way they do is that special things
happen when you try to open the link.  The `open' function realizes you
have specified the name of a link, reads the file name contained in the
link, and opens that file name instead.  The `stat' function likewise
operates on the file that the symbolic link points to, instead of on
the link itself.

   By contrast, other operations such as deleting or renaming the file
operate on the link itself.  The functions `readlink' and `lstat' also
refrain from following symbolic links, because their purpose is to
obtain information about the link.  `link', the function that makes a
hard link, does too.  It makes a hard link to the symbolic link, which
one rarely wants.

   Some systems have for some functions operating on files have a limit
on how many symbolic links are followed when resolving a path name.  The
limit if it exists is published in the `sys/param.h' header file.

 -- Macro: int MAXSYMLINKS
     The macro `MAXSYMLINKS' specifies how many symlinks some function
     will follow before returning `ELOOP'.  Not all functions behave the
     same and this value is not the same a that returned for
     `_SC_SYMLOOP' by `sysconf'.  In fact, the `sysconf' result can
     indicate that there is no fixed limit although `MAXSYMLINKS'
     exists and has a finite value.

   Prototypes for most of the functions listed in this section are in
`unistd.h'.  

 -- Function: int symlink (const char *OLDNAME, const char *NEWNAME)
     The `symlink' function makes a symbolic link to OLDNAME named
     NEWNAME.

     The normal return value from `symlink' is `0'.  A return value of
     `-1' indicates an error.  In addition to the usual file name
     syntax errors (*note File Name Errors::), the following `errno'
     error conditions are defined for this function:

    `EEXIST'
          There is already an existing file named NEWNAME.

    `EROFS'
          The file NEWNAME would exist on a read-only file system.

    `ENOSPC'
          The directory or file system cannot be extended to make the
          new link.

    `EIO'
          A hardware error occurred while reading or writing data on
          the disk.


 -- Function: int readlink (const char *FILENAME, char *BUFFER, size_t
          SIZE)
     The `readlink' function gets the value of the symbolic link
     FILENAME.  The file name that the link points to is copied into
     BUFFER.  This file name string is _not_ null-terminated;
     `readlink' normally returns the number of characters copied.  The
     SIZE argument specifies the maximum number of characters to copy,
     usually the allocation size of BUFFER.

     If the return value equals SIZE, you cannot tell whether or not
     there was room to return the entire name.  So make a bigger buffer
     and call `readlink' again.  Here is an example:

          char *
          readlink_malloc (const char *filename)
          {
            int size = 100;
            char *buffer = NULL;

            while (1)
              {
                buffer = (char *) xrealloc (buffer, size);
                int nchars = readlink (filename, buffer, size);
                if (nchars < 0)
                  {
                    free (buffer);
                    return NULL;
                  }
                if (nchars < size)
                  return buffer;
                size *= 2;
              }
          }

     A value of `-1' is returned in case of error.  In addition to the
     usual file name errors (*note File Name Errors::), the following
     `errno' error conditions are defined for this function:

    `EINVAL'
          The named file is not a symbolic link.

    `EIO'
          A hardware error occurred while reading or writing data on
          the disk.

   In some situations it is desirable to resolve all the symbolic links
to get the real name of a file where no prefix names a symbolic link
which is followed and no filename in the path is `.' or `..'.  This is
for instance desirable if files have to be compare in which case
different names can refer to the same inode.

 -- Function: char * canonicalize_file_name (const char *NAME)
     The `canonicalize_file_name' function returns the absolute name of
     the file named by NAME which contains no `.', `..' components nor
     any repeated path separators (`/') or symlinks.  The result is
     passed back as the return value of the function in a block of
     memory allocated with `malloc'.  If the result is not used anymore
     the memory should be freed with a call to `free'.

     If any of the path components is missing the function returns a
     NULL pointer.  This is also what is returned if the length of the
     path reaches or exceeds `PATH_MAX' characters.  In any case
     `errno' is set accordingly.

    `ENAMETOOLONG'
          The resulting path is too long.  This error only occurs on
          systems which have a limit on the file name length.

    `EACCES'
          At least one of the path components is not readable.

    `ENOENT'
          The input file name is empty.

    `ENOENT'
          At least one of the path components does not exist.

    `ELOOP'
          More than `MAXSYMLINKS' many symlinks have been followed.

     This function is a GNU extension and is declared in `stdlib.h'.

   The Unix standard includes a similar function which differs from
`canonicalize_file_name' in that the user has to provide the buffer
where the result is placed in.

 -- Function: char * realpath (const char *restrict NAME, char
          *restrict RESOLVED)
     A call to `realpath' where the RESOLVED parameter is `NULL'
     behaves exactly like `canonicalize_file_name'.  The function
     allocates a buffer for the file name and returns a pointer to it.
     If RESOLVED is not `NULL' it points to a buffer into which the
     result is copied.  It is the callers responsibility to allocate a
     buffer which is large enough.  On systems which define `PATH_MAX'
     this means the buffer must be large enough for a pathname of this
     size.  For systems without limitations on the pathname length the
     requirement cannot be met and programs should not call `realpath'
     with anything but `NULL' for the second parameter.

     One other difference is that the buffer RESOLVED (if nonzero) will
     contain the part of the path component which does not exist or is
     not readable if the function returns `NULL' and `errno' is set to
     `EACCES' or `ENOENT'.

     This function is declared in `stdlib.h'.

   The advantage of using this function is that it is more widely
available.  The drawback is that it reports failures for long path on
systems which have no limits on the file name length.


File: libc.info,  Node: Deleting Files,  Next: Renaming Files,  Prev: Symbolic Links,  Up: File System Interface

14.6 Deleting Files
===================

You can delete a file with `unlink' or `remove'.

   Deletion actually deletes a file name.  If this is the file's only
name, then the file is deleted as well.  If the file has other
remaining names (*note Hard Links::), it remains accessible under those
names.

 -- Function: int unlink (const char *FILENAME)
     The `unlink' function deletes the file name FILENAME.  If this is
     a file's sole name, the file itself is also deleted.  (Actually,
     if any process has the file open when this happens, deletion is
     postponed until all processes have closed the file.)

     The function `unlink' is declared in the header file `unistd.h'.

     This function returns `0' on successful completion, and `-1' on
     error.  In addition to the usual file name errors (*note File Name
     Errors::), the following `errno' error conditions are defined for
     this function:

    `EACCES'
          Write permission is denied for the directory from which the
          file is to be removed, or the directory has the sticky bit
          set and you do not own the file.

    `EBUSY'
          This error indicates that the file is being used by the
          system in such a way that it can't be unlinked.  For example,
          you might see this error if the file name specifies the root
          directory or a mount point for a file system.

    `ENOENT'
          The file name to be deleted doesn't exist.

    `EPERM'
          On some systems `unlink' cannot be used to delete the name of
          a directory, or at least can only be used this way by a
          privileged user.  To avoid such problems, use `rmdir' to
          delete directories.  (In the GNU system `unlink' can never
          delete the name of a directory.)

    `EROFS'
          The directory containing the file name to be deleted is on a
          read-only file system and can't be modified.

 -- Function: int rmdir (const char *FILENAME)
     The `rmdir' function deletes a directory.  The directory must be
     empty before it can be removed; in other words, it can only contain
     entries for `.' and `..'.

     In most other respects, `rmdir' behaves like `unlink'.  There are
     two additional `errno' error conditions defined for `rmdir':

    `ENOTEMPTY'
    `EEXIST'
          The directory to be deleted is not empty.

     These two error codes are synonymous; some systems use one, and
     some use the other.  The GNU system always uses `ENOTEMPTY'.

     The prototype for this function is declared in the header file
     `unistd.h'.  

 -- Function: int remove (const char *FILENAME)
     This is the ISO C function to remove a file.  It works like
     `unlink' for files and like `rmdir' for directories.  `remove' is
     declared in `stdio.h'.  


File: libc.info,  Node: Renaming Files,  Next: Creating Directories,  Prev: Deleting Files,  Up: File System Interface

14.7 Renaming Files
===================

The `rename' function is used to change a file's name.

 -- Function: int rename (const char *OLDNAME, const char *NEWNAME)
     The `rename' function renames the file OLDNAME to NEWNAME.  The
     file formerly accessible under the name OLDNAME is afterwards
     accessible as NEWNAME instead.  (If the file had any other names
     aside from OLDNAME, it continues to have those names.)

     The directory containing the name NEWNAME must be on the same file
     system as the directory containing the name OLDNAME.

     One special case for `rename' is when OLDNAME and NEWNAME are two
     names for the same file.  The consistent way to handle this case
     is to delete OLDNAME.  However, in this case POSIX requires that
     `rename' do nothing and report success--which is inconsistent.  We
     don't know what your operating system will do.

     If OLDNAME is not a directory, then any existing file named
     NEWNAME is removed during the renaming operation.  However, if
     NEWNAME is the name of a directory, `rename' fails in this case.

     If OLDNAME is a directory, then either NEWNAME must not exist or
     it must name a directory that is empty.  In the latter case, the
     existing directory named NEWNAME is deleted first.  The name
     NEWNAME must not specify a subdirectory of the directory `oldname'
     which is being renamed.

     One useful feature of `rename' is that the meaning of NEWNAME
     changes "atomically" from any previously existing file by that
     name to its new meaning (i.e., the file that was called OLDNAME).
     There is no instant at which NEWNAME is non-existent "in between"
     the old meaning and the new meaning.  If there is a system crash
     during the operation, it is possible for both names to still
     exist; but NEWNAME will always be intact if it exists at all.

     If `rename' fails, it returns `-1'.  In addition to the usual file
     name errors (*note File Name Errors::), the following `errno'
     error conditions are defined for this function:

    `EACCES'
          One of the directories containing NEWNAME or OLDNAME refuses
          write permission; or NEWNAME and OLDNAME are directories and
          write permission is refused for one of them.

    `EBUSY'
          A directory named by OLDNAME or NEWNAME is being used by the
          system in a way that prevents the renaming from working.
          This includes directories that are mount points for
          filesystems, and directories that are the current working
          directories of processes.

    `ENOTEMPTY'
    `EEXIST'
          The directory NEWNAME isn't empty.  The GNU system always
          returns `ENOTEMPTY' for this, but some other systems return
          `EEXIST'.

    `EINVAL'
          OLDNAME is a directory that contains NEWNAME.

    `EISDIR'
          NEWNAME is a directory but the OLDNAME isn't.

    `EMLINK'
          The parent directory of NEWNAME would have too many links
          (entries).

    `ENOENT'
          The file OLDNAME doesn't exist.

    `ENOSPC'
          The directory that would contain NEWNAME has no room for
          another entry, and there is no space left in the file system
          to expand it.

    `EROFS'
          The operation would involve writing to a directory on a
          read-only file system.

    `EXDEV'
          The two file names NEWNAME and OLDNAME are on different file
          systems.


File: libc.info,  Node: Creating Directories,  Next: File Attributes,  Prev: Renaming Files,  Up: File System Interface

14.8 Creating Directories
=========================

Directories are created with the `mkdir' function.  (There is also a
shell command `mkdir' which does the same thing.)

 -- Function: int mkdir (const char *FILENAME, mode_t MODE)
     The `mkdir' function creates a new, empty directory with name
     FILENAME.

     The argument MODE specifies the file permissions for the new
     directory file.  *Note Permission Bits::, for more information
     about this.

     A return value of `0' indicates successful completion, and `-1'
     indicates failure.  In addition to the usual file name syntax
     errors (*note File Name Errors::), the following `errno' error
     conditions are defined for this function:

    `EACCES'
          Write permission is denied for the parent directory in which
          the new directory is to be added.

    `EEXIST'
          A file named FILENAME already exists.

    `EMLINK'
          The parent directory has too many links (entries).

          Well-designed file systems never report this error, because
          they permit more links than your disk could possibly hold.
          However, you must still take account of the possibility of
          this error, as it could result from network access to a file
          system on another machine.

    `ENOSPC'
          The file system doesn't have enough room to create the new
          directory.

    `EROFS'
          The parent directory of the directory being created is on a
          read-only file system and cannot be modified.

     To use this function, your program should include the header file
     `sys/stat.h'.  


File: libc.info,  Node: File Attributes,  Next: Making Special Files,  Prev: Creating Directories,  Up: File System Interface

14.9 File Attributes
====================

When you issue an `ls -l' shell command on a file, it gives you
information about the size of the file, who owns it, when it was last
modified, etc.  These are called the "file attributes", and are
associated with the file itself and not a particular one of its names.

   This section contains information about how you can inquire about and
modify the attributes of a file.

* Menu:

* Attribute Meanings::          The names of the file attributes,
                                 and what their values mean.
* Reading Attributes::          How to read the attributes of a file.
* Testing File Type::           Distinguishing ordinary files,
                                 directories, links...
* File Owner::                  How ownership for new files is determined,
			         and how to change it.
* Permission Bits::             How information about a file's access
                                 mode is stored.
* Access Permission::           How the system decides who can access a file.
* Setting Permissions::         How permissions for new files are assigned,
			         and how to change them.
* Testing File Access::         How to find out if your process can
                                 access a file.
* File Times::                  About the time attributes of a file.
* File Size::			Manually changing the size of a file.


File: libc.info,  Node: Attribute Meanings,  Next: Reading Attributes,  Up: File Attributes

14.9.1 The meaning of the File Attributes
-----------------------------------------

When you read the attributes of a file, they come back in a structure
called `struct stat'.  This section describes the names of the
attributes, their data types, and what they mean.  For the functions to
read the attributes of a file, see *Note Reading Attributes::.

   The header file `sys/stat.h' declares all the symbols defined in
this section.  

 -- Data Type: struct stat
     The `stat' structure type is used to return information about the
     attributes of a file.  It contains at least the following members:

    `mode_t st_mode'
          Specifies the mode of the file.  This includes file type
          information (*note Testing File Type::) and the file
          permission bits (*note Permission Bits::).

    `ino_t st_ino'
          The file serial number, which distinguishes this file from
          all other files on the same device.

    `dev_t st_dev'
          Identifies the device containing the file.  The `st_ino' and
          `st_dev', taken together, uniquely identify the file.  The
          `st_dev' value is not necessarily consistent across reboots or
          system crashes, however.

    `nlink_t st_nlink'
          The number of hard links to the file.  This count keeps track
          of how many directories have entries for this file.  If the
          count is ever decremented to zero, then the file itself is
          discarded as soon as no process still holds it open.
          Symbolic links are not counted in the total.

    `uid_t st_uid'
          The user ID of the file's owner.  *Note File Owner::.

    `gid_t st_gid'
          The group ID of the file.  *Note File Owner::.

    `off_t st_size'
          This specifies the size of a regular file in bytes.  For
          files that are really devices this field isn't usually
          meaningful.  For symbolic links this specifies the length of
          the file name the link refers to.

    `time_t st_atime'
          This is the last access time for the file.  *Note File
          Times::.

    `unsigned long int st_atime_usec'
          This is the fractional part of the last access time for the
          file.  *Note File Times::.

    `time_t st_mtime'
          This is the time of the last modification to the contents of
          the file.  *Note File Times::.

    `unsigned long int st_mtime_usec'
          This is the fractional part of the time of the last
          modification to the contents of the file.  *Note File Times::.

    `time_t st_ctime'
          This is the time of the last modification to the attributes
          of the file.  *Note File Times::.

    `unsigned long int st_ctime_usec'
          This is the fractional part of the time of the last
          modification to the attributes of the file.  *Note File
          Times::.

    `blkcnt_t st_blocks'
          This is the amount of disk space that the file occupies,
          measured in units of 512-byte blocks.

          The number of disk blocks is not strictly proportional to the
          size of the file, for two reasons: the file system may use
          some blocks for internal record keeping; and the file may be
          sparse--it may have "holes" which contain zeros but do not
          actually take up space on the disk.

          You can tell (approximately) whether a file is sparse by
          comparing this value with `st_size', like this:

               (st.st_blocks * 512 < st.st_size)

          This test is not perfect because a file that is just slightly
          sparse might not be detected as sparse at all.  For practical
          applications, this is not a problem.

    `unsigned int st_blksize'
          The optimal block size for reading of writing this file, in
          bytes.  You might use this size for allocating the buffer
          space for reading of writing the file.  (This is unrelated to
          `st_blocks'.)

   The extensions for the Large File Support (LFS) require, even on
32-bit machines, types which can handle file sizes up to 2^63.
Therefore a new definition of `struct stat' is necessary.

 -- Data Type: struct stat64
     The members of this type are the same and have the same names as
     those in `struct stat'.  The only difference is that the members
     `st_ino', `st_size', and `st_blocks' have a different type to
     support larger values.

    `mode_t st_mode'
          Specifies the mode of the file.  This includes file type
          information (*note Testing File Type::) and the file
          permission bits (*note Permission Bits::).

    `ino64_t st_ino'
          The file serial number, which distinguishes this file from
          all other files on the same device.

    `dev_t st_dev'
          Identifies the device containing the file.  The `st_ino' and
          `st_dev', taken together, uniquely identify the file.  The
          `st_dev' value is not necessarily consistent across reboots or
          system crashes, however.

    `nlink_t st_nlink'
          The number of hard links to the file.  This count keeps track
          of how many directories have entries for this file.  If the
          count is ever decremented to zero, then the file itself is
          discarded as soon as no process still holds it open.
          Symbolic links are not counted in the total.

    `uid_t st_uid'
          The user ID of the file's owner.  *Note File Owner::.

    `gid_t st_gid'
          The group ID of the file.  *Note File Owner::.

    `off64_t st_size'
          This specifies the size of a regular file in bytes.  For
          files that are really devices this field isn't usually
          meaningful.  For symbolic links this specifies the length of
          the file name the link refers to.

    `time_t st_atime'
          This is the last access time for the file.  *Note File
          Times::.

    `unsigned long int st_atime_usec'
          This is the fractional part of the last access time for the
          file.  *Note File Times::.

    `time_t st_mtime'
          This is the time of the last modification to the contents of
          the file.  *Note File Times::.

    `unsigned long int st_mtime_usec'
          This is the fractional part of the time of the last
          modification to the contents of the file.  *Note File Times::.

    `time_t st_ctime'
          This is the time of the last modification to the attributes
          of the file.  *Note File Times::.

    `unsigned long int st_ctime_usec'
          This is the fractional part of the time of the last
          modification to the attributes of the file.  *Note File
          Times::.

    `blkcnt64_t st_blocks'
          This is the amount of disk space that the file occupies,
          measured in units of 512-byte blocks.

    `unsigned int st_blksize'
          The optimal block size for reading of writing this file, in
          bytes.  You might use this size for allocating the buffer
          space for reading of writing the file.  (This is unrelated to
          `st_blocks'.)

   Some of the file attributes have special data type names which exist
specifically for those attributes.  (They are all aliases for well-known
integer types that you know and love.)  These typedef names are defined
in the header file `sys/types.h' as well as in `sys/stat.h'.  Here is a
list of them.

 -- Data Type: mode_t
     This is an integer data type used to represent file modes.  In the
     GNU system, this is equivalent to `unsigned int'.

 -- Data Type: ino_t
     This is an arithmetic data type used to represent file serial
     numbers.  (In Unix jargon, these are sometimes called "inode
     numbers".)  In the GNU system, this type is equivalent to
     `unsigned long int'.

     If the source is compiled with `_FILE_OFFSET_BITS == 64' this type
     is transparently replaced by `ino64_t'.

 -- Data Type: ino64_t
     This is an arithmetic data type used to represent file serial
     numbers for the use in LFS.  In the GNU system, this type is
     equivalent to `unsigned long long int'.

     When compiling with `_FILE_OFFSET_BITS == 64' this type is
     available under the name `ino_t'.

 -- Data Type: dev_t
     This is an arithmetic data type used to represent file device
     numbers.  In the GNU system, this is equivalent to `int'.

 -- Data Type: nlink_t
     This is an arithmetic data type used to represent file link counts.
     In the GNU system, this is equivalent to `unsigned short int'.

 -- Data Type: blkcnt_t
     This is an arithmetic data type used to represent block counts.
     In the GNU system, this is equivalent to `unsigned long int'.

     If the source is compiled with `_FILE_OFFSET_BITS == 64' this type
     is transparently replaced by `blkcnt64_t'.

 -- Data Type: blkcnt64_t
     This is an arithmetic data type used to represent block counts for
     the use in LFS.  In the GNU system, this is equivalent to `unsigned
     long long int'.

     When compiling with `_FILE_OFFSET_BITS == 64' this type is
     available under the name `blkcnt_t'.


File: libc.info,  Node: Reading Attributes,  Next: Testing File Type,  Prev: Attribute Meanings,  Up: File Attributes

14.9.2 Reading the Attributes of a File
---------------------------------------

To examine the attributes of files, use the functions `stat', `fstat'
and `lstat'.  They return the attribute information in a `struct stat'
object.  All three functions are declared in the header file
`sys/stat.h'.

 -- Function: int stat (const char *FILENAME, struct stat *BUF)
     The `stat' function returns information about the attributes of the
     file named by FILENAME in the structure pointed to by BUF.

     If FILENAME is the name of a symbolic link, the attributes you get
     describe the file that the link points to.  If the link points to a
     nonexistent file name, then `stat' fails reporting a nonexistent
     file.

     The return value is `0' if the operation is successful, or `-1' on
     failure.  In addition to the usual file name errors (*note File
     Name Errors::, the following `errno' error conditions are defined
     for this function:

    `ENOENT'
          The file named by FILENAME doesn't exist.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `stat64' since the LFS interface transparently
     replaces the normal implementation.

 -- Function: int stat64 (const char *FILENAME, struct stat64 *BUF)
     This function is similar to `stat' but it is also able to work on
     files larger then 2^31 bytes on 32-bit systems.  To be able to do
     this the result is stored in a variable of type `struct stat64' to
     which BUF must point.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is available under the name `stat' and so transparently
     replaces the interface for small files on 32-bit machines.

 -- Function: int fstat (int FILEDES, struct stat *BUF)
     The `fstat' function is like `stat', except that it takes an open
     file descriptor as an argument instead of a file name.  *Note
     Low-Level I/O::.

     Like `stat', `fstat' returns `0' on success and `-1' on failure.
     The following `errno' error conditions are defined for `fstat':

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `fstat64' since the LFS interface transparently
     replaces the normal implementation.

 -- Function: int fstat64 (int FILEDES, struct stat64 *BUF)
     This function is similar to `fstat' but is able to work on large
     files on 32-bit platforms.  For large files the file descriptor
     FILEDES should be obtained by `open64' or `creat64'.  The BUF
     pointer points to a variable of type `struct stat64' which is able
     to represent the larger values.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is available under the name `fstat' and so transparently
     replaces the interface for small files on 32-bit machines.

 -- Function: int lstat (const char *FILENAME, struct stat *BUF)
     The `lstat' function is like `stat', except that it does not
     follow symbolic links.  If FILENAME is the name of a symbolic
     link, `lstat' returns information about the link itself; otherwise
     `lstat' works like `stat'.  *Note Symbolic Links::.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is in fact `lstat64' since the LFS interface transparently
     replaces the normal implementation.

 -- Function: int lstat64 (const char *FILENAME, struct stat64 *BUF)
     This function is similar to `lstat' but it is also able to work on
     files larger then 2^31 bytes on 32-bit systems.  To be able to do
     this the result is stored in a variable of type `struct stat64' to
     which BUF must point.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' this
     function is available under the name `lstat' and so transparently
     replaces the interface for small files on 32-bit machines.


File: libc.info,  Node: Testing File Type,  Next: File Owner,  Prev: Reading Attributes,  Up: File Attributes

14.9.3 Testing the Type of a File
---------------------------------

The "file mode", stored in the `st_mode' field of the file attributes,
contains two kinds of information: the file type code, and the access
permission bits.  This section discusses only the type code, which you
can use to tell whether the file is a directory, socket, symbolic link,
and so on.  For details about access permissions see *Note Permission
Bits::.

   There are two ways you can access the file type information in a file
mode.  Firstly, for each file type there is a "predicate macro" which
examines a given file mode and returns whether it is of that type or
not.  Secondly, you can mask out the rest of the file mode to leave
just the file type code, and compare this against constants for each of
the supported file types.

   All of the symbols listed in this section are defined in the header
file `sys/stat.h'.  

   The following predicate macros test the type of a file, given the
value M which is the `st_mode' field returned by `stat' on that file:

 -- Macro: int S_ISDIR (mode_t M)
     This macro returns non-zero if the file is a directory.

 -- Macro: int S_ISCHR (mode_t M)
     This macro returns non-zero if the file is a character special
     file (a device like a terminal).

 -- Macro: int S_ISBLK (mode_t M)
     This macro returns non-zero if the file is a block special file (a
     device like a disk).

 -- Macro: int S_ISREG (mode_t M)
     This macro returns non-zero if the file is a regular file.

 -- Macro: int S_ISFIFO (mode_t M)
     This macro returns non-zero if the file is a FIFO special file, or
     a pipe.  *Note Pipes and FIFOs::.

 -- Macro: int S_ISLNK (mode_t M)
     This macro returns non-zero if the file is a symbolic link.  *Note
     Symbolic Links::.

 -- Macro: int S_ISSOCK (mode_t M)
     This macro returns non-zero if the file is a socket.  *Note
     Sockets::.

   An alternate non-POSIX method of testing the file type is supported
for compatibility with BSD.  The mode can be bitwise AND-ed with
`S_IFMT' to extract the file type code, and compared to the appropriate
constant.  For example,

     S_ISCHR (MODE)

is equivalent to:

     ((MODE & S_IFMT) == S_IFCHR)

 -- Macro: int S_IFMT
     This is a bit mask used to extract the file type code from a mode
     value.

   These are the symbolic names for the different file type codes:

`S_IFDIR'
     This is the file type constant of a directory file.

`S_IFCHR'
     This is the file type constant of a character-oriented device file.

`S_IFBLK'
     This is the file type constant of a block-oriented device file.

`S_IFREG'
     This is the file type constant of a regular file.

`S_IFLNK'
     This is the file type constant of a symbolic link.

`S_IFSOCK'
     This is the file type constant of a socket.

`S_IFIFO'
     This is the file type constant of a FIFO or pipe.

   The POSIX.1b standard introduced a few more objects which possibly
can be implemented as object in the filesystem.  These are message
queues, semaphores, and shared memory objects.  To allow
differentiating these objects from other files the POSIX standard
introduces three new test macros.  But unlike the other macros it does
not take the value of the `st_mode' field as the parameter.  Instead
they expect a pointer to the whole `struct stat' structure.

 -- Macro: int S_TYPEISMQ (struct stat *S)
     If the system implement POSIX message queues as distinct objects
     and the file is a message queue object, this macro returns a
     non-zero value.  In all other cases the result is zero.

 -- Macro: int S_TYPEISSEM (struct stat *S)
     If the system implement POSIX semaphores as distinct objects and
     the file is a semaphore object, this macro returns a non-zero
     value.  In all other cases the result is zero.

 -- Macro: int S_TYPEISSHM (struct stat *S)
     If the system implement POSIX shared memory objects as distinct
     objects and the file is an shared memory object, this macro
     returns a non-zero value.  In all other cases the result is zero.


File: libc.info,  Node: File Owner,  Next: Permission Bits,  Prev: Testing File Type,  Up: File Attributes

14.9.4 File Owner
-----------------

Every file has an "owner" which is one of the registered user names
defined on the system.  Each file also has a "group" which is one of
the defined groups.  The file owner can often be useful for showing you
who edited the file (especially when you edit with GNU Emacs), but its
main purpose is for access control.

   The file owner and group play a role in determining access because
the file has one set of access permission bits for the owner, another
set that applies to users who belong to the file's group, and a third
set of bits that applies to everyone else.  *Note Access Permission::,
for the details of how access is decided based on this data.

   When a file is created, its owner is set to the effective user ID of
the process that creates it (*note Process Persona::).  The file's
group ID may be set to either the effective group ID of the process, or
the group ID of the directory that contains the file, depending on the
system where the file is stored.  When you access a remote file system,
it behaves according to its own rules, not according to the system your
program is running on.  Thus, your program must be prepared to encounter
either kind of behavior no matter what kind of system you run it on.

   You can change the owner and/or group owner of an existing file using
the `chown' function.  This is the primitive for the `chown' and
`chgrp' shell commands.

   The prototype for this function is declared in `unistd.h'.

 -- Function: int chown (const char *FILENAME, uid_t OWNER, gid_t GROUP)
     The `chown' function changes the owner of the file FILENAME to
     OWNER, and its group owner to GROUP.

     Changing the owner of the file on certain systems clears the
     set-user-ID and set-group-ID permission bits.  (This is because
     those bits may not be appropriate for the new owner.)  Other file
     permission bits are not changed.

     The return value is `0' on success and `-1' on failure.  In
     addition to the usual file name errors (*note File Name Errors::),
     the following `errno' error conditions are defined for this
     function:

    `EPERM'
          This process lacks permission to make the requested change.

          Only privileged users or the file's owner can change the
          file's group.  On most file systems, only privileged users
          can change the file owner; some file systems allow you to
          change the owner if you are currently the owner.  When you
          access a remote file system, the behavior you encounter is
          determined by the system that actually holds the file, not by
          the system your program is running on.

          *Note Options for Files::, for information about the
          `_POSIX_CHOWN_RESTRICTED' macro.

    `EROFS'
          The file is on a read-only file system.

 -- Function: int fchown (int FILEDES, int OWNER, int GROUP)
     This is like `chown', except that it changes the owner of the open
     file with descriptor FILEDES.

     The return value from `fchown' is `0' on success and `-1' on
     failure.  The following `errno' error codes are defined for this
     function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The FILEDES argument corresponds to a pipe or socket, not an
          ordinary file.

    `EPERM'
          This process lacks permission to make the requested change.
          For details see `chmod' above.

    `EROFS'
          The file resides on a read-only file system.


File: libc.info,  Node: Permission Bits,  Next: Access Permission,  Prev: File Owner,  Up: File Attributes

14.9.5 The Mode Bits for Access Permission
------------------------------------------

The "file mode", stored in the `st_mode' field of the file attributes,
contains two kinds of information: the file type code, and the access
permission bits.  This section discusses only the access permission
bits, which control who can read or write the file.  *Note Testing File
Type::, for information about the file type code.

   All of the symbols listed in this section are defined in the header
file `sys/stat.h'.  

   These symbolic constants are defined for the file mode bits that
control access permission for the file:

`S_IRUSR'
`S_IREAD'
     Read permission bit for the owner of the file.  On many systems
     this bit is 0400.  `S_IREAD' is an obsolete synonym provided for
     BSD compatibility.

`S_IWUSR'
`S_IWRITE'
     Write permission bit for the owner of the file.  Usually 0200.
     `S_IWRITE' is an obsolete synonym provided for BSD compatibility.

`S_IXUSR'
`S_IEXEC'
     Execute (for ordinary files) or search (for directories)
     permission bit for the owner of the file.  Usually 0100.
     `S_IEXEC' is an obsolete synonym provided for BSD compatibility.

`S_IRWXU'
     This is equivalent to `(S_IRUSR | S_IWUSR | S_IXUSR)'.

`S_IRGRP'
     Read permission bit for the group owner of the file.  Usually 040.

`S_IWGRP'
     Write permission bit for the group owner of the file.  Usually 020.

`S_IXGRP'
     Execute or search permission bit for the group owner of the file.
     Usually 010.

`S_IRWXG'
     This is equivalent to `(S_IRGRP | S_IWGRP | S_IXGRP)'.

`S_IROTH'
     Read permission bit for other users.  Usually 04.

`S_IWOTH'
     Write permission bit for other users.  Usually 02.

`S_IXOTH'
     Execute or search permission bit for other users.  Usually 01.

`S_IRWXO'
     This is equivalent to `(S_IROTH | S_IWOTH | S_IXOTH)'.

`S_ISUID'
     This is the set-user-ID on execute bit, usually 04000.  *Note How
     Change Persona::.

`S_ISGID'
     This is the set-group-ID on execute bit, usually 02000.  *Note How
     Change Persona::.

`S_ISVTX'
     This is the "sticky" bit, usually 01000.

     For a directory it gives permission to delete a file in that
     directory only if you own that file.  Ordinarily, a user can
     either delete all the files in a directory or cannot delete any of
     them (based on whether the user has write permission for the
     directory).  The same restriction applies--you must have both
     write permission for the directory and own the file you want to
     delete.  The one exception is that the owner of the directory can
     delete any file in the directory, no matter who owns it (provided
     the owner has given himself write permission for the directory).
     This is commonly used for the `/tmp' directory, where anyone may
     create files but not delete files created by other users.

     Originally the sticky bit on an executable file modified the
     swapping policies of the system.  Normally, when a program
     terminated, its pages in core were immediately freed and reused.
     If the sticky bit was set on the executable file, the system kept
     the pages in core for a while as if the program were still
     running.  This was advantageous for a program likely to be run
     many times in succession.  This usage is obsolete in modern
     systems.  When a program terminates, its pages always remain in
     core as long as there is no shortage of memory in the system.
     When the program is next run, its pages will still be in core if
     no shortage arose since the last run.

     On some modern systems where the sticky bit has no useful meaning
     for an executable file, you cannot set the bit at all for a
     non-directory.  If you try, `chmod' fails with `EFTYPE'; *note
     Setting Permissions::.

     Some systems (particularly SunOS) have yet another use for the
     sticky bit.  If the sticky bit is set on a file that is _not_
     executable, it means the opposite: never cache the pages of this
     file at all.  The main use of this is for the files on an NFS
     server machine which are used as the swap area of diskless client
     machines.  The idea is that the pages of the file will be cached
     in the client's memory, so it is a waste of the server's memory to
     cache them a second time.  With this usage the sticky bit also
     implies that the filesystem may fail to record the file's
     modification time onto disk reliably (the idea being that no-one
     cares for a swap file).

     This bit is only available on BSD systems (and those derived from
     them).  Therefore one has to use the `_BSD_SOURCE' feature select
     macro to get the definition (*note Feature Test Macros::).

   The actual bit values of the symbols are listed in the table above
so you can decode file mode values when debugging your programs.  These
bit values are correct for most systems, but they are not guaranteed.

   *Warning:* Writing explicit numbers for file permissions is bad
practice.  Not only is it not portable, it also requires everyone who
reads your program to remember what the bits mean.  To make your program
clean use the symbolic names.


File: libc.info,  Node: Access Permission,  Next: Setting Permissions,  Prev: Permission Bits,  Up: File Attributes

14.9.6 How Your Access to a File is Decided
-------------------------------------------

Recall that the operating system normally decides access permission for
a file based on the effective user and group IDs of the process and its
supplementary group IDs, together with the file's owner, group and
permission bits.  These concepts are discussed in detail in *Note
Process Persona::.

   If the effective user ID of the process matches the owner user ID of
the file, then permissions for read, write, and execute/search are
controlled by the corresponding "user" (or "owner") bits.  Likewise, if
any of the effective group ID or supplementary group IDs of the process
matches the group owner ID of the file, then permissions are controlled
by the "group" bits.  Otherwise, permissions are controlled by the
"other" bits.

   Privileged users, like `root', can access any file regardless of its
permission bits.  As a special case, for a file to be executable even
by a privileged user, at least one of its execute bits must be set.


File: libc.info,  Node: Setting Permissions,  Next: Testing File Access,  Prev: Access Permission,  Up: File Attributes

14.9.7 Assigning File Permissions
---------------------------------

The primitive functions for creating files (for example, `open' or
`mkdir') take a MODE argument, which specifies the file permissions to
give the newly created file.  This mode is modified by the process's
"file creation mask", or "umask", before it is used.

   The bits that are set in the file creation mask identify permissions
that are always to be disabled for newly created files.  For example, if
you set all the "other" access bits in the mask, then newly created
files are not accessible at all to processes in the "other" category,
even if the MODE argument passed to the create function would permit
such access.  In other words, the file creation mask is the complement
of the ordinary access permissions you want to grant.

   Programs that create files typically specify a MODE argument that
includes all the permissions that make sense for the particular file.
For an ordinary file, this is typically read and write permission for
all classes of users.  These permissions are then restricted as
specified by the individual user's own file creation mask.

   To change the permission of an existing file given its name, call
`chmod'.  This function uses the specified permission bits and ignores
the file creation mask.

   In normal use, the file creation mask is initialized by the user's
login shell (using the `umask' shell command), and inherited by all
subprocesses.  Application programs normally don't need to worry about
the file creation mask.  It will automatically do what it is supposed to
do.

   When your program needs to create a file and bypass the umask for its
access permissions, the easiest way to do this is to use `fchmod' after
opening the file, rather than changing the umask.  In fact, changing
the umask is usually done only by shells.  They use the `umask'
function.

   The functions in this section are declared in `sys/stat.h'.  

 -- Function: mode_t umask (mode_t MASK)
     The `umask' function sets the file creation mask of the current
     process to MASK, and returns the previous value of the file
     creation mask.

     Here is an example showing how to read the mask with `umask'
     without changing it permanently:

          mode_t
          read_umask (void)
          {
            mode_t mask = umask (0);
            umask (mask);
            return mask;
          }

     However, it is better to use `getumask' if you just want to read
     the mask value, because it is reentrant (at least if you use the
     GNU operating system).

 -- Function: mode_t getumask (void)
     Return the current value of the file creation mask for the current
     process.  This function is a GNU extension.

 -- Function: int chmod (const char *FILENAME, mode_t MODE)
     The `chmod' function sets the access permission bits for the file
     named by FILENAME to MODE.

     If FILENAME is a symbolic link, `chmod' changes the permissions of
     the file pointed to by the link, not those of the link itself.

     This function returns `0' if successful and `-1' if not.  In
     addition to the usual file name errors (*note File Name Errors::),
     the following `errno' error conditions are defined for this
     function:

    `ENOENT'
          The named file doesn't exist.

    `EPERM'
          This process does not have permission to change the access
          permissions of this file.  Only the file's owner (as judged
          by the effective user ID of the process) or a privileged user
          can change them.

    `EROFS'
          The file resides on a read-only file system.

    `EFTYPE'
          MODE has the `S_ISVTX' bit (the "sticky bit") set, and the
          named file is not a directory.  Some systems do not allow
          setting the sticky bit on non-directory files, and some do
          (and only some of those assign a useful meaning to the bit
          for non-directory files).

          You only get `EFTYPE' on systems where the sticky bit has no
          useful meaning for non-directory files, so it is always safe
          to just clear the bit in MODE and call `chmod' again.  *Note
          Permission Bits::, for full details on the sticky bit.

 -- Function: int fchmod (int FILEDES, int MODE)
     This is like `chmod', except that it changes the permissions of the
     currently open file given by FILEDES.

     The return value from `fchmod' is `0' on success and `-1' on
     failure.  The following `errno' error codes are defined for this
     function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The FILEDES argument corresponds to a pipe or socket, or
          something else that doesn't really have access permissions.

    `EPERM'
          This process does not have permission to change the access
          permissions of this file.  Only the file's owner (as judged
          by the effective user ID of the process) or a privileged user
          can change them.

    `EROFS'
          The file resides on a read-only file system.


File: libc.info,  Node: Testing File Access,  Next: File Times,  Prev: Setting Permissions,  Up: File Attributes

14.9.8 Testing Permission to Access a File
------------------------------------------

In some situations it is desirable to allow programs to access files or
devices even if this is not possible with the permissions granted to the
user.  One possible solution is to set the setuid-bit of the program
file.  If such a program is started the _effective_ user ID of the
process is changed to that of the owner of the program file.  So to
allow write access to files like `/etc/passwd', which normally can be
written only by the super-user, the modifying program will have to be
owned by `root' and the setuid-bit must be set.

   But beside the files the program is intended to change the user
should not be allowed to access any file to which s/he would not have
access anyway.  The program therefore must explicitly check whether _the
user_ would have the necessary access to a file, before it reads or
writes the file.

   To do this, use the function `access', which checks for access
permission based on the process's _real_ user ID rather than the
effective user ID.  (The setuid feature does not alter the real user ID,
so it reflects the user who actually ran the program.)

   There is another way you could check this access, which is easy to
describe, but very hard to use.  This is to examine the file mode bits
and mimic the system's own access computation.  This method is
undesirable because many systems have additional access control
features; your program cannot portably mimic them, and you would not
want to try to keep track of the diverse features that different systems
have.  Using `access' is simple and automatically does whatever is
appropriate for the system you are using.

   `access' is _only_ only appropriate to use in setuid programs.  A
non-setuid program will always use the effective ID rather than the
real ID.

   The symbols in this section are declared in `unistd.h'.

 -- Function: int access (const char *FILENAME, int HOW)
     The `access' function checks to see whether the file named by
     FILENAME can be accessed in the way specified by the HOW argument.
     The HOW argument either can be the bitwise OR of the flags
     `R_OK', `W_OK', `X_OK', or the existence test `F_OK'.

     This function uses the _real_ user and group IDs of the calling
     process, rather than the _effective_ IDs, to check for access
     permission.  As a result, if you use the function from a `setuid'
     or `setgid' program (*note How Change Persona::), it gives
     information relative to the user who actually ran the program.

     The return value is `0' if the access is permitted, and `-1'
     otherwise.  (In other words, treated as a predicate function,
     `access' returns true if the requested access is _denied_.)

     In addition to the usual file name errors (*note File Name
     Errors::), the following `errno' error conditions are defined for
     this function:

    `EACCES'
          The access specified by HOW is denied.

    `ENOENT'
          The file doesn't exist.

    `EROFS'
          Write permission was requested for a file on a read-only file
          system.

   These macros are defined in the header file `unistd.h' for use as
the HOW argument to the `access' function.  The values are integer
constants.  

 -- Macro: int R_OK
     Flag meaning test for read permission.

 -- Macro: int W_OK
     Flag meaning test for write permission.

 -- Macro: int X_OK
     Flag meaning test for execute/search permission.

 -- Macro: int F_OK
     Flag meaning test for existence of the file.


File: libc.info,  Node: File Times,  Next: File Size,  Prev: Testing File Access,  Up: File Attributes

14.9.9 File Times
-----------------

Each file has three time stamps associated with it:  its access time,
its modification time, and its attribute modification time.  These
correspond to the `st_atime', `st_mtime', and `st_ctime' members of the
`stat' structure; see *Note File Attributes::.

   All of these times are represented in calendar time format, as
`time_t' objects.  This data type is defined in `time.h'.  For more
information about representation and manipulation of time values, see
*Note Calendar Time::.  

   Reading from a file updates its access time attribute, and writing
updates its modification time.  When a file is created, all three time
stamps for that file are set to the current time.  In addition, the
attribute change time and modification time fields of the directory that
contains the new entry are updated.

   Adding a new name for a file with the `link' function updates the
attribute change time field of the file being linked, and both the
attribute change time and modification time fields of the directory
containing the new name.  These same fields are affected if a file name
is deleted with `unlink', `remove' or `rmdir'.  Renaming a file with
`rename' affects only the attribute change time and modification time
fields of the two parent directories involved, and not the times for
the file being renamed.

   Changing the attributes of a file (for example, with `chmod')
updates its attribute change time field.

   You can also change some of the time stamps of a file explicitly
using the `utime' function--all except the attribute change time.  You
need to include the header file `utime.h' to use this facility.  

 -- Data Type: struct utimbuf
     The `utimbuf' structure is used with the `utime' function to
     specify new access and modification times for a file.  It contains
     the following members:

    `time_t actime'
          This is the access time for the file.

    `time_t modtime'
          This is the modification time for the file.

 -- Function: int utime (const char *FILENAME, const struct utimbuf
          *TIMES)
     This function is used to modify the file times associated with the
     file named FILENAME.

     If TIMES is a null pointer, then the access and modification times
     of the file are set to the current time.  Otherwise, they are set
     to the values from the `actime' and `modtime' members
     (respectively) of the `utimbuf' structure pointed to by TIMES.

     The attribute modification time for the file is set to the current
     time in either case (since changing the time stamps is itself a
     modification of the file attributes).

     The `utime' function returns `0' if successful and `-1' on
     failure.  In addition to the usual file name errors (*note File
     Name Errors::), the following `errno' error conditions are defined
     for this function:

    `EACCES'
          There is a permission problem in the case where a null
          pointer was passed as the TIMES argument.  In order to update
          the time stamp on the file, you must either be the owner of
          the file, have write permission for the file, or be a
          privileged user.

    `ENOENT'
          The file doesn't exist.

    `EPERM'
          If the TIMES argument is not a null pointer, you must either
          be the owner of the file or be a privileged user.

    `EROFS'
          The file lives on a read-only file system.

   Each of the three time stamps has a corresponding microsecond part,
which extends its resolution.  These fields are called `st_atime_usec',
`st_mtime_usec', and `st_ctime_usec'; each has a value between 0 and
999,999, which indicates the time in microseconds.  They correspond to
the `tv_usec' field of a `timeval' structure; see *Note High-Resolution
Calendar::.

   The `utimes' function is like `utime', but also lets you specify the
fractional part of the file times.  The prototype for this function is
in the header file `sys/time.h'.  

 -- Function: int utimes (const char *FILENAME, struct timeval TVP[2])
     This function sets the file access and modification times of the
     file FILENAME.  The new file access time is specified by `TVP[0]',
     and the new modification time by `TVP[1]'.  Similar to `utime', if
     TVP is a null pointer then the access and modification times of
     the file are set to the current time.  This function comes from
     BSD.

     The return values and error conditions are the same as for the
     `utime' function.

 -- Function: int lutimes (const char *FILENAME, struct timeval TVP[2])
     This function is like `utimes', except that it does not follow
     symbolic links.  If FILENAME is the name of a symbolic link,
     `lutimes' sets the file access and modification times of the
     symbolic link special file itself (as seen by `lstat'; *note
     Symbolic Links::) while `utimes' sets the file access and
     modification times of the file the symbolic link refers to.  This
     function comes from FreeBSD, and is not available on all platforms
     (if not available, it will fail with `ENOSYS').

     The return values and error conditions are the same as for the
     `utime' function.

 -- Function: int futimes (int FD, struct timeval TVP[2])
     This function is like `utimes', except that it takes an open file
     descriptor as an argument instead of a file name.  *Note Low-Level
     I/O::.  This function comes from FreeBSD, and is not available on
     all platforms (if not available, it will fail with `ENOSYS').

     Like `utimes', `futimes' returns `0' on success and `-1' on
     failure.  The following `errno' error conditions are defined for
     `futimes':

    `EACCES'
          There is a permission problem in the case where a null
          pointer was passed as the TIMES argument.  In order to update
          the time stamp on the file, you must either be the owner of
          the file, have write permission for the file, or be a
          privileged user.

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EPERM'
          If the TIMES argument is not a null pointer, you must either
          be the owner of the file or be a privileged user.

    `EROFS'
          The file lives on a read-only file system.


File: libc.info,  Node: File Size,  Prev: File Times,  Up: File Attributes

14.9.10 File Size
-----------------

Normally file sizes are maintained automatically.  A file begins with a
size of 0 and is automatically extended when data is written past its
end.  It is also possible to empty a file completely by an `open' or
`fopen' call.

   However, sometimes it is necessary to _reduce_ the size of a file.
This can be done with the `truncate' and `ftruncate' functions.  They
were introduced in BSD Unix.  `ftruncate' was later added to POSIX.1.

   Some systems allow you to extend a file (creating holes) with these
functions.  This is useful when using memory-mapped I/O (*note
Memory-mapped I/O::), where files are not automatically extended.
However, it is not portable but must be implemented if `mmap' allows
mapping of files (i.e., `_POSIX_MAPPED_FILES' is defined).

   Using these functions on anything other than a regular file gives
_undefined_ results.  On many systems, such a call will appear to
succeed, without actually accomplishing anything.

 -- Function: int truncate (const char *FILENAME, off_t LENGTH)
     The `truncate' function changes the size of FILENAME to LENGTH.
     If LENGTH is shorter than the previous length, data at the end
     will be lost.  The file must be writable by the user to perform
     this operation.

     If LENGTH is longer, holes will be added to the end.  However, some
     systems do not support this feature and will leave the file
     unchanged.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' the
     `truncate' function is in fact `truncate64' and the type `off_t'
     has 64 bits which makes it possible to handle files up to 2^63
     bytes in length.

     The return value is 0 for success, or -1 for an error.  In
     addition to the usual file name errors, the following errors may
     occur:

    `EACCES'
          The file is a directory or not writable.

    `EINVAL'
          LENGTH is negative.

    `EFBIG'
          The operation would extend the file beyond the limits of the
          operating system.

    `EIO'
          A hardware I/O error occurred.

    `EPERM'
          The file is "append-only" or "immutable".

    `EINTR'
          The operation was interrupted by a signal.



 -- Function: int truncate64 (const char *NAME, off64_t LENGTH)
     This function is similar to the `truncate' function.  The
     difference is that the LENGTH argument is 64 bits wide even on 32
     bits machines, which allows the handling of files with sizes up to
     2^63 bytes.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' on
     a 32 bits machine this function is actually available under the
     name `truncate' and so transparently replaces the 32 bits
     interface.

 -- Function: int ftruncate (int FD, off_t LENGTH)
     This is like `truncate', but it works on a file descriptor FD for
     an opened file instead of a file name to identify the object.  The
     file must be opened for writing to successfully carry out the
     operation.

     The POSIX standard leaves it implementation defined what happens
     if the specified new LENGTH of the file is bigger than the
     original size.  The `ftruncate' function might simply leave the
     file alone and do nothing or it can increase the size to the
     desired size.  In this later case the extended area should be
     zero-filled.  So using `ftruncate' is no reliable way to increase
     the file size but if it is possible it is probably the fastest
     way.  The function also operates on POSIX shared memory segments
     if these are implemented by the system.

     `ftruncate' is especially useful in combination with `mmap'.
     Since the mapped region must have a fixed size one cannot enlarge
     the file by writing something beyond the last mapped page.
     Instead one has to enlarge the file itself and then remap the file
     with the new size.  The example below shows how this works.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' the
     `ftruncate' function is in fact `ftruncate64' and the type `off_t'
     has 64 bits which makes it possible to handle files up to 2^63
     bytes in length.

     The return value is 0 for success, or -1 for an error.  The
     following errors may occur:

    `EBADF'
          FD does not correspond to an open file.

    `EACCES'
          FD is a directory or not open for writing.

    `EINVAL'
          LENGTH is negative.

    `EFBIG'
          The operation would extend the file beyond the limits of the
          operating system.

    `EIO'
          A hardware I/O error occurred.

    `EPERM'
          The file is "append-only" or "immutable".

    `EINTR'
          The operation was interrupted by a signal.



 -- Function: int ftruncate64 (int ID, off64_t LENGTH)
     This function is similar to the `ftruncate' function.  The
     difference is that the LENGTH argument is 64 bits wide even on 32
     bits machines which allows the handling of files with sizes up to
     2^63 bytes.

     When the source file is compiled with `_FILE_OFFSET_BITS == 64' on
     a 32 bits machine this function is actually available under the
     name `ftruncate' and so transparently replaces the 32 bits
     interface.

   As announced here is a little example of how to use `ftruncate' in
combination with `mmap':

     int fd;
     void *start;
     size_t len;

     int
     add (off_t at, void *block, size_t size)
     {
       if (at + size > len)
         {
           /* Resize the file and remap.  */
           size_t ps = sysconf (_SC_PAGESIZE);
           size_t ns = (at + size + ps - 1) & ~(ps - 1);
           void *np;
           if (ftruncate (fd, ns) < 0)
             return -1;
           np = mmap (NULL, ns, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
           if (np == MAP_FAILED)
             return -1;
           start = np;
           len = ns;
         }
       memcpy ((char *) start + at, block, size);
       return 0;
     }

   The function `add' writes a block of memory at an arbitrary position
in the file.  If the current size of the file is too small it is
extended.  Note the it is extended by a round number of pages.  This is
a requirement of `mmap'.  The program has to keep track of the real
size, and when it has finished a final `ftruncate' call should set the
real size of the file.


File: libc.info,  Node: Making Special Files,  Next: Temporary Files,  Prev: File Attributes,  Up: File System Interface

14.10 Making Special Files
==========================

The `mknod' function is the primitive for making special files, such as
files that correspond to devices.  The GNU library includes this
function for compatibility with BSD.

   The prototype for `mknod' is declared in `sys/stat.h'.  

 -- Function: int mknod (const char *FILENAME, int MODE, int DEV)
     The `mknod' function makes a special file with name FILENAME.  The
     MODE specifies the mode of the file, and may include the various
     special file bits, such as `S_IFCHR' (for a character special file)
     or `S_IFBLK' (for a block special file).  *Note Testing File
     Type::.

     The DEV argument specifies which device the special file refers to.
     Its exact interpretation depends on the kind of special file being
     created.

     The return value is `0' on success and `-1' on error.  In addition
     to the usual file name errors (*note File Name Errors::), the
     following `errno' error conditions are defined for this function:

    `EPERM'
          The calling process is not privileged.  Only the superuser
          can create special files.

    `ENOSPC'
          The directory or file system that would contain the new file
          is full and cannot be extended.

    `EROFS'
          The directory containing the new file can't be modified
          because it's on a read-only file system.

    `EEXIST'
          There is already a file named FILENAME.  If you want to
          replace this file, you must remove the old file explicitly
          first.


File: libc.info,  Node: Temporary Files,  Prev: Making Special Files,  Up: File System Interface

14.11 Temporary Files
=====================

If you need to use a temporary file in your program, you can use the
`tmpfile' function to open it.  Or you can use the `tmpnam' (better:
`tmpnam_r') function to provide a name for a temporary file and then
you can open it in the usual way with `fopen'.

   The `tempnam' function is like `tmpnam' but lets you choose what
directory temporary files will go in, and something about what their
file names will look like.  Important for multi-threaded programs is
that `tempnam' is reentrant, while `tmpnam' is not since it returns a
pointer to a static buffer.

   These facilities are declared in the header file `stdio.h'.  

 -- Function: FILE * tmpfile (void)
     This function creates a temporary binary file for update mode, as
     if by calling `fopen' with mode `"wb+"'.  The file is deleted
     automatically when it is closed or when the program terminates.
     (On some other ISO C systems the file may fail to be deleted if
     the program terminates abnormally).

     This function is reentrant.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit system this function is in fact `tmpfile64', i.e., the LFS
     interface transparently replaces the old interface.

 -- Function: FILE * tmpfile64 (void)
     This function is similar to `tmpfile', but the stream it returns a
     pointer to was opened using `tmpfile64'.  Therefore this stream can
     be used for files larger then 2^31 bytes on 32-bit machines.

     Please note that the return type is still `FILE *'.  There is no
     special `FILE' type for the LFS interface.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a 32
     bits machine this function is available under the name `tmpfile'
     and so transparently replaces the old interface.

 -- Function: char * tmpnam (char *RESULT)
     This function constructs and returns a valid file name that does
     not refer to any existing file.  If the RESULT argument is a null
     pointer, the return value is a pointer to an internal static
     string, which might be modified by subsequent calls and therefore
     makes this function non-reentrant.  Otherwise, the RESULT argument
     should be a pointer to an array of at least `L_tmpnam' characters,
     and the result is written into that array.

     It is possible for `tmpnam' to fail if you call it too many times
     without removing previously-created files.  This is because the
     limited length of the temporary file names gives room for only a
     finite number of different names.  If `tmpnam' fails it returns a
     null pointer.

     *Warning:* Between the time the pathname is constructed and the
     file is created another process might have created a file with the
     same name using `tmpnam', leading to a possible security hole.  The
     implementation generates names which can hardly be predicted, but
     when opening the file you should use the `O_EXCL' flag.  Using
     `tmpfile' or `mkstemp' is a safe way to avoid this problem.

 -- Function: char * tmpnam_r (char *RESULT)
     This function is nearly identical to the `tmpnam' function, except
     that if RESULT is a null pointer it returns a null pointer.

     This guarantees reentrancy because the non-reentrant situation of
     `tmpnam' cannot happen here.

     *Warning*: This function has the same security problems as
     `tmpnam'.

 -- Macro: int L_tmpnam
     The value of this macro is an integer constant expression that
     represents the minimum size of a string large enough to hold a
     file name generated by the `tmpnam' function.

 -- Macro: int TMP_MAX
     The macro `TMP_MAX' is a lower bound for how many temporary names
     you can create with `tmpnam'.  You can rely on being able to call
     `tmpnam' at least this many times before it might fail saying you
     have made too many temporary file names.

     With the GNU library, you can create a very large number of
     temporary file names.  If you actually created the files, you
     would probably run out of disk space before you ran out of names.
     Some other systems have a fixed, small limit on the number of
     temporary files.  The limit is never less than `25'.

 -- Function: char * tempnam (const char *DIR, const char *PREFIX)
     This function generates a unique temporary file name.  If PREFIX
     is not a null pointer, up to five characters of this string are
     used as a prefix for the file name.  The return value is a string
     newly allocated with `malloc', so you should release its storage
     with `free' when it is no longer needed.

     Because the string is dynamically allocated this function is
     reentrant.

     The directory prefix for the temporary file name is determined by
     testing each of the following in sequence.  The directory must
     exist and be writable.

        * The environment variable `TMPDIR', if it is defined.  For
          security reasons this only happens if the program is not SUID
          or SGID enabled.

        * The DIR argument, if it is not a null pointer.

        * The value of the `P_tmpdir' macro.

        * The directory `/tmp'.

     This function is defined for SVID compatibility.

     *Warning:* Between the time the pathname is constructed and the
     file is created another process might have created a file with the
     same name using `tempnam', leading to a possible security hole.
     The implementation generates names which can hardly be predicted,
     but when opening the file you should use the `O_EXCL' flag.  Using
     `tmpfile' or `mkstemp' is a safe way to avoid this problem.
   
 -- SVID Macro: char * P_tmpdir
     This macro is the name of the default directory for temporary
     files.

   Older Unix systems did not have the functions just described.
Instead they used `mktemp' and `mkstemp'.  Both of these functions work
by modifying a file name template string you pass.  The last six
characters of this string must be `XXXXXX'.  These six `X's are
replaced with six characters which make the whole string a unique file
name.  Usually the template string is something like
`/tmp/PREFIXXXXXXX', and each program uses a unique PREFIX.

   *NB:* Because `mktemp' and `mkstemp' modify the template string, you
_must not_ pass string constants to them.  String constants are
normally in read-only storage, so your program would crash when
`mktemp' or `mkstemp' tried to modify the string.  These functions are
declared in the header file `stdlib.h'.  

 -- Function: char * mktemp (char *TEMPLATE)
     The `mktemp' function generates a unique file name by modifying
     TEMPLATE as described above.  If successful, it returns TEMPLATE
     as modified.  If `mktemp' cannot find a unique file name, it makes
     TEMPLATE an empty string and returns that.  If TEMPLATE does not
     end with `XXXXXX', `mktemp' returns a null pointer.

     *Warning:* Between the time the pathname is constructed and the
     file is created another process might have created a file with the
     same name using `mktemp', leading to a possible security hole.  The
     implementation generates names which can hardly be predicted, but
     when opening the file you should use the `O_EXCL' flag.  Using
     `mkstemp' is a safe way to avoid this problem.

 -- Function: int mkstemp (char *TEMPLATE)
     The `mkstemp' function generates a unique file name just as
     `mktemp' does, but it also opens the file for you with `open'
     (*note Opening and Closing Files::).  If successful, it modifies
     TEMPLATE in place and returns a file descriptor for that file open
     for reading and writing.  If `mkstemp' cannot create a
     uniquely-named file, it returns `-1'.  If TEMPLATE does not end
     with `XXXXXX', `mkstemp' returns `-1' and does not modify TEMPLATE.

     The file is opened using mode `0600'.  If the file is meant to be
     used by other users this mode must be changed explicitly.

   Unlike `mktemp', `mkstemp' is actually guaranteed to create a unique
file that cannot possibly clash with any other program trying to create
a temporary file.  This is because it works by calling `open' with the
`O_EXCL' flag, which says you want to create a new file and get an
error if the file already exists.

 -- Function: char * mkdtemp (char *TEMPLATE)
     The `mkdtemp' function creates a directory with a unique name.  If
     it succeeds, it overwrites TEMPLATE with the name of the
     directory, and returns TEMPLATE.  As with `mktemp' and `mkstemp',
     TEMPLATE should be a string ending with `XXXXXX'.

     If `mkdtemp' cannot create an uniquely named directory, it returns
     `NULL' and sets ERRNO appropriately.  If TEMPLATE does not end
     with `XXXXXX', `mkdtemp' returns `NULL' and does not modify
     TEMPLATE.  ERRNO will be set to `EINVAL' in this case.

     The directory is created using mode `0700'.

   The directory created by `mkdtemp' cannot clash with temporary files
or directories created by other users.  This is because directory
creation always works like `open' with `O_EXCL'.  *Note Creating
Directories::.

   The `mkdtemp' function comes from OpenBSD.


File: libc.info,  Node: Pipes and FIFOs,  Next: Sockets,  Prev: File System Interface,  Up: Top

15 Pipes and FIFOs
******************

A "pipe" is a mechanism for interprocess communication; data written to
the pipe by one process can be read by another process.  The data is
handled in a first-in, first-out (FIFO) order.  The pipe has no name; it
is created for one use and both ends must be inherited from the single
process which created the pipe.

   A "FIFO special file" is similar to a pipe, but instead of being an
anonymous, temporary connection, a FIFO has a name or names like any
other file.  Processes open the FIFO by name in order to communicate
through it.

   A pipe or FIFO has to be open at both ends simultaneously.  If you
read from a pipe or FIFO file that doesn't have any processes writing
to it (perhaps because they have all closed the file, or exited), the
read returns end-of-file.  Writing to a pipe or FIFO that doesn't have a
reading process is treated as an error condition; it generates a
`SIGPIPE' signal, and fails with error code `EPIPE' if the signal is
handled or blocked.

   Neither pipes nor FIFO special files allow file positioning.  Both
reading and writing operations happen sequentially; reading from the
beginning of the file and writing at the end.

* Menu:

* Creating a Pipe::             Making a pipe with the `pipe' function.
* Pipe to a Subprocess::        Using a pipe to communicate with a
				 child process.
* FIFO Special Files::          Making a FIFO special file.
* Pipe Atomicity::		When pipe (or FIFO) I/O is atomic.


File: libc.info,  Node: Creating a Pipe,  Next: Pipe to a Subprocess,  Up: Pipes and FIFOs

15.1 Creating a Pipe
====================

The primitive for creating a pipe is the `pipe' function.  This creates
both the reading and writing ends of the pipe.  It is not very useful
for a single process to use a pipe to talk to itself.  In typical use,
a process creates a pipe just before it forks one or more child
processes (*note Creating a Process::).  The pipe is then used for
communication either between the parent or child processes, or between
two sibling processes.

   The `pipe' function is declared in the header file `unistd.h'.  

 -- Function: int pipe (int FILEDES[2])
     The `pipe' function creates a pipe and puts the file descriptors
     for the reading and writing ends of the pipe (respectively) into
     `FILEDES[0]' and `FILEDES[1]'.

     An easy way to remember that the input end comes first is that file
     descriptor `0' is standard input, and file descriptor `1' is
     standard output.

     If successful, `pipe' returns a value of `0'.  On failure, `-1' is
     returned.  The following `errno' error conditions are defined for
     this function:

    `EMFILE'
          The process has too many files open.

    `ENFILE'
          There are too many open files in the entire system.  *Note
          Error Codes::, for more information about `ENFILE'.  This
          error never occurs in the GNU system.

   Here is an example of a simple program that creates a pipe.  This
program uses the `fork' function (*note Creating a Process::) to create
a child process.  The parent process writes data to the pipe, which is
read by the child process.

     #include <sys/types.h>
     #include <unistd.h>
     #include <stdio.h>
     #include <stdlib.h>

     /* Read characters from the pipe and echo them to `stdout'. */

     void
     read_from_pipe (int file)
     {
       FILE *stream;
       int c;
       stream = fdopen (file, "r");
       while ((c = fgetc (stream)) != EOF)
         putchar (c);
       fclose (stream);
     }

     /* Write some random text to the pipe. */

     void
     write_to_pipe (int file)
     {
       FILE *stream;
       stream = fdopen (file, "w");
       fprintf (stream, "hello, world!\n");
       fprintf (stream, "goodbye, world!\n");
       fclose (stream);
     }

     int
     main (void)
     {
       pid_t pid;
       int mypipe[2];

       /* Create the pipe. */
       if (pipe (mypipe))
         {
           fprintf (stderr, "Pipe failed.\n");
           return EXIT_FAILURE;
         }

       /* Create the child process. */
       pid = fork ();
       if (pid == (pid_t) 0)
         {
           /* This is the child process.
              Close other end first. */
           close (mypipe[1]);
           read_from_pipe (mypipe[0]);
           return EXIT_SUCCESS;
         }
       else if (pid < (pid_t) 0)
         {
           /* The fork failed. */
           fprintf (stderr, "Fork failed.\n");
           return EXIT_FAILURE;
         }
       else
         {
           /* This is the parent process.
              Close other end first. */
           close (mypipe[0]);
           write_to_pipe (mypipe[1]);
           return EXIT_SUCCESS;
         }
     }


File: libc.info,  Node: Pipe to a Subprocess,  Next: FIFO Special Files,  Prev: Creating a Pipe,  Up: Pipes and FIFOs

15.2 Pipe to a Subprocess
=========================

A common use of pipes is to send data to or receive data from a program
being run as a subprocess.  One way of doing this is by using a
combination of `pipe' (to create the pipe), `fork' (to create the
subprocess), `dup2' (to force the subprocess to use the pipe as its
standard input or output channel), and `exec' (to execute the new
program).  Or, you can use `popen' and `pclose'.

   The advantage of using `popen' and `pclose' is that the interface is
much simpler and easier to use.  But it doesn't offer as much
flexibility as using the low-level functions directly.

 -- Function: FILE * popen (const char *COMMAND, const char *MODE)
     The `popen' function is closely related to the `system' function;
     see *Note Running a Command::.  It executes the shell command
     COMMAND as a subprocess.  However, instead of waiting for the
     command to complete, it creates a pipe to the subprocess and
     returns a stream that corresponds to that pipe.

     If you specify a MODE argument of `"r"', you can read from the
     stream to retrieve data from the standard output channel of the
     subprocess.  The subprocess inherits its standard input channel
     from the parent process.

     Similarly, if you specify a MODE argument of `"w"', you can write
     to the stream to send data to the standard input channel of the
     subprocess.  The subprocess inherits its standard output channel
     from the parent process.

     In the event of an error `popen' returns a null pointer.  This
     might happen if the pipe or stream cannot be created, if the
     subprocess cannot be forked, or if the program cannot be executed.

 -- Function: int pclose (FILE *STREAM)
     The `pclose' function is used to close a stream created by `popen'.
     It waits for the child process to terminate and returns its status
     value, as for the `system' function.

   Here is an example showing how to use `popen' and `pclose' to filter
output through another program, in this case the paging program `more'.

     #include <stdio.h>
     #include <stdlib.h>

     void
     write_data (FILE * stream)
     {
       int i;
       for (i = 0; i < 100; i++)
         fprintf (stream, "%d\n", i);
       if (ferror (stream))
         {
           fprintf (stderr, "Output to stream failed.\n");
           exit (EXIT_FAILURE);
         }
     }

     int
     main (void)
     {
       FILE *output;

       output = popen ("more", "w");
       if (!output)
         {
           fprintf (stderr,
                    "incorrect parameters or too many files.\n");
           return EXIT_FAILURE;
         }
       write_data (output);
       if (pclose (output) != 0)
         {
           fprintf (stderr,
                    "Could not run more or other error.\n");
         }
       return EXIT_SUCCESS;
     }


File: libc.info,  Node: FIFO Special Files,  Next: Pipe Atomicity,  Prev: Pipe to a Subprocess,  Up: Pipes and FIFOs

15.3 FIFO Special Files
=======================

A FIFO special file is similar to a pipe, except that it is created in a
different way.  Instead of being an anonymous communications channel, a
FIFO special file is entered into the file system by calling `mkfifo'.

   Once you have created a FIFO special file in this way, any process
can open it for reading or writing, in the same way as an ordinary file.
However, it has to be open at both ends simultaneously before you can
proceed to do any input or output operations on it.  Opening a FIFO for
reading normally blocks until some other process opens the same FIFO for
writing, and vice versa.

   The `mkfifo' function is declared in the header file `sys/stat.h'.  

 -- Function: int mkfifo (const char *FILENAME, mode_t MODE)
     The `mkfifo' function makes a FIFO special file with name
     FILENAME.  The MODE argument is used to set the file's
     permissions; see *Note Setting Permissions::.

     The normal, successful return value from `mkfifo' is `0'.  In the
     case of an error, `-1' is returned.  In addition to the usual file
     name errors (*note File Name Errors::), the following `errno'
     error conditions are defined for this function:

    `EEXIST'
          The named file already exists.

    `ENOSPC'
          The directory or file system cannot be extended.

    `EROFS'
          The directory that would contain the file resides on a
          read-only file system.


File: libc.info,  Node: Pipe Atomicity,  Prev: FIFO Special Files,  Up: Pipes and FIFOs

15.4 Atomicity of Pipe I/O
==========================

Reading or writing pipe data is "atomic" if the size of data written is
not greater than `PIPE_BUF'.  This means that the data transfer seems
to be an instantaneous unit, in that nothing else in the system can
observe a state in which it is partially complete.  Atomic I/O may not
begin right away (it may need to wait for buffer space or for data),
but once it does begin it finishes immediately.

   Reading or writing a larger amount of data may not be atomic; for
example, output data from other processes sharing the descriptor may be
interspersed.  Also, once `PIPE_BUF' characters have been written,
further writes will block until some characters are read.

   *Note Limits for Files::, for information about the `PIPE_BUF'
parameter.


File: libc.info,  Node: Sockets,  Next: Low-Level Terminal Interface,  Prev: Pipes and FIFOs,  Up: Top

16 Sockets
**********

This chapter describes the GNU facilities for interprocess
communication using sockets.

   A "socket" is a generalized interprocess communication channel.
Like a pipe, a socket is represented as a file descriptor.  Unlike pipes
sockets support communication between unrelated processes, and even
between processes running on different machines that communicate over a
network.  Sockets are the primary means of communicating with other
machines; `telnet', `rlogin', `ftp', `talk' and the other familiar
network programs use sockets.

   Not all operating systems support sockets.  In the GNU library, the
header file `sys/socket.h' exists regardless of the operating system,
and the socket functions always exist, but if the system does not
really support sockets these functions always fail.

   *Incomplete:* We do not currently document the facilities for
broadcast messages or for configuring Internet interfaces.  The
reentrant functions and some newer functions that are related to IPv6
aren't documented either so far.

* Menu:

* Socket Concepts::	Basic concepts you need to know about.
* Communication Styles::Stream communication, datagrams and other styles.
* Socket Addresses::	How socket names (``addresses'') work.
* Interface Naming::	Identifying specific network interfaces.
* Local Namespace::	Details about the local namespace.
* Internet Namespace::	Details about the Internet namespace.
* Misc Namespaces::	Other namespaces not documented fully here.
* Open/Close Sockets::  Creating sockets and destroying them.
* Connections::		Operations on sockets with connection state.
* Datagrams::		Operations on datagram sockets.
* Inetd::		Inetd is a daemon that starts servers on request.
			   The most convenient way to write a server
			   is to make it work with Inetd.
* Socket Options::	Miscellaneous low-level socket options.
* Networks Database::   Accessing the database of network names.


File: libc.info,  Node: Socket Concepts,  Next: Communication Styles,  Up: Sockets

16.1 Socket Concepts
====================

When you create a socket, you must specify the style of communication
you want to use and the type of protocol that should implement it.  The
"communication style" of a socket defines the user-level semantics of
sending and receiving data on the socket.  Choosing a communication
style specifies the answers to questions such as these:

   * *What are the units of data transmission?*  Some communication
     styles regard the data as a sequence of bytes with no larger
     structure; others group the bytes into records (which are known in
     this context as "packets").

   * *Can data be lost during normal operation?*  Some communication
     styles guarantee that all the data sent arrives in the order it was
     sent (barring system or network crashes); other styles occasionally
     lose data as a normal part of operation, and may sometimes deliver
     packets more than once or in the wrong order.

     Designing a program to use unreliable communication styles usually
     involves taking precautions to detect lost or misordered packets
     and to retransmit data as needed.

   * *Is communication entirely with one partner?*  Some communication
     styles are like a telephone call--you make a "connection" with one
     remote socket and then exchange data freely.  Other styles are
     like mailing letters--you specify a destination address for each
     message you send.

   You must also choose a "namespace" for naming the socket.  A socket
name ("address") is meaningful only in the context of a particular
namespace.  In fact, even the data type to use for a socket name may
depend on the namespace.  Namespaces are also called "domains", but we
avoid that word as it can be confused with other usage of the same
term.  Each namespace has a symbolic name that starts with `PF_'.  A
corresponding symbolic name starting with `AF_' designates the address
format for that namespace.

   Finally you must choose the "protocol" to carry out the
communication.  The protocol determines what low-level mechanism is used
to transmit and receive data.  Each protocol is valid for a particular
namespace and communication style; a namespace is sometimes called a
"protocol family" because of this, which is why the namespace names
start with `PF_'.

   The rules of a protocol apply to the data passing between two
programs, perhaps on different computers; most of these rules are
handled by the operating system and you need not know about them.  What
you do need to know about protocols is this:

   * In order to have communication between two sockets, they must
     specify the _same_ protocol.

   * Each protocol is meaningful with particular style/namespace
     combinations and cannot be used with inappropriate combinations.
     For example, the TCP protocol fits only the byte stream style of
     communication and the Internet namespace.

   * For each combination of style and namespace there is a "default
     protocol", which you can request by specifying 0 as the protocol
     number.  And that's what you should normally do--use the default.

   Throughout the following description at various places
variables/parameters to denote sizes are required.  And here the trouble
starts.  In the first implementations the type of these variables was
simply `int'.  On most machines at that time an `int' was 32 bits wide,
which created a _de facto_ standard requiring 32-bit variables.  This
is important since references to variables of this type are passed to
the kernel.

   Then the POSIX people came and unified the interface with the words
"all size values are of type `size_t'".  On 64-bit machines `size_t' is
64 bits wide, so pointers to variables were no longer possible.

   The Unix98 specification provides a solution by introducing a type
`socklen_t'.  This type is used in all of the cases that POSIX changed
to use `size_t'.  The only requirement of this type is that it be an
unsigned type of at least 32 bits.  Therefore, implementations which
require that references to 32-bit variables be passed can be as happy
as implementations which use 64-bit values.


File: libc.info,  Node: Communication Styles,  Next: Socket Addresses,  Prev: Socket Concepts,  Up: Sockets

16.2 Communication Styles
=========================

The GNU library includes support for several different kinds of sockets,
each with different characteristics.  This section describes the
supported socket types.  The symbolic constants listed here are defined
in `sys/socket.h'.  

 -- Macro: int SOCK_STREAM
     The `SOCK_STREAM' style is like a pipe (*note Pipes and FIFOs::).
     It operates over a connection with a particular remote socket and
     transmits data reliably as a stream of bytes.

     Use of this style is covered in detail in *Note Connections::.

 -- Macro: int SOCK_DGRAM
     The `SOCK_DGRAM' style is used for sending individually-addressed
     packets unreliably.  It is the diametrical opposite of
     `SOCK_STREAM'.

     Each time you write data to a socket of this kind, that data
     becomes one packet.  Since `SOCK_DGRAM' sockets do not have
     connections, you must specify the recipient address with each
     packet.

     The only guarantee that the system makes about your requests to
     transmit data is that it will try its best to deliver each packet
     you send.  It may succeed with the sixth packet after failing with
     the fourth and fifth packets; the seventh packet may arrive before
     the sixth, and may arrive a second time after the sixth.

     The typical use for `SOCK_DGRAM' is in situations where it is
     acceptable to simply re-send a packet if no response is seen in a
     reasonable amount of time.

     *Note Datagrams::, for detailed information about how to use
     datagram sockets.

 -- Macro: int SOCK_RAW
     This style provides access to low-level network protocols and
     interfaces.  Ordinary user programs usually have no need to use
     this style.


File: libc.info,  Node: Socket Addresses,  Next: Interface Naming,  Prev: Communication Styles,  Up: Sockets

16.3 Socket Addresses
=====================

The name of a socket is normally called an "address".  The functions
and symbols for dealing with socket addresses were named
inconsistently, sometimes using the term "name" and sometimes using
"address".  You can regard these terms as synonymous where sockets are
concerned.

   A socket newly created with the `socket' function has no address.
Other processes can find it for communication only if you give it an
address.  We call this "binding" the address to the socket, and the way
to do it is with the `bind' function.

   You need be concerned with the address of a socket if other processes
are to find it and start communicating with it.  You can specify an
address for other sockets, but this is usually pointless; the first time
you send data from a socket, or use it to initiate a connection, the
system assigns an address automatically if you have not specified one.

   Occasionally a client needs to specify an address because the server
discriminates based on address; for example, the rsh and rlogin
protocols look at the client's socket address and only bypass password
checking if it is less than `IPPORT_RESERVED' (*note Ports::).

   The details of socket addresses vary depending on what namespace you
are using.  *Note Local Namespace::, or *Note Internet Namespace::, for
specific information.

   Regardless of the namespace, you use the same functions `bind' and
`getsockname' to set and examine a socket's address.  These functions
use a phony data type, `struct sockaddr *', to accept the address.  In
practice, the address lives in a structure of some other data type
appropriate to the address format you are using, but you cast its
address to `struct sockaddr *' when you pass it to `bind'.

* Menu:

* Address Formats::		About `struct sockaddr'.
* Setting Address::		Binding an address to a socket.
* Reading Address::		Reading the address of a socket.


File: libc.info,  Node: Address Formats,  Next: Setting Address,  Up: Socket Addresses

16.3.1 Address Formats
----------------------

The functions `bind' and `getsockname' use the generic data type
`struct sockaddr *' to represent a pointer to a socket address.  You
can't use this data type effectively to interpret an address or
construct one; for that, you must use the proper data type for the
socket's namespace.

   Thus, the usual practice is to construct an address of the proper
namespace-specific type, then cast a pointer to `struct sockaddr *'
when you call `bind' or `getsockname'.

   The one piece of information that you can get from the `struct
sockaddr' data type is the "address format designator".  This tells you
which data type to use to understand the address fully.

   The symbols in this section are defined in the header file
`sys/socket.h'.

 -- Data Type: struct sockaddr
     The `struct sockaddr' type itself has the following members:

    `short int sa_family'
          This is the code for the address format of this address.  It
          identifies the format of the data which follows.

    `char sa_data[14]'
          This is the actual socket address data, which is
          format-dependent.  Its length also depends on the format, and
          may well be more than 14.  The length 14 of `sa_data' is
          essentially arbitrary.

   Each address format has a symbolic name which starts with `AF_'.
Each of them corresponds to a `PF_' symbol which designates the
corresponding namespace.  Here is a list of address format names:

`AF_LOCAL'
     This designates the address format that goes with the local
     namespace.  (`PF_LOCAL' is the name of that namespace.)  *Note
     Local Namespace Details::, for information about this address
     format.

`AF_UNIX'
     This is a synonym for `AF_LOCAL'.  Although `AF_LOCAL' is mandated
     by POSIX.1g, `AF_UNIX' is portable to more systems.  `AF_UNIX' was
     the traditional name stemming from BSD, so even most POSIX systems
     support it.  It is also the name of choice in the Unix98
     specification. (The same is true for `PF_UNIX' vs. `PF_LOCAL').

`AF_FILE'
     This is another synonym for `AF_LOCAL', for compatibility.
     (`PF_FILE' is likewise a synonym for `PF_LOCAL'.)

`AF_INET'
     This designates the address format that goes with the Internet
     namespace.  (`PF_INET' is the name of that namespace.)  *Note
     Internet Address Formats::.

`AF_INET6'
     This is similar to `AF_INET', but refers to the IPv6 protocol.
     (`PF_INET6' is the name of the corresponding namespace.)

`AF_UNSPEC'
     This designates no particular address format.  It is used only in
     rare cases, such as to clear out the default destination address
     of a "connected" datagram socket.  *Note Sending Datagrams::.

     The corresponding namespace designator symbol `PF_UNSPEC' exists
     for completeness, but there is no reason to use it in a program.

   `sys/socket.h' defines symbols starting with `AF_' for many
different kinds of networks, most or all of which are not actually
implemented.  We will document those that really work as we receive
information about how to use them.


File: libc.info,  Node: Setting Address,  Next: Reading Address,  Prev: Address Formats,  Up: Socket Addresses

16.3.2 Setting the Address of a Socket
--------------------------------------

Use the `bind' function to assign an address to a socket.  The
prototype for `bind' is in the header file `sys/socket.h'.  For
examples of use, see *Note Local Socket Example::, or see *Note Inet
Example::.

 -- Function: int bind (int SOCKET, struct sockaddr *ADDR, socklen_t
          LENGTH)
     The `bind' function assigns an address to the socket SOCKET.  The
     ADDR and LENGTH arguments specify the address; the detailed format
     of the address depends on the namespace.  The first part of the
     address is always the format designator, which specifies a
     namespace, and says that the address is in the format of that
     namespace.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `EADDRNOTAVAIL'
          The specified address is not available on this machine.

    `EADDRINUSE'
          Some other socket is already using the specified address.

    `EINVAL'
          The socket SOCKET already has an address.

    `EACCES'
          You do not have permission to access the requested address.
          (In the Internet domain, only the super-user is allowed to
          specify a port number in the range 0 through
          `IPPORT_RESERVED' minus one; see *Note Ports::.)

     Additional conditions may be possible depending on the particular
     namespace of the socket.


File: libc.info,  Node: Reading Address,  Prev: Setting Address,  Up: Socket Addresses

16.3.3 Reading the Address of a Socket
--------------------------------------

Use the function `getsockname' to examine the address of an Internet
socket.  The prototype for this function is in the header file
`sys/socket.h'.

 -- Function: int getsockname (int SOCKET, struct sockaddr *ADDR,
          socklen_t *LENGTH-PTR)
     The `getsockname' function returns information about the address
     of the socket SOCKET in the locations specified by the ADDR and
     LENGTH-PTR arguments.  Note that the LENGTH-PTR is a pointer; you
     should initialize it to be the allocation size of ADDR, and on
     return it contains the actual size of the address data.

     The format of the address data depends on the socket namespace.
     The length of the information is usually fixed for a given
     namespace, so normally you can know exactly how much space is
     needed and can provide that much.  The usual practice is to
     allocate a place for the value using the proper data type for the
     socket's namespace, then cast its address to `struct sockaddr *'
     to pass it to `getsockname'.

     The return value is `0' on success and `-1' on error.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `ENOBUFS'
          There are not enough internal buffers available for the
          operation.

   You can't read the address of a socket in the file namespace.  This
is consistent with the rest of the system; in general, there's no way to
find a file's name from a descriptor for that file.


File: libc.info,  Node: Interface Naming,  Next: Local Namespace,  Prev: Socket Addresses,  Up: Sockets

16.4 Interface Naming
=====================

Each network interface has a name.  This usually consists of a few
letters that relate to the type of interface, which may be followed by a
number if there is more than one interface of that type.  Examples
might be `lo' (the loopback interface) and `eth0' (the first Ethernet
interface).

   Although such names are convenient for humans, it would be clumsy to
have to use them whenever a program needs to refer to an interface.  In
such situations an interface is referred to by its "index", which is an
arbitrarily-assigned small positive integer.

   The following functions, constants and data types are declared in the
header file `net/if.h'.

 -- Constant: size_t IFNAMSIZ
     This constant defines the maximum buffer size needed to hold an
     interface name, including its terminating zero byte.

 -- Function: unsigned int if_nametoindex (const char *ifname)
     This function yields the interface index corresponding to a
     particular name.  If no interface exists with the name given, it
     returns 0.

 -- Function: char * if_indextoname (unsigned int ifindex, char *ifname)
     This function maps an interface index to its corresponding name.
     The returned name is placed in the buffer pointed to by `ifname',
     which must be at least `IFNAMSIZ' bytes in length.  If the index
     was invalid, the function's return value is a null pointer,
     otherwise it is `ifname'.

 -- Data Type: struct if_nameindex
     This data type is used to hold the information about a single
     interface.  It has the following members:

    `unsigned int if_index;'
          This is the interface index.

    `char *if_name'
          This is the null-terminated index name.


 -- Function: struct if_nameindex * if_nameindex (void)
     This function returns an array of `if_nameindex' structures, one
     for every interface that is present.  The end of the list is
     indicated by a structure with an interface of 0 and a null name
     pointer.  If an error occurs, this function returns a null pointer.

     The returned structure must be freed with `if_freenameindex' after
     use.

 -- Function: void if_freenameindex (struct if_nameindex *ptr)
     This function frees the structure returned by an earlier call to
     `if_nameindex'.


File: libc.info,  Node: Local Namespace,  Next: Internet Namespace,  Prev: Interface Naming,  Up: Sockets

16.5 The Local Namespace
========================

This section describes the details of the local namespace, whose
symbolic name (required when you create a socket) is `PF_LOCAL'.  The
local namespace is also known as "Unix domain sockets".  Another name
is file namespace since socket addresses are normally implemented as
file names.

* Menu:

* Concepts: Local Namespace Concepts. What you need to understand.
* Details: Local Namespace Details.   Address format, symbolic names, etc.
* Example: Local Socket Example.      Example of creating a socket.


File: libc.info,  Node: Local Namespace Concepts,  Next: Local Namespace Details,  Up: Local Namespace

16.5.1 Local Namespace Concepts
-------------------------------

In the local namespace socket addresses are file names.  You can specify
any file name you want as the address of the socket, but you must have
write permission on the directory containing it.  It's common to put
these files in the `/tmp' directory.

   One peculiarity of the local namespace is that the name is only used
when opening the connection; once open the address is not meaningful and
may not exist.

   Another peculiarity is that you cannot connect to such a socket from
another machine-not even if the other machine shares the file system
which contains the name of the socket.  You can see the socket in a
directory listing, but connecting to it never succeeds.  Some programs
take advantage of this, such as by asking the client to send its own
process ID, and using the process IDs to distinguish between clients.
However, we recommend you not use this method in protocols you design,
as we might someday permit connections from other machines that mount
the same file systems.  Instead, send each new client an identifying
number if you want it to have one.

   After you close a socket in the local namespace, you should delete
the file name from the file system.  Use `unlink' or `remove' to do
this; see *Note Deleting Files::.

   The local namespace supports just one protocol for any communication
style; it is protocol number `0'.


File: libc.info,  Node: Local Namespace Details,  Next: Local Socket Example,  Prev: Local Namespace Concepts,  Up: Local Namespace

16.5.2 Details of Local Namespace
---------------------------------

To create a socket in the local namespace, use the constant `PF_LOCAL'
as the NAMESPACE argument to `socket' or `socketpair'.  This constant
is defined in `sys/socket.h'.

 -- Macro: int PF_LOCAL
     This designates the local namespace, in which socket addresses are
     local names, and its associated family of protocols.  `PF_Local'
     is the macro used by Posix.1g.

 -- Macro: int PF_UNIX
     This is a synonym for `PF_LOCAL', for compatibility's sake.

 -- Macro: int PF_FILE
     This is a synonym for `PF_LOCAL', for compatibility's sake.

   The structure for specifying socket names in the local namespace is
defined in the header file `sys/un.h': 

 -- Data Type: struct sockaddr_un
     This structure is used to specify local namespace socket
     addresses.  It has the following members:

    `short int sun_family'
          This identifies the address family or format of the socket
          address.  You should store the value `AF_LOCAL' to designate
          the local namespace.  *Note Socket Addresses::.

    `char sun_path[108]'
          This is the file name to use.

          *Incomplete:*  Why is 108 a magic number?  RMS suggests making
          this a zero-length array and tweaking the following example
          to use `alloca' to allocate an appropriate amount of storage
          based on the length of the filename.

   You should compute the LENGTH parameter for a socket address in the
local namespace as the sum of the size of the `sun_family' component
and the string length (_not_ the allocation size!) of the file name
string.  This can be done using the macro `SUN_LEN':

 -- Macro: int SUN_LEN (_struct sockaddr_un *_ PTR)
     The macro computes the length of socket address in the local
     namespace.


File: libc.info,  Node: Local Socket Example,  Prev: Local Namespace Details,  Up: Local Namespace

16.5.3 Example of Local-Namespace Sockets
-----------------------------------------

Here is an example showing how to create and name a socket in the local
namespace.

     #include <stddef.h>
     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <string.h>
     #include <sys/socket.h>
     #include <sys/un.h>

     int
     make_named_socket (const char *filename)
     {
       struct sockaddr_un name;
       int sock;
       size_t size;

       /* Create the socket. */
       sock = socket (PF_LOCAL, SOCK_DGRAM, 0);
       if (sock < 0)
         {
           perror ("socket");
           exit (EXIT_FAILURE);
         }

       /* Bind a name to the socket. */
       name.sun_family = AF_LOCAL;
       strncpy (name.sun_path, filename, sizeof (name.sun_path));
       name.sun_path[sizeof (name.sun_path) - 1] = '\0';

       /* The size of the address is
          the offset of the start of the filename,
          plus its length,
          plus one for the terminating null byte.
          Alternatively you can just do:
          size = SUN_LEN (&name);
      */
       size = (offsetof (struct sockaddr_un, sun_path)
               + strlen (name.sun_path) + 1);

       if (bind (sock, (struct sockaddr *) &name, size) < 0)
         {
           perror ("bind");
           exit (EXIT_FAILURE);
         }

       return sock;
     }


File: libc.info,  Node: Internet Namespace,  Next: Misc Namespaces,  Prev: Local Namespace,  Up: Sockets

16.6 The Internet Namespace
===========================

This section describes the details of the protocols and socket naming
conventions used in the Internet namespace.

   Originally the Internet namespace used only IP version 4 (IPv4).
With the growing number of hosts on the Internet, a new protocol with a
larger address space was necessary: IP version 6 (IPv6).  IPv6
introduces 128-bit addresses (IPv4 has 32-bit addresses) and other
features, and will eventually replace IPv4.

   To create a socket in the IPv4 Internet namespace, use the symbolic
name `PF_INET' of this namespace as the NAMESPACE argument to `socket'
or `socketpair'.  For IPv6 addresses you need the macro `PF_INET6'.
These macros are defined in `sys/socket.h'.  

 -- Macro: int PF_INET
     This designates the IPv4 Internet namespace and associated family
     of protocols.

 -- Macro: int PF_INET6
     This designates the IPv6 Internet namespace and associated family
     of protocols.

   A socket address for the Internet namespace includes the following
components:

   * The address of the machine you want to connect to.  Internet
     addresses can be specified in several ways; these are discussed in
     *Note Internet Address Formats::, *Note Host Addresses:: and *Note
     Host Names::.

   * A port number for that machine.  *Note Ports::.

   You must ensure that the address and port number are represented in a
canonical format called "network byte order".  *Note Byte Order::, for
information about this.

* Menu:

* Internet Address Formats::    How socket addresses are specified in the
                                 Internet namespace.
* Host Addresses::	        All about host addresses of Internet host.
* Protocols Database::		Referring to protocols by name.
* Ports::			Internet port numbers.
* Services Database::           Ports may have symbolic names.
* Byte Order::		        Different hosts may use different byte
                                 ordering conventions; you need to
                                 canonicalize host address and port number.
* Inet Example::	        Putting it all together.


File: libc.info,  Node: Internet Address Formats,  Next: Host Addresses,  Up: Internet Namespace

16.6.1 Internet Socket Address Formats
--------------------------------------

In the Internet namespace, for both IPv4 (`AF_INET') and IPv6
(`AF_INET6'), a socket address consists of a host address and a port on
that host.  In addition, the protocol you choose serves effectively as
a part of the address because local port numbers are meaningful only
within a particular protocol.

   The data types for representing socket addresses in the Internet
namespace are defined in the header file `netinet/in.h'.  

 -- Data Type: struct sockaddr_in
     This is the data type used to represent socket addresses in the
     Internet namespace.  It has the following members:

    `sa_family_t sin_family'
          This identifies the address family or format of the socket
          address.  You should store the value `AF_INET' in this member.
          *Note Socket Addresses::.

    `struct in_addr sin_addr'
          This is the Internet address of the host machine.  *Note Host
          Addresses::, and *Note Host Names::, for how to get a value
          to store here.

    `unsigned short int sin_port'
          This is the port number.  *Note Ports::.

   When you call `bind' or `getsockname', you should specify `sizeof
(struct sockaddr_in)' as the LENGTH parameter if you are using an IPv4
Internet namespace socket address.

 -- Data Type: struct sockaddr_in6
     This is the data type used to represent socket addresses in the
     IPv6 namespace.  It has the following members:

    `sa_family_t sin6_family'
          This identifies the address family or format of the socket
          address.  You should store the value of `AF_INET6' in this
          member.  *Note Socket Addresses::.

    `struct in6_addr sin6_addr'
          This is the IPv6 address of the host machine.  *Note Host
          Addresses::, and *Note Host Names::, for how to get a value
          to store here.

    `uint32_t sin6_flowinfo'
          This is a currently unimplemented field.

    `uint16_t sin6_port'
          This is the port number.  *Note Ports::.



File: libc.info,  Node: Host Addresses,  Next: Protocols Database,  Prev: Internet Address Formats,  Up: Internet Namespace

16.6.2 Host Addresses
---------------------

Each computer on the Internet has one or more "Internet addresses",
numbers which identify that computer among all those on the Internet.
Users typically write IPv4 numeric host addresses as sequences of four
numbers, separated by periods, as in `128.52.46.32', and IPv6 numeric
host addresses as sequences of up to eight numbers separated by colons,
as in `5f03:1200:836f:c100::1'.

   Each computer also has one or more "host names", which are strings
of words separated by periods, as in `mescaline.gnu.org'.

   Programs that let the user specify a host typically accept both
numeric addresses and host names.  To open a connection a program needs
a numeric address, and so must convert a host name to the numeric
address it stands for.

* Menu:

* Abstract Host Addresses::	What a host number consists of.
* Data type: Host Address Data Type.	Data type for a host number.
* Functions: Host Address Functions.	Functions to operate on them.
* Names: Host Names.		Translating host names to host numbers.


File: libc.info,  Node: Abstract Host Addresses,  Next: Host Address Data Type,  Up: Host Addresses

16.6.2.1 Internet Host Addresses
................................

Each computer on the Internet has one or more Internet addresses,
numbers which identify that computer among all those on the Internet.

An IPv4 Internet host address is a number containing four bytes of data.
Historically these are divided into two parts, a "network number" and a
"local network address number" within that network.  In the mid-1990s
classless addresses were introduced which changed this behavior.  Since
some functions implicitly expect the old definitions, we first describe
the class-based network and will then describe classless addresses.
IPv6 uses only classless addresses and therefore the following
paragraphs don't apply.

   The class-based IPv4 network number consists of the first one, two or
three bytes; the rest of the bytes are the local address.

   IPv4 network numbers are registered with the Network Information
Center (NIC), and are divided into three classes--A, B and C.  The local
network address numbers of individual machines are registered with the
administrator of the particular network.

   Class A networks have single-byte numbers in the range 0 to 127.
There are only a small number of Class A networks, but they can each
support a very large number of hosts.  Medium-sized Class B networks
have two-byte network numbers, with the first byte in the range 128 to
191.  Class C networks are the smallest; they have three-byte network
numbers, with the first byte in the range 192-255.  Thus, the first 1,
2, or 3 bytes of an Internet address specify a network.  The remaining
bytes of the Internet address specify the address within that network.

   The Class A network 0 is reserved for broadcast to all networks.  In
addition, the host number 0 within each network is reserved for
broadcast to all hosts in that network.  These uses are obsolete now
but for compatibility reasons you shouldn't use network 0 and host
number 0.

   The Class A network 127 is reserved for loopback; you can always use
the Internet address `127.0.0.1' to refer to the host machine.

   Since a single machine can be a member of multiple networks, it can
have multiple Internet host addresses.  However, there is never
supposed to be more than one machine with the same host address.

   There are four forms of the "standard numbers-and-dots notation" for
Internet addresses:

`A.B.C.D'
     This specifies all four bytes of the address individually and is
     the commonly used representation.

`A.B.C'
     The last part of the address, C, is interpreted as a 2-byte
     quantity.  This is useful for specifying host addresses in a Class
     B network with network address number `A.B'.

`A.B'
     The last part of the address, B, is interpreted as a 3-byte
     quantity.  This is useful for specifying host addresses in a Class
     A network with network address number A.

`A'
     If only one part is given, this corresponds directly to the host
     address number.

   Within each part of the address, the usual C conventions for
specifying the radix apply.  In other words, a leading `0x' or `0X'
implies hexadecimal radix; a leading `0' implies octal; and otherwise
decimal radix is assumed.

Classless Addresses
...................

IPv4 addresses (and IPv6 addresses also) are now considered classless;
the distinction between classes A, B and C can be ignored.  Instead an
IPv4 host address consists of a 32-bit address and a 32-bit mask.  The
mask contains set bits for the network part and cleared bits for the
host part.  The network part is contiguous from the left, with the
remaining bits representing the host.  As a consequence, the netmask can
simply be specified as the number of set bits.  Classes A, B and C are
just special cases of this general rule.  For example, class A addresses
have a netmask of `255.0.0.0' or a prefix length of 8.

   Classless IPv4 network addresses are written in numbers-and-dots
notation with the prefix length appended and a slash as separator.  For
example the class A network 10 is written as `10.0.0.0/8'.

IPv6 Addresses
..............

IPv6 addresses contain 128 bits (IPv4 has 32 bits) of data.  A host
address is usually written as eight 16-bit hexadecimal numbers that are
separated by colons.  Two colons are used to abbreviate strings of
consecutive zeros.  For example, the IPv6 loopback address
`0:0:0:0:0:0:0:1' can just be written as `::1'.


File: libc.info,  Node: Host Address Data Type,  Next: Host Address Functions,  Prev: Abstract Host Addresses,  Up: Host Addresses

16.6.2.2 Host Address Data Type
...............................

IPv4 Internet host addresses are represented in some contexts as
integers (type `uint32_t').  In other contexts, the integer is packaged
inside a structure of type `struct in_addr'.  It would be better if the
usage were made consistent, but it is not hard to extract the integer
from the structure or put the integer into a structure.

   You will find older code that uses `unsigned long int' for IPv4
Internet host addresses instead of `uint32_t' or `struct in_addr'.
Historically `unsigned long int' was a 32-bit number but with 64-bit
machines this has changed.  Using `unsigned long int' might break the
code if it is used on machines where this type doesn't have 32 bits.
`uint32_t' is specified by Unix98 and guaranteed to have 32 bits.

   IPv6 Internet host addresses have 128 bits and are packaged inside a
structure of type `struct in6_addr'.

   The following basic definitions for Internet addresses are declared
in the header file `netinet/in.h': 

 -- Data Type: struct in_addr
     This data type is used in certain contexts to contain an IPv4
     Internet host address.  It has just one field, named `s_addr',
     which records the host address number as an `uint32_t'.

 -- Macro: uint32_t INADDR_LOOPBACK
     You can use this constant to stand for "the address of this
     machine," instead of finding its actual address.  It is the IPv4
     Internet address `127.0.0.1', which is usually called `localhost'.
     This special constant saves you the trouble of looking up the
     address of your own machine.  Also, the system usually implements
     `INADDR_LOOPBACK' specially, avoiding any network traffic for the
     case of one machine talking to itself.

 -- Macro: uint32_t INADDR_ANY
     You can use this constant to stand for "any incoming address" when
     binding to an address.  *Note Setting Address::.  This is the usual
     address to give in the `sin_addr' member of `struct sockaddr_in'
     when you want to accept Internet connections.

 -- Macro: uint32_t INADDR_BROADCAST
     This constant is the address you use to send a broadcast message.

 -- Macro: uint32_t INADDR_NONE
     This constant is returned by some functions to indicate an error.

 -- Data Type: struct in6_addr
     This data type is used to store an IPv6 address.  It stores 128
     bits of data, which can be accessed (via a union) in a variety of
     ways.

 -- Constant: struct in6_addr in6addr_loopback
     This constant is the IPv6 address `::1', the loopback address.  See
     above for a description of what this means.  The macro
     `IN6ADDR_LOOPBACK_INIT' is provided to allow you to initialize your
     own variables to this value.

 -- Constant: struct in6_addr in6addr_any
     This constant is the IPv6 address `::', the unspecified address.
     See above for a description of what this means.  The macro
     `IN6ADDR_ANY_INIT' is provided to allow you to initialize your own
     variables to this value.


File: libc.info,  Node: Host Address Functions,  Next: Host Names,  Prev: Host Address Data Type,  Up: Host Addresses

16.6.2.3 Host Address Functions
...............................

These additional functions for manipulating Internet addresses are
declared in the header file `arpa/inet.h'.  They represent Internet
addresses in network byte order, and network numbers and
local-address-within-network numbers in host byte order.  *Note Byte
Order::, for an explanation of network and host byte order.

 -- Function: int inet_aton (const char *NAME, struct in_addr *ADDR)
     This function converts the IPv4 Internet host address NAME from
     the standard numbers-and-dots notation into binary data and stores
     it in the `struct in_addr' that ADDR points to.  `inet_aton'
     returns nonzero if the address is valid, zero if not.

 -- Function: uint32_t inet_addr (const char *NAME)
     This function converts the IPv4 Internet host address NAME from the
     standard numbers-and-dots notation into binary data.  If the input
     is not valid, `inet_addr' returns `INADDR_NONE'.  This is an
     obsolete interface to `inet_aton', described immediately above. It
     is obsolete because `INADDR_NONE' is a valid address
     (255.255.255.255), and `inet_aton' provides a cleaner way to
     indicate error return.

 -- Function: uint32_t inet_network (const char *NAME)
     This function extracts the network number from the address NAME,
     given in the standard numbers-and-dots notation. The returned
     address is in host order. If the input is not valid,
     `inet_network' returns `-1'.

     The function works only with traditional IPv4 class A, B and C
     network types.  It doesn't work with classless addresses and
     shouldn't be used anymore.

 -- Function: char * inet_ntoa (struct in_addr ADDR)
     This function converts the IPv4 Internet host address ADDR to a
     string in the standard numbers-and-dots notation.  The return
     value is a pointer into a statically-allocated buffer.  Subsequent
     calls will overwrite the same buffer, so you should copy the
     string if you need to save it.

     In multi-threaded programs each thread has an own
     statically-allocated buffer.  But still subsequent calls of
     `inet_ntoa' in the same thread will overwrite the result of the
     last call.

     Instead of `inet_ntoa' the newer function `inet_ntop' which is
     described below should be used since it handles both IPv4 and IPv6
     addresses.

 -- Function: struct in_addr inet_makeaddr (uint32_t NET, uint32_t
          LOCAL)
     This function makes an IPv4 Internet host address by combining the
     network number NET with the local-address-within-network number
     LOCAL.

 -- Function: uint32_t inet_lnaof (struct in_addr ADDR)
     This function returns the local-address-within-network part of the
     Internet host address ADDR.

     The function works only with traditional IPv4 class A, B and C
     network types.  It doesn't work with classless addresses and
     shouldn't be used anymore.

 -- Function: uint32_t inet_netof (struct in_addr ADDR)
     This function returns the network number part of the Internet host
     address ADDR.

     The function works only with traditional IPv4 class A, B and C
     network types.  It doesn't work with classless addresses and
     shouldn't be used anymore.

 -- Function: int inet_pton (int AF, const char *CP, void *BUF)
     This function converts an Internet address (either IPv4 or IPv6)
     from presentation (textual) to network (binary) format.  AF should
     be either `AF_INET' or `AF_INET6', as appropriate for the type of
     address being converted.  CP is a pointer to the input string, and
     BUF is a pointer to a buffer for the result.  It is the caller's
     responsibility to make sure the buffer is large enough.

 -- Function: const char * inet_ntop (int AF, const void *CP, char
          *BUF, size_t LEN)
     This function converts an Internet address (either IPv4 or IPv6)
     from network (binary) to presentation (textual) form.  AF should be
     either `AF_INET' or `AF_INET6', as appropriate.  CP is a pointer
     to the address to be converted.  BUF should be a pointer to a
     buffer to hold the result, and LEN is the length of this buffer.
     The return value from the function will be this buffer address.


File: libc.info,  Node: Host Names,  Prev: Host Address Functions,  Up: Host Addresses

16.6.2.4 Host Names
...................

Besides the standard numbers-and-dots notation for Internet addresses,
you can also refer to a host by a symbolic name.  The advantage of a
symbolic name is that it is usually easier to remember.  For example,
the machine with Internet address `158.121.106.19' is also known as
`alpha.gnu.org'; and other machines in the `gnu.org' domain can refer
to it simply as `alpha'.

   Internally, the system uses a database to keep track of the mapping
between host names and host numbers.  This database is usually either
the file `/etc/hosts' or an equivalent provided by a name server.  The
functions and other symbols for accessing this database are declared in
`netdb.h'.  They are BSD features, defined unconditionally if you
include `netdb.h'.

 -- Data Type: struct hostent
     This data type is used to represent an entry in the hosts
     database.  It has the following members:

    `char *h_name'
          This is the "official" name of the host.

    `char **h_aliases'
          These are alternative names for the host, represented as a
          null-terminated vector of strings.

    `int h_addrtype'
          This is the host address type; in practice, its value is
          always either `AF_INET' or `AF_INET6', with the latter being
          used for IPv6 hosts.  In principle other kinds of addresses
          could be represented in the database as well as Internet
          addresses; if this were done, you might find a value in this
          field other than `AF_INET' or `AF_INET6'.  *Note Socket
          Addresses::.

    `int h_length'
          This is the length, in bytes, of each address.

    `char **h_addr_list'
          This is the vector of addresses for the host.  (Recall that
          the host might be connected to multiple networks and have
          different addresses on each one.)  The vector is terminated
          by a null pointer.

    `char *h_addr'
          This is a synonym for `h_addr_list[0]'; in other words, it is
          the first host address.

   As far as the host database is concerned, each address is just a
block of memory `h_length' bytes long.  But in other contexts there is
an implicit assumption that you can convert IPv4 addresses to a `struct
in_addr' or an `uint32_t'.  Host addresses in a `struct hostent'
structure are always given in network byte order; see *Note Byte
Order::.

   You can use `gethostbyname', `gethostbyname2' or `gethostbyaddr' to
search the hosts database for information about a particular host.  The
information is returned in a statically-allocated structure; you must
copy the information if you need to save it across calls.  You can also
use `getaddrinfo' and `getnameinfo' to obtain this information.

 -- Function: struct hostent * gethostbyname (const char *NAME)
     The `gethostbyname' function returns information about the host
     named NAME.  If the lookup fails, it returns a null pointer.

 -- Function: struct hostent * gethostbyname2 (const char *NAME, int AF)
     The `gethostbyname2' function is like `gethostbyname', but allows
     the caller to specify the desired address family (e.g.  `AF_INET'
     or `AF_INET6') of the result.

 -- Function: struct hostent * gethostbyaddr (const char *ADDR, size_t
          LENGTH, int FORMAT)
     The `gethostbyaddr' function returns information about the host
     with Internet address ADDR.  The parameter ADDR is not really a
     pointer to char - it can be a pointer to an IPv4 or an IPv6
     address. The LENGTH argument is the size (in bytes) of the address
     at ADDR.  FORMAT specifies the address format; for an IPv4
     Internet address, specify a value of `AF_INET'; for an IPv6
     Internet address, use `AF_INET6'.

     If the lookup fails, `gethostbyaddr' returns a null pointer.

   If the name lookup by `gethostbyname' or `gethostbyaddr' fails, you
can find out the reason by looking at the value of the variable
`h_errno'.  (It would be cleaner design for these functions to set
`errno', but use of `h_errno' is compatible with other systems.)

   Here are the error codes that you may find in `h_errno':

`HOST_NOT_FOUND'
     No such host is known in the database.

`TRY_AGAIN'
     This condition happens when the name server could not be
     contacted.  If you try again later, you may succeed then.

`NO_RECOVERY'
     A non-recoverable error occurred.

`NO_ADDRESS'
     The host database contains an entry for the name, but it doesn't
     have an associated Internet address.

   The lookup functions above all have one in common: they are not
reentrant and therefore unusable in multi-threaded applications.
Therefore provides the GNU C library a new set of functions which can be
used in this context.

 -- Function: int gethostbyname_r (const char *restrict NAME, struct
          hostent *restrict RESULT_BUF, char *restrict BUF, size_t
          BUFLEN, struct hostent **restrict RESULT, int *restrict
          H_ERRNOP)
     The `gethostbyname_r' function returns information about the host
     named NAME.  The caller must pass a pointer to an object of type
     `struct hostent' in the RESULT_BUF parameter.  In addition the
     function may need extra buffer space and the caller must pass an
     pointer and the size of the buffer in the BUF and BUFLEN
     parameters.

     A pointer to the buffer, in which the result is stored, is
     available in `*RESULT' after the function call successfully
     returned.  If an error occurs or if no entry is found, the pointer
     `*RESULT' is a null pointer.  Success is signalled by a zero
     return value.  If the function failed the return value is an error
     number.  In addition to the errors defined for `gethostbyname' it
     can also be `ERANGE'.  In this case the call should be repeated
     with a larger buffer.  Additional error information is not stored
     in the global variable `h_errno' but instead in the object pointed
     to by H_ERRNOP.

     Here's a small example:
          struct hostent *
          gethostname (char *host)
          {
            struct hostent hostbuf, *hp;
            size_t hstbuflen;
            char *tmphstbuf;
            int res;
            int herr;

            hstbuflen = 1024;
            /* Allocate buffer, remember to free it to avoid memory leakage.  */
            tmphstbuf = malloc (hstbuflen);

            while ((res = gethostbyname_r (host, &hostbuf, tmphstbuf, hstbuflen,
                                           &hp, &herr)) == ERANGE)
              {
                /* Enlarge the buffer.  */
                hstbuflen *= 2;
                tmphstbuf = realloc (tmphstbuf, hstbuflen);
              }
            /*  Check for errors.  */
            if (res || hp == NULL)
              return NULL;
            return hp;
          }

 -- Function: int gethostbyname2_r (const char *NAME, int AF, struct
          hostent *restrict RESULT_BUF, char *restrict BUF, size_t
          BUFLEN, struct hostent **restrict RESULT, int *restrict
          H_ERRNOP)
     The `gethostbyname2_r' function is like `gethostbyname_r', but
     allows the caller to specify the desired address family (e.g.
     `AF_INET' or `AF_INET6') for the result.

 -- Function: int gethostbyaddr_r (const char *ADDR, size_t LENGTH, int
          FORMAT, struct hostent *restrict RESULT_BUF, char *restrict
          BUF, size_t BUFLEN, struct hostent **restrict RESULT, int
          *restrict H_ERRNOP)
     The `gethostbyaddr_r' function returns information about the host
     with Internet address ADDR.  The parameter ADDR is not really a
     pointer to char - it can be a pointer to an IPv4 or an IPv6
     address. The LENGTH argument is the size (in bytes) of the address
     at ADDR.  FORMAT specifies the address format; for an IPv4
     Internet address, specify a value of `AF_INET'; for an IPv6
     Internet address, use `AF_INET6'.

     Similar to the `gethostbyname_r' function, the caller must provide
     buffers for the result and memory used internally.  In case of
     success the function returns zero.  Otherwise the value is an
     error number where `ERANGE' has the special meaning that the
     caller-provided buffer is too small.

   You can also scan the entire hosts database one entry at a time using
`sethostent', `gethostent' and `endhostent'.  Be careful when using
these functions because they are not reentrant.

 -- Function: void sethostent (int STAYOPEN)
     This function opens the hosts database to begin scanning it.  You
     can then call `gethostent' to read the entries.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `gethostbyname' or `gethostbyaddr' will not
     close the database (as they usually would).  This makes for more
     efficiency if you call those functions several times, by avoiding
     reopening the database for each call.

 -- Function: struct hostent * gethostent (void)
     This function returns the next entry in the hosts database.  It
     returns a null pointer if there are no more entries.

 -- Function: void endhostent (void)
     This function closes the hosts database.


File: libc.info,  Node: Ports,  Next: Services Database,  Prev: Protocols Database,  Up: Internet Namespace

16.6.3 Internet Ports
---------------------

A socket address in the Internet namespace consists of a machine's
Internet address plus a "port number" which distinguishes the sockets
on a given machine (for a given protocol).  Port numbers range from 0
to 65,535.

   Port numbers less than `IPPORT_RESERVED' are reserved for standard
servers, such as `finger' and `telnet'.  There is a database that keeps
track of these, and you can use the `getservbyname' function to map a
service name onto a port number; see *Note Services Database::.

   If you write a server that is not one of the standard ones defined in
the database, you must choose a port number for it.  Use a number
greater than `IPPORT_USERRESERVED'; such numbers are reserved for
servers and won't ever be generated automatically by the system.
Avoiding conflicts with servers being run by other users is up to you.

   When you use a socket without specifying its address, the system
generates a port number for it.  This number is between
`IPPORT_RESERVED' and `IPPORT_USERRESERVED'.

   On the Internet, it is actually legitimate to have two different
sockets with the same port number, as long as they never both try to
communicate with the same socket address (host address plus port
number).  You shouldn't duplicate a port number except in special
circumstances where a higher-level protocol requires it.  Normally, the
system won't let you do it; `bind' normally insists on distinct port
numbers.  To reuse a port number, you must set the socket option
`SO_REUSEADDR'.  *Note Socket-Level Options::.

   These macros are defined in the header file `netinet/in.h'.

 -- Macro: int IPPORT_RESERVED
     Port numbers less than `IPPORT_RESERVED' are reserved for
     superuser use.

 -- Macro: int IPPORT_USERRESERVED
     Port numbers greater than or equal to `IPPORT_USERRESERVED' are
     reserved for explicit use; they will never be allocated
     automatically.


File: libc.info,  Node: Services Database,  Next: Byte Order,  Prev: Ports,  Up: Internet Namespace

16.6.4 The Services Database
----------------------------

The database that keeps track of "well-known" services is usually
either the file `/etc/services' or an equivalent from a name server.
You can use these utilities, declared in `netdb.h', to access the
services database.  

 -- Data Type: struct servent
     This data type holds information about entries from the services
     database.  It has the following members:

    `char *s_name'
          This is the "official" name of the service.

    `char **s_aliases'
          These are alternate names for the service, represented as an
          array of strings.  A null pointer terminates the array.

    `int s_port'
          This is the port number for the service.  Port numbers are
          given in network byte order; see *Note Byte Order::.

    `char *s_proto'
          This is the name of the protocol to use with this service.
          *Note Protocols Database::.

   To get information about a particular service, use the
`getservbyname' or `getservbyport' functions.  The information is
returned in a statically-allocated structure; you must copy the
information if you need to save it across calls.

 -- Function: struct servent * getservbyname (const char *NAME, const
          char *PROTO)
     The `getservbyname' function returns information about the service
     named NAME using protocol PROTO.  If it can't find such a service,
     it returns a null pointer.

     This function is useful for servers as well as for clients; servers
     use it to determine which port they should listen on (*note
     Listening::).

 -- Function: struct servent * getservbyport (int PORT, const char
          *PROTO)
     The `getservbyport' function returns information about the service
     at port PORT using protocol PROTO.  If it can't find such a
     service, it returns a null pointer.

You can also scan the services database using `setservent',
`getservent' and `endservent'.  Be careful when using these functions
because they are not reentrant.

 -- Function: void setservent (int STAYOPEN)
     This function opens the services database to begin scanning it.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `getservbyname' or `getservbyport' will not
     close the database (as they usually would).  This makes for more
     efficiency if you call those functions several times, by avoiding
     reopening the database for each call.

 -- Function: struct servent * getservent (void)
     This function returns the next entry in the services database.  If
     there are no more entries, it returns a null pointer.

 -- Function: void endservent (void)
     This function closes the services database.


File: libc.info,  Node: Byte Order,  Next: Inet Example,  Prev: Services Database,  Up: Internet Namespace

16.6.5 Byte Order Conversion
----------------------------

Different kinds of computers use different conventions for the ordering
of bytes within a word.  Some computers put the most significant byte
within a word first (this is called "big-endian" order), and others put
it last ("little-endian" order).

   So that machines with different byte order conventions can
communicate, the Internet protocols specify a canonical byte order
convention for data transmitted over the network.  This is known as
"network byte order".

   When establishing an Internet socket connection, you must make sure
that the data in the `sin_port' and `sin_addr' members of the
`sockaddr_in' structure are represented in network byte order.  If you
are encoding integer data in the messages sent through the socket, you
should convert this to network byte order too.  If you don't do this,
your program may fail when running on or talking to other kinds of
machines.

   If you use `getservbyname' and `gethostbyname' or `inet_addr' to get
the port number and host address, the values are already in network
byte order, and you can copy them directly into the `sockaddr_in'
structure.

   Otherwise, you have to convert the values explicitly.  Use `htons'
and `ntohs' to convert values for the `sin_port' member.  Use `htonl'
and `ntohl' to convert IPv4 addresses for the `sin_addr' member.
(Remember, `struct in_addr' is equivalent to `uint32_t'.)  These
functions are declared in `netinet/in.h'.  

 -- Function: uint16_t htons (uint16_t HOSTSHORT)
     This function converts the `uint16_t' integer HOSTSHORT from host
     byte order to network byte order.

 -- Function: uint16_t ntohs (uint16_t NETSHORT)
     This function converts the `uint16_t' integer NETSHORT from
     network byte order to host byte order.

 -- Function: uint32_t htonl (uint32_t HOSTLONG)
     This function converts the `uint32_t' integer HOSTLONG from host
     byte order to network byte order.

     This is used for IPv4 Internet addresses.

 -- Function: uint32_t ntohl (uint32_t NETLONG)
     This function converts the `uint32_t' integer NETLONG from network
     byte order to host byte order.

     This is used for IPv4 Internet addresses.


File: libc.info,  Node: Protocols Database,  Next: Ports,  Prev: Host Addresses,  Up: Internet Namespace

16.6.6 Protocols Database
-------------------------

The communications protocol used with a socket controls low-level
details of how data are exchanged.  For example, the protocol implements
things like checksums to detect errors in transmissions, and routing
instructions for messages.  Normal user programs have little reason to
mess with these details directly.

   The default communications protocol for the Internet namespace
depends on the communication style.  For stream communication, the
default is TCP ("transmission control protocol").  For datagram
communication, the default is UDP ("user datagram protocol").  For
reliable datagram communication, the default is RDP ("reliable datagram
protocol").  You should nearly always use the default.

   Internet protocols are generally specified by a name instead of a
number.  The network protocols that a host knows about are stored in a
database.  This is usually either derived from the file
`/etc/protocols', or it may be an equivalent provided by a name server.
You look up the protocol number associated with a named protocol in
the database using the `getprotobyname' function.

   Here are detailed descriptions of the utilities for accessing the
protocols database.  These are declared in `netdb.h'.  

 -- Data Type: struct protoent
     This data type is used to represent entries in the network
     protocols database.  It has the following members:

    `char *p_name'
          This is the official name of the protocol.

    `char **p_aliases'
          These are alternate names for the protocol, specified as an
          array of strings.  The last element of the array is a null
          pointer.

    `int p_proto'
          This is the protocol number (in host byte order); use this
          member as the PROTOCOL argument to `socket'.

   You can use `getprotobyname' and `getprotobynumber' to search the
protocols database for a specific protocol.  The information is
returned in a statically-allocated structure; you must copy the
information if you need to save it across calls.

 -- Function: struct protoent * getprotobyname (const char *NAME)
     The `getprotobyname' function returns information about the
     network protocol named NAME.  If there is no such protocol, it
     returns a null pointer.

 -- Function: struct protoent * getprotobynumber (int PROTOCOL)
     The `getprotobynumber' function returns information about the
     network protocol with number PROTOCOL.  If there is no such
     protocol, it returns a null pointer.

   You can also scan the whole protocols database one protocol at a
time by using `setprotoent', `getprotoent' and `endprotoent'.  Be
careful when using these functions because they are not reentrant.

 -- Function: void setprotoent (int STAYOPEN)
     This function opens the protocols database to begin scanning it.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `getprotobyname' or `getprotobynumber' will
     not close the database (as they usually would).  This makes for
     more efficiency if you call those functions several times, by
     avoiding reopening the database for each call.

 -- Function: struct protoent * getprotoent (void)
     This function returns the next entry in the protocols database.  It
     returns a null pointer if there are no more entries.

 -- Function: void endprotoent (void)
     This function closes the protocols database.


File: libc.info,  Node: Inet Example,  Prev: Byte Order,  Up: Internet Namespace

16.6.7 Internet Socket Example
------------------------------

Here is an example showing how to create and name a socket in the
Internet namespace.  The newly created socket exists on the machine that
the program is running on.  Rather than finding and using the machine's
Internet address, this example specifies `INADDR_ANY' as the host
address; the system replaces that with the machine's actual address.

     #include <stdio.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <netinet/in.h>

     int
     make_socket (uint16_t port)
     {
       int sock;
       struct sockaddr_in name;

       /* Create the socket. */
       sock = socket (PF_INET, SOCK_STREAM, 0);
       if (sock < 0)
         {
           perror ("socket");
           exit (EXIT_FAILURE);
         }

       /* Give the socket a name. */
       name.sin_family = AF_INET;
       name.sin_port = htons (port);
       name.sin_addr.s_addr = htonl (INADDR_ANY);
       if (bind (sock, (struct sockaddr *) &name, sizeof (name)) < 0)
         {
           perror ("bind");
           exit (EXIT_FAILURE);
         }

       return sock;
     }

   Here is another example, showing how you can fill in a `sockaddr_in'
structure, given a host name string and a port number:

     #include <stdio.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <netinet/in.h>
     #include <netdb.h>

     void
     init_sockaddr (struct sockaddr_in *name,
                    const char *hostname,
                    uint16_t port)
     {
       struct hostent *hostinfo;

       name->sin_family = AF_INET;
       name->sin_port = htons (port);
       hostinfo = gethostbyname (hostname);
       if (hostinfo == NULL)
         {
           fprintf (stderr, "Unknown host %s.\n", hostname);
           exit (EXIT_FAILURE);
         }
       name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
     }


File: libc.info,  Node: Misc Namespaces,  Next: Open/Close Sockets,  Prev: Internet Namespace,  Up: Sockets

16.7 Other Namespaces
=====================

Certain other namespaces and associated protocol families are supported
but not documented yet because they are not often used.  `PF_NS' refers
to the Xerox Network Software protocols.  `PF_ISO' stands for Open
Systems Interconnect.  `PF_CCITT' refers to protocols from CCITT.
`socket.h' defines these symbols and others naming protocols not
actually implemented.

   `PF_IMPLINK' is used for communicating between hosts and Internet
Message Processors.  For information on this and `PF_ROUTE', an
occasionally-used local area routing protocol, see the GNU Hurd Manual
(to appear in the future).


File: libc.info,  Node: Open/Close Sockets,  Next: Connections,  Prev: Misc Namespaces,  Up: Sockets

16.8 Opening and Closing Sockets
================================

This section describes the actual library functions for opening and
closing sockets.  The same functions work for all namespaces and
connection styles.

* Menu:

* Creating a Socket::           How to open a socket.
* Closing a Socket::            How to close a socket.
* Socket Pairs::                These are created like pipes.


File: libc.info,  Node: Creating a Socket,  Next: Closing a Socket,  Up: Open/Close Sockets

16.8.1 Creating a Socket
------------------------

The primitive for creating a socket is the `socket' function, declared
in `sys/socket.h'.  

 -- Function: int socket (int NAMESPACE, int STYLE, int PROTOCOL)
     This function creates a socket and specifies communication style
     STYLE, which should be one of the socket styles listed in *Note
     Communication Styles::.  The NAMESPACE argument specifies the
     namespace; it must be `PF_LOCAL' (*note Local Namespace::) or
     `PF_INET' (*note Internet Namespace::).  PROTOCOL designates the
     specific protocol (*note Socket Concepts::); zero is usually right
     for PROTOCOL.

     The return value from `socket' is the file descriptor for the new
     socket, or `-1' in case of error.  The following `errno' error
     conditions are defined for this function:

    `EPROTONOSUPPORT'
          The PROTOCOL or STYLE is not supported by the NAMESPACE
          specified.

    `EMFILE'
          The process already has too many file descriptors open.

    `ENFILE'
          The system already has too many file descriptors open.

    `EACCES'
          The process does not have the privilege to create a socket of
          the specified STYLE or PROTOCOL.

    `ENOBUFS'
          The system ran out of internal buffer space.

     The file descriptor returned by the `socket' function supports both
     read and write operations.  However, like pipes, sockets do not
     support file positioning operations.

   For examples of how to call the `socket' function, see *Note Local
Socket Example::, or *Note Inet Example::.


File: libc.info,  Node: Closing a Socket,  Next: Socket Pairs,  Prev: Creating a Socket,  Up: Open/Close Sockets

16.8.2 Closing a Socket
-----------------------

When you have finished using a socket, you can simply close its file
descriptor with `close'; see *Note Opening and Closing Files::.  If
there is still data waiting to be transmitted over the connection,
normally `close' tries to complete this transmission.  You can control
this behavior using the `SO_LINGER' socket option to specify a timeout
period; see *Note Socket Options::.

   You can also shut down only reception or transmission on a
connection by calling `shutdown', which is declared in `sys/socket.h'.

 -- Function: int shutdown (int SOCKET, int HOW)
     The `shutdown' function shuts down the connection of socket
     SOCKET.  The argument HOW specifies what action to perform:

    `0'
          Stop receiving data for this socket.  If further data arrives,
          reject it.

    `1'
          Stop trying to transmit data from this socket.  Discard any
          data waiting to be sent.  Stop looking for acknowledgement of
          data already sent; don't retransmit it if it is lost.

    `2'
          Stop both reception and transmission.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          SOCKET is not a socket.

    `ENOTCONN'
          SOCKET is not connected.


File: libc.info,  Node: Socket Pairs,  Prev: Closing a Socket,  Up: Open/Close Sockets

16.8.3 Socket Pairs
-------------------

A "socket pair" consists of a pair of connected (but unnamed) sockets.
It is very similar to a pipe and is used in much the same way.  Socket
pairs are created with the `socketpair' function, declared in
`sys/socket.h'.  A socket pair is much like a pipe; the main difference
is that the socket pair is bidirectional, whereas the pipe has one
input-only end and one output-only end (*note Pipes and FIFOs::).

 -- Function: int socketpair (int NAMESPACE, int STYLE, int PROTOCOL,
          int FILEDES[2])
     This function creates a socket pair, returning the file
     descriptors in `FILEDES[0]' and `FILEDES[1]'.  The socket pair is
     a full-duplex communications channel, so that both reading and
     writing may be performed at either end.

     The NAMESPACE, STYLE and PROTOCOL arguments are interpreted as for
     the `socket' function.  STYLE should be one of the communication
     styles listed in *Note Communication Styles::.  The NAMESPACE
     argument specifies the namespace, which must be `AF_LOCAL' (*note
     Local Namespace::); PROTOCOL specifies the communications
     protocol, but zero is the only meaningful value.

     If STYLE specifies a connectionless communication style, then the
     two sockets you get are not _connected_, strictly speaking, but
     each of them knows the other as the default destination address,
     so they can send packets to each other.

     The `socketpair' function returns `0' on success and `-1' on
     failure.  The following `errno' error conditions are defined for
     this function:

    `EMFILE'
          The process has too many file descriptors open.

    `EAFNOSUPPORT'
          The specified namespace is not supported.

    `EPROTONOSUPPORT'
          The specified protocol is not supported.

    `EOPNOTSUPP'
          The specified protocol does not support the creation of
          socket pairs.


File: libc.info,  Node: Connections,  Next: Datagrams,  Prev: Open/Close Sockets,  Up: Sockets

16.9 Using Sockets with Connections
===================================

The most common communication styles involve making a connection to a
particular other socket, and then exchanging data with that socket over
and over.  Making a connection is asymmetric; one side (the "client")
acts to request a connection, while the other side (the "server") makes
a socket and waits for the connection request.

* Menu:

* Connecting::    	     What the client program must do.
* Listening::		     How a server program waits for requests.
* Accepting Connections::    What the server does when it gets a request.
* Who is Connected::	     Getting the address of the
				other side of a connection.
* Transferring Data::        How to send and receive data.
* Byte Stream Example::	     An example program: a client for communicating
			      over a byte stream socket in the Internet namespace.
* Server Example::	     A corresponding server program.
* Out-of-Band Data::         This is an advanced feature.


File: libc.info,  Node: Connecting,  Next: Listening,  Up: Connections

16.9.1 Making a Connection
--------------------------

In making a connection, the client makes a connection while the server
waits for and accepts the connection.  Here we discuss what the client
program must do with the `connect' function, which is declared in
`sys/socket.h'.

 -- Function: int connect (int SOCKET, struct sockaddr *ADDR, socklen_t
          LENGTH)
     The `connect' function initiates a connection from the socket with
     file descriptor SOCKET to the socket whose address is specified by
     the ADDR and LENGTH arguments.  (This socket is typically on
     another machine, and it must be already set up as a server.)
     *Note Socket Addresses::, for information about how these
     arguments are interpreted.

     Normally, `connect' waits until the server responds to the request
     before it returns.  You can set nonblocking mode on the socket
     SOCKET to make `connect' return immediately without waiting for
     the response.  *Note File Status Flags::, for information about
     nonblocking mode.

     The normal return value from `connect' is `0'.  If an error
     occurs, `connect' returns `-1'.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          The socket SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          File descriptor SOCKET is not a socket.

    `EADDRNOTAVAIL'
          The specified address is not available on the remote machine.

    `EAFNOSUPPORT'
          The namespace of the ADDR is not supported by this socket.

    `EISCONN'
          The socket SOCKET is already connected.

    `ETIMEDOUT'
          The attempt to establish the connection timed out.

    `ECONNREFUSED'
          The server has actively refused to establish the connection.

    `ENETUNREACH'
          The network of the given ADDR isn't reachable from this host.

    `EADDRINUSE'
          The socket address of the given ADDR is already in use.

    `EINPROGRESS'
          The socket SOCKET is non-blocking and the connection could
          not be established immediately.  You can determine when the
          connection is completely established with `select'; *note
          Waiting for I/O::.  Another `connect' call on the same
          socket, before the connection is completely established, will
          fail with `EALREADY'.

    `EALREADY'
          The socket SOCKET is non-blocking and already has a pending
          connection in progress (see `EINPROGRESS' above).

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Listening,  Next: Accepting Connections,  Prev: Connecting,  Up: Connections

16.9.2 Listening for Connections
--------------------------------

Now let us consider what the server process must do to accept
connections on a socket.  First it must use the `listen' function to
enable connection requests on the socket, and then accept each incoming
connection with a call to `accept' (*note Accepting Connections::).
Once connection requests are enabled on a server socket, the `select'
function reports when the socket has a connection ready to be accepted
(*note Waiting for I/O::).

   The `listen' function is not allowed for sockets using
connectionless communication styles.

   You can write a network server that does not even start running
until a connection to it is requested.  *Note Inetd Servers::.

   In the Internet namespace, there are no special protection mechanisms
for controlling access to a port; any process on any machine can make a
connection to your server.  If you want to restrict access to your
server, make it examine the addresses associated with connection
requests or implement some other handshaking or identification protocol.

   In the local namespace, the ordinary file protection bits control
who has access to connect to the socket.

 -- Function: int listen (int SOCKET, int N)
     The `listen' function enables the socket SOCKET to accept
     connections, thus making it a server socket.

     The argument N specifies the length of the queue for pending
     connections.  When the queue fills, new clients attempting to
     connect fail with `ECONNREFUSED' until the server calls `accept' to
     accept a connection from the queue.

     The `listen' function returns `0' on success and `-1' on failure.
     The following `errno' error conditions are defined for this
     function:

    `EBADF'
          The argument SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          The argument SOCKET is not a socket.

    `EOPNOTSUPP'
          The socket SOCKET does not support this operation.


File: libc.info,  Node: Accepting Connections,  Next: Who is Connected,  Prev: Listening,  Up: Connections

16.9.3 Accepting Connections
----------------------------

When a server receives a connection request, it can complete the
connection by accepting the request.  Use the function `accept' to do
this.

   A socket that has been established as a server can accept connection
requests from multiple clients.  The server's original socket _does not
become part of the connection_; instead, `accept' makes a new socket
which participates in the connection.  `accept' returns the descriptor
for this socket.  The server's original socket remains available for
listening for further connection requests.

   The number of pending connection requests on a server socket is
finite.  If connection requests arrive from clients faster than the
server can act upon them, the queue can fill up and additional requests
are refused with an `ECONNREFUSED' error.  You can specify the maximum
length of this queue as an argument to the `listen' function, although
the system may also impose its own internal limit on the length of this
queue.

 -- Function: int accept (int SOCKET, struct sockaddr *ADDR, socklen_t
          *LENGTH_PTR)
     This function is used to accept a connection request on the server
     socket SOCKET.

     The `accept' function waits if there are no connections pending,
     unless the socket SOCKET has nonblocking mode set.  (You can use
     `select' to wait for a pending connection, with a nonblocking
     socket.)  *Note File Status Flags::, for information about
     nonblocking mode.

     The ADDR and LENGTH-PTR arguments are used to return information
     about the name of the client socket that initiated the connection.
     *Note Socket Addresses::, for information about the format of the
     information.

     Accepting a connection does not make SOCKET part of the
     connection.  Instead, it creates a new socket which becomes
     connected.  The normal return value of `accept' is the file
     descriptor for the new socket.

     After `accept', the original socket SOCKET remains open and
     unconnected, and continues listening until you close it.  You can
     accept further connections with SOCKET by calling `accept' again.

     If an error occurs, `accept' returns `-1'.  The following `errno'
     error conditions are defined for this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET argument is not a socket.

    `EOPNOTSUPP'
          The descriptor SOCKET does not support this operation.

    `EWOULDBLOCK'
          SOCKET has nonblocking mode set, and there are no pending
          connections immediately available.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.

   The `accept' function is not allowed for sockets using
connectionless communication styles.


File: libc.info,  Node: Who is Connected,  Next: Transferring Data,  Prev: Accepting Connections,  Up: Connections

16.9.4 Who is Connected to Me?
------------------------------

 -- Function: int getpeername (int SOCKET, struct sockaddr *ADDR,
          socklen_t *LENGTH-PTR)
     The `getpeername' function returns the address of the socket that
     SOCKET is connected to; it stores the address in the memory space
     specified by ADDR and LENGTH-PTR.  It stores the length of the
     address in `*LENGTH-PTR'.

     *Note Socket Addresses::, for information about the format of the
     address.  In some operating systems, `getpeername' works only for
     sockets in the Internet domain.

     The return value is `0' on success and `-1' on error.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          The argument SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `ENOTCONN'
          The socket SOCKET is not connected.

    `ENOBUFS'
          There are not enough internal buffers available.


File: libc.info,  Node: Transferring Data,  Next: Byte Stream Example,  Prev: Who is Connected,  Up: Connections

16.9.5 Transferring Data
------------------------

Once a socket has been connected to a peer, you can use the ordinary
`read' and `write' operations (*note I/O Primitives::) to transfer
data.  A socket is a two-way communications channel, so read and write
operations can be performed at either end.

   There are also some I/O modes that are specific to socket operations.
In order to specify these modes, you must use the `recv' and `send'
functions instead of the more generic `read' and `write' functions.
The `recv' and `send' functions take an additional argument which you
can use to specify various flags to control special I/O modes.  For
example, you can specify the `MSG_OOB' flag to read or write
out-of-band data, the `MSG_PEEK' flag to peek at input, or the
`MSG_DONTROUTE' flag to control inclusion of routing information on
output.

* Menu:

* Sending Data::		Sending data with `send'.
* Receiving Data::		Reading data with `recv'.
* Socket Data Options::		Using `send' and `recv'.


File: libc.info,  Node: Sending Data,  Next: Receiving Data,  Up: Transferring Data

16.9.5.1 Sending Data
.....................

The `send' function is declared in the header file `sys/socket.h'.  If
your FLAGS argument is zero, you can just as well use `write' instead
of `send'; see *Note I/O Primitives::.  If the socket was connected but
the connection has broken, you get a `SIGPIPE' signal for any use of
`send' or `write' (*note Miscellaneous Signals::).

 -- Function: int send (int SOCKET, void *BUFFER, size_t SIZE, int
          FLAGS)
     The `send' function is like `write', but with the additional flags
     FLAGS.  The possible values of FLAGS are described in *Note Socket
     Data Options::.

     This function returns the number of bytes transmitted, or `-1' on
     failure.  If the socket is nonblocking, then `send' (like `write')
     can return after sending just part of the data.  *Note File Status
     Flags::, for information about nonblocking mode.

     Note, however, that a successful return value merely indicates that
     the message has been sent without error, not necessarily that it
     has been received without error.

     The following `errno' error conditions are defined for this
     function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `EINTR'
          The operation was interrupted by a signal before any data was
          sent.  *Note Interrupted Primitives::.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `EMSGSIZE'
          The socket type requires that the message be sent atomically,
          but the message is too large for this to be possible.

    `EWOULDBLOCK'
          Nonblocking mode has been set on the socket, and the write
          operation would block.  (Normally `send' blocks until the
          operation can be completed.)

    `ENOBUFS'
          There is not enough internal buffer space available.

    `ENOTCONN'
          You never connected this socket.

    `EPIPE'
          This socket was connected but the connection is now broken.
          In this case, `send' generates a `SIGPIPE' signal first; if
          that signal is ignored or blocked, or if its handler returns,
          then `send' fails with `EPIPE'.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Receiving Data,  Next: Socket Data Options,  Prev: Sending Data,  Up: Transferring Data

16.9.5.2 Receiving Data
.......................

The `recv' function is declared in the header file `sys/socket.h'.  If
your FLAGS argument is zero, you can just as well use `read' instead of
`recv'; see *Note I/O Primitives::.

 -- Function: int recv (int SOCKET, void *BUFFER, size_t SIZE, int
          FLAGS)
     The `recv' function is like `read', but with the additional flags
     FLAGS.  The possible values of FLAGS are described in *Note Socket
     Data Options::.

     If nonblocking mode is set for SOCKET, and no data are available to
     be read, `recv' fails immediately rather than waiting.  *Note File
     Status Flags::, for information about nonblocking mode.

     This function returns the number of bytes received, or `-1' on
     failure.  The following `errno' error conditions are defined for
     this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `EWOULDBLOCK'
          Nonblocking mode has been set on the socket, and the read
          operation would block.  (Normally, `recv' blocks until there
          is input available to be read.)

    `EINTR'
          The operation was interrupted by a signal before any data was
          read.  *Note Interrupted Primitives::.

    `ENOTCONN'
          You never connected this socket.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Socket Data Options,  Prev: Receiving Data,  Up: Transferring Data

16.9.5.3 Socket Data Options
............................

The FLAGS argument to `send' and `recv' is a bit mask.  You can
bitwise-OR the values of the following macros together to obtain a
value for this argument.  All are defined in the header file
`sys/socket.h'.

 -- Macro: int MSG_OOB
     Send or receive out-of-band data.  *Note Out-of-Band Data::.

 -- Macro: int MSG_PEEK
     Look at the data but don't remove it from the input queue.  This is
     only meaningful with input functions such as `recv', not with
     `send'.

 -- Macro: int MSG_DONTROUTE
     Don't include routing information in the message.  This is only
     meaningful with output operations, and is usually only of interest
     for diagnostic or routing programs.  We don't try to explain it
     here.


File: libc.info,  Node: Byte Stream Example,  Next: Server Example,  Prev: Transferring Data,  Up: Connections

16.9.6 Byte Stream Socket Example
---------------------------------

Here is an example client program that makes a connection for a byte
stream socket in the Internet namespace.  It doesn't do anything
particularly interesting once it has connected to the server; it just
sends a text string to the server and exits.

   This program uses `init_sockaddr' to set up the socket address; see
*Note Inet Example::.

     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <unistd.h>
     #include <sys/types.h>
     #include <sys/socket.h>
     #include <netinet/in.h>
     #include <netdb.h>

     #define PORT            5555
     #define MESSAGE         "Yow!!! Are we having fun yet?!?"
     #define SERVERHOST      "mescaline.gnu.org"

     void
     write_to_server (int filedes)
     {
       int nbytes;

       nbytes = write (filedes, MESSAGE, strlen (MESSAGE) + 1);
       if (nbytes < 0)
         {
           perror ("write");
           exit (EXIT_FAILURE);
         }
     }


     int
     main (void)
     {
       extern void init_sockaddr (struct sockaddr_in *name,
                                  const char *hostname,
                                  uint16_t port);
       int sock;
       struct sockaddr_in servername;

       /* Create the socket. */
       sock = socket (PF_INET, SOCK_STREAM, 0);
       if (sock < 0)
         {
           perror ("socket (client)");
           exit (EXIT_FAILURE);
         }

       /* Connect to the server. */
       init_sockaddr (&servername, SERVERHOST, PORT);
       if (0 > connect (sock,
                        (struct sockaddr *) &servername,
                        sizeof (servername)))
         {
           perror ("connect (client)");
           exit (EXIT_FAILURE);
         }

       /* Send data to the server. */
       write_to_server (sock);
       close (sock);
       exit (EXIT_SUCCESS);
     }


File: libc.info,  Node: Server Example,  Next: Out-of-Band Data,  Prev: Byte Stream Example,  Up: Connections

16.9.7 Byte Stream Connection Server Example
--------------------------------------------

The server end is much more complicated.  Since we want to allow
multiple clients to be connected to the server at the same time, it
would be incorrect to wait for input from a single client by simply
calling `read' or `recv'.  Instead, the right thing to do is to use
`select' (*note Waiting for I/O::) to wait for input on all of the open
sockets.  This also allows the server to deal with additional
connection requests.

   This particular server doesn't do anything interesting once it has
gotten a message from a client.  It does close the socket for that
client when it detects an end-of-file condition (resulting from the
client shutting down its end of the connection).

   This program uses `make_socket' to set up the socket address; see
*Note Inet Example::.

     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <unistd.h>
     #include <sys/types.h>
     #include <sys/socket.h>
     #include <netinet/in.h>
     #include <netdb.h>

     #define PORT    5555
     #define MAXMSG  512

     int
     read_from_client (int filedes)
     {
       char buffer[MAXMSG];
       int nbytes;

       nbytes = read (filedes, buffer, MAXMSG);
       if (nbytes < 0)
         {
           /* Read error. */
           perror ("read");
           exit (EXIT_FAILURE);
         }
       else if (nbytes == 0)
         /* End-of-file. */
         return -1;
       else
         {
           /* Data read. */
           fprintf (stderr, "Server: got message: `%s'\n", buffer);
           return 0;
         }
     }

     int
     main (void)
     {
       extern int make_socket (uint16_t port);
       int sock;
       fd_set active_fd_set, read_fd_set;
       int i;
       struct sockaddr_in clientname;
       size_t size;

       /* Create the socket and set it up to accept connections. */
       sock = make_socket (PORT);
       if (listen (sock, 1) < 0)
         {
           perror ("listen");
           exit (EXIT_FAILURE);
         }

       /* Initialize the set of active sockets. */
       FD_ZERO (&active_fd_set);
       FD_SET (sock, &active_fd_set);

       while (1)
         {
           /* Block until input arrives on one or more active sockets. */
           read_fd_set = active_fd_set;
           if (select (FD_SETSIZE, &read_fd_set, NULL, NULL, NULL) < 0)
             {
               perror ("select");
               exit (EXIT_FAILURE);
             }

           /* Service all the sockets with input pending. */
           for (i = 0; i < FD_SETSIZE; ++i)
             if (FD_ISSET (i, &read_fd_set))
               {
                 if (i == sock)
                   {
                     /* Connection request on original socket. */
                     int new;
                     size = sizeof (clientname);
                     new = accept (sock,
                                   (struct sockaddr *) &clientname,
                                   &size);
                     if (new < 0)
                       {
                         perror ("accept");
                         exit (EXIT_FAILURE);
                       }
                     fprintf (stderr,
                              "Server: connect from host %s, port %hd.\n",
                              inet_ntoa (clientname.sin_addr),
                              ntohs (clientname.sin_port));
                     FD_SET (new, &active_fd_set);
                   }
                 else
                   {
                     /* Data arriving on an already-connected socket. */
                     if (read_from_client (i) < 0)
                       {
                         close (i);
                         FD_CLR (i, &active_fd_set);
                       }
                   }
               }
         }
     }


File: libc.info,  Node: Out-of-Band Data,  Prev: Server Example,  Up: Connections

16.9.8 Out-of-Band Data
-----------------------

Streams with connections permit "out-of-band" data that is delivered
with higher priority than ordinary data.  Typically the reason for
sending out-of-band data is to send notice of an exceptional condition.
To send out-of-band data use `send', specifying the flag `MSG_OOB'
(*note Sending Data::).

   Out-of-band data are received with higher priority because the
receiving process need not read it in sequence; to read the next
available out-of-band data, use `recv' with the `MSG_OOB' flag (*note
Receiving Data::).  Ordinary read operations do not read out-of-band
data; they read only ordinary data.

   When a socket finds that out-of-band data are on their way, it sends
a `SIGURG' signal to the owner process or process group of the socket.
You can specify the owner using the `F_SETOWN' command to the `fcntl'
function; see *Note Interrupt Input::.  You must also establish a
handler for this signal, as described in *Note Signal Handling::, in
order to take appropriate action such as reading the out-of-band data.

   Alternatively, you can test for pending out-of-band data, or wait
until there is out-of-band data, using the `select' function; it can
wait for an exceptional condition on the socket.  *Note Waiting for
I/O::, for more information about `select'.

   Notification of out-of-band data (whether with `SIGURG' or with
`select') indicates that out-of-band data are on the way; the data may
not actually arrive until later.  If you try to read the out-of-band
data before it arrives, `recv' fails with an `EWOULDBLOCK' error.

   Sending out-of-band data automatically places a "mark" in the stream
of ordinary data, showing where in the sequence the out-of-band data
"would have been".  This is useful when the meaning of out-of-band data
is "cancel everything sent so far".  Here is how you can test, in the
receiving process, whether any ordinary data was sent before the mark:

     success = ioctl (socket, SIOCATMARK, &atmark);

   The `integer' variable ATMARK is set to a nonzero value if the
socket's read pointer has reached the "mark".

   Here's a function to discard any ordinary data preceding the
out-of-band mark:

     int
     discard_until_mark (int socket)
     {
       while (1)
         {
           /* This is not an arbitrary limit; any size will do.  */
           char buffer[1024];
           int atmark, success;

           /* If we have reached the mark, return.  */
           success = ioctl (socket, SIOCATMARK, &atmark);
           if (success < 0)
             perror ("ioctl");
           if (result)
             return;

           /* Otherwise, read a bunch of ordinary data and discard it.
              This is guaranteed not to read past the mark
              if it starts before the mark.  */
           success = read (socket, buffer, sizeof buffer);
           if (success < 0)
             perror ("read");
         }
     }

   If you don't want to discard the ordinary data preceding the mark,
you may need to read some of it anyway, to make room in internal system
buffers for the out-of-band data.  If you try to read out-of-band data
and get an `EWOULDBLOCK' error, try reading some ordinary data (saving
it so that you can use it when you want it) and see if that makes room.
Here is an example:

     struct buffer
     {
       char *buf;
       int size;
       struct buffer *next;
     };

     /* Read the out-of-band data from SOCKET and return it
        as a `struct buffer', which records the address of the data
        and its size.

        It may be necessary to read some ordinary data
        in order to make room for the out-of-band data.
        If so, the ordinary data are saved as a chain of buffers
        found in the `next' field of the value.  */

     struct buffer *
     read_oob (int socket)
     {
       struct buffer *tail = 0;
       struct buffer *list = 0;

       while (1)
         {
           /* This is an arbitrary limit.
              Does anyone know how to do this without a limit?  */
     #define BUF_SZ 1024
           char *buf = (char *) xmalloc (BUF_SZ);
           int success;
           int atmark;

           /* Try again to read the out-of-band data.  */
           success = recv (socket, buf, BUF_SZ, MSG_OOB);
           if (success >= 0)
             {
               /* We got it, so return it.  */
               struct buffer *link
                 = (struct buffer *) xmalloc (sizeof (struct buffer));
               link->buf = buf;
               link->size = success;
               link->next = list;
               return link;
             }

           /* If we fail, see if we are at the mark.  */
           success = ioctl (socket, SIOCATMARK, &atmark);
           if (success < 0)
             perror ("ioctl");
           if (atmark)
             {
               /* At the mark; skipping past more ordinary data cannot help.
                  So just wait a while.  */
               sleep (1);
               continue;
             }

           /* Otherwise, read a bunch of ordinary data and save it.
              This is guaranteed not to read past the mark
              if it starts before the mark.  */
           success = read (socket, buf, BUF_SZ);
           if (success < 0)
             perror ("read");

           /* Save this data in the buffer list.  */
           {
             struct buffer *link
               = (struct buffer *) xmalloc (sizeof (struct buffer));
             link->buf = buf;
             link->size = success;

             /* Add the new link to the end of the list.  */
             if (tail)
               tail->next = link;
             else
               list = link;
             tail = link;
           }
         }
     }


File: libc.info,  Node: Datagrams,  Next: Inetd,  Prev: Connections,  Up: Sockets

16.10 Datagram Socket Operations
================================

This section describes how to use communication styles that don't use
connections (styles `SOCK_DGRAM' and `SOCK_RDM').  Using these styles,
you group data into packets and each packet is an independent
communication.  You specify the destination for each packet
individually.

   Datagram packets are like letters: you send each one independently
with its own destination address, and they may arrive in the wrong
order or not at all.

   The `listen' and `accept' functions are not allowed for sockets
using connectionless communication styles.

* Menu:

* Sending Datagrams::    Sending packets on a datagram socket.
* Receiving Datagrams::  Receiving packets on a datagram socket.
* Datagram Example::     An example program: packets sent over a
                           datagram socket in the local namespace.
* Example Receiver::	 Another program, that receives those packets.


File: libc.info,  Node: Sending Datagrams,  Next: Receiving Datagrams,  Up: Datagrams

16.10.1 Sending Datagrams
-------------------------

The normal way of sending data on a datagram socket is by using the
`sendto' function, declared in `sys/socket.h'.

   You can call `connect' on a datagram socket, but this only specifies
a default destination for further data transmission on the socket.
When a socket has a default destination you can use `send' (*note
Sending Data::) or even `write' (*note I/O Primitives::) to send a
packet there.  You can cancel the default destination by calling
`connect' using an address format of `AF_UNSPEC' in the ADDR argument.
*Note Connecting::, for more information about the `connect' function.

 -- Function: int sendto (int SOCKET, void *BUFFER. size_t SIZE, int
          FLAGS, struct sockaddr *ADDR, socklen_t LENGTH)
     The `sendto' function transmits the data in the BUFFER through the
     socket SOCKET to the destination address specified by the ADDR and
     LENGTH arguments.  The SIZE argument specifies the number of bytes
     to be transmitted.

     The FLAGS are interpreted the same way as for `send'; see *Note
     Socket Data Options::.

     The return value and error conditions are also the same as for
     `send', but you cannot rely on the system to detect errors and
     report them; the most common error is that the packet is lost or
     there is no-one at the specified address to receive it, and the
     operating system on your machine usually does not know this.

     It is also possible for one call to `sendto' to report an error
     owing to a problem related to a previous call.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Receiving Datagrams,  Next: Datagram Example,  Prev: Sending Datagrams,  Up: Datagrams

16.10.2 Receiving Datagrams
---------------------------

The `recvfrom' function reads a packet from a datagram socket and also
tells you where it was sent from.  This function is declared in
`sys/socket.h'.

 -- Function: int recvfrom (int SOCKET, void *BUFFER, size_t SIZE, int
          FLAGS, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)
     The `recvfrom' function reads one packet from the socket SOCKET
     into the buffer BUFFER.  The SIZE argument specifies the maximum
     number of bytes to be read.

     If the packet is longer than SIZE bytes, then you get the first
     SIZE bytes of the packet and the rest of the packet is lost.
     There's no way to read the rest of the packet.  Thus, when you use
     a packet protocol, you must always know how long a packet to
     expect.

     The ADDR and LENGTH-PTR arguments are used to return the address
     where the packet came from.  *Note Socket Addresses::.  For a
     socket in the local domain the address information won't be
     meaningful, since you can't read the address of such a socket
     (*note Local Namespace::).  You can specify a null pointer as the
     ADDR argument if you are not interested in this information.

     The FLAGS are interpreted the same way as for `recv' (*note Socket
     Data Options::).  The return value and error conditions are also
     the same as for `recv'.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.

   You can use plain `recv' (*note Receiving Data::) instead of
`recvfrom' if you don't need to find out who sent the packet (either
because you know where it should come from or because you treat all
possible senders alike).  Even `read' can be used if you don't want to
specify FLAGS (*note I/O Primitives::).


File: libc.info,  Node: Datagram Example,  Next: Example Receiver,  Prev: Receiving Datagrams,  Up: Datagrams

16.10.3 Datagram Socket Example
-------------------------------

Here is a set of example programs that send messages over a datagram
stream in the local namespace.  Both the client and server programs use
the `make_named_socket' function that was presented in *Note Local
Socket Example::, to create and name their sockets.

   First, here is the server program.  It sits in a loop waiting for
messages to arrive, bouncing each message back to the sender.
Obviously this isn't a particularly useful program, but it does show
the general ideas involved.

     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <sys/un.h>

     #define SERVER  "/tmp/serversocket"
     #define MAXMSG  512

     int
     main (void)
     {
       int sock;
       char message[MAXMSG];
       struct sockaddr_un name;
       size_t size;
       int nbytes;

       /* Remove the filename first, it's ok if the call fails */
       unlink (SERVER);

       /* Make the socket, then loop endlessly. */
       sock = make_named_socket (SERVER);
       while (1)
         {
           /* Wait for a datagram. */
           size = sizeof (name);
           nbytes = recvfrom (sock, message, MAXMSG, 0,
                              (struct sockaddr *) & name, &size);
           if (nbytes < 0)
             {
               perror ("recfrom (server)");
               exit (EXIT_FAILURE);
             }

           /* Give a diagnostic message. */
           fprintf (stderr, "Server: got message: %s\n", message);

           /* Bounce the message back to the sender. */
           nbytes = sendto (sock, message, nbytes, 0,
                            (struct sockaddr *) & name, size);
           if (nbytes < 0)
             {
               perror ("sendto (server)");
               exit (EXIT_FAILURE);
             }
         }
     }


File: libc.info,  Node: Example Receiver,  Prev: Datagram Example,  Up: Datagrams

16.10.4 Example of Reading Datagrams
------------------------------------

Here is the client program corresponding to the server above.

   It sends a datagram to the server and then waits for a reply.  Notice
that the socket for the client (as well as for the server) in this
example has to be given a name.  This is so that the server can direct
a message back to the client.  Since the socket has no associated
connection state, the only way the server can do this is by referencing
the name of the client.

     #include <stdio.h>
     #include <errno.h>
     #include <unistd.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <sys/un.h>

     #define SERVER  "/tmp/serversocket"
     #define CLIENT  "/tmp/mysocket"
     #define MAXMSG  512
     #define MESSAGE "Yow!!! Are we having fun yet?!?"

     int
     main (void)
     {
       extern int make_named_socket (const char *name);
       int sock;
       char message[MAXMSG];
       struct sockaddr_un name;
       size_t size;
       int nbytes;

       /* Make the socket. */
       sock = make_named_socket (CLIENT);

       /* Initialize the server socket address. */
       name.sun_family = AF_LOCAL;
       strcpy (name.sun_path, SERVER);
       size = strlen (name.sun_path) + sizeof (name.sun_family);

       /* Send the datagram. */
       nbytes = sendto (sock, MESSAGE, strlen (MESSAGE) + 1, 0,
                        (struct sockaddr *) & name, size);
       if (nbytes < 0)
         {
           perror ("sendto (client)");
           exit (EXIT_FAILURE);
         }

       /* Wait for a reply. */
       nbytes = recvfrom (sock, message, MAXMSG, 0, NULL, 0);
       if (nbytes < 0)
         {
           perror ("recfrom (client)");
           exit (EXIT_FAILURE);
         }

       /* Print a diagnostic message. */
       fprintf (stderr, "Client: got message: %s\n", message);

       /* Clean up. */
       remove (CLIENT);
       close (sock);
     }

   Keep in mind that datagram socket communications are unreliable.  In
this example, the client program waits indefinitely if the message
never reaches the server or if the server's response never comes back.
It's up to the user running the program to kill and restart it if
desired.  A more automatic solution could be to use `select' (*note
Waiting for I/O::) to establish a timeout period for the reply, and in
case of timeout either re-send the message or shut down the socket and
exit.


File: libc.info,  Node: Inetd,  Next: Socket Options,  Prev: Datagrams,  Up: Sockets

16.11 The `inetd' Daemon
========================

We've explained above how to write a server program that does its own
listening.  Such a server must already be running in order for anyone
to connect to it.

   Another way to provide a service on an Internet port is to let the
daemon program `inetd' do the listening.  `inetd' is a program that
runs all the time and waits (using `select') for messages on a
specified set of ports.  When it receives a message, it accepts the
connection (if the socket style calls for connections) and then forks a
child process to run the corresponding server program.  You specify the
ports and their programs in the file `/etc/inetd.conf'.

* Menu:

* Inetd Servers::
* Configuring Inetd::


File: libc.info,  Node: Inetd Servers,  Next: Configuring Inetd,  Up: Inetd

16.11.1 `inetd' Servers
-----------------------

Writing a server program to be run by `inetd' is very simple.  Each time
someone requests a connection to the appropriate port, a new server
process starts.  The connection already exists at this time; the socket
is available as the standard input descriptor and as the standard
output descriptor (descriptors 0 and 1) in the server process.  Thus
the server program can begin reading and writing data right away.
Often the program needs only the ordinary I/O facilities; in fact, a
general-purpose filter program that knows nothing about sockets can
work as a byte stream server run by `inetd'.

   You can also use `inetd' for servers that use connectionless
communication styles.  For these servers, `inetd' does not try to accept
a connection since no connection is possible.  It just starts the
server program, which can read the incoming datagram packet from
descriptor 0.  The server program can handle one request and then exit,
or you can choose to write it to keep reading more requests until no
more arrive, and then exit.  You must specify which of these two
techniques the server uses when you configure `inetd'.


File: libc.info,  Node: Configuring Inetd,  Prev: Inetd Servers,  Up: Inetd

16.11.2 Configuring `inetd'
---------------------------

The file `/etc/inetd.conf' tells `inetd' which ports to listen to and
what server programs to run for them.  Normally each entry in the file
is one line, but you can split it onto multiple lines provided all but
the first line of the entry start with whitespace.  Lines that start
with `#' are comments.

   Here are two standard entries in `/etc/inetd.conf':

     ftp	stream	tcp	nowait	root	/libexec/ftpd	ftpd
     talk	dgram	udp	wait	root	/libexec/talkd	talkd

   An entry has this format:

     SERVICE STYLE PROTOCOL WAIT USERNAME PROGRAM ARGUMENTS

   The SERVICE field says which service this program provides.  It
should be the name of a service defined in `/etc/services'.  `inetd'
uses SERVICE to decide which port to listen on for this entry.

   The fields STYLE and PROTOCOL specify the communication style and
the protocol to use for the listening socket.  The style should be the
name of a communication style, converted to lower case and with `SOCK_'
deleted--for example, `stream' or `dgram'.  PROTOCOL should be one of
the protocols listed in `/etc/protocols'.  The typical protocol names
are `tcp' for byte stream connections and `udp' for unreliable
datagrams.

   The WAIT field should be either `wait' or `nowait'.  Use `wait' if
STYLE is a connectionless style and the server, once started, handles
multiple requests as they come in.  Use `nowait' if `inetd' should
start a new process for each message or request that comes in.  If
STYLE uses connections, then WAIT *must* be `nowait'.

   USER is the user name that the server should run as.  `inetd' runs
as root, so it can set the user ID of its children arbitrarily.  It's
best to avoid using `root' for USER if you can; but some servers, such
as Telnet and FTP, read a username and password themselves.  These
servers need to be root initially so they can log in as commanded by
the data coming over the network.

   PROGRAM together with ARGUMENTS specifies the command to run to
start the server.  PROGRAM should be an absolute file name specifying
the executable file to run.  ARGUMENTS consists of any number of
whitespace-separated words, which become the command-line arguments of
PROGRAM.  The first word in ARGUMENTS is argument zero, which should by
convention be the program name itself (sans directories).

   If you edit `/etc/inetd.conf', you can tell `inetd' to reread the
file and obey its new contents by sending the `inetd' process the
`SIGHUP' signal.  You'll have to use `ps' to determine the process ID
of the `inetd' process as it is not fixed.


File: libc.info,  Node: Socket Options,  Next: Networks Database,  Prev: Inetd,  Up: Sockets

16.12 Socket Options
====================

This section describes how to read or set various options that modify
the behavior of sockets and their underlying communications protocols.

   When you are manipulating a socket option, you must specify which
"level" the option pertains to.  This describes whether the option
applies to the socket interface, or to a lower-level communications
protocol interface.

* Menu:

* Socket Option Functions::     The basic functions for setting and getting
                                 socket options.
* Socket-Level Options::        Details of the options at the socket level.


File: libc.info,  Node: Socket Option Functions,  Next: Socket-Level Options,  Up: Socket Options

16.12.1 Socket Option Functions
-------------------------------

Here are the functions for examining and modifying socket options.
They are declared in `sys/socket.h'.

 -- Function: int getsockopt (int SOCKET, int LEVEL, int OPTNAME, void
          *OPTVAL, socklen_t *OPTLEN-PTR)
     The `getsockopt' function gets information about the value of
     option OPTNAME at level LEVEL for socket SOCKET.

     The option value is stored in a buffer that OPTVAL points to.
     Before the call, you should supply in `*OPTLEN-PTR' the size of
     this buffer; on return, it contains the number of bytes of
     information actually stored in the buffer.

     Most options interpret the OPTVAL buffer as a single `int' value.

     The actual return value of `getsockopt' is `0' on success and `-1'
     on failure.  The following `errno' error conditions are defined:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `ENOPROTOOPT'
          The OPTNAME doesn't make sense for the given LEVEL.

 -- Function: int setsockopt (int SOCKET, int LEVEL, int OPTNAME, void
          *OPTVAL, socklen_t OPTLEN)
     This function is used to set the socket option OPTNAME at level
     LEVEL for socket SOCKET.  The value of the option is passed in the
     buffer OPTVAL of size OPTLEN.

     The return value and error codes for `setsockopt' are the same as
     for `getsockopt'.



File: libc.info,  Node: Socket-Level Options,  Prev: Socket Option Functions,  Up: Socket Options

16.12.2 Socket-Level Options
----------------------------

 -- Constant: int SOL_SOCKET
     Use this constant as the LEVEL argument to `getsockopt' or
     `setsockopt' to manipulate the socket-level options described in
     this section.

Here is a table of socket-level option names; all are defined in the
header file `sys/socket.h'.

`SO_DEBUG'
     This option toggles recording of debugging information in the
     underlying protocol modules.  The value has type `int'; a nonzero
     value means "yes".

`SO_REUSEADDR'
     This option controls whether `bind' (*note Setting Address::)
     should permit reuse of local addresses for this socket.  If you
     enable this option, you can actually have two sockets with the
     same Internet port number; but the system won't allow you to use
     the two identically-named sockets in a way that would confuse the
     Internet.  The reason for this option is that some higher-level
     Internet protocols, including FTP, require you to keep reusing the
     same port number.

     The value has type `int'; a nonzero value means "yes".

`SO_KEEPALIVE'
     This option controls whether the underlying protocol should
     periodically transmit messages on a connected socket.  If the peer
     fails to respond to these messages, the connection is considered
     broken.  The value has type `int'; a nonzero value means "yes".

`SO_DONTROUTE'
     This option controls whether outgoing messages bypass the normal
     message routing facilities.  If set, messages are sent directly to
     the network interface instead.  The value has type `int'; a nonzero
     value means "yes".

`SO_LINGER'
     This option specifies what should happen when the socket of a type
     that promises reliable delivery still has untransmitted messages
     when it is closed; see *Note Closing a Socket::.  The value has
     type `struct linger'.

      -- Data Type: struct linger
          This structure type has the following members:

         `int l_onoff'
               This field is interpreted as a boolean.  If nonzero,
               `close' blocks until the data are transmitted or the
               timeout period has expired.

         `int l_linger'
               This specifies the timeout period, in seconds.

`SO_BROADCAST'
     This option controls whether datagrams may be broadcast from the
     socket.  The value has type `int'; a nonzero value means "yes".

`SO_OOBINLINE'
     If this option is set, out-of-band data received on the socket is
     placed in the normal input queue.  This permits it to be read using
     `read' or `recv' without specifying the `MSG_OOB' flag.  *Note
     Out-of-Band Data::.  The value has type `int'; a nonzero value
     means "yes".

`SO_SNDBUF'
     This option gets or sets the size of the output buffer.  The value
     is a `size_t', which is the size in bytes.

`SO_RCVBUF'
     This option gets or sets the size of the input buffer.  The value
     is a `size_t', which is the size in bytes.

`SO_STYLE'
`SO_TYPE'
     This option can be used with `getsockopt' only.  It is used to get
     the socket's communication style.  `SO_TYPE' is the historical
     name, and `SO_STYLE' is the preferred name in GNU.  The value has
     type `int' and its value designates a communication style; see
     *Note Communication Styles::.

`SO_ERROR'
     This option can be used with `getsockopt' only.  It is used to
     reset the error status of the socket.  The value is an `int',
     which represents the previous error status.


File: libc.info,  Node: Networks Database,  Prev: Socket Options,  Up: Sockets

16.13 Networks Database
=======================

Many systems come with a database that records a list of networks known
to the system developer.  This is usually kept either in the file
`/etc/networks' or in an equivalent from a name server.  This data base
is useful for routing programs such as `route', but it is not useful
for programs that simply communicate over the network.  We provide
functions to access this database, which are declared in `netdb.h'.

 -- Data Type: struct netent
     This data type is used to represent information about entries in
     the networks database.  It has the following members:

    `char *n_name'
          This is the "official" name of the network.

    `char **n_aliases'
          These are alternative names for the network, represented as a
          vector of strings.  A null pointer terminates the array.

    `int n_addrtype'
          This is the type of the network number; this is always equal
          to `AF_INET' for Internet networks.

    `unsigned long int n_net'
          This is the network number.  Network numbers are returned in
          host byte order; see *Note Byte Order::.

   Use the `getnetbyname' or `getnetbyaddr' functions to search the
networks database for information about a specific network.  The
information is returned in a statically-allocated structure; you must
copy the information if you need to save it.

 -- Function: struct netent * getnetbyname (const char *NAME)
     The `getnetbyname' function returns information about the network
     named NAME.  It returns a null pointer if there is no such network.

 -- Function: struct netent * getnetbyaddr (unsigned long int NET, int
          TYPE)
     The `getnetbyaddr' function returns information about the network
     of type TYPE with number NET.  You should specify a value of
     `AF_INET' for the TYPE argument for Internet networks.

     `getnetbyaddr' returns a null pointer if there is no such network.

   You can also scan the networks database using `setnetent',
`getnetent' and `endnetent'.  Be careful when using these functions
because they are not reentrant.

 -- Function: void setnetent (int STAYOPEN)
     This function opens and rewinds the networks database.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `getnetbyname' or `getnetbyaddr' will not
     close the database (as they usually would).  This makes for more
     efficiency if you call those functions several times, by avoiding
     reopening the database for each call.

 -- Function: struct netent * getnetent (void)
     This function returns the next entry in the networks database.  It
     returns a null pointer if there are no more entries.

 -- Function: void endnetent (void)
     This function closes the networks database.


File: libc.info,  Node: Low-Level Terminal Interface,  Next: Syslog,  Prev: Sockets,  Up: Top

17 Low-Level Terminal Interface
*******************************

This chapter describes functions that are specific to terminal devices.
You can use these functions to do things like turn off input echoing;
set serial line characteristics such as line speed and flow control; and
change which characters are used for end-of-file, command-line editing,
sending signals, and similar control functions.

   Most of the functions in this chapter operate on file descriptors.
*Note Low-Level I/O::, for more information about what a file
descriptor is and how to open a file descriptor for a terminal device.

* Menu:

* Is It a Terminal::            How to determine if a file is a terminal
			         device, and what its name is.
* I/O Queues::                  About flow control and typeahead.
* Canonical or Not::            Two basic styles of input processing.
* Terminal Modes::              How to examine and modify flags controlling
			         details of terminal I/O: echoing,
                                 signals, editing.  Posix.
* BSD Terminal Modes::          BSD compatible terminal mode setting
* Line Control::                Sending break sequences, clearing
                                 terminal buffers ...
* Noncanon Example::            How to read single characters without echo.
* Pseudo-Terminals::            How to open a pseudo-terminal.


File: libc.info,  Node: Is It a Terminal,  Next: I/O Queues,  Up: Low-Level Terminal Interface

17.1 Identifying Terminals
==========================

The functions described in this chapter only work on files that
correspond to terminal devices.  You can find out whether a file
descriptor is associated with a terminal by using the `isatty' function.

   Prototypes for the functions in this section are declared in the
header file `unistd.h'.

 -- Function: int isatty (int FILEDES)
     This function returns `1' if FILEDES is a file descriptor
     associated with an open terminal device, and 0 otherwise.

   If a file descriptor is associated with a terminal, you can get its
associated file name using the `ttyname' function.  See also the
`ctermid' function, described in *Note Identifying the Terminal::.

 -- Function: char * ttyname (int FILEDES)
     If the file descriptor FILEDES is associated with a terminal
     device, the `ttyname' function returns a pointer to a
     statically-allocated, null-terminated string containing the file
     name of the terminal file.  The value is a null pointer if the
     file descriptor isn't associated with a terminal, or the file name
     cannot be determined.

 -- Function: int ttyname_r (int FILEDES, char *BUF, size_t LEN)
     The `ttyname_r' function is similar to the `ttyname' function
     except that it places its result into the user-specified buffer
     starting at BUF with length LEN.

     The normal return value from `ttyname_r' is 0.  Otherwise an error
     number is returned to indicate the error.  The following `errno'
     error conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

    `ERANGE'
          The buffer length LEN is too small to store the string to be
          returned.


File: libc.info,  Node: I/O Queues,  Next: Canonical or Not,  Prev: Is It a Terminal,  Up: Low-Level Terminal Interface

17.2 I/O Queues
===============

Many of the remaining functions in this section refer to the input and
output queues of a terminal device.  These queues implement a form of
buffering _within the kernel_ independent of the buffering implemented
by I/O streams (*note I/O on Streams::).

   The "terminal input queue" is also sometimes referred to as its
"typeahead buffer".  It holds the characters that have been received
from the terminal but not yet read by any process.

   The size of the input queue is described by the `MAX_INPUT' and
`_POSIX_MAX_INPUT' parameters; see *Note Limits for Files::.  You are
guaranteed a queue size of at least `MAX_INPUT', but the queue might be
larger, and might even dynamically change size.  If input flow control
is enabled by setting the `IXOFF' input mode bit (*note Input Modes::),
the terminal driver transmits STOP and START characters to the terminal
when necessary to prevent the queue from overflowing.  Otherwise, input
may be lost if it comes in too fast from the terminal.  In canonical
mode, all input stays in the queue until a newline character is
received, so the terminal input queue can fill up when you type a very
long line.  *Note Canonical or Not::.

   The "terminal output queue" is like the input queue, but for output;
it contains characters that have been written by processes, but not yet
transmitted to the terminal.  If output flow control is enabled by
setting the `IXON' input mode bit (*note Input Modes::), the terminal
driver obeys START and STOP characters sent by the terminal to stop and
restart transmission of output.

   "Clearing" the terminal input queue means discarding any characters
that have been received but not yet read.  Similarly, clearing the
terminal output queue means discarding any characters that have been
written but not yet transmitted.


File: libc.info,  Node: Canonical or Not,  Next: Terminal Modes,  Prev: I/O Queues,  Up: Low-Level Terminal Interface

17.3 Two Styles of Input: Canonical or Not
==========================================

POSIX systems support two basic modes of input: canonical and
noncanonical.

   In "canonical input processing" mode, terminal input is processed in
lines terminated by newline (`'\n''), EOF, or EOL characters.  No input
can be read until an entire line has been typed by the user, and the
`read' function (*note I/O Primitives::) returns at most a single line
of input, no matter how many bytes are requested.

   In canonical input mode, the operating system provides input editing
facilities: some characters are interpreted specially to perform editing
operations within the current line of text, such as ERASE and KILL.
*Note Editing Characters::.

   The constants `_POSIX_MAX_CANON' and `MAX_CANON' parameterize the
maximum number of bytes which may appear in a single line of canonical
input.  *Note Limits for Files::.  You are guaranteed a maximum line
length of at least `MAX_CANON' bytes, but the maximum might be larger,
and might even dynamically change size.

   In "noncanonical input processing" mode, characters are not grouped
into lines, and ERASE and KILL processing is not performed.  The
granularity with which bytes are read in noncanonical input mode is
controlled by the MIN and TIME settings.  *Note Noncanonical Input::.

   Most programs use canonical input mode, because this gives the user a
way to edit input line by line.  The usual reason to use noncanonical
mode is when the program accepts single-character commands or provides
its own editing facilities.

   The choice of canonical or noncanonical input is controlled by the
`ICANON' flag in the `c_lflag' member of `struct termios'.  *Note Local
Modes::.


File: libc.info,  Node: Terminal Modes,  Next: BSD Terminal Modes,  Prev: Canonical or Not,  Up: Low-Level Terminal Interface

17.4 Terminal Modes
===================

This section describes the various terminal attributes that control how
input and output are done.  The functions, data structures, and symbolic
constants are all declared in the header file `termios.h'.

   Don't confuse terminal attributes with file attributes.  A device
special file which is associated with a terminal has file attributes as
described in *Note File Attributes::.  These are unrelated to the
attributes of the terminal device itself, which are discussed in this
section.

* Menu:

* Mode Data Types::             The data type `struct termios' and
                                 related types.
* Mode Functions::              Functions to read and set the terminal
                                 attributes.
* Setting Modes::               The right way to set terminal attributes
                                 reliably.
* Input Modes::                 Flags controlling low-level input handling.
* Output Modes::                Flags controlling low-level output handling.
* Control Modes::               Flags controlling serial port behavior.
* Local Modes::                 Flags controlling high-level input handling.
* Line Speed::                  How to read and set the terminal line speed.
* Special Characters::          Characters that have special effects,
			         and how to change them.
* Noncanonical Input::          Controlling how long to wait for input.


File: libc.info,  Node: Mode Data Types,  Next: Mode Functions,  Up: Terminal Modes

17.4.1 Terminal Mode Data Types
-------------------------------

The entire collection of attributes of a terminal is stored in a
structure of type `struct termios'.  This structure is used with the
functions `tcgetattr' and `tcsetattr' to read and set the attributes.

 -- Data Type: struct termios
     Structure that records all the I/O attributes of a terminal.  The
     structure includes at least the following members:

    `tcflag_t c_iflag'
          A bit mask specifying flags for input modes; see *Note Input
          Modes::.

    `tcflag_t c_oflag'
          A bit mask specifying flags for output modes; see *Note
          Output Modes::.

    `tcflag_t c_cflag'
          A bit mask specifying flags for control modes; see *Note
          Control Modes::.

    `tcflag_t c_lflag'
          A bit mask specifying flags for local modes; see *Note Local
          Modes::.

    `cc_t c_cc[NCCS]'
          An array specifying which characters are associated with
          various control functions; see *Note Special Characters::.

     The `struct termios' structure also contains members which encode
     input and output transmission speeds, but the representation is
     not specified.  *Note Line Speed::, for how to examine and store
     the speed values.

   The following sections describe the details of the members of the
`struct termios' structure.

 -- Data Type: tcflag_t
     This is an unsigned integer type used to represent the various bit
     masks for terminal flags.

 -- Data Type: cc_t
     This is an unsigned integer type used to represent characters
     associated with various terminal control functions.

 -- Macro: int NCCS
     The value of this macro is the number of elements in the `c_cc'
     array.


File: libc.info,  Node: Mode Functions,  Next: Setting Modes,  Prev: Mode Data Types,  Up: Terminal Modes

17.4.2 Terminal Mode Functions
------------------------------

 -- Function: int tcgetattr (int FILEDES, struct termios *TERMIOS-P)
     This function is used to examine the attributes of the terminal
     device with file descriptor FILEDES.  The attributes are returned
     in the structure that TERMIOS-P points to.

     If successful, `tcgetattr' returns 0.  A return value of -1
     indicates an error.  The following `errno' error conditions are
     defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

 -- Function: int tcsetattr (int FILEDES, int WHEN, const struct
          termios *TERMIOS-P)
     This function sets the attributes of the terminal device with file
     descriptor FILEDES.  The new attributes are taken from the
     structure that TERMIOS-P points to.

     The WHEN argument specifies how to deal with input and output
     already queued.  It can be one of the following values:

    `TCSANOW'
          Make the change immediately.

    `TCSADRAIN'
          Make the change after waiting until all queued output has
          been written.  You should usually use this option when
          changing parameters that affect output.

    `TCSAFLUSH'
          This is like `TCSADRAIN', but also discards any queued input.

    `TCSASOFT'
          This is a flag bit that you can add to any of the above
          alternatives.  Its meaning is to inhibit alteration of the
          state of the terminal hardware.  It is a BSD extension; it is
          only supported on BSD systems and the GNU system.

          Using `TCSASOFT' is exactly the same as setting the `CIGNORE'
          bit in the `c_cflag' member of the structure TERMIOS-P points
          to.  *Note Control Modes::, for a description of `CIGNORE'.

     If this function is called from a background process on its
     controlling terminal, normally all processes in the process group
     are sent a `SIGTTOU' signal, in the same way as if the process
     were trying to write to the terminal.  The exception is if the
     calling process itself is ignoring or blocking `SIGTTOU' signals,
     in which case the operation is performed and no signal is sent.
     *Note Job Control::.

     If successful, `tcsetattr' returns 0.  A return value of -1
     indicates an error.  The following `errno' error conditions are
     defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

    `EINVAL'
          Either the value of the `when' argument is not valid, or
          there is something wrong with the data in the TERMIOS-P
          argument.

Although `tcgetattr' and `tcsetattr' specify the terminal device with a
file descriptor, the attributes are those of the terminal device itself
and not of the file descriptor.  This means that the effects of
changing terminal attributes are persistent; if another process opens
the terminal file later on, it will see the changed attributes even
though it doesn't have anything to do with the open file descriptor you
originally specified in changing the attributes.

   Similarly, if a single process has multiple or duplicated file
descriptors for the same terminal device, changing the terminal
attributes affects input and output to all of these file descriptors.
This means, for example, that you can't open one file descriptor or
stream to read from a terminal in the normal line-buffered, echoed
mode; and simultaneously have another file descriptor for the same
terminal that you use to read from it in single-character, non-echoed
mode.  Instead, you have to explicitly switch the terminal back and
forth between the two modes.


File: libc.info,  Node: Setting Modes,  Next: Input Modes,  Prev: Mode Functions,  Up: Terminal Modes

17.4.3 Setting Terminal Modes Properly
--------------------------------------

When you set terminal modes, you should call `tcgetattr' first to get
the current modes of the particular terminal device, modify only those
modes that you are really interested in, and store the result with
`tcsetattr'.

   It's a bad idea to simply initialize a `struct termios' structure to
a chosen set of attributes and pass it directly to `tcsetattr'.  Your
program may be run years from now, on systems that support members not
documented in this manual.  The way to avoid setting these members to
unreasonable values is to avoid changing them.

   What's more, different terminal devices may require different mode
settings in order to function properly.  So you should avoid blindly
copying attributes from one terminal device to another.

   When a member contains a collection of independent flags, as the
`c_iflag', `c_oflag' and `c_cflag' members do, even setting the entire
member is a bad idea, because particular operating systems have their
own flags.  Instead, you should start with the current value of the
member and alter only the flags whose values matter in your program,
leaving any other flags unchanged.

   Here is an example of how to set one flag (`ISTRIP') in the `struct
termios' structure while properly preserving all the other data in the
structure:

     int
     set_istrip (int desc, int value)
     {
       struct termios settings;
       int result;

       result = tcgetattr (desc, &settings);
       if (result < 0)
         {
           perror ("error in tcgetattr");
           return 0;
         }
       settings.c_iflag &= ~ISTRIP;
       if (value)
         settings.c_iflag |= ISTRIP;
       result = tcsetattr (desc, TCSANOW, &settings);
       if (result < 0)
         {
           perror ("error in tcsetattr");
           return 0;
        }
       return 1;
     }


File: libc.info,  Node: Input Modes,  Next: Output Modes,  Prev: Setting Modes,  Up: Terminal Modes

17.4.4 Input Modes
------------------

This section describes the terminal attribute flags that control fairly
low-level aspects of input processing: handling of parity errors, break
signals, flow control, and <RET> and <LFD> characters.

   All of these flags are bits in the `c_iflag' member of the `struct
termios' structure.  The member is an integer, and you change flags
using the operators `&', `|' and `^'.  Don't try to specify the entire
value for `c_iflag'--instead, change only specific flags and leave the
rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t INPCK
     If this bit is set, input parity checking is enabled.  If it is
     not set, no checking at all is done for parity errors on input; the
     characters are simply passed through to the application.

     Parity checking on input processing is independent of whether
     parity detection and generation on the underlying terminal
     hardware is enabled; see *Note Control Modes::.  For example, you
     could clear the `INPCK' input mode flag and set the `PARENB'
     control mode flag to ignore parity errors on input, but still
     generate parity on output.

     If this bit is set, what happens when a parity error is detected
     depends on whether the `IGNPAR' or `PARMRK' bits are set.  If
     neither of these bits are set, a byte with a parity error is
     passed to the application as a `'\0'' character.

 -- Macro: tcflag_t IGNPAR
     If this bit is set, any byte with a framing or parity error is
     ignored.  This is only useful if `INPCK' is also set.

 -- Macro: tcflag_t PARMRK
     If this bit is set, input bytes with parity or framing errors are
     marked when passed to the program.  This bit is meaningful only
     when `INPCK' is set and `IGNPAR' is not set.

     The way erroneous bytes are marked is with two preceding bytes,
     `377' and `0'.  Thus, the program actually reads three bytes for
     one erroneous byte received from the terminal.

     If a valid byte has the value `0377', and `ISTRIP' (see below) is
     not set, the program might confuse it with the prefix that marks a
     parity error.  So a valid byte `0377' is passed to the program as
     two bytes, `0377' `0377', in this case.

 -- Macro: tcflag_t ISTRIP
     If this bit is set, valid input bytes are stripped to seven bits;
     otherwise, all eight bits are available for programs to read.

 -- Macro: tcflag_t IGNBRK
     If this bit is set, break conditions are ignored.

     A "break condition" is defined in the context of asynchronous
     serial data transmission as a series of zero-value bits longer
     than a single byte.

 -- Macro: tcflag_t BRKINT
     If this bit is set and `IGNBRK' is not set, a break condition
     clears the terminal input and output queues and raises a `SIGINT'
     signal for the foreground process group associated with the
     terminal.

     If neither `BRKINT' nor `IGNBRK' are set, a break condition is
     passed to the application as a single `'\0'' character if `PARMRK'
     is not set, or otherwise as a three-character sequence `'\377'',
     `'\0'', `'\0''.

 -- Macro: tcflag_t IGNCR
     If this bit is set, carriage return characters (`'\r'') are
     discarded on input.  Discarding carriage return may be useful on
     terminals that send both carriage return and linefeed when you
     type the <RET> key.

 -- Macro: tcflag_t ICRNL
     If this bit is set and `IGNCR' is not set, carriage return
     characters (`'\r'') received as input are passed to the
     application as newline characters (`'\n'').

 -- Macro: tcflag_t INLCR
     If this bit is set, newline characters (`'\n'') received as input
     are passed to the application as carriage return characters
     (`'\r'').

 -- Macro: tcflag_t IXOFF
     If this bit is set, start/stop control on input is enabled.  In
     other words, the computer sends STOP and START characters as
     necessary to prevent input from coming in faster than programs are
     reading it.  The idea is that the actual terminal hardware that is
     generating the input data responds to a STOP character by
     suspending transmission, and to a START character by resuming
     transmission.  *Note Start/Stop Characters::.

 -- Macro: tcflag_t IXON
     If this bit is set, start/stop control on output is enabled.  In
     other words, if the computer receives a STOP character, it
     suspends output until a START character is received.  In this
     case, the STOP and START characters are never passed to the
     application program.  If this bit is not set, then START and STOP
     can be read as ordinary characters.  *Note Start/Stop Characters::.

 -- Macro: tcflag_t IXANY
     If this bit is set, any input character restarts output when
     output has been suspended with the STOP character.  Otherwise,
     only the START character restarts output.

     This is a BSD extension; it exists only on BSD systems and the GNU
     system.

 -- Macro: tcflag_t IMAXBEL
     If this bit is set, then filling up the terminal input buffer
     sends a BEL character (code `007') to the terminal to ring the
     bell.

     This is a BSD extension.


File: libc.info,  Node: Output Modes,  Next: Control Modes,  Prev: Input Modes,  Up: Terminal Modes

17.4.5 Output Modes
-------------------

This section describes the terminal flags and fields that control how
output characters are translated and padded for display.  All of these
are contained in the `c_oflag' member of the `struct termios' structure.

   The `c_oflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_oflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t OPOST
     If this bit is set, output data is processed in some unspecified
     way so that it is displayed appropriately on the terminal device.
     This typically includes mapping newline characters (`'\n'') onto
     carriage return and linefeed pairs.

     If this bit isn't set, the characters are transmitted as-is.

   The following three bits are BSD features, and they exist only BSD
systems and the GNU system.  They are effective only if `OPOST' is set.

 -- Macro: tcflag_t ONLCR
     If this bit is set, convert the newline character on output into a
     pair of characters, carriage return followed by linefeed.

 -- Macro: tcflag_t OXTABS
     If this bit is set, convert tab characters on output into the
     appropriate number of spaces to emulate a tab stop every eight
     columns.

 -- Macro: tcflag_t ONOEOT
     If this bit is set, discard `C-d' characters (code `004') on
     output.  These characters cause many dial-up terminals to
     disconnect.


File: libc.info,  Node: Control Modes,  Next: Local Modes,  Prev: Output Modes,  Up: Terminal Modes

17.4.6 Control Modes
--------------------

This section describes the terminal flags and fields that control
parameters usually associated with asynchronous serial data
transmission.  These flags may not make sense for other kinds of
terminal ports (such as a network connection pseudo-terminal).  All of
these are contained in the `c_cflag' member of the `struct termios'
structure.

   The `c_cflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_cflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t CLOCAL
     If this bit is set, it indicates that the terminal is connected
     "locally" and that the modem status lines (such as carrier detect)
     should be ignored.  

     On many systems if this bit is not set and you call `open' without
     the `O_NONBLOCK' flag set, `open' blocks until a modem connection
     is established.

     If this bit is not set and a modem disconnect is detected, a
     `SIGHUP' signal is sent to the controlling process group for the
     terminal (if it has one).  Normally, this causes the process to
     exit; see *Note Signal Handling::.  Reading from the terminal
     after a disconnect causes an end-of-file condition, and writing
     causes an `EIO' error to be returned.  The terminal device must be
     closed and reopened to clear the condition.  

 -- Macro: tcflag_t HUPCL
     If this bit is set, a modem disconnect is generated when all
     processes that have the terminal device open have either closed
     the file or exited.

 -- Macro: tcflag_t CREAD
     If this bit is set, input can be read from the terminal.
     Otherwise, input is discarded when it arrives.

 -- Macro: tcflag_t CSTOPB
     If this bit is set, two stop bits are used.  Otherwise, only one
     stop bit is used.

 -- Macro: tcflag_t PARENB
     If this bit is set, generation and detection of a parity bit are
     enabled.  *Note Input Modes::, for information on how input parity
     errors are handled.

     If this bit is not set, no parity bit is added to output
     characters, and input characters are not checked for correct
     parity.

 -- Macro: tcflag_t PARODD
     This bit is only useful if `PARENB' is set.  If `PARODD' is set,
     odd parity is used, otherwise even parity is used.

   The control mode flags also includes a field for the number of bits
per character.  You can use the `CSIZE' macro as a mask to extract the
value, like this: `settings.c_cflag & CSIZE'.

 -- Macro: tcflag_t CSIZE
     This is a mask for the number of bits per character.

 -- Macro: tcflag_t CS5
     This specifies five bits per byte.

 -- Macro: tcflag_t CS6
     This specifies six bits per byte.

 -- Macro: tcflag_t CS7
     This specifies seven bits per byte.

 -- Macro: tcflag_t CS8
     This specifies eight bits per byte.

   The following four bits are BSD extensions; this exist only on BSD
systems and the GNU system.

 -- Macro: tcflag_t CCTS_OFLOW
     If this bit is set, enable flow control of output based on the CTS
     wire (RS232 protocol).

 -- Macro: tcflag_t CRTS_IFLOW
     If this bit is set, enable flow control of input based on the RTS
     wire (RS232 protocol).

 -- Macro: tcflag_t MDMBUF
     If this bit is set, enable carrier-based flow control of output.

 -- Macro: tcflag_t CIGNORE
     If this bit is set, it says to ignore the control modes and line
     speed values entirely.  This is only meaningful in a call to
     `tcsetattr'.

     The `c_cflag' member and the line speed values returned by
     `cfgetispeed' and `cfgetospeed' will be unaffected by the call.
     `CIGNORE' is useful if you want to set all the software modes in
     the other members, but leave the hardware details in `c_cflag'
     unchanged.  (This is how the `TCSASOFT' flag to `tcsettattr'
     works.)

     This bit is never set in the structure filled in by `tcgetattr'.


File: libc.info,  Node: Local Modes,  Next: Line Speed,  Prev: Control Modes,  Up: Terminal Modes

17.4.7 Local Modes
------------------

This section describes the flags for the `c_lflag' member of the
`struct termios' structure.  These flags generally control higher-level
aspects of input processing than the input modes flags described in
*Note Input Modes::, such as echoing, signals, and the choice of
canonical or noncanonical input.

   The `c_lflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_lflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t ICANON
     This bit, if set, enables canonical input processing mode.
     Otherwise, input is processed in noncanonical mode.  *Note
     Canonical or Not::.

 -- Macro: tcflag_t ECHO
     If this bit is set, echoing of input characters back to the
     terminal is enabled.  

 -- Macro: tcflag_t ECHOE
     If this bit is set, echoing indicates erasure of input with the
     ERASE character by erasing the last character in the current line
     from the screen.  Otherwise, the character erased is re-echoed to
     show what has happened (suitable for a printing terminal).

     This bit only controls the display behavior; the `ICANON' bit by
     itself controls actual recognition of the ERASE character and
     erasure of input, without which `ECHOE' is simply irrelevant.

 -- Macro: tcflag_t ECHOPRT
     This bit is like `ECHOE', enables display of the ERASE character in
     a way that is geared to a hardcopy terminal.  When you type the
     ERASE character, a `\' character is printed followed by the first
     character erased.  Typing the ERASE character again just prints
     the next character erased.  Then, the next time you type a normal
     character, a `/' character is printed before the character echoes.

     This is a BSD extension, and exists only in BSD systems and the
     GNU system.

 -- Macro: tcflag_t ECHOK
     This bit enables special display of the KILL character by moving
     to a new line after echoing the KILL character normally.  The
     behavior of `ECHOKE' (below) is nicer to look at.

     If this bit is not set, the KILL character echoes just as it would
     if it were not the KILL character.  Then it is up to the user to
     remember that the KILL character has erased the preceding input;
     there is no indication of this on the screen.

     This bit only controls the display behavior; the `ICANON' bit by
     itself controls actual recognition of the KILL character and
     erasure of input, without which `ECHOK' is simply irrelevant.

 -- Macro: tcflag_t ECHOKE
     This bit is similar to `ECHOK'.  It enables special display of the
     KILL character by erasing on the screen the entire line that has
     been killed.  This is a BSD extension, and exists only in BSD
     systems and the GNU system.

 -- Macro: tcflag_t ECHONL
     If this bit is set and the `ICANON' bit is also set, then the
     newline (`'\n'') character is echoed even if the `ECHO' bit is not
     set.

 -- Macro: tcflag_t ECHOCTL
     If this bit is set and the `ECHO' bit is also set, echo control
     characters with `^' followed by the corresponding text character.
     Thus, control-A echoes as `^A'.  This is usually the preferred mode
     for interactive input, because echoing a control character back to
     the terminal could have some undesired effect on the terminal.

     This is a BSD extension, and exists only in BSD systems and the
     GNU system.

 -- Macro: tcflag_t ISIG
     This bit controls whether the INTR, QUIT, and SUSP characters are
     recognized.  The functions associated with these characters are
     performed if and only if this bit is set.  Being in canonical or
     noncanonical input mode has no affect on the interpretation of
     these characters.

     You should use caution when disabling recognition of these
     characters.  Programs that cannot be interrupted interactively are
     very user-unfriendly.  If you clear this bit, your program should
     provide some alternate interface that allows the user to
     interactively send the signals associated with these characters,
     or to escape from the program.  

     *Note Signal Characters::.

 -- Macro: tcflag_t IEXTEN
     POSIX.1 gives `IEXTEN' implementation-defined meaning, so you
     cannot rely on this interpretation on all systems.

     On BSD systems and the GNU system, it enables the LNEXT and
     DISCARD characters.  *Note Other Special::.

 -- Macro: tcflag_t NOFLSH
     Normally, the INTR, QUIT, and SUSP characters cause input and
     output queues for the terminal to be cleared.  If this bit is set,
     the queues are not cleared.

 -- Macro: tcflag_t TOSTOP
     If this bit is set and the system supports job control, then
     `SIGTTOU' signals are generated by background processes that
     attempt to write to the terminal.  *Note Access to the Terminal::.

   The following bits are BSD extensions; they exist only in BSD systems
and the GNU system.

 -- Macro: tcflag_t ALTWERASE
     This bit determines how far the WERASE character should erase.  The
     WERASE character erases back to the beginning of a word; the
     question is, where do words begin?

     If this bit is clear, then the beginning of a word is a
     nonwhitespace character following a whitespace character.  If the
     bit is set, then the beginning of a word is an alphanumeric
     character or underscore following a character which is none of
     those.

     *Note Editing Characters::, for more information about the WERASE
     character.

 -- Macro: tcflag_t FLUSHO
     This is the bit that toggles when the user types the DISCARD
     character.  While this bit is set, all output is discarded.  *Note
     Other Special::.

 -- Macro: tcflag_t NOKERNINFO
     Setting this bit disables handling of the STATUS character.  *Note
     Other Special::.

 -- Macro: tcflag_t PENDIN
     If this bit is set, it indicates that there is a line of input that
     needs to be reprinted.  Typing the REPRINT character sets this
     bit; the bit remains set until reprinting is finished.  *Note
     Editing Characters::.


File: libc.info,  Node: Line Speed,  Next: Special Characters,  Prev: Local Modes,  Up: Terminal Modes

17.4.8 Line Speed
-----------------

The terminal line speed tells the computer how fast to read and write
data on the terminal.

   If the terminal is connected to a real serial line, the terminal
speed you specify actually controls the line--if it doesn't match the
terminal's own idea of the speed, communication does not work.  Real
serial ports accept only certain standard speeds.  Also, particular
hardware may not support even all the standard speeds.  Specifying a
speed of zero hangs up a dialup connection and turns off modem control
signals.

   If the terminal is not a real serial line (for example, if it is a
network connection), then the line speed won't really affect data
transmission speed, but some programs will use it to determine the
amount of padding needed.  It's best to specify a line speed value that
matches the actual speed of the actual terminal, but you can safely
experiment with different values to vary the amount of padding.

   There are actually two line speeds for each terminal, one for input
and one for output.  You can set them independently, but most often
terminals use the same speed for both directions.

   The speed values are stored in the `struct termios' structure, but
don't try to access them in the `struct termios' structure directly.
Instead, you should use the following functions to read and store them:

 -- Function: speed_t cfgetospeed (const struct termios *TERMIOS-P)
     This function returns the output line speed stored in the structure
     `*TERMIOS-P'.

 -- Function: speed_t cfgetispeed (const struct termios *TERMIOS-P)
     This function returns the input line speed stored in the structure
     `*TERMIOS-P'.

 -- Function: int cfsetospeed (struct termios *TERMIOS-P, speed_t SPEED)
     This function stores SPEED in `*TERMIOS-P' as the output speed.
     The normal return value is 0; a value of -1 indicates an error.
     If SPEED is not a speed, `cfsetospeed' returns -1.

 -- Function: int cfsetispeed (struct termios *TERMIOS-P, speed_t SPEED)
     This function stores SPEED in `*TERMIOS-P' as the input speed.
     The normal return value is 0; a value of -1 indicates an error.
     If SPEED is not a speed, `cfsetospeed' returns -1.

 -- Function: int cfsetspeed (struct termios *TERMIOS-P, speed_t SPEED)
     This function stores SPEED in `*TERMIOS-P' as both the input and
     output speeds.  The normal return value is 0; a value of -1
     indicates an error.  If SPEED is not a speed, `cfsetspeed' returns
     -1.  This function is an extension in 4.4 BSD.

 -- Data Type: speed_t
     The `speed_t' type is an unsigned integer data type used to
     represent line speeds.

   The functions `cfsetospeed' and `cfsetispeed' report errors only for
speed values that the system simply cannot handle.  If you specify a
speed value that is basically acceptable, then those functions will
succeed.  But they do not check that a particular hardware device can
actually support the specified speeds--in fact, they don't know which
device you plan to set the speed for.  If you use `tcsetattr' to set
the speed of a particular device to a value that it cannot handle,
`tcsetattr' returns -1.

   *Portability note:* In the GNU library, the functions above accept
speeds measured in bits per second as input, and return speed values
measured in bits per second.  Other libraries require speeds to be
indicated by special codes.  For POSIX.1 portability, you must use one
of the following symbols to represent the speed; their precise numeric
values are system-dependent, but each name has a fixed meaning: `B110'
stands for 110 bps, `B300' for 300 bps, and so on.  There is no
portable way to represent any speed but these, but these are the only
speeds that typical serial lines can support.

     B0  B50  B75  B110  B134  B150  B200
     B300  B600  B1200  B1800  B2400  B4800
     B9600  B19200  B38400  B57600  B115200
     B230400  B460800

   BSD defines two additional speed symbols as aliases: `EXTA' is an
alias for `B19200' and `EXTB' is an alias for `B38400'.  These aliases
are obsolete.


File: libc.info,  Node: Special Characters,  Next: Noncanonical Input,  Prev: Line Speed,  Up: Terminal Modes

17.4.9 Special Characters
-------------------------

In canonical input, the terminal driver recognizes a number of special
characters which perform various control functions.  These include the
ERASE character (usually <DEL>) for editing input, and other editing
characters.  The INTR character (normally `C-c') for sending a `SIGINT'
signal, and other signal-raising characters, may be available in either
canonical or noncanonical input mode.  All these characters are
described in this section.

   The particular characters used are specified in the `c_cc' member of
the `struct termios' structure.  This member is an array; each element
specifies the character for a particular role.  Each element has a
symbolic constant that stands for the index of that element--for
example, `VINTR' is the index of the element that specifies the INTR
character, so storing `'='' in `TERMIOS.c_cc[VINTR]' specifies `=' as
the INTR character.

   On some systems, you can disable a particular special character
function by specifying the value `_POSIX_VDISABLE' for that role.  This
value is unequal to any possible character code.  *Note Options for
Files::, for more information about how to tell whether the operating
system you are using supports `_POSIX_VDISABLE'.

* Menu:

* Editing Characters::          Special characters that terminate lines and
                                  delete text, and other editing functions.
* Signal Characters::           Special characters that send or raise signals
                                  to or for certain classes of processes.
* Start/Stop Characters::       Special characters that suspend or resume
                                  suspended output.
* Other Special::		Other special characters for BSD systems:
				  they can discard output, and print status.


File: libc.info,  Node: Editing Characters,  Next: Signal Characters,  Up: Special Characters

17.4.9.1 Characters for Input Editing
.....................................

These special characters are active only in canonical input mode.
*Note Canonical or Not::.

 -- Macro: int VEOF
     This is the subscript for the EOF character in the special control
     character array.  `TERMIOS.c_cc[VEOF]' holds the character itself.

     The EOF character is recognized only in canonical input mode.  It
     acts as a line terminator in the same way as a newline character,
     but if the EOF character is typed at the beginning of a line it
     causes `read' to return a byte count of zero, indicating
     end-of-file.  The EOF character itself is discarded.

     Usually, the EOF character is `C-d'.

 -- Macro: int VEOL
     This is the subscript for the EOL character in the special control
     character array.  `TERMIOS.c_cc[VEOL]' holds the character itself.

     The EOL character is recognized only in canonical input mode.  It
     acts as a line terminator, just like a newline character.  The EOL
     character is not discarded; it is read as the last character in
     the input line.

     You don't need to use the EOL character to make <RET> end a line.
     Just set the ICRNL flag.  In fact, this is the default state of
     affairs.

 -- Macro: int VEOL2
     This is the subscript for the EOL2 character in the special control
     character array.  `TERMIOS.c_cc[VEOL2]' holds the character itself.

     The EOL2 character works just like the EOL character (see above),
     but it can be a different character.  Thus, you can specify two
     characters to terminate an input line, by setting EOL to one of
     them and EOL2 to the other.

     The EOL2 character is a BSD extension; it exists only on BSD
     systems and the GNU system.

 -- Macro: int VERASE
     This is the subscript for the ERASE character in the special
     control character array.  `TERMIOS.c_cc[VERASE]' holds the
     character itself.

     The ERASE character is recognized only in canonical input mode.
     When the user types the erase character, the previous character
     typed is discarded.  (If the terminal generates multibyte
     character sequences, this may cause more than one byte of input to
     be discarded.)  This cannot be used to erase past the beginning of
     the current line of text.  The ERASE character itself is discarded.

     Usually, the ERASE character is <DEL>.

 -- Macro: int VWERASE
     This is the subscript for the WERASE character in the special
     control character array.  `TERMIOS.c_cc[VWERASE]' holds the
     character itself.

     The WERASE character is recognized only in canonical mode.  It
     erases an entire word of prior input, and any whitespace after it;
     whitespace characters before the word are not erased.

     The definition of a "word" depends on the setting of the
     `ALTWERASE' mode; *note Local Modes::.

     If the `ALTWERASE' mode is not set, a word is defined as a sequence
     of any characters except space or tab.

     If the `ALTWERASE' mode is set, a word is defined as a sequence of
     characters containing only letters, numbers, and underscores,
     optionally followed by one character that is not a letter, number,
     or underscore.

     The WERASE character is usually `C-w'.

     This is a BSD extension.

 -- Macro: int VKILL
     This is the subscript for the KILL character in the special control
     character array.  `TERMIOS.c_cc[VKILL]' holds the character itself.

     The KILL character is recognized only in canonical input mode.
     When the user types the kill character, the entire contents of the
     current line of input are discarded.  The kill character itself is
     discarded too.

     The KILL character is usually `C-u'.

 -- Macro: int VREPRINT
     This is the subscript for the REPRINT character in the special
     control character array.  `TERMIOS.c_cc[VREPRINT]' holds the
     character itself.

     The REPRINT character is recognized only in canonical mode.  It
     reprints the current input line.  If some asynchronous output has
     come while you are typing, this lets you see the line you are
     typing clearly again.

     The REPRINT character is usually `C-r'.

     This is a BSD extension.


File: libc.info,  Node: Signal Characters,  Next: Start/Stop Characters,  Prev: Editing Characters,  Up: Special Characters

17.4.9.2 Characters that Cause Signals
......................................

These special characters may be active in either canonical or
noncanonical input mode, but only when the `ISIG' flag is set (*note
Local Modes::).

 -- Macro: int VINTR
     This is the subscript for the INTR character in the special control
     character array.  `TERMIOS.c_cc[VINTR]' holds the character itself.

     The INTR (interrupt) character raises a `SIGINT' signal for all
     processes in the foreground job associated with the terminal.  The
     INTR character itself is then discarded.  *Note Signal Handling::,
     for more information about signals.

     Typically, the INTR character is `C-c'.

 -- Macro: int VQUIT
     This is the subscript for the QUIT character in the special control
     character array.  `TERMIOS.c_cc[VQUIT]' holds the character itself.

     The QUIT character raises a `SIGQUIT' signal for all processes in
     the foreground job associated with the terminal.  The QUIT
     character itself is then discarded.  *Note Signal Handling::, for
     more information about signals.

     Typically, the QUIT character is `C-\'.

 -- Macro: int VSUSP
     This is the subscript for the SUSP character in the special control
     character array.  `TERMIOS.c_cc[VSUSP]' holds the character itself.

     The SUSP (suspend) character is recognized only if the
     implementation supports job control (*note Job Control::).  It
     causes a `SIGTSTP' signal to be sent to all processes in the
     foreground job associated with the terminal.  The SUSP character
     itself is then discarded.  *Note Signal Handling::, for more
     information about signals.

     Typically, the SUSP character is `C-z'.

   Few applications disable the normal interpretation of the SUSP
character.  If your program does this, it should provide some other
mechanism for the user to stop the job.  When the user invokes this
mechanism, the program should send a `SIGTSTP' signal to the process
group of the process, not just to the process itself.  *Note Signaling
Another Process::.

 -- Macro: int VDSUSP
     This is the subscript for the DSUSP character in the special
     control character array.  `TERMIOS.c_cc[VDSUSP]' holds the
     character itself.

     The DSUSP (suspend) character is recognized only if the
     implementation supports job control (*note Job Control::).  It
     sends a `SIGTSTP' signal, like the SUSP character, but not right
     away--only when the program tries to read it as input.  Not all
     systems with job control support DSUSP; only BSD-compatible
     systems (including the GNU system).

     *Note Signal Handling::, for more information about signals.

     Typically, the DSUSP character is `C-y'.


File: libc.info,  Node: Start/Stop Characters,  Next: Other Special,  Prev: Signal Characters,  Up: Special Characters

17.4.9.3 Special Characters for Flow Control
............................................

These special characters may be active in either canonical or
noncanonical input mode, but their use is controlled by the flags
`IXON' and `IXOFF' (*note Input Modes::).

 -- Macro: int VSTART
     This is the subscript for the START character in the special
     control character array.  `TERMIOS.c_cc[VSTART]' holds the
     character itself.

     The START character is used to support the `IXON' and `IXOFF'
     input modes.  If `IXON' is set, receiving a START character resumes
     suspended output; the START character itself is discarded.  If
     `IXANY' is set, receiving any character at all resumes suspended
     output; the resuming character is not discarded unless it is the
     START character.  `IXOFF' is set, the system may also transmit
     START characters to the terminal.

     The usual value for the START character is `C-q'.  You may not be
     able to change this value--the hardware may insist on using `C-q'
     regardless of what you specify.

 -- Macro: int VSTOP
     This is the subscript for the STOP character in the special control
     character array.  `TERMIOS.c_cc[VSTOP]' holds the character itself.

     The STOP character is used to support the `IXON' and `IXOFF' input
     modes.  If `IXON' is set, receiving a STOP character causes output
     to be suspended; the STOP character itself is discarded.  If
     `IXOFF' is set, the system may also transmit STOP characters to the
     terminal, to prevent the input queue from overflowing.

     The usual value for the STOP character is `C-s'.  You may not be
     able to change this value--the hardware may insist on using `C-s'
     regardless of what you specify.


File: libc.info,  Node: Other Special,  Prev: Start/Stop Characters,  Up: Special Characters

17.4.9.4 Other Special Characters
.................................

These special characters exist only in BSD systems and the GNU system.

 -- Macro: int VLNEXT
     This is the subscript for the LNEXT character in the special
     control character array.  `TERMIOS.c_cc[VLNEXT]' holds the
     character itself.

     The LNEXT character is recognized only when `IEXTEN' is set, but in
     both canonical and noncanonical mode.  It disables any special
     significance of the next character the user types.  Even if the
     character would normally perform some editing function or generate
     a signal, it is read as a plain character.  This is the analogue
     of the `C-q' command in Emacs.  "LNEXT" stands for "literal next."

     The LNEXT character is usually `C-v'.

 -- Macro: int VDISCARD
     This is the subscript for the DISCARD character in the special
     control character array.  `TERMIOS.c_cc[VDISCARD]' holds the
     character itself.

     The DISCARD character is recognized only when `IEXTEN' is set, but
     in both canonical and noncanonical mode.  Its effect is to toggle
     the discard-output flag.  When this flag is set, all program
     output is discarded.  Setting the flag also discards all output
     currently in the output buffer.  Typing any other character resets
     the flag.

 -- Macro: int VSTATUS
     This is the subscript for the STATUS character in the special
     control character array.  `TERMIOS.c_cc[VSTATUS]' holds the
     character itself.

     The STATUS character's effect is to print out a status message
     about how the current process is running.

     The STATUS character is recognized only in canonical mode, and
     only if `NOKERNINFO' is not set.


File: libc.info,  Node: Noncanonical Input,  Prev: Special Characters,  Up: Terminal Modes

17.4.10 Noncanonical Input
--------------------------

In noncanonical input mode, the special editing characters such as
ERASE and KILL are ignored.  The system facilities for the user to edit
input are disabled in noncanonical mode, so that all input characters
(unless they are special for signal or flow-control purposes) are passed
to the application program exactly as typed.  It is up to the
application program to give the user ways to edit the input, if
appropriate.

   Noncanonical mode offers special parameters called MIN and TIME for
controlling whether and how long to wait for input to be available.  You
can even use them to avoid ever waiting--to return immediately with
whatever input is available, or with no input.

   The MIN and TIME are stored in elements of the `c_cc' array, which
is a member of the `struct termios' structure.  Each element of this
array has a particular role, and each element has a symbolic constant
that stands for the index of that element.  `VMIN' and `VMAX' are the
names for the indices in the array of the MIN and TIME slots.

 -- Macro: int VMIN
     This is the subscript for the MIN slot in the `c_cc' array.  Thus,
     `TERMIOS.c_cc[VMIN]' is the value itself.

     The MIN slot is only meaningful in noncanonical input mode; it
     specifies the minimum number of bytes that must be available in the
     input queue in order for `read' to return.

 -- Macro: int VTIME
     This is the subscript for the TIME slot in the `c_cc' array.  Thus,
     `TERMIOS.c_cc[VTIME]' is the value itself.

     The TIME slot is only meaningful in noncanonical input mode; it
     specifies how long to wait for input before returning, in units of
     0.1 seconds.

   The MIN and TIME values interact to determine the criterion for when
`read' should return; their precise meanings depend on which of them
are nonzero.  There are four possible cases:

   * Both TIME and MIN are nonzero.

     In this case, TIME specifies how long to wait after each input
     character to see if more input arrives.  After the first character
     received, `read' keeps waiting until either MIN bytes have arrived
     in all, or TIME elapses with no further input.

     `read' always blocks until the first character arrives, even if
     TIME elapses first.  `read' can return more than MIN characters if
     more than MIN happen to be in the queue.

   * Both MIN and TIME are zero.

     In this case, `read' always returns immediately with as many
     characters as are available in the queue, up to the number
     requested.  If no input is immediately available, `read' returns a
     value of zero.

   * MIN is zero but TIME has a nonzero value.

     In this case, `read' waits for time TIME for input to become
     available; the availability of a single byte is enough to satisfy
     the read request and cause `read' to return.  When it returns, it
     returns as many characters as are available, up to the number
     requested.  If no input is available before the timer expires,
     `read' returns a value of zero.

   * TIME is zero but MIN has a nonzero value.

     In this case, `read' waits until at least MIN bytes are available
     in the queue.  At that time, `read' returns as many characters as
     are available, up to the number requested.  `read' can return more
     than MIN characters if more than MIN happen to be in the queue.

   What happens if MIN is 50 and you ask to read just 10 bytes?
Normally, `read' waits until there are 50 bytes in the buffer (or, more
generally, the wait condition described above is satisfied), and then
reads 10 of them, leaving the other 40 buffered in the operating system
for a subsequent call to `read'.

   *Portability note:* On some systems, the MIN and TIME slots are
actually the same as the EOF and EOL slots.  This causes no serious
problem because the MIN and TIME slots are used only in noncanonical
input and the EOF and EOL slots are used only in canonical input, but it
isn't very clean.  The GNU library allocates separate slots for these
uses.

 -- Function: void cfmakeraw (struct termios *TERMIOS-P)
     This function provides an easy way to set up `*TERMIOS-P' for what
     has traditionally been called "raw mode" in BSD.  This uses
     noncanonical input, and turns off most processing to give an
     unmodified channel to the terminal.

     It does exactly this:
            TERMIOS-P->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                                          |INLCR|IGNCR|ICRNL|IXON);
            TERMIOS-P->c_oflag &= ~OPOST;
            TERMIOS-P->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
            TERMIOS-P->c_cflag &= ~(CSIZE|PARENB);
            TERMIOS-P->c_cflag |= CS8;


File: libc.info,  Node: BSD Terminal Modes,  Next: Line Control,  Prev: Terminal Modes,  Up: Low-Level Terminal Interface

17.5 BSD Terminal Modes
=======================

The usual way to get and set terminal modes is with the functions
described in *Note Terminal Modes::.  However, on some systems you can
use the BSD-derived functions in this section to do some of the same
thing.  On many systems, these functions do not exist.  Even with the
GNU C library, the functions simply fail with `errno' = `ENOSYS' with
many kernels, including Linux.

   The symbols used in this section are declared in `sgtty.h'.

 -- Data Type: struct sgttyb
     This structure is an input or output parameter list for `gtty' and
     `stty'.

    `char sg_ispeed'
          Line speed for input

    `char sg_ospeed'
          Line speed for output

    `char sg_erase'
          Erase character

    `char sg_kill'
          Kill character

    `int sg_flags'
          Various flags

 -- Function: int gtty (int FILEDES, struct sgttyb *ATTRIBUTES)
     This function gets the attributes of a terminal.

     `gtty' sets *ATTRIBUTES to describe the terminal attributes of the
     terminal which is open with file descriptor FILEDES.

 -- Function: int stty (int FILEDES, struct sgttyb * attributes)
     This function sets the attributes of a terminal.

     `stty' sets the terminal attributes of the terminal which is open
     with file descriptor FILEDES to those described by *FILEDES.


File: libc.info,  Node: Line Control,  Next: Noncanon Example,  Prev: BSD Terminal Modes,  Up: Low-Level Terminal Interface

17.6 Line Control Functions
===========================

These functions perform miscellaneous control actions on terminal
devices.  As regards terminal access, they are treated like doing
output: if any of these functions is used by a background process on its
controlling terminal, normally all processes in the process group are
sent a `SIGTTOU' signal.  The exception is if the calling process
itself is ignoring or blocking `SIGTTOU' signals, in which case the
operation is performed and no signal is sent.  *Note Job Control::.

 -- Function: int tcsendbreak (int FILEDES, int DURATION)
     This function generates a break condition by transmitting a stream
     of zero bits on the terminal associated with the file descriptor
     FILEDES.  The duration of the break is controlled by the DURATION
     argument.  If zero, the duration is between 0.25 and 0.5 seconds.
     The meaning of a nonzero value depends on the operating system.

     This function does nothing if the terminal is not an asynchronous
     serial data port.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

 -- Function: int tcdrain (int FILEDES)
     The `tcdrain' function waits until all queued output to the
     terminal FILEDES has been transmitted.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `tcdrain' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `tcdrain' should be protected using cancellation handlers.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

    `EINTR'
          The operation was interrupted by delivery of a signal.  *Note
          Interrupted Primitives::.

 -- Function: int tcflush (int FILEDES, int QUEUE)
     The `tcflush' function is used to clear the input and/or output
     queues associated with the terminal file FILEDES.  The QUEUE
     argument specifies which queue(s) to clear, and can be one of the
     following values:

    `TCIFLUSH'
          Clear any input data received, but not yet read.

    `TCOFLUSH'
          Clear any output data written, but not yet transmitted.

    `TCIOFLUSH'
          Clear both queued input and output.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

    `EINVAL'
          A bad value was supplied as the QUEUE argument.

     It is unfortunate that this function is named `tcflush', because
     the term "flush" is normally used for quite another
     operation--waiting until all output is transmitted--and using it
     for discarding input or output would be confusing.  Unfortunately,
     the name `tcflush' comes from POSIX and we cannot change it.

 -- Function: int tcflow (int FILEDES, int ACTION)
     The `tcflow' function is used to perform operations relating to
     XON/XOFF flow control on the terminal file specified by FILEDES.

     The ACTION argument specifies what operation to perform, and can
     be one of the following values:

    `TCOOFF'
          Suspend transmission of output.

    `TCOON'
          Restart transmission of output.

    `TCIOFF'
          Transmit a STOP character.

    `TCION'
          Transmit a START character.

     For more information about the STOP and START characters, see
     *Note Special Characters::.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

    `EINVAL'
          A bad value was supplied as the ACTION argument.


File: libc.info,  Node: Noncanon Example,  Next: Pseudo-Terminals,  Prev: Line Control,  Up: Low-Level Terminal Interface

17.7 Noncanonical Mode Example
==============================

Here is an example program that shows how you can set up a terminal
device to read single characters in noncanonical input mode, without
echo.

     #include <unistd.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <termios.h>

     /* Use this variable to remember original terminal attributes. */

     struct termios saved_attributes;

     void
     reset_input_mode (void)
     {
       tcsetattr (STDIN_FILENO, TCSANOW, &saved_attributes);
     }

     void
     set_input_mode (void)
     {
       struct termios tattr;
       char *name;

       /* Make sure stdin is a terminal. */
       if (!isatty (STDIN_FILENO))
         {
           fprintf (stderr, "Not a terminal.\n");
           exit (EXIT_FAILURE);
         }

       /* Save the terminal attributes so we can restore them later. */
       tcgetattr (STDIN_FILENO, &saved_attributes);
       atexit (reset_input_mode);

       /* Set the funny terminal modes. */
       tcgetattr (STDIN_FILENO, &tattr);
       tattr.c_lflag &= ~(ICANON|ECHO); /* Clear ICANON and ECHO. */
       tattr.c_cc[VMIN] = 1;
       tattr.c_cc[VTIME] = 0;
       tcsetattr (STDIN_FILENO, TCSAFLUSH, &tattr);
     }

     int
     main (void)
     {
       char c;

       set_input_mode ();

       while (1)
         {
           read (STDIN_FILENO, &c, 1);
           if (c == '\004')          /* `C-d' */
             break;
           else
             putchar (c);
         }

       return EXIT_SUCCESS;
     }

   This program is careful to restore the original terminal modes before
exiting or terminating with a signal.  It uses the `atexit' function
(*note Cleanups on Exit::) to make sure this is done by `exit'.

   The shell is supposed to take care of resetting the terminal modes
when a process is stopped or continued; see *Note Job Control::.  But
some existing shells do not actually do this, so you may wish to
establish handlers for job control signals that reset terminal modes.
The above example does so.


File: libc.info,  Node: Pseudo-Terminals,  Prev: Noncanon Example,  Up: Low-Level Terminal Interface

17.8 Pseudo-Terminals
=====================

A "pseudo-terminal" is a special interprocess communication channel
that acts like a terminal.  One end of the channel is called the
"master" side or "master pseudo-terminal device", the other side is
called the "slave" side.  Data written to the master side is received
by the slave side as if it was the result of a user typing at an
ordinary terminal, and data written to the slave side is sent to the
master side as if it was written on an ordinary terminal.

   Pseudo terminals are the way programs like `xterm' and `emacs'
implement their terminal emulation functionality.

* Menu:

* Allocation::             Allocating a pseudo terminal.
* Pseudo-Terminal Pairs::  How to open both sides of a
                            pseudo-terminal in a single operation.


File: libc.info,  Node: Allocation,  Next: Pseudo-Terminal Pairs,  Up: Pseudo-Terminals

17.8.1 Allocating Pseudo-Terminals
----------------------------------

This subsection describes functions for allocating a pseudo-terminal,
and for making this pseudo-terminal available for actual use.  These
functions are declared in the header file `stdlib.h'.

 -- Function: int getpt (void)
     The `getpt' function returns a new file descriptor for the next
     available master pseudo-terminal.  The normal return value from
     `getpt' is a non-negative integer file descriptor.  In the case of
     an error, a value of -1 is returned instead.  The following
     `errno' conditions are defined for this function:

    `ENOENT'
          There are no free master pseudo-terminals available.

     This function is a GNU extension.

 -- Function: int grantpt (int FILEDES)
     The `grantpt' function changes the ownership and access permission
     of the slave pseudo-terminal device corresponding to the master
     pseudo-terminal device associated with the file descriptor
     FILEDES.  The owner is set from the real user ID of the calling
     process (*note Process Persona::), and the group is set to a
     special group (typically "tty") or from the real group ID of the
     calling process.  The access permission is set such that the file
     is both readable and writable by the owner and only writable by
     the group.

     On some systems this function is implemented by invoking a special
     `setuid' root program (*note How Change Persona::).  As a
     consequence, installing a signal handler for the `SIGCHLD' signal
     (*note Job Control Signals::) may interfere with a call to
     `grantpt'.

     The normal return value from `grantpt' is 0; a value of -1 is
     returned in case of failure.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The FILEDES argument is not associated with a master
          pseudo-terminal device.

    `EACCES'
          The slave pseudo-terminal device corresponding to the master
          associated with FILEDES could not be accessed.


 -- Function: int unlockpt (int FILEDES)
     The `unlockpt' function unlocks the slave pseudo-terminal device
     corresponding to the master pseudo-terminal device associated with
     the file descriptor FILEDES.  On many systems, the slave can only
     be opened after unlocking, so portable applications should always
     call `unlockpt' before trying to open the slave.

     The normal return value from `unlockpt' is 0; a value of -1 is
     returned in case of failure.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The FILEDES argument is not associated with a master
          pseudo-terminal device.

 -- Function: char * ptsname (int FILEDES)
     If the file descriptor FILEDES is associated with a master
     pseudo-terminal device, the `ptsname' function returns a pointer
     to a statically-allocated, null-terminated string containing the
     file name of the associated slave pseudo-terminal file.  This
     string might be overwritten by subsequent calls to `ptsname'.

 -- Function: int ptsname_r (int FILEDES, char *BUF, size_t LEN)
     The `ptsname_r' function is similar to the `ptsname' function
     except that it places its result into the user-specified buffer
     starting at BUF with length LEN.

     This function is a GNU extension.

   *Portability Note:* On System V derived systems, the file returned
by the `ptsname' and `ptsname_r' functions may be STREAMS-based, and
therefore require additional processing after opening before it
actually behaves as a pseudo terminal.

   Typical usage of these functions is illustrated by the following
example:
     int
     open_pty_pair (int *amaster, int *aslave)
     {
       int master, slave;
       char *name;

       master = getpt ();
       if (master < 0)
         return 0;

       if (grantpt (master) < 0 || unlockpt (master) < 0)
         goto close_master;
       name = ptsname (master);
       if (name == NULL)
         goto close_master;

       slave = open (name, O_RDWR);
       if (slave == -1)
         goto close_master;

       if (isastream (slave))
         {
           if (ioctl (slave, I_PUSH, "ptem") < 0
               || ioctl (slave, I_PUSH, "ldterm") < 0)
             goto close_slave;
         }

       *amaster = master;
       *aslave = slave;
       return 1;

     close_slave:
       close (slave);

     close_master:
       close (master);
       return 0;
     }


File: libc.info,  Node: Pseudo-Terminal Pairs,  Prev: Allocation,  Up: Pseudo-Terminals

17.8.2 Opening a Pseudo-Terminal Pair
-------------------------------------

These functions, derived from BSD, are available in the separate
`libutil' library, and declared in `pty.h'.

 -- Function: int openpty (int *AMASTER, int *ASLAVE, char *NAME, const
          struct termios *TERMP, const struct winsize *WINP)
     This function allocates and opens a pseudo-terminal pair,
     returning the file descriptor for the master in *AMASTER, and the
     file descriptor for the slave in *ASLAVE.  If the argument NAME is
     not a null pointer, the file name of the slave pseudo-terminal
     device is stored in `*name'.  If TERMP is not a null pointer, the
     terminal attributes of the slave are set to the ones specified in
     the structure that TERMP points to (*note Terminal Modes::).
     Likewise, if the WINP is not a null pointer, the screen size of
     the slave is set to the values specified in the structure that
     WINP points to.

     The normal return value from `openpty' is 0; a value of -1 is
     returned in case of failure.  The following `errno' conditions are
     defined for this function:

    `ENOENT'
          There are no free pseudo-terminal pairs available.

     *Warning:* Using the `openpty' function with NAME not set to
     `NULL' is *very dangerous* because it provides no protection
     against overflowing the string NAME.  You should use the `ttyname'
     function on the file descriptor returned in *SLAVE to find out the
     file name of the slave pseudo-terminal device instead.

 -- Function: int forkpty (int *AMASTER, char *NAME, const struct
          termios *TERMP, const struct winsize *WINP)
     This function is similar to the `openpty' function, but in
     addition, forks a new process (*note Creating a Process::) and
     makes the newly opened slave pseudo-terminal device the
     controlling terminal (*note Controlling Terminal::) for the child
     process.

     If the operation is successful, there are then both parent and
     child processes and both see `forkpty' return, but with different
     values: it returns a value of 0 in the child process and returns
     the child's process ID in the parent process.

     If the allocation of a pseudo-terminal pair or the process creation
     failed, `forkpty' returns a value of -1 in the parent process.

     *Warning:* The `forkpty' function has the same problems with
     respect to the NAME argument as `openpty'.


File: libc.info,  Node: Syslog,  Next: Mathematics,  Prev: Low-Level Terminal Interface,  Up: Top

18 Syslog
*********

This chapter describes facilities for issuing and logging messages of
system administration interest.  This chapter has nothing to do with
programs issuing messages to their own users or keeping private logs
(One would typically do that with the facilities described in *Note I/O
on Streams::).

   Most systems have a facility called "Syslog" that allows programs to
submit messages of interest to system administrators and can be
configured to pass these messages on in various ways, such as printing
on the console, mailing to a particular person, or recording in a log
file for future reference.

   A program uses the facilities in this chapter to submit such
messages.

* Menu:

* Overview of Syslog::           Overview of a system's Syslog facility
* Submitting Syslog Messages::   Functions to submit messages to Syslog


File: libc.info,  Node: Overview of Syslog,  Next: Submitting Syslog Messages,  Up: Syslog

18.1 Overview of Syslog
=======================

System administrators have to deal with lots of different kinds of
messages from a plethora of subsystems within each system, and usually
lots of systems as well.  For example, an FTP server might report every
connection it gets.  The kernel might report hardware failures on a disk
drive.  A DNS server might report usage statistics at regular intervals.

   Some of these messages need to be brought to a system administrator's
attention immediately.  And it may not be just any system administrator
- there may be a particular system administrator who deals with a
particular kind of message.  Other messages just need to be recorded for
future reference if there is a problem.  Still others may need to have
information extracted from them by an automated process that generates
monthly reports.

   To deal with these messages, most Unix systems have a facility called
"Syslog."  It is generally based on a daemon called "Syslogd" Syslogd
listens for messages on a Unix domain socket named `/dev/log'.  Based
on classification information in the messages and its configuration
file (usually `/etc/syslog.conf'), Syslogd routes them in various ways.
Some of the popular routings are:

   * Write to the system console

   * Mail to a specific user

   * Write to a log file

   * Pass to another daemon

   * Discard

   Syslogd can also handle messages from other systems.  It listens on
the `syslog' UDP port as well as the local socket for messages.

   Syslog can handle messages from the kernel itself.  But the kernel
doesn't write to `/dev/log'; rather, another daemon (sometimes called
"Klogd") extracts messages from the kernel and passes them on to Syslog
as any other process would (and it properly identifies them as messages
from the kernel).

   Syslog can even handle messages that the kernel issued before
Syslogd or Klogd was running.  A Linux kernel, for example, stores
startup messages in a kernel message ring and they are normally still
there when Klogd later starts up.  Assuming Syslogd is running by the
time Klogd starts, Klogd then passes everything in the message ring to
it.

   In order to classify messages for disposition, Syslog requires any
process that submits a message to it to provide two pieces of
classification information with it:

facility
     This identifies who submitted the message.  There are a small
     number of facilities defined.  The kernel, the mail subsystem, and
     an FTP server are examples of recognized facilities.  For the
     complete list, *Note syslog; vsyslog::.  Keep in mind that these
     are essentially arbitrary classifications.  "Mail subsystem"
     doesn't have any more meaning than the system administrator gives
     to it.

priority
     This tells how important the content of the message is.  Examples
     of defined priority values are: debug, informational, warning,
     critical.  For the complete list, see *Note syslog; vsyslog::.
     Except for the fact that the priorities have a defined order, the
     meaning of each of these priorities is entirely determined by the
     system administrator.


   A "facility/priority" is a number that indicates both the facility
and the priority.

   *Warning:* This terminology is not universal.  Some people use
"level" to refer to the priority and "priority" to refer to the
combination of facility and priority.  A Linux kernel has a concept of a
message "level," which corresponds both to a Syslog priority and to a
Syslog facility/priority (It can be both because the facility code for
the kernel is zero, and that makes priority and facility/priority the
same value).

   The GNU C library provides functions to submit messages to Syslog.
They do it by writing to the `/dev/log' socket.  *Note Submitting
Syslog Messages::.

   The GNU C library functions only work to submit messages to the
Syslog facility on the same system.  To submit a message to the Syslog
facility on another system, use the socket I/O functions to write a UDP
datagram to the `syslog' UDP port on that system.  *Note Sockets::.


File: libc.info,  Node: Submitting Syslog Messages,  Prev: Overview of Syslog,  Up: Syslog

18.2 Submitting Syslog Messages
===============================

The GNU C library provides functions to submit messages to the Syslog
facility:

* Menu:

* openlog::                      Open connection to Syslog
* syslog; vsyslog::              Submit message to Syslog
* closelog::                     Close connection to Syslog
* setlogmask::                   Cause certain messages to be ignored
* Syslog Example::               Example of all of the above

   These functions only work to submit messages to the Syslog facility
on the same system.  To submit a message to the Syslog facility on
another system, use the socket I/O functions to write a UDP datagram to
the `syslog' UDP port on that system.  *Note Sockets::.


File: libc.info,  Node: openlog,  Next: syslog; vsyslog,  Up: Submitting Syslog Messages

18.2.1 openlog
--------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: void openlog (const char *IDENT, int OPTION, int FACILITY)
     `openlog' opens or reopens a connection to Syslog in preparation
     for submitting messages.

     IDENT is an arbitrary identification string which future `syslog'
     invocations will prefix to each message.  This is intended to
     identify the source of the message, and people conventionally set
     it to the name of the program that will submit the messages.

     If IDENT is NULL, or if `openlog' is not called, the default
     identification string used in Syslog messages will be the program
     name, taken from argv[0].

     Please note that the string pointer IDENT will be retained
     internally by the Syslog routines.  You must not free the memory
     that IDENT points to.  It is also dangerous to pass a reference to
     an automatic variable since leaving the scope would mean ending the
     lifetime of the variable.  If you want to change the IDENT string,
     you must call `openlog' again; overwriting the string pointed to by
     IDENT is not thread-safe.

     You can cause the Syslog routines to drop the reference to IDENT
     and go back to the default string (the program name taken from
     argv[0]), by calling `closelog': *Note closelog::.

     In particular, if you are writing code for a shared library that
     might get loaded and then unloaded (e.g. a PAM module), and you
     use `openlog', you must call `closelog' before any point where
     your library might get unloaded, as in this example:

          #include <syslog.h>

          void
          shared_library_function (void)
          {
            openlog ("mylibrary", option, priority);

            syslog (LOG_INFO, "shared library has been invoked");

            closelog ();
          }

     Without the call to `closelog', future invocations of `syslog' by
     the program using the shared library may crash, if the library gets
     unloaded and the memory containing the string `"mylibrary"' becomes
     unmapped.  This is a limitation of the BSD syslog interface.

     `openlog' may or may not open the `/dev/log' socket, depending on
     OPTION.  If it does, it tries to open it and connect it as a
     stream socket.  If that doesn't work, it tries to open it and
     connect it as a datagram socket.  The socket has the "Close on
     Exec" attribute, so the kernel will close it if the process
     performs an exec.

     You don't have to use `openlog'.  If you call `syslog' without
     having called `openlog', `syslog' just opens the connection
     implicitly and uses defaults for the information in IDENT and
     OPTIONS.

     OPTIONS is a bit string, with the bits as defined by the following
     single bit masks:

    `LOG_PERROR'
          If on, `openlog' sets up the connection so that any `syslog'
          on this connection writes its message to the calling process'
          Standard Error stream in addition to submitting it to Syslog.
          If off, `syslog' does not write the message to Standard
          Error.

    `LOG_CONS'
          If on, `openlog' sets up the connection so that a `syslog' on
          this connection that fails to submit a message to Syslog
          writes the message instead to system console.  If off,
          `syslog' does not write to the system console (but of course
          Syslog may write messages it receives to the console).

    `LOG_PID'
          When on, `openlog' sets up the connection so that a `syslog'
          on this connection inserts the calling process' Process ID
          (PID) into the message.  When off, `openlog' does not insert
          the PID.

    `LOG_NDELAY'
          When on, `openlog' opens and connects the `/dev/log' socket.
          When off, a future `syslog' call must open and connect the
          socket.

          *Portability note:*  In early systems, the sense of this bit
          was exactly the opposite.

    `LOG_ODELAY'
          This bit does nothing.  It exists for backward compatibility.


     If any other bit in OPTIONS is on, the result is undefined.

     FACILITY is the default facility code for this connection.  A
     `syslog' on this connection that specifies default facility causes
     this facility to be associated with the message.  See `syslog' for
     possible values.  A value of zero means the default default, which
     is `LOG_USER'.

     If a Syslog connection is already open when you call `openlog',
     `openlog' "reopens" the connection.  Reopening is like opening
     except that if you specify zero for the default facility code, the
     default facility code simply remains unchanged and if you specify
     LOG_NDELAY and the socket is already open and connected, `openlog'
     just leaves it that way.



File: libc.info,  Node: syslog; vsyslog,  Next: closelog,  Prev: openlog,  Up: Submitting Syslog Messages

18.2.2 syslog, vsyslog
----------------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: void syslog (int FACILITY_PRIORITY, char *FORMAT, ...)
     `syslog' submits a message to the Syslog facility.  It does this by
     writing to the Unix domain socket `/dev/log'.

     `syslog' submits the message with the facility and priority
     indicated by FACILITY_PRIORITY.  The macro `LOG_MAKEPRI' generates
     a facility/priority from a facility and a priority, as in the
     following example:

          LOG_MAKEPRI(LOG_USER, LOG_WARNING)

     The possible values for the facility code are (macros):

    `LOG_USER'
          A miscellaneous user process

    `LOG_MAIL'
          Mail

    `LOG_DAEMON'
          A miscellaneous system daemon

    `LOG_AUTH'
          Security (authorization)

    `LOG_SYSLOG'
          Syslog

    `LOG_LPR'
          Central printer

    `LOG_NEWS'
          Network news (e.g. Usenet)

    `LOG_UUCP'
          UUCP

    `LOG_CRON'
          Cron and At

    `LOG_AUTHPRIV'
          Private security (authorization)

    `LOG_FTP'
          Ftp server

    `LOG_LOCAL0'
          Locally defined

    `LOG_LOCAL1'
          Locally defined

    `LOG_LOCAL2'
          Locally defined

    `LOG_LOCAL3'
          Locally defined

    `LOG_LOCAL4'
          Locally defined

    `LOG_LOCAL5'
          Locally defined

    `LOG_LOCAL6'
          Locally defined

    `LOG_LOCAL7'
          Locally defined

     Results are undefined if the facility code is anything else.

     *NB:* `syslog' recognizes one other facility code: that of the
     kernel.  But you can't specify that facility code with these
     functions.  If you try, it looks the same to `syslog' as if you are
     requesting the default facility.  But you wouldn't want to anyway,
     because any program that uses the GNU C library is not the kernel.

     You can use just a priority code as FACILITY_PRIORITY.  In that
     case, `syslog' assumes the default facility established when the
     Syslog connection was opened.  *Note Syslog Example::.

     The possible values for the priority code are (macros):

    `LOG_EMERG'
          The message says the system is unusable.

    `LOG_ALERT'
          Action on the message must be taken immediately.

    `LOG_CRIT'
          The message states a critical condition.

    `LOG_ERR'
          The message describes an error.

    `LOG_WARNING'
          The message is a warning.

    `LOG_NOTICE'
          The message describes a normal but important event.

    `LOG_INFO'
          The message is purely informational.

    `LOG_DEBUG'
          The message is only for debugging purposes.

     Results are undefined if the priority code is anything else.

     If the process does not presently have a Syslog connection open
     (i.e., it did not call `openlog'), `syslog' implicitly opens the
     connection the same as `openlog' would, with the following defaults
     for information that would otherwise be included in an `openlog'
     call: The default identification string is the program name.  The
     default default facility is `LOG_USER'.  The default for all the
     connection options in OPTIONS is as if those bits were off.
     `syslog' leaves the Syslog connection open.

     If the `dev/log' socket is not open and connected, `syslog' opens
     and connects it, the same as `openlog' with the `LOG_NDELAY'
     option would.

     `syslog' leaves `/dev/log' open and connected unless its attempt
     to send the message failed, in which case `syslog' closes it (with
     the hope that a future implicit open will restore the Syslog
     connection to a usable state).

     Example:


          #include <syslog.h>
          syslog (LOG_MAKEPRI(LOG_LOCAL1, LOG_ERROR),
                  "Unable to make network connection to %s.  Error=%m", host);


 -- Function: void vsyslog (int FACILITY_PRIORITY, char *FORMAT,
          va_list arglist)
     This is functionally identical to `syslog', with the BSD style
     variable length argument.



File: libc.info,  Node: closelog,  Next: setlogmask,  Prev: syslog; vsyslog,  Up: Submitting Syslog Messages

18.2.3 closelog
---------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: void closelog (void)
     `closelog' closes the current Syslog connection, if there is one.
     This includes closing the `dev/log' socket, if it is open.
     `closelog' also sets the identification string for Syslog messages
     back to the default, if `openlog' was called with a non-NULL
     argument to IDENT.  The default identification string is the
     program name taken from argv[0].

     If you are writing shared library code that uses `openlog' to
     generate custom syslog output, you should use `closelog' to drop
     the GNU C library's internal reference to the IDENT pointer when
     you are done.  Please read the section on `openlog' for more
     information: *Note openlog::.

     `closelog' does not flush any buffers.  You do not have to call
     `closelog' before re-opening a Syslog connection with `initlog'.
     Syslog connections are automatically closed on exec or exit.



File: libc.info,  Node: setlogmask,  Next: Syslog Example,  Prev: closelog,  Up: Submitting Syslog Messages

18.2.4 setlogmask
-----------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: int setlogmask (int MASK)
     `setlogmask' sets a mask (the "logmask") that determines which
     future `syslog' calls shall be ignored.  If a program has not
     called `setlogmask', `syslog' doesn't ignore any calls.  You can
     use `setlogmask' to specify that messages of particular priorities
     shall be ignored in the future.

     A `setlogmask' call overrides any previous `setlogmask' call.

     Note that the logmask exists entirely independently of opening and
     closing of Syslog connections.

     Setting the logmask has a similar effect to, but is not the same
     as, configuring Syslog.  The Syslog configuration may cause Syslog
     to discard certain messages it receives, but the logmask causes
     certain messages never to get submitted to Syslog in the first
     place.

     MASK is a bit string with one bit corresponding to each of the
     possible message priorities.  If the bit is on, `syslog' handles
     messages of that priority normally.  If it is off, `syslog'
     discards messages of that priority.  Use the message priority
     macros described in *Note syslog; vsyslog:: and the `LOG_MASK' to
     construct an appropriate MASK value, as in this example:

          LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ERROR)

     or

          ~(LOG_MASK(LOG_INFO))

     There is also a `LOG_UPTO' macro, which generates a mask with the
     bits on for a certain priority and all priorities above it:

          LOG_UPTO(LOG_ERROR)

     The unfortunate naming of the macro is due to the fact that
     internally, higher numbers are used for lower message priorities.



File: libc.info,  Node: Syslog Example,  Prev: setlogmask,  Up: Submitting Syslog Messages

18.2.5 Syslog Example
---------------------

Here is an example of `openlog', `syslog', and `closelog':

   This example sets the logmask so that debug and informational
messages get discarded without ever reaching Syslog.  So the second
`syslog' in the example does nothing.

     #include <syslog.h>

     setlogmask (LOG_UPTO (LOG_NOTICE));

     openlog ("exampleprog", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);

     syslog (LOG_NOTICE, "Program started by User %d", getuid ());
     syslog (LOG_INFO, "A tree falls in a forest");

     closelog ();


File: libc.info,  Node: Mathematics,  Next: Arithmetic,  Prev: Syslog,  Up: Top

19 Mathematics
**************

This chapter contains information about functions for performing
mathematical computations, such as trigonometric functions.  Most of
these functions have prototypes declared in the header file `math.h'.
The complex-valued functions are defined in `complex.h'.  

   All mathematical functions which take a floating-point argument have
three variants, one each for `double', `float', and `long double'
arguments.  The `double' versions are mostly defined in ISO C89.  The
`float' and `long double' versions are from the numeric extensions to C
included in ISO C99.

   Which of the three versions of a function should be used depends on
the situation.  For most calculations, the `float' functions are the
fastest.  On the other hand, the `long double' functions have the
highest precision.  `double' is somewhere in between.  It is usually
wise to pick the narrowest type that can accommodate your data.  Not
all machines have a distinct `long double' type; it may be the same as
`double'.

* Menu:

* Mathematical Constants::      Precise numeric values for often-used
                                 constants.
* Trig Functions::              Sine, cosine, tangent, and friends.
* Inverse Trig Functions::      Arcsine, arccosine, etc.
* Exponents and Logarithms::    Also pow and sqrt.
* Hyperbolic Functions::        sinh, cosh, tanh, etc.
* Special Functions::           Bessel, gamma, erf.
* Errors in Math Functions::    Known Maximum Errors in Math Functions.
* Pseudo-Random Numbers::       Functions for generating pseudo-random
				 numbers.
* FP Function Optimizations::   Fast code or small code.


File: libc.info,  Node: Mathematical Constants,  Next: Trig Functions,  Up: Mathematics

19.1 Predefined Mathematical Constants
======================================

The header `math.h' defines several useful mathematical constants.  All
values are defined as preprocessor macros starting with `M_'.  The
values provided are:

`M_E'
     The base of natural logarithms.

`M_LOG2E'
     The logarithm to base `2' of `M_E'.

`M_LOG10E'
     The logarithm to base `10' of `M_E'.

`M_LN2'
     The natural logarithm of `2'.

`M_LN10'
     The natural logarithm of `10'.

`M_PI'
     Pi, the ratio of a circle's circumference to its diameter.

`M_PI_2'
     Pi divided by two.

`M_PI_4'
     Pi divided by four.

`M_1_PI'
     The reciprocal of pi (1/pi)

`M_2_PI'
     Two times the reciprocal of pi.

`M_2_SQRTPI'
     Two times the reciprocal of the square root of pi.

`M_SQRT2'
     The square root of two.

`M_SQRT1_2'
     The reciprocal of the square root of two (also the square root of
     1/2).

   These constants come from the Unix98 standard and were also
available in 4.4BSD; therefore they are only defined if `_BSD_SOURCE' or
`_XOPEN_SOURCE=500', or a more general feature select macro, is
defined.  The default set of features includes these constants.  *Note
Feature Test Macros::.

   All values are of type `double'.  As an extension, the GNU C library
also defines these constants with type `long double'.  The `long
double' macros have a lowercase `l' appended to their names: `M_El',
`M_PIl', and so forth.  These are only available if `_GNU_SOURCE' is
defined.

   _Note:_ Some programs use a constant named `PI' which has the same
value as `M_PI'.  This constant is not standard; it may have appeared
in some old AT&T headers, and is mentioned in Stroustrup's book on C++.
It infringes on the user's name space, so the GNU C library does not
define it.  Fixing programs written to expect it is simple: replace
`PI' with `M_PI' throughout, or put `-DPI=M_PI' on the compiler command
line.


File: libc.info,  Node: Trig Functions,  Next: Inverse Trig Functions,  Prev: Mathematical Constants,  Up: Mathematics

19.2 Trigonometric Functions
============================

These are the familiar `sin', `cos', and `tan' functions.  The
arguments to all of these functions are in units of radians; recall
that pi radians equals 180 degrees.

   The math library normally defines `M_PI' to a `double' approximation
of pi.  If strict ISO and/or POSIX compliance are requested this
constant is not defined, but you can easily define it yourself:

     #define M_PI 3.14159265358979323846264338327

You can also compute the value of pi with the expression `acos (-1.0)'.

 -- Function: double sin (double X)
 -- Function: float sinf (float X)
 -- Function: long double sinl (long double X)
     These functions return the sine of X, where X is given in radians.
     The return value is in the range `-1' to `1'.

 -- Function: double cos (double X)
 -- Function: float cosf (float X)
 -- Function: long double cosl (long double X)
     These functions return the cosine of X, where X is given in
     radians.  The return value is in the range `-1' to `1'.

 -- Function: double tan (double X)
 -- Function: float tanf (float X)
 -- Function: long double tanl (long double X)
     These functions return the tangent of X, where X is given in
     radians.

     Mathematically, the tangent function has singularities at odd
     multiples of pi/2.  If the argument X is too close to one of these
     singularities, `tan' will signal overflow.

   In many applications where `sin' and `cos' are used, the sine and
cosine of the same angle are needed at the same time.  It is more
efficient to compute them simultaneously, so the library provides a
function to do that.

 -- Function: void sincos (double X, double *SINX, double *COSX)
 -- Function: void sincosf (float X, float *SINX, float *COSX)
 -- Function: void sincosl (long double X, long double *SINX, long
          double *COSX)
     These functions return the sine of X in `*SINX' and the cosine of
     X in `*COS', where X is given in radians.  Both values, `*SINX'
     and `*COSX', are in the range of `-1' to `1'.

     This function is a GNU extension.  Portable programs should be
     prepared to cope with its absence.

   ISO C99 defines variants of the trig functions which work on complex
numbers.  The GNU C library provides these functions, but they are only
useful if your compiler supports the new complex types defined by the
standard.  (As of this writing GCC supports complex numbers, but there
are bugs in the implementation.)

 -- Function: complex double csin (complex double Z)
 -- Function: complex float csinf (complex float Z)
 -- Function: complex long double csinl (complex long double Z)
     These functions return the complex sine of Z.  The mathematical
     definition of the complex sine is

     sin (z) = 1/(2*i) * (exp (z*i) - exp (-z*i)).

 -- Function: complex double ccos (complex double Z)
 -- Function: complex float ccosf (complex float Z)
 -- Function: complex long double ccosl (complex long double Z)
     These functions return the complex cosine of Z.  The mathematical
     definition of the complex cosine is

     cos (z) = 1/2 * (exp (z*i) + exp (-z*i))

 -- Function: complex double ctan (complex double Z)
 -- Function: complex float ctanf (complex float Z)
 -- Function: complex long double ctanl (complex long double Z)
     These functions return the complex tangent of Z.  The mathematical
     definition of the complex tangent is

     tan (z) = -i * (exp (z*i) - exp (-z*i)) / (exp (z*i) + exp (-z*i))

     The complex tangent has poles at pi/2 + 2n, where n is an integer.
     `ctan' may signal overflow if Z is too close to a pole.


File: libc.info,  Node: Inverse Trig Functions,  Next: Exponents and Logarithms,  Prev: Trig Functions,  Up: Mathematics

19.3 Inverse Trigonometric Functions
====================================

These are the usual arc sine, arc cosine and arc tangent functions,
which are the inverses of the sine, cosine and tangent functions
respectively.

 -- Function: double asin (double X)
 -- Function: float asinf (float X)
 -- Function: long double asinl (long double X)
     These functions compute the arc sine of X--that is, the value whose
     sine is X.  The value is in units of radians.  Mathematically,
     there are infinitely many such values; the one actually returned
     is the one between `-pi/2' and `pi/2' (inclusive).

     The arc sine function is defined mathematically only over the
     domain `-1' to `1'.  If X is outside the domain, `asin' signals a
     domain error.

 -- Function: double acos (double X)
 -- Function: float acosf (float X)
 -- Function: long double acosl (long double X)
     These functions compute the arc cosine of X--that is, the value
     whose cosine is X.  The value is in units of radians.
     Mathematically, there are infinitely many such values; the one
     actually returned is the one between `0' and `pi' (inclusive).

     The arc cosine function is defined mathematically only over the
     domain `-1' to `1'.  If X is outside the domain, `acos' signals a
     domain error.

 -- Function: double atan (double X)
 -- Function: float atanf (float X)
 -- Function: long double atanl (long double X)
     These functions compute the arc tangent of X--that is, the value
     whose tangent is X.  The value is in units of radians.
     Mathematically, there are infinitely many such values; the one
     actually returned is the one between `-pi/2' and `pi/2'
     (inclusive).

 -- Function: double atan2 (double Y, double X)
 -- Function: float atan2f (float Y, float X)
 -- Function: long double atan2l (long double Y, long double X)
     This function computes the arc tangent of Y/X, but the signs of
     both arguments are used to determine the quadrant of the result,
     and X is permitted to be zero.  The return value is given in
     radians and is in the range `-pi' to `pi', inclusive.

     If X and Y are coordinates of a point in the plane, `atan2'
     returns the signed angle between the line from the origin to that
     point and the x-axis.  Thus, `atan2' is useful for converting
     Cartesian coordinates to polar coordinates.  (To compute the
     radial coordinate, use `hypot'; see *Note Exponents and
     Logarithms::.)

     If both X and Y are zero, `atan2' returns zero.

   ISO C99 defines complex versions of the inverse trig functions.

 -- Function: complex double casin (complex double Z)
 -- Function: complex float casinf (complex float Z)
 -- Function: complex long double casinl (complex long double Z)
     These functions compute the complex arc sine of Z--that is, the
     value whose sine is Z.  The value returned is in radians.

     Unlike the real-valued functions, `casin' is defined for all
     values of Z.

 -- Function: complex double cacos (complex double Z)
 -- Function: complex float cacosf (complex float Z)
 -- Function: complex long double cacosl (complex long double Z)
     These functions compute the complex arc cosine of Z--that is, the
     value whose cosine is Z.  The value returned is in radians.

     Unlike the real-valued functions, `cacos' is defined for all
     values of Z.

 -- Function: complex double catan (complex double Z)
 -- Function: complex float catanf (complex float Z)
 -- Function: complex long double catanl (complex long double Z)
     These functions compute the complex arc tangent of Z--that is, the
     value whose tangent is Z.  The value is in units of radians.


File: libc.info,  Node: Exponents and Logarithms,  Next: Hyperbolic Functions,  Prev: Inverse Trig Functions,  Up: Mathematics

19.4 Exponentiation and Logarithms
==================================

 -- Function: double exp (double X)
 -- Function: float expf (float X)
 -- Function: long double expl (long double X)
     These functions compute `e' (the base of natural logarithms) raised
     to the power X.

     If the magnitude of the result is too large to be representable,
     `exp' signals overflow.

 -- Function: double exp2 (double X)
 -- Function: float exp2f (float X)
 -- Function: long double exp2l (long double X)
     These functions compute `2' raised to the power X.
     Mathematically, `exp2 (x)' is the same as `exp (x * log (2))'.

 -- Function: double exp10 (double X)
 -- Function: float exp10f (float X)
 -- Function: long double exp10l (long double X)
 -- Function: double pow10 (double X)
 -- Function: float pow10f (float X)
 -- Function: long double pow10l (long double X)
     These functions compute `10' raised to the power X.
     Mathematically, `exp10 (x)' is the same as `exp (x * log (10))'.

     These functions are GNU extensions.  The name `exp10' is
     preferred, since it is analogous to `exp' and `exp2'.

 -- Function: double log (double X)
 -- Function: float logf (float X)
 -- Function: long double logl (long double X)
     These functions compute the natural logarithm of X.  `exp (log
     (X))' equals X, exactly in mathematics and approximately in C.

     If X is negative, `log' signals a domain error.  If X is zero, it
     returns negative infinity; if X is too close to zero, it may
     signal overflow.

 -- Function: double log10 (double X)
 -- Function: float log10f (float X)
 -- Function: long double log10l (long double X)
     These functions return the base-10 logarithm of X.  `log10 (X)'
     equals `log (X) / log (10)'.


 -- Function: double log2 (double X)
 -- Function: float log2f (float X)
 -- Function: long double log2l (long double X)
     These functions return the base-2 logarithm of X.  `log2 (X)'
     equals `log (X) / log (2)'.

 -- Function: double logb (double X)
 -- Function: float logbf (float X)
 -- Function: long double logbl (long double X)
     These functions extract the exponent of X and return it as a
     floating-point value.  If `FLT_RADIX' is two, `logb' is equal to
     `floor (log2 (x))', except it's probably faster.

     If X is de-normalized, `logb' returns the exponent X would have if
     it were normalized.  If X is infinity (positive or negative),
     `logb' returns oo.  If X is zero, `logb' returns oo.  It does not
     signal.

 -- Function: int ilogb (double X)
 -- Function: int ilogbf (float X)
 -- Function: int ilogbl (long double X)
     These functions are equivalent to the corresponding `logb'
     functions except that they return signed integer values.

Since integers cannot represent infinity and NaN, `ilogb' instead
returns an integer that can't be the exponent of a normal floating-point
number.  `math.h' defines constants so you can check for this.

 -- Macro: int FP_ILOGB0
     `ilogb' returns this value if its argument is `0'.  The numeric
     value is either `INT_MIN' or `-INT_MAX'.

     This macro is defined in ISO C99.

 -- Macro: int FP_ILOGBNAN
     `ilogb' returns this value if its argument is `NaN'.  The numeric
     value is either `INT_MIN' or `INT_MAX'.

     This macro is defined in ISO C99.

   These values are system specific.  They might even be the same.  The
proper way to test the result of `ilogb' is as follows:

     i = ilogb (f);
     if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
       {
         if (isnan (f))
           {
             /* Handle NaN.  */
           }
         else if (f  == 0.0)
           {
             /* Handle 0.0.  */
           }
         else
           {
             /* Some other value with large exponent,
                perhaps +Inf.  */
           }
       }

 -- Function: double pow (double BASE, double POWER)
 -- Function: float powf (float BASE, float POWER)
 -- Function: long double powl (long double BASE, long double POWER)
     These are general exponentiation functions, returning BASE raised
     to POWER.

     Mathematically, `pow' would return a complex number when BASE is
     negative and POWER is not an integral value.  `pow' can't do that,
     so instead it signals a domain error. `pow' may also underflow or
     overflow the destination type.

 -- Function: double sqrt (double X)
 -- Function: float sqrtf (float X)
 -- Function: long double sqrtl (long double X)
     These functions return the nonnegative square root of X.

     If X is negative, `sqrt' signals a domain error.  Mathematically,
     it should return a complex number.

 -- Function: double cbrt (double X)
 -- Function: float cbrtf (float X)
 -- Function: long double cbrtl (long double X)
     These functions return the cube root of X.  They cannot fail;
     every representable real value has a representable real cube root.

 -- Function: double hypot (double X, double Y)
 -- Function: float hypotf (float X, float Y)
 -- Function: long double hypotl (long double X, long double Y)
     These functions return `sqrt (X*X + Y*Y)'.  This is the length of
     the hypotenuse of a right triangle with sides of length X and Y,
     or the distance of the point (X, Y) from the origin.  Using this
     function instead of the direct formula is wise, since the error is
     much smaller.  See also the function `cabs' in *Note Absolute
     Value::.

 -- Function: double expm1 (double X)
 -- Function: float expm1f (float X)
 -- Function: long double expm1l (long double X)
     These functions return a value equivalent to `exp (X) - 1'.  They
     are computed in a way that is accurate even if X is near zero--a
     case where `exp (X) - 1' would be inaccurate owing to subtraction
     of two numbers that are nearly equal.

 -- Function: double log1p (double X)
 -- Function: float log1pf (float X)
 -- Function: long double log1pl (long double X)
     These functions returns a value equivalent to `log (1 + X)'.  They
     are computed in a way that is accurate even if X is near zero.

   ISO C99 defines complex variants of some of the exponentiation and
logarithm functions.

 -- Function: complex double cexp (complex double Z)
 -- Function: complex float cexpf (complex float Z)
 -- Function: complex long double cexpl (complex long double Z)
     These functions return `e' (the base of natural logarithms) raised
     to the power of Z.  Mathematically, this corresponds to the value

     exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))

 -- Function: complex double clog (complex double Z)
 -- Function: complex float clogf (complex float Z)
 -- Function: complex long double clogl (complex long double Z)
     These functions return the natural logarithm of Z.
     Mathematically, this corresponds to the value

     log (z) = log (cabs (z)) + I * carg (z)

     `clog' has a pole at 0, and will signal overflow if Z equals or is
     very close to 0.  It is well-defined for all other values of Z.

 -- Function: complex double clog10 (complex double Z)
 -- Function: complex float clog10f (complex float Z)
 -- Function: complex long double clog10l (complex long double Z)
     These functions return the base 10 logarithm of the complex value
     Z. Mathematically, this corresponds to the value

     log (z) = log10 (cabs (z)) + I * carg (z)

     These functions are GNU extensions.

 -- Function: complex double csqrt (complex double Z)
 -- Function: complex float csqrtf (complex float Z)
 -- Function: complex long double csqrtl (complex long double Z)
     These functions return the complex square root of the argument Z.
     Unlike the real-valued functions, they are defined for all values
     of Z.

 -- Function: complex double cpow (complex double BASE, complex double
          POWER)
 -- Function: complex float cpowf (complex float BASE, complex float
          POWER)
 -- Function: complex long double cpowl (complex long double BASE,
          complex long double POWER)
     These functions return BASE raised to the power of POWER.  This is
     equivalent to `cexp (y * clog (x))'


File: libc.info,  Node: Hyperbolic Functions,  Next: Special Functions,  Prev: Exponents and Logarithms,  Up: Mathematics

19.5 Hyperbolic Functions
=========================

The functions in this section are related to the exponential functions;
see *Note Exponents and Logarithms::.

 -- Function: double sinh (double X)
 -- Function: float sinhf (float X)
 -- Function: long double sinhl (long double X)
     These functions return the hyperbolic sine of X, defined
     mathematically as `(exp (X) - exp (-X)) / 2'.  They may signal
     overflow if X is too large.

 -- Function: double cosh (double X)
 -- Function: float coshf (float X)
 -- Function: long double coshl (long double X)
     These function return the hyperbolic cosine of X, defined
     mathematically as `(exp (X) + exp (-X)) / 2'.  They may signal
     overflow if X is too large.

 -- Function: double tanh (double X)
 -- Function: float tanhf (float X)
 -- Function: long double tanhl (long double X)
     These functions return the hyperbolic tangent of X, defined
     mathematically as `sinh (X) / cosh (X)'.  They may signal overflow
     if X is too large.

   There are counterparts for the hyperbolic functions which take
complex arguments.

 -- Function: complex double csinh (complex double Z)
 -- Function: complex float csinhf (complex float Z)
 -- Function: complex long double csinhl (complex long double Z)
     These functions return the complex hyperbolic sine of Z, defined
     mathematically as `(exp (Z) - exp (-Z)) / 2'.

 -- Function: complex double ccosh (complex double Z)
 -- Function: complex float ccoshf (complex float Z)
 -- Function: complex long double ccoshl (complex long double Z)
     These functions return the complex hyperbolic cosine of Z, defined
     mathematically as `(exp (Z) + exp (-Z)) / 2'.

 -- Function: complex double ctanh (complex double Z)
 -- Function: complex float ctanhf (complex float Z)
 -- Function: complex long double ctanhl (complex long double Z)
     These functions return the complex hyperbolic tangent of Z,
     defined mathematically as `csinh (Z) / ccosh (Z)'.

 -- Function: double asinh (double X)
 -- Function: float asinhf (float X)
 -- Function: long double asinhl (long double X)
     These functions return the inverse hyperbolic sine of X--the value
     whose hyperbolic sine is X.

 -- Function: double acosh (double X)
 -- Function: float acoshf (float X)
 -- Function: long double acoshl (long double X)
     These functions return the inverse hyperbolic cosine of X--the
     value whose hyperbolic cosine is X.  If X is less than `1',
     `acosh' signals a domain error.

 -- Function: double atanh (double X)
 -- Function: float atanhf (float X)
 -- Function: long double atanhl (long double X)
     These functions return the inverse hyperbolic tangent of X--the
     value whose hyperbolic tangent is X.  If the absolute value of X
     is greater than `1', `atanh' signals a domain error; if it is
     equal to 1, `atanh' returns infinity.

 -- Function: complex double casinh (complex double Z)
 -- Function: complex float casinhf (complex float Z)
 -- Function: complex long double casinhl (complex long double Z)
     These functions return the inverse complex hyperbolic sine of
     Z--the value whose complex hyperbolic sine is Z.

 -- Function: complex double cacosh (complex double Z)
 -- Function: complex float cacoshf (complex float Z)
 -- Function: complex long double cacoshl (complex long double Z)
     These functions return the inverse complex hyperbolic cosine of
     Z--the value whose complex hyperbolic cosine is Z.  Unlike the
     real-valued functions, there are no restrictions on the value of Z.

 -- Function: complex double catanh (complex double Z)
 -- Function: complex float catanhf (complex float Z)
 -- Function: complex long double catanhl (complex long double Z)
     These functions return the inverse complex hyperbolic tangent of
     Z--the value whose complex hyperbolic tangent is Z.  Unlike the
     real-valued functions, there are no restrictions on the value of Z.


File: libc.info,  Node: Special Functions,  Next: Errors in Math Functions,  Prev: Hyperbolic Functions,  Up: Mathematics

19.6 Special Functions
======================

These are some more exotic mathematical functions which are sometimes
useful.  Currently they only have real-valued versions.

 -- Function: double erf (double X)
 -- Function: float erff (float X)
 -- Function: long double erfl (long double X)
     `erf' returns the error function of X.  The error function is
     defined as
          erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt

 -- Function: double erfc (double X)
 -- Function: float erfcf (float X)
 -- Function: long double erfcl (long double X)
     `erfc' returns `1.0 - erf(X)', but computed in a fashion that
     avoids round-off error when X is large.

 -- Function: double lgamma (double X)
 -- Function: float lgammaf (float X)
 -- Function: long double lgammal (long double X)
     `lgamma' returns the natural logarithm of the absolute value of
     the gamma function of X.  The gamma function is defined as
          gamma (x) = integral from 0 to oo of t^(x-1) e^-t dt

     The sign of the gamma function is stored in the global variable
     SIGNGAM, which is declared in `math.h'.  It is `1' if the
     intermediate result was positive or zero, or `-1' if it was
     negative.

     To compute the real gamma function you can use the `tgamma'
     function or you can compute the values as follows:
          lgam = lgamma(x);
          gam  = signgam*exp(lgam);

     The gamma function has singularities at the non-positive integers.
     `lgamma' will raise the zero divide exception if evaluated at a
     singularity.

 -- Function: double lgamma_r (double X, int *SIGNP)
 -- Function: float lgammaf_r (float X, int *SIGNP)
 -- Function: long double lgammal_r (long double X, int *SIGNP)
     `lgamma_r' is just like `lgamma', but it stores the sign of the
     intermediate result in the variable pointed to by SIGNP instead of
     in the SIGNGAM global.  This means it is reentrant.

 -- Function: double gamma (double X)
 -- Function: float gammaf (float X)
 -- Function: long double gammal (long double X)
     These functions exist for compatibility reasons.  They are
     equivalent to `lgamma' etc.  It is better to use `lgamma' since
     for one the name reflects better the actual computation, moreover
     `lgamma' is standardized in ISO C99 while `gamma' is not.

 -- Function: double tgamma (double X)
 -- Function: float tgammaf (float X)
 -- Function: long double tgammal (long double X)
     `tgamma' applies the gamma function to X.  The gamma function is
     defined as
          gamma (x) = integral from 0 to oo of t^(x-1) e^-t dt

     This function was introduced in ISO C99.

 -- Function: double j0 (double X)
 -- Function: float j0f (float X)
 -- Function: long double j0l (long double X)
     `j0' returns the Bessel function of the first kind of order 0 of
     X.  It may signal underflow if X is too large.

 -- Function: double j1 (double X)
 -- Function: float j1f (float X)
 -- Function: long double j1l (long double X)
     `j1' returns the Bessel function of the first kind of order 1 of
     X.  It may signal underflow if X is too large.

 -- Function: double jn (int n, double X)
 -- Function: float jnf (int n, float X)
 -- Function: long double jnl (int n, long double X)
     `jn' returns the Bessel function of the first kind of order N of
     X.  It may signal underflow if X is too large.

 -- Function: double y0 (double X)
 -- Function: float y0f (float X)
 -- Function: long double y0l (long double X)
     `y0' returns the Bessel function of the second kind of order 0 of
     X.  It may signal underflow if X is too large.  If X is negative,
     `y0' signals a domain error; if it is zero, `y0' signals overflow
     and returns -oo.

 -- Function: double y1 (double X)
 -- Function: float y1f (float X)
 -- Function: long double y1l (long double X)
     `y1' returns the Bessel function of the second kind of order 1 of
     X.  It may signal underflow if X is too large.  If X is negative,
     `y1' signals a domain error; if it is zero, `y1' signals overflow
     and returns -oo.

 -- Function: double yn (int n, double X)
 -- Function: float ynf (int n, float X)
 -- Function: long double ynl (int n, long double X)
     `yn' returns the Bessel function of the second kind of order N of
     X.  It may signal underflow if X is too large.  If X is negative,
     `yn' signals a domain error; if it is zero, `yn' signals overflow
     and returns -oo.


File: libc.info,  Node: Errors in Math Functions,  Next: Pseudo-Random Numbers,  Prev: Special Functions,  Up: Mathematics

19.7 Known Maximum Errors in Math Functions
===========================================

This section lists the known errors of the functions in the math
library.  Errors are measured in "units of the last place".  This is a
measure for the relative error.  For a number z with the representation
d.d...d*2^e (we assume IEEE floating-point numbers with base 2) the ULP
is represented by

     |d.d...d - (z / 2^e)| / 2^(p - 1)

where p is the number of bits in the mantissa of the floating-point
number representation.  Ideally the error for all functions is always
less than 0.5ulps.  Using rounding bits this is also possible and
normally implemented for the basic operations.  To achieve the same for
the complex math functions requires a lot more work and this has not
yet been done.

   Therefore many of the functions in the math library have errors.  The
table lists the maximum error for each function which is exposed by one
of the existing tests in the test suite.  The table tries to cover as
much as possible and list the actual maximum error (or at least a
ballpark figure) but this is often not achieved due to the large search
space.

   The table lists the ULP values for different architectures.
Different architectures have different results since their hardware
support for floating-point operations varies and also the existing
hardware support is different.

Function      Generic         ix86            IA64            PowerPC         S/390
acosf         -               -               -               -               -
acos          -               -               -               -               -
acosl         -               622             -               1               -
acoshf        -               -               -               -               -
acosh         -               -               -               -               -
acoshl        -               -               -               1               -
asinf         -               -               -               -               -
asin          -               -               -               -               -
asinl         -               1               -               2               -
asinhf        -               -               -               -               -
asinh         -               -               -               -               -
asinhl        -               -               -               1               -
atanf         -               -               -               -               -
atan          -               -               -               -               -
atanl         -               -               -               -               -
atanhf        -               -               -               1               1
atanh         -               -               -               -               -
atanhl        -               1               -               -               -
atan2f        -               -               -               1               1
atan2         -               -               -               -               -
atan2l        -               -               -               1               1
cabsf         -               -               -               -               -
cabs          -               -               -               -               -
cabsl         -               -               -               1               -
cacosf        -               0 + i 1         0 + i 1         -               -
cacos         -               -               -               -               -
cacosl        -               0 + i 2         0 + i 2         1 + i 1         0 + i 1
cacoshf       -               9 + i 4         7 + i 0         7 + i 3         7 + i 3
cacosh        -               1 + i 1         1 + i 1         1 + i 1         1 + i 1
cacoshl       -               6 + i 1         7 + i 1         1 + i 0         0 + i 1
cargf         -               -               -               -               -
carg          -               -               -               -               -
cargl         -               -               -               -               -
casinf        -               1 + i 1         1 + i 1         1 + i 0         1 + i 0
casin         -               1 + i 0         1 + i 0         1 + i 0         1 + i 0
casinl        -               2 + i 2         2 + i 2         1 + i 1         0 + i 1
casinhf       -               1 + i 6         1 + i 6         1 + i 6         1 + i 6
casinh        -               5 + i 3         5 + i 3         5 + i 3         5 + i 3
casinhl       -               5 + i 5         5 + i 5         4 + i 1         4 + i 2
catanf        -               0 + i 1         0 + i 1         4 + i 1         4 + i 1
catan         -               0 + i 1         0 + i 1         0 + i 1         0 + i 1
catanl        -               -               -               1 + i 1         0 + i 1
catanhf       -               1 + i 0         -               0 + i 6         0 + i 6
catanh        -               2 + i 0         4 + i 0         4 + i 0         4 + i 0
catanhl       -               1 + i 0         1 + i 0         -               1 + i 1
cbrtf         -               -               -               -               -
cbrt          -               -               -               1               1
cbrtl         -               1               -               1               1
ccosf         -               0 + i 1         0 + i 1         1 + i 1         1 + i 1
ccos          -               1 + i 0         1 + i 0         1 + i 0         1 + i 0
ccosl         -               1 + i 1         1 + i 1         1 + i 1         1 + i 1
ccoshf        -               1 + i 1         1 + i 1         1 + i 1         1 + i 1
ccosh         -               1 + i 1         1 + i 1         1 + i 0         1 + i 0
ccoshl        -               0 + i 1         0 + i 1         1 + i 2         1 + i 1
ceilf         -               -               -               -               -
ceil          -               -               -               -               -
ceill         -               -               -               -               -
cexpf         -               -               1 + i 1         1 + i 1         1 + i 1
cexp          -               -               -               -               -
cexpl         -               1 + i 1         0 + i 1         2 + i 1         1 + i 1
cimagf        -               -               -               -               -
cimag         -               -               -               -               -
cimagl        -               -               -               -               -
clogf         -               1 + i 0         1 + i 0         1 + i 3         1 + i 3
clog          -               -               -               -               -
clogl         -               1 + i 0         1 + i 0         2 + i 1         1 + i 0
clog10f       -               1 + i 1         1 + i 1         1 + i 5         1 + i 5
clog10        -               1 + i 1         1 + i 1         0 + i 1         0 + i 1
clog10l       -               1 + i 1         1 + i 1         3 + i 1         1 + i 1
conjf         -               -               -               -               -
conj          -               -               -               -               -
conjl         -               -               -               -               -
copysignf     -               -               -               -               -
copysign      -               -               -               -               -
copysignl     -               -               -               -               -
cosf          -               1               1               1               1
cos           -               2               2               2               2
cosl          -               1               1               1               1
coshf         -               -               -               -               -
cosh          -               -               -               -               -
coshl         -               -               -               1               -
cpowf         -               4 + i 3         5 + i 3         5 + i 2         4 + i 2
cpow          -               1 + i 2         2 + i 2         2 + i 2         2 + i 2
cpowl         -               763 + i 2       6 + i 4         2 + i 2         10 + i 1
cprojf        -               -               -               -               -
cproj         -               -               -               -               -
cprojl        -               -               -               0 + i 1         -
crealf        -               -               -               -               -
creal         -               -               -               -               -
creall        -               -               -               -               -
csinf         -               1 + i 1         1 + i 1         -               -
csin          -               -               -               -               -
csinl         -               1 + i 0         1 + i 0         1 + i 0         1 + i 1
csinhf        -               1 + i 1         1 + i 1         1 + i 1         1 + i 1
csinh         -               1 + i 1         1 + i 1         0 + i 1         0 + i 1
csinhl        -               1 + i 2         1 + i 2         1 + i 1         1 + i 0
csqrtf        -               -               1 + i 0         1 + i 0         1 + i 0
csqrt         -               -               -               -               -
csqrtl        -               -               -               1 + i 1         1 + i 1
ctanf         -               0 + i 1         0 + i 1         -               -
ctan          -               1 + i 1         1 + i 1         1 + i 1         1 + i 1
ctanl         -               439 + i 3       2 + i 1         1 + i 1         1 + i 2
ctanhf        -               1 + i 1         0 + i 1         2 + i 1         2 + i 1
ctanh         -               1 + i 1         1 + i 1         1 + i 0         1 + i 0
ctanhl        -               5 + i 25        1 + i 24        1 + i 1         1 + i 1
erff          -               -               -               -               -
erf           -               1               1               1               1
erfl          -               -               -               1               -
erfcf         -               1               1               1               1
erfc          -               1               1               1               1
erfcl         -               1               1               1               1
expf          -               -               -               -               -
exp           -               -               -               -               -
expl          -               -               -               1               -
exp10f        -               -               2               2               2
exp10         -               -               6               6               6
exp10l        -               8               3               8               1
exp2f         -               -               -               -               -
exp2          -               -               -               -               -
exp2l         -               -               -               2               2
expm1f        -               -               -               1               1
expm1         -               -               -               1               1
expm1l        -               -               1               -               1
fabsf         -               -               -               -               -
fabs          -               -               -               -               -
fabsl         -               -               -               -               -
fdimf         -               -               -               -               -
fdim          -               -               -               -               -
fdiml         -               -               -               -               -
floorf        -               -               -               -               -
floor         -               -               -               -               -
floorl        -               -               -               -               -
fmaf          -               -               -               -               -
fma           -               -               -               -               -
fmal          -               -               -               -               -
fmaxf         -               -               -               -               -
fmax          -               -               -               -               -
fmaxl         -               -               -               -               -
fminf         -               -               -               -               -
fmin          -               -               -               -               -
fminl         -               -               -               -               -
fmodf         -               -               -               -               -
fmod          -               -               -               -               -
fmodl         -               -               -               -               -
frexpf        -               -               -               -               -
frexp         -               -               -               -               -
frexpl        -               -               -               -               -
gammaf        -               -               -               -               -
gamma         -               1               -               -               -
gammal        -               1               1               1               1
hypotf        -               1               1               1               1
hypot         -               -               -               -               -
hypotl        -               -               -               1               -
ilogbf        -               -               -               -               -
ilogb         -               -               -               -               -
ilogbl        -               -               -               -               -
j0f           -               2               2               2               2
j0            -               3               3               3               3
j0l           -               1               2               1               2
j1f           -               1               2               2               2
j1            -               1               1               1               1
j1l           -               1               1               1               4
jnf           -               2               4               4               4
jn            -               5               3               3               4
jnl           -               2               2               4               4
lgammaf       -               2               2               2               2
lgamma        -               1               1               1               1
lgammal       -               1               1               3               1
lrintf        -               -               -               -               -
lrint         -               -               -               -               -
lrintl        -               -               -               -               -
llrintf       -               -               -               -               -
llrint        -               -               -               -               -
llrintl       -               -               -               -               -
logf          -               1               1               -               -
log           -               -               -               -               -
logl          -               -               -               1               -
log10f        -               1               1               2               2
log10         -               -               -               1               1
log10l        -               1               1               1               1
log1pf        -               -               -               1               1
log1p         -               -               -               -               -
log1pl        -               -               -               1               1
log2f         -               -               -               -               -
log2          -               -               -               -               -
log2l         -               -               -               1               1
logbf         -               -               -               -               -
logb          -               -               -               -               -
logbl         -               -               -               -               -
lroundf       -               -               -               -               -
lround        -               -               -               -               -
lroundl       -               -               -               -               -
llroundf      -               -               -               -               -
llround       -               -               -               -               -
llroundl      -               -               -               -               -
modff         -               -               -               -               -
modf          -               -               -               -               -
modfl         -               -               -               -               -
nearbyintf    -               -               -               -               -
nearbyint     -               -               -               -               -
nearbyintl    -               -               -               -               -
nextafterf    -               -               -               -               -
nextafter     -               -               -               -               -
nextafterl    -               -               -               -               -
nexttowardf   -               -               -               -               -
nexttoward    -               -               -               -               -
nexttowardl   -               -               -               -               -
powf          -               -               -               -               -
pow           -               -               -               -               -
powl          -               -               -               1               -
remainderf    -               -               -               -               -
remainder     -               -               -               -               -
remainderl    -               -               -               -               -
remquof       -               -               -               -               -
remquo        -               -               -               -               -
remquol       -               -               -               -               -
rintf         -               -               -               -               -
rint          -               -               -               -               -
rintl         -               -               -               -               -
roundf        -               -               -               -               -
round         -               -               -               -               -
roundl        -               -               -               -               -
scalbf        -               -               -               -               -
scalb         -               -               -               -               -
scalbl        -               -               -               -               -
scalbnf       -               -               -               -               -
scalbn        -               -               -               -               -
scalbnl       -               -               -               -               -
scalblnf      -               -               -               -               -
scalbln       -               -               -               -               -
scalblnl      -               -               -               -               -
sinf          -               -               -               -               -
sin           -               -               -               -               -
sinl          -               -               -               1               -
sincosf       -               1               1               1               1
sincos        -               1               1               1               1
sincosl       -               1               1               1               1
sinhf         -               -               -               -               -
sinh          -               1               -               -               -
sinhl         -               -               -               1               -
sqrtf         -               -               -               -               -
sqrt          -               -               -               -               -
sqrtl         -               -               -               -               1
tanf          -               -               -               -               -
tan           -               1               1               1               1
tanl          -               -               -               1               -
tanhf         -               -               -               -               -
tanh          -               -               -               -               -
tanhl         -               -               -               1               1
tgammaf       -               1               1               1               1
tgamma        -               2               1               1               1
tgammal       -               1               1               1               1
truncf        -               -               -               -               -
trunc         -               -               -               -               -
truncl        -               -               -               -               -
y0f           -               1               1               1               1
y0            -               2               2               2               2
y0l           -               1               1               1               3
y1f           -               2               2               2               2
y1            -               2               3               3               3
y1l           -               1               1               2               1
ynf           -               3               2               2               2
yn            -               2               3               3               3
ynl           -               4               2               2               5

Function      SH4             Sparc 32-bit    Sparc 64-bit    x86_64/fpu
acosf         -               -               -               -
acos          -               -               -               -
acosl         -               -               -               1
acoshf        -               -               -               -
acosh         -               -               -               -
acoshl        -               -               -               -
asinf         2               -               -               -
asin          1               -               -               -
asinl         -               -               -               1
asinhf        -               -               -               -
asinh         -               -               -               -
asinhl        -               -               -               -
atanf         -               -               -               -
atan          -               -               -               -
atanl         -               -               -               -
atanhf        -               1               1               1
atanh         1               -               -               -
atanhl        -               -               -               1
atan2f        4               6               6               1
atan2         -               -               -               -
atan2l        -               1               1               -
cabsf         1               -               -               -
cabs          1               -               -               -
cabsl         -               -               -               -
cacosf        1 + i 1         -               -               0 + i 1
cacos         1 + i 0         -               -               -
cacosl        -               0 + i 1         0 + i 1         0 + i 2
cacoshf       7 + i 3         7 + i 3         7 + i 3         7 + i 3
cacosh        1 + i 1         1 + i 1         1 + i 1         1 + i 1
cacoshl       -               5 + i 1         5 + i 1         6 + i 1
cargf         -               -               -               -
carg          -               -               -               -
cargl         -               -               -               -
casinf        2 + i 1         1 + i 0         1 + i 0         1 + i 1
casin         3 + i 0         1 + i 0         1 + i 0         1 + i 0
casinl        -               0 + i 1         0 + i 1         2 + i 2
casinhf       1 + i 6         1 + i 6         1 + i 6         1 + i 6
casinh        5 + i 3         5 + i 3         5 + i 3         5 + i 3
casinhl       -               4 + i 2         4 + i 2         5 + i 5
catanf        4 + i 1         4 + i 1         4 + i 1         4 + i 1
catan         0 + i 1         0 + i 1         0 + i 1         0 + i 1
catanl        -               0 + i 1         0 + i 1         -
catanhf       1 + i 6         0 + i 6         0 + i 6         0 + i 6
catanh        4 + i 1         4 + i 0         4 + i 0         4 + i 0
catanhl       -               1 + i 1         1 + i 1         1 + i 0
cbrtf         -               -               -               -
cbrt          1               1               1               1
cbrtl         -               1               1               1
ccosf         0 + i 1         1 + i 1         1 + i 1         1 + i 1
ccos          1 + i 1         1 + i 0         1 + i 0         1 + i 0
ccosl         -               1 + i 1         1 + i 1         1 + i 1
ccoshf        1 + i 1         1 + i 1         1 + i 1         1 + i 1
ccosh         1 + i 1         1 + i 0         1 + i 0         1 + i 1
ccoshl        -               1 + i 1         1 + i 1         0 + i 1
ceilf         -               -               -               -
ceil          -               -               -               -
ceill         -               -               -               -
cexpf         1 + i 1         1 + i 1         1 + i 1         1 + i 1
cexp          1 + i 0         -               -               -
cexpl         -               1 + i 1         1 + i 1         0 + i 1
cimagf        -               -               -               -
cimag         -               -               -               -
cimagl        -               -               -               -
clogf         0 + i 3         1 + i 3         1 + i 3         1 + i 3
clog          0 + i 1         -               -               -
clogl         -               1 + i 0         1 + i 0         1 + i 0
clog10f       1 + i 5         1 + i 5         1 + i 5         1 + i 5
clog10        1 + i 1         0 + i 1         0 + i 1         1 + i 1
clog10l       -               1 + i 1         1 + i 1         1 + i 1
conjf         -               -               -               -
conj          -               -               -               -
conjl         -               -               -               -
copysignf     -               -               -               -
copysign      -               -               -               -
copysignl     -               -               -               -
cosf          1               1               1               1
cos           2               2               2               2
cosl          -               1               1               1
coshf         -               -               -               -
cosh          -               -               -               -
coshl         -               -               -               -
cpowf         4 + i 2         4 + i 2         4 + i 2         5 + i 2
cpow          1 + i 1.1031    2 + i 2         2 + i 2         2 + i 2
cpowl         -               10 + i 1        10 + i 1        5 + i 2
cprojf        -               -               -               -
cproj         -               -               -               -
cprojl        -               -               -               -
crealf        -               -               -               -
creal         -               -               -               -
creall        -               -               -               -
csinf         0 + i 1         -               -               0 + i 1
csin          -               -               -               0 + i 1
csinl         -               1 + i 1         1 + i 1         1 + i 0
csinhf        1 + i 1         1 + i 1         1 + i 1         1 + i 1
csinh         0 + i 1         0 + i 1         0 + i 1         1 + i 1
csinhl        -               1 + i 0         1 + i 0         1 + i 2
csqrtf        1 + i 1         1 + i 0         1 + i 0         1 + i 0
csqrt         1 + i 0         -               -               -
csqrtl        -               1 + i 1         1 + i 1         -
ctanf         1 + i 1         -               -               0 + i 1
ctan          1 + i 1         1 + i 1         1 + i 1         1 + i 1
ctanl         -               1 + i 2         1 + i 2         439 + i 3
ctanhf        2 + i 1         2 + i 1         2 + i 1         2 + i 1
ctanh         2 + i 2         1 + i 0         1 + i 0         1 + i 1
ctanhl        -               1 + i 1         1 + i 1         5 + i 25
erff          -               -               -               -
erf           -               1               1               1
erfl          -               -               -               -
erfcf         12              -               -               -
erfc          24              1               1               1
erfcl         -               1               1               1
expf          -               -               -               -
exp           -               -               -               -
expl          -               -               -               -
exp10f        2               2               2               2
exp10         6               6               6               6
exp10l        -               1               1               8
exp2f         -               -               -               -
exp2          -               -               -               -
exp2l         -               2               2               -
expm1f        1               1               1               1
expm1         -               1               1               1
expm1l        -               1               1               -
fabsf         -               -               -               -
fabs          -               -               -               -
fabsl         -               -               -               -
fdimf         -               -               -               -
fdim          -               -               -               -
fdiml         -               -               -               -
floorf        -               -               -               -
floor         -               -               -               -
floorl        -               -               -               -
fmaf          -               -               -               -
fma           -               -               -               -
fmal          -               -               -               -
fmaxf         -               -               -               -
fmax          -               -               -               -
fmaxl         -               -               -               -
fminf         -               -               -               -
fmin          -               -               -               -
fminl         -               -               -               -
fmodf         1               -               -               -
fmod          2               -               -               -
fmodl         -               -               -               -
frexpf        -               -               -               -
frexp         -               -               -               -
frexpl        -               -               -               -
gammaf        -               -               -               -
gamma         -               -               -               -
gammal        -               1               1               1
hypotf        1               1               1               1
hypot         1               -               -               -
hypotl        -               -               -               -
ilogbf        -               -               -               -
ilogb         -               -               -               -
ilogbl        -               -               -               -
j0f           2               2               2               2
j0            2               2               2               2
j0l           -               2               2               1
j1f           2               2               2               2
j1            1               1               1               1
j1l           -               4               4               1
jnf           4               4               4               4
jn            6               4               4               4
jnl           -               4               4               2
lgammaf       2               2               2               2
lgamma        1               1               1               1
lgammal       -               1               1               1
lrintf        -               -               -               -
lrint         -               -               -               -
lrintl        -               -               -               -
llrintf       -               -               -               -
llrint        -               -               -               -
llrintl       -               -               -               -
logf          1               -               -               -
log           1               -               -               -
logl          -               -               -               -
log10f        1               2               2               2
log10         1               1               1               1
log10l        -               1               1               1
log1pf        1               1               1               1
log1p         1               -               -               -
log1pl        -               1               1               -
log2f         1               -               -               -
log2          1               -               -               -
log2l         -               1               1               -
logbf         -               -               -               -
logb          -               -               -               -
logbl         -               -               -               -
lroundf       -               -               -               -
lround        -               -               -               -
lroundl       -               -               -               -
llroundf      -               -               -               -
llround       -               -               -               -
llroundl      -               -               -               -
modff         -               -               -               -
modf          -               -               -               -
modfl         -               -               -               -
nearbyintf    -               -               -               -
nearbyint     -               -               -               -
nearbyintl    -               -               -               -
nextafterf    -               -               -               -
nextafter     -               -               -               -
nextafterl    -               -               -               -
nexttowardf   -               -               -               -
nexttoward    -               -               -               -
nexttowardl   -               -               -               -
powf          -               -               -               -
pow           -               -               -               -
powl          -               -               -               -
remainderf    -               -               -               -
remainder     -               -               -               -
remainderl    -               -               -               -
remquof       -               -               -               -
remquo        -               -               -               -
remquol       -               -               -               -
rintf         -               -               -               -
rint          -               -               -               -
rintl         -               -               -               -
roundf        -               -               -               -
round         -               -               -               -
roundl        -               -               -               -
scalbf        -               -               -               -
scalb         -               -               -               -
scalbl        -               -               -               -
scalbnf       -               -               -               -
scalbn        -               -               -               -
scalbnl       -               -               -               -
scalblnf      -               -               -               -
scalbln       -               -               -               -
scalblnl      -               -               -               -
sinf          -               -               -               -
sin           -               -               -               -
sinl          -               -               -               -
sincosf       1               1               1               1
sincos        1               1               1               1
sincosl       -               1               1               1
sinhf         1               -               -               -
sinh          1               -               -               -
sinhl         -               -               -               -
sqrtf         -               -               -               -
sqrt          -               -               -               -
sqrtl         -               1               1               -
tanf          -               -               -               -
tan           0.5             1               1               1
tanl          -               -               -               -
tanhf         1               -               -               -
tanh          1               -               -               -
tanhl         -               1               1               -
tgammaf       1               1               1               1
tgamma        1               1               1               1
tgammal       -               1               1               1
truncf        -               -               -               -
trunc         -               -               -               -
truncl        -               -               -               -
y0f           1               1               1               1
y0            2               2               2               2
y0l           -               3               3               1
y1f           2               2               2               2
y1            3               3               3               3
y1l           -               1               1               1
ynf           2               2               2               2
yn            3               3               3               3
ynl           -               5               5               4


File: libc.info,  Node: Pseudo-Random Numbers,  Next: FP Function Optimizations,  Prev: Errors in Math Functions,  Up: Mathematics

19.8 Pseudo-Random Numbers
==========================

This section describes the GNU facilities for generating a series of
pseudo-random numbers.  The numbers generated are not truly random;
typically, they form a sequence that repeats periodically, with a period
so large that you can ignore it for ordinary purposes.  The random
number generator works by remembering a "seed" value which it uses to
compute the next random number and also to compute a new seed.

   Although the generated numbers look unpredictable within one run of a
program, the sequence of numbers is _exactly the same_ from one run to
the next.  This is because the initial seed is always the same.  This
is convenient when you are debugging a program, but it is unhelpful if
you want the program to behave unpredictably.  If you want a different
pseudo-random series each time your program runs, you must specify a
different seed each time.  For ordinary purposes, basing the seed on the
current time works well.

   You can obtain repeatable sequences of numbers on a particular
machine type by specifying the same initial seed value for the random
number generator.  There is no standard meaning for a particular seed
value; the same seed, used in different C libraries or on different CPU
types, will give you different random numbers.

   The GNU library supports the standard ISO C random number functions
plus two other sets derived from BSD and SVID.  The BSD and ISO C
functions provide identical, somewhat limited functionality.  If only a
small number of random bits are required, we recommend you use the
ISO C interface, `rand' and `srand'.  The SVID functions provide a more
flexible interface, which allows better random number generator
algorithms, provides more random bits (up to 48) per call, and can
provide random floating-point numbers.  These functions are required by
the XPG standard and therefore will be present in all modern Unix
systems.

* Menu:

* ISO Random::                  `rand' and friends.
* BSD Random::                  `random' and friends.
* SVID Random::                 `drand48' and friends.


File: libc.info,  Node: ISO Random,  Next: BSD Random,  Up: Pseudo-Random Numbers

19.8.1 ISO C Random Number Functions
------------------------------------

This section describes the random number functions that are part of the
ISO C standard.

   To use these facilities, you should include the header file
`stdlib.h' in your program.  

 -- Macro: int RAND_MAX
     The value of this macro is an integer constant representing the
     largest value the `rand' function can return.  In the GNU library,
     it is `2147483647', which is the largest signed integer
     representable in 32 bits.  In other libraries, it may be as low as
     `32767'.

 -- Function: int rand (void)
     The `rand' function returns the next pseudo-random number in the
     series.  The value ranges from `0' to `RAND_MAX'.

 -- Function: void srand (unsigned int SEED)
     This function establishes SEED as the seed for a new series of
     pseudo-random numbers.  If you call `rand' before a seed has been
     established with `srand', it uses the value `1' as a default seed.

     To produce a different pseudo-random series each time your program
     is run, do `srand (time (0))'.

   POSIX.1 extended the C standard functions to support reproducible
random numbers in multi-threaded programs.  However, the extension is
badly designed and unsuitable for serious work.

 -- Function: int rand_r (unsigned int *SEED)
     This function returns a random number in the range 0 to `RAND_MAX'
     just as `rand' does.  However, all its state is stored in the SEED
     argument.  This means the RNG's state can only have as many bits
     as the type `unsigned int' has.  This is far too few to provide a
     good RNG.

     If your program requires a reentrant RNG, we recommend you use the
     reentrant GNU extensions to the SVID random number generator.  The
     POSIX.1 interface should only be used when the GNU extensions are
     not available.


File: libc.info,  Node: BSD Random,  Next: SVID Random,  Prev: ISO Random,  Up: Pseudo-Random Numbers

19.8.2 BSD Random Number Functions
----------------------------------

This section describes a set of random number generation functions that
are derived from BSD.  There is no advantage to using these functions
with the GNU C library; we support them for BSD compatibility only.

   The prototypes for these functions are in `stdlib.h'.  

 -- Function: long int random (void)
     This function returns the next pseudo-random number in the
     sequence.  The value returned ranges from `0' to `RAND_MAX'.

     *NB:* Temporarily this function was defined to return a `int32_t'
     value to indicate that the return value always contains 32 bits
     even if `long int' is wider.  The standard demands it differently.
     Users must always be aware of the 32-bit limitation, though.

 -- Function: void srandom (unsigned int SEED)
     The `srandom' function sets the state of the random number
     generator based on the integer SEED.  If you supply a SEED value
     of `1', this will cause `random' to reproduce the default set of
     random numbers.

     To produce a different set of pseudo-random numbers each time your
     program runs, do `srandom (time (0))'.

 -- Function: void * initstate (unsigned int SEED, void *STATE, size_t
          SIZE)
     The `initstate' function is used to initialize the random number
     generator state.  The argument STATE is an array of SIZE bytes,
     used to hold the state information.  It is initialized based on
     SEED.  The size must be between 8 and 256 bytes, and should be a
     power of two.  The bigger the STATE array, the better.

     The return value is the previous value of the state information
     array.  You can use this value later as an argument to `setstate'
     to restore that state.

 -- Function: void * setstate (void *STATE)
     The `setstate' function restores the random number state
     information STATE.  The argument must have been the result of a
     previous call to INITSTATE or SETSTATE.

     The return value is the previous value of the state information
     array.  You can use this value later as an argument to `setstate'
     to restore that state.

     If the function fails the return value is `NULL'.

   The four functions described so far in this section all work on a
state which is shared by all threads.  The state is not directly
accessible to the user and can only be modified by these functions.
This makes it hard to deal with situations where each thread should
have its own pseudo-random number generator.

   The GNU C library contains four additional functions which contain
the state as an explicit parameter and therefore make it possible to
handle thread-local PRNGs.  Beside this there is no difference.  In
fact, the four functions already discussed are implemented internally
using the following interfaces.

   The `stdlib.h' header contains a definition of the following type:

 -- Data Type: struct random_data
     Objects of type `struct random_data' contain the information
     necessary to represent the state of the PRNG.  Although a complete
     definition of the type is present the type should be treated as
     opaque.

   The functions modifying the state follow exactly the already
described functions.

 -- Function: int random_r (struct random_data *restrict BUF, int32_t
          *restrict RESULT)
     The `random_r' function behaves exactly like the `random' function
     except that it uses and modifies the state in the object pointed
     to by the first parameter instead of the global state.

 -- Function: int srandom_r (unsigned int SEED, struct random_data *BUF)
     The `srandom_r' function behaves exactly like the `srandom'
     function except that it uses and modifies the state in the object
     pointed to by the second parameter instead of the global state.

 -- Function: int initstate_r (unsigned int SEED, char *restrict
          STATEBUF, size_t STATELEN, struct random_data *restrict BUF)
     The `initstate_r' function behaves exactly like the `initstate'
     function except that it uses and modifies the state in the object
     pointed to by the fourth parameter instead of the global state.

 -- Function: int setstate_r (char *restrict STATEBUF, struct
          random_data *restrict BUF)
     The `setstate_r' function behaves exactly like the `setstate'
     function except that it uses and modifies the state in the object
     pointed to by the first parameter instead of the global state.


File: libc.info,  Node: SVID Random,  Prev: BSD Random,  Up: Pseudo-Random Numbers

19.8.3 SVID Random Number Function
----------------------------------

The C library on SVID systems contains yet another kind of random number
generator functions.  They use a state of 48 bits of data.  The user can
choose among a collection of functions which return the random bits in
different forms.

   Generally there are two kinds of function.  The first uses a state of
the random number generator which is shared among several functions and
by all threads of the process.  The second requires the user to handle
the state.

   All functions have in common that they use the same congruential
formula with the same constants.  The formula is

     Y = (a * X + c) mod m

where X is the state of the generator at the beginning and Y the state
at the end.  `a' and `c' are constants determining the way the
generator works.  By default they are

     a = 0x5DEECE66D = 25214903917
     c = 0xb = 11

but they can also be changed by the user.  `m' is of course 2^48 since
the state consists of a 48-bit array.

   The prototypes for these functions are in `stdlib.h'.  

 -- Function: double drand48 (void)
     This function returns a `double' value in the range of `0.0' to
     `1.0' (exclusive).  The random bits are determined by the global
     state of the random number generator in the C library.

     Since the `double' type according to IEEE 754 has a 52-bit
     mantissa this means 4 bits are not initialized by the random number
     generator.  These are (of course) chosen to be the least
     significant bits and they are initialized to `0'.

 -- Function: double erand48 (unsigned short int XSUBI[3])
     This function returns a `double' value in the range of `0.0' to
     `1.0' (exclusive), similarly to `drand48'.  The argument is an
     array describing the state of the random number generator.

     This function can be called subsequently since it updates the
     array to guarantee random numbers.  The array should have been
     initialized before initial use to obtain reproducible results.

 -- Function: long int lrand48 (void)
     The `lrand48' function returns an integer value in the range of
     `0' to `2^31' (exclusive).  Even if the size of the `long int'
     type can take more than 32 bits, no higher numbers are returned.
     The random bits are determined by the global state of the random
     number generator in the C library.

 -- Function: long int nrand48 (unsigned short int XSUBI[3])
     This function is similar to the `lrand48' function in that it
     returns a number in the range of `0' to `2^31' (exclusive) but the
     state of the random number generator used to produce the random
     bits is determined by the array provided as the parameter to the
     function.

     The numbers in the array are updated afterwards so that subsequent
     calls to this function yield different results (as is expected of
     a random number generator).  The array should have been
     initialized before the first call to obtain reproducible results.

 -- Function: long int mrand48 (void)
     The `mrand48' function is similar to `lrand48'.  The only
     difference is that the numbers returned are in the range `-2^31' to
     `2^31' (exclusive).

 -- Function: long int jrand48 (unsigned short int XSUBI[3])
     The `jrand48' function is similar to `nrand48'.  The only
     difference is that the numbers returned are in the range `-2^31' to
     `2^31' (exclusive).  For the `xsubi' parameter the same
     requirements are necessary.

   The internal state of the random number generator can be initialized
in several ways.  The methods differ in the completeness of the
information provided.

 -- Function: void srand48 (long int SEEDVAL)
     The `srand48' function sets the most significant 32 bits of the
     internal state of the random number generator to the least
     significant 32 bits of the SEEDVAL parameter.  The lower 16 bits
     are initialized to the value `0x330E'.  Even if the `long int'
     type contains more than 32 bits only the lower 32 bits are used.

     Owing to this limitation, initialization of the state of this
     function is not very useful.  But it makes it easy to use a
     construct like `srand48 (time (0))'.

     A side-effect of this function is that the values `a' and `c' from
     the internal state, which are used in the congruential formula,
     are reset to the default values given above.  This is of
     importance once the user has called the `lcong48' function (see
     below).

 -- Function: unsigned short int * seed48 (unsigned short int
          SEED16V[3])
     The `seed48' function initializes all 48 bits of the state of the
     internal random number generator from the contents of the parameter
     SEED16V.  Here the lower 16 bits of the first element of SEE16V
     initialize the least significant 16 bits of the internal state,
     the lower 16 bits of `SEED16V[1]' initialize the mid-order 16 bits
     of the state and the 16 lower bits of `SEED16V[2]' initialize the
     most significant 16 bits of the state.

     Unlike `srand48' this function lets the user initialize all 48 bits
     of the state.

     The value returned by `seed48' is a pointer to an array containing
     the values of the internal state before the change.  This might be
     useful to restart the random number generator at a certain state.
     Otherwise the value can simply be ignored.

     As for `srand48', the values `a' and `c' from the congruential
     formula are reset to the default values.

   There is one more function to initialize the random number generator
which enables you to specify even more information by allowing you to
change the parameters in the congruential formula.

 -- Function: void lcong48 (unsigned short int PARAM[7])
     The `lcong48' function allows the user to change the complete state
     of the random number generator.  Unlike `srand48' and `seed48',
     this function also changes the constants in the congruential
     formula.

     From the seven elements in the array PARAM the least significant
     16 bits of the entries `PARAM[0]' to `PARAM[2]' determine the
     initial state, the least significant 16 bits of `PARAM[3]' to
     `PARAM[5]' determine the 48 bit constant `a' and `PARAM[6]'
     determines the 16-bit value `c'.

   All the above functions have in common that they use the global
parameters for the congruential formula.  In multi-threaded programs it
might sometimes be useful to have different parameters in different
threads.  For this reason all the above functions have a counterpart
which works on a description of the random number generator in the
user-supplied buffer instead of the global state.

   Please note that it is no problem if several threads use the global
state if all threads use the functions which take a pointer to an array
containing the state.  The random numbers are computed following the
same loop but if the state in the array is different all threads will
obtain an individual random number generator.

   The user-supplied buffer must be of type `struct drand48_data'.
This type should be regarded as opaque and not manipulated directly.

 -- Function: int drand48_r (struct drand48_data *BUFFER, double
          *RESULT)
     This function is equivalent to the `drand48' function with the
     difference that it does not modify the global random number
     generator parameters but instead the parameters in the buffer
     supplied through the pointer BUFFER.  The random number is
     returned in the variable pointed to by RESULT.

     The return value of the function indicates whether the call
     succeeded.  If the value is less than `0' an error occurred and
     ERRNO is set to indicate the problem.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int erand48_r (unsigned short int XSUBI[3], struct
          drand48_data *BUFFER, double *RESULT)
     The `erand48_r' function works like `erand48', but in addition it
     takes an argument BUFFER which describes the random number
     generator.  The state of the random number generator is taken from
     the `xsubi' array, the parameters for the congruential formula
     from the global random number generator data.  The random number
     is returned in the variable pointed to by RESULT.

     The return value is non-negative if the call succeeded.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int lrand48_r (struct drand48_data *BUFFER, double
          *RESULT)
     This function is similar to `lrand48', but in addition it takes a
     pointer to a buffer describing the state of the random number
     generator just like `drand48'.

     If the return value of the function is non-negative the variable
     pointed to by RESULT contains the result.  Otherwise an error
     occurred.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int nrand48_r (unsigned short int XSUBI[3], struct
          drand48_data *BUFFER, long int *RESULT)
     The `nrand48_r' function works like `nrand48' in that it produces
     a random number in the range `0' to `2^31'.  But instead of using
     the global parameters for the congruential formula it uses the
     information from the buffer pointed to by BUFFER.  The state is
     described by the values in XSUBI.

     If the return value is non-negative the variable pointed to by
     RESULT contains the result.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int mrand48_r (struct drand48_data *BUFFER, double
          *RESULT)
     This function is similar to `mrand48' but like the other reentrant
     functions it uses the random number generator described by the
     value in the buffer pointed to by BUFFER.

     If the return value is non-negative the variable pointed to by
     RESULT contains the result.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int jrand48_r (unsigned short int XSUBI[3], struct
          drand48_data *BUFFER, long int *RESULT)
     The `jrand48_r' function is similar to `jrand48'.  Like the other
     reentrant functions of this function family it uses the
     congruential formula parameters from the buffer pointed to by
     BUFFER.

     If the return value is non-negative the variable pointed to by
     RESULT contains the result.

     This function is a GNU extension and should not be used in portable
     programs.

   Before any of the above functions are used the buffer of type
`struct drand48_data' should be initialized.  The easiest way to do
this is to fill the whole buffer with null bytes, e.g. by

     memset (buffer, '\0', sizeof (struct drand48_data));

Using any of the reentrant functions of this family now will
automatically initialize the random number generator to the default
values for the state and the parameters of the congruential formula.

   The other possibility is to use any of the functions which explicitly
initialize the buffer.  Though it might be obvious how to initialize the
buffer from looking at the parameter to the function, it is highly
recommended to use these functions since the result might not always be
what you expect.

 -- Function: int srand48_r (long int SEEDVAL, struct drand48_data
          *BUFFER)
     The description of the random number generator represented by the
     information in BUFFER is initialized similarly to what the function
     `srand48' does.  The state is initialized from the parameter
     SEEDVAL and the parameters for the congruential formula are
     initialized to their default values.

     If the return value is non-negative the function call succeeded.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int seed48_r (unsigned short int SEED16V[3], struct
          drand48_data *BUFFER)
     This function is similar to `srand48_r' but like `seed48' it
     initializes all 48 bits of the state from the parameter SEED16V.

     If the return value is non-negative the function call succeeded.
     It does not return a pointer to the previous state of the random
     number generator like the `seed48' function does.  If the user
     wants to preserve the state for a later re-run s/he can copy the
     whole buffer pointed to by BUFFER.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int lcong48_r (unsigned short int PARAM[7], struct
          drand48_data *BUFFER)
     This function initializes all aspects of the random number
     generator described in BUFFER with the data in PARAM.  Here it is
     especially true that the function does more than just copying the
     contents of PARAM and BUFFER.  More work is required and therefore
     it is important to use this function rather than initializing the
     random number generator directly.

     If the return value is non-negative the function call succeeded.

     This function is a GNU extension and should not be used in portable
     programs.


File: libc.info,  Node: FP Function Optimizations,  Prev: Pseudo-Random Numbers,  Up: Mathematics

19.9 Is Fast Code or Small Code preferred?
==========================================

If an application uses many floating point functions it is often the
case that the cost of the function calls themselves is not negligible.
Modern processors can often execute the operations themselves very
fast, but the function call disrupts the instruction pipeline.

   For this reason the GNU C Library provides optimizations for many of
the frequently-used math functions.  When GNU CC is used and the user
activates the optimizer, several new inline functions and macros are
defined.  These new functions and macros have the same names as the
library functions and so are used instead of the latter.  In the case of
inline functions the compiler will decide whether it is reasonable to
use them, and this decision is usually correct.

   This means that no calls to the library functions may be necessary,
and can increase the speed of generated code significantly.  The
drawback is that code size will increase, and the increase is not
always negligible.

   There are two kind of inline functions: Those that give the same
result as the library functions and others that might not set `errno'
and might have a reduced precision and/or argument range in comparison
with the library functions.  The latter inline functions are only
available if the flag `-ffast-math' is given to GNU CC.

   In cases where the inline functions and macros are not wanted the
symbol `__NO_MATH_INLINES' should be defined before any system header is
included.  This will ensure that only library functions are used.  Of
course, it can be determined for each file in the project whether
giving this option is preferable or not.

   Not all hardware implements the entire IEEE 754 standard, and even
if it does there may be a substantial performance penalty for using some
of its features.  For example, enabling traps on some processors forces
the FPU to run un-pipelined, which can more than double calculation
time.


File: libc.info,  Node: Arithmetic,  Next: Date and Time,  Prev: Mathematics,  Up: Top

20 Arithmetic Functions
***********************

This chapter contains information about functions for doing basic
arithmetic operations, such as splitting a float into its integer and
fractional parts or retrieving the imaginary part of a complex value.
These functions are declared in the header files `math.h' and
`complex.h'.

* Menu:

* Integers::                    Basic integer types and concepts
* Integer Division::            Integer division with guaranteed rounding.
* Floating Point Numbers::      Basic concepts.  IEEE 754.
* Floating Point Classes::      The five kinds of floating-point number.
* Floating Point Errors::       When something goes wrong in a calculation.
* Rounding::                    Controlling how results are rounded.
* Control Functions::           Saving and restoring the FPU's state.
* Arithmetic Functions::        Fundamental operations provided by the library.
* Complex Numbers::             The types.  Writing complex constants.
* Operations on Complex::       Projection, conjugation, decomposition.
* Parsing of Numbers::          Converting strings to numbers.
* System V Number Conversion::  An archaic way to convert numbers to strings.


File: libc.info,  Node: Integers,  Next: Integer Division,  Up: Arithmetic

20.1 Integers
=============

The C language defines several integer data types: integer, short
integer, long integer, and character, all in both signed and unsigned
varieties.  The GNU C compiler extends the language to contain long
long integers as well.  

   The C integer types were intended to allow code to be portable among
machines with different inherent data sizes (word sizes), so each type
may have different ranges on different machines.  The problem with this
is that a program often needs to be written for a particular range of
integers, and sometimes must be written for a particular size of
storage, regardless of what machine the program runs on.

   To address this problem, the GNU C library contains C type
definitions you can use to declare integers that meet your exact needs.
Because the GNU C library header files are customized to a specific
machine, your program source code doesn't have to be.

   These `typedef's are in `stdint.h'.  

   If you require that an integer be represented in exactly N bits, use
one of the following types, with the obvious mapping to bit size and
signedness:

   * int8_t

   * int16_t

   * int32_t

   * int64_t

   * uint8_t

   * uint16_t

   * uint32_t

   * uint64_t

   If your C compiler and target machine do not allow integers of a
certain size, the corresponding above type does not exist.

   If you don't need a specific storage size, but want the smallest data
structure with _at least_ N bits, use one of these:

   * int_least8_t

   * int_least16_t

   * int_least32_t

   * int_least64_t

   * uint_least8_t

   * uint_least16_t

   * uint_least32_t

   * uint_least64_t

   If you don't need a specific storage size, but want the data
structure that allows the fastest access while having at least N bits
(and among data structures with the same access speed, the smallest
one), use one of these:

   * int_fast8_t

   * int_fast16_t

   * int_fast32_t

   * int_fast64_t

   * uint_fast8_t

   * uint_fast16_t

   * uint_fast32_t

   * uint_fast64_t

   If you want an integer with the widest range possible on the
platform on which it is being used, use one of the following.  If you
use these, you should write code that takes into account the variable
size and range of the integer.

   * intmax_t

   * uintmax_t

   The GNU C library also provides macros that tell you the maximum and
minimum possible values for each integer data type.  The macro names
follow these examples: `INT32_MAX', `UINT8_MAX', `INT_FAST32_MIN',
`INT_LEAST64_MIN', `UINTMAX_MAX', `INTMAX_MAX', `INTMAX_MIN'.  Note
that there are no macros for unsigned integer minima.  These are always
zero.  

   There are similar macros for use with C's built in integer types
which should come with your C compiler.  These are described in *Note
Data Type Measurements::.

   Don't forget you can use the C `sizeof' function with any of these
data types to get the number of bytes of storage each uses.


File: libc.info,  Node: Integer Division,  Next: Floating Point Numbers,  Prev: Integers,  Up: Arithmetic

20.2 Integer Division
=====================

This section describes functions for performing integer division.  These
functions are redundant when GNU CC is used, because in GNU C the `/'
operator always rounds towards zero.  But in other C implementations,
`/' may round differently with negative arguments.  `div' and `ldiv'
are useful because they specify how to round the quotient: towards
zero.  The remainder has the same sign as the numerator.

   These functions are specified to return a result R such that the
value `R.quot*DENOMINATOR + R.rem' equals NUMERATOR.

   To use these facilities, you should include the header file
`stdlib.h' in your program.

 -- Data Type: div_t
     This is a structure type used to hold the result returned by the
     `div' function.  It has the following members:

    `int quot'
          The quotient from the division.

    `int rem'
          The remainder from the division.

 -- Function: div_t div (int NUMERATOR, int DENOMINATOR)
     This function `div' computes the quotient and remainder from the
     division of NUMERATOR by DENOMINATOR, returning the result in a
     structure of type `div_t'.

     If the result cannot be represented (as in a division by zero), the
     behavior is undefined.

     Here is an example, albeit not a very useful one.

          div_t result;
          result = div (20, -6);

     Now `result.quot' is `-3' and `result.rem' is `2'.

 -- Data Type: ldiv_t
     This is a structure type used to hold the result returned by the
     `ldiv' function.  It has the following members:

    `long int quot'
          The quotient from the division.

    `long int rem'
          The remainder from the division.

     (This is identical to `div_t' except that the components are of
     type `long int' rather than `int'.)

 -- Function: ldiv_t ldiv (long int NUMERATOR, long int DENOMINATOR)
     The `ldiv' function is similar to `div', except that the arguments
     are of type `long int' and the result is returned as a structure
     of type `ldiv_t'.

 -- Data Type: lldiv_t
     This is a structure type used to hold the result returned by the
     `lldiv' function.  It has the following members:

    `long long int quot'
          The quotient from the division.

    `long long int rem'
          The remainder from the division.

     (This is identical to `div_t' except that the components are of
     type `long long int' rather than `int'.)

 -- Function: lldiv_t lldiv (long long int NUMERATOR, long long int
          DENOMINATOR)
     The `lldiv' function is like the `div' function, but the arguments
     are of type `long long int' and the result is returned as a
     structure of type `lldiv_t'.

     The `lldiv' function was added in ISO C99.

 -- Data Type: imaxdiv_t
     This is a structure type used to hold the result returned by the
     `imaxdiv' function.  It has the following members:

    `intmax_t quot'
          The quotient from the division.

    `intmax_t rem'
          The remainder from the division.

     (This is identical to `div_t' except that the components are of
     type `intmax_t' rather than `int'.)

     See *Note Integers:: for a description of the `intmax_t' type.


 -- Function: imaxdiv_t imaxdiv (intmax_t NUMERATOR, intmax_t
          DENOMINATOR)
     The `imaxdiv' function is like the `div' function, but the
     arguments are of type `intmax_t' and the result is returned as a
     structure of type `imaxdiv_t'.

     See *Note Integers:: for a description of the `intmax_t' type.

     The `imaxdiv' function was added in ISO C99.


File: libc.info,  Node: Floating Point Numbers,  Next: Floating Point Classes,  Prev: Integer Division,  Up: Arithmetic

20.3 Floating Point Numbers
===========================

Most computer hardware has support for two different kinds of numbers:
integers (...-3, -2, -1, 0, 1, 2, 3...) and floating-point numbers.
Floating-point numbers have three parts: the "mantissa", the
"exponent", and the "sign bit".  The real number represented by a
floating-point value is given by (s ? -1 : 1) * 2^e * M where s is the
sign bit, e the exponent, and M the mantissa.  *Note Floating Point
Concepts::, for details.  (It is possible to have a different "base"
for the exponent, but all modern hardware uses 2.)

   Floating-point numbers can represent a finite subset of the real
numbers.  While this subset is large enough for most purposes, it is
important to remember that the only reals that can be represented
exactly are rational numbers that have a terminating binary expansion
shorter than the width of the mantissa.  Even simple fractions such as
1/5 can only be approximated by floating point.

   Mathematical operations and functions frequently need to produce
values that are not representable.  Often these values can be
approximated closely enough for practical purposes, but sometimes they
can't.  Historically there was no way to tell when the results of a
calculation were inaccurate.  Modern computers implement the IEEE 754
standard for numerical computations, which defines a framework for
indicating to the program when the results of calculation are not
trustworthy.  This framework consists of a set of "exceptions" that
indicate why a result could not be represented, and the special values
"infinity" and "not a number" (NaN).


File: libc.info,  Node: Floating Point Classes,  Next: Floating Point Errors,  Prev: Floating Point Numbers,  Up: Arithmetic

20.4 Floating-Point Number Classification Functions
===================================================

ISO C99 defines macros that let you determine what sort of
floating-point number a variable holds.

 -- Macro: int fpclassify (_float-type_ X)
     This is a generic macro which works on all floating-point types and
     which returns a value of type `int'.  The possible values are:

    `FP_NAN'
          The floating-point number X is "Not a Number" (*note Infinity
          and NaN::)

    `FP_INFINITE'
          The value of X is either plus or minus infinity (*note
          Infinity and NaN::)

    `FP_ZERO'
          The value of X is zero.  In floating-point formats like
          IEEE 754, where zero can be signed, this value is also
          returned if X is negative zero.

    `FP_SUBNORMAL'
          Numbers whose absolute value is too small to be represented
          in the normal format are represented in an alternate,
          "denormalized" format (*note Floating Point Concepts::).
          This format is less precise but can represent values closer
          to zero.  `fpclassify' returns this value for values of X in
          this alternate format.

    `FP_NORMAL'
          This value is returned for all other values of X.  It
          indicates that there is nothing special about the number.


   `fpclassify' is most useful if more than one property of a number
must be tested.  There are more specific macros which only test one
property at a time.  Generally these macros execute faster than
`fpclassify', since there is special hardware support for them.  You
should therefore use the specific macros whenever possible.

 -- Macro: int isfinite (_float-type_ X)
     This macro returns a nonzero value if X is finite: not plus or
     minus infinity, and not NaN.  It is equivalent to

          (fpclassify (x) != FP_NAN && fpclassify (x) != FP_INFINITE)

     `isfinite' is implemented as a macro which accepts any
     floating-point type.

 -- Macro: int isnormal (_float-type_ X)
     This macro returns a nonzero value if X is finite and normalized.
     It is equivalent to

          (fpclassify (x) == FP_NORMAL)

 -- Macro: int isnan (_float-type_ X)
     This macro returns a nonzero value if X is NaN.  It is equivalent
     to

          (fpclassify (x) == FP_NAN)

   Another set of floating-point classification functions was provided
by BSD.  The GNU C library also supports these functions; however, we
recommend that you use the ISO C99 macros in new code.  Those are
standard and will be available more widely.  Also, since they are
macros, you do not have to worry about the type of their argument.

 -- Function: int isinf (double X)
 -- Function: int isinff (float X)
 -- Function: int isinfl (long double X)
     This function returns `-1' if X represents negative infinity, `1'
     if X represents positive infinity, and `0' otherwise.

 -- Function: int isnan (double X)
 -- Function: int isnanf (float X)
 -- Function: int isnanl (long double X)
     This function returns a nonzero value if X is a "not a number"
     value, and zero otherwise.

     *NB:* The `isnan' macro defined by ISO C99 overrides the BSD
     function.  This is normally not a problem, because the two
     routines behave identically.  However, if you really need to get
     the BSD function for some reason, you can write

          (isnan) (x)

 -- Function: int finite (double X)
 -- Function: int finitef (float X)
 -- Function: int finitel (long double X)
     This function returns a nonzero value if X is finite or a "not a
     number" value, and zero otherwise.

   *Portability Note:* The functions listed in this section are BSD
extensions.


File: libc.info,  Node: Floating Point Errors,  Next: Rounding,  Prev: Floating Point Classes,  Up: Arithmetic

20.5 Errors in Floating-Point Calculations
==========================================

* Menu:

* FP Exceptions::               IEEE 754 math exceptions and how to detect them.
* Infinity and NaN::            Special values returned by calculations.
* Status bit operations::       Checking for exceptions after the fact.
* Math Error Reporting::        How the math functions report errors.


File: libc.info,  Node: FP Exceptions,  Next: Infinity and NaN,  Up: Floating Point Errors

20.5.1 FP Exceptions
--------------------

The IEEE 754 standard defines five "exceptions" that can occur during a
calculation.  Each corresponds to a particular sort of error, such as
overflow.

   When exceptions occur (when exceptions are "raised", in the language
of the standard), one of two things can happen.  By default the
exception is simply noted in the floating-point "status word", and the
program continues as if nothing had happened.  The operation produces a
default value, which depends on the exception (see the table below).
Your program can check the status word to find out which exceptions
happened.

   Alternatively, you can enable "traps" for exceptions.  In that case,
when an exception is raised, your program will receive the `SIGFPE'
signal.  The default action for this signal is to terminate the
program.  *Note Signal Handling::, for how you can change the effect of
the signal.

   In the System V math library, the user-defined function `matherr' is
called when certain exceptions occur inside math library functions.
However, the Unix98 standard deprecates this interface.  We support it
for historical compatibility, but recommend that you do not use it in
new programs.

The exceptions defined in IEEE 754 are:

`Invalid Operation'
     This exception is raised if the given operands are invalid for the
     operation to be performed.  Examples are (see IEEE 754, section 7):
       1. Addition or subtraction: oo - oo.  (But oo + oo = oo).

       2. Multiplication: 0 * oo.

       3. Division: 0/0 or oo/oo.

       4. Remainder: x REM y, where y is zero or x is infinite.

       5. Square root if the operand is less then zero.  More
          generally, any mathematical function evaluated outside its
          domain produces this exception.

       6. Conversion of a floating-point number to an integer or decimal
          string, when the number cannot be represented in the target
          format (due to overflow, infinity, or NaN).

       7. Conversion of an unrecognizable input string.

       8. Comparison via predicates involving < or >, when one or other
          of the operands is NaN.  You can prevent this exception by
          using the unordered comparison functions instead; see *Note
          FP Comparison Functions::.

     If the exception does not trap, the result of the operation is NaN.

`Division by Zero'
     This exception is raised when a finite nonzero number is divided
     by zero.  If no trap occurs the result is either +oo or -oo,
     depending on the signs of the operands.

`Overflow'
     This exception is raised whenever the result cannot be represented
     as a finite value in the precision format of the destination.  If
     no trap occurs the result depends on the sign of the intermediate
     result and the current rounding mode (IEEE 754, section 7.3):
       1. Round to nearest carries all overflows to oo with the sign of
          the intermediate result.

       2. Round toward 0 carries all overflows to the largest
          representable finite number with the sign of the intermediate
          result.

       3. Round toward -oo carries positive overflows to the largest
          representable finite number and negative overflows to -oo.

       4. Round toward oo carries negative overflows to the most
          negative representable finite number and positive overflows
          to oo.

     Whenever the overflow exception is raised, the inexact exception
     is also raised.

`Underflow'
     The underflow exception is raised when an intermediate result is
     too small to be calculated accurately, or if the operation's
     result rounded to the destination precision is too small to be
     normalized.

     When no trap is installed for the underflow exception, underflow is
     signaled (via the underflow flag) only when both tininess and loss
     of accuracy have been detected.  If no trap handler is installed
     the operation continues with an imprecise small value, or zero if
     the destination precision cannot hold the small exact result.

`Inexact'
     This exception is signalled if a rounded result is not exact (such
     as when calculating the square root of two) or a result overflows
     without an overflow trap.


File: libc.info,  Node: Infinity and NaN,  Next: Status bit operations,  Prev: FP Exceptions,  Up: Floating Point Errors

20.5.2 Infinity and NaN
-----------------------

IEEE 754 floating point numbers can represent positive or negative
infinity, and "NaN" (not a number).  These three values arise from
calculations whose result is undefined or cannot be represented
accurately.  You can also deliberately set a floating-point variable to
any of them, which is sometimes useful.  Some examples of calculations
that produce infinity or NaN:

     1/0 = oo
     log (0) = -oo
     sqrt (-1) = NaN

   When a calculation produces any of these values, an exception also
occurs; see *Note FP Exceptions::.

   The basic operations and math functions all accept infinity and NaN
and produce sensible output.  Infinities propagate through calculations
as one would expect: for example, 2 + oo = oo, 4/oo = 0, atan (oo) =
pi/2.  NaN, on the other hand, infects any calculation that involves
it.  Unless the calculation would produce the same result no matter
what real value replaced NaN, the result is NaN.

   In comparison operations, positive infinity is larger than all values
except itself and NaN, and negative infinity is smaller than all values
except itself and NaN.  NaN is "unordered": it is not equal to, greater
than, or less than anything, _including itself_. `x == x' is false if
the value of `x' is NaN.  You can use this to test whether a value is
NaN or not, but the recommended way to test for NaN is with the `isnan'
function (*note Floating Point Classes::).  In addition, `<', `>',
`<=', and `>=' will raise an exception when applied to NaNs.

   `math.h' defines macros that allow you to explicitly set a variable
to infinity or NaN.

 -- Macro: float INFINITY
     An expression representing positive infinity.  It is equal to the
     value produced  by mathematical operations like `1.0 / 0.0'.
     `-INFINITY' represents negative infinity.

     You can test whether a floating-point value is infinite by
     comparing it to this macro.  However, this is not recommended; you
     should use the `isfinite' macro instead.  *Note Floating Point
     Classes::.

     This macro was introduced in the ISO C99 standard.

 -- Macro: float NAN
     An expression representing a value which is "not a number".  This
     macro is a GNU extension, available only on machines that support
     the "not a number" value--that is to say, on all machines that
     support IEEE floating point.

     You can use `#ifdef NAN' to test whether the machine supports NaN.
     (Of course, you must arrange for GNU extensions to be visible,
     such as by defining `_GNU_SOURCE', and then you must include
     `math.h'.)

   IEEE 754 also allows for another unusual value: negative zero.  This
value is produced when you divide a positive number by negative
infinity, or when a negative result is smaller than the limits of
representation.  Negative zero behaves identically to zero in all
calculations, unless you explicitly test the sign bit with `signbit' or
`copysign'.


File: libc.info,  Node: Status bit operations,  Next: Math Error Reporting,  Prev: Infinity and NaN,  Up: Floating Point Errors

20.5.3 Examining the FPU status word
------------------------------------

ISO C99 defines functions to query and manipulate the floating-point
status word.  You can use these functions to check for untrapped
exceptions when it's convenient, rather than worrying about them in the
middle of a calculation.

   These constants represent the various IEEE 754 exceptions.  Not all
FPUs report all the different exceptions.  Each constant is defined if
and only if the FPU you are compiling for supports that exception, so
you can test for FPU support with `#ifdef'.  They are defined in
`fenv.h'.

`FE_INEXACT'
     The inexact exception.

`FE_DIVBYZERO'
     The divide by zero exception.

`FE_UNDERFLOW'
     The underflow exception.

`FE_OVERFLOW'
     The overflow exception.

`FE_INVALID'
     The invalid exception.

   The macro `FE_ALL_EXCEPT' is the bitwise OR of all exception macros
which are supported by the FP implementation.

   These functions allow you to clear exception flags, test for
exceptions, and save and restore the set of exceptions flagged.

 -- Function: int feclearexcept (int EXCEPTS)
     This function clears all of the supported exception flags
     indicated by EXCEPTS.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int feraiseexcept (int EXCEPTS)
     This function raises the supported exceptions indicated by
     EXCEPTS.  If more than one exception bit in EXCEPTS is set the
     order in which the exceptions are raised is undefined except that
     overflow (`FE_OVERFLOW') or underflow (`FE_UNDERFLOW') are raised
     before inexact (`FE_INEXACT').  Whether for overflow or underflow
     the inexact exception is also raised is also implementation
     dependent.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int fetestexcept (int EXCEPTS)
     Test whether the exception flags indicated by the parameter EXCEPT
     are currently set.  If any of them are, a nonzero value is returned
     which specifies which exceptions are set.  Otherwise the result is
     zero.

   To understand these functions, imagine that the status word is an
integer variable named STATUS.  `feclearexcept' is then equivalent to
`status &= ~excepts' and `fetestexcept' is equivalent to `(status &
excepts)'.  The actual implementation may be very different, of course.

   Exception flags are only cleared when the program explicitly
requests it, by calling `feclearexcept'.  If you want to check for
exceptions from a set of calculations, you should clear all the flags
first.  Here is a simple example of the way to use `fetestexcept':

     {
       double f;
       int raised;
       feclearexcept (FE_ALL_EXCEPT);
       f = compute ();
       raised = fetestexcept (FE_OVERFLOW | FE_INVALID);
       if (raised & FE_OVERFLOW) { /* ... */ }
       if (raised & FE_INVALID) { /* ... */ }
       /* ... */
     }

   You cannot explicitly set bits in the status word.  You can, however,
save the entire status word and restore it later.  This is done with the
following functions:

 -- Function: int fegetexceptflag (fexcept_t *FLAGP, int EXCEPTS)
     This function stores in the variable pointed to by FLAGP an
     implementation-defined value representing the current setting of
     the exception flags indicated by EXCEPTS.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int fesetexceptflag (const fexcept_t *FLAGP, int EXCEPTS)
     This function restores the flags for the exceptions indicated by
     EXCEPTS to the values stored in the variable pointed to by FLAGP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

   Note that the value stored in `fexcept_t' bears no resemblance to
the bit mask returned by `fetestexcept'.  The type may not even be an
integer.  Do not attempt to modify an `fexcept_t' variable.


File: libc.info,  Node: Math Error Reporting,  Prev: Status bit operations,  Up: Floating Point Errors

20.5.4 Error Reporting by Mathematical Functions
------------------------------------------------

Many of the math functions are defined only over a subset of the real or
complex numbers.  Even if they are mathematically defined, their result
may be larger or smaller than the range representable by their return
type.  These are known as "domain errors", "overflows", and
"underflows", respectively.  Math functions do several things when one
of these errors occurs.  In this manual we will refer to the complete
response as "signalling" a domain error, overflow, or underflow.

   When a math function suffers a domain error, it raises the invalid
exception and returns NaN.  It also sets ERRNO to `EDOM'; this is for
compatibility with old systems that do not support IEEE 754 exception
handling.  Likewise, when overflow occurs, math functions raise the
overflow exception and return oo or -oo as appropriate.  They also set
ERRNO to `ERANGE'.  When underflow occurs, the underflow exception is
raised, and zero (appropriately signed) is returned.  ERRNO may be set
to `ERANGE', but this is not guaranteed.

   Some of the math functions are defined mathematically to result in a
complex value over parts of their domains.  The most familiar example of
this is taking the square root of a negative number.  The complex math
functions, such as `csqrt', will return the appropriate complex value
in this case.  The real-valued functions, such as `sqrt', will signal a
domain error.

   Some older hardware does not support infinities.  On that hardware,
overflows instead return a particular very large number (usually the
largest representable number).  `math.h' defines macros you can use to
test for overflow on both old and new hardware.

 -- Macro: double HUGE_VAL
 -- Macro: float HUGE_VALF
 -- Macro: long double HUGE_VALL
     An expression representing a particular very large number.  On
     machines that use IEEE 754 floating point format, `HUGE_VAL' is
     infinity.  On other machines, it's typically the largest positive
     number that can be represented.

     Mathematical functions return the appropriately typed version of
     `HUGE_VAL' or `-HUGE_VAL' when the result is too large to be
     represented.


File: libc.info,  Node: Rounding,  Next: Control Functions,  Prev: Floating Point Errors,  Up: Arithmetic

20.6 Rounding Modes
===================

Floating-point calculations are carried out internally with extra
precision, and then rounded to fit into the destination type.  This
ensures that results are as precise as the input data.  IEEE 754
defines four possible rounding modes:

Round to nearest.
     This is the default mode.  It should be used unless there is a
     specific need for one of the others.  In this mode results are
     rounded to the nearest representable value.  If the result is
     midway between two representable values, the even representable is
     chosen. "Even" here means the lowest-order bit is zero.  This
     rounding mode prevents statistical bias and guarantees numeric
     stability: round-off errors in a lengthy calculation will remain
     smaller than half of `FLT_EPSILON'.

Round toward plus Infinity.
     All results are rounded to the smallest representable value which
     is greater than the result.

Round toward minus Infinity.
     All results are rounded to the largest representable value which
     is less than the result.

Round toward zero.
     All results are rounded to the largest representable value whose
     magnitude is less than that of the result.  In other words, if the
     result is negative it is rounded up; if it is positive, it is
     rounded down.

`fenv.h' defines constants which you can use to refer to the various
rounding modes.  Each one will be defined if and only if the FPU
supports the corresponding rounding mode.

`FE_TONEAREST'
     Round to nearest.

`FE_UPWARD'
     Round toward +oo.

`FE_DOWNWARD'
     Round toward -oo.

`FE_TOWARDZERO'
     Round toward zero.

   Underflow is an unusual case.  Normally, IEEE 754 floating point
numbers are always normalized (*note Floating Point Concepts::).
Numbers smaller than 2^r (where r is the minimum exponent,
`FLT_MIN_RADIX-1' for FLOAT) cannot be represented as normalized
numbers.  Rounding all such numbers to zero or 2^r would cause some
algorithms to fail at 0.  Therefore, they are left in denormalized
form.  That produces loss of precision, since some bits of the mantissa
are stolen to indicate the decimal point.

   If a result is too small to be represented as a denormalized number,
it is rounded to zero.  However, the sign of the result is preserved; if
the calculation was negative, the result is "negative zero".  Negative
zero can also result from some operations on infinity, such as 4/-oo.
Negative zero behaves identically to zero except when the `copysign' or
`signbit' functions are used to check the sign bit directly.

   At any time one of the above four rounding modes is selected.  You
can find out which one with this function:

 -- Function: int fegetround (void)
     Returns the currently selected rounding mode, represented by one
     of the values of the defined rounding mode macros.

To change the rounding mode, use this function:

 -- Function: int fesetround (int ROUND)
     Changes the currently selected rounding mode to ROUND.  If ROUND
     does not correspond to one of the supported rounding modes nothing
     is changed.  `fesetround' returns zero if it changed the rounding
     mode, a nonzero value if the mode is not supported.

   You should avoid changing the rounding mode if possible.  It can be
an expensive operation; also, some hardware requires you to compile your
program differently for it to work.  The resulting code may run slower.
See your compiler documentation for details.


File: libc.info,  Node: Control Functions,  Next: Arithmetic Functions,  Prev: Rounding,  Up: Arithmetic

20.7 Floating-Point Control Functions
=====================================

IEEE 754 floating-point implementations allow the programmer to decide
whether traps will occur for each of the exceptions, by setting bits in
the "control word".  In C, traps result in the program receiving the
`SIGFPE' signal; see *Note Signal Handling::.

   *NB:* IEEE 754 says that trap handlers are given details of the
exceptional situation, and can set the result value.  C signals do not
provide any mechanism to pass this information back and forth.
Trapping exceptions in C is therefore not very useful.

   It is sometimes necessary to save the state of the floating-point
unit while you perform some calculation.  The library provides functions
which save and restore the exception flags, the set of exceptions that
generate traps, and the rounding mode.  This information is known as the
"floating-point environment".

   The functions to save and restore the floating-point environment all
use a variable of type `fenv_t' to store information.  This type is
defined in `fenv.h'.  Its size and contents are implementation-defined.
You should not attempt to manipulate a variable of this type directly.

   To save the state of the FPU, use one of these functions:

 -- Function: int fegetenv (fenv_t *ENVP)
     Store the floating-point environment in the variable pointed to by
     ENVP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int feholdexcept (fenv_t *ENVP)
     Store the current floating-point environment in the object pointed
     to by ENVP.  Then clear all exception flags, and set the FPU to
     trap no exceptions.  Not all FPUs support trapping no exceptions;
     if `feholdexcept' cannot set this mode, it returns nonzero value.
     If it succeeds, it returns zero.

   The functions which restore the floating-point environment can take
these kinds of arguments:

   * Pointers to `fenv_t' objects, which were initialized previously by
     a call to `fegetenv' or `feholdexcept'.

   * The special macro `FE_DFL_ENV' which represents the floating-point
     environment as it was available at program start.

   * Implementation defined macros with names starting with `FE_' and
     having type `fenv_t *'.

     If possible, the GNU C Library defines a macro `FE_NOMASK_ENV'
     which represents an environment where every exception raised
     causes a trap to occur.  You can test for this macro using
     `#ifdef'.  It is only defined if `_GNU_SOURCE' is defined.

     Some platforms might define other predefined environments.

To set the floating-point environment, you can use either of these
functions:

 -- Function: int fesetenv (const fenv_t *ENVP)
     Set the floating-point environment to that described by ENVP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int feupdateenv (const fenv_t *ENVP)
     Like `fesetenv', this function sets the floating-point environment
     to that described by ENVP.  However, if any exceptions were
     flagged in the status word before `feupdateenv' was called, they
     remain flagged after the call.  In other words, after `feupdateenv'
     is called, the status word is the bitwise OR of the previous
     status word and the one saved in ENVP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

To control for individual exceptions if raising them causes a trap to
occur, you can use the following two functions.

   *Portability Note:* These functions are all GNU extensions.

 -- Function: int feenableexcept (int EXCEPTS)
     This functions enables traps for each of the exceptions as
     indicated by the parameter EXCEPT.  The individual excepetions are
     described in *Note Status bit operations::.  Only the specified
     exceptions are enabled, the status of the other exceptions is not
     changed.

     The function returns the previous enabled exceptions in case the
     operation was successful, `-1' otherwise.

 -- Function: int fedisableexcept (int EXCEPTS)
     This functions disables traps for each of the exceptions as
     indicated by the parameter EXCEPT.  The individual excepetions are
     described in *Note Status bit operations::.  Only the specified
     exceptions are disabled, the status of the other exceptions is not
     changed.

     The function returns the previous enabled exceptions in case the
     operation was successful, `-1' otherwise.

 -- Function: int fegetexcept (int EXCEPTS)
     The function returns a bitmask of all currently enabled
     exceptions.  It returns `-1' in case of failure.


File: libc.info,  Node: Arithmetic Functions,  Next: Complex Numbers,  Prev: Control Functions,  Up: Arithmetic

20.8 Arithmetic Functions
=========================

The C library provides functions to do basic operations on
floating-point numbers.  These include absolute value, maximum and
minimum, normalization, bit twiddling, rounding, and a few others.

* Menu:

* Absolute Value::              Absolute values of integers and floats.
* Normalization Functions::     Extracting exponents and putting them back.
* Rounding Functions::          Rounding floats to integers.
* Remainder Functions::         Remainders on division, precisely defined.
* FP Bit Twiddling::            Sign bit adjustment.  Adding epsilon.
* FP Comparison Functions::     Comparisons without risk of exceptions.
* Misc FP Arithmetic::          Max, min, positive difference, multiply-add.


File: libc.info,  Node: Absolute Value,  Next: Normalization Functions,  Up: Arithmetic Functions

20.8.1 Absolute Value
---------------------

These functions are provided for obtaining the "absolute value" (or
"magnitude") of a number.  The absolute value of a real number X is X
if X is positive, -X if X is negative.  For a complex number Z, whose
real part is X and whose imaginary part is Y, the absolute value is
`sqrt (X*X + Y*Y)'.

   Prototypes for `abs', `labs' and `llabs' are in `stdlib.h';
`imaxabs' is declared in `inttypes.h'; `fabs', `fabsf' and `fabsl' are
declared in `math.h'.  `cabs', `cabsf' and `cabsl' are declared in
`complex.h'.

 -- Function: int abs (int NUMBER)
 -- Function: long int labs (long int NUMBER)
 -- Function: long long int llabs (long long int NUMBER)
 -- Function: intmax_t imaxabs (intmax_t NUMBER)
     These functions return the absolute value of NUMBER.

     Most computers use a two's complement integer representation, in
     which the absolute value of `INT_MIN' (the smallest possible `int')
     cannot be represented; thus, `abs (INT_MIN)' is not defined.

     `llabs' and `imaxdiv' are new to ISO C99.

     See *Note Integers:: for a description of the `intmax_t' type.


 -- Function: double fabs (double NUMBER)
 -- Function: float fabsf (float NUMBER)
 -- Function: long double fabsl (long double NUMBER)
     This function returns the absolute value of the floating-point
     number NUMBER.

 -- Function: double cabs (complex double Z)
 -- Function: float cabsf (complex float Z)
 -- Function: long double cabsl (complex long double Z)
     These functions return the absolute  value of the complex number Z
     (*note Complex Numbers::).  The absolute value of a complex number
     is:

          sqrt (creal (Z) * creal (Z) + cimag (Z) * cimag (Z))

     This function should always be used instead of the direct formula
     because it takes special care to avoid losing precision.  It may
     also take advantage of hardware support for this operation. See
     `hypot' in *Note Exponents and Logarithms::.


File: libc.info,  Node: Normalization Functions,  Next: Rounding Functions,  Prev: Absolute Value,  Up: Arithmetic Functions

20.8.2 Normalization Functions
------------------------------

The functions described in this section are primarily provided as a way
to efficiently perform certain low-level manipulations on floating point
numbers that are represented internally using a binary radix; see *Note
Floating Point Concepts::.  These functions are required to have
equivalent behavior even if the representation does not use a radix of
2, but of course they are unlikely to be particularly efficient in
those cases.

   All these functions are declared in `math.h'.

 -- Function: double frexp (double VALUE, int *EXPONENT)
 -- Function: float frexpf (float VALUE, int *EXPONENT)
 -- Function: long double frexpl (long double VALUE, int *EXPONENT)
     These functions are used to split the number VALUE into a
     normalized fraction and an exponent.

     If the argument VALUE is not zero, the return value is VALUE times
     a power of two, and is always in the range 1/2 (inclusive) to 1
     (exclusive).  The corresponding exponent is stored in `*EXPONENT';
     the return value multiplied by 2 raised to this exponent equals
     the original number VALUE.

     For example, `frexp (12.8, &exponent)' returns `0.8' and stores
     `4' in `exponent'.

     If VALUE is zero, then the return value is zero and zero is stored
     in `*EXPONENT'.

 -- Function: double ldexp (double VALUE, int EXPONENT)
 -- Function: float ldexpf (float VALUE, int EXPONENT)
 -- Function: long double ldexpl (long double VALUE, int EXPONENT)
     These functions return the result of multiplying the floating-point
     number VALUE by 2 raised to the power EXPONENT.  (It can be used
     to reassemble floating-point numbers that were taken apart by
     `frexp'.)

     For example, `ldexp (0.8, 4)' returns `12.8'.

   The following functions, which come from BSD, provide facilities
equivalent to those of `ldexp' and `frexp'.  See also the ISO C
function `logb' which originally also appeared in BSD.

 -- Function: double scalb (double VALUE, int EXPONENT)
 -- Function: float scalbf (float VALUE, int EXPONENT)
 -- Function: long double scalbl (long double VALUE, int EXPONENT)
     The `scalb' function is the BSD name for `ldexp'.

 -- Function: long long int scalbn (double X, int n)
 -- Function: long long int scalbnf (float X, int n)
 -- Function: long long int scalbnl (long double X, int n)
     `scalbn' is identical to `scalb', except that the exponent N is an
     `int' instead of a floating-point number.

 -- Function: long long int scalbln (double X, long int n)
 -- Function: long long int scalblnf (float X, long int n)
 -- Function: long long int scalblnl (long double X, long int n)
     `scalbln' is identical to `scalb', except that the exponent N is a
     `long int' instead of a floating-point number.

 -- Function: long long int significand (double X)
 -- Function: long long int significandf (float X)
 -- Function: long long int significandl (long double X)
     `significand' returns the mantissa of X scaled to the range [1, 2).
     It is equivalent to `scalb (X, (double) -ilogb (X))'.

     This function exists mainly for use in certain standardized tests
     of IEEE 754 conformance.


File: libc.info,  Node: Rounding Functions,  Next: Remainder Functions,  Prev: Normalization Functions,  Up: Arithmetic Functions

20.8.3 Rounding Functions
-------------------------

The functions listed here perform operations such as rounding and
truncation of floating-point values. Some of these functions convert
floating point numbers to integer values.  They are all declared in
`math.h'.

   You can also convert floating-point numbers to integers simply by
casting them to `int'.  This discards the fractional part, effectively
rounding towards zero.  However, this only works if the result can
actually be represented as an `int'--for very large numbers, this is
impossible.  The functions listed here return the result as a `double'
instead to get around this problem.

 -- Function: double ceil (double X)
 -- Function: float ceilf (float X)
 -- Function: long double ceill (long double X)
     These functions round X upwards to the nearest integer, returning
     that value as a `double'.  Thus, `ceil (1.5)' is `2.0'.

 -- Function: double floor (double X)
 -- Function: float floorf (float X)
 -- Function: long double floorl (long double X)
     These functions round X downwards to the nearest integer,
     returning that value as a `double'.  Thus, `floor (1.5)' is `1.0'
     and `floor (-1.5)' is `-2.0'.

 -- Function: double trunc (double X)
 -- Function: float truncf (float X)
 -- Function: long double truncl (long double X)
     The `trunc' functions round X towards zero to the nearest integer
     (returned in floating-point format).  Thus, `trunc (1.5)' is `1.0'
     and `trunc (-1.5)' is `-1.0'.

 -- Function: double rint (double X)
 -- Function: float rintf (float X)
 -- Function: long double rintl (long double X)
     These functions round X to an integer value according to the
     current rounding mode.  *Note Floating Point Parameters::, for
     information about the various rounding modes.  The default
     rounding mode is to round to the nearest integer; some machines
     support other modes, but round-to-nearest is always used unless
     you explicitly select another.

     If X was not initially an integer, these functions raise the
     inexact exception.

 -- Function: double nearbyint (double X)
 -- Function: float nearbyintf (float X)
 -- Function: long double nearbyintl (long double X)
     These functions return the same value as the `rint' functions, but
     do not raise the inexact exception if X is not an integer.

 -- Function: double round (double X)
 -- Function: float roundf (float X)
 -- Function: long double roundl (long double X)
     These functions are similar to `rint', but they round halfway
     cases away from zero instead of to the nearest integer (or other
     current rounding mode).

 -- Function: long int lrint (double X)
 -- Function: long int lrintf (float X)
 -- Function: long int lrintl (long double X)
     These functions are just like `rint', but they return a `long int'
     instead of a floating-point number.

 -- Function: long long int llrint (double X)
 -- Function: long long int llrintf (float X)
 -- Function: long long int llrintl (long double X)
     These functions are just like `rint', but they return a `long long
     int' instead of a floating-point number.

 -- Function: long int lround (double X)
 -- Function: long int lroundf (float X)
 -- Function: long int lroundl (long double X)
     These functions are just like `round', but they return a `long
     int' instead of a floating-point number.

 -- Function: long long int llround (double X)
 -- Function: long long int llroundf (float X)
 -- Function: long long int llroundl (long double X)
     These functions are just like `round', but they return a `long
     long int' instead of a floating-point number.

 -- Function: double modf (double VALUE, double *INTEGER-PART)
 -- Function: float modff (float VALUE, float *INTEGER-PART)
 -- Function: long double modfl (long double VALUE, long double
          *INTEGER-PART)
     These functions break the argument VALUE into an integer part and a
     fractional part (between `-1' and `1', exclusive).  Their sum
     equals VALUE.  Each of the parts has the same sign as VALUE, and
     the integer part is always rounded toward zero.

     `modf' stores the integer part in `*INTEGER-PART', and returns the
     fractional part.  For example, `modf (2.5, &intpart)' returns
     `0.5' and stores `2.0' into `intpart'.


File: libc.info,  Node: Remainder Functions,  Next: FP Bit Twiddling,  Prev: Rounding Functions,  Up: Arithmetic Functions

20.8.4 Remainder Functions
--------------------------

The functions in this section compute the remainder on division of two
floating-point numbers.  Each is a little different; pick the one that
suits your problem.

 -- Function: double fmod (double NUMERATOR, double DENOMINATOR)
 -- Function: float fmodf (float NUMERATOR, float DENOMINATOR)
 -- Function: long double fmodl (long double NUMERATOR, long double
          DENOMINATOR)
     These functions compute the remainder from the division of
     NUMERATOR by DENOMINATOR.  Specifically, the return value is
     `NUMERATOR - N * DENOMINATOR', where N is the quotient of
     NUMERATOR divided by DENOMINATOR, rounded towards zero to an
     integer.  Thus, `fmod (6.5, 2.3)' returns `1.9', which is `6.5'
     minus `4.6'.

     The result has the same sign as the NUMERATOR and has magnitude
     less than the magnitude of the DENOMINATOR.

     If DENOMINATOR is zero, `fmod' signals a domain error.

 -- Function: double drem (double NUMERATOR, double DENOMINATOR)
 -- Function: float dremf (float NUMERATOR, float DENOMINATOR)
 -- Function: long double dreml (long double NUMERATOR, long double
          DENOMINATOR)
     These functions are like `fmod' except that they round the
     internal quotient N to the nearest integer instead of towards zero
     to an integer.  For example, `drem (6.5, 2.3)' returns `-0.4',
     which is `6.5' minus `6.9'.

     The absolute value of the result is less than or equal to half the
     absolute value of the DENOMINATOR.  The difference between `fmod
     (NUMERATOR, DENOMINATOR)' and `drem (NUMERATOR, DENOMINATOR)' is
     always either DENOMINATOR, minus DENOMINATOR, or zero.

     If DENOMINATOR is zero, `drem' signals a domain error.

 -- Function: double remainder (double NUMERATOR, double DENOMINATOR)
 -- Function: float remainderf (float NUMERATOR, float DENOMINATOR)
 -- Function: long double remainderl (long double NUMERATOR, long
          double DENOMINATOR)
     This function is another name for `drem'.


File: libc.info,  Node: FP Bit Twiddling,  Next: FP Comparison Functions,  Prev: Remainder Functions,  Up: Arithmetic Functions

20.8.5 Setting and modifying single bits of FP values
-----------------------------------------------------

There are some operations that are too complicated or expensive to
perform by hand on floating-point numbers.  ISO C99 defines functions
to do these operations, which mostly involve changing single bits.

 -- Function: double copysign (double X, double Y)
 -- Function: float copysignf (float X, float Y)
 -- Function: long double copysignl (long double X, long double Y)
     These functions return X but with the sign of Y.  They work even
     if X or Y are NaN or zero.  Both of these can carry a sign
     (although not all implementations support it) and this is one of
     the few operations that can tell the difference.

     `copysign' never raises an exception.

     This function is defined in IEC 559 (and the appendix with
     recommended functions in IEEE 754/IEEE 854).

 -- Function: int signbit (_float-type_ X)
     `signbit' is a generic macro which can work on all floating-point
     types.  It returns a nonzero value if the value of X has its sign
     bit set.

     This is not the same as `x < 0.0', because IEEE 754 floating point
     allows zero to be signed.  The comparison `-0.0 < 0.0' is false,
     but `signbit (-0.0)' will return a nonzero value.

 -- Function: double nextafter (double X, double Y)
 -- Function: float nextafterf (float X, float Y)
 -- Function: long double nextafterl (long double X, long double Y)
     The `nextafter' function returns the next representable neighbor of
     X in the direction towards Y.  The size of the step between X and
     the result depends on the type of the result.  If X = Y the
     function simply returns Y.  If either value is `NaN', `NaN' is
     returned.  Otherwise a value corresponding to the value of the
     least significant bit in the mantissa is added or subtracted,
     depending on the direction.  `nextafter' will signal overflow or
     underflow if the result goes outside of the range of normalized
     numbers.

     This function is defined in IEC 559 (and the appendix with
     recommended functions in IEEE 754/IEEE 854).

 -- Function: double nexttoward (double X, long double Y)
 -- Function: float nexttowardf (float X, long double Y)
 -- Function: long double nexttowardl (long double X, long double Y)
     These functions are identical to the corresponding versions of
     `nextafter' except that their second argument is a `long double'.

 -- Function: double nan (const char *TAGP)
 -- Function: float nanf (const char *TAGP)
 -- Function: long double nanl (const char *TAGP)
     The `nan' function returns a representation of NaN, provided that
     NaN is supported by the target platform.  `nan
     ("N-CHAR-SEQUENCE")' is equivalent to `strtod
     ("NAN(N-CHAR-SEQUENCE)")'.

     The argument TAGP is used in an unspecified manner.  On IEEE 754
     systems, there are many representations of NaN, and TAGP selects
     one.  On other systems it may do nothing.


File: libc.info,  Node: FP Comparison Functions,  Next: Misc FP Arithmetic,  Prev: FP Bit Twiddling,  Up: Arithmetic Functions

20.8.6 Floating-Point Comparison Functions
------------------------------------------

The standard C comparison operators provoke exceptions when one or other
of the operands is NaN.  For example,

     int v = a < 1.0;

will raise an exception if A is NaN.  (This does _not_ happen with `=='
and `!='; those merely return false and true, respectively, when NaN is
examined.)  Frequently this exception is undesirable.  ISO C99
therefore defines comparison functions that do not raise exceptions
when NaN is examined.  All of the functions are implemented as macros
which allow their arguments to be of any floating-point type.  The
macros are guaranteed to evaluate their arguments only once.

 -- Macro: int isgreater (_real-floating_ X, _real-floating_ Y)
     This macro determines whether the argument X is greater than Y.
     It is equivalent to `(X) > (Y)', but no exception is raised if X
     or Y are NaN.

 -- Macro: int isgreaterequal (_real-floating_ X, _real-floating_ Y)
     This macro determines whether the argument X is greater than or
     equal to Y.  It is equivalent to `(X) >= (Y)', but no exception is
     raised if X or Y are NaN.

 -- Macro: int isless (_real-floating_ X, _real-floating_ Y)
     This macro determines whether the argument X is less than Y.  It
     is equivalent to `(X) < (Y)', but no exception is raised if X or Y
     are NaN.

 -- Macro: int islessequal (_real-floating_ X, _real-floating_ Y)
     This macro determines whether the argument X is less than or equal
     to Y.  It is equivalent to `(X) <= (Y)', but no exception is
     raised if X or Y are NaN.

 -- Macro: int islessgreater (_real-floating_ X, _real-floating_ Y)
     This macro determines whether the argument X is less or greater
     than Y.  It is equivalent to `(X) < (Y) || (X) > (Y)' (although it
     only evaluates X and Y once), but no exception is raised if X or Y
     are NaN.

     This macro is not equivalent to `X != Y', because that expression
     is true if X or Y are NaN.

 -- Macro: int isunordered (_real-floating_ X, _real-floating_ Y)
     This macro determines whether its arguments are unordered.  In
     other words, it is true if X or Y are NaN, and false otherwise.

   Not all machines provide hardware support for these operations.  On
machines that don't, the macros can be very slow.  Therefore, you should
not use these functions when NaN is not a concern.

   *NB:* There are no macros `isequal' or `isunequal'.  They are
unnecessary, because the `==' and `!=' operators do _not_ throw an
exception if one or both of the operands are NaN.


File: libc.info,  Node: Misc FP Arithmetic,  Prev: FP Comparison Functions,  Up: Arithmetic Functions

20.8.7 Miscellaneous FP arithmetic functions
--------------------------------------------

The functions in this section perform miscellaneous but common
operations that are awkward to express with C operators.  On some
processors these functions can use special machine instructions to
perform these operations faster than the equivalent C code.

 -- Function: double fmin (double X, double Y)
 -- Function: float fminf (float X, float Y)
 -- Function: long double fminl (long double X, long double Y)
     The `fmin' function returns the lesser of the two values X and Y.
     It is similar to the expression
          ((x) < (y) ? (x) : (y))
     except that X and Y are only evaluated once.

     If an argument is NaN, the other argument is returned.  If both
     arguments are NaN, NaN is returned.

 -- Function: double fmax (double X, double Y)
 -- Function: float fmaxf (float X, float Y)
 -- Function: long double fmaxl (long double X, long double Y)
     The `fmax' function returns the greater of the two values X and Y.

     If an argument is NaN, the other argument is returned.  If both
     arguments are NaN, NaN is returned.

 -- Function: double fdim (double X, double Y)
 -- Function: float fdimf (float X, float Y)
 -- Function: long double fdiml (long double X, long double Y)
     The `fdim' function returns the positive difference between X and
     Y.  The positive difference is X - Y if X is greater than Y, and 0
     otherwise.

     If X, Y, or both are NaN, NaN is returned.

 -- Function: double fma (double X, double Y, double Z)
 -- Function: float fmaf (float X, float Y, float Z)
 -- Function: long double fmal (long double X, long double Y, long
          double Z)
     The `fma' function performs floating-point multiply-add.  This is
     the operation (X * Y) + Z, but the intermediate result is not
     rounded to the destination type.  This can sometimes improve the
     precision of a calculation.

     This function was introduced because some processors have a special
     instruction to perform multiply-add.  The C compiler cannot use it
     directly, because the expression `x*y + z' is defined to round the
     intermediate result.  `fma' lets you choose when you want to round
     only once.

     On processors which do not implement multiply-add in hardware,
     `fma' can be very slow since it must avoid intermediate rounding.
     `math.h' defines the symbols `FP_FAST_FMA', `FP_FAST_FMAF', and
     `FP_FAST_FMAL' when the corresponding version of `fma' is no
     slower than the expression `x*y + z'.  In the GNU C library, this
     always means the operation is implemented in hardware.


File: libc.info,  Node: Complex Numbers,  Next: Operations on Complex,  Prev: Arithmetic Functions,  Up: Arithmetic

20.9 Complex Numbers
====================

ISO C99 introduces support for complex numbers in C.  This is done with
a new type qualifier, `complex'.  It is a keyword if and only if
`complex.h' has been included.  There are three complex types,
corresponding to the three real types:  `float complex', `double
complex', and `long double complex'.

   To construct complex numbers you need a way to indicate the imaginary
part of a number.  There is no standard notation for an imaginary
floating point constant.  Instead, `complex.h' defines two macros that
can be used to create complex numbers.

 -- Macro: const float complex _Complex_I
     This macro is a representation of the complex number "0+1i".
     Multiplying a real floating-point value by `_Complex_I' gives a
     complex number whose value is purely imaginary.  You can use this
     to construct complex constants:

          3.0 + 4.0i = `3.0 + 4.0 * _Complex_I'

     Note that `_Complex_I * _Complex_I' has the value `-1', but the
     type of that value is `complex'.

`_Complex_I' is a bit of a mouthful.  `complex.h' also defines a
shorter name for the same constant.

 -- Macro: const float complex I
     This macro has exactly the same value as `_Complex_I'.  Most of the
     time it is preferable.  However, it causes problems if you want to
     use the identifier `I' for something else.  You can safely write

          #include <complex.h>
          #undef I

     if you need `I' for your own purposes.  (In that case we recommend
     you also define some other short name for `_Complex_I', such as
     `J'.)



File: libc.info,  Node: Operations on Complex,  Next: Parsing of Numbers,  Prev: Complex Numbers,  Up: Arithmetic

20.10 Projections, Conjugates, and Decomposing of Complex Numbers
=================================================================

ISO C99 also defines functions that perform basic operations on complex
numbers, such as decomposition and conjugation.  The prototypes for all
these functions are in `complex.h'.  All functions are available in
three variants, one for each of the three complex types.

 -- Function: double creal (complex double Z)
 -- Function: float crealf (complex float Z)
 -- Function: long double creall (complex long double Z)
     These functions return the real part of the complex number Z.

 -- Function: double cimag (complex double Z)
 -- Function: float cimagf (complex float Z)
 -- Function: long double cimagl (complex long double Z)
     These functions return the imaginary part of the complex number Z.

 -- Function: complex double conj (complex double Z)
 -- Function: complex float conjf (complex float Z)
 -- Function: complex long double conjl (complex long double Z)
     These functions return the conjugate value of the complex number
     Z.  The conjugate of a complex number has the same real part and a
     negated imaginary part.  In other words, `conj(a + bi) = a + -bi'.

 -- Function: double carg (complex double Z)
 -- Function: float cargf (complex float Z)
 -- Function: long double cargl (complex long double Z)
     These functions return the argument of the complex number Z.  The
     argument of a complex number is the angle in the complex plane
     between the positive real axis and a line passing through zero and
     the number.  This angle is measured in the usual fashion and
     ranges from 0 to 2pi.

     `carg' has a branch cut along the positive real axis.

 -- Function: complex double cproj (complex double Z)
 -- Function: complex float cprojf (complex float Z)
 -- Function: complex long double cprojl (complex long double Z)
     These functions return the projection of the complex value Z onto
     the Riemann sphere.  Values with a infinite imaginary part are
     projected to positive infinity on the real axis, even if the real
     part is NaN.  If the real part is infinite, the result is
     equivalent to

          INFINITY + I * copysign (0.0, cimag (z))


File: libc.info,  Node: Parsing of Numbers,  Next: System V Number Conversion,  Prev: Operations on Complex,  Up: Arithmetic

20.11 Parsing of Numbers
========================

This section describes functions for "reading" integer and
floating-point numbers from a string.  It may be more convenient in some
cases to use `sscanf' or one of the related functions; see *Note
Formatted Input::.  But often you can make a program more robust by
finding the tokens in the string by hand, then converting the numbers
one by one.

* Menu:

* Parsing of Integers::         Functions for conversion of integer values.
* Parsing of Floats::           Functions for conversion of floating-point
				 values.


File: libc.info,  Node: Parsing of Integers,  Next: Parsing of Floats,  Up: Parsing of Numbers

20.11.1 Parsing of Integers
---------------------------

The `str' functions are declared in `stdlib.h' and those beginning with
`wcs' are declared in `wchar.h'.  One might wonder about the use of
`restrict' in the prototypes of the functions in this section.  It is
seemingly useless but the ISO C standard uses it (for the functions
defined there) so we have to do it as well.

 -- Function: long int strtol (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)
     The `strtol' ("string-to-long") function converts the initial part
     of STRING to a signed integer, which is returned as a value of
     type `long int'.

     This function attempts to decompose STRING as follows:

        * A (possibly empty) sequence of whitespace characters.  Which
          characters are whitespace is determined by the `isspace'
          function (*note Classification of Characters::).  These are
          discarded.

        * An optional plus or minus sign (`+' or `-').

        * A nonempty sequence of digits in the radix specified by BASE.

          If BASE is zero, decimal radix is assumed unless the series of
          digits begins with `0' (specifying octal radix), or `0x' or
          `0X' (specifying hexadecimal radix); in other words, the same
          syntax used for integer constants in C.

          Otherwise BASE must have a value between `2' and `36'.  If
          BASE is `16', the digits may optionally be preceded by `0x'
          or `0X'.  If base has no legal value the value returned is
          `0l' and the global variable `errno' is set to `EINVAL'.

        * Any remaining characters in the string.  If TAILPTR is not a
          null pointer, `strtol' stores a pointer to this tail in
          `*TAILPTR'.

     If the string is empty, contains only whitespace, or does not
     contain an initial substring that has the expected syntax for an
     integer in the specified BASE, no conversion is performed.  In
     this case, `strtol' returns a value of zero and the value stored in
     `*TAILPTR' is the value of STRING.

     In a locale other than the standard `"C"' locale, this function
     may recognize additional implementation-dependent syntax.

     If the string has valid syntax for an integer but the value is not
     representable because of overflow, `strtol' returns either
     `LONG_MAX' or `LONG_MIN' (*note Range of Type::), as appropriate
     for the sign of the value.  It also sets `errno' to `ERANGE' to
     indicate there was overflow.

     You should not check for errors by examining the return value of
     `strtol', because the string might be a valid representation of
     `0l', `LONG_MAX', or `LONG_MIN'.  Instead, check whether TAILPTR
     points to what you expect after the number (e.g. `'\0'' if the
     string should end after the number).  You also need to clear ERRNO
     before the call and check it afterward, in case there was overflow.

     There is an example at the end of this section.

 -- Function: long int wcstol (const wchar_t *restrict STRING, wchar_t
          **restrict TAILPTR, int BASE)
     The `wcstol' function is equivalent to the `strtol' function in
     nearly all aspects but handles wide character strings.

     The `wcstol' function was introduced in Amendment 1 of ISO C90.

 -- Function: unsigned long int strtoul (const char *retrict STRING,
          char **restrict TAILPTR, int BASE)
     The `strtoul' ("string-to-unsigned-long") function is like
     `strtol' except it converts to an `unsigned long int' value.  The
     syntax is the same as described above for `strtol'.  The value
     returned on overflow is `ULONG_MAX' (*note Range of Type::).

     If STRING depicts a negative number, `strtoul' acts the same as
     STRTOL but casts the result to an unsigned integer.  That means
     for example that `strtoul' on `"-1"' returns `ULONG_MAX' and an
     input more negative than `LONG_MIN' returns (`ULONG_MAX' + 1) / 2.

     `strtoul' sets ERRNO to `EINVAL' if BASE is out of range, or
     `ERANGE' on overflow.

 -- Function: unsigned long int wcstoul (const wchar_t *restrict
          STRING, wchar_t **restrict TAILPTR, int BASE)
     The `wcstoul' function is equivalent to the `strtoul' function in
     nearly all aspects but handles wide character strings.

     The `wcstoul' function was introduced in Amendment 1 of ISO C90.

 -- Function: long long int strtoll (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)
     The `strtoll' function is like `strtol' except that it returns a
     `long long int' value, and accepts numbers with a correspondingly
     larger range.

     If the string has valid syntax for an integer but the value is not
     representable because of overflow, `strtoll' returns either
     `LONG_LONG_MAX' or `LONG_LONG_MIN' (*note Range of Type::), as
     appropriate for the sign of the value.  It also sets `errno' to
     `ERANGE' to indicate there was overflow.

     The `strtoll' function was introduced in ISO C99.

 -- Function: long long int wcstoll (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)
     The `wcstoll' function is equivalent to the `strtoll' function in
     nearly all aspects but handles wide character strings.

     The `wcstoll' function was introduced in Amendment 1 of ISO C90.

 -- Function: long long int strtoq (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)
     `strtoq' ("string-to-quad-word") is the BSD name for `strtoll'.

 -- Function: long long int wcstoq (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)
     The `wcstoq' function is equivalent to the `strtoq' function in
     nearly all aspects but handles wide character strings.

     The `wcstoq' function is a GNU extension.

 -- Function: unsigned long long int strtoull (const char *restrict
          STRING, char **restrict TAILPTR, int BASE)
     The `strtoull' function is related to `strtoll' the same way
     `strtoul' is related to `strtol'.

     The `strtoull' function was introduced in ISO C99.

 -- Function: unsigned long long int wcstoull (const wchar_t *restrict
          STRING, wchar_t **restrict TAILPTR, int BASE)
     The `wcstoull' function is equivalent to the `strtoull' function
     in nearly all aspects but handles wide character strings.

     The `wcstoull' function was introduced in Amendment 1 of ISO C90.

 -- Function: unsigned long long int strtouq (const char *restrict
          STRING, char **restrict TAILPTR, int BASE)
     `strtouq' is the BSD name for `strtoull'.

 -- Function: unsigned long long int wcstouq (const wchar_t *restrict
          STRING, wchar_t **restrict TAILPTR, int BASE)
     The `wcstouq' function is equivalent to the `strtouq' function in
     nearly all aspects but handles wide character strings.

     The `wcstouq' function is a GNU extension.

 -- Function: intmax_t strtoimax (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)
     The `strtoimax' function is like `strtol' except that it returns a
     `intmax_t' value, and accepts numbers of a corresponding range.

     If the string has valid syntax for an integer but the value is not
     representable because of overflow, `strtoimax' returns either
     `INTMAX_MAX' or `INTMAX_MIN' (*note Integers::), as appropriate
     for the sign of the value.  It also sets `errno' to `ERANGE' to
     indicate there was overflow.

     See *Note Integers:: for a description of the `intmax_t' type.  The
     `strtoimax' function was introduced in ISO C99.

 -- Function: intmax_t wcstoimax (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)
     The `wcstoimax' function is equivalent to the `strtoimax' function
     in nearly all aspects but handles wide character strings.

     The `wcstoimax' function was introduced in ISO C99.

 -- Function: uintmax_t strtoumax (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)
     The `strtoumax' function is related to `strtoimax' the same way
     that `strtoul' is related to `strtol'.

     See *Note Integers:: for a description of the `intmax_t' type.  The
     `strtoumax' function was introduced in ISO C99.

 -- Function: uintmax_t wcstoumax (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)
     The `wcstoumax' function is equivalent to the `strtoumax' function
     in nearly all aspects but handles wide character strings.

     The `wcstoumax' function was introduced in ISO C99.

 -- Function: long int atol (const char *STRING)
     This function is similar to the `strtol' function with a BASE
     argument of `10', except that it need not detect overflow errors.
     The `atol' function is provided mostly for compatibility with
     existing code; using `strtol' is more robust.

 -- Function: int atoi (const char *STRING)
     This function is like `atol', except that it returns an `int'.
     The `atoi' function is also considered obsolete; use `strtol'
     instead.

 -- Function: long long int atoll (const char *STRING)
     This function is similar to `atol', except it returns a `long long
     int'.

     The `atoll' function was introduced in ISO C99.  It too is
     obsolete (despite having just been added); use `strtoll' instead.

   All the functions mentioned in this section so far do not handle
alternative representations of characters as described in the locale
data.  Some locales specify thousands separator and the way they have to
be used which can help to make large numbers more readable.  To read
such numbers one has to use the `scanf' functions with the `'' flag.

   Here is a function which parses a string as a sequence of integers
and returns the sum of them:

     int
     sum_ints_from_string (char *string)
     {
       int sum = 0;

       while (1) {
         char *tail;
         int next;

         /* Skip whitespace by hand, to detect the end.  */
         while (isspace (*string)) string++;
         if (*string == 0)
           break;

         /* There is more nonwhitespace,  */
         /* so it ought to be another number.  */
         errno = 0;
         /* Parse it.  */
         next = strtol (string, &tail, 0);
         /* Add it in, if not overflow.  */
         if (errno)
           printf ("Overflow\n");
         else
           sum += next;
         /* Advance past it.  */
         string = tail;
       }

       return sum;
     }


File: libc.info,  Node: Parsing of Floats,  Prev: Parsing of Integers,  Up: Parsing of Numbers

20.11.2 Parsing of Floats
-------------------------

The `str' functions are declared in `stdlib.h' and those beginning with
`wcs' are declared in `wchar.h'.  One might wonder about the use of
`restrict' in the prototypes of the functions in this section.  It is
seemingly useless but the ISO C standard uses it (for the functions
defined there) so we have to do it as well.

 -- Function: double strtod (const char *restrict STRING, char
          **restrict TAILPTR)
     The `strtod' ("string-to-double") function converts the initial
     part of STRING to a floating-point number, which is returned as a
     value of type `double'.

     This function attempts to decompose STRING as follows:

        * A (possibly empty) sequence of whitespace characters.  Which
          characters are whitespace is determined by the `isspace'
          function (*note Classification of Characters::).  These are
          discarded.

        * An optional plus or minus sign (`+' or `-').

        * A floating point number in decimal or hexadecimal format.  The
          decimal format is:
             - A nonempty sequence of digits optionally containing a
               decimal-point character--normally `.', but it depends on
               the locale (*note General Numeric::).

             - An optional exponent part, consisting of a character `e'
               or `E', an optional sign, and a sequence of digits.


          The hexadecimal format is as follows:
             - A 0x or 0X followed by a nonempty sequence of
               hexadecimal digits optionally containing a decimal-point
               character--normally `.', but it depends on the locale
               (*note General Numeric::).

             - An optional binary-exponent part, consisting of a
               character `p' or `P', an optional sign, and a sequence
               of digits.


        * Any remaining characters in the string.  If TAILPTR is not a
          null pointer, a pointer to this tail of the string is stored
          in `*TAILPTR'.

     If the string is empty, contains only whitespace, or does not
     contain an initial substring that has the expected syntax for a
     floating-point number, no conversion is performed.  In this case,
     `strtod' returns a value of zero and the value returned in
     `*TAILPTR' is the value of STRING.

     In a locale other than the standard `"C"' or `"POSIX"' locales,
     this function may recognize additional locale-dependent syntax.

     If the string has valid syntax for a floating-point number but the
     value is outside the range of a `double', `strtod' will signal
     overflow or underflow as described in *Note Math Error Reporting::.

     `strtod' recognizes four special input strings.  The strings
     `"inf"' and `"infinity"' are converted to oo, or to the largest
     representable value if the floating-point format doesn't support
     infinities.  You can prepend a `"+"' or `"-"' to specify the sign.
     Case is ignored when scanning these strings.

     The strings `"nan"' and `"nan(CHARS...)"' are converted to NaN.
     Again, case is ignored.  If CHARS... are provided, they are used
     in some unspecified fashion to select a particular representation
     of NaN (there can be several).

     Since zero is a valid result as well as the value returned on
     error, you should check for errors in the same way as for
     `strtol', by examining ERRNO and TAILPTR.

 -- Function: float strtof (const char *STRING, char **TAILPTR)
 -- Function: long double strtold (const char *STRING, char **TAILPTR)
     These functions are analogous to `strtod', but return `float' and
     `long double' values respectively.  They report errors in the same
     way as `strtod'.  `strtof' can be substantially faster than
     `strtod', but has less precision; conversely, `strtold' can be
     much slower but has more precision (on systems where `long double'
     is a separate type).

     These functions have been GNU extensions and are new to ISO C99.

 -- Function: double wcstod (const wchar_t *restrict STRING, wchar_t
          **restrict TAILPTR)
 -- Function: float wcstof (const wchar_t *STRING, wchar_t **TAILPTR)
 -- Function: long double wcstold (const wchar_t *STRING, wchar_t
          **TAILPTR)
     The `wcstod', `wcstof', and `wcstol' functions are equivalent in
     nearly all aspect to the `strtod', `strtof', and `strtold'
     functions but it handles wide character string.

     The `wcstod' function was introduced in Amendment 1 of ISO C90.
     The `wcstof' and `wcstold' functions were introduced in ISO C99.

 -- Function: double atof (const char *STRING)
     This function is similar to the `strtod' function, except that it
     need not detect overflow and underflow errors.  The `atof' function
     is provided mostly for compatibility with existing code; using
     `strtod' is more robust.

   The GNU C library also provides `_l' versions of these functions,
which take an additional argument, the locale to use in conversion.
*Note Parsing of Integers::.


File: libc.info,  Node: System V Number Conversion,  Prev: Parsing of Numbers,  Up: Arithmetic

20.12 Old-fashioned System V number-to-string functions
=======================================================

The old System V C library provided three functions to convert numbers
to strings, with unusual and hard-to-use semantics.  The GNU C library
also provides these functions and some natural extensions.

   These functions are only available in glibc and on systems descended
from AT&T Unix.  Therefore, unless these functions do precisely what you
need, it is better to use `sprintf', which is standard.

   All these functions are defined in `stdlib.h'.

 -- Function: char * ecvt (double VALUE, int NDIGIT, int *DECPT, int
          *NEG)
     The function `ecvt' converts the floating-point number VALUE to a
     string with at most NDIGIT decimal digits.  The returned string
     contains no decimal point or sign. The first digit of the string
     is non-zero (unless VALUE is actually zero) and the last digit is
     rounded to nearest.  `*DECPT' is set to the index in the string of
     the first digit after the decimal point.  `*NEG' is set to a
     nonzero value if VALUE is negative, zero otherwise.

     If NDIGIT decimal digits would exceed the precision of a `double'
     it is reduced to a system-specific value.

     The returned string is statically allocated and overwritten by
     each call to `ecvt'.

     If VALUE is zero, it is implementation defined whether `*DECPT' is
     `0' or `1'.

     For example: `ecvt (12.3, 5, &d, &n)' returns `"12300"' and sets D
     to `2' and N to `0'.

 -- Function: char * fcvt (double VALUE, int NDIGIT, int *DECPT, int
          *NEG)
     The function `fcvt' is like `ecvt', but NDIGIT specifies the
     number of digits after the decimal point.  If NDIGIT is less than
     zero, VALUE is rounded to the NDIGIT+1'th place to the left of the
     decimal point.  For example, if NDIGIT is `-1', VALUE will be
     rounded to the nearest 10.  If NDIGIT is negative and larger than
     the number of digits to the left of the decimal point in VALUE,
     VALUE will be rounded to one significant digit.

     If NDIGIT decimal digits would exceed the precision of a `double'
     it is reduced to a system-specific value.

     The returned string is statically allocated and overwritten by
     each call to `fcvt'.

 -- Function: char * gcvt (double VALUE, int NDIGIT, char *BUF)
     `gcvt' is functionally equivalent to `sprintf(buf, "%*g", ndigit,
     value'.  It is provided only for compatibility's sake.  It returns
     BUF.

     If NDIGIT decimal digits would exceed the precision of a `double'
     it is reduced to a system-specific value.

   As extensions, the GNU C library provides versions of these three
functions that take `long double' arguments.

 -- Function: char * qecvt (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG)
     This function is equivalent to `ecvt' except that it takes a `long
     double' for the first parameter and that NDIGIT is restricted by
     the precision of a `long double'.

 -- Function: char * qfcvt (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG)
     This function is equivalent to `fcvt' except that it takes a `long
     double' for the first parameter and that NDIGIT is restricted by
     the precision of a `long double'.

 -- Function: char * qgcvt (long double VALUE, int NDIGIT, char *BUF)
     This function is equivalent to `gcvt' except that it takes a `long
     double' for the first parameter and that NDIGIT is restricted by
     the precision of a `long double'.

   The `ecvt' and `fcvt' functions, and their `long double'
equivalents, all return a string located in a static buffer which is
overwritten by the next call to the function.  The GNU C library
provides another set of extended functions which write the converted
string into a user-supplied buffer.  These have the conventional `_r'
suffix.

   `gcvt_r' is not necessary, because `gcvt' already uses a
user-supplied buffer.

 -- Function: int ecvt_r (double VALUE, int NDIGIT, int *DECPT, int
          *NEG, char *BUF, size_t LEN)
     The `ecvt_r' function is the same as `ecvt', except that it places
     its result into the user-specified buffer pointed to by BUF, with
     length LEN.  The return value is `-1' in case of an error and zero
     otherwise.

     This function is a GNU extension.

 -- Function: int fcvt_r (double VALUE, int NDIGIT, int *DECPT, int
          *NEG, char *BUF, size_t LEN)
     The `fcvt_r' function is the same as `fcvt', except that it places
     its result into the user-specified buffer pointed to by BUF, with
     length LEN.  The return value is `-1' in case of an error and zero
     otherwise.

     This function is a GNU extension.

 -- Function: int qecvt_r (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG, char *BUF, size_t LEN)
     The `qecvt_r' function is the same as `qecvt', except that it
     places its result into the user-specified buffer pointed to by
     BUF, with length LEN.  The return value is `-1' in case of an
     error and zero otherwise.

     This function is a GNU extension.

 -- Function: int qfcvt_r (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG, char *BUF, size_t LEN)
     The `qfcvt_r' function is the same as `qfcvt', except that it
     places its result into the user-specified buffer pointed to by
     BUF, with length LEN.  The return value is `-1' in case of an
     error and zero otherwise.

     This function is a GNU extension.


File: libc.info,  Node: Date and Time,  Next: Resource Usage And Limitation,  Prev: Arithmetic,  Up: Top

21 Date and Time
****************

This chapter describes functions for manipulating dates and times,
including functions for determining what time it is and conversion
between different time representations.

* Menu:

* Time Basics::                 Concepts and definitions.
* Elapsed Time::                Data types to represent elapsed times
* Processor And CPU Time::      Time a program has spent executing.
* Calendar Time::               Manipulation of ``real'' dates and times.
* Setting an Alarm::            Sending a signal after a specified time.
* Sleeping::                    Waiting for a period of time.


File: libc.info,  Node: Time Basics,  Next: Elapsed Time,  Up: Date and Time

21.1 Time Basics
================

Discussing time in a technical manual can be difficult because the word
"time" in English refers to lots of different things.  In this manual,
we use a rigorous terminology to avoid confusion, and the only thing we
use the simple word "time" for is to talk about the abstract concept.

   A "calendar time" is a point in the time continuum, for example
November 4, 1990 at 18:02.5 UTC.  Sometimes this is called "absolute
time".  

   We don't speak of a "date", because that is inherent in a calendar
time.  

   An "interval" is a contiguous part of the time continuum between two
calendar times, for example the hour between 9:00 and 10:00 on July 4,
1980.  

   An "elapsed time" is the length of an interval, for example, 35
minutes.  People sometimes sloppily use the word "interval" to refer to
the elapsed time of some interval.  

   An "amount of time" is a sum of elapsed times, which need not be of
any specific intervals.  For example, the amount of time it takes to
read a book might be 9 hours, independently of when and in how many
sittings it is read.

   A "period" is the elapsed time of an interval between two events,
especially when they are part of a sequence of regularly repeating
events.  

   "CPU time" is like calendar time, except that it is based on the
subset of the time continuum when a particular process is actively
using a CPU.  CPU time is, therefore, relative to a process.  

   "Processor time" is an amount of time that a CPU is in use.  In
fact, it's a basic system resource, since there's a limit to how much
can exist in any given interval (that limit is the elapsed time of the
interval times the number of CPUs in the processor).  People often call
this CPU time, but we reserve the latter term in this manual for the
definition above.  


File: libc.info,  Node: Elapsed Time,  Next: Processor And CPU Time,  Prev: Time Basics,  Up: Date and Time

21.2 Elapsed Time
=================

One way to represent an elapsed time is with a simple arithmetic data
type, as with the following function to compute the elapsed time between
two calendar times.  This function is declared in `time.h'.

 -- Function: double difftime (time_t TIME1, time_t TIME0)
     The `difftime' function returns the number of seconds of elapsed
     time between calendar time TIME1 and calendar time TIME0, as a
     value of type `double'.  The difference ignores leap seconds
     unless leap second support is enabled.

     In the GNU system, you can simply subtract `time_t' values.  But on
     other systems, the `time_t' data type might use some other encoding
     where subtraction doesn't work directly.

   The GNU C library provides two data types specifically for
representing an elapsed time.  They are used by various GNU C library
functions, and you can use them for your own purposes too.  They're
exactly the same except that one has a resolution in microseconds, and
the other, newer one, is in nanoseconds.

 -- Data Type: struct timeval
     The `struct timeval' structure represents an elapsed time.  It is
     declared in `sys/time.h' and has the following members:

    `long int tv_sec'
          This represents the number of whole seconds of elapsed time.

    `long int tv_usec'
          This is the rest of the elapsed time (a fraction of a second),
          represented as the number of microseconds.  It is always less
          than one million.


 -- Data Type: struct timespec
     The `struct timespec' structure represents an elapsed time.  It is
     declared in `time.h' and has the following members:

    `long int tv_sec'
          This represents the number of whole seconds of elapsed time.

    `long int tv_nsec'
          This is the rest of the elapsed time (a fraction of a second),
          represented as the number of nanoseconds.  It is always less
          than one billion.


   It is often necessary to subtract two values of type
`struct timeval' or `struct timespec'.  Here is the best way to do
this.  It works even on some peculiar operating systems where the
`tv_sec' member has an unsigned type.

     /* Subtract the `struct timeval' values X and Y,
        storing the result in RESULT.
        Return 1 if the difference is negative, otherwise 0.  */

     int
     timeval_subtract (result, x, y)
          struct timeval *result, *x, *y;
     {
       /* Perform the carry for the later subtraction by updating Y. */
       if (x->tv_usec < y->tv_usec) {
         int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
         y->tv_usec -= 1000000 * nsec;
         y->tv_sec += nsec;
       }
       if (x->tv_usec - y->tv_usec > 1000000) {
         int nsec = (x->tv_usec - y->tv_usec) / 1000000;
         y->tv_usec += 1000000 * nsec;
         y->tv_sec -= nsec;
       }

       /* Compute the time remaining to wait.
          `tv_usec' is certainly positive. */
       result->tv_sec = x->tv_sec - y->tv_sec;
       result->tv_usec = x->tv_usec - y->tv_usec;

       /* Return 1 if result is negative. */
       return x->tv_sec < y->tv_sec;
     }

   Common functions that use `struct timeval' are `gettimeofday' and
`settimeofday'.

   There are no GNU C library functions specifically oriented toward
dealing with elapsed times, but the calendar time, processor time, and
alarm and sleeping functions have a lot to do with them.


File: libc.info,  Node: Processor And CPU Time,  Next: Calendar Time,  Prev: Elapsed Time,  Up: Date and Time

21.3 Processor And CPU Time
===========================

If you're trying to optimize your program or measure its efficiency,
it's very useful to know how much processor time it uses.  For that,
calendar time and elapsed times are useless because a process may spend
time waiting for I/O or for other processes to use the CPU.  However,
you can get the information with the functions in this section.

   CPU time (*note Time Basics::) is represented by the data type
`clock_t', which is a number of "clock ticks".  It gives the total
amount of time a process has actively used a CPU since some arbitrary
event.  On the GNU system, that event is the creation of the process.
While arbitrary in general, the event is always the same event for any
particular process, so you can always measure how much time on the CPU
a particular computation takes by examining the process' CPU time
before and after the computation.  

   In the GNU system, `clock_t' is equivalent to `long int' and
`CLOCKS_PER_SEC' is an integer value.  But in other systems, both
`clock_t' and the macro `CLOCKS_PER_SEC' can be either integer or
floating-point types.  Casting CPU time values to `double', as in the
example above, makes sure that operations such as arithmetic and
printing work properly and consistently no matter what the underlying
representation is.

   Note that the clock can wrap around.  On a 32bit system with
`CLOCKS_PER_SEC' set to one million this function will return the same
value approximately every 72 minutes.

   For additional functions to examine a process' use of processor time,
and to control it, see *Note Resource Usage And Limitation::.

* Menu:

* CPU Time::                    The `clock' function.
* Processor Time::              The `times' function.


File: libc.info,  Node: CPU Time,  Next: Processor Time,  Up: Processor And CPU Time

21.3.1 CPU Time Inquiry
-----------------------

To get a process' CPU time, you can use the `clock' function.  This
facility is declared in the header file `time.h'.  

   In typical usage, you call the `clock' function at the beginning and
end of the interval you want to time, subtract the values, and then
divide by `CLOCKS_PER_SEC' (the number of clock ticks per second) to
get processor time, like this:

     #include <time.h>

     clock_t start, end;
     double cpu_time_used;

     start = clock();
     ... /* Do the work. */
     end = clock();
     cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

   Do not use a single CPU time as an amount of time; it doesn't work
that way.  Either do a subtraction as shown above or query processor
time directly.  *Note Processor Time::.

   Different computers and operating systems vary wildly in how they
keep track of CPU time.  It's common for the internal processor clock
to have a resolution somewhere between a hundredth and millionth of a
second.

 -- Macro: int CLOCKS_PER_SEC
     The value of this macro is the number of clock ticks per second
     measured by the `clock' function.  POSIX requires that this value
     be one million independent of the actual resolution.

 -- Macro: int CLK_TCK
     This is an obsolete name for `CLOCKS_PER_SEC'.

 -- Data Type: clock_t
     This is the type of the value returned by the `clock' function.
     Values of type `clock_t' are numbers of clock ticks.

 -- Function: clock_t clock (void)
     This function returns the calling process' current CPU time.  If
     the CPU time is not available or cannot be represented, `clock'
     returns the value `(clock_t)(-1)'.


File: libc.info,  Node: Processor Time,  Prev: CPU Time,  Up: Processor And CPU Time

21.3.2 Processor Time Inquiry
-----------------------------

The `times' function returns information about a process' consumption
of processor time in a `struct tms' object, in addition to the process'
CPU time.  *Note Time Basics::.  You should include the header file
`sys/times.h' to use this facility.  

 -- Data Type: struct tms
     The `tms' structure is used to return information about process
     times.  It contains at least the following members:

    `clock_t tms_utime'
          This is the total processor time the calling process has used
          in executing the instructions of its program.

    `clock_t tms_stime'
          This is the processor time the system has used on behalf of
          the calling process.

    `clock_t tms_cutime'
          This is the sum of the `tms_utime' values and the `tms_cutime'
          values of all terminated child processes of the calling
          process, whose status has been reported to the parent process
          by `wait' or `waitpid'; see *Note Process Completion::.  In
          other words, it represents the total processor time used in
          executing the instructions of all the terminated child
          processes of the calling process, excluding child processes
          which have not yet been reported by `wait' or `waitpid'.  

    `clock_t tms_cstime'
          This is similar to `tms_cutime', but represents the total
          processor time system has used on behalf of all the
          terminated child processes of the calling process.

     All of the times are given in numbers of clock ticks.  Unlike CPU
     time, these are the actual amounts of time; not relative to any
     event.  *Note Creating a Process::.

 -- Function: clock_t times (struct tms *BUFFER)
     The `times' function stores the processor time information for the
     calling process in BUFFER.

     The return value is the calling process' CPU time (the same value
     you get from `clock()'.  `times' returns `(clock_t)(-1)' to
     indicate failure.

   *Portability Note:* The `clock' function described in *Note CPU
Time:: is specified by the ISO C standard.  The `times' function is a
feature of POSIX.1.  In the GNU system, the CPU time is defined to be
equivalent to the sum of the `tms_utime' and `tms_stime' fields
returned by `times'.


File: libc.info,  Node: Calendar Time,  Next: Setting an Alarm,  Prev: Processor And CPU Time,  Up: Date and Time

21.4 Calendar Time
==================

This section describes facilities for keeping track of calendar time.
*Note Time Basics::.

   The GNU C library represents calendar time three ways:

   * "Simple time" (the `time_t' data type) is a compact
     representation, typically giving the number of seconds of elapsed
     time since some implementation-specific base time.  

   * There is also a "high-resolution time" representation.  Like simple
     time, this represents a calendar time as an elapsed time since a
     base time, but instead of measuring in whole seconds, it uses a
     `struct timeval' data type, which includes fractions of a second.
     Use this time representation instead of simple time when you need
     greater precision.  

   * "Local time" or "broken-down time" (the `struct tm' data type)
     represents a calendar time as a set of components specifying the
     year, month, and so on in the Gregorian calendar, for a specific
     time zone.  This calendar time representation is usually used only
     to communicate with people.  

* Menu:

* Simple Calendar Time::        Facilities for manipulating calendar time.
* High-Resolution Calendar::    A time representation with greater precision.
* Broken-down Time::            Facilities for manipulating local time.
* High Accuracy Clock::         Maintaining a high accuracy system clock.
* Formatting Calendar Time::    Converting times to strings.
* Parsing Date and Time::       Convert textual time and date information back
                                 into broken-down time values.
* TZ Variable::                 How users specify the time zone.
* Time Zone Functions::         Functions to examine or specify the time zone.
* Time Functions Example::      An example program showing use of some of
				 the time functions.


File: libc.info,  Node: Simple Calendar Time,  Next: High-Resolution Calendar,  Up: Calendar Time

21.4.1 Simple Calendar Time
---------------------------

This section describes the `time_t' data type for representing calendar
time as simple time, and the functions which operate on simple time
objects.  These facilities are declared in the header file `time.h'.  

 -- Data Type: time_t
     This is the data type used to represent simple time.  Sometimes,
     it also represents an elapsed time.  When interpreted as a
     calendar time value, it represents the number of seconds elapsed
     since 00:00:00 on January 1, 1970, Coordinated Universal Time.
     (This calendar time is sometimes referred to as the "epoch".)
     POSIX requires that this count not include leap seconds, but on
     some systems this count includes leap seconds if you set `TZ' to
     certain values (*note TZ Variable::).

     Note that a simple time has no concept of local time zone.
     Calendar Time T is the same instant in time regardless of where on
     the globe the computer is.

     In the GNU C library, `time_t' is equivalent to `long int'.  In
     other systems, `time_t' might be either an integer or
     floating-point type.

   The function `difftime' tells you the elapsed time between two
simple calendar times, which is not always as easy to compute as just
subtracting.  *Note Elapsed Time::.

 -- Function: time_t time (time_t *RESULT)
     The `time' function returns the current calendar time as a value of
     type `time_t'.  If the argument RESULT is not a null pointer, the
     calendar time value is also stored in `*RESULT'.  If the current
     calendar time is not available, the value `(time_t)(-1)' is
     returned.

 -- Function: int stime (time_t *NEWTIME)
     `stime' sets the system clock, i.e., it tells the system that the
     current calendar time is NEWTIME, where `newtime' is interpreted
     as described in the above definition of `time_t'.

     `settimeofday' is a newer function which sets the system clock to
     better than one second precision.  `settimeofday' is generally a
     better choice than `stime'.  *Note High-Resolution Calendar::.

     Only the superuser can set the system clock.

     If the function succeeds, the return value is zero.  Otherwise, it
     is `-1' and `errno' is set accordingly:

    `EPERM'
          The process is not superuser.


File: libc.info,  Node: High-Resolution Calendar,  Next: Broken-down Time,  Prev: Simple Calendar Time,  Up: Calendar Time

21.4.2 High-Resolution Calendar
-------------------------------

The `time_t' data type used to represent simple times has a resolution
of only one second.  Some applications need more precision.

   So, the GNU C library also contains functions which are capable of
representing calendar times to a higher resolution than one second.  The
functions and the associated data types described in this section are
declared in `sys/time.h'.  

 -- Data Type: struct timezone
     The `struct timezone' structure is used to hold minimal information
     about the local time zone.  It has the following members:

    `int tz_minuteswest'
          This is the number of minutes west of UTC.

    `int tz_dsttime'
          If nonzero, Daylight Saving Time applies during some part of
          the year.

     The `struct timezone' type is obsolete and should never be used.
     Instead, use the facilities described in *Note Time Zone
     Functions::.

 -- Function: int gettimeofday (struct timeval *TP, struct timezone
          *TZP)
     The `gettimeofday' function returns the current calendar time as
     the elapsed time since the epoch in the `struct timeval' structure
     indicated by TP.  (*note Elapsed Time:: for a description of
     `struct timeval').  Information about the time zone is returned in
     the structure pointed at TZP.  If the TZP argument is a null
     pointer, time zone information is ignored.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error condition is defined for this function:

    `ENOSYS'
          The operating system does not support getting time zone
          information, and TZP is not a null pointer.  The GNU
          operating system does not support using `struct timezone' to
          represent time zone information; that is an obsolete feature
          of 4.3 BSD.  Instead, use the facilities described in *Note
          Time Zone Functions::.

 -- Function: int settimeofday (const struct timeval *TP, const struct
          timezone *TZP)
     The `settimeofday' function sets the current calendar time in the
     system clock according to the arguments.  As for `gettimeofday',
     the calendar time is represented as the elapsed time since the
     epoch.  As for `gettimeofday', time zone information is ignored if
     TZP is a null pointer.

     You must be a privileged user in order to use `settimeofday'.

     Some kernels automatically set the system clock from some source
     such as a hardware clock when they start up.  Others, including
     Linux, place the system clock in an "invalid" state (in which
     attempts to read the clock fail).  A call of `stime' removes the
     system clock from an invalid state, and system startup scripts
     typically run a program that calls `stime'.

     `settimeofday' causes a sudden jump forwards or backwards, which
     can cause a variety of problems in a system.  Use `adjtime' (below)
     to make a smooth transition from one time to another by temporarily
     speeding up or slowing down the clock.

     With a Linux kernel, `adjtimex' does the same thing and can also
     make permanent changes to the speed of the system clock so it
     doesn't need to be corrected as often.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EPERM'
          This process cannot set the clock because it is not
          privileged.

    `ENOSYS'
          The operating system does not support setting time zone
          information, and TZP is not a null pointer.

 -- Function: int adjtime (const struct timeval *DELTA, struct timeval
          *OLDDELTA)
     This function speeds up or slows down the system clock in order to
     make a gradual adjustment.  This ensures that the calendar time
     reported by the system clock is always monotonically increasing,
     which might not happen if you simply set the clock.

     The DELTA argument specifies a relative adjustment to be made to
     the clock time.  If negative, the system clock is slowed down for a
     while until it has lost this much elapsed time.  If positive, the
     system clock is speeded up for a while.

     If the OLDDELTA argument is not a null pointer, the `adjtime'
     function returns information about any previous time adjustment
     that has not yet completed.

     This function is typically used to synchronize the clocks of
     computers in a local network.  You must be a privileged user to
     use it.

     With a Linux kernel, you can use the `adjtimex' function to
     permanently change the clock speed.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error condition is defined for this function:

    `EPERM'
          You do not have privilege to set the time.

   *Portability Note:*  The `gettimeofday', `settimeofday', and
`adjtime' functions are derived from BSD.

   Symbols for the following function are declared in `sys/timex.h'.

 -- Function: int adjtimex (struct timex *TIMEX)
     `adjtimex' is functionally identical to `ntp_adjtime'.  *Note High
     Accuracy Clock::.

     This function is present only with a Linux kernel.



File: libc.info,  Node: Broken-down Time,  Next: High Accuracy Clock,  Prev: High-Resolution Calendar,  Up: Calendar Time

21.4.3 Broken-down Time
-----------------------

Calendar time is represented by the usual GNU C library functions as an
elapsed time since a fixed base calendar time.  This is convenient for
computation, but has no relation to the way people normally think of
calendar time.  By contrast, "broken-down time" is a binary
representation of calendar time separated into year, month, day, and so
on.  Broken-down time values are not useful for calculations, but they
are useful for printing human readable time information.

   A broken-down time value is always relative to a choice of time
zone, and it also indicates which time zone that is.

   The symbols in this section are declared in the header file `time.h'.

 -- Data Type: struct tm
     This is the data type used to represent a broken-down time.  The
     structure contains at least the following members, which can
     appear in any order.

    `int tm_sec'
          This is the number of full seconds since the top of the
          minute (normally in the range `0' through `59', but the
          actual upper limit is `60', to allow for leap seconds if leap
          second support is available).  

    `int tm_min'
          This is the number of full minutes since the top of the hour
          (in the range `0' through `59').

    `int tm_hour'
          This is the number of full hours past midnight (in the range
          `0' through `23').

    `int tm_mday'
          This is the ordinal day of the month (in the range `1'
          through `31').  Watch out for this one!  As the only ordinal
          number in the structure, it is inconsistent with the rest of
          the structure.

    `int tm_mon'
          This is the number of full calendar months since the
          beginning of the year (in the range `0' through `11').  Watch
          out for this one!  People usually use ordinal numbers for
          month-of-year (where January = 1).

    `int tm_year'
          This is the number of full calendar years since 1900.

    `int tm_wday'
          This is the number of full days since Sunday (in the range
          `0' through `6').

    `int tm_yday'
          This is the number of full days since the beginning of the
          year (in the range `0' through `365').

    `int tm_isdst'
          This is a flag that indicates whether Daylight Saving Time is
          (or was, or will be) in effect at the time described.  The
          value is positive if Daylight Saving Time is in effect, zero
          if it is not, and negative if the information is not
          available.

    `long int tm_gmtoff'
          This field describes the time zone that was used to compute
          this broken-down time value, including any adjustment for
          daylight saving; it is the number of seconds that you must
          add to UTC to get local time.  You can also think of this as
          the number of seconds east of UTC.  For example, for U.S.
          Eastern Standard Time, the value is `-5*60*60'.  The
          `tm_gmtoff' field is derived from BSD and is a GNU library
          extension; it is not visible in a strict ISO C environment.

    `const char *tm_zone'
          This field is the name for the time zone that was used to
          compute this broken-down time value.  Like `tm_gmtoff', this
          field is a BSD and GNU extension, and is not visible in a
          strict ISO C environment.

 -- Function: struct tm * localtime (const time_t *TIME)
     The `localtime' function converts the simple time pointed to by
     TIME to broken-down time representation, expressed relative to the
     user's specified time zone.

     The return value is a pointer to a static broken-down time
     structure, which might be overwritten by subsequent calls to
     `ctime', `gmtime', or `localtime'.  (But no other library function
     overwrites the contents of this object.)

     The return value is the null pointer if TIME cannot be represented
     as a broken-down time; typically this is because the year cannot
     fit into an `int'.

     Calling `localtime' has one other effect: it sets the variable
     `tzname' with information about the current time zone.  *Note Time
     Zone Functions::.

   Using the `localtime' function is a big problem in multi-threaded
programs.  The result is returned in a static buffer and this is used in
all threads.  POSIX.1c introduced a variant of this function.

 -- Function: struct tm * localtime_r (const time_t *TIME, struct tm
          *RESULTP)
     The `localtime_r' function works just like the `localtime'
     function.  It takes a pointer to a variable containing a simple
     time and converts it to the broken-down time format.

     But the result is not placed in a static buffer.  Instead it is
     placed in the object of type `struct tm' to which the parameter
     RESULTP points.

     If the conversion is successful the function returns a pointer to
     the object the result was written into, i.e., it returns RESULTP.

 -- Function: struct tm * gmtime (const time_t *TIME)
     This function is similar to `localtime', except that the
     broken-down time is expressed as Coordinated Universal Time (UTC)
     (formerly called Greenwich Mean Time (GMT)) rather than relative
     to a local time zone.


   As for the `localtime' function we have the problem that the result
is placed in a static variable.  POSIX.1c also provides a replacement
for `gmtime'.

 -- Function: struct tm * gmtime_r (const time_t *TIME, struct tm
          *RESULTP)
     This function is similar to `localtime_r', except that it converts
     just like `gmtime' the given time as Coordinated Universal Time.

     If the conversion is successful the function returns a pointer to
     the object the result was written into, i.e., it returns RESULTP.

 -- Function: time_t mktime (struct tm *BROKENTIME)
     The `mktime' function is used to convert a broken-down time
     structure to a simple time representation.  It also "normalizes"
     the contents of the broken-down time structure, by filling in the
     day of week and day of year based on the other date and time
     components.

     The `mktime' function ignores the specified contents of the
     `tm_wday' and `tm_yday' members of the broken-down time structure.
     It uses the values of the other components to determine the
     calendar time; it's permissible for these components to have
     unnormalized values outside their normal ranges.  The last thing
     that `mktime' does is adjust the components of the BROKENTIME
     structure (including the `tm_wday' and `tm_yday').

     If the specified broken-down time cannot be represented as a
     simple time, `mktime' returns a value of `(time_t)(-1)' and does
     not modify the contents of BROKENTIME.

     Calling `mktime' also sets the variable `tzname' with information
     about the current time zone.  *Note Time Zone Functions::.

 -- Function: time_t timelocal (struct tm *BROKENTIME)
     `timelocal' is functionally identical to `mktime', but more
     mnemonically named.  Note that it is the inverse of the `localtime'
     function.

     *Portability note:*  `mktime' is essentially universally
     available.  `timelocal' is rather rare.


 -- Function: time_t timegm (struct tm *BROKENTIME)
     `timegm' is functionally identical to `mktime' except it always
     takes the input values to be Coordinated Universal Time (UTC)
     regardless of any local time zone setting.

     Note that `timegm' is the inverse of `gmtime'.

     *Portability note:*  `mktime' is essentially universally
     available.  `timegm' is rather rare.  For the most portable
     conversion from a UTC broken-down time to a simple time, set the
     `TZ' environment variable to UTC, call `mktime', then set `TZ'
     back.



File: libc.info,  Node: High Accuracy Clock,  Next: Formatting Calendar Time,  Prev: Broken-down Time,  Up: Calendar Time

21.4.4 High Accuracy Clock
--------------------------

The `ntp_gettime' and `ntp_adjtime' functions provide an interface to
monitor and manipulate the system clock to maintain high accuracy time.
For example, you can fine tune the speed of the clock or synchronize
it with another time source.

   A typical use of these functions is by a server implementing the
Network Time Protocol to synchronize the clocks of multiple systems and
high precision clocks.

   These functions are declared in `sys/timex.h'.

 -- Data Type: struct ntptimeval
     This structure is used for information about the system clock.  It
     contains the following members:
    `struct timeval time'
          This is the current calendar time, expressed as the elapsed
          time since the epoch.  The `struct timeval' data type is
          described in *Note Elapsed Time::.

    `long int maxerror'
          This is the maximum error, measured in microseconds.  Unless
          updated via `ntp_adjtime' periodically, this value will reach
          some platform-specific maximum value.

    `long int esterror'
          This is the estimated error, measured in microseconds.  This
          value can be set by `ntp_adjtime' to indicate the estimated
          offset of the system clock from the true calendar time.

 -- Function: int ntp_gettime (struct ntptimeval *TPTR)
     The `ntp_gettime' function sets the structure pointed to by TPTR
     to current values.  The elements of the structure afterwards
     contain the values the timer implementation in the kernel assumes.
     They might or might not be correct.  If they are not a
     `ntp_adjtime' call is necessary.

     The return value is `0' on success and other values on failure.
     The following `errno' error conditions are defined for this
     function:

    `TIME_ERROR'
          The precision clock model is not properly set up at the
          moment, thus the clock must be considered unsynchronized, and
          the values should be treated with care.

 -- Data Type: struct timex
     This structure is used to control and monitor the system clock.  It
     contains the following members:
    `unsigned int modes'
          This variable controls whether and which values are set.
          Several symbolic constants have to be combined with _binary
          or_ to specify the effective mode.  These constants start
          with `MOD_'.

    `long int offset'
          This value indicates the current offset of the system clock
          from the true calendar time.  The value is given in
          microseconds.  If bit `MOD_OFFSET' is set in `modes', the
          offset (and possibly other dependent values) can be set.  The
          offset's absolute value must not exceed `MAXPHASE'.

    `long int frequency'
          This value indicates the difference in frequency between the
          true calendar time and the system clock.  The value is
          expressed as scaled PPM (parts per million, 0.0001%).  The
          scaling is `1 << SHIFT_USEC'.  The value can be set with bit
          `MOD_FREQUENCY', but the absolute value must not exceed
          `MAXFREQ'.

    `long int maxerror'
          This is the maximum error, measured in microseconds.  A new
          value can be set using bit `MOD_MAXERROR'.  Unless updated via
          `ntp_adjtime' periodically, this value will increase steadily
          and reach some platform-specific maximum value.

    `long int esterror'
          This is the estimated error, measured in microseconds.  This
          value can be set using bit `MOD_ESTERROR'.

    `int status'
          This variable reflects the various states of the clock
          machinery.  There are symbolic constants for the significant
          bits, starting with `STA_'.  Some of these flags can be
          updated using the `MOD_STATUS' bit.

    `long int constant'
          This value represents the bandwidth or stiffness of the PLL
          (phase locked loop) implemented in the kernel.  The value can
          be changed using bit `MOD_TIMECONST'.

    `long int precision'
          This value represents the accuracy or the maximum error when
          reading the system clock.  The value is expressed in
          microseconds.

    `long int tolerance'
          This value represents the maximum frequency error of the
          system clock in scaled PPM.  This value is used to increase
          the `maxerror' every second.

    `struct timeval time'
          The current calendar time.

    `long int tick'
          The elapsed time between clock ticks in microseconds.  A
          clock tick is a periodic timer interrupt on which the system
          clock is based.

    `long int ppsfreq'
          This is the first of a few optional variables that are
          present only if the system clock can use a PPS (pulse per
          second) signal to discipline the system clock.  The value is
          expressed in scaled PPM and it denotes the difference in
          frequency between the system clock and the PPS signal.

    `long int jitter'
          This value expresses a median filtered average of the PPS
          signal's dispersion in microseconds.

    `int shift'
          This value is a binary exponent for the duration of the PPS
          calibration interval, ranging from `PPS_SHIFT' to
          `PPS_SHIFTMAX'.

    `long int stabil'
          This value represents the median filtered dispersion of the
          PPS frequency in scaled PPM.

    `long int jitcnt'
          This counter represents the number of pulses where the jitter
          exceeded the allowed maximum `MAXTIME'.

    `long int calcnt'
          This counter reflects the number of successful calibration
          intervals.

    `long int errcnt'
          This counter represents the number of calibration errors
          (caused by large offsets or jitter).

    `long int stbcnt'
          This counter denotes the number of calibrations where the
          stability exceeded the threshold.

 -- Function: int ntp_adjtime (struct timex *TPTR)
     The `ntp_adjtime' function sets the structure specified by TPTR to
     current values.

     In addition, `ntp_adjtime' updates some settings to match what you
     pass to it in *TPTR.  Use the `modes' element of *TPTR to select
     what settings to update.  You can set `offset', `freq',
     `maxerror', `esterror', `status', `constant', and `tick'.

     `modes' = zero means set nothing.

     Only the superuser can update settings.

     The return value is `0' on success and other values on failure.
     The following `errno' error conditions are defined for this
     function:

    `TIME_ERROR'
          The high accuracy clock model is not properly set up at the
          moment, thus the clock must be considered unsynchronized, and
          the values should be treated with care.  Another reason could
          be that the specified new values are not allowed.

    `EPERM'
          The process specified a settings update, but is not superuser.


     For more details see RFC1305 (Network Time Protocol, Version 3) and
     related documents.

     *Portability note:* Early versions of the GNU C library did not
     have this function but did have the synonymous `adjtimex'.



File: libc.info,  Node: Formatting Calendar Time,  Next: Parsing Date and Time,  Prev: High Accuracy Clock,  Up: Calendar Time

21.4.5 Formatting Calendar Time
-------------------------------

The functions described in this section format calendar time values as
strings.  These functions are declared in the header file `time.h'.  

 -- Function: char * asctime (const struct tm *BROKENTIME)
     The `asctime' function converts the broken-down time value that
     BROKENTIME points to into a string in a standard format:

          "Tue May 21 13:46:22 1991\n"

     The abbreviations for the days of week are: `Sun', `Mon', `Tue',
     `Wed', `Thu', `Fri', and `Sat'.

     The abbreviations for the months are: `Jan', `Feb', `Mar', `Apr',
     `May', `Jun', `Jul', `Aug', `Sep', `Oct', `Nov', and `Dec'.

     The return value points to a statically allocated string, which
     might be overwritten by subsequent calls to `asctime' or `ctime'.
     (But no other library function overwrites the contents of this
     string.)

 -- Function: char * asctime_r (const struct tm *BROKENTIME, char
          *BUFFER)
     This function is similar to `asctime' but instead of placing the
     result in a static buffer it writes the string in the buffer
     pointed to by the parameter BUFFER.  This buffer should have room
     for at least 26 bytes, including the terminating null.

     If no error occurred the function returns a pointer to the string
     the result was written into, i.e., it returns BUFFER.  Otherwise
     return `NULL'.

 -- Function: char * ctime (const time_t *TIME)
     The `ctime' function is similar to `asctime', except that you
     specify the calendar time argument as a `time_t' simple time value
     rather than in broken-down local time format.  It is equivalent to

          asctime (localtime (TIME))

     `ctime' sets the variable `tzname', because `localtime' does so.
     *Note Time Zone Functions::.

 -- Function: char * ctime_r (const time_t *TIME, char *BUFFER)
     This function is similar to `ctime', but places the result in the
     string pointed to by BUFFER.  It is equivalent to (written using
     gcc extensions, *note Statement Exprs: (gcc)Statement Exprs.):

          ({ struct tm tm; asctime_r (localtime_r (time, &tm), buf); })

     If no error occurred the function returns a pointer to the string
     the result was written into, i.e., it returns BUFFER.  Otherwise
     return `NULL'.

 -- Function: size_t strftime (char *S, size_t SIZE, const char
          *TEMPLATE, const struct tm *BROKENTIME)
     This function is similar to the `sprintf' function (*note
     Formatted Input::), but the conversion specifications that can
     appear in the format template TEMPLATE are specialized for
     printing components of the date and time BROKENTIME according to
     the locale currently specified for time conversion (*note
     Locales::).

     Ordinary characters appearing in the TEMPLATE are copied to the
     output string S; this can include multibyte character sequences.
     Conversion specifiers are introduced by a `%' character, followed
     by an optional flag which can be one of the following.  These flags
     are all GNU extensions. The first three affect only the output of
     numbers:

    `_'
          The number is padded with spaces.

    `-'
          The number is not padded at all.

    `0'
          The number is padded with zeros even if the format specifies
          padding with spaces.

    `^'
          The output uses uppercase characters, but only if this is
          possible (*note Case Conversion::).

     The default action is to pad the number with zeros to keep it a
     constant width.  Numbers that do not have a range indicated below
     are never padded, since there is no natural width for them.

     Following the flag an optional specification of the width is
     possible.  This is specified in decimal notation.  If the natural
     size of the output is of the field has less than the specified
     number of characters, the result is written right adjusted and
     space padded to the given size.

     An optional modifier can follow the optional flag and width
     specification.  The modifiers, which were first standardized by
     POSIX.2-1992 and by ISO C99, are:

    `E'
          Use the locale's alternate representation for date and time.
          This modifier applies to the `%c', `%C', `%x', `%X', `%y' and
          `%Y' format specifiers.  In a Japanese locale, for example,
          `%Ex' might yield a date format based on the Japanese
          Emperors' reigns.

    `O'
          Use the locale's alternate numeric symbols for numbers.  This
          modifier applies only to numeric format specifiers.

     If the format supports the modifier but no alternate representation
     is available, it is ignored.

     The conversion specifier ends with a format specifier taken from
     the following list.  The whole `%' sequence is replaced in the
     output string as follows:

    `%a'
          The abbreviated weekday name according to the current locale.

    `%A'
          The full weekday name according to the current locale.

    `%b'
          The abbreviated month name according to the current locale.

    `%B'
          The full month name according to the current locale.

          Using `%B' together with `%d' produces grammatically
          incorrect results for some locales.

    `%c'
          The preferred calendar time representation for the current
          locale.

    `%C'
          The century of the year.  This is equivalent to the greatest
          integer not greater than the year divided by 100.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%d'
          The day of the month as a decimal number (range `01' through
          `31').

    `%D'
          The date using the format `%m/%d/%y'.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%e'
          The day of the month like with `%d', but padded with blank
          (range ` 1' through `31').

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%F'
          The date using the format `%Y-%m-%d'.  This is the form
          specified in the ISO 8601 standard and is the preferred form
          for all uses.

          This format was first standardized by ISO C99 and by
          POSIX.1-2001.

    `%g'
          The year corresponding to the ISO week number, but without
          the century (range `00' through `99').  This has the same
          format and value as `%y', except that if the ISO week number
          (see `%V') belongs to the previous or next year, that year is
          used instead.

          This format was first standardized by ISO C99 and by
          POSIX.1-2001.

    `%G'
          The year corresponding to the ISO week number.  This has the
          same format and value as `%Y', except that if the ISO week
          number (see `%V') belongs to the previous or next year, that
          year is used instead.

          This format was first standardized by ISO C99 and by
          POSIX.1-2001 but was previously available as a GNU extension.

    `%h'
          The abbreviated month name according to the current locale.
          The action is the same as for `%b'.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%H'
          The hour as a decimal number, using a 24-hour clock (range
          `00' through `23').

    `%I'
          The hour as a decimal number, using a 12-hour clock (range
          `01' through `12').

    `%j'
          The day of the year as a decimal number (range `001' through
          `366').

    `%k'
          The hour as a decimal number, using a 24-hour clock like
          `%H', but padded with blank (range ` 0' through `23').

          This format is a GNU extension.

    `%l'
          The hour as a decimal number, using a 12-hour clock like
          `%I', but padded with blank (range ` 1' through `12').

          This format is a GNU extension.

    `%m'
          The month as a decimal number (range `01' through `12').

    `%M'
          The minute as a decimal number (range `00' through `59').

    `%n'
          A single `\n' (newline) character.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%p'
          Either `AM' or `PM', according to the given time value; or the
          corresponding strings for the current locale.  Noon is
          treated as `PM' and midnight as `AM'.  In most locales
          `AM'/`PM' format is not supported, in such cases `"%p"'
          yields an empty string.

    `%P'
          Either `am' or `pm', according to the given time value; or the
          corresponding strings for the current locale, printed in
          lowercase characters.  Noon is treated as `pm' and midnight
          as `am'.  In most locales `AM'/`PM' format is not supported,
          in such cases `"%P"' yields an empty string.

          This format is a GNU extension.

    `%r'
          The complete calendar time using the AM/PM format of the
          current locale.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.  In the POSIX locale, this format is equivalent to
          `%I:%M:%S %p'.

    `%R'
          The hour and minute in decimal numbers using the format
          `%H:%M'.

          This format was first standardized by ISO C99 and by
          POSIX.1-2001 but was previously available as a GNU extension.

    `%s'
          The number of seconds since the epoch, i.e., since 1970-01-01
          00:00:00 UTC.  Leap seconds are not counted unless leap
          second support is available.

          This format is a GNU extension.

    `%S'
          The seconds as a decimal number (range `00' through `60').

    `%t'
          A single `\t' (tabulator) character.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%T'
          The time of day using decimal numbers using the format
          `%H:%M:%S'.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%u'
          The day of the week as a decimal number (range `1' through
          `7'), Monday being `1'.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%U'
          The week number of the current year as a decimal number
          (range `00' through `53'), starting with the first Sunday as
          the first day of the first week.  Days preceding the first
          Sunday in the year are considered to be in week `00'.

    `%V'
          The ISO 8601:1988 week number as a decimal number (range `01'
          through `53').  ISO weeks start with Monday and end with
          Sunday.  Week `01' of a year is the first week which has the
          majority of its days in that year; this is equivalent to the
          week containing the year's first Thursday, and it is also
          equivalent to the week containing January 4.  Week `01' of a
          year can contain days from the previous year.  The week
          before week `01' of a year is the last week (`52' or `53') of
          the previous year even if it contains days from the new year.

          This format was first standardized by POSIX.2-1992 and by
          ISO C99.

    `%w'
          The day of the week as a decimal number (range `0' through
          `6'), Sunday being `0'.

    `%W'
          The week number of the current year as a decimal number
          (range `00' through `53'), starting with the first Monday as
          the first day of the first week.  All days preceding the
          first Monday in the year are considered to be in week `00'.

    `%x'
          The preferred date representation for the current locale.

    `%X'
          The preferred time of day representation for the current
          locale.

    `%y'
          The year without a century as a decimal number (range `00'
          through `99').  This is equivalent to the year modulo 100.

    `%Y'
          The year as a decimal number, using the Gregorian calendar.
          Years before the year `1' are numbered `0', `-1', and so on.

    `%z'
          RFC 822/ISO 8601:1988 style numeric time zone (e.g., `-0600'
          or `+0100'), or nothing if no time zone is determinable.

          This format was first standardized by ISO C99 and by
          POSIX.1-2001 but was previously available as a GNU extension.

          In the POSIX locale, a full RFC 822 timestamp is generated by
          the format `"%a, %d %b %Y %H:%M:%S %z"' (or the equivalent
          `"%a, %d %b %Y %T %z"').

    `%Z'
          The time zone abbreviation (empty if the time zone can't be
          determined).

    `%%'
          A literal `%' character.

     The SIZE parameter can be used to specify the maximum number of
     characters to be stored in the array S, including the terminating
     null character.  If the formatted time requires more than SIZE
     characters, `strftime' returns zero and the contents of the array
     S are undefined.  Otherwise the return value indicates the number
     of characters placed in the array S, not including the terminating
     null character.

     _Warning:_ This convention for the return value which is prescribed
     in ISO C can lead to problems in some situations.  For certain
     format strings and certain locales the output really can be the
     empty string and this cannot be discovered by testing the return
     value only.  E.g., in most locales the AM/PM time format is not
     supported (most of the world uses the 24 hour time
     representation).  In such locales `"%p"' will return the empty
     string, i.e., the return value is zero.  To detect situations like
     this something similar to the following code should be used:

          buf[0] = '\1';
          len = strftime (buf, bufsize, format, tp);
          if (len == 0 && buf[0] != '\0')
            {
              /* Something went wrong in the strftime call.  */
              ...
            }

     If S is a null pointer, `strftime' does not actually write
     anything, but instead returns the number of characters it would
     have written.

     According to POSIX.1 every call to `strftime' implies a call to
     `tzset'.  So the contents of the environment variable `TZ' is
     examined before any output is produced.

     For an example of `strftime', see *Note Time Functions Example::.

 -- Function: size_t wcsftime (wchar_t *S, size_t SIZE, const wchar_t
          *TEMPLATE, const struct tm *BROKENTIME)
     The `wcsftime' function is equivalent to the `strftime' function
     with the difference that it operates on wide character strings.
     The buffer where the result is stored, pointed to by S, must be an
     array of wide characters.  The parameter SIZE which specifies the
     size of the output buffer gives the number of wide character, not
     the number of bytes.

     Also the format string TEMPLATE is a wide character string.  Since
     all characters needed to specify the format string are in the basic
     character set it is portably possible to write format strings in
     the C source code using the `L"..."' notation.  The parameter
     BROKENTIME has the same meaning as in the `strftime' call.

     The `wcsftime' function supports the same flags, modifiers, and
     format specifiers as the `strftime' function.

     The return value of `wcsftime' is the number of wide characters
     stored in `s'.  When more characters would have to be written than
     can be placed in the buffer S the return value is zero, with the
     same problems indicated in the `strftime' documentation.


File: libc.info,  Node: Parsing Date and Time,  Next: TZ Variable,  Prev: Formatting Calendar Time,  Up: Calendar Time

21.4.6 Convert textual time and date information back
-----------------------------------------------------

The ISO C standard does not specify any functions which can convert the
output of the `strftime' function back into a binary format.  This led
to a variety of more-or-less successful implementations with different
interfaces over the years.  Then the Unix standard was extended by the
addition of two functions: `strptime' and `getdate'.  Both have strange
interfaces but at least they are widely available.

* Menu:

* Low-Level Time String Parsing::  Interpret string according to given format.
* General Time String Parsing::    User-friendly function to parse data and
                                    time strings.


File: libc.info,  Node: Low-Level Time String Parsing,  Next: General Time String Parsing,  Up: Parsing Date and Time

21.4.6.1 Interpret string according to given format
...................................................

The first function is rather low-level.  It is nevertheless frequently
used in software since it is better known.  Its interface and
implementation are heavily influenced by the `getdate' function, which
is defined and implemented in terms of calls to `strptime'.

 -- Function: char * strptime (const char *S, const char *FMT, struct
          tm *TP)
     The `strptime' function parses the input string S according to the
     format string FMT and stores its results in the structure TP.

     The input string could be generated by a `strftime' call or
     obtained any other way.  It does not need to be in a
     human-recognizable format; e.g. a date passed as `"02:1999:9"' is
     acceptable, even though it is ambiguous without context.  As long
     as the format string FMT matches the input string the function
     will succeed.

     The user has to make sure, though, that the input can be parsed in
     a unambiguous way.  The string `"1999112"' can be parsed using the
     format `"%Y%m%d"' as 1999-1-12, 1999-11-2, or even 19991-1-2.  It
     is necessary to add appropriate separators to reliably get results.

     The format string consists of the same components as the format
     string of the `strftime' function.  The only difference is that
     the flags `_', `-', `0', and `^' are not allowed.  Several of the
     distinct formats of `strftime' do the same work in `strptime'
     since differences like case of the input do not matter.  For
     reasons of symmetry all formats are supported, though.

     The modifiers `E' and `O' are also allowed everywhere the
     `strftime' function allows them.

     The formats are:

    `%a'
    `%A'
          The weekday name according to the current locale, in
          abbreviated form or the full name.

    `%b'
    `%B'
    `%h'
          The month name according to the current locale, in
          abbreviated form or the full name.

    `%c'
          The date and time representation for the current locale.

    `%Ec'
          Like `%c' but the locale's alternative date and time format
          is used.

    `%C'
          The century of the year.

          It makes sense to use this format only if the format string
          also contains the `%y' format.

    `%EC'
          The locale's representation of the period.

          Unlike `%C' it sometimes makes sense to use this format since
          some cultures represent years relative to the beginning of
          eras instead of using the Gregorian years.

    `%d'

    `%e'
          The day of the month as a decimal number (range `1' through
          `31').  Leading zeroes are permitted but not required.

    `%Od'
    `%Oe'
          Same as `%d' but using the locale's alternative numeric
          symbols.

          Leading zeroes are permitted but not required.

    `%D'
          Equivalent to `%m/%d/%y'.

    `%F'
          Equivalent to `%Y-%m-%d', which is the ISO 8601 date format.

          This is a GNU extension following an ISO C99 extension to
          `strftime'.

    `%g'
          The year corresponding to the ISO week number, but without
          the century (range `00' through `99').

          _Note:_ Currently, this is not fully implemented.  The format
          is recognized, input is consumed but no field in TM is set.

          This format is a GNU extension following a GNU extension of
          `strftime'.

    `%G'
          The year corresponding to the ISO week number.

          _Note:_ Currently, this is not fully implemented.  The format
          is recognized, input is consumed but no field in TM is set.

          This format is a GNU extension following a GNU extension of
          `strftime'.

    `%H'
    `%k'
          The hour as a decimal number, using a 24-hour clock (range
          `00' through `23').

          `%k' is a GNU extension following a GNU extension of
          `strftime'.

    `%OH'
          Same as `%H' but using the locale's alternative numeric
          symbols.

    `%I'
    `%l'
          The hour as a decimal number, using a 12-hour clock (range
          `01' through `12').

          `%l' is a GNU extension following a GNU extension of
          `strftime'.

    `%OI'
          Same as `%I' but using the locale's alternative numeric
          symbols.

    `%j'
          The day of the year as a decimal number (range `1' through
          `366').

          Leading zeroes are permitted but not required.

    `%m'
          The month as a decimal number (range `1' through `12').

          Leading zeroes are permitted but not required.

    `%Om'
          Same as `%m' but using the locale's alternative numeric
          symbols.

    `%M'
          The minute as a decimal number (range `0' through `59').

          Leading zeroes are permitted but not required.

    `%OM'
          Same as `%M' but using the locale's alternative numeric
          symbols.

    `%n'
    `%t'
          Matches any white space.

    `%p'

    `%P'
          The locale-dependent equivalent to `AM' or `PM'.

          This format is not useful unless `%I' or `%l' is also used.
          Another complication is that the locale might not define
          these values at all and therefore the conversion fails.

          `%P' is a GNU extension following a GNU extension to
          `strftime'.

    `%r'
          The complete time using the AM/PM format of the current
          locale.

          A complication is that the locale might not define this
          format at all and therefore the conversion fails.

    `%R'
          The hour and minute in decimal numbers using the format
          `%H:%M'.

          `%R' is a GNU extension following a GNU extension to
          `strftime'.

    `%s'
          The number of seconds since the epoch, i.e., since 1970-01-01
          00:00:00 UTC.  Leap seconds are not counted unless leap
          second support is available.

          `%s' is a GNU extension following a GNU extension to
          `strftime'.

    `%S'
          The seconds as a decimal number (range `0' through `60').

          Leading zeroes are permitted but not required.

          *NB:* The Unix specification says the upper bound on this
          value is `61', a result of a decision to allow double leap
          seconds.  You will not see the value `61' because no minute
          has more than one leap second, but the myth persists.

    `%OS'
          Same as `%S' but using the locale's alternative numeric
          symbols.

    `%T'
          Equivalent to the use of `%H:%M:%S' in this place.

    `%u'
          The day of the week as a decimal number (range `1' through
          `7'), Monday being `1'.

          Leading zeroes are permitted but not required.

          _Note:_ Currently, this is not fully implemented.  The format
          is recognized, input is consumed but no field in TM is set.

    `%U'
          The week number of the current year as a decimal number
          (range `0' through `53').

          Leading zeroes are permitted but not required.

    `%OU'
          Same as `%U' but using the locale's alternative numeric
          symbols.

    `%V'
          The ISO 8601:1988 week number as a decimal number (range `1'
          through `53').

          Leading zeroes are permitted but not required.

          _Note:_ Currently, this is not fully implemented.  The format
          is recognized, input is consumed but no field in TM is set.

    `%w'
          The day of the week as a decimal number (range `0' through
          `6'), Sunday being `0'.

          Leading zeroes are permitted but not required.

          _Note:_ Currently, this is not fully implemented.  The format
          is recognized, input is consumed but no field in TM is set.

    `%Ow'
          Same as `%w' but using the locale's alternative numeric
          symbols.

    `%W'
          The week number of the current year as a decimal number
          (range `0' through `53').

          Leading zeroes are permitted but not required.

          _Note:_ Currently, this is not fully implemented.  The format
          is recognized, input is consumed but no field in TM is set.

    `%OW'
          Same as `%W' but using the locale's alternative numeric
          symbols.

    `%x'
          The date using the locale's date format.

    `%Ex'
          Like `%x' but the locale's alternative data representation is
          used.

    `%X'
          The time using the locale's time format.

    `%EX'
          Like `%X' but the locale's alternative time representation is
          used.

    `%y'
          The year without a century as a decimal number (range `0'
          through `99').

          Leading zeroes are permitted but not required.

          Note that it is questionable to use this format without the
          `%C' format.  The `strptime' function does regard input
          values in the range 68 to 99 as the years 1969 to 1999 and
          the values 0 to 68 as the years 2000 to 2068.  But maybe this
          heuristic fails for some input data.

          Therefore it is best to avoid `%y' completely and use `%Y'
          instead.

    `%Ey'
          The offset from `%EC' in the locale's alternative
          representation.

    `%Oy'
          The offset of the year (from `%C') using the locale's
          alternative numeric symbols.

    `%Y'
          The year as a decimal number, using the Gregorian calendar.

    `%EY'
          The full alternative year representation.

    `%z'
          The offset from GMT in ISO 8601/RFC822 format.

    `%Z'
          The timezone name.

          _Note:_ Currently, this is not fully implemented.  The format
          is recognized, input is consumed but no field in TM is set.

    `%%'
          A literal `%' character.

     All other characters in the format string must have a matching
     character in the input string.  Exceptions are white spaces in the
     input string which can match zero or more whitespace characters in
     the format string.

     *Portability Note:* The XPG standard advises applications to use
     at least one whitespace character (as specified by `isspace') or
     other non-alphanumeric characters between any two conversion
     specifications.  The GNU C Library does not have this limitation
     but other libraries might have trouble parsing formats like
     `"%d%m%Y%H%M%S"'.

     The `strptime' function processes the input string from right to
     left.  Each of the three possible input elements (white space,
     literal, or format) are handled one after the other.  If the input
     cannot be matched to the format string the function stops.  The
     remainder of the format and input strings are not processed.

     The function returns a pointer to the first character it was
     unable to process.  If the input string contains more characters
     than required by the format string the return value points right
     after the last consumed input character.  If the whole input
     string is consumed the return value points to the `NULL' byte at
     the end of the string.  If an error occurs, i.e., `strptime' fails
     to match all of the format string, the function returns `NULL'.

   The specification of the function in the XPG standard is rather
vague, leaving out a few important pieces of information.  Most
importantly, it does not specify what happens to those elements of TM
which are not directly initialized by the different formats.  The
implementations on different Unix systems vary here.

   The GNU libc implementation does not touch those fields which are not
directly initialized.  Exceptions are the `tm_wday' and `tm_yday'
elements, which are recomputed if any of the year, month, or date
elements changed.  This has two implications:

   * Before calling the `strptime' function for a new input string, you
     should prepare the TM structure you pass.  Normally this will mean
     initializing all values are to zero.  Alternatively, you can set
     all fields to values like `INT_MAX', allowing you to determine
     which elements were set by the function call.  Zero does not work
     here since it is a valid value for many of the fields.

     Careful initialization is necessary if you want to find out
     whether a certain field in TM was initialized by the function call.

   * You can construct a `struct tm' value with several consecutive
     `strptime' calls.  A useful application of this is e.g. the parsing
     of two separate strings, one containing date information and the
     other time information.  By parsing one after the other without
     clearing the structure in-between, you can construct a complete
     broken-down time.

   The following example shows a function which parses a string which is
contains the date information in either US style or ISO 8601 form:

     const char *
     parse_date (const char *input, struct tm *tm)
     {
       const char *cp;

       /* First clear the result structure.  */
       memset (tm, '\0', sizeof (*tm));

       /* Try the ISO format first.  */
       cp = strptime (input, "%F", tm);
       if (cp == NULL)
         {
           /* Does not match.  Try the US form.  */
           cp = strptime (input, "%D", tm);
         }

       return cp;
     }


File: libc.info,  Node: General Time String Parsing,  Prev: Low-Level Time String Parsing,  Up: Parsing Date and Time

21.4.6.2 A More User-friendly Way to Parse Times and Dates
..........................................................

The Unix standard defines another function for parsing date strings.
The interface is weird, but if the function happens to suit your
application it is just fine.  It is problematic to use this function in
multi-threaded programs or libraries, since it returns a pointer to a
static variable, and uses a global variable and global state (an
environment variable).

 -- Variable: getdate_err
     This variable of type `int' contains the error code of the last
     unsuccessful call to `getdate'.  Defined values are:

    1
          The environment variable `DATEMSK' is not defined or null.

    2
          The template file denoted by the `DATEMSK' environment
          variable cannot be opened.

    3
          Information about the template file cannot retrieved.

    4
          The template file is not a regular file.

    5
          An I/O error occurred while reading the template file.

    6
          Not enough memory available to execute the function.

    7
          The template file contains no matching template.

    8
          The input date is invalid, but would match a template
          otherwise.  This includes dates like February 31st, and dates
          which cannot be represented in a `time_t' variable.

 -- Function: struct tm * getdate (const char *STRING)
     The interface to `getdate' is the simplest possible for a function
     to parse a string and return the value.  STRING is the input
     string and the result is returned in a statically-allocated
     variable.

     The details about how the string is processed are hidden from the
     user.  In fact, they can be outside the control of the program.
     Which formats are recognized is controlled by the file named by
     the environment variable `DATEMSK'.  This file should contain
     lines of valid format strings which could be passed to `strptime'.

     The `getdate' function reads these format strings one after the
     other and tries to match the input string.  The first line which
     completely matches the input string is used.

     Elements not initialized through the format string retain the
     values present at the time of the `getdate' function call.

     The formats recognized by `getdate' are the same as for
     `strptime'.  See above for an explanation.  There are only a few
     extensions to the `strptime' behavior:

        * If the `%Z' format is given the broken-down time is based on
          the current time of the timezone matched, not of the current
          timezone of the runtime environment.

          _Note_: This is not implemented (currently).  The problem is
          that timezone names are not unique.  If a fixed timezone is
          assumed for a given string (say `EST' meaning US East Coast
          time), then uses for countries other than the USA will fail.
          So far we have found no good solution to this.

        * If only the weekday is specified the selected day depends on
          the current date.  If the current weekday is greater or equal
          to the `tm_wday' value the current week's day is chosen,
          otherwise the day next week is chosen.

        * A similar heuristic is used when only the month is given and
          not the year.  If the month is greater than or equal to the
          current month, then the current year is used.  Otherwise it
          wraps to next year.  The first day of the month is assumed if
          one is not explicitly specified.

        * The current hour, minute, and second are used if the
          appropriate value is not set through the format.

        * If no date is given tomorrow's date is used if the time is
          smaller than the current time.  Otherwise today's date is
          taken.

     It should be noted that the format in the template file need not
     only contain format elements.  The following is a list of possible
     format strings (taken from the Unix standard):

          %m
          %A %B %d, %Y %H:%M:%S
          %A
          %B
          %m/%d/%y %I %p
          %d,%m,%Y %H:%M
          at %A the %dst of %B in %Y
          run job at %I %p,%B %dnd
          %A den %d. %B %Y %H.%M Uhr

     As you can see, the template list can contain very specific
     strings like `run job at %I %p,%B %dnd'.  Using the above list of
     templates and assuming the current time is Mon Sep 22 12:19:47 EDT
     1986 we can obtain the following results for the given input.

     Input          Match        Result
     Mon            %a           Mon Sep 22 12:19:47 EDT 1986
     Sun            %a           Sun Sep 28 12:19:47 EDT 1986
     Fri            %a           Fri Sep 26 12:19:47 EDT 1986
     September      %B           Mon Sep 1 12:19:47 EDT 1986
     January        %B           Thu Jan 1 12:19:47 EST 1987
     December       %B           Mon Dec 1 12:19:47 EST 1986
     Sep Mon        %b %a        Mon Sep 1 12:19:47 EDT 1986
     Jan Fri        %b %a        Fri Jan 2 12:19:47 EST 1987
     Dec Mon        %b %a        Mon Dec 1 12:19:47 EST 1986
     Jan Wed 1989   %b %a %Y     Wed Jan 4 12:19:47 EST 1989
     Fri 9          %a %H        Fri Sep 26 09:00:00 EDT 1986
     Feb 10:30      %b %H:%S     Sun Feb 1 10:00:30 EST 1987
     10:30          %H:%M        Tue Sep 23 10:30:00 EDT 1986
     13:30          %H:%M        Mon Sep 22 13:30:00 EDT 1986

     The return value of the function is a pointer to a static variable
     of type `struct tm', or a null pointer if an error occurred.  The
     result is only valid until the next `getdate' call, making this
     function unusable in multi-threaded applications.

     The `errno' variable is _not_ changed.  Error conditions are
     stored in the global variable `getdate_err'.  See the description
     above for a list of the possible error values.

     _Warning:_ The `getdate' function should _never_ be used in
     SUID-programs.  The reason is obvious: using the `DATEMSK'
     environment variable you can get the function to open any
     arbitrary file and chances are high that with some bogus input
     (such as a binary file) the program will crash.

 -- Function: int getdate_r (const char *STRING, struct tm *TP)
     The `getdate_r' function is the reentrant counterpart of
     `getdate'.  It does not use the global variable `getdate_err' to
     signal an error, but instead returns an error code.  The same error
     codes as described in the `getdate_err' documentation above are
     used, with 0 meaning success.

     Moreover, `getdate_r' stores the broken-down time in the variable
     of type `struct tm' pointed to by the second argument, rather than
     in a static variable.

     This function is not defined in the Unix standard.  Nevertheless
     it is available on some other Unix systems as well.

     The warning against using `getdate' in SUID-programs applies to
     `getdate_r' as well.


File: libc.info,  Node: TZ Variable,  Next: Time Zone Functions,  Prev: Parsing Date and Time,  Up: Calendar Time

21.4.7 Specifying the Time Zone with `TZ'
-----------------------------------------

In POSIX systems, a user can specify the time zone by means of the `TZ'
environment variable.  For information about how to set environment
variables, see *Note Environment Variables::.  The functions for
accessing the time zone are declared in `time.h'.  

   You should not normally need to set `TZ'.  If the system is
configured properly, the default time zone will be correct.  You might
set `TZ' if you are using a computer over a network from a different
time zone, and would like times reported to you in the time zone local
to you, rather than what is local to the computer.

   In POSIX.1 systems the value of the `TZ' variable can be in one of
three formats.  With the GNU C library, the most common format is the
last one, which can specify a selection from a large database of time
zone information for many regions of the world.  The first two formats
are used to describe the time zone information directly, which is both
more cumbersome and less precise.  But the POSIX.1 standard only
specifies the details of the first two formats, so it is good to be
familiar with them in case you come across a POSIX.1 system that doesn't
support a time zone information database.

   The first format is used when there is no Daylight Saving Time (or
summer time) in the local time zone:

     STD OFFSET

   The STD string specifies the name of the time zone.  It must be
three or more characters long and must not contain a leading colon,
embedded digits, commas, nor plus and minus signs.  There is no space
character separating the time zone name from the OFFSET, so these
restrictions are necessary to parse the specification correctly.

   The OFFSET specifies the time value you must add to the local time
to get a Coordinated Universal Time value.  It has syntax like
[`+'|`-']HH[`:'MM[`:'SS]].  This is positive if the local time zone is
west of the Prime Meridian and negative if it is east.  The hour must
be between `0' and `23', and the minute and seconds between `0' and
`59'.

   For example, here is how we would specify Eastern Standard Time, but
without any Daylight Saving Time alternative:

     EST+5

   The second format is used when there is Daylight Saving Time:

     STD OFFSET DST [OFFSET]`,'START[`/'TIME]`,'END[`/'TIME]

   The initial STD and OFFSET specify the standard time zone, as
described above.  The DST string and OFFSET specify the name and offset
for the corresponding Daylight Saving Time zone; if the OFFSET is
omitted, it defaults to one hour ahead of standard time.

   The remainder of the specification describes when Daylight Saving
Time is in effect.  The START field is when Daylight Saving Time goes
into effect and the END field is when the change is made back to
standard time.  The following formats are recognized for these fields:

`JN'
     This specifies the Julian day, with N between `1' and `365'.
     February 29 is never counted, even in leap years.

`N'
     This specifies the Julian day, with N between `0' and `365'.
     February 29 is counted in leap years.

`MM.W.D'
     This specifies day D of week W of month M.  The day D must be
     between `0' (Sunday) and `6'.  The week W must be between `1' and
     `5'; week `1' is the first week in which day D occurs, and week
     `5' specifies the _last_ D day in the month.  The month M should be
     between `1' and `12'.

   The TIME fields specify when, in the local time currently in effect,
the change to the other time occurs.  If omitted, the default is
`02:00:00'.

   For example, here is how you would specify the Eastern time zone in
the United States, including the appropriate Daylight Saving Time and
its dates of applicability.  The normal offset from UTC is 5 hours;
since this is west of the prime meridian, the sign is positive.  Summer
time begins on the first Sunday in April at 2:00am, and ends on the
last Sunday in October at 2:00am.

     EST+5EDT,M4.1.0/2,M10.5.0/2

   The schedule of Daylight Saving Time in any particular jurisdiction
has changed over the years.  To be strictly correct, the conversion of
dates and times in the past should be based on the schedule that was in
effect then.  However, this format has no facilities to let you specify
how the schedule has changed from year to year.  The most you can do is
specify one particular schedule--usually the present day schedule--and
this is used to convert any date, no matter when.  For precise time zone
specifications, it is best to use the time zone information database
(see below).

   The third format looks like this:

     :CHARACTERS

   Each operating system interprets this format differently; in the GNU
C library, CHARACTERS is the name of a file which describes the time
zone.

   If the `TZ' environment variable does not have a value, the
operation chooses a time zone by default.  In the GNU C library, the
default time zone is like the specification `TZ=:/etc/localtime' (or
`TZ=:/usr/local/etc/localtime', depending on how GNU C library was
configured; *note Installation::).  Other C libraries use their own
rule for choosing the default time zone, so there is little we can say
about them.

   If CHARACTERS begins with a slash, it is an absolute file name;
otherwise the library looks for the file
`/share/lib/zoneinfo/CHARACTERS'.  The `zoneinfo' directory contains
data files describing local time zones in many different parts of the
world.  The names represent major cities, with subdirectories for
geographical areas; for example, `America/New_York', `Europe/London',
`Asia/Hong_Kong'.  These data files are installed by the system
administrator, who also sets `/etc/localtime' to point to the data file
for the local time zone.  The GNU C library comes with a large database
of time zone information for most regions of the world, which is
maintained by a community of volunteers and put in the public domain.


File: libc.info,  Node: Time Zone Functions,  Next: Time Functions Example,  Prev: TZ Variable,  Up: Calendar Time

21.4.8 Functions and Variables for Time Zones
---------------------------------------------

 -- Variable: char * tzname [2]
     The array `tzname' contains two strings, which are the standard
     names of the pair of time zones (standard and Daylight Saving)
     that the user has selected.  `tzname[0]' is the name of the
     standard time zone (for example, `"EST"'), and `tzname[1]' is the
     name for the time zone when Daylight Saving Time is in use (for
     example, `"EDT"').  These correspond to the STD and DST strings
     (respectively) from the `TZ' environment variable.  If Daylight
     Saving Time is never used, `tzname[1]' is the empty string.

     The `tzname' array is initialized from the `TZ' environment
     variable whenever `tzset', `ctime', `strftime', `mktime', or
     `localtime' is called.  If multiple abbreviations have been used
     (e.g. `"EWT"' and `"EDT"' for U.S. Eastern War Time and Eastern
     Daylight Time), the array contains the most recent abbreviation.

     The `tzname' array is required for POSIX.1 compatibility, but in
     GNU programs it is better to use the `tm_zone' member of the
     broken-down time structure, since `tm_zone' reports the correct
     abbreviation even when it is not the latest one.

     Though the strings are declared as `char *' the user must refrain
     from modifying these strings.  Modifying the strings will almost
     certainly lead to trouble.


 -- Function: void tzset (void)
     The `tzset' function initializes the `tzname' variable from the
     value of the `TZ' environment variable.  It is not usually
     necessary for your program to call this function, because it is
     called automatically when you use the other time conversion
     functions that depend on the time zone.

   The following variables are defined for compatibility with System V
Unix.  Like `tzname', these variables are set by calling `tzset' or the
other time conversion functions.

 -- Variable: long int timezone
     This contains the difference between UTC and the latest local
     standard time, in seconds west of UTC.  For example, in the U.S.
     Eastern time zone, the value is `5*60*60'.  Unlike the `tm_gmtoff'
     member of the broken-down time structure, this value is not
     adjusted for daylight saving, and its sign is reversed.  In GNU
     programs it is better to use `tm_gmtoff', since it contains the
     correct offset even when it is not the latest one.

 -- Variable: int daylight
     This variable has a nonzero value if Daylight Saving Time rules
     apply.  A nonzero value does not necessarily mean that Daylight
     Saving Time is now in effect; it means only that Daylight Saving
     Time is sometimes in effect.


File: libc.info,  Node: Time Functions Example,  Prev: Time Zone Functions,  Up: Calendar Time

21.4.9 Time Functions Example
-----------------------------

Here is an example program showing the use of some of the calendar time
functions.

     #include <time.h>
     #include <stdio.h>

     #define SIZE 256

     int
     main (void)
     {
       char buffer[SIZE];
       time_t curtime;
       struct tm *loctime;

       /* Get the current time. */
       curtime = time (NULL);

       /* Convert it to local time representation. */
       loctime = localtime (&curtime);

       /* Print out the date and time in the standard format. */
       fputs (asctime (loctime), stdout);

       /* Print it out in a nice format. */
       strftime (buffer, SIZE, "Today is %A, %B %d.\n", loctime);
       fputs (buffer, stdout);
       strftime (buffer, SIZE, "The time is %I:%M %p.\n", loctime);
       fputs (buffer, stdout);

       return 0;
     }

   It produces output like this:

     Wed Jul 31 13:02:36 1991
     Today is Wednesday, July 31.
     The time is 01:02 PM.


File: libc.info,  Node: Setting an Alarm,  Next: Sleeping,  Prev: Calendar Time,  Up: Date and Time

21.5 Setting an Alarm
=====================

The `alarm' and `setitimer' functions provide a mechanism for a process
to interrupt itself in the future.  They do this by setting a timer;
when the timer expires, the process receives a signal.

   Each process has three independent interval timers available:

   * A real-time timer that counts elapsed time.  This timer sends a
     `SIGALRM' signal to the process when it expires.  

   * A virtual timer that counts processor time used by the process.
     This timer sends a `SIGVTALRM' signal to the process when it
     expires.  

   * A profiling timer that counts both processor time used by the
     process, and processor time spent in system calls on behalf of the
     process.  This timer sends a `SIGPROF' signal to the process when
     it expires.  

     This timer is useful for profiling in interpreters.  The interval
     timer mechanism does not have the fine granularity necessary for
     profiling native code.

   You can only have one timer of each kind set at any given time.  If
you set a timer that has not yet expired, that timer is simply reset to
the new value.

   You should establish a handler for the appropriate alarm signal using
`signal' or `sigaction' before issuing a call to `setitimer' or
`alarm'.  Otherwise, an unusual chain of events could cause the timer
to expire before your program establishes the handler.  In this case it
would be terminated, since termination is the default action for the
alarm signals.  *Note Signal Handling::.

   To be able to use the alarm function to interrupt a system call which
might block otherwise indefinitely it is important to _not_ set the
`SA_RESTART' flag when registering the signal handler using
`sigaction'.  When not using `sigaction' things get even uglier: the
`signal' function has to fixed semantics with respect to restarts.  The
BSD semantics for this function is to set the flag.  Therefore, if
`sigaction' for whatever reason cannot be used, it is necessary to use
`sysv_signal' and not `signal'.

   The `setitimer' function is the primary means for setting an alarm.
This facility is declared in the header file `sys/time.h'.  The `alarm'
function, declared in `unistd.h', provides a somewhat simpler interface
for setting the real-time timer.  

 -- Data Type: struct itimerval
     This structure is used to specify when a timer should expire.  It
     contains the following members:
    `struct timeval it_interval'
          This is the period between successive timer interrupts.  If
          zero, the alarm will only be sent once.

    `struct timeval it_value'
          This is the period between now and the first timer interrupt.
          If zero, the alarm is disabled.

     The `struct timeval' data type is described in *Note Elapsed
     Time::.

 -- Function: int setitimer (int WHICH, struct itimerval *NEW, struct
          itimerval *OLD)
     The `setitimer' function sets the timer specified by WHICH
     according to NEW.  The WHICH argument can have a value of
     `ITIMER_REAL', `ITIMER_VIRTUAL', or `ITIMER_PROF'.

     If OLD is not a null pointer, `setitimer' returns information
     about any previous unexpired timer of the same kind in the
     structure it points to.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EINVAL'
          The timer period is too large.

 -- Function: int getitimer (int WHICH, struct itimerval *OLD)
     The `getitimer' function stores information about the timer
     specified by WHICH in the structure pointed at by OLD.

     The return value and error conditions are the same as for
     `setitimer'.

`ITIMER_REAL'
     This constant can be used as the WHICH argument to the `setitimer'
     and `getitimer' functions to specify the real-time timer.

`ITIMER_VIRTUAL'
     This constant can be used as the WHICH argument to the `setitimer'
     and `getitimer' functions to specify the virtual timer.

`ITIMER_PROF'
     This constant can be used as the WHICH argument to the `setitimer'
     and `getitimer' functions to specify the profiling timer.

 -- Function: unsigned int alarm (unsigned int SECONDS)
     The `alarm' function sets the real-time timer to expire in SECONDS
     seconds.  If you want to cancel any existing alarm, you can do
     this by calling `alarm' with a SECONDS argument of zero.

     The return value indicates how many seconds remain before the
     previous alarm would have been sent.  If there is no previous
     alarm, `alarm' returns zero.

   The `alarm' function could be defined in terms of `setitimer' like
this:

     unsigned int
     alarm (unsigned int seconds)
     {
       struct itimerval old, new;
       new.it_interval.tv_usec = 0;
       new.it_interval.tv_sec = 0;
       new.it_value.tv_usec = 0;
       new.it_value.tv_sec = (long int) seconds;
       if (setitimer (ITIMER_REAL, &new, &old) < 0)
         return 0;
       else
         return old.it_value.tv_sec;
     }

   There is an example showing the use of the `alarm' function in *Note
Handler Returns::.

   If you simply want your process to wait for a given number of
seconds, you should use the `sleep' function.  *Note Sleeping::.

   You shouldn't count on the signal arriving precisely when the timer
expires.  In a multiprocessing environment there is typically some
amount of delay involved.

   *Portability Note:* The `setitimer' and `getitimer' functions are
derived from BSD Unix, while the `alarm' function is specified by the
POSIX.1 standard.  `setitimer' is more powerful than `alarm', but
`alarm' is more widely used.


File: libc.info,  Node: Sleeping,  Prev: Setting an Alarm,  Up: Date and Time

21.6 Sleeping
=============

The function `sleep' gives a simple way to make the program wait for a
short interval.  If your program doesn't use signals (except to
terminate), then you can expect `sleep' to wait reliably throughout the
specified interval.  Otherwise, `sleep' can return sooner if a signal
arrives; if you want to wait for a given interval regardless of
signals, use `select' (*note Waiting for I/O::) and don't specify any
descriptors to wait for.

 -- Function: unsigned int sleep (unsigned int SECONDS)
     The `sleep' function waits for SECONDS or until a signal is
     delivered, whichever happens first.

     If `sleep' function returns because the requested interval is over,
     it returns a value of zero.  If it returns because of delivery of a
     signal, its return value is the remaining time in the sleep
     interval.

     The `sleep' function is declared in `unistd.h'.

   Resist the temptation to implement a sleep for a fixed amount of
time by using the return value of `sleep', when nonzero, to call
`sleep' again.  This will work with a certain amount of accuracy as
long as signals arrive infrequently.  But each signal can cause the
eventual wakeup time to be off by an additional second or so.  Suppose a
few signals happen to arrive in rapid succession by bad luck--there is
no limit on how much this could shorten or lengthen the wait.

   Instead, compute the calendar time at which the program should stop
waiting, and keep trying to wait until that calendar time.  This won't
be off by more than a second.  With just a little more work, you can use
`select' and make the waiting period quite accurate.  (Of course, heavy
system load can cause additional unavoidable delays--unless the machine
is dedicated to one application, there is no way you can avoid this.)

   On some systems, `sleep' can do strange things if your program uses
`SIGALRM' explicitly.  Even if `SIGALRM' signals are being ignored or
blocked when `sleep' is called, `sleep' might return prematurely on
delivery of a `SIGALRM' signal.  If you have established a handler for
`SIGALRM' signals and a `SIGALRM' signal is delivered while the process
is sleeping, the action taken might be just to cause `sleep' to return
instead of invoking your handler.  And, if `sleep' is interrupted by
delivery of a signal whose handler requests an alarm or alters the
handling of `SIGALRM', this handler and `sleep' will interfere.

   On the GNU system, it is safe to use `sleep' and `SIGALRM' in the
same program, because `sleep' does not work by means of `SIGALRM'.

 -- Function: int nanosleep (const struct timespec *REQUESTED_TIME,
          struct timespec *REMAINING)
     If resolution to seconds is not enough the `nanosleep' function can
     be used.  As the name suggests the sleep interval can be specified
     in nanoseconds.  The actual elapsed time of the sleep interval
     might be longer since the system rounds the elapsed time you
     request up to the next integer multiple of the actual resolution
     the system can deliver.

     *`requested_time' is the elapsed time of the interval you want to
     sleep.

     The function returns as *`remaining' the elapsed time left in the
     interval for which you requested to sleep.  If the interval
     completed without getting interrupted by a signal, this is zero.

     `struct timespec' is described in *Note Elapsed Time::.

     If the function returns because the interval is over the return
     value is zero.  If the function returns -1 the global variable
     ERRNO is set to the following values:

    `EINTR'
          The call was interrupted because a signal was delivered to
          the thread.  If the REMAINING parameter is not the null
          pointer the structure pointed to by REMAINING is updated to
          contain the remaining elapsed time.

    `EINVAL'
          The nanosecond value in the REQUESTED_TIME parameter contains
          an illegal value.  Either the value is negative or greater
          than or equal to 1000 million.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `nanosleep' is called.  If the thread gets canceled these
     resources stay allocated until the program ends.  To avoid this
     calls to `nanosleep' should be protected using cancellation
     handlers.

     The `nanosleep' function is declared in `time.h'.


File: libc.info,  Node: Resource Usage And Limitation,  Next: Non-Local Exits,  Prev: Date and Time,  Up: Top

22 Resource Usage And Limitation
********************************

This chapter describes functions for examining how much of various
kinds of resources (CPU time, memory, etc.) a process has used and
getting and setting limits on future usage.

* Menu:

* Resource Usage::		Measuring various resources used.
* Limits on Resources::		Specifying limits on resource usage.
* Priority::			Reading or setting process run priority.
* Memory Resources::            Querying memory available resources.
* Processor Resources::         Learn about the processors available.


File: libc.info,  Node: Resource Usage,  Next: Limits on Resources,  Up: Resource Usage And Limitation

22.1 Resource Usage
===================

The function `getrusage' and the data type `struct rusage' are used to
examine the resource usage of a process.  They are declared in
`sys/resource.h'.

 -- Function: int getrusage (int PROCESSES, struct rusage *RUSAGE)
     This function reports resource usage totals for processes
     specified by PROCESSES, storing the information in `*RUSAGE'.

     In most systems, PROCESSES has only two valid values:

    `RUSAGE_SELF'
          Just the current process.

    `RUSAGE_CHILDREN'
          All child processes (direct and indirect) that have already
          terminated.

     In the GNU system, you can also inquire about a particular child
     process by specifying its process ID.

     The return value of `getrusage' is zero for success, and `-1' for
     failure.

    `EINVAL'
          The argument PROCESSES is not valid.

   One way of getting resource usage for a particular child process is
with the function `wait4', which returns totals for a child when it
terminates.  *Note BSD Wait Functions::.

 -- Data Type: struct rusage
     This data type stores various resource usage statistics.  It has
     the following members, and possibly others:

    `struct timeval ru_utime'
          Time spent executing user instructions.

    `struct timeval ru_stime'
          Time spent in operating system code on behalf of PROCESSES.

    `long int ru_maxrss'
          The maximum resident set size used, in kilobytes.  That is,
          the maximum number of kilobytes of physical memory that
          PROCESSES used simultaneously.

    `long int ru_ixrss'
          An integral value expressed in kilobytes times ticks of
          execution, which indicates the amount of memory used by text
          that was shared with other processes.

    `long int ru_idrss'
          An integral value expressed the same way, which is the amount
          of unshared memory used for data.

    `long int ru_isrss'
          An integral value expressed the same way, which is the amount
          of unshared memory used for stack space.

    `long int ru_minflt'
          The number of page faults which were serviced without
          requiring any I/O.

    `long int ru_majflt'
          The number of page faults which were serviced by doing I/O.

    `long int ru_nswap'
          The number of times PROCESSES was swapped entirely out of
          main memory.

    `long int ru_inblock'
          The number of times the file system had to read from the disk
          on behalf of PROCESSES.

    `long int ru_oublock'
          The number of times the file system had to write to the disk
          on behalf of PROCESSES.

    `long int ru_msgsnd'
          Number of IPC messages sent.

    `long int ru_msgrcv'
          Number of IPC messages received.

    `long int ru_nsignals'
          Number of signals received.

    `long int ru_nvcsw'
          The number of times PROCESSES voluntarily invoked a context
          switch (usually to wait for some service).

    `long int ru_nivcsw'
          The number of times an involuntary context switch took place
          (because a time slice expired, or another process of higher
          priority was scheduled).

   `vtimes' is a historical function that does some of what `getrusage'
does.  `getrusage' is a better choice.

   `vtimes' and its `vtimes' data structure are declared in
`sys/vtimes.h'.  

 -- Function: int vtimes (struct vtimes CURRENT, struct vtimes CHILD)
     `vtimes' reports resource usage totals for a process.

     If CURRENT is non-null, `vtimes' stores resource usage totals for
     the invoking process alone in the structure to which it points.  If
     CHILD is non-null, `vtimes' stores resource usage totals for all
     past children (which have terminated) of the invoking process in
     the structure to which it points.

      -- Data Type: struct vtimes
          This data type contains information about the resource usage
          of a process.  Each member corresponds to a member of the
          `struct rusage' data type described above.

         `vm_utime'
               User CPU time.  Analogous to `ru_utime' in `struct
               rusage'

         `vm_stime'
               System CPU time.  Analogous to `ru_stime' in `struct
               rusage'

         `vm_idsrss'
               Data and stack memory.  The sum of the values that would
               be reported as `ru_idrss' and `ru_isrss' in `struct
               rusage'

         `vm_ixrss'
               Shared memory.  Analogous to `ru_ixrss' in `struct
               rusage'

         `vm_maxrss'
               Maximent resident set size.  Analogous to `ru_maxrss' in
               `struct rusage'

         `vm_majflt'
               Major page faults.  Analogous to `ru_majflt' in `struct
               rusage'

         `vm_minflt'
               Minor page faults.  Analogous to `ru_minflt' in `struct
               rusage'

         `vm_nswap'
               Swap count.  Analogous to `ru_nswap' in `struct rusage'

         `vm_inblk'
               Disk reads.  Analogous to `ru_inblk' in `struct rusage'

         `vm_oublk'
               Disk writes.  Analogous to `ru_oublk' in `struct rusage'

     The return value is zero if the function succeeds; `-1' otherwise.

   An additional historical function for examining resource usage,
`vtimes', is supported but not documented here.  It is declared in
`sys/vtimes.h'.


File: libc.info,  Node: Limits on Resources,  Next: Priority,  Prev: Resource Usage,  Up: Resource Usage And Limitation

22.2 Limiting Resource Usage
============================

You can specify limits for the resource usage of a process.  When the
process tries to exceed a limit, it may get a signal, or the system call
by which it tried to do so may fail, depending on the resource.  Each
process initially inherits its limit values from its parent, but it can
subsequently change them.

   There are two per-process limits associated with a resource: 

"current limit"
     The current limit is the value the system will not allow usage to
     exceed.  It is also called the "soft limit" because the process
     being limited can generally raise the current limit at will.  

"maximum limit"
     The maximum limit is the maximum value to which a process is
     allowed to set its current limit.  It is also called the "hard
     limit" because there is no way for a process to get around it.  A
     process may lower its own maximum limit, but only the superuser
     may increase a maximum limit.  

   The symbols for use with `getrlimit', `setrlimit', `getrlimit64',
and `setrlimit64' are defined in `sys/resource.h'.

 -- Function: int getrlimit (int RESOURCE, struct rlimit *RLP)
     Read the current and maximum limits for the resource RESOURCE and
     store them in `*RLP'.

     The return value is `0' on success and `-1' on failure.  The only
     possible `errno' error condition is `EFAULT'.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit system this function is in fact `getrlimit64'.  Thus, the
     LFS interface transparently replaces the old interface.

 -- Function: int getrlimit64 (int RESOURCE, struct rlimit64 *RLP)
     This function is similar to `getrlimit' but its second parameter is
     a pointer to a variable of type `struct rlimit64', which allows it
     to read values which wouldn't fit in the member of a `struct
     rlimit'.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit machine, this function is available under the name
     `getrlimit' and so transparently replaces the old interface.

 -- Function: int setrlimit (int RESOURCE, const struct rlimit *RLP)
     Store the current and maximum limits for the resource RESOURCE in
     `*RLP'.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error condition is possible:

    `EPERM'
             * The process tried to raise a current limit beyond the
               maximum limit.

             * The process tried to raise a maximum limit, but is not
               superuser.

     When the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit system this function is in fact `setrlimit64'.  Thus, the
     LFS interface transparently replaces the old interface.

 -- Function: int setrlimit64 (int RESOURCE, const struct rlimit64 *RLP)
     This function is similar to `setrlimit' but its second parameter is
     a pointer to a variable of type `struct rlimit64' which allows it
     to set values which wouldn't fit in the member of a `struct
     rlimit'.

     If the sources are compiled with `_FILE_OFFSET_BITS == 64' on a
     32-bit machine this function is available under the name
     `setrlimit' and so transparently replaces the old interface.

 -- Data Type: struct rlimit
     This structure is used with `getrlimit' to receive limit values,
     and with `setrlimit' to specify limit values for a particular
     process and resource.  It has two fields:

    `rlim_t rlim_cur'
          The current limit

    `rlim_t rlim_max'
          The maximum limit.

     For `getrlimit', the structure is an output; it receives the
     current values.  For `setrlimit', it specifies the new values.

   For the LFS functions a similar type is defined in `sys/resource.h'.

 -- Data Type: struct rlimit64
     This structure is analogous to the `rlimit' structure above, but
     its components have wider ranges.  It has two fields:

    `rlim64_t rlim_cur'
          This is analogous to `rlimit.rlim_cur', but with a different
          type.

    `rlim64_t rlim_max'
          This is analogous to `rlimit.rlim_max', but with a different
          type.


   Here is a list of resources for which you can specify a limit.
Memory and file sizes are measured in bytes.

`RLIMIT_CPU'
     The maximum amount of CPU time the process can use.  If it runs for
     longer than this, it gets a signal: `SIGXCPU'.  The value is
     measured in seconds.  *Note Operation Error Signals::.

`RLIMIT_FSIZE'
     The maximum size of file the process can create.  Trying to write a
     larger file causes a signal: `SIGXFSZ'.  *Note Operation Error
     Signals::.

`RLIMIT_DATA'
     The maximum size of data memory for the process.  If the process
     tries to allocate data memory beyond this amount, the allocation
     function fails.

`RLIMIT_STACK'
     The maximum stack size for the process.  If the process tries to
     extend its stack past this size, it gets a `SIGSEGV' signal.
     *Note Program Error Signals::.

`RLIMIT_CORE'
     The maximum size core file that this process can create.  If the
     process terminates and would dump a core file larger than this,
     then no core file is created.  So setting this limit to zero
     prevents core files from ever being created.

`RLIMIT_RSS'
     The maximum amount of physical memory that this process should get.
     This parameter is a guide for the system's scheduler and memory
     allocator; the system may give the process more memory when there
     is a surplus.

`RLIMIT_MEMLOCK'
     The maximum amount of memory that can be locked into physical
     memory (so it will never be paged out).

`RLIMIT_NPROC'
     The maximum number of processes that can be created with the same
     user ID.  If you have reached the limit for your user ID, `fork'
     will fail with `EAGAIN'.  *Note Creating a Process::.

`RLIMIT_NOFILE'
`RLIMIT_OFILE'
     The maximum number of files that the process can open.  If it
     tries to open more files than this, its open attempt fails with
     `errno' `EMFILE'.  *Note Error Codes::.  Not all systems support
     this limit; GNU does, and 4.4 BSD does.

`RLIMIT_AS'
     The maximum size of total memory that this process should get.  If
     the process tries to allocate more memory beyond this amount with,
     for example, `brk', `malloc', `mmap' or `sbrk', the allocation
     function fails.

`RLIM_NLIMITS'
     The number of different resource limits.  Any valid RESOURCE
     operand must be less than `RLIM_NLIMITS'.

 -- Constant: int RLIM_INFINITY
     This constant stands for a value of "infinity" when supplied as
     the limit value in `setrlimit'.

   The following are historical functions to do some of what the
functions above do.  The functions above are better choices.

   `ulimit' and the command symbols are declared in `ulimit.h'.  

 -- Function: int ulimit (int CMD, ...)
     `ulimit' gets the current limit or sets the current and maximum
     limit for a particular resource for the calling process according
     to the command CMD.a

     If you are getting a limit, the command argument is the only
     argument.  If you are setting a limit, there is a second argument:
     `long int' LIMIT which is the value to which you are setting the
     limit.

     The CMD values and the operations they specify are:
    `GETFSIZE'
          Get the current limit on the size of a file, in units of 512
          bytes.

    `SETFSIZE'
          Set the current and maximum limit on the size of a file to
          LIMIT * 512 bytes.


     There are also some other CMD values that may do things on some
     systems, but they are not supported.

     Only the superuser may increase a maximum limit.

     When you successfully get a limit, the return value of `ulimit' is
     that limit, which is never negative.  When you successfully set a
     limit, the return value is zero.  When the function fails, the
     return value is `-1' and `errno' is set according to the reason:

    `EPERM'
          A process tried to increase a maximum limit, but is not
          superuser.


   `vlimit' and its resource symbols are declared in `sys/vlimit.h'.  

 -- Function: int vlimit (int RESOURCE, int LIMIT)
     `vlimit' sets the current limit for a resource for a process.

     RESOURCE identifies the resource:

    `LIM_CPU'
          Maximum CPU time.  Same as `RLIMIT_CPU' for `setrlimit'.

    `LIM_FSIZE'
          Maximum file size.  Same as `RLIMIT_FSIZE' for `setrlimit'.

    `LIM_DATA'
          Maximum data memory.  Same as `RLIMIT_DATA' for `setrlimit'.

    `LIM_STACK'
          Maximum stack size.  Same as `RLIMIT_STACK' for `setrlimit'.

    `LIM_CORE'
          Maximum core file size.  Same as `RLIMIT_COR' for `setrlimit'.

    `LIM_MAXRSS'
          Maximum physical memory.  Same as `RLIMIT_RSS' for
          `setrlimit'.

     The return value is zero for success, and `-1' with `errno' set
     accordingly for failure:

    `EPERM'
          The process tried to set its current limit beyond its maximum
          limit.



File: libc.info,  Node: Priority,  Next: Memory Resources,  Prev: Limits on Resources,  Up: Resource Usage And Limitation

22.3 Process CPU Priority And Scheduling
========================================

When multiple processes simultaneously require CPU time, the system's
scheduling policy and process CPU priorities determine which processes
get it.  This section describes how that determination is made and GNU
C library functions to control it.

   It is common to refer to CPU scheduling simply as scheduling and a
process' CPU priority simply as the process' priority, with the CPU
resource being implied.  Bear in mind, though, that CPU time is not the
only resource a process uses or that processes contend for.  In some
cases, it is not even particularly important.  Giving a process a high
"priority" may have very little effect on how fast a process runs with
respect to other processes.  The priorities discussed in this section
apply only to CPU time.

   CPU scheduling is a complex issue and different systems do it in
wildly different ways.  New ideas continually develop and find their
way into the intricacies of the various systems' scheduling algorithms.
This section discusses the general concepts, some specifics of systems
that commonly use the GNU C library, and some standards.

   For simplicity, we talk about CPU contention as if there is only one
CPU in the system.  But all the same principles apply when a processor
has multiple CPUs, and knowing that the number of processes that can
run at any one time is equal to the number of CPUs, you can easily
extrapolate the information.

   The functions described in this section are all defined by the
POSIX.1 and POSIX.1b standards (the `sched...' functions are POSIX.1b).
However, POSIX does not define any semantics for the values that these
functions get and set.  In this chapter, the semantics are based on the
Linux kernel's implementation of the POSIX standard.  As you will see,
the Linux implementation is quite the inverse of what the authors of the
POSIX syntax had in mind.

* Menu:

* Absolute Priority::               The first tier of priority.  Posix
* Realtime Scheduling::             Scheduling among the process nobility
* Basic Scheduling Functions::      Get/set scheduling policy, priority
* Traditional Scheduling::          Scheduling among the vulgar masses
* CPU Affinity::                    Limiting execution to certain CPUs


File: libc.info,  Node: Absolute Priority,  Next: Realtime Scheduling,  Up: Priority

22.3.1 Absolute Priority
------------------------

Every process has an absolute priority, and it is represented by a
number.  The higher the number, the higher the absolute priority.

   On systems of the past, and most systems today, all processes have
absolute priority 0 and this section is irrelevant.  In that case,
*Note Traditional Scheduling::.  Absolute priorities were invented to
accommodate realtime systems, in which it is vital that certain
processes be able to respond to external events happening in real time,
which means they cannot wait around while some other process that _wants
to_, but doesn't _need to_ run occupies the CPU.

   When two processes are in contention to use the CPU at any instant,
the one with the higher absolute priority always gets it.  This is true
even if the process with the lower priority is already using the CPU
(i.e., the scheduling is preemptive).  Of course, we're only talking
about processes that are running or "ready to run," which means they are
ready to execute instructions right now.  When a process blocks to wait
for something like I/O, its absolute priority is irrelevant.

   *NB:*  The term "runnable" is a synonym for "ready to run."

   When two processes are running or ready to run and both have the same
absolute priority, it's more interesting.  In that case, who gets the
CPU is determined by the scheduling policy.  If the processes have
absolute priority 0, the traditional scheduling policy described in
*Note Traditional Scheduling:: applies.  Otherwise, the policies
described in *Note Realtime Scheduling:: apply.

   You normally give an absolute priority above 0 only to a process that
can be trusted not to hog the CPU.  Such processes are designed to block
(or terminate) after relatively short CPU runs.

   A process begins life with the same absolute priority as its parent
process.  Functions described in *Note Basic Scheduling Functions:: can
change it.

   Only a privileged process can change a process' absolute priority to
something other than `0'.  Only a privileged process or the target
process' owner can change its absolute priority at all.

   POSIX requires absolute priority values used with the realtime
scheduling policies to be consecutive with a range of at least 32.  On
Linux, they are 1 through 99.  The functions `sched_get_priority_max'
and `sched_set_priority_min' portably tell you what the range is on a
particular system.

22.3.1.1 Using Absolute Priority
................................

One thing you must keep in mind when designing real time applications is
that having higher absolute priority than any other process doesn't
guarantee the process can run continuously.  Two things that can wreck a
good CPU run are interrupts and page faults.

   Interrupt handlers live in that limbo between processes.  The CPU is
executing instructions, but they aren't part of any process.  An
interrupt will stop even the highest priority process.  So you must
allow for slight delays and make sure that no device in the system has
an interrupt handler that could cause too long a delay between
instructions for your process.

   Similarly, a page fault causes what looks like a straightforward
sequence of instructions to take a long time.  The fact that other
processes get to run while the page faults in is of no consequence,
because as soon as the I/O is complete, the high priority process will
kick them out and run again, but the wait for the I/O itself could be a
problem.  To neutralize this threat, use `mlock' or `mlockall'.

   There are a few ramifications of the absoluteness of this priority
on a single-CPU system that you need to keep in mind when you choose to
set a priority and also when you're working on a program that runs with
high absolute priority.  Consider a process that has higher absolute
priority than any other process in the system and due to a bug in its
program, it gets into an infinite loop.  It will never cede the CPU.
You can't run a command to kill it because your command would need to
get the CPU in order to run.  The errant program is in complete
control.  It controls the vertical, it controls the horizontal.

   There are two ways to avoid this: 1) keep a shell running somewhere
with a higher absolute priority.  2) keep a controlling terminal
attached to the high priority process group.  All the priority in the
world won't stop an interrupt handler from running and delivering a
signal to the process if you hit Control-C.

   Some systems use absolute priority as a means of allocating a fixed
percentage of CPU time to a process.  To do this, a super high priority
privileged process constantly monitors the process' CPU usage and raises
its absolute priority when the process isn't getting its entitled share
and lowers it when the process is exceeding it.

   *NB:*  The absolute priority is sometimes called the "static
priority."  We don't use that term in this manual because it misses the
most important feature of the absolute priority:  its absoluteness.


File: libc.info,  Node: Realtime Scheduling,  Next: Basic Scheduling Functions,  Prev: Absolute Priority,  Up: Priority

22.3.2 Realtime Scheduling
--------------------------

Whenever two processes with the same absolute priority are ready to run,
the kernel has a decision to make, because only one can run at a time.
If the processes have absolute priority 0, the kernel makes this
decision as described in *Note Traditional Scheduling::.  Otherwise,
the decision is as described in this section.

   If two processes are ready to run but have different absolute
priorities, the decision is much simpler, and is described in *Note
Absolute Priority::.

   Each process has a scheduling policy.  For processes with absolute
priority other than zero, there are two available:

  1. First Come First Served

  2. Round Robin

   The most sensible case is where all the processes with a certain
absolute priority have the same scheduling policy.  We'll discuss that
first.

   In Round Robin, processes share the CPU, each one running for a small
quantum of time ("time slice") and then yielding to another in a
circular fashion.  Of course, only processes that are ready to run and
have the same absolute priority are in this circle.

   In First Come First Served, the process that has been waiting the
longest to run gets the CPU, and it keeps it until it voluntarily
relinquishes the CPU, runs out of things to do (blocks), or gets
preempted by a higher priority process.

   First Come First Served, along with maximal absolute priority and
careful control of interrupts and page faults, is the one to use when a
process absolutely, positively has to run at full CPU speed or not at
all.

   Judicious use of `sched_yield' function invocations by processes
with First Come First Served scheduling policy forms a good compromise
between Round Robin and First Come First Served.

   To understand how scheduling works when processes of different
scheduling policies occupy the same absolute priority, you have to know
the nitty gritty details of how processes enter and exit the ready to
run list:

   In both cases, the ready to run list is organized as a true queue,
where a process gets pushed onto the tail when it becomes ready to run
and is popped off the head when the scheduler decides to run it.  Note
that ready to run and running are two mutually exclusive states.  When
the scheduler runs a process, that process is no longer ready to run
and no longer in the ready to run list.  When the process stops
running, it may go back to being ready to run again.

   The only difference between a process that is assigned the Round
Robin scheduling policy and a process that is assigned First Come First
Serve is that in the former case, the process is automatically booted
off the CPU after a certain amount of time.  When that happens, the
process goes back to being ready to run, which means it enters the
queue at the tail.  The time quantum we're talking about is small.
Really small.  This is not your father's timesharing.  For example,
with the Linux kernel, the round robin time slice is a thousand times
shorter than its typical time slice for traditional scheduling.

   A process begins life with the same scheduling policy as its parent
process.  Functions described in *Note Basic Scheduling Functions:: can
change it.

   Only a privileged process can set the scheduling policy of a process
that has absolute priority higher than 0.


File: libc.info,  Node: Basic Scheduling Functions,  Next: Traditional Scheduling,  Prev: Realtime Scheduling,  Up: Priority

22.3.3 Basic Scheduling Functions
---------------------------------

This section describes functions in the GNU C library for setting the
absolute priority and scheduling policy of a process.

   *Portability Note:*  On systems that have the functions in this
section, the macro _POSIX_PRIORITY_SCHEDULING is defined in
`<unistd.h>'.

   For the case that the scheduling policy is traditional scheduling,
more functions to fine tune the scheduling are in *Note Traditional
Scheduling::.

   Don't try to make too much out of the naming and structure of these
functions.  They don't match the concepts described in this manual
because the functions are as defined by POSIX.1b, but the implementation
on systems that use the GNU C library is the inverse of what the POSIX
structure contemplates.  The POSIX scheme assumes that the primary
scheduling parameter is the scheduling policy and that the priority
value, if any, is a parameter of the scheduling policy.  In the
implementation, though, the priority value is king and the scheduling
policy, if anything, only fine tunes the effect of that priority.

   The symbols in this section are declared by including file `sched.h'.

 -- Data Type: struct sched_param
     This structure describes an absolute priority.
    `int sched_priority'
          absolute priority value

 -- Function: int sched_setscheduler (pid_t PID, int POLICY, const
          struct sched_param *PARAM)
     This function sets both the absolute priority and the scheduling
     policy for a process.

     It assigns the absolute priority value given by PARAM and the
     scheduling policy POLICY to the process with Process ID PID, or
     the calling process if PID is zero.  If POLICY is negative,
     `sched_setscheduler' keeps the existing scheduling policy.

     The following macros represent the valid values for POLICY:

    `SCHED_OTHER'
          Traditional Scheduling

    `SCHED_FIFO'
          First In First Out

    `SCHED_RR'
          Round Robin

     On success, the return value is `0'.  Otherwise, it is `-1' and
     `ERRNO' is set accordingly.  The `errno' values specific to this
     function are:

    `EPERM'
             * The calling process does not have `CAP_SYS_NICE'
               permission and POLICY is not `SCHED_OTHER' (or it's
               negative and the existing policy is not `SCHED_OTHER'.

             * The calling process does not have `CAP_SYS_NICE'
               permission and its owner is not the target process'
               owner.  I.e., the effective uid of the calling process
               is neither the effective nor the real uid of process PID.

    `ESRCH'
          There is no process with pid PID and PID is not zero.

    `EINVAL'
             * POLICY does not identify an existing scheduling policy.

             * The absolute priority value identified by *PARAM is
               outside the valid range for the scheduling policy POLICY
               (or the existing scheduling policy if POLICY is
               negative) or PARAM is null.  `sched_get_priority_max'
               and `sched_get_priority_min' tell you what the valid
               range is.

             * PID is negative.


 -- Function: int sched_getscheduler (pid_t PID)
     This function returns the scheduling policy assigned to the
     process with Process ID (pid) PID, or the calling process if PID
     is zero.

     The return value is the scheduling policy.  See
     `sched_setscheduler' for the possible values.

     If the function fails, the return value is instead `-1' and
     `errno' is set accordingly.

     The `errno' values specific to this function are:

    `ESRCH'
          There is no process with pid PID and it is not zero.

    `EINVAL'
          PID is negative.


     Note that this function is not an exact mate to
     `sched_setscheduler' because while that function sets the
     scheduling policy and the absolute priority, this function gets
     only the scheduling policy.  To get the absolute priority, use
     `sched_getparam'.


 -- Function: int sched_setparam (pid_t PID, const struct sched_param
          *PARAM)
     This function sets a process' absolute priority.

     It is functionally identical to `sched_setscheduler' with POLICY =
     `-1'.


 -- Function: int sched_getparam (pid_t PID, const struct sched_param
          *PARAM)
     This function returns a process' absolute priority.

     PID is the Process ID (pid) of the process whose absolute priority
     you want to know.

     PARAM is a pointer to a structure in which the function stores the
     absolute priority of the process.

     On success, the return value is `0'.  Otherwise, it is `-1' and
     `ERRNO' is set accordingly.  The `errno' values specific to this
     function are:

    `ESRCH'
          There is no process with pid PID and it is not zero.

    `EINVAL'
          PID is negative.



 -- Function: int sched_get_priority_min (int *POLICY);
     This function returns the lowest absolute priority value that is
     allowable for a process with scheduling policy POLICY.

     On Linux, it is 0 for SCHED_OTHER and 1 for everything else.

     On success, the return value is `0'.  Otherwise, it is `-1' and
     `ERRNO' is set accordingly.  The `errno' values specific to this
     function are:

    `EINVAL'
          POLICY does not identify an existing scheduling policy.


 -- Function: int sched_get_priority_max (int *POLICY);
     This function returns the highest absolute priority value that is
     allowable for a process that with scheduling policy POLICY.

     On Linux, it is 0 for SCHED_OTHER and 99 for everything else.

     On success, the return value is `0'.  Otherwise, it is `-1' and
     `ERRNO' is set accordingly.  The `errno' values specific to this
     function are:

    `EINVAL'
          POLICY does not identify an existing scheduling policy.


 -- Function: int sched_rr_get_interval (pid_t PID, struct timespec
          *INTERVAL)
     This function returns the length of the quantum (time slice) used
     with the Round Robin scheduling policy, if it is used, for the
     process with Process ID PID.

     It returns the length of time as INTERVAL.

     With a Linux kernel, the round robin time slice is always 150
     microseconds, and PID need not even be a real pid.

     The return value is `0' on success and in the pathological case
     that it fails, the return value is `-1' and `errno' is set
     accordingly.  There is nothing specific that can go wrong with this
     function, so there are no specific `errno' values.


 -- Function: int sched_yield (void)
     This function voluntarily gives up the process' claim on the CPU.

     Technically, `sched_yield' causes the calling process to be made
     immediately ready to run (as opposed to running, which is what it
     was before).  This means that if it has absolute priority higher
     than 0, it gets pushed onto the tail of the queue of processes
     that share its absolute priority and are ready to run, and it will
     run again when its turn next arrives.  If its absolute priority is
     0, it is more complicated, but still has the effect of yielding
     the CPU to other processes.

     If there are no other processes that share the calling process'
     absolute priority, this function doesn't have any effect.

     To the extent that the containing program is oblivious to what
     other processes in the system are doing and how fast it executes,
     this function appears as a no-op.

     The return value is `0' on success and in the pathological case
     that it fails, the return value is `-1' and `errno' is set
     accordingly.  There is nothing specific that can go wrong with this
     function, so there are no specific `errno' values.



File: libc.info,  Node: Traditional Scheduling,  Next: CPU Affinity,  Prev: Basic Scheduling Functions,  Up: Priority

22.3.4 Traditional Scheduling
-----------------------------

This section is about the scheduling among processes whose absolute
priority is 0.  When the system hands out the scraps of CPU time that
are left over after the processes with higher absolute priority have
taken all they want, the scheduling described herein determines who
among the great unwashed processes gets them.

* Menu:

* Traditional Scheduling Intro::
* Traditional Scheduling Functions::


File: libc.info,  Node: Traditional Scheduling Intro,  Next: Traditional Scheduling Functions,  Up: Traditional Scheduling

22.3.4.1 Introduction To Traditional Scheduling
...............................................

Long before there was absolute priority (See *Note Absolute Priority::),
Unix systems were scheduling the CPU using this system.  When Posix came
in like the Romans and imposed absolute priorities to accommodate the
needs of realtime processing, it left the indigenous Absolute Priority
Zero processes to govern themselves by their own familiar scheduling
policy.

   Indeed, absolute priorities higher than zero are not available on
many systems today and are not typically used when they are, being
intended mainly for computers that do realtime processing.  So this
section describes the only scheduling many programmers need to be
concerned about.

   But just to be clear about the scope of this scheduling: Any time a
process with a absolute priority of 0 and a process with an absolute
priority higher than 0 are ready to run at the same time, the one with
absolute priority 0 does not run.  If it's already running when the
higher priority ready-to-run process comes into existence, it stops
immediately.

   In addition to its absolute priority of zero, every process has
another priority, which we will refer to as "dynamic priority" because
it changes over time.  The dynamic priority is meaningless for
processes with an absolute priority higher than zero.

   The dynamic priority sometimes determines who gets the next turn on
the CPU.  Sometimes it determines how long turns last.  Sometimes it
determines whether a process can kick another off the CPU.

   In Linux, the value is a combination of these things, but mostly it
is just determines the length of the time slice.  The higher a process'
dynamic priority, the longer a shot it gets on the CPU when it gets one.
If it doesn't use up its time slice before giving up the CPU to do
something like wait for I/O, it is favored for getting the CPU back when
it's ready for it, to finish out its time slice.  Other than that,
selection of processes for new time slices is basically round robin.
But the scheduler does throw a bone to the low priority processes: A
process' dynamic priority rises every time it is snubbed in the
scheduling process.  In Linux, even the fat kid gets to play.

   The fluctuation of a process' dynamic priority is regulated by
another value: The "nice" value.  The nice value is an integer, usually
in the range -20 to 20, and represents an upper limit on a process'
dynamic priority.  The higher the nice number, the lower that limit.

   On a typical Linux system, for example, a process with a nice value
of 20 can get only 10 milliseconds on the CPU at a time, whereas a
process with a nice value of -20 can achieve a high enough priority to
get 400 milliseconds.

   The idea of the nice value is deferential courtesy.  In the
beginning, in the Unix garden of Eden, all processes shared equally in
the bounty of the computer system.  But not all processes really need
the same share of CPU time, so the nice value gave a courteous process
the ability to refuse its equal share of CPU time that others might
prosper.  Hence, the higher a process' nice value, the nicer the
process is.  (Then a snake came along and offered some process a
negative nice value and the system became the crass resource allocation
system we know today).

   Dynamic priorities tend upward and downward with an objective of
smoothing out allocation of CPU time and giving quick response time to
infrequent requests.  But they never exceed their nice limits, so on a
heavily loaded CPU, the nice value effectively determines how fast a
process runs.

   In keeping with the socialistic heritage of Unix process priority, a
process begins life with the same nice value as its parent process and
can raise it at will.  A process can also raise the nice value of any
other process owned by the same user (or effective user).  But only a
privileged process can lower its nice value.  A privileged process can
also raise or lower another process' nice value.

   GNU C Library functions for getting and setting nice values are
described in *Note Traditional Scheduling Functions::.


File: libc.info,  Node: Traditional Scheduling Functions,  Prev: Traditional Scheduling Intro,  Up: Traditional Scheduling

22.3.4.2 Functions For Traditional Scheduling
.............................................

This section describes how you can read and set the nice value of a
process.  All these symbols are declared in `sys/resource.h'.

   The function and macro names are defined by POSIX, and refer to
"priority," but the functions actually have to do with nice values, as
the terms are used both in the manual and POSIX.

   The range of valid nice values depends on the kernel, but typically
it runs from `-20' to `20'.  A lower nice value corresponds to higher
priority for the process.  These constants describe the range of
priority values:

`PRIO_MIN'
     The lowest valid nice value.

`PRIO_MAX'
     The highest valid nice value.

 -- Function: int getpriority (int CLASS, int ID)
     Return the nice value of a set of processes; CLASS and ID specify
     which ones (see below).  If the processes specified do not all
     have the same nice value, this returns the lowest value that any
     of them has.

     On success, the return value is `0'.  Otherwise, it is `-1' and
     `ERRNO' is set accordingly.  The `errno' values specific to this
     function are:

    `ESRCH'
          The combination of CLASS and ID does not match any existing
          process.

    `EINVAL'
          The value of CLASS is not valid.

     If the return value is `-1', it could indicate failure, or it could
     be the nice value.  The only way to make certain is to set `errno =
     0' before calling `getpriority', then use `errno != 0' afterward
     as the criterion for failure.

 -- Function: int setpriority (int CLASS, int ID, int NICEVAL)
     Set the nice value of a set of processes to NICEVAL; CLASS and ID
     specify which ones (see below).

     The return value is `0' on success, and `-1' on failure.  The
     following `errno' error condition are possible for this function:

    `ESRCH'
          The combination of CLASS and ID does not match any existing
          process.

    `EINVAL'
          The value of CLASS is not valid.

    `EPERM'
          The call would set the nice value of a process which is owned
          by a different user than the calling process (i.e., the
          target process' real or effective uid does not match the
          calling process' effective uid) and the calling process does
          not have `CAP_SYS_NICE' permission.

    `EACCES'
          The call would lower the process' nice value and the process
          does not have `CAP_SYS_NICE' permission.


   The arguments CLASS and ID together specify a set of processes in
which you are interested.  These are the possible values of CLASS:

`PRIO_PROCESS'
     One particular process.  The argument ID is a process ID (pid).

`PRIO_PGRP'
     All the processes in a particular process group.  The argument ID
     is a process group ID (pgid).

`PRIO_USER'
     All the processes owned by a particular user (i.e., whose real uid
     indicates the user).  The argument ID is a user ID (uid).

   If the argument ID is 0, it stands for the calling process, its
process group, or its owner (real uid), according to CLASS.

 -- Function: int nice (int INCREMENT)
     Increment the nice value of the calling process by INCREMENT.  The
     return value is the new nice value on success, and `-1' on
     failure.  In the case of failure, `errno' will be set to the same
     values as for `setpriority'.

     Here is an equivalent definition of `nice':

          int
          nice (int increment)
          {
            int result, old = getpriority (PRIO_PROCESS, 0);
            result = setpriority (PRIO_PROCESS, 0, old + increment);
            if (result != -1)
                return old + increment;
            else
                return -1;
          }


File: libc.info,  Node: CPU Affinity,  Prev: Traditional Scheduling,  Up: Priority

22.3.5 Limiting execution to certain CPUs
-----------------------------------------

On a multi-processor system the operating system usually distributes
the different processes which are runnable on all available CPUs in a
way which allows the system to work most efficiently.  Which processes
and threads run can be to some extend be control with the scheduling
functionality described in the last sections.  But which CPU finally
executes which process or thread is not covered.

   There are a number of reasons why a program might want to have
control over this aspect of the system as well:

   * One thread or process is responsible for absolutely critical work
     which under no circumstances must be interrupted or hindered from
     making process by other process or threads using CPU resources.  In
     this case the special process would be confined to a CPU which no
     other process or thread is allowed to use.

   * The access to certain resources (RAM, I/O ports) has different
     costs from different CPUs.  This is the case in NUMA (Non-Uniform
     Memory Architecture) machines.  Preferably memory should be
     accessed locally but this requirement is usually not visible to
     the scheduler.  Therefore forcing a process or thread to the CPUs
     which have local access to the mostly used memory helps to
     significantly boost the performance.

   * In controlled runtimes resource allocation and book-keeping work
     (for instance garbage collection) is performance local to
     processors.  This can help to reduce locking costs if the
     resources do not have to be protected from concurrent accesses
     from different processors.

   The POSIX standard up to this date is of not much help to solve this
problem.  The Linux kernel provides a set of interfaces to allow
specifying _affinity sets_ for a process.  The scheduler will schedule
the thread or process on CPUs specified by the affinity masks.  The
interfaces which the GNU C library define follow to some extend the
Linux kernel interface.

 -- Data Type: cpu_set_t
     This data set is a bitset where each bit represents a CPU.  How the
     system's CPUs are mapped to bits in the bitset is system dependent.
     The data type has a fixed size; in the unlikely case that the
     number of bits are not sufficient to describe the CPUs of the
     system a different interface has to be used.

     This type is a GNU extension and is defined in `sched.h'.

   To manipulate the bitset, to set and reset bits, a number of macros
is defined.  Some of the macros take a CPU number as a parameter.  Here
it is important to never exceed the size of the bitset.  The following
macro specifies the number of bits in the `cpu_set_t' bitset.

 -- Macro: int CPU_SETSIZE
     The value of this macro is the maximum number of CPUs which can be
     handled with a `cpu_set_t' object.

   The type `cpu_set_t' should be considered opaque; all manipulation
should happen via the next four macros.

 -- Macro: void CPU_ZERO (cpu_set_t *SET)
     This macro initializes the CPU set SET to be the empty set.

     This macro is a GNU extension and is defined in `sched.h'.

 -- Macro: void CPU_SET (int CPU, cpu_set_t *SET)
     This macro adds CPU to the CPU set SET.

     The CPU parameter must not have side effects since it is evaluated
     more than once.

     This macro is a GNU extension and is defined in `sched.h'.

 -- Macro: void CPU_CLR (int CPU, cpu_set_t *SET)
     This macro removes CPU from the CPU set SET.

     The CPU parameter must not have side effects since it is evaluated
     more than once.

     This macro is a GNU extension and is defined in `sched.h'.

 -- Macro: int CPU_ISSET (int CPU, const cpu_set_t *SET)
     This macro returns a nonzero value (true) if CPU is a member of
     the CPU set SET, and zero (false) otherwise.

     The CPU parameter must not have side effects since it is evaluated
     more than once.

     This macro is a GNU extension and is defined in `sched.h'.

   CPU bitsets can be constructed from scratch or the currently
installed affinity mask can be retrieved from the system.

 -- Function: int sched_getaffinity (pid_t PID, size_t CPUSETSIZE,
          cpu_set_t *CPUSET)
     This functions stores the CPU affinity mask for the process or
     thread with the ID PID in the CPUSETSIZE bytes long bitmap pointed
     to by CPUSET.  If successful, the function always initializes all
     bits in the `cpu_set_t' object and returns zero.

     If PID does not correspond to a process or thread on the system
     the or the function fails for some other reason, it returns `-1'
     and `errno' is set to represent the error condition.

    `ESRCH'
          No process or thread with the given ID found.

    `EFAULT'
          The pointer CPUSET is does not point to a valid object.

     This function is a GNU extension and is declared in `sched.h'.

   Note that it is not portably possible to use this information to
retrieve the information for different POSIX threads.  A separate
interface must be provided for that.

 -- Function: int sched_setaffinity (pid_t PID, size_t CPUSETSIZE,
          const cpu_set_t *CPUSET)
     This function installs the CPUSETSIZE bytes long affinity mask
     pointed to by CPUSET for the process or thread with the ID PID.
     If successful the function returns zero and the scheduler will in
     future take the affinity information into account.

     If the function fails it will return `-1' and `errno' is set to
     the error code:

    `ESRCH'
          No process or thread with the given ID found.

    `EFAULT'
          The pointer CPUSET is does not point to a valid object.

    `EINVAL'
          The bitset is not valid.  This might mean that the affinity
          set might not leave a processor for the process or thread to
          run on.

     This function is a GNU extension and is declared in `sched.h'.


File: libc.info,  Node: Memory Resources,  Next: Processor Resources,  Prev: Priority,  Up: Resource Usage And Limitation

22.4 Querying memory available resources
========================================

The amount of memory available in the system and the way it is organized
determines oftentimes the way programs can and have to work.  For
functions like `mmap' it is necessary to know about the size of
individual memory pages and knowing how much memory is available enables
a program to select appropriate sizes for, say, caches.  Before we get
into these details a few words about memory subsystems in traditional
Unix systems will be given.

* Menu:

* Memory Subsystem::           Overview about traditional Unix memory handling.
* Query Memory Parameters::    How to get information about the memory
                                subsystem?


File: libc.info,  Node: Memory Subsystem,  Next: Query Memory Parameters,  Up: Memory Resources

22.4.1 Overview about traditional Unix memory handling
------------------------------------------------------

Unix systems normally provide processes virtual address spaces.  This
means that the addresses of the memory regions do not have to correspond
directly to the addresses of the actual physical memory which stores the
data.  An extra level of indirection is introduced which translates
virtual addresses into physical addresses.  This is normally done by the
hardware of the processor.

   Using a virtual address space has several advantage.  The most
important is process isolation.  The different processes running on the
system cannot interfere directly with each other.  No process can write
into the address space of another process (except when shared memory is
used but then it is wanted and controlled).

   Another advantage of virtual memory is that the address space the
processes see can actually be larger than the physical memory available.
The physical memory can be extended by storage on an external media
where the content of currently unused memory regions is stored.  The
address translation can then intercept accesses to these memory regions
and make memory content available again by loading the data back into
memory.  This concept makes it necessary that programs which have to use
lots of memory know the difference between available virtual address
space and available physical memory.  If the working set of virtual
memory of all the processes is larger than the available physical memory
the system will slow down dramatically due to constant swapping of
memory content from the memory to the storage media and back.  This is
called "thrashing".  

   A final aspect of virtual memory which is important and follows from
what is said in the last paragraph is the granularity of the virtual
address space handling.  When we said that the virtual address handling
stores memory content externally it cannot do this on a byte-by-byte
basis.  The administrative overhead does not allow this (leaving alone
the processor hardware).  Instead several thousand bytes are handled
together and form a "page".  The size of each page is always a power of
two byte.  The smallest page size in use today is 4096, with 8192,
16384, and 65536 being other popular sizes.


File: libc.info,  Node: Query Memory Parameters,  Prev: Memory Subsystem,  Up: Memory Resources

22.4.2 How to get information about the memory subsystem?
---------------------------------------------------------

The page size of the virtual memory the process sees is essential to
know in several situations.  Some programming interface (e.g., `mmap',
*note Memory-mapped I/O::) require the user to provide information
adjusted to the page size.  In the case of `mmap' is it necessary to
provide a length argument which is a multiple of the page size.
Another place where the knowledge about the page size is useful is in
memory allocation.  If one allocates pieces of memory in larger chunks
which are then subdivided by the application code it is useful to
adjust the size of the larger blocks to the page size.  If the total
memory requirement for the block is close (but not larger) to a multiple
of the page size the kernel's memory handling can work more effectively
since it only has to allocate memory pages which are fully used.  (To do
this optimization it is necessary to know a bit about the memory
allocator which will require a bit of memory itself for each block and
this overhead must not push the total size over the page size multiple.

   The page size traditionally was a compile time constant.  But recent
development of processors changed this.  Processors now support
different page sizes and they can possibly even vary among different
processes on the same system.  Therefore the system should be queried at
runtime about the current page size and no assumptions (except about it
being a power of two) should be made.

   The correct interface to query about the page size is `sysconf'
(*note Sysconf Definition::) with the parameter `_SC_PAGESIZE'.  There
is a much older interface available, too.

 -- Function: int getpagesize (void)
     The `getpagesize' function returns the page size of the process.
     This value is fixed for the runtime of the process but can vary in
     different runs of the application.

     The function is declared in `unistd.h'.

   Widely available on System V derived systems is a method to get
information about the physical memory the system has.  The call

       sysconf (_SC_PHYS_PAGES)

returns the total number of pages of physical the system has.  This
does not mean all this memory is available.  This information can be
found using

       sysconf (_SC_AVPHYS_PAGES)

   These two values help to optimize applications.  The value returned
for `_SC_AVPHYS_PAGES' is the amount of memory the application can use
without hindering any other process (given that no other process
increases its memory usage).  The value returned for `_SC_PHYS_PAGES'
is more or less a hard limit for the working set.  If all applications
together constantly use more than that amount of memory the system is
in trouble.

   The GNU C library provides in addition to these already described
way to get this information two functions.  They are declared in the
file `sys/sysinfo.h'.  Programmers should prefer to use the `sysconf'
method described above.

 -- Function: long int get_phys_pages (void)
     The `get_phys_pages' function returns the total number of pages of
     physical the system has.  To get the amount of memory this number
     has to be multiplied by the page size.

     This function is a GNU extension.

 -- Function: long int get_avphys_pages (void)
     The `get_phys_pages' function returns the number of available
     pages of physical the system has.  To get the amount of memory
     this number has to be multiplied by the page size.

     This function is a GNU extension.


File: libc.info,  Node: Processor Resources,  Prev: Memory Resources,  Up: Resource Usage And Limitation

22.5 Learn about the processors available
=========================================

The use of threads or processes with shared memory allows an application
to take advantage of all the processing power a system can provide.  If
the task can be parallelized the optimal way to write an application is
to have at any time as many processes running as there are processors.
To determine the number of processors available to the system one can
run

       sysconf (_SC_NPROCESSORS_CONF)

which returns the number of processors the operating system configured.
But it might be possible for the operating system to disable individual
processors and so the call

       sysconf (_SC_NPROCESSORS_ONLN)

returns the number of processors which are currently inline (i.e.,
available).

   For these two pieces of information the GNU C library also provides
functions to get the information directly.  The functions are declared
in `sys/sysinfo.h'.

 -- Function: int get_nprocs_conf (void)
     The `get_nprocs_conf' function returns the number of processors the
     operating system configured.

     This function is a GNU extension.

 -- Function: int get_nprocs (void)
     The `get_nprocs' function returns the number of available
     processors.

     This function is a GNU extension.

   Before starting more threads it should be checked whether the
processors are not already overused.  Unix systems calculate something
called the "load average".  This is a number indicating how many
processes were running.  This number is average over different periods
of times (normally 1, 5, and 15 minutes).

 -- Function: int getloadavg (double LOADAVG[], int NELEM)
     This function gets the 1, 5 and 15 minute load averages of the
     system. The values are placed in LOADAVG.  `getloadavg' will place
     at most NELEM elements into the array but never more than three
     elements.  The return value is the number of elements written to
     LOADAVG, or -1 on error.

     This function is declared in `stdlib.h'.


File: libc.info,  Node: Non-Local Exits,  Next: Signal Handling,  Prev: Resource Usage And Limitation,  Up: Top

23 Non-Local Exits
******************

Sometimes when your program detects an unusual situation inside a deeply
nested set of function calls, you would like to be able to immediately
return to an outer level of control.  This section describes how you can
do such "non-local exits" using the `setjmp' and `longjmp' functions.

* Menu:

* Intro: Non-Local Intro.        When and how to use these facilities.
* Details: Non-Local Details.    Functions for non-local exits.
* Non-Local Exits and Signals::  Portability issues.
* System V contexts::            Complete context control a la System V.


File: libc.info,  Node: Non-Local Intro,  Next: Non-Local Details,  Up: Non-Local Exits

23.1 Introduction to Non-Local Exits
====================================

As an example of a situation where a non-local exit can be useful,
suppose you have an interactive program that has a "main loop" that
prompts for and executes commands.  Suppose the "read" command reads
input from a file, doing some lexical analysis and parsing of the input
while processing it.  If a low-level input error is detected, it would
be useful to be able to return immediately to the "main loop" instead
of having to make each of the lexical analysis, parsing, and processing
phases all have to explicitly deal with error situations initially
detected by nested calls.

   (On the other hand, if each of these phases has to do a substantial
amount of cleanup when it exits--such as closing files, deallocating
buffers or other data structures, and the like--then it can be more
appropriate to do a normal return and have each phase do its own
cleanup, because a non-local exit would bypass the intervening phases
and their associated cleanup code entirely.  Alternatively, you could
use a non-local exit but do the cleanup explicitly either before or
after returning to the "main loop".)

   In some ways, a non-local exit is similar to using the `return'
statement to return from a function.  But while `return' abandons only
a single function call, transferring control back to the point at which
it was called, a non-local exit can potentially abandon many levels of
nested function calls.

   You identify return points for non-local exits by calling the
function `setjmp'.  This function saves information about the execution
environment in which the call to `setjmp' appears in an object of type
`jmp_buf'.  Execution of the program continues normally after the call
to `setjmp', but if an exit is later made to this return point by
calling `longjmp' with the corresponding `jmp_buf' object, control is
transferred back to the point where `setjmp' was called.  The return
value from `setjmp' is used to distinguish between an ordinary return
and a return made by a call to `longjmp', so calls to `setjmp' usually
appear in an `if' statement.

   Here is how the example program described above might be set up:

     #include <setjmp.h>
     #include <stdlib.h>
     #include <stdio.h>

     jmp_buf main_loop;

     void
     abort_to_main_loop (int status)
     {
       longjmp (main_loop, status);
     }

     int
     main (void)
     {
       while (1)
         if (setjmp (main_loop))
           puts ("Back at main loop....");
         else
           do_command ();
     }


     void
     do_command (void)
     {
       char buffer[128];
       if (fgets (buffer, 128, stdin) == NULL)
         abort_to_main_loop (-1);
       else
         exit (EXIT_SUCCESS);
     }

   The function `abort_to_main_loop' causes an immediate transfer of
control back to the main loop of the program, no matter where it is
called from.

   The flow of control inside the `main' function may appear a little
mysterious at first, but it is actually a common idiom with `setjmp'.
A normal call to `setjmp' returns zero, so the "else" clause of the
conditional is executed.  If `abort_to_main_loop' is called somewhere
within the execution of `do_command', then it actually appears as if
the _same_ call to `setjmp' in `main' were returning a second time with
a value of `-1'.

   So, the general pattern for using `setjmp' looks something like:

     if (setjmp (BUFFER))
       /* Code to clean up after premature return. */
       ...
     else
       /* Code to be executed normally after setting up the return point. */
       ...


File: libc.info,  Node: Non-Local Details,  Next: Non-Local Exits and Signals,  Prev: Non-Local Intro,  Up: Non-Local Exits

23.2 Details of Non-Local Exits
===============================

Here are the details on the functions and data structures used for
performing non-local exits.  These facilities are declared in
`setjmp.h'.  

 -- Data Type: jmp_buf
     Objects of type `jmp_buf' hold the state information to be
     restored by a non-local exit.  The contents of a `jmp_buf'
     identify a specific place to return to.

 -- Macro: int setjmp (jmp_buf STATE)
     When called normally, `setjmp' stores information about the
     execution state of the program in STATE and returns zero.  If
     `longjmp' is later used to perform a non-local exit to this STATE,
     `setjmp' returns a nonzero value.

 -- Function: void longjmp (jmp_buf STATE, int VALUE)
     This function restores current execution to the state saved in
     STATE, and continues execution from the call to `setjmp' that
     established that return point.  Returning from `setjmp' by means of
     `longjmp' returns the VALUE argument that was passed to `longjmp',
     rather than `0'.  (But if VALUE is given as `0', `setjmp' returns
     `1').

   There are a lot of obscure but important restrictions on the use of
`setjmp' and `longjmp'.  Most of these restrictions are present because
non-local exits require a fair amount of magic on the part of the C
compiler and can interact with other parts of the language in strange
ways.

   The `setjmp' function is actually a macro without an actual function
definition, so you shouldn't try to `#undef' it or take its address.
In addition, calls to `setjmp' are safe in only the following contexts:

   * As the test expression of a selection or iteration statement (such
     as `if', `switch', or `while').

   * As one operand of a equality or comparison operator that appears
     as the test expression of a selection or iteration statement.  The
     other operand must be an integer constant expression.

   * As the operand of a unary `!' operator, that appears as the test
     expression of a selection or iteration statement.

   * By itself as an expression statement.

   Return points are valid only during the dynamic extent of the
function that called `setjmp' to establish them.  If you `longjmp' to a
return point that was established in a function that has already
returned, unpredictable and disastrous things are likely to happen.

   You should use a nonzero VALUE argument to `longjmp'.  While
`longjmp' refuses to pass back a zero argument as the return value from
`setjmp', this is intended as a safety net against accidental misuse
and is not really good programming style.

   When you perform a non-local exit, accessible objects generally
retain whatever values they had at the time `longjmp' was called.  The
exception is that the values of automatic variables local to the
function containing the `setjmp' call that have been changed since the
call to `setjmp' are indeterminate, unless you have declared them
`volatile'.


File: libc.info,  Node: Non-Local Exits and Signals,  Next: System V contexts,  Prev: Non-Local Details,  Up: Non-Local Exits

23.3 Non-Local Exits and Signals
================================

In BSD Unix systems, `setjmp' and `longjmp' also save and restore the
set of blocked signals; see *Note Blocking Signals::.  However, the
POSIX.1 standard requires `setjmp' and `longjmp' not to change the set
of blocked signals, and provides an additional pair of functions
(`sigsetjmp' and `siglongjmp') to get the BSD behavior.

   The behavior of `setjmp' and `longjmp' in the GNU library is
controlled by feature test macros; see *Note Feature Test Macros::.  The
default in the GNU system is the POSIX.1 behavior rather than the BSD
behavior.

   The facilities in this section are declared in the header file
`setjmp.h'.  

 -- Data Type: sigjmp_buf
     This is similar to `jmp_buf', except that it can also store state
     information about the set of blocked signals.

 -- Function: int sigsetjmp (sigjmp_buf STATE, int SAVESIGS)
     This is similar to `setjmp'.  If SAVESIGS is nonzero, the set of
     blocked signals is saved in STATE and will be restored if a
     `siglongjmp' is later performed with this STATE.

 -- Function: void siglongjmp (sigjmp_buf STATE, int VALUE)
     This is similar to `longjmp' except for the type of its STATE
     argument.  If the `sigsetjmp' call that set this STATE used a
     nonzero SAVESIGS flag, `siglongjmp' also restores the set of
     blocked signals.


File: libc.info,  Node: System V contexts,  Prev: Non-Local Exits and Signals,  Up: Non-Local Exits

23.4 Complete Context Control
=============================

The Unix standard one more set of function to control the execution path
and these functions are more powerful than those discussed in this
chapter so far.  These function were part of the original System V API
and by this route were added to the Unix API.  Beside on branded Unix
implementations these interfaces are not widely available.  Not all
platforms and/or architectures the GNU C Library is available on provide
this interface.  Use `configure' to detect the availability.

   Similar to the `jmp_buf' and `sigjmp_buf' types used for the
variables to contain the state of the `longjmp' functions the
interfaces of interest here have an appropriate type as well.  Objects
of this type are normally much larger since more information is
contained.  The type is also used in a few more places as we will see.
The types and functions described in this section are all defined and
declared respectively in the `ucontext.h' header file.

 -- Data Type: ucontext_t
     The `ucontext_t' type is defined as a structure with as least the
     following elements:

    `ucontext_t *uc_link'
          This is a pointer to the next context structure which is used
          if the context described in the current structure returns.

    `sigset_t uc_sigmask'
          Set of signals which are blocked when this context is used.

    `stack_t uc_stack'
          Stack used for this context.  The value need not be (and
          normally is not) the stack pointer.  *Note Signal Stack::.

    `mcontext_t uc_mcontext'
          This element contains the actual state of the process.  The
          `mcontext_t' type is also defined in this header but the
          definition should be treated as opaque.  Any use of knowledge
          of the type makes applications less portable.


   Objects of this type have to be created by the user.  The
initialization and modification happens through one of the following
functions:

 -- Function: int getcontext (ucontext_t *UCP)
     The `getcontext' function initializes the variable pointed to by
     UCP with the context of the calling thread.  The context contains
     the content of the registers, the signal mask, and the current
     stack.  Executing the contents would start at the point where the
     `getcontext' call just returned.

     The function returns `0' if successful.  Otherwise it returns `-1'
     and sets ERRNO accordingly.

   The `getcontext' function is similar to `setjmp' but it does not
provide an indication of whether the function returns for the first
time or whether the initialized context was used and the execution is
resumed at just that point.  If this is necessary the user has to take
determine this herself.  This must be done carefully since the context
contains registers which might contain register variables.  This is a
good situation to define variables with `volatile'.

   Once the context variable is initialized it can be used as is or it
can be modified.  The latter is normally done to implement co-routines
or similar constructs.  The `makecontext' function is what has to be
used to do that.

 -- Function: void makecontext (ucontext_t *UCP, void (*FUNC) (void),
          int ARGC, ...)
     The UCP parameter passed to the `makecontext' shall be initialized
     by a call to `getcontext'.  The context will be modified to in a
     way so that if the context is resumed it will start by calling the
     function `func' which gets ARGC integer arguments passed.  The
     integer arguments which are to be passed should follow the ARGC
     parameter in the call to `makecontext'.

     Before the call to this function the `uc_stack' and `uc_link'
     element of the UCP structure should be initialized.  The
     `uc_stack' element describes the stack which is used for this
     context.  No two contexts which are used at the same time should
     use the same memory region for a stack.

     The `uc_link' element of the object pointed to by UCP should be a
     pointer to the context to be executed when the function FUNC
     returns or it should be a null pointer.  See `setcontext' for more
     information about the exact use.

   While allocating the memory for the stack one has to be careful.
Most modern processors keep track of whether a certain memory region is
allowed to contain code which is executed or not.  Data segments and
heap memory is normally not tagged to allow this.  The result is that
programs would fail.  Examples for such code include the calling
sequences the GNU C compiler generates for calls to nested functions.
Safe ways to allocate stacks correctly include using memory on the
original threads stack or explicitly allocate memory tagged for
execution using (*note Memory-mapped I/O::).

   *Compatibility note*: The current Unix standard is very imprecise
about the way the stack is allocated.  All implementations seem to agree
that the `uc_stack' element must be used but the values stored in the
elements of the `stack_t' value are unclear.  The GNU C library and
most other Unix implementations require the `ss_sp' value of the
`uc_stack' element to point to the base of the memory region allocated
for the stack and the size of the memory region is stored in `ss_size'.
There are implements out there which require `ss_sp' to be set to the
value the stack pointer will have (which can depending on the direction
the stack grows be different).  This difference makes the `makecontext'
function hard to use and it requires detection of the platform at
compile time.

 -- Function: int setcontext (const ucontext_t *UCP)
     The `setcontext' function restores the context described by UCP.
     The context is not modified and can be reused as often as wanted.

     If the context was created by `getcontext' execution resumes with
     the registers filled with the same values and the same stack as if
     the `getcontext' call just returned.

     If the context was modified with a call to `makecontext' execution
     continues with the function passed to `makecontext' which gets the
     specified parameters passed.  If this function returns execution is
     resumed in the context which was referenced by the `uc_link'
     element of the context structure passed to `makecontext' at the
     time of the call.  If `uc_link' was a null pointer the application
     terminates in this case.

     Since the context contains information about the stack no two
     threads should use the same context at the same time.  The result
     in most cases would be disastrous.

     The `setcontext' function does not return unless an error occurred
     in which case it returns `-1'.

   The `setcontext' function simply replaces the current context with
the one described by the UCP parameter.  This is often useful but there
are situations where the current context has to be preserved.

 -- Function: int swapcontext (ucontext_t *restrict OUCP, const
          ucontext_t *restrict UCP)
     The `swapcontext' function is similar to `setcontext' but instead
     of just replacing the current context the latter is first saved in
     the object pointed to by OUCP as if this was a call to
     `getcontext'.  The saved context would resume after the call to
     `swapcontext'.

     Once the current context is saved the context described in UCP is
     installed and execution continues as described in this context.

     If `swapcontext' succeeds the function does not return unless the
     context OUCP is used without prior modification by `makecontext'.
     The return value in this case is `0'.  If the function fails it
     returns `-1' and set ERRNO accordingly.

Example for SVID Context Handling
=================================

The easiest way to use the context handling functions is as a
replacement for `setjmp' and `longjmp'.  The context contains on most
platforms more information which might lead to less surprises but this
also means using these functions is more expensive (beside being less
portable).

     int
     random_search (int n, int (*fp) (int, ucontext_t *))
     {
       volatile int cnt = 0;
       ucontext_t uc;

       /* Safe current context.  */
       if (getcontext (&uc) < 0)
         return -1;

       /* If we have not tried N times try again.  */
       if (cnt++ < n)
         /* Call the function with a new random number
            and the context.  */
         if (fp (rand (), &uc) != 0)
           /* We found what we were looking for.  */
           return 1;

       /* Not found.  */
       return 0;
     }

   Using contexts in such a way enables emulating exception handling.
The search functions passed in the FP parameter could be very large,
nested, and complex which would make it complicated (or at least would
require a lot of code) to leave the function with an error value which
has to be passed down to the caller.  By using the context it is
possible to leave the search function in one step and allow restarting
the search which also has the nice side effect that it can be
significantly faster.

   Something which is harder to implement with `setjmp' and `longjmp'
is to switch temporarily to a different execution path and then resume
where execution was stopped.

     #include <signal.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <ucontext.h>
     #include <sys/time.h>

     /* Set by the signal handler. */
     static volatile int expired;

     /* The contexts. */
     static ucontext_t uc[3];

     /* We do only a certain number of switches. */
     static int switches;


     /* This is the function doing the work.  It is just a
        skeleton, real code has to be filled in. */
     static void
     f (int n)
     {
       int m = 0;
       while (1)
         {
           /* This is where the work would be done. */
           if (++m % 100 == 0)
             {
               putchar ('.');
               fflush (stdout);
             }

           /* Regularly the EXPIRE variable must be checked. */
           if (expired)
             {
               /* We do not want the program to run forever. */
               if (++switches == 20)
                 return;

               printf ("\nswitching from %d to %d\n", n, 3 - n);
               expired = 0;
               /* Switch to the other context, saving the current one. */
               swapcontext (&uc[n], &uc[3 - n]);
             }
         }
     }

     /* This is the signal handler which simply set the variable. */
     void
     handler (int signal)
     {
       expired = 1;
     }


     int
     main (void)
     {
       struct sigaction sa;
       struct itimerval it;
       char st1[8192];
       char st2[8192];

       /* Initialize the data structures for the interval timer. */
       sa.sa_flags = SA_RESTART;
       sigfillset (&sa.sa_mask);
       sa.sa_handler = handler;
       it.it_interval.tv_sec = 0;
       it.it_interval.tv_usec = 1;
       it.it_value = it.it_interval;

       /* Install the timer and get the context we can manipulate. */
       if (sigaction (SIGPROF, &sa, NULL) < 0
           || setitimer (ITIMER_PROF, &it, NULL) < 0
           || getcontext (&uc[1]) == -1
           || getcontext (&uc[2]) == -1)
         abort ();

       /* Create a context with a separate stack which causes the
          function `f' to be call with the parameter `1'.
          Note that the `uc_link' points to the main context
          which will cause the program to terminate once the function
          return. */
       uc[1].uc_link = &uc[0];
       uc[1].uc_stack.ss_sp = st1;
       uc[1].uc_stack.ss_size = sizeof st1;
       makecontext (&uc[1], (void (*) (void)) f, 1, 1);

       /* Similarly, but `2' is passed as the parameter to `f'. */
       uc[2].uc_link = &uc[0];
       uc[2].uc_stack.ss_sp = st2;
       uc[2].uc_stack.ss_size = sizeof st2;
       makecontext (&uc[2], (void (*) (void)) f, 1, 2);

       /* Start running. */
       swapcontext (&uc[0], &uc[1]);
       putchar ('\n');

       return 0;
     }

   This an example how the context functions can be used to implement
co-routines or cooperative multi-threading.  All that has to be done is
to call every once in a while `swapcontext' to continue running a
different context.  It is not allowed to do the context switching from
the signal handler directly since neither `setcontext' nor
`swapcontext' are functions which can be called from a signal handler.
But setting a variable in the signal handler and checking it in the
body of the functions which are executed.  Since `swapcontext' is
saving the current context it is possible to have multiple different
scheduling points in the code.  Execution will always resume where it
was left.


File: libc.info,  Node: Signal Handling,  Next: Program Basics,  Prev: Non-Local Exits,  Up: Top

24 Signal Handling
******************

A "signal" is a software interrupt delivered to a process.  The
operating system uses signals to report exceptional situations to an
executing program.  Some signals report errors such as references to
invalid memory addresses; others report asynchronous events, such as
disconnection of a phone line.

   The GNU C library defines a variety of signal types, each for a
particular kind of event.  Some kinds of events make it inadvisable or
impossible for the program to proceed as usual, and the corresponding
signals normally abort the program.  Other kinds of signals that report
harmless events are ignored by default.

   If you anticipate an event that causes signals, you can define a
handler function and tell the operating system to run it when that
particular type of signal arrives.

   Finally, one process can send a signal to another process; this
allows a parent process to abort a child, or two related processes to
communicate and synchronize.

* Menu:

* Concepts of Signals::         Introduction to the signal facilities.
* Standard Signals::            Particular kinds of signals with
                                 standard names and meanings.
* Signal Actions::              Specifying what happens when a
                                 particular signal is delivered.
* Defining Handlers::           How to write a signal handler function.
* Interrupted Primitives::	Signal handlers affect use of `open',
				 `read', `write' and other functions.
* Generating Signals::          How to send a signal to a process.
* Blocking Signals::            Making the system hold signals temporarily.
* Waiting for a Signal::        Suspending your program until a signal
                                 arrives.
* Signal Stack::                Using a Separate Signal Stack.
* BSD Signal Handling::         Additional functions for backward
			         compatibility with BSD.


File: libc.info,  Node: Concepts of Signals,  Next: Standard Signals,  Up: Signal Handling

24.1 Basic Concepts of Signals
==============================

This section explains basic concepts of how signals are generated, what
happens after a signal is delivered, and how programs can handle
signals.

* Menu:

* Kinds of Signals::            Some examples of what can cause a signal.
* Signal Generation::           Concepts of why and how signals occur.
* Delivery of Signal::          Concepts of what a signal does to the
                                 process.


File: libc.info,  Node: Kinds of Signals,  Next: Signal Generation,  Up: Concepts of Signals

24.1.1 Some Kinds of Signals
----------------------------

A signal reports the occurrence of an exceptional event.  These are some
of the events that can cause (or "generate", or "raise") a signal:

   * A program error such as dividing by zero or issuing an address
     outside the valid range.

   * A user request to interrupt or terminate the program.  Most
     environments are set up to let a user suspend the program by
     typing `C-z', or terminate it with `C-c'.  Whatever key sequence
     is used, the operating system sends the proper signal to interrupt
     the process.

   * The termination of a child process.

   * Expiration of a timer or alarm.

   * A call to `kill' or `raise' by the same process.

   * A call to `kill' from another process.  Signals are a limited but
     useful form of interprocess communication.

   * An attempt to perform an I/O operation that cannot be done.
     Examples are reading from a pipe that has no writer (*note Pipes
     and FIFOs::), and reading or writing to a terminal in certain
     situations (*note Job Control::).

   Each of these kinds of events (excepting explicit calls to `kill'
and `raise') generates its own particular kind of signal.  The various
kinds of signals are listed and described in detail in *Note Standard
Signals::.


File: libc.info,  Node: Signal Generation,  Next: Delivery of Signal,  Prev: Kinds of Signals,  Up: Concepts of Signals

24.1.2 Concepts of Signal Generation
------------------------------------

In general, the events that generate signals fall into three major
categories: errors, external events, and explicit requests.

   An error means that a program has done something invalid and cannot
continue execution.  But not all kinds of errors generate signals--in
fact, most do not.  For example, opening a nonexistent file is an error,
but it does not raise a signal; instead, `open' returns `-1'.  In
general, errors that are necessarily associated with certain library
functions are reported by returning a value that indicates an error.
The errors which raise signals are those which can happen anywhere in
the program, not just in library calls.  These include division by zero
and invalid memory addresses.

   An external event generally has to do with I/O or other processes.
These include the arrival of input, the expiration of a timer, and the
termination of a child process.

   An explicit request means the use of a library function such as
`kill' whose purpose is specifically to generate a signal.

   Signals may be generated "synchronously" or "asynchronously".  A
synchronous signal pertains to a specific action in the program, and is
delivered (unless blocked) during that action.  Most errors generate
signals synchronously, and so do explicit requests by a process to
generate a signal for that same process.  On some machines, certain
kinds of hardware errors (usually floating-point exceptions) are not
reported completely synchronously, but may arrive a few instructions
later.

   Asynchronous signals are generated by events outside the control of
the process that receives them.  These signals arrive at unpredictable
times during execution.  External events generate signals
asynchronously, and so do explicit requests that apply to some other
process.

   A given type of signal is either typically synchronous or typically
asynchronous.  For example, signals for errors are typically synchronous
because errors generate signals synchronously.  But any type of signal
can be generated synchronously or asynchronously with an explicit
request.


File: libc.info,  Node: Delivery of Signal,  Prev: Signal Generation,  Up: Concepts of Signals

24.1.3 How Signals Are Delivered
--------------------------------

When a signal is generated, it becomes "pending".  Normally it remains
pending for just a short period of time and then is "delivered" to the
process that was signaled.  However, if that kind of signal is
currently "blocked", it may remain pending indefinitely--until signals
of that kind are "unblocked".  Once unblocked, it will be delivered
immediately.  *Note Blocking Signals::.

   When the signal is delivered, whether right away or after a long
delay, the "specified action" for that signal is taken.  For certain
signals, such as `SIGKILL' and `SIGSTOP', the action is fixed, but for
most signals, the program has a choice: ignore the signal, specify a
"handler function", or accept the "default action" for that kind of
signal.  The program specifies its choice using functions such as
`signal' or `sigaction' (*note Signal Actions::).  We sometimes say
that a handler "catches" the signal.  While the handler is running,
that particular signal is normally blocked.

   If the specified action for a kind of signal is to ignore it, then
any such signal which is generated is discarded immediately.  This
happens even if the signal is also blocked at the time.  A signal
discarded in this way will never be delivered, not even if the program
subsequently specifies a different action for that kind of signal and
then unblocks it.

   If a signal arrives which the program has neither handled nor
ignored, its "default action" takes place.  Each kind of signal has its
own default action, documented below (*note Standard Signals::).  For
most kinds of signals, the default action is to terminate the process.
For certain kinds of signals that represent "harmless" events, the
default action is to do nothing.

   When a signal terminates a process, its parent process can determine
the cause of termination by examining the termination status code
reported by the `wait' or `waitpid' functions.  (This is discussed in
more detail in *Note Process Completion::.)  The information it can get
includes the fact that termination was due to a signal and the kind of
signal involved.  If a program you run from a shell is terminated by a
signal, the shell typically prints some kind of error message.

   The signals that normally represent program errors have a special
property: when one of these signals terminates the process, it also
writes a "core dump file" which records the state of the process at the
time of termination.  You can examine the core dump with a debugger to
investigate what caused the error.

   If you raise a "program error" signal by explicit request, and this
terminates the process, it makes a core dump file just as if the signal
had been due directly to an error.


File: libc.info,  Node: Standard Signals,  Next: Signal Actions,  Prev: Concepts of Signals,  Up: Signal Handling

24.2 Standard Signals
=====================

This section lists the names for various standard kinds of signals and
describes what kind of event they mean.  Each signal name is a macro
which stands for a positive integer--the "signal number" for that kind
of signal.  Your programs should never make assumptions about the
numeric code for a particular kind of signal, but rather refer to them
always by the names defined here.  This is because the number for a
given kind of signal can vary from system to system, but the meanings of
the names are standardized and fairly uniform.

   The signal names are defined in the header file `signal.h'.

 -- Macro: int NSIG
     The value of this symbolic constant is the total number of signals
     defined.  Since the signal numbers are allocated consecutively,
     `NSIG' is also one greater than the largest defined signal number.

* Menu:

* Program Error Signals::       Used to report serious program errors.
* Termination Signals::         Used to interrupt and/or terminate the
                                 program.
* Alarm Signals::               Used to indicate expiration of timers.
* Asynchronous I/O Signals::    Used to indicate input is available.
* Job Control Signals::         Signals used to support job control.
* Operation Error Signals::     Used to report operational system errors.
* Miscellaneous Signals::       Miscellaneous Signals.
* Signal Messages::             Printing a message describing a signal.


File: libc.info,  Node: Program Error Signals,  Next: Termination Signals,  Up: Standard Signals

24.2.1 Program Error Signals
----------------------------

The following signals are generated when a serious program error is
detected by the operating system or the computer itself.  In general,
all of these signals are indications that your program is seriously
broken in some way, and there's usually no way to continue the
computation which encountered the error.

   Some programs handle program error signals in order to tidy up before
terminating; for example, programs that turn off echoing of terminal
input should handle program error signals in order to turn echoing back
on.  The handler should end by specifying the default action for the
signal that happened and then reraising it; this will cause the program
to terminate with that signal, as if it had not had a handler.  (*Note
Termination in Handler::.)

   Termination is the sensible ultimate outcome from a program error in
most programs.  However, programming systems such as Lisp that can load
compiled user programs might need to keep executing even if a user
program incurs an error.  These programs have handlers which use
`longjmp' to return control to the command level.

   The default action for all of these signals is to cause the process
to terminate.  If you block or ignore these signals or establish
handlers for them that return normally, your program will probably
break horribly when such signals happen, unless they are generated by
`raise' or `kill' instead of a real error.

   When one of these program error signals terminates a process, it also
writes a "core dump file" which records the state of the process at the
time of termination.  The core dump file is named `core' and is written
in whichever directory is current in the process at the time.  (On the
GNU system, you can specify the file name for core dumps with the
environment variable `COREFILE'.)  The purpose of core dump files is so
that you can examine them with a debugger to investigate what caused
the error.

 -- Macro: int SIGFPE
     The `SIGFPE' signal reports a fatal arithmetic error.  Although the
     name is derived from "floating-point exception", this signal
     actually covers all arithmetic errors, including division by zero
     and overflow.  If a program stores integer data in a location
     which is then used in a floating-point operation, this often
     causes an "invalid operation" exception, because the processor
     cannot recognize the data as a floating-point number.  

     Actual floating-point exceptions are a complicated subject because
     there are many types of exceptions with subtly different meanings,
     and the `SIGFPE' signal doesn't distinguish between them.  The
     `IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std
     754-1985 and ANSI/IEEE Std 854-1987)' defines various
     floating-point exceptions and requires conforming computer systems
     to report their occurrences.  However, this standard does not
     specify how the exceptions are reported, or what kinds of handling
     and control the operating system can offer to the programmer.

   BSD systems provide the `SIGFPE' handler with an extra argument that
distinguishes various causes of the exception.  In order to access this
argument, you must define the handler to accept two arguments, which
means you must cast it to a one-argument function type in order to
establish the handler.  The GNU library does provide this extra
argument, but the value is meaningful only on operating systems that
provide the information (BSD systems and GNU systems).

`FPE_INTOVF_TRAP'
     Integer overflow (impossible in a C program unless you enable
     overflow trapping in a hardware-specific fashion).

`FPE_INTDIV_TRAP'
     Integer division by zero.

`FPE_SUBRNG_TRAP'
     Subscript-range (something that C programs never check for).

`FPE_FLTOVF_TRAP'
     Floating overflow trap.

`FPE_FLTDIV_TRAP'
     Floating/decimal division by zero.

`FPE_FLTUND_TRAP'
     Floating underflow trap.  (Trapping on floating underflow is not
     normally enabled.)

`FPE_DECOVF_TRAP'
     Decimal overflow trap.  (Only a few machines have decimal
     arithmetic and C never uses it.)

 -- Macro: int SIGILL
     The name of this signal is derived from "illegal instruction"; it
     usually means your program is trying to execute garbage or a
     privileged instruction.  Since the C compiler generates only valid
     instructions, `SIGILL' typically indicates that the executable
     file is corrupted, or that you are trying to execute data.  Some
     common ways of getting into the latter situation are by passing an
     invalid object where a pointer to a function was expected, or by
     writing past the end of an automatic array (or similar problems
     with pointers to automatic variables) and corrupting other data on
     the stack such as the return address of a stack frame.

     `SIGILL' can also be generated when the stack overflows, or when
     the system has trouble running the handler for a signal.
   
 -- Macro: int SIGSEGV
     This signal is generated when a program tries to read or write
     outside the memory that is allocated for it, or to write memory
     that can only be read.  (Actually, the signals only occur when the
     program goes far enough outside to be detected by the system's
     memory protection mechanism.)  The name is an abbreviation for
     "segmentation violation".

     Common ways of getting a `SIGSEGV' condition include dereferencing
     a null or uninitialized pointer, or when you use a pointer to step
     through an array, but fail to check for the end of the array.  It
     varies among systems whether dereferencing a null pointer generates
     `SIGSEGV' or `SIGBUS'.

 -- Macro: int SIGBUS
     This signal is generated when an invalid pointer is dereferenced.
     Like `SIGSEGV', this signal is typically the result of
     dereferencing an uninitialized pointer.  The difference between
     the two is that `SIGSEGV' indicates an invalid access to valid
     memory, while `SIGBUS' indicates an access to an invalid address.
     In particular, `SIGBUS' signals often result from dereferencing a
     misaligned pointer, such as referring to a four-word integer at an
     address not divisible by four.  (Each kind of computer has its own
     requirements for address alignment.)

     The name of this signal is an abbreviation for "bus error".
   
 -- Macro: int SIGABRT
     This signal indicates an error detected by the program itself and
     reported by calling `abort'.  *Note Aborting a Program::.

 -- Macro: int SIGIOT
     Generated by the PDP-11 "iot" instruction.  On most machines, this
     is just another name for `SIGABRT'.

 -- Macro: int SIGTRAP
     Generated by the machine's breakpoint instruction, and possibly
     other trap instructions.  This signal is used by debuggers.  Your
     program will probably only see `SIGTRAP' if it is somehow
     executing bad instructions.

 -- Macro: int SIGEMT
     Emulator trap; this results from certain unimplemented instructions
     which might be emulated in software, or the operating system's
     failure to properly emulate them.

 -- Macro: int SIGSYS
     Bad system call; that is to say, the instruction to trap to the
     operating system was executed, but the code number for the system
     call to perform was invalid.


File: libc.info,  Node: Termination Signals,  Next: Alarm Signals,  Prev: Program Error Signals,  Up: Standard Signals

24.2.2 Termination Signals
--------------------------

These signals are all used to tell a process to terminate, in one way
or another.  They have different names because they're used for slightly
different purposes, and programs might want to handle them differently.

   The reason for handling these signals is usually so your program can
tidy up as appropriate before actually terminating.  For example, you
might want to save state information, delete temporary files, or restore
the previous terminal modes.  Such a handler should end by specifying
the default action for the signal that happened and then reraising it;
this will cause the program to terminate with that signal, as if it had
not had a handler.  (*Note Termination in Handler::.)

   The (obvious) default action for all of these signals is to cause the
process to terminate.

 -- Macro: int SIGTERM
     The `SIGTERM' signal is a generic signal used to cause program
     termination.  Unlike `SIGKILL', this signal can be blocked,
     handled, and ignored.  It is the normal way to politely ask a
     program to terminate.

     The shell command `kill' generates `SIGTERM' by default.  

 -- Macro: int SIGINT
     The `SIGINT' ("program interrupt") signal is sent when the user
     types the INTR character (normally `C-c').  *Note Special
     Characters::, for information about terminal driver support for
     `C-c'.

 -- Macro: int SIGQUIT
     The `SIGQUIT' signal is similar to `SIGINT', except that it's
     controlled by a different key--the QUIT character, usually
     `C-\'--and produces a core dump when it terminates the process,
     just like a program error signal.  You can think of this as a
     program error condition "detected" by the user.

     *Note Program Error Signals::, for information about core dumps.
     *Note Special Characters::, for information about terminal driver
     support.

     Certain kinds of cleanups are best omitted in handling `SIGQUIT'.
     For example, if the program creates temporary files, it should
     handle the other termination requests by deleting the temporary
     files.  But it is better for `SIGQUIT' not to delete them, so that
     the user can examine them in conjunction with the core dump.

 -- Macro: int SIGKILL
     The `SIGKILL' signal is used to cause immediate program
     termination.  It cannot be handled or ignored, and is therefore
     always fatal.  It is also not possible to block this signal.

     This signal is usually generated only by explicit request.  Since
     it cannot be handled, you should generate it only as a last
     resort, after first trying a less drastic method such as `C-c' or
     `SIGTERM'.  If a process does not respond to any other termination
     signals, sending it a `SIGKILL' signal will almost always cause it
     to go away.

     In fact, if `SIGKILL' fails to terminate a process, that by itself
     constitutes an operating system bug which you should report.

     The system will generate `SIGKILL' for a process itself under some
     unusual conditions where the program cannot possibly continue to
     run (even to run a signal handler).
   
 -- Macro: int SIGHUP
     The `SIGHUP' ("hang-up") signal is used to report that the user's
     terminal is disconnected, perhaps because a network or telephone
     connection was broken.  For more information about this, see *Note
     Control Modes::.

     This signal is also used to report the termination of the
     controlling process on a terminal to jobs associated with that
     session; this termination effectively disconnects all processes in
     the session from the controlling terminal.  For more information,
     see *Note Termination Internals::.


File: libc.info,  Node: Alarm Signals,  Next: Asynchronous I/O Signals,  Prev: Termination Signals,  Up: Standard Signals

24.2.3 Alarm Signals
--------------------

These signals are used to indicate the expiration of timers.  *Note
Setting an Alarm::, for information about functions that cause these
signals to be sent.

   The default behavior for these signals is to cause program
termination.  This default is rarely useful, but no other default would
be useful; most of the ways of using these signals would require
handler functions in any case.

 -- Macro: int SIGALRM
     This signal typically indicates expiration of a timer that
     measures real or clock time.  It is used by the `alarm' function,
     for example.
   
 -- Macro: int SIGVTALRM
     This signal typically indicates expiration of a timer that
     measures CPU time used by the current process.  The name is an
     abbreviation for "virtual time alarm".
   
 -- Macro: int SIGPROF
     This signal typically indicates expiration of a timer that measures
     both CPU time used by the current process, and CPU time expended on
     behalf of the process by the system.  Such a timer is used to
     implement code profiling facilities, hence the name of this signal.
   

File: libc.info,  Node: Asynchronous I/O Signals,  Next: Job Control Signals,  Prev: Alarm Signals,  Up: Standard Signals

24.2.4 Asynchronous I/O Signals
-------------------------------

The signals listed in this section are used in conjunction with
asynchronous I/O facilities.  You have to take explicit action by
calling `fcntl' to enable a particular file descriptor to generate
these signals (*note Interrupt Input::).  The default action for these
signals is to ignore them.

 -- Macro: int SIGIO
     This signal is sent when a file descriptor is ready to perform
     input or output.

     On most operating systems, terminals and sockets are the only
     kinds of files that can generate `SIGIO'; other kinds, including
     ordinary files, never generate `SIGIO' even if you ask them to.

     In the GNU system `SIGIO' will always be generated properly if you
     successfully set asynchronous mode with `fcntl'.

 -- Macro: int SIGURG
     This signal is sent when "urgent" or out-of-band data arrives on a
     socket.  *Note Out-of-Band Data::.

 -- Macro: int SIGPOLL
     This is a System V signal name, more or less similar to `SIGIO'.
     It is defined only for compatibility.


File: libc.info,  Node: Job Control Signals,  Next: Operation Error Signals,  Prev: Asynchronous I/O Signals,  Up: Standard Signals

24.2.5 Job Control Signals
--------------------------

These signals are used to support job control.  If your system doesn't
support job control, then these macros are defined but the signals
themselves can't be raised or handled.

   You should generally leave these signals alone unless you really
understand how job control works.  *Note Job Control::.

 -- Macro: int SIGCHLD
     This signal is sent to a parent process whenever one of its child
     processes terminates or stops.

     The default action for this signal is to ignore it.  If you
     establish a handler for this signal while there are child
     processes that have terminated but not reported their status via
     `wait' or `waitpid' (*note Process Completion::), whether your new
     handler applies to those processes or not depends on the
     particular operating system.

 -- Macro: int SIGCLD
     This is an obsolete name for `SIGCHLD'.

 -- Macro: int SIGCONT
     You can send a `SIGCONT' signal to a process to make it continue.
     This signal is special--it always makes the process continue if it
     is stopped, before the signal is delivered.  The default behavior
     is to do nothing else.  You cannot block this signal.  You can set
     a handler, but `SIGCONT' always makes the process continue
     regardless.

     Most programs have no reason to handle `SIGCONT'; they simply
     resume execution without realizing they were ever stopped.  You
     can use a handler for `SIGCONT' to make a program do something
     special when it is stopped and continued--for example, to reprint
     a prompt when it is suspended while waiting for input.

 -- Macro: int SIGSTOP
     The `SIGSTOP' signal stops the process.  It cannot be handled,
     ignored, or blocked.
   
 -- Macro: int SIGTSTP
     The `SIGTSTP' signal is an interactive stop signal.  Unlike
     `SIGSTOP', this signal can be handled and ignored.

     Your program should handle this signal if you have a special need
     to leave files or system tables in a secure state when a process is
     stopped.  For example, programs that turn off echoing should handle
     `SIGTSTP' so they can turn echoing back on before stopping.

     This signal is generated when the user types the SUSP character
     (normally `C-z').  For more information about terminal driver
     support, see *Note Special Characters::.
   
 -- Macro: int SIGTTIN
     A process cannot read from the user's terminal while it is running
     as a background job.  When any process in a background job tries to
     read from the terminal, all of the processes in the job are sent a
     `SIGTTIN' signal.  The default action for this signal is to stop
     the process.  For more information about how this interacts with
     the terminal driver, see *Note Access to the Terminal::.
   
 -- Macro: int SIGTTOU
     This is similar to `SIGTTIN', but is generated when a process in a
     background job attempts to write to the terminal or set its modes.
     Again, the default action is to stop the process.  `SIGTTOU' is
     only generated for an attempt to write to the terminal if the
     `TOSTOP' output mode is set; *note Output Modes::.
   
   While a process is stopped, no more signals can be delivered to it
until it is continued, except `SIGKILL' signals and (obviously)
`SIGCONT' signals.  The signals are marked as pending, but not
delivered until the process is continued.  The `SIGKILL' signal always
causes termination of the process and can't be blocked, handled or
ignored.  You can ignore `SIGCONT', but it always causes the process to
be continued anyway if it is stopped.  Sending a `SIGCONT' signal to a
process causes any pending stop signals for that process to be
discarded.  Likewise, any pending `SIGCONT' signals for a process are
discarded when it receives a stop signal.

   When a process in an orphaned process group (*note Orphaned Process
Groups::) receives a `SIGTSTP', `SIGTTIN', or `SIGTTOU' signal and does
not handle it, the process does not stop.  Stopping the process would
probably not be very useful, since there is no shell program that will
notice it stop and allow the user to continue it.  What happens instead
depends on the operating system you are using.  Some systems may do
nothing; others may deliver another signal instead, such as `SIGKILL'
or `SIGHUP'.  In the GNU system, the process dies with `SIGKILL'; this
avoids the problem of many stopped, orphaned processes lying around the
system.


File: libc.info,  Node: Operation Error Signals,  Next: Miscellaneous Signals,  Prev: Job Control Signals,  Up: Standard Signals

24.2.6 Operation Error Signals
------------------------------

These signals are used to report various errors generated by an
operation done by the program.  They do not necessarily indicate a
programming error in the program, but an error that prevents an
operating system call from completing.  The default action for all of
them is to cause the process to terminate.

 -- Macro: int SIGPIPE
     Broken pipe.  If you use pipes or FIFOs, you have to design your
     application so that one process opens the pipe for reading before
     another starts writing.  If the reading process never starts, or
     terminates unexpectedly, writing to the pipe or FIFO raises a
     `SIGPIPE' signal.  If `SIGPIPE' is blocked, handled or ignored,
     the offending call fails with `EPIPE' instead.

     Pipes and FIFO special files are discussed in more detail in *Note
     Pipes and FIFOs::.

     Another cause of `SIGPIPE' is when you try to output to a socket
     that isn't connected.  *Note Sending Data::.

 -- Macro: int SIGLOST
     Resource lost.  This signal is generated when you have an advisory
     lock on an NFS file, and the NFS server reboots and forgets about
     your lock.

     In the GNU system, `SIGLOST' is generated when any server program
     dies unexpectedly.  It is usually fine to ignore the signal;
     whatever call was made to the server that died just returns an
     error.

 -- Macro: int SIGXCPU
     CPU time limit exceeded.  This signal is generated when the process
     exceeds its soft resource limit on CPU time.  *Note Limits on
     Resources::.

 -- Macro: int SIGXFSZ
     File size limit exceeded.  This signal is generated when the
     process attempts to extend a file so it exceeds the process's soft
     resource limit on file size.  *Note Limits on Resources::.


File: libc.info,  Node: Miscellaneous Signals,  Next: Signal Messages,  Prev: Operation Error Signals,  Up: Standard Signals

24.2.7 Miscellaneous Signals
----------------------------

These signals are used for various other purposes.  In general, they
will not affect your program unless it explicitly uses them for
something.

 -- Macro: int SIGUSR1
 -- Macro: int SIGUSR2
     The `SIGUSR1' and `SIGUSR2' signals are set aside for you to use
     any way you want.  They're useful for simple interprocess
     communication, if you write a signal handler for them in the
     program that receives the signal.

     There is an example showing the use of `SIGUSR1' and `SIGUSR2' in
     *Note Signaling Another Process::.

     The default action is to terminate the process.

 -- Macro: int SIGWINCH
     Window size change.  This is generated on some systems (including
     GNU) when the terminal driver's record of the number of rows and
     columns on the screen is changed.  The default action is to ignore
     it.

     If a program does full-screen display, it should handle `SIGWINCH'.
     When the signal arrives, it should fetch the new screen size and
     reformat its display accordingly.

 -- Macro: int SIGINFO
     Information request.  In 4.4 BSD and the GNU system, this signal
     is sent to all the processes in the foreground process group of
     the controlling terminal when the user types the STATUS character
     in canonical mode; *note Signal Characters::.

     If the process is the leader of the process group, the default
     action is to print some status information about the system and
     what the process is doing.  Otherwise the default is to do nothing.


File: libc.info,  Node: Signal Messages,  Prev: Miscellaneous Signals,  Up: Standard Signals

24.2.8 Signal Messages
----------------------

We mentioned above that the shell prints a message describing the signal
that terminated a child process.  The clean way to print a message
describing a signal is to use the functions `strsignal' and `psignal'.
These functions use a signal number to specify which kind of signal to
describe.  The signal number may come from the termination status of a
child process (*note Process Completion::) or it may come from a signal
handler in the same process.

 -- Function: char * strsignal (int SIGNUM)
     This function returns a pointer to a statically-allocated string
     containing a message describing the signal SIGNUM.  You should not
     modify the contents of this string; and, since it can be rewritten
     on subsequent calls, you should save a copy of it if you need to
     reference it later.

     This function is a GNU extension, declared in the header file
     `string.h'.

 -- Function: void psignal (int SIGNUM, const char *MESSAGE)
     This function prints a message describing the signal SIGNUM to the
     standard error output stream `stderr'; see *Note Standard
     Streams::.

     If you call `psignal' with a MESSAGE that is either a null pointer
     or an empty string, `psignal' just prints the message
     corresponding to SIGNUM, adding a trailing newline.

     If you supply a non-null MESSAGE argument, then `psignal' prefixes
     its output with this string.  It adds a colon and a space
     character to separate the MESSAGE from the string corresponding to
     SIGNUM.

     This function is a BSD feature, declared in the header file
     `signal.h'.

   There is also an array `sys_siglist' which contains the messages for
the various signal codes.  This array exists on BSD systems, unlike
`strsignal'.


File: libc.info,  Node: Signal Actions,  Next: Defining Handlers,  Prev: Standard Signals,  Up: Signal Handling

24.3 Specifying Signal Actions
==============================

The simplest way to change the action for a signal is to use the
`signal' function.  You can specify a built-in action (such as to
ignore the signal), or you can "establish a handler".

   The GNU library also implements the more versatile `sigaction'
facility.  This section describes both facilities and gives suggestions
on which to use when.

* Menu:

* Basic Signal Handling::       The simple `signal' function.
* Advanced Signal Handling::    The more powerful `sigaction' function.
* Signal and Sigaction::        How those two functions interact.
* Sigaction Function Example::  An example of using the sigaction function.
* Flags for Sigaction::         Specifying options for signal handling.
* Initial Signal Actions::      How programs inherit signal actions.


File: libc.info,  Node: Basic Signal Handling,  Next: Advanced Signal Handling,  Up: Signal Actions

24.3.1 Basic Signal Handling
----------------------------

The `signal' function provides a simple interface for establishing an
action for a particular signal.  The function and associated macros are
declared in the header file `signal.h'.  

 -- Data Type: sighandler_t
     This is the type of signal handler functions.  Signal handlers
     take one integer argument specifying the signal number, and have
     return type `void'.  So, you should define handler functions like
     this:

          void HANDLER (int `signum') { ... }

     The name `sighandler_t' for this data type is a GNU extension.

 -- Function: sighandler_t signal (int SIGNUM, sighandler_t ACTION)
     The `signal' function establishes ACTION as the action for the
     signal SIGNUM.

     The first argument, SIGNUM, identifies the signal whose behavior
     you want to control, and should be a signal number.  The proper
     way to specify a signal number is with one of the symbolic signal
     names (*note Standard Signals::)--don't use an explicit number,
     because the numerical code for a given kind of signal may vary
     from operating system to operating system.

     The second argument, ACTION, specifies the action to use for the
     signal SIGNUM.  This can be one of the following:

    `SIG_DFL'
          `SIG_DFL' specifies the default action for the particular
          signal.  The default actions for various kinds of signals are
          stated in *Note Standard Signals::.

    `SIG_IGN'
          `SIG_IGN' specifies that the signal should be ignored.

          Your program generally should not ignore signals that
          represent serious events or that are normally used to request
          termination.  You cannot ignore the `SIGKILL' or `SIGSTOP'
          signals at all.  You can ignore program error signals like
          `SIGSEGV', but ignoring the error won't enable the program to
          continue executing meaningfully.  Ignoring user requests such
          as `SIGINT', `SIGQUIT', and `SIGTSTP' is unfriendly.

          When you do not wish signals to be delivered during a certain
          part of the program, the thing to do is to block them, not
          ignore them.  *Note Blocking Signals::.

    `HANDLER'
          Supply the address of a handler function in your program, to
          specify running this handler as the way to deliver the signal.

          For more information about defining signal handler functions,
          see *Note Defining Handlers::.

     If you set the action for a signal to `SIG_IGN', or if you set it
     to `SIG_DFL' and the default action is to ignore that signal, then
     any pending signals of that type are discarded (even if they are
     blocked).  Discarding the pending signals means that they will
     never be delivered, not even if you subsequently specify another
     action and unblock this kind of signal.

     The `signal' function returns the action that was previously in
     effect for the specified SIGNUM.  You can save this value and
     restore it later by calling `signal' again.

     If `signal' can't honor the request, it returns `SIG_ERR' instead.
     The following `errno' error conditions are defined for this
     function:

    `EINVAL'
          You specified an invalid SIGNUM; or you tried to ignore or
          provide a handler for `SIGKILL' or `SIGSTOP'.

   *Compatibility Note:* A problem encountered when working with the
`signal' function is that it has different semantics on BSD and SVID
systems.  The difference is that on SVID systems the signal handler is
deinstalled after signal delivery.  On BSD systems the handler must be
explicitly deinstalled.  In the GNU C Library we use the BSD version by
default.  To use the SVID version you can either use the function
`sysv_signal' (see below) or use the `_XOPEN_SOURCE' feature select
macro (*note Feature Test Macros::).  In general, use of these
functions should be avoided because of compatibility problems.  It is
better to use `sigaction' if it is available since the results are much
more reliable.

   Here is a simple example of setting up a handler to delete temporary
files when certain fatal signals happen:

     #include <signal.h>

     void
     termination_handler (int signum)
     {
       struct temp_file *p;

       for (p = temp_file_list; p; p = p->next)
         unlink (p->name);
     }

     int
     main (void)
     {
       ...
       if (signal (SIGINT, termination_handler) == SIG_IGN)
         signal (SIGINT, SIG_IGN);
       if (signal (SIGHUP, termination_handler) == SIG_IGN)
         signal (SIGHUP, SIG_IGN);
       if (signal (SIGTERM, termination_handler) == SIG_IGN)
         signal (SIGTERM, SIG_IGN);
       ...
     }

Note that if a given signal was previously set to be ignored, this code
avoids altering that setting.  This is because non-job-control shells
often ignore certain signals when starting children, and it is important
for the children to respect this.

   We do not handle `SIGQUIT' or the program error signals in this
example because these are designed to provide information for debugging
(a core dump), and the temporary files may give useful information.

 -- Function: sighandler_t sysv_signal (int SIGNUM, sighandler_t ACTION)
     The `sysv_signal' implements the behavior of the standard `signal'
     function as found on SVID systems.  The difference to BSD systems
     is that the handler is deinstalled after a delivery of a signal.

     *Compatibility Note:* As said above for `signal', this function
     should be avoided when possible.  `sigaction' is the preferred
     method.

 -- Function: sighandler_t ssignal (int SIGNUM, sighandler_t ACTION)
     The `ssignal' function does the same thing as `signal'; it is
     provided only for compatibility with SVID.

 -- Macro: sighandler_t SIG_ERR
     The value of this macro is used as the return value from `signal'
     to indicate an error.


File: libc.info,  Node: Advanced Signal Handling,  Next: Signal and Sigaction,  Prev: Basic Signal Handling,  Up: Signal Actions

24.3.2 Advanced Signal Handling
-------------------------------

The `sigaction' function has the same basic effect as `signal': to
specify how a signal should be handled by the process.  However,
`sigaction' offers more control, at the expense of more complexity.  In
particular, `sigaction' allows you to specify additional flags to
control when the signal is generated and how the handler is invoked.

   The `sigaction' function is declared in `signal.h'.  

 -- Data Type: struct sigaction
     Structures of type `struct sigaction' are used in the `sigaction'
     function to specify all the information about how to handle a
     particular signal.  This structure contains at least the following
     members:

    `sighandler_t sa_handler'
          This is used in the same way as the ACTION argument to the
          `signal' function.  The value can be `SIG_DFL', `SIG_IGN', or
          a function pointer.  *Note Basic Signal Handling::.

    `sigset_t sa_mask'
          This specifies a set of signals to be blocked while the
          handler runs.  Blocking is explained in *Note Blocking for
          Handler::.  Note that the signal that was delivered is
          automatically blocked by default before its handler is
          started; this is true regardless of the value in `sa_mask'.
          If you want that signal not to be blocked within its handler,
          you must write code in the handler to unblock it.

    `int sa_flags'
          This specifies various flags which can affect the behavior of
          the signal.  These are described in more detail in *Note
          Flags for Sigaction::.

 -- Function: int sigaction (int SIGNUM, const struct sigaction
          *restrict ACTION, struct sigaction *restrict OLD-ACTION)
     The ACTION argument is used to set up a new action for the signal
     SIGNUM, while the OLD-ACTION argument is used to return
     information about the action previously associated with this
     symbol.  (In other words, OLD-ACTION has the same purpose as the
     `signal' function's return value--you can check to see what the
     old action in effect for the signal was, and restore it later if
     you want.)

     Either ACTION or OLD-ACTION can be a null pointer.  If OLD-ACTION
     is a null pointer, this simply suppresses the return of
     information about the old action.  If ACTION is a null pointer,
     the action associated with the signal SIGNUM is unchanged; this
     allows you to inquire about how a signal is being handled without
     changing that handling.

     The return value from `sigaction' is zero if it succeeds, and `-1'
     on failure.  The following `errno' error conditions are defined
     for this function:

    `EINVAL'
          The SIGNUM argument is not valid, or you are trying to trap
          or ignore `SIGKILL' or `SIGSTOP'.


File: libc.info,  Node: Signal and Sigaction,  Next: Sigaction Function Example,  Prev: Advanced Signal Handling,  Up: Signal Actions

24.3.3 Interaction of `signal' and `sigaction'
----------------------------------------------

It's possible to use both the `signal' and `sigaction' functions within
a single program, but you have to be careful because they can interact
in slightly strange ways.

   The `sigaction' function specifies more information than the
`signal' function, so the return value from `signal' cannot express the
full range of `sigaction' possibilities.  Therefore, if you use
`signal' to save and later reestablish an action, it may not be able to
reestablish properly a handler that was established with `sigaction'.

   To avoid having problems as a result, always use `sigaction' to save
and restore a handler if your program uses `sigaction' at all.  Since
`sigaction' is more general, it can properly save and reestablish any
action, regardless of whether it was established originally with
`signal' or `sigaction'.

   On some systems if you establish an action with `signal' and then
examine it with `sigaction', the handler address that you get may not
be the same as what you specified with `signal'.  It may not even be
suitable for use as an action argument with `signal'.  But you can rely
on using it as an argument to `sigaction'.  This problem never happens
on the GNU system.

   So, you're better off using one or the other of the mechanisms
consistently within a single program.

   *Portability Note:* The basic `signal' function is a feature of
ISO C, while `sigaction' is part of the POSIX.1 standard.  If you are
concerned about portability to non-POSIX systems, then you should use
the `signal' function instead.


File: libc.info,  Node: Sigaction Function Example,  Next: Flags for Sigaction,  Prev: Signal and Sigaction,  Up: Signal Actions

24.3.4 `sigaction' Function Example
-----------------------------------

In *Note Basic Signal Handling::, we gave an example of establishing a
simple handler for termination signals using `signal'.  Here is an
equivalent example using `sigaction':

     #include <signal.h>

     void
     termination_handler (int signum)
     {
       struct temp_file *p;

       for (p = temp_file_list; p; p = p->next)
         unlink (p->name);
     }

     int
     main (void)
     {
       ...
       struct sigaction new_action, old_action;

       /* Set up the structure to specify the new action. */
       new_action.sa_handler = termination_handler;
       sigemptyset (&new_action.sa_mask);
       new_action.sa_flags = 0;

       sigaction (SIGINT, NULL, &old_action);
       if (old_action.sa_handler != SIG_IGN)
         sigaction (SIGINT, &new_action, NULL);
       sigaction (SIGHUP, NULL, &old_action);
       if (old_action.sa_handler != SIG_IGN)
         sigaction (SIGHUP, &new_action, NULL);
       sigaction (SIGTERM, NULL, &old_action);
       if (old_action.sa_handler != SIG_IGN)
         sigaction (SIGTERM, &new_action, NULL);
       ...
     }

   The program just loads the `new_action' structure with the desired
parameters and passes it in the `sigaction' call.  The usage of
`sigemptyset' is described later; see *Note Blocking Signals::.

   As in the example using `signal', we avoid handling signals
previously set to be ignored.  Here we can avoid altering the signal
handler even momentarily, by using the feature of `sigaction' that lets
us examine the current action without specifying a new one.

   Here is another example.  It retrieves information about the current
action for `SIGINT' without changing that action.

     struct sigaction query_action;

     if (sigaction (SIGINT, NULL, &query_action) < 0)
       /* `sigaction' returns -1 in case of error. */
     else if (query_action.sa_handler == SIG_DFL)
       /* `SIGINT' is handled in the default, fatal manner. */
     else if (query_action.sa_handler == SIG_IGN)
       /* `SIGINT' is ignored. */
     else
       /* A programmer-defined signal handler is in effect. */


File: libc.info,  Node: Flags for Sigaction,  Next: Initial Signal Actions,  Prev: Sigaction Function Example,  Up: Signal Actions

24.3.5 Flags for `sigaction'
----------------------------

The `sa_flags' member of the `sigaction' structure is a catch-all for
special features.  Most of the time, `SA_RESTART' is a good value to
use for this field.

   The value of `sa_flags' is interpreted as a bit mask.  Thus, you
should choose the flags you want to set, OR those flags together, and
store the result in the `sa_flags' member of your `sigaction' structure.

   Each signal number has its own set of flags.  Each call to
`sigaction' affects one particular signal number, and the flags that
you specify apply only to that particular signal.

   In the GNU C library, establishing a handler with `signal' sets all
the flags to zero except for `SA_RESTART', whose value depends on the
settings you have made with `siginterrupt'.  *Note Interrupted
Primitives::, to see what this is about.

   These macros are defined in the header file `signal.h'.

 -- Macro: int SA_NOCLDSTOP
     This flag is meaningful only for the `SIGCHLD' signal.  When the
     flag is set, the system delivers the signal for a terminated child
     process but not for one that is stopped.  By default, `SIGCHLD' is
     delivered for both terminated children and stopped children.

     Setting this flag for a signal other than `SIGCHLD' has no effect.

 -- Macro: int SA_ONSTACK
     If this flag is set for a particular signal number, the system
     uses the signal stack when delivering that kind of signal.  *Note
     Signal Stack::.  If a signal with this flag arrives and you have
     not set a signal stack, the system terminates the program with
     `SIGILL'.

 -- Macro: int SA_RESTART
     This flag controls what happens when a signal is delivered during
     certain primitives (such as `open', `read' or `write'), and the
     signal handler returns normally.  There are two alternatives: the
     library function can resume, or it can return failure with error
     code `EINTR'.

     The choice is controlled by the `SA_RESTART' flag for the
     particular kind of signal that was delivered.  If the flag is set,
     returning from a handler resumes the library function.  If the
     flag is clear, returning from a handler makes the function fail.
     *Note Interrupted Primitives::.


File: libc.info,  Node: Initial Signal Actions,  Prev: Flags for Sigaction,  Up: Signal Actions

24.3.6 Initial Signal Actions
-----------------------------

When a new process is created (*note Creating a Process::), it inherits
handling of signals from its parent process.  However, when you load a
new process image using the `exec' function (*note Executing a File::),
any signals that you've defined your own handlers for revert to their
`SIG_DFL' handling.  (If you think about it a little, this makes sense;
the handler functions from the old program are specific to that
program, and aren't even present in the address space of the new
program image.)  Of course, the new program can establish its own
handlers.

   When a program is run by a shell, the shell normally sets the initial
actions for the child process to `SIG_DFL' or `SIG_IGN', as
appropriate.  It's a good idea to check to make sure that the shell has
not set up an initial action of `SIG_IGN' before you establish your own
signal handlers.

   Here is an example of how to establish a handler for `SIGHUP', but
not if `SIGHUP' is currently ignored:

     ...
     struct sigaction temp;

     sigaction (SIGHUP, NULL, &temp);

     if (temp.sa_handler != SIG_IGN)
       {
         temp.sa_handler = handle_sighup;
         sigemptyset (&temp.sa_mask);
         sigaction (SIGHUP, &temp, NULL);
       }


File: libc.info,  Node: Defining Handlers,  Next: Interrupted Primitives,  Prev: Signal Actions,  Up: Signal Handling

24.4 Defining Signal Handlers
=============================

This section describes how to write a signal handler function that can
be established with the `signal' or `sigaction' functions.

   A signal handler is just a function that you compile together with
the rest of the program.  Instead of directly invoking the function,
you use `signal' or `sigaction' to tell the operating system to call it
when a signal arrives.  This is known as "establishing" the handler.
*Note Signal Actions::.

   There are two basic strategies you can use in signal handler
functions:

   * You can have the handler function note that the signal arrived by
     tweaking some global data structures, and then return normally.

   * You can have the handler function terminate the program or transfer
     control to a point where it can recover from the situation that
     caused the signal.

   You need to take special care in writing handler functions because
they can be called asynchronously.  That is, a handler might be called
at any point in the program, unpredictably.  If two signals arrive
during a very short interval, one handler can run within another.  This
section describes what your handler should do, and what you should
avoid.

* Menu:

* Handler Returns::             Handlers that return normally, and what
                                 this means.
* Termination in Handler::      How handler functions terminate a program.
* Longjmp in Handler::          Nonlocal transfer of control out of a
                                 signal handler.
* Signals in Handler::          What happens when signals arrive while
                                 the handler is already occupied.
* Merged Signals::		When a second signal arrives before the
				 first is handled.
* Nonreentrancy::               Do not call any functions unless you know they
                                 are reentrant with respect to signals.
* Atomic Data Access::          A single handler can run in the middle of
                                 reading or writing a single object.


File: libc.info,  Node: Handler Returns,  Next: Termination in Handler,  Up: Defining Handlers

24.4.1 Signal Handlers that Return
----------------------------------

Handlers which return normally are usually used for signals such as
`SIGALRM' and the I/O and interprocess communication signals.  But a
handler for `SIGINT' might also return normally after setting a flag
that tells the program to exit at a convenient time.

   It is not safe to return normally from the handler for a program
error signal, because the behavior of the program when the handler
function returns is not defined after a program error.  *Note Program
Error Signals::.

   Handlers that return normally must modify some global variable in
order to have any effect.  Typically, the variable is one that is
examined periodically by the program during normal operation.  Its data
type should be `sig_atomic_t' for reasons described in *Note Atomic
Data Access::.

   Here is a simple example of such a program.  It executes the body of
the loop until it has noticed that a `SIGALRM' signal has arrived.
This technique is useful because it allows the iteration in progress
when the signal arrives to complete before the loop exits.

     #include <signal.h>
     #include <stdio.h>
     #include <stdlib.h>

     /* This flag controls termination of the main loop. */
     volatile sig_atomic_t keep_going = 1;

     /* The signal handler just clears the flag and re-enables itself. */
     void
     catch_alarm (int sig)
     {
       keep_going = 0;
       signal (sig, catch_alarm);
     }

     void
     do_stuff (void)
     {
       puts ("Doing stuff while waiting for alarm....");
     }

     int
     main (void)
     {
       /* Establish a handler for SIGALRM signals. */
       signal (SIGALRM, catch_alarm);

       /* Set an alarm to go off in a little while. */
       alarm (2);

       /* Check the flag once in a while to see when to quit. */
       while (keep_going)
         do_stuff ();

       return EXIT_SUCCESS;
     }


File: libc.info,  Node: Termination in Handler,  Next: Longjmp in Handler,  Prev: Handler Returns,  Up: Defining Handlers

24.4.2 Handlers That Terminate the Process
------------------------------------------

Handler functions that terminate the program are typically used to cause
orderly cleanup or recovery from program error signals and interactive
interrupts.

   The cleanest way for a handler to terminate the process is to raise
the same signal that ran the handler in the first place.  Here is how
to do this:

     volatile sig_atomic_t fatal_error_in_progress = 0;

     void
     fatal_error_signal (int sig)
     {
       /* Since this handler is established for more than one kind of signal,
          it might still get invoked recursively by delivery of some other kind
          of signal.  Use a static variable to keep track of that. */
       if (fatal_error_in_progress)
         raise (sig);
       fatal_error_in_progress = 1;

       /* Now do the clean up actions:
          - reset terminal modes
          - kill child processes
          - remove lock files */
       ...

       /* Now reraise the signal.  We reactivate the signal's
          default handling, which is to terminate the process.
          We could just call `exit' or `abort',
          but reraising the signal sets the return status
          from the process correctly. */
       signal (sig, SIG_DFL);
       raise (sig);
     }


File: libc.info,  Node: Longjmp in Handler,  Next: Signals in Handler,  Prev: Termination in Handler,  Up: Defining Handlers

24.4.3 Nonlocal Control Transfer in Handlers
--------------------------------------------

You can do a nonlocal transfer of control out of a signal handler using
the `setjmp' and `longjmp' facilities (*note Non-Local Exits::).

   When the handler does a nonlocal control transfer, the part of the
program that was running will not continue.  If this part of the program
was in the middle of updating an important data structure, the data
structure will remain inconsistent.  Since the program does not
terminate, the inconsistency is likely to be noticed later on.

   There are two ways to avoid this problem.  One is to block the signal
for the parts of the program that update important data structures.
Blocking the signal delays its delivery until it is unblocked, once the
critical updating is finished.  *Note Blocking Signals::.

   The other way to re-initialize the crucial data structures in the
signal handler, or make their values consistent.

   Here is a rather schematic example showing the reinitialization of
one global variable.

     #include <signal.h>
     #include <setjmp.h>

     jmp_buf return_to_top_level;

     volatile sig_atomic_t waiting_for_input;

     void
     handle_sigint (int signum)
     {
       /* We may have been waiting for input when the signal arrived,
          but we are no longer waiting once we transfer control. */
       waiting_for_input = 0;
       longjmp (return_to_top_level, 1);
     }

     int
     main (void)
     {
       ...
       signal (SIGINT, sigint_handler);
       ...
       while (1) {
         prepare_for_command ();
         if (setjmp (return_to_top_level) == 0)
           read_and_execute_command ();
       }
     }

     /* Imagine this is a subroutine used by various commands. */
     char *
     read_data ()
     {
       if (input_from_terminal) {
         waiting_for_input = 1;
         ...
         waiting_for_input = 0;
       } else {
         ...
       }
     }


File: libc.info,  Node: Signals in Handler,  Next: Merged Signals,  Prev: Longjmp in Handler,  Up: Defining Handlers

24.4.4 Signals Arriving While a Handler Runs
--------------------------------------------

What happens if another signal arrives while your signal handler
function is running?

   When the handler for a particular signal is invoked, that signal is
automatically blocked until the handler returns.  That means that if two
signals of the same kind arrive close together, the second one will be
held until the first has been handled.  (The handler can explicitly
unblock the signal using `sigprocmask', if you want to allow more
signals of this type to arrive; see *Note Process Signal Mask::.)

   However, your handler can still be interrupted by delivery of another
kind of signal.  To avoid this, you can use the `sa_mask' member of the
action structure passed to `sigaction' to explicitly specify which
signals should be blocked while the signal handler runs.  These signals
are in addition to the signal for which the handler was invoked, and
any other signals that are normally blocked by the process.  *Note
Blocking for Handler::.

   When the handler returns, the set of blocked signals is restored to
the value it had before the handler ran.  So using `sigprocmask' inside
the handler only affects what signals can arrive during the execution of
the handler itself, not what signals can arrive once the handler
returns.

   *Portability Note:* Always use `sigaction' to establish a handler
for a signal that you expect to receive asynchronously, if you want
your program to work properly on System V Unix.  On this system, the
handling of a signal whose handler was established with `signal'
automatically sets the signal's action back to `SIG_DFL', and the
handler must re-establish itself each time it runs.  This practice,
while inconvenient, does work when signals cannot arrive in succession.
However, if another signal can arrive right away, it may arrive before
the handler can re-establish itself.  Then the second signal would
receive the default handling, which could terminate the process.


File: libc.info,  Node: Merged Signals,  Next: Nonreentrancy,  Prev: Signals in Handler,  Up: Defining Handlers

24.4.5 Signals Close Together Merge into One
--------------------------------------------

If multiple signals of the same type are delivered to your process
before your signal handler has a chance to be invoked at all, the
handler may only be invoked once, as if only a single signal had
arrived.  In effect, the signals merge into one.  This situation can
arise when the signal is blocked, or in a multiprocessing environment
where the system is busy running some other processes while the signals
are delivered.  This means, for example, that you cannot reliably use a
signal handler to count signals.  The only distinction you can reliably
make is whether at least one signal has arrived since a given time in
the past.

   Here is an example of a handler for `SIGCHLD' that compensates for
the fact that the number of signals received may not equal the number of
child processes that generate them.  It assumes that the program keeps
track of all the child processes with a chain of structures as follows:

     struct process
     {
       struct process *next;
       /* The process ID of this child.  */
       int pid;
       /* The descriptor of the pipe or pseudo terminal
          on which output comes from this child.  */
       int input_descriptor;
       /* Nonzero if this process has stopped or terminated.  */
       sig_atomic_t have_status;
       /* The status of this child; 0 if running,
          otherwise a status value from `waitpid'.  */
       int status;
     };

     struct process *process_list;

   This example also uses a flag to indicate whether signals have
arrived since some time in the past--whenever the program last cleared
it to zero.

     /* Nonzero means some child's status has changed
        so look at `process_list' for the details.  */
     int process_status_change;

   Here is the handler itself:

     void
     sigchld_handler (int signo)
     {
       int old_errno = errno;

       while (1) {
         register int pid;
         int w;
         struct process *p;

         /* Keep asking for a status until we get a definitive result.  */
         do
           {
             errno = 0;
             pid = waitpid (WAIT_ANY, &w, WNOHANG | WUNTRACED);
           }
         while (pid <= 0 && errno == EINTR);

         if (pid <= 0) {
           /* A real failure means there are no more
              stopped or terminated child processes, so return.  */
           errno = old_errno;
           return;
         }

         /* Find the process that signaled us, and record its status.  */

         for (p = process_list; p; p = p->next)
           if (p->pid == pid) {
             p->status = w;
             /* Indicate that the `status' field
                has data to look at.  We do this only after storing it.  */
             p->have_status = 1;

             /* If process has terminated, stop waiting for its output.  */
             if (WIFSIGNALED (w) || WIFEXITED (w))
               if (p->input_descriptor)
                 FD_CLR (p->input_descriptor, &input_wait_mask);

             /* The program should check this flag from time to time
                to see if there is any news in `process_list'.  */
             ++process_status_change;
           }

         /* Loop around to handle all the processes
            that have something to tell us.  */
       }
     }

   Here is the proper way to check the flag `process_status_change':

     if (process_status_change) {
       struct process *p;
       process_status_change = 0;
       for (p = process_list; p; p = p->next)
         if (p->have_status) {
           ... Examine `p->status' ...
         }
     }

It is vital to clear the flag before examining the list; otherwise, if a
signal were delivered just before the clearing of the flag, and after
the appropriate element of the process list had been checked, the status
change would go unnoticed until the next signal arrived to set the flag
again.  You could, of course, avoid this problem by blocking the signal
while scanning the list, but it is much more elegant to guarantee
correctness by doing things in the right order.

   The loop which checks process status avoids examining `p->status'
until it sees that status has been validly stored.  This is to make sure
that the status cannot change in the middle of accessing it.  Once
`p->have_status' is set, it means that the child process is stopped or
terminated, and in either case, it cannot stop or terminate again until
the program has taken notice.  *Note Atomic Usage::, for more
information about coping with interruptions during accesses of a
variable.

   Here is another way you can test whether the handler has run since
the last time you checked.  This technique uses a counter which is never
changed outside the handler.  Instead of clearing the count, the program
remembers the previous value and sees whether it has changed since the
previous check.  The advantage of this method is that different parts of
the program can check independently, each part checking whether there
has been a signal since that part last checked.

     sig_atomic_t process_status_change;

     sig_atomic_t last_process_status_change;

     ...
     {
       sig_atomic_t prev = last_process_status_change;
       last_process_status_change = process_status_change;
       if (last_process_status_change != prev) {
         struct process *p;
         for (p = process_list; p; p = p->next)
           if (p->have_status) {
             ... Examine `p->status' ...
           }
       }
     }


File: libc.info,  Node: Nonreentrancy,  Next: Atomic Data Access,  Prev: Merged Signals,  Up: Defining Handlers

24.4.6 Signal Handling and Nonreentrant Functions
-------------------------------------------------

Handler functions usually don't do very much.  The best practice is to
write a handler that does nothing but set an external variable that the
program checks regularly, and leave all serious work to the program.
This is best because the handler can be called asynchronously, at
unpredictable times--perhaps in the middle of a primitive function, or
even between the beginning and the end of a C operator that requires
multiple instructions.  The data structures being manipulated might
therefore be in an inconsistent state when the handler function is
invoked.  Even copying one `int' variable into another can take two
instructions on most machines.

   This means you have to be very careful about what you do in a signal
handler.

   * If your handler needs to access any global variables from your
     program, declare those variables `volatile'.  This tells the
     compiler that the value of the variable might change
     asynchronously, and inhibits certain optimizations that would be
     invalidated by such modifications.

   * If you call a function in the handler, make sure it is "reentrant"
     with respect to signals, or else make sure that the signal cannot
     interrupt a call to a related function.

   A function can be non-reentrant if it uses memory that is not on the
stack.

   * If a function uses a static variable or a global variable, or a
     dynamically-allocated object that it finds for itself, then it is
     non-reentrant and any two calls to the function can interfere.

     For example, suppose that the signal handler uses `gethostbyname'.
     This function returns its value in a static object, reusing the
     same object each time.  If the signal happens to arrive during a
     call to `gethostbyname', or even after one (while the program is
     still using the value), it will clobber the value that the program
     asked for.

     However, if the program does not use `gethostbyname' or any other
     function that returns information in the same object, or if it
     always blocks signals around each use, then you are safe.

     There are a large number of library functions that return values
     in a fixed object, always reusing the same object in this fashion,
     and all of them cause the same problem.  Function descriptions in
     this manual always mention this behavior.

   * If a function uses and modifies an object that you supply, then it
     is potentially non-reentrant; two calls can interfere if they use
     the same object.

     This case arises when you do I/O using streams.  Suppose that the
     signal handler prints a message with `fprintf'.  Suppose that the
     program was in the middle of an `fprintf' call using the same
     stream when the signal was delivered.  Both the signal handler's
     message and the program's data could be corrupted, because both
     calls operate on the same data structure--the stream itself.

     However, if you know that the stream that the handler uses cannot
     possibly be used by the program at a time when signals can arrive,
     then you are safe.  It is no problem if the program uses some
     other stream.

   * On most systems, `malloc' and `free' are not reentrant, because
     they use a static data structure which records what memory blocks
     are free.  As a result, no library functions that allocate or free
     memory are reentrant.  This includes functions that allocate space
     to store a result.

     The best way to avoid the need to allocate memory in a handler is
     to allocate in advance space for signal handlers to use.

     The best way to avoid freeing memory in a handler is to flag or
     record the objects to be freed, and have the program check from
     time to time whether anything is waiting to be freed.  But this
     must be done with care, because placing an object on a chain is
     not atomic, and if it is interrupted by another signal handler
     that does the same thing, you could "lose" one of the objects.

   * Any function that modifies `errno' is non-reentrant, but you can
     correct for this: in the handler, save the original value of
     `errno' and restore it before returning normally.  This prevents
     errors that occur within the signal handler from being confused
     with errors from system calls at the point the program is
     interrupted to run the handler.

     This technique is generally applicable; if you want to call in a
     handler a function that modifies a particular object in memory,
     you can make this safe by saving and restoring that object.

   * Merely reading from a memory object is safe provided that you can
     deal with any of the values that might appear in the object at a
     time when the signal can be delivered.  Keep in mind that
     assignment to some data types requires more than one instruction,
     which means that the handler could run "in the middle of" an
     assignment to the variable if its type is not atomic.  *Note
     Atomic Data Access::.

   * Merely writing into a memory object is safe as long as a sudden
     change in the value, at any time when the handler might run, will
     not disturb anything.


File: libc.info,  Node: Atomic Data Access,  Prev: Nonreentrancy,  Up: Defining Handlers

24.4.7 Atomic Data Access and Signal Handling
---------------------------------------------

Whether the data in your application concerns atoms, or mere text, you
have to be careful about the fact that access to a single datum is not
necessarily "atomic".  This means that it can take more than one
instruction to read or write a single object.  In such cases, a signal
handler might be invoked in the middle of reading or writing the object.

   There are three ways you can cope with this problem.  You can use
data types that are always accessed atomically; you can carefully
arrange that nothing untoward happens if an access is interrupted, or
you can block all signals around any access that had better not be
interrupted (*note Blocking Signals::).

* Menu:

* Non-atomic Example::		A program illustrating interrupted access.
* Types: Atomic Types.		Data types that guarantee no interruption.
* Usage: Atomic Usage.		Proving that interruption is harmless.


File: libc.info,  Node: Non-atomic Example,  Next: Atomic Types,  Up: Atomic Data Access

24.4.7.1 Problems with Non-Atomic Access
........................................

Here is an example which shows what can happen if a signal handler runs
in the middle of modifying a variable.  (Interrupting the reading of a
variable can also lead to paradoxical results, but here we only show
writing.)

     #include <signal.h>
     #include <stdio.h>

     volatile struct two_words { int a, b; } memory;

     void
     handler(int signum)
     {
        printf ("%d,%d\n", memory.a, memory.b);
        alarm (1);
     }

     int
     main (void)
     {
        static struct two_words zeros = { 0, 0 }, ones = { 1, 1 };
        signal (SIGALRM, handler);
        memory = zeros;
        alarm (1);
        while (1)
          {
            memory = zeros;
            memory = ones;
          }
     }

   This program fills `memory' with zeros, ones, zeros, ones,
alternating forever; meanwhile, once per second, the alarm signal
handler prints the current contents.  (Calling `printf' in the handler
is safe in this program because it is certainly not being called outside
the handler when the signal happens.)

   Clearly, this program can print a pair of zeros or a pair of ones.
But that's not all it can do!  On most machines, it takes several
instructions to store a new value in `memory', and the value is stored
one word at a time.  If the signal is delivered in between these
instructions, the handler might find that `memory.a' is zero and
`memory.b' is one (or vice versa).

   On some machines it may be possible to store a new value in `memory'
with just one instruction that cannot be interrupted.  On these
machines, the handler will always print two zeros or two ones.


File: libc.info,  Node: Atomic Types,  Next: Atomic Usage,  Prev: Non-atomic Example,  Up: Atomic Data Access

24.4.7.2 Atomic Types
.....................

To avoid uncertainty about interrupting access to a variable, you can
use a particular data type for which access is always atomic:
`sig_atomic_t'.  Reading and writing this data type is guaranteed to
happen in a single instruction, so there's no way for a handler to run
"in the middle" of an access.

   The type `sig_atomic_t' is always an integer data type, but which
one it is, and how many bits it contains, may vary from machine to
machine.

 -- Data Type: sig_atomic_t
     This is an integer data type.  Objects of this type are always
     accessed atomically.

   In practice, you can assume that `int' is atomic.  You can also
assume that pointer types are atomic; that is very convenient.  Both of
these assumptions are true on all of the machines that the GNU C
library supports and on all POSIX systems we know of.


File: libc.info,  Node: Atomic Usage,  Prev: Atomic Types,  Up: Atomic Data Access

24.4.7.3 Atomic Usage Patterns
..............................

Certain patterns of access avoid any problem even if an access is
interrupted.  For example, a flag which is set by the handler, and
tested and cleared by the main program from time to time, is always safe
even if access actually requires two instructions.  To show that this is
so, we must consider each access that could be interrupted, and show
that there is no problem if it is interrupted.

   An interrupt in the middle of testing the flag is safe because
either it's recognized to be nonzero, in which case the precise value
doesn't matter, or it will be seen to be nonzero the next time it's
tested.

   An interrupt in the middle of clearing the flag is no problem because
either the value ends up zero, which is what happens if a signal comes
in just before the flag is cleared, or the value ends up nonzero, and
subsequent events occur as if the signal had come in just after the flag
was cleared.  As long as the code handles both of these cases properly,
it can also handle a signal in the middle of clearing the flag.  (This
is an example of the sort of reasoning you need to do to figure out
whether non-atomic usage is safe.)

   Sometimes you can insure uninterrupted access to one object by
protecting its use with another object, perhaps one whose type
guarantees atomicity.  *Note Merged Signals::, for an example.


File: libc.info,  Node: Interrupted Primitives,  Next: Generating Signals,  Prev: Defining Handlers,  Up: Signal Handling

24.5 Primitives Interrupted by Signals
======================================

A signal can arrive and be handled while an I/O primitive such as
`open' or `read' is waiting for an I/O device.  If the signal handler
returns, the system faces the question: what should happen next?

   POSIX specifies one approach: make the primitive fail right away.
The error code for this kind of failure is `EINTR'.  This is flexible,
but usually inconvenient.  Typically, POSIX applications that use signal
handlers must check for `EINTR' after each library function that can
return it, in order to try the call again.  Often programmers forget to
check, which is a common source of error.

   The GNU library provides a convenient way to retry a call after a
temporary failure, with the macro `TEMP_FAILURE_RETRY':

 -- Macro: TEMP_FAILURE_RETRY (EXPRESSION)
     This macro evaluates EXPRESSION once, and examines its value as
     type `long int'.  If the value equals `-1', that indicates a
     failure and `errno' should be set to show what kind of failure.
     If it fails and reports error code `EINTR', `TEMP_FAILURE_RETRY'
     evaluates it again, and over and over until the result is not a
     temporary failure.

     The value returned by `TEMP_FAILURE_RETRY' is whatever value
     EXPRESSION produced.

   BSD avoids `EINTR' entirely and provides a more convenient approach:
to restart the interrupted primitive, instead of making it fail.  If
you choose this approach, you need not be concerned with `EINTR'.

   You can choose either approach with the GNU library.  If you use
`sigaction' to establish a signal handler, you can specify how that
handler should behave.  If you specify the `SA_RESTART' flag, return
from that handler will resume a primitive; otherwise, return from that
handler will cause `EINTR'.  *Note Flags for Sigaction::.

   Another way to specify the choice is with the `siginterrupt'
function.  *Note BSD Handler::.

   When you don't specify with `sigaction' or `siginterrupt' what a
particular handler should do, it uses a default choice.  The default
choice in the GNU library depends on the feature test macros you have
defined.  If you define `_BSD_SOURCE' or `_GNU_SOURCE' before calling
`signal', the default is to resume primitives; otherwise, the default
is to make them fail with `EINTR'.  (The library contains alternate
versions of the `signal' function, and the feature test macros
determine which one you really call.)  *Note Feature Test Macros::.  

   The description of each primitive affected by this issue lists
`EINTR' among the error codes it can return.

   There is one situation where resumption never happens no matter which
choice you make: when a data-transfer function such as `read' or
`write' is interrupted by a signal after transferring part of the data.
In this case, the function returns the number of bytes already
transferred, indicating partial success.

   This might at first appear to cause unreliable behavior on
record-oriented devices (including datagram sockets; *note Datagrams::),
where splitting one `read' or `write' into two would read or write two
records.  Actually, there is no problem, because interruption after a
partial transfer cannot happen on such devices; they always transfer an
entire record in one burst, with no waiting once data transfer has
started.


File: libc.info,  Node: Generating Signals,  Next: Blocking Signals,  Prev: Interrupted Primitives,  Up: Signal Handling

24.6 Generating Signals
=======================

Besides signals that are generated as a result of a hardware trap or
interrupt, your program can explicitly send signals to itself or to
another process.

* Menu:

* Signaling Yourself::          A process can send a signal to itself.
* Signaling Another Process::   Send a signal to another process.
* Permission for kill::         Permission for using `kill'.
* Kill Example::                Using `kill' for Communication.


File: libc.info,  Node: Signaling Yourself,  Next: Signaling Another Process,  Up: Generating Signals

24.6.1 Signaling Yourself
-------------------------

A process can send itself a signal with the `raise' function.  This
function is declared in `signal.h'.  

 -- Function: int raise (int SIGNUM)
     The `raise' function sends the signal SIGNUM to the calling
     process.  It returns zero if successful and a nonzero value if it
     fails.  About the only reason for failure would be if the value of
     SIGNUM is invalid.

 -- Function: int gsignal (int SIGNUM)
     The `gsignal' function does the same thing as `raise'; it is
     provided only for compatibility with SVID.

   One convenient use for `raise' is to reproduce the default behavior
of a signal that you have trapped.  For instance, suppose a user of your
program types the SUSP character (usually `C-z'; *note Special
Characters::) to send it an interactive stop signal (`SIGTSTP'), and
you want to clean up some internal data buffers before stopping.  You
might set this up like this:

     #include <signal.h>

     /* When a stop signal arrives, set the action back to the default
        and then resend the signal after doing cleanup actions. */

     void
     tstp_handler (int sig)
     {
       signal (SIGTSTP, SIG_DFL);
       /* Do cleanup actions here. */
       ...
       raise (SIGTSTP);
     }

     /* When the process is continued again, restore the signal handler. */

     void
     cont_handler (int sig)
     {
       signal (SIGCONT, cont_handler);
       signal (SIGTSTP, tstp_handler);
     }

     /* Enable both handlers during program initialization. */

     int
     main (void)
     {
       signal (SIGCONT, cont_handler);
       signal (SIGTSTP, tstp_handler);
       ...
     }

   *Portability note:* `raise' was invented by the ISO C committee.
Older systems may not support it, so using `kill' may be more portable.
*Note Signaling Another Process::.


File: libc.info,  Node: Signaling Another Process,  Next: Permission for kill,  Prev: Signaling Yourself,  Up: Generating Signals

24.6.2 Signaling Another Process
--------------------------------

The `kill' function can be used to send a signal to another process.
In spite of its name, it can be used for a lot of things other than
causing a process to terminate.  Some examples of situations where you
might want to send signals between processes are:

   * A parent process starts a child to perform a task--perhaps having
     the child running an infinite loop--and then terminates the child
     when the task is no longer needed.

   * A process executes as part of a group, and needs to terminate or
     notify the other processes in the group when an error or other
     event occurs.

   * Two processes need to synchronize while working together.

   This section assumes that you know a little bit about how processes
work.  For more information on this subject, see *Note Processes::.

   The `kill' function is declared in `signal.h'.  

 -- Function: int kill (pid_t PID, int SIGNUM)
     The `kill' function sends the signal SIGNUM to the process or
     process group specified by PID.  Besides the signals listed in
     *Note Standard Signals::, SIGNUM can also have a value of zero to
     check the validity of the PID.

     The PID specifies the process or process group to receive the
     signal:

    `PID > 0'
          The process whose identifier is PID.

    `PID == 0'
          All processes in the same process group as the sender.

    `PID < -1'
          The process group whose identifier is -PID.

    `PID == -1'
          If the process is privileged, send the signal to all
          processes except for some special system processes.
          Otherwise, send the signal to all processes with the same
          effective user ID.

     A process can send a signal to itself with a call like
     `kill (getpid(), SIGNUM)'.  If `kill' is used by a process to send
     a signal to itself, and the signal is not blocked, then `kill'
     delivers at least one signal (which might be some other pending
     unblocked signal instead of the signal SIGNUM) to that process
     before it returns.

     The return value from `kill' is zero if the signal can be sent
     successfully.  Otherwise, no signal is sent, and a value of `-1' is
     returned.  If PID specifies sending a signal to several processes,
     `kill' succeeds if it can send the signal to at least one of them.
     There's no way you can tell which of the processes got the signal
     or whether all of them did.

     The following `errno' error conditions are defined for this
     function:

    `EINVAL'
          The SIGNUM argument is an invalid or unsupported number.

    `EPERM'
          You do not have the privilege to send a signal to the process
          or any of the processes in the process group named by PID.

    `ESRCH'
          The PID argument does not refer to an existing process or
          group.

 -- Function: int killpg (int PGID, int SIGNUM)
     This is similar to `kill', but sends signal SIGNUM to the process
     group PGID.  This function is provided for compatibility with BSD;
     using `kill' to do this is more portable.

   As a simple example of `kill', the call `kill (getpid (), SIG)' has
the same effect as `raise (SIG)'.


File: libc.info,  Node: Permission for kill,  Next: Kill Example,  Prev: Signaling Another Process,  Up: Generating Signals

24.6.3 Permission for using `kill'
----------------------------------

There are restrictions that prevent you from using `kill' to send
signals to any random process.  These are intended to prevent antisocial
behavior such as arbitrarily killing off processes belonging to another
user.  In typical use, `kill' is used to pass signals between parent,
child, and sibling processes, and in these situations you normally do
have permission to send signals.  The only common exception is when you
run a setuid program in a child process; if the program changes its
real UID as well as its effective UID, you may not have permission to
send a signal.  The `su' program does this.

   Whether a process has permission to send a signal to another process
is determined by the user IDs of the two processes.  This concept is
discussed in detail in *Note Process Persona::.

   Generally, for a process to be able to send a signal to another
process, either the sending process must belong to a privileged user
(like `root'), or the real or effective user ID of the sending process
must match the real or effective user ID of the receiving process.  If
the receiving process has changed its effective user ID from the
set-user-ID mode bit on its process image file, then the owner of the
process image file is used in place of its current effective user ID.
In some implementations, a parent process might be able to send signals
to a child process even if the user ID's don't match, and other
implementations might enforce other restrictions.

   The `SIGCONT' signal is a special case.  It can be sent if the
sender is part of the same session as the receiver, regardless of user
IDs.


File: libc.info,  Node: Kill Example,  Prev: Permission for kill,  Up: Generating Signals

24.6.4 Using `kill' for Communication
-------------------------------------

Here is a longer example showing how signals can be used for
interprocess communication.  This is what the `SIGUSR1' and `SIGUSR2'
signals are provided for.  Since these signals are fatal by default,
the process that is supposed to receive them must trap them through
`signal' or `sigaction'.

   In this example, a parent process forks a child process and then
waits for the child to complete its initialization.  The child process
tells the parent when it is ready by sending it a `SIGUSR1' signal,
using the `kill' function.

     #include <signal.h>
     #include <stdio.h>
     #include <sys/types.h>
     #include <unistd.h>

     /* When a `SIGUSR1' signal arrives, set this variable. */
     volatile sig_atomic_t usr_interrupt = 0;

     void
     synch_signal (int sig)
     {
       usr_interrupt = 1;
     }

     /* The child process executes this function. */
     void
     child_function (void)
     {
       /* Perform initialization. */
       printf ("I'm here!!!  My pid is %d.\n", (int) getpid ());

       /* Let parent know you're done. */
       kill (getppid (), SIGUSR1);

       /* Continue with execution. */
       puts ("Bye, now....");
       exit (0);
     }

     int
     main (void)
     {
       struct sigaction usr_action;
       sigset_t block_mask;
       pid_t child_id;

       /* Establish the signal handler. */
       sigfillset (&block_mask);
       usr_action.sa_handler = synch_signal;
       usr_action.sa_mask = block_mask;
       usr_action.sa_flags = 0;
       sigaction (SIGUSR1, &usr_action, NULL);

       /* Create the child process. */
       child_id = fork ();
       if (child_id == 0)
         child_function ();          /* Does not return. */

       /* Busy wait for the child to send a signal. */
       while (!usr_interrupt)
         ;

       /* Now continue execution. */
       puts ("That's all, folks!");

       return 0;
     }

   This example uses a busy wait, which is bad, because it wastes CPU
cycles that other programs could otherwise use.  It is better to ask the
system to wait until the signal arrives.  See the example in *Note
Waiting for a Signal::.


File: libc.info,  Node: Blocking Signals,  Next: Waiting for a Signal,  Prev: Generating Signals,  Up: Signal Handling

24.7 Blocking Signals
=====================

Blocking a signal means telling the operating system to hold it and
deliver it later.  Generally, a program does not block signals
indefinitely--it might as well ignore them by setting their actions to
`SIG_IGN'.  But it is useful to block signals briefly, to prevent them
from interrupting sensitive operations.  For instance:

   * You can use the `sigprocmask' function to block signals while you
     modify global variables that are also modified by the handlers for
     these signals.

   * You can set `sa_mask' in your `sigaction' call to block certain
     signals while a particular signal handler runs.  This way, the
     signal handler can run without being interrupted itself by signals.

* Menu:

* Why Block::                           The purpose of blocking signals.
* Signal Sets::                         How to specify which signals to
                                         block.
* Process Signal Mask::                 Blocking delivery of signals to your
				         process during normal execution.
* Testing for Delivery::                Blocking to Test for Delivery of
                                         a Signal.
* Blocking for Handler::                Blocking additional signals while a
				         handler is being run.
* Checking for Pending Signals::        Checking for Pending Signals
* Remembering a Signal::                How you can get almost the same
                                         effect as blocking a signal, by
                                         handling it and setting a flag
                                         to be tested later.


File: libc.info,  Node: Why Block,  Next: Signal Sets,  Up: Blocking Signals

24.7.1 Why Blocking Signals is Useful
-------------------------------------

Temporary blocking of signals with `sigprocmask' gives you a way to
prevent interrupts during critical parts of your code.  If signals
arrive in that part of the program, they are delivered later, after you
unblock them.

   One example where this is useful is for sharing data between a signal
handler and the rest of the program.  If the type of the data is not
`sig_atomic_t' (*note Atomic Data Access::), then the signal handler
could run when the rest of the program has only half finished reading
or writing the data.  This would lead to confusing consequences.

   To make the program reliable, you can prevent the signal handler from
running while the rest of the program is examining or modifying that
data--by blocking the appropriate signal around the parts of the
program that touch the data.

   Blocking signals is also necessary when you want to perform a certain
action only if a signal has not arrived.  Suppose that the handler for
the signal sets a flag of type `sig_atomic_t'; you would like to test
the flag and perform the action if the flag is not set.  This is
unreliable.  Suppose the signal is delivered immediately after you test
the flag, but before the consequent action: then the program will
perform the action even though the signal has arrived.

   The only way to test reliably for whether a signal has yet arrived
is to test while the signal is blocked.


File: libc.info,  Node: Signal Sets,  Next: Process Signal Mask,  Prev: Why Block,  Up: Blocking Signals

24.7.2 Signal Sets
------------------

All of the signal blocking functions use a data structure called a
"signal set" to specify what signals are affected.  Thus, every
activity involves two stages: creating the signal set, and then passing
it as an argument to a library function.  

   These facilities are declared in the header file `signal.h'.  

 -- Data Type: sigset_t
     The `sigset_t' data type is used to represent a signal set.
     Internally, it may be implemented as either an integer or structure
     type.

     For portability, use only the functions described in this section
     to initialize, change, and retrieve information from `sigset_t'
     objects--don't try to manipulate them directly.

   There are two ways to initialize a signal set.  You can initially
specify it to be empty with `sigemptyset' and then add specified
signals individually.  Or you can specify it to be full with
`sigfillset' and then delete specified signals individually.

   You must always initialize the signal set with one of these two
functions before using it in any other way.  Don't try to set all the
signals explicitly because the `sigset_t' object might include some
other information (like a version field) that needs to be initialized as
well.  (In addition, it's not wise to put into your program an
assumption that the system has no signals aside from the ones you know
about.)

 -- Function: int sigemptyset (sigset_t *SET)
     This function initializes the signal set SET to exclude all of the
     defined signals.  It always returns `0'.

 -- Function: int sigfillset (sigset_t *SET)
     This function initializes the signal set SET to include all of the
     defined signals.  Again, the return value is `0'.

 -- Function: int sigaddset (sigset_t *SET, int SIGNUM)
     This function adds the signal SIGNUM to the signal set SET.  All
     `sigaddset' does is modify SET; it does not block or unblock any
     signals.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error condition is defined for this function:

    `EINVAL'
          The SIGNUM argument doesn't specify a valid signal.

 -- Function: int sigdelset (sigset_t *SET, int SIGNUM)
     This function removes the signal SIGNUM from the signal set SET.
     All `sigdelset' does is modify SET; it does not block or unblock
     any signals.  The return value and error conditions are the same
     as for `sigaddset'.

   Finally, there is a function to test what signals are in a signal
set:

 -- Function: int sigismember (const sigset_t *SET, int SIGNUM)
     The `sigismember' function tests whether the signal SIGNUM is a
     member of the signal set SET.  It returns `1' if the signal is in
     the set, `0' if not, and `-1' if there is an error.

     The following `errno' error condition is defined for this function:

    `EINVAL'
          The SIGNUM argument doesn't specify a valid signal.


File: libc.info,  Node: Process Signal Mask,  Next: Testing for Delivery,  Prev: Signal Sets,  Up: Blocking Signals

24.7.3 Process Signal Mask
--------------------------

The collection of signals that are currently blocked is called the
"signal mask".  Each process has its own signal mask.  When you create
a new process (*note Creating a Process::), it inherits its parent's
mask.  You can block or unblock signals with total flexibility by
modifying the signal mask.

   The prototype for the `sigprocmask' function is in `signal.h'.  

   Note that you must not use `sigprocmask' in multi-threaded processes,
because each thread has its own signal mask and there is no single
process signal mask. According to POSIX, the behavior of `sigprocmask'
in a multi-threaded process is "unspecified".  Instead, use
`pthread_sigmask'.

 -- Function: int sigprocmask (int HOW, const sigset_t *restrict SET,
          sigset_t *restrict OLDSET)
     The `sigprocmask' function is used to examine or change the calling
     process's signal mask.  The HOW argument determines how the signal
     mask is changed, and must be one of the following values:

    `SIG_BLOCK'
          Block the signals in `set'--add them to the existing mask.  In
          other words, the new mask is the union of the existing mask
          and SET.

    `SIG_UNBLOCK'
          Unblock the signals in SET--remove them from the existing
          mask.

    `SIG_SETMASK'
          Use SET for the mask; ignore the previous value of the mask.

     The last argument, OLDSET, is used to return information about the
     old process signal mask.  If you just want to change the mask
     without looking at it, pass a null pointer as the OLDSET argument.
     Similarly, if you want to know what's in the mask without changing
     it, pass a null pointer for SET (in this case the HOW argument is
     not significant).  The OLDSET argument is often used to remember
     the previous signal mask in order to restore it later.  (Since the
     signal mask is inherited over `fork' and `exec' calls, you can't
     predict what its contents are when your program starts running.)

     If invoking `sigprocmask' causes any pending signals to be
     unblocked, at least one of those signals is delivered to the
     process before `sigprocmask' returns.  The order in which pending
     signals are delivered is not specified, but you can control the
     order explicitly by making multiple `sigprocmask' calls to unblock
     various signals one at a time.

     The `sigprocmask' function returns `0' if successful, and `-1' to
     indicate an error.  The following `errno' error conditions are
     defined for this function:

    `EINVAL'
          The HOW argument is invalid.

     You can't block the `SIGKILL' and `SIGSTOP' signals, but if the
     signal set includes these, `sigprocmask' just ignores them instead
     of returning an error status.

     Remember, too, that blocking program error signals such as `SIGFPE'
     leads to undesirable results for signals generated by an actual
     program error (as opposed to signals sent with `raise' or `kill').
     This is because your program may be too broken to be able to
     continue executing to a point where the signal is unblocked again.
     *Note Program Error Signals::.


File: libc.info,  Node: Testing for Delivery,  Next: Blocking for Handler,  Prev: Process Signal Mask,  Up: Blocking Signals

24.7.4 Blocking to Test for Delivery of a Signal
------------------------------------------------

Now for a simple example.  Suppose you establish a handler for
`SIGALRM' signals that sets a flag whenever a signal arrives, and your
main program checks this flag from time to time and then resets it.
You can prevent additional `SIGALRM' signals from arriving in the
meantime by wrapping the critical part of the code with calls to
`sigprocmask', like this:

     /* This variable is set by the SIGALRM signal handler. */
     volatile sig_atomic_t flag = 0;

     int
     main (void)
     {
       sigset_t block_alarm;

       ...

       /* Initialize the signal mask. */
       sigemptyset (&block_alarm);
       sigaddset (&block_alarm, SIGALRM);

       while (1)
         {
           /* Check if a signal has arrived; if so, reset the flag. */
           sigprocmask (SIG_BLOCK, &block_alarm, NULL);
           if (flag)
             {
               ACTIONS-IF-NOT-ARRIVED
               flag = 0;
             }
           sigprocmask (SIG_UNBLOCK, &block_alarm, NULL);

           ...
         }
     }


File: libc.info,  Node: Blocking for Handler,  Next: Checking for Pending Signals,  Prev: Testing for Delivery,  Up: Blocking Signals

24.7.5 Blocking Signals for a Handler
-------------------------------------

When a signal handler is invoked, you usually want it to be able to
finish without being interrupted by another signal.  From the moment the
handler starts until the moment it finishes, you must block signals that
might confuse it or corrupt its data.

   When a handler function is invoked on a signal, that signal is
automatically blocked (in addition to any other signals that are already
in the process's signal mask) during the time the handler is running.
If you set up a handler for `SIGTSTP', for instance, then the arrival
of that signal forces further `SIGTSTP' signals to wait during the
execution of the handler.

   However, by default, other kinds of signals are not blocked; they can
arrive during handler execution.

   The reliable way to block other kinds of signals during the
execution of the handler is to use the `sa_mask' member of the
`sigaction' structure.

   Here is an example:

     #include <signal.h>
     #include <stddef.h>

     void catch_stop ();

     void
     install_handler (void)
     {
       struct sigaction setup_action;
       sigset_t block_mask;

       sigemptyset (&block_mask);
       /* Block other terminal-generated signals while handler runs. */
       sigaddset (&block_mask, SIGINT);
       sigaddset (&block_mask, SIGQUIT);
       setup_action.sa_handler = catch_stop;
       setup_action.sa_mask = block_mask;
       setup_action.sa_flags = 0;
       sigaction (SIGTSTP, &setup_action, NULL);
     }

   This is more reliable than blocking the other signals explicitly in
the code for the handler.  If you block signals explicitly in the
handler, you can't avoid at least a short interval at the beginning of
the handler where they are not yet blocked.

   You cannot remove signals from the process's current mask using this
mechanism.  However, you can make calls to `sigprocmask' within your
handler to block or unblock signals as you wish.

   In any case, when the handler returns, the system restores the mask
that was in place before the handler was entered.  If any signals that
become unblocked by this restoration are pending, the process will
receive those signals immediately, before returning to the code that was
interrupted.


File: libc.info,  Node: Checking for Pending Signals,  Next: Remembering a Signal,  Prev: Blocking for Handler,  Up: Blocking Signals

24.7.6 Checking for Pending Signals
-----------------------------------

You can find out which signals are pending at any time by calling
`sigpending'.  This function is declared in `signal.h'.  

 -- Function: int sigpending (sigset_t *SET)
     The `sigpending' function stores information about pending signals
     in SET.  If there is a pending signal that is blocked from
     delivery, then that signal is a member of the returned set.  (You
     can test whether a particular signal is a member of this set using
     `sigismember'; see *Note Signal Sets::.)

     The return value is `0' if successful, and `-1' on failure.

   Testing whether a signal is pending is not often useful.  Testing
when that signal is not blocked is almost certainly bad design.

   Here is an example.

     #include <signal.h>
     #include <stddef.h>

     sigset_t base_mask, waiting_mask;

     sigemptyset (&base_mask);
     sigaddset (&base_mask, SIGINT);
     sigaddset (&base_mask, SIGTSTP);

     /* Block user interrupts while doing other processing. */
     sigprocmask (SIG_SETMASK, &base_mask, NULL);
     ...

     /* After a while, check to see whether any signals are pending. */
     sigpending (&waiting_mask);
     if (sigismember (&waiting_mask, SIGINT)) {
       /* User has tried to kill the process. */
     }
     else if (sigismember (&waiting_mask, SIGTSTP)) {
       /* User has tried to stop the process. */
     }

   Remember that if there is a particular signal pending for your
process, additional signals of that same type that arrive in the
meantime might be discarded.  For example, if a `SIGINT' signal is
pending when another `SIGINT' signal arrives, your program will
probably only see one of them when you unblock this signal.

   *Portability Note:* The `sigpending' function is new in POSIX.1.
Older systems have no equivalent facility.


File: libc.info,  Node: Remembering a Signal,  Prev: Checking for Pending Signals,  Up: Blocking Signals

24.7.7 Remembering a Signal to Act On Later
-------------------------------------------

Instead of blocking a signal using the library facilities, you can get
almost the same results by making the handler set a flag to be tested
later, when you "unblock".  Here is an example:

     /* If this flag is nonzero, don't handle the signal right away. */
     volatile sig_atomic_t signal_pending;

     /* This is nonzero if a signal arrived and was not handled. */
     volatile sig_atomic_t defer_signal;

     void
     handler (int signum)
     {
       if (defer_signal)
         signal_pending = signum;
       else
         ... /* "Really" handle the signal. */
     }

     ...

     void
     update_mumble (int frob)
     {
       /* Prevent signals from having immediate effect. */
       defer_signal++;
       /* Now update `mumble', without worrying about interruption. */
       mumble.a = 1;
       mumble.b = hack ();
       mumble.c = frob;
       /* We have updated `mumble'.  Handle any signal that came in. */
       defer_signal--;
       if (defer_signal == 0 && signal_pending != 0)
         raise (signal_pending);
     }

   Note how the particular signal that arrives is stored in
`signal_pending'.  That way, we can handle several types of
inconvenient signals with the same mechanism.

   We increment and decrement `defer_signal' so that nested critical
sections will work properly; thus, if `update_mumble' were called with
`signal_pending' already nonzero, signals would be deferred not only
within `update_mumble', but also within the caller.  This is also why
we do not check `signal_pending' if `defer_signal' is still nonzero.

   The incrementing and decrementing of `defer_signal' each require more
than one instruction; it is possible for a signal to happen in the
middle.  But that does not cause any problem.  If the signal happens
early enough to see the value from before the increment or decrement,
that is equivalent to a signal which came before the beginning of the
increment or decrement, which is a case that works properly.

   It is absolutely vital to decrement `defer_signal' before testing
`signal_pending', because this avoids a subtle bug.  If we did these
things in the other order, like this,

       if (defer_signal == 1 && signal_pending != 0)
         raise (signal_pending);
       defer_signal--;

then a signal arriving in between the `if' statement and the decrement
would be effectively "lost" for an indefinite amount of time.  The
handler would merely set `defer_signal', but the program having already
tested this variable, it would not test the variable again.

   Bugs like these are called "timing errors".  They are especially bad
because they happen only rarely and are nearly impossible to reproduce.
You can't expect to find them with a debugger as you would find a
reproducible bug.  So it is worth being especially careful to avoid
them.

   (You would not be tempted to write the code in this order, given the
use of `defer_signal' as a counter which must be tested along with
`signal_pending'.  After all, testing for zero is cleaner than testing
for one.  But if you did not use `defer_signal' as a counter, and gave
it values of zero and one only, then either order might seem equally
simple.  This is a further advantage of using a counter for
`defer_signal': it will reduce the chance you will write the code in
the wrong order and create a subtle bug.)


File: libc.info,  Node: Waiting for a Signal,  Next: Signal Stack,  Prev: Blocking Signals,  Up: Signal Handling

24.8 Waiting for a Signal
=========================

If your program is driven by external events, or uses signals for
synchronization, then when it has nothing to do it should probably wait
until a signal arrives.

* Menu:

* Using Pause::                 The simple way, using `pause'.
* Pause Problems::              Why the simple way is often not very good.
* Sigsuspend::                  Reliably waiting for a specific signal.


File: libc.info,  Node: Using Pause,  Next: Pause Problems,  Up: Waiting for a Signal

24.8.1 Using `pause'
--------------------

The simple way to wait until a signal arrives is to call `pause'.
Please read about its disadvantages, in the following section, before
you use it.

 -- Function: int pause ()
     The `pause' function suspends program execution until a signal
     arrives whose action is either to execute a handler function, or to
     terminate the process.

     If the signal causes a handler function to be executed, then
     `pause' returns.  This is considered an unsuccessful return (since
     "successful" behavior would be to suspend the program forever), so
     the return value is `-1'.  Even if you specify that other
     primitives should resume when a system handler returns (*note
     Interrupted Primitives::), this has no effect on `pause'; it
     always fails when a signal is handled.

     The following `errno' error conditions are defined for this
     function:

    `EINTR'
          The function was interrupted by delivery of a signal.

     If the signal causes program termination, `pause' doesn't return
     (obviously).

     This function is a cancellation point in multithreaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `pause' is called.  If the thread gets cancelled these resources
     stay allocated until the program ends.  To avoid this calls to
     `pause' should be protected using cancellation handlers.

     The `pause' function is declared in  `unistd.h'.


File: libc.info,  Node: Pause Problems,  Next: Sigsuspend,  Prev: Using Pause,  Up: Waiting for a Signal

24.8.2 Problems with `pause'
----------------------------

The simplicity of `pause' can conceal serious timing errors that can
make a program hang mysteriously.

   It is safe to use `pause' if the real work of your program is done
by the signal handlers themselves, and the "main program" does nothing
but call `pause'.  Each time a signal is delivered, the handler will do
the next batch of work that is to be done, and then return, so that the
main loop of the program can call `pause' again.

   You can't safely use `pause' to wait until one more signal arrives,
and then resume real work.  Even if you arrange for the signal handler
to cooperate by setting a flag, you still can't use `pause' reliably.
Here is an example of this problem:

     /* `usr_interrupt' is set by the signal handler.  */
     if (!usr_interrupt)
       pause ();

     /* Do work once the signal arrives.  */
     ...

This has a bug: the signal could arrive after the variable
`usr_interrupt' is checked, but before the call to `pause'.  If no
further signals arrive, the process would never wake up again.

   You can put an upper limit on the excess waiting by using `sleep' in
a loop, instead of using `pause'.  (*Note Sleeping::, for more about
`sleep'.)  Here is what this looks like:

     /* `usr_interrupt' is set by the signal handler.
     while (!usr_interrupt)
       sleep (1);

     /* Do work once the signal arrives.  */
     ...

   For some purposes, that is good enough.  But with a little more
complexity, you can wait reliably until a particular signal handler is
run, using `sigsuspend'.  *Note Sigsuspend::.


File: libc.info,  Node: Sigsuspend,  Prev: Pause Problems,  Up: Waiting for a Signal

24.8.3 Using `sigsuspend'
-------------------------

The clean and reliable way to wait for a signal to arrive is to block it
and then use `sigsuspend'.  By using `sigsuspend' in a loop, you can
wait for certain kinds of signals, while letting other kinds of signals
be handled by their handlers.

 -- Function: int sigsuspend (const sigset_t *SET)
     This function replaces the process's signal mask with SET and then
     suspends the process until a signal is delivered whose action is
     either to terminate the process or invoke a signal handling
     function.  In other words, the program is effectively suspended
     until one of the signals that is not a member of SET arrives.

     If the process is woken up by delivery of a signal that invokes a
     handler function, and the handler function returns, then
     `sigsuspend' also returns.

     The mask remains SET only as long as `sigsuspend' is waiting.  The
     function `sigsuspend' always restores the previous signal mask
     when it returns.

     The return value and error conditions are the same as for `pause'.

   With `sigsuspend', you can replace the `pause' or `sleep' loop in
the previous section with something completely reliable:

     sigset_t mask, oldmask;

     ...

     /* Set up the mask of signals to temporarily block. */
     sigemptyset (&mask);
     sigaddset (&mask, SIGUSR1);

     ...

     /* Wait for a signal to arrive. */
     sigprocmask (SIG_BLOCK, &mask, &oldmask);
     while (!usr_interrupt)
       sigsuspend (&oldmask);
     sigprocmask (SIG_UNBLOCK, &mask, NULL);

   This last piece of code is a little tricky.  The key point to
remember here is that when `sigsuspend' returns, it resets the process's
signal mask to the original value, the value from before the call to
`sigsuspend'--in this case, the `SIGUSR1' signal is once again blocked.
The second call to `sigprocmask' is necessary to explicitly unblock
this signal.

   One other point: you may be wondering why the `while' loop is
necessary at all, since the program is apparently only waiting for one
`SIGUSR1' signal.  The answer is that the mask passed to `sigsuspend'
permits the process to be woken up by the delivery of other kinds of
signals, as well--for example, job control signals.  If the process is
woken up by a signal that doesn't set `usr_interrupt', it just suspends
itself again until the "right" kind of signal eventually arrives.

   This technique takes a few more lines of preparation, but that is
needed just once for each kind of wait criterion you want to use.  The
code that actually waits is just four lines.


File: libc.info,  Node: Signal Stack,  Next: BSD Signal Handling,  Prev: Waiting for a Signal,  Up: Signal Handling

24.9 Using a Separate Signal Stack
==================================

A signal stack is a special area of memory to be used as the execution
stack during signal handlers.  It should be fairly large, to avoid any
danger that it will overflow in turn; the macro `SIGSTKSZ' is defined
to a canonical size for signal stacks.  You can use `malloc' to
allocate the space for the stack.  Then call `sigaltstack' or
`sigstack' to tell the system to use that space for the signal stack.

   You don't need to write signal handlers differently in order to use a
signal stack.  Switching from one stack to the other happens
automatically.  (Some non-GNU debuggers on some machines may get
confused if you examine a stack trace while a handler that uses the
signal stack is running.)

   There are two interfaces for telling the system to use a separate
signal stack.  `sigstack' is the older interface, which comes from 4.2
BSD.  `sigaltstack' is the newer interface, and comes from 4.4 BSD.
The `sigaltstack' interface has the advantage that it does not require
your program to know which direction the stack grows, which depends on
the specific machine and operating system.

 -- Data Type: stack_t
     This structure describes a signal stack.  It contains the
     following members:

    `void *ss_sp'
          This points to the base of the signal stack.

    `size_t ss_size'
          This is the size (in bytes) of the signal stack which `ss_sp'
          points to.  You should set this to however much space you
          allocated for the stack.

          There are two macros defined in `signal.h' that you should
          use in calculating this size:

         `SIGSTKSZ'
               This is the canonical size for a signal stack.  It is
               judged to be sufficient for normal uses.

         `MINSIGSTKSZ'
               This is the amount of signal stack space the operating
               system needs just to implement signal delivery.  The
               size of a signal stack *must* be greater than this.

               For most cases, just using `SIGSTKSZ' for `ss_size' is
               sufficient.  But if you know how much stack space your
               program's signal handlers will need, you may want to use
               a different size.  In this case, you should allocate
               `MINSIGSTKSZ' additional bytes for the signal stack and
               increase `ss_size' accordingly.

    `int ss_flags'
          This field contains the bitwise OR of these flags:

         `SS_DISABLE'
               This tells the system that it should not use the signal
               stack.

         `SS_ONSTACK'
               This is set by the system, and indicates that the signal
               stack is currently in use.  If this bit is not set, then
               signals will be delivered on the normal user stack.

 -- Function: int sigaltstack (const stack_t *restrict STACK, stack_t
          *restrict OLDSTACK)
     The `sigaltstack' function specifies an alternate stack for use
     during signal handling.  When a signal is received by the process
     and its action indicates that the signal stack is used, the system
     arranges a switch to the currently installed signal stack while
     the handler for that signal is executed.

     If OLDSTACK is not a null pointer, information about the currently
     installed signal stack is returned in the location it points to.
     If STACK is not a null pointer, then this is installed as the new
     stack for use by signal handlers.

     The return value is `0' on success and `-1' on failure.  If
     `sigaltstack' fails, it sets `errno' to one of these values:

    `EINVAL'
          You tried to disable a stack that was in fact currently in
          use.

    `ENOMEM'
          The size of the alternate stack was too small.  It must be
          greater than `MINSIGSTKSZ'.

   Here is the older `sigstack' interface.  You should use
`sigaltstack' instead on systems that have it.

 -- Data Type: struct sigstack
     This structure describes a signal stack.  It contains the
     following members:

    `void *ss_sp'
          This is the stack pointer.  If the stack grows downwards on
          your machine, this should point to the top of the area you
          allocated.  If the stack grows upwards, it should point to
          the bottom.

    `int ss_onstack'
          This field is true if the process is currently using this
          stack.

 -- Function: int sigstack (const struct sigstack *STACK, struct
          sigstack *OLDSTACK)
     The `sigstack' function specifies an alternate stack for use during
     signal handling.  When a signal is received by the process and its
     action indicates that the signal stack is used, the system
     arranges a switch to the currently installed signal stack while
     the handler for that signal is executed.

     If OLDSTACK is not a null pointer, information about the currently
     installed signal stack is returned in the location it points to.
     If STACK is not a null pointer, then this is installed as the new
     stack for use by signal handlers.

     The return value is `0' on success and `-1' on failure.


File: libc.info,  Node: BSD Signal Handling,  Prev: Signal Stack,  Up: Signal Handling

24.10 BSD Signal Handling
=========================

This section describes alternative signal handling functions derived
from BSD Unix.  These facilities were an advance, in their time; today,
they are mostly obsolete, and supported mainly for compatibility with
BSD Unix.

   There are many similarities between the BSD and POSIX signal handling
facilities, because the POSIX facilities were inspired by the BSD
facilities.  Besides having different names for all the functions to
avoid conflicts, the main differences between the two are:

   * BSD Unix represents signal masks as an `int' bit mask, rather than
     as a `sigset_t' object.

   * The BSD facilities use a different default for whether an
     interrupted primitive should fail or resume.  The POSIX facilities
     make system calls fail unless you specify that they should resume.
     With the BSD facility, the default is to make system calls resume
     unless you say they should fail.  *Note Interrupted Primitives::.

   The BSD facilities are declared in `signal.h'.  

* Menu:

* BSD Handler::                 BSD Function to Establish a Handler.
* Blocking in BSD::             BSD Functions for Blocking Signals.


File: libc.info,  Node: BSD Handler,  Next: Blocking in BSD,  Up: BSD Signal Handling

24.10.1 BSD Function to Establish a Handler
-------------------------------------------

 -- Data Type: struct sigvec
     This data type is the BSD equivalent of `struct sigaction' (*note
     Advanced Signal Handling::); it is used to specify signal actions
     to the `sigvec' function.  It contains the following members:

    `sighandler_t sv_handler'
          This is the handler function.

    `int sv_mask'
          This is the mask of additional signals to be blocked while
          the handler function is being called.

    `int sv_flags'
          This is a bit mask used to specify various flags which affect
          the behavior of the signal.  You can also refer to this field
          as `sv_onstack'.

These symbolic constants can be used to provide values for the
`sv_flags' field of a `sigvec' structure.  This field is a bit mask
value, so you bitwise-OR the flags of interest to you together.

 -- Macro: int SV_ONSTACK
     If this bit is set in the `sv_flags' field of a `sigvec'
     structure, it means to use the signal stack when delivering the
     signal.

 -- Macro: int SV_INTERRUPT
     If this bit is set in the `sv_flags' field of a `sigvec'
     structure, it means that system calls interrupted by this kind of
     signal should not be restarted if the handler returns; instead,
     the system calls should return with a `EINTR' error status.  *Note
     Interrupted Primitives::.

 -- Macro: int SV_RESETHAND
     If this bit is set in the `sv_flags' field of a `sigvec'
     structure, it means to reset the action for the signal back to
     `SIG_DFL' when the signal is received.

 -- Function: int sigvec (int SIGNUM, const struct sigvec
          *ACTION,struct sigvec *OLD-ACTION)
     This function is the equivalent of `sigaction' (*note Advanced
     Signal Handling::); it installs the action ACTION for the signal
     SIGNUM, returning information about the previous action in effect
     for that signal in OLD-ACTION.

 -- Function: int siginterrupt (int SIGNUM, int FAILFLAG)
     This function specifies which approach to use when certain
     primitives are interrupted by handling signal SIGNUM.  If FAILFLAG
     is false, signal SIGNUM restarts primitives.  If FAILFLAG is true,
     handling SIGNUM causes these primitives to fail with error code
     `EINTR'.  *Note Interrupted Primitives::.


File: libc.info,  Node: Blocking in BSD,  Prev: BSD Handler,  Up: BSD Signal Handling

24.10.2 BSD Functions for Blocking Signals
------------------------------------------

 -- Macro: int sigmask (int SIGNUM)
     This macro returns a signal mask that has the bit for signal SIGNUM
     set.  You can bitwise-OR the results of several calls to `sigmask'
     together to specify more than one signal.  For example,

          (sigmask (SIGTSTP) | sigmask (SIGSTOP)
           | sigmask (SIGTTIN) | sigmask (SIGTTOU))

     specifies a mask that includes all the job-control stop signals.

 -- Function: int sigblock (int MASK)
     This function is equivalent to `sigprocmask' (*note Process Signal
     Mask::) with a HOW argument of `SIG_BLOCK': it adds the signals
     specified by MASK to the calling process's set of blocked signals.
     The return value is the previous set of blocked signals.

 -- Function: int sigsetmask (int MASK)
     This function equivalent to `sigprocmask' (*note Process Signal
     Mask::) with a HOW argument of `SIG_SETMASK': it sets the calling
     process's signal mask to MASK.  The return value is the previous
     set of blocked signals.

 -- Function: int sigpause (int MASK)
     This function is the equivalent of `sigsuspend' (*note Waiting for
     a Signal::):  it sets the calling process's signal mask to MASK,
     and waits for a signal to arrive.  On return the previous set of
     blocked signals is restored.


File: libc.info,  Node: Program Basics,  Next: Processes,  Prev: Signal Handling,  Up: Top

25 The Basic Program/System Interface
*************************************

"Processes" are the primitive units for allocation of system resources.
Each process has its own address space and (usually) one thread of
control.  A process executes a program; you can have multiple processes
executing the same program, but each process has its own copy of the
program within its own address space and executes it independently of
the other copies.  Though it may have multiple threads of control
within the same program and a program may be composed of multiple
logically separate modules, a process always executes exactly one
program.

   Note that we are using a specific definition of "program" for the
purposes of this manual, which corresponds to a common definition in the
context of Unix system.  In popular usage, "program" enjoys a much
broader definition; it can refer for example to a system's kernel, an
editor macro, a complex package of software, or a discrete section of
code executing within a process.

   Writing the program is what this manual is all about.  This chapter
explains the most basic interface between your program and the system
that runs, or calls, it.  This includes passing of parameters (arguments
and environment) from the system, requesting basic services from the
system, and telling the system the program is done.

   A program starts another program with the `exec' family of system
calls.  This chapter looks at program startup from the execee's point
of view.  To see the event from the execor's point of view, see *Note
Executing a File::.

* Menu:

* Program Arguments::           Parsing your program's command-line arguments.
* Environment Variables::       Less direct parameters affecting your program
* System Calls::                Requesting service from the system
* Program Termination::         Telling the system you're done; return status


File: libc.info,  Node: Program Arguments,  Next: Environment Variables,  Up: Program Basics

25.1 Program Arguments
======================

The system starts a C program by calling the function `main'.  It is up
to you to write a function named `main'--otherwise, you won't even be
able to link your program without errors.

   In ISO C you can define `main' either to take no arguments, or to
take two arguments that represent the command line arguments to the
program, like this:

     int main (int ARGC, char *ARGV[])

   The command line arguments are the whitespace-separated tokens given
in the shell command used to invoke the program; thus, in `cat foo
bar', the arguments are `foo' and `bar'.  The only way a program can
look at its command line arguments is via the arguments of `main'.  If
`main' doesn't take arguments, then you cannot get at the command line.

   The value of the ARGC argument is the number of command line
arguments.  The ARGV argument is a vector of C strings; its elements
are the individual command line argument strings.  The file name of the
program being run is also included in the vector as the first element;
the value of ARGC counts this element.  A null pointer always follows
the last element: `ARGV[ARGC]' is this null pointer.

   For the command `cat foo bar', ARGC is 3 and ARGV has three
elements, `"cat"', `"foo"' and `"bar"'.

   In Unix systems you can define `main' a third way, using three
arguments:

     int main (int ARGC, char *ARGV[], char *ENVP[])

   The first two arguments are just the same.  The third argument ENVP
gives the program's environment; it is the same as the value of
`environ'.  *Note Environment Variables::.  POSIX.1 does not allow this
three-argument form, so to be portable it is best to write `main' to
take two arguments, and use the value of `environ'.

* Menu:

* Argument Syntax::             By convention, options start with a hyphen.
* Parsing Program Arguments::   Ways to parse program options and arguments.


File: libc.info,  Node: Argument Syntax,  Next: Parsing Program Arguments,  Up: Program Arguments

25.1.1 Program Argument Syntax Conventions
------------------------------------------

POSIX recommends these conventions for command line arguments.
`getopt' (*note Getopt::) and `argp_parse' (*note Argp::) make it easy
to implement them.

   * Arguments are options if they begin with a hyphen delimiter (`-').

   * Multiple options may follow a hyphen delimiter in a single token if
     the options do not take arguments.  Thus, `-abc' is equivalent to
     `-a -b -c'.

   * Option names are single alphanumeric characters (as for `isalnum';
     *note Classification of Characters::).

   * Certain options require an argument.  For example, the `-o' command
     of the `ld' command requires an argument--an output file name.

   * An option and its argument may or may not appear as separate
     tokens.  (In other words, the whitespace separating them is
     optional.)  Thus, `-o foo' and `-ofoo' are equivalent.

   * Options typically precede other non-option arguments.

     The implementations of `getopt' and `argp_parse' in the GNU C
     library normally make it appear as if all the option arguments were
     specified before all the non-option arguments for the purposes of
     parsing, even if the user of your program intermixed option and
     non-option arguments.  They do this by reordering the elements of
     the ARGV array.  This behavior is nonstandard; if you want to
     suppress it, define the `_POSIX_OPTION_ORDER' environment variable.
     *Note Standard Environment::.

   * The argument `--' terminates all options; any following arguments
     are treated as non-option arguments, even if they begin with a
     hyphen.

   * A token consisting of a single hyphen character is interpreted as
     an ordinary non-option argument.  By convention, it is used to
     specify input from or output to the standard input and output
     streams.

   * Options may be supplied in any order, or appear multiple times.
     The interpretation is left up to the particular application
     program.

   GNU adds "long options" to these conventions.  Long options consist
of `--' followed by a name made of alphanumeric characters and dashes.
Option names are typically one to three words long, with hyphens to
separate words.  Users can abbreviate the option names as long as the
abbreviations are unique.

   To specify an argument for a long option, write `--NAME=VALUE'.
This syntax enables a long option to accept an argument that is itself
optional.

   Eventually, the GNU system will provide completion for long option
names in the shell.


File: libc.info,  Node: Parsing Program Arguments,  Prev: Argument Syntax,  Up: Program Arguments

25.1.2 Parsing Program Arguments
--------------------------------

If the syntax for the command line arguments to your program is simple
enough, you can simply pick the arguments off from ARGV by hand.  But
unless your program takes a fixed number of arguments, or all of the
arguments are interpreted in the same way (as file names, for example),
you are usually better off using `getopt' (*note Getopt::) or
`argp_parse' (*note Argp::) to do the parsing.

   `getopt' is more standard (the short-option only version of it is a
part of the POSIX standard), but using `argp_parse' is often easier,
both for very simple and very complex option structures, because it
does more of the dirty work for you.

* Menu:

* Getopt::                      Parsing program options using `getopt'.
* Argp::                        Parsing program options using `argp_parse'.
* Suboptions::                  Some programs need more detailed options.
* Suboptions Example::          This shows how it could be done for `mount'.


File: libc.info,  Node: Getopt,  Next: Argp,  Up: Parsing Program Arguments

25.2 Parsing program options using `getopt'
===========================================

The `getopt' and `getopt_long' functions automate some of the chore
involved in parsing typical unix command line options.

* Menu:

* Using Getopt::                Using the `getopt' function.
* Example of Getopt::           An example of parsing options with `getopt'.
* Getopt Long Options::         GNU suggests utilities accept long-named
                                 options; here is one way to do.
* Getopt Long Option Example::  An example of using `getopt_long'.


File: libc.info,  Node: Using Getopt,  Next: Example of Getopt,  Up: Getopt

25.2.1 Using the `getopt' function
----------------------------------

Here are the details about how to call the `getopt' function.  To use
this facility, your program must include the header file `unistd.h'.  

 -- Variable: int opterr
     If the value of this variable is nonzero, then `getopt' prints an
     error message to the standard error stream if it encounters an
     unknown option character or an option with a missing required
     argument.  This is the default behavior.  If you set this variable
     to zero, `getopt' does not print any messages, but it still
     returns the character `?' to indicate an error.

 -- Variable: int optopt
     When `getopt' encounters an unknown option character or an option
     with a missing required argument, it stores that option character
     in this variable.  You can use this for providing your own
     diagnostic messages.

 -- Variable: int optind
     This variable is set by `getopt' to the index of the next element
     of the ARGV array to be processed.  Once `getopt' has found all of
     the option arguments, you can use this variable to determine where
     the remaining non-option arguments begin.  The initial value of
     this variable is `1'.

 -- Variable: char * optarg
     This variable is set by `getopt' to point at the value of the
     option argument, for those options that accept arguments.

 -- Function: int getopt (int ARGC, char **ARGV, const char *OPTIONS)
     The `getopt' function gets the next option argument from the
     argument list specified by the ARGV and ARGC arguments.  Normally
     these values come directly from the arguments received by `main'.

     The OPTIONS argument is a string that specifies the option
     characters that are valid for this program.  An option character
     in this string can be followed by a colon (`:') to indicate that
     it takes a required argument.  If an option character is followed
     by two colons (`::'), its argument is optional; this is a GNU
     extension.

     `getopt' has three ways to deal with options that follow
     non-options ARGV elements.  The special argument `--' forces in
     all cases the end of option scanning.

        * The default is to permute the contents of ARGV while scanning
          it so that eventually all the non-options are at the end.
          This allows options to be given in any order, even with
          programs that were not written to expect this.

        * If the OPTIONS argument string begins with a hyphen (`-'),
          this is treated specially.  It permits arguments that are not
          options to be returned as if they were associated with option
          character `\1'.

        * POSIX demands the following behavior: The first non-option
          stops option processing.  This mode is selected by either
          setting the environment variable `POSIXLY_CORRECT' or
          beginning the OPTIONS argument string with a plus sign (`+').

     The `getopt' function returns the option character for the next
     command line option.  When no more option arguments are available,
     it returns `-1'.  There may still be more non-option arguments; you
     must compare the external variable `optind' against the ARGC
     parameter to check this.

     If the option has an argument, `getopt' returns the argument by
     storing it in the variable OPTARG.  You don't ordinarily need to
     copy the `optarg' string, since it is a pointer into the original
     ARGV array, not into a static area that might be overwritten.

     If `getopt' finds an option character in ARGV that was not
     included in OPTIONS, or a missing option argument, it returns `?'
     and sets the external variable `optopt' to the actual option
     character.  If the first character of OPTIONS is a colon (`:'),
     then `getopt' returns `:' instead of `?' to indicate a missing
     option argument.  In addition, if the external variable `opterr'
     is nonzero (which is the default), `getopt' prints an error
     message.


File: libc.info,  Node: Example of Getopt,  Next: Getopt Long Options,  Prev: Using Getopt,  Up: Getopt

25.2.2 Example of Parsing Arguments with `getopt'
-------------------------------------------------

Here is an example showing how `getopt' is typically used.  The key
points to notice are:

   * Normally, `getopt' is called in a loop.  When `getopt' returns
     `-1', indicating no more options are present, the loop terminates.

   * A `switch' statement is used to dispatch on the return value from
     `getopt'.  In typical use, each case just sets a variable that is
     used later in the program.

   * A second loop is used to process the remaining non-option
     arguments.

     #include <ctype.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <unistd.h>

     int
     main (int argc, char **argv)
     {
       int aflag = 0;
       int bflag = 0;
       char *cvalue = NULL;
       int index;
       int c;

       opterr = 0;

       while ((c = getopt (argc, argv, "abc:")) != -1)
         switch (c)
           {
           case 'a':
             aflag = 1;
             break;
           case 'b':
             bflag = 1;
             break;
           case 'c':
             cvalue = optarg;
             break;
           case '?':
             if (optopt == 'c')
               fprintf (stderr, "Option -%c requires an argument.\n", optopt);
             else if (isprint (optopt))
               fprintf (stderr, "Unknown option `-%c'.\n", optopt);
             else
               fprintf (stderr,
                        "Unknown option character `\\x%x'.\n",
                        optopt);
             return 1;
           default:
             abort ();
           }

       printf ("aflag = %d, bflag = %d, cvalue = %s\n",
               aflag, bflag, cvalue);

       for (index = optind; index < argc; index++)
         printf ("Non-option argument %s\n", argv[index]);
       return 0;
     }

   Here are some examples showing what this program prints with
different combinations of arguments:

     % testopt
     aflag = 0, bflag = 0, cvalue = (null)

     % testopt -a -b
     aflag = 1, bflag = 1, cvalue = (null)

     % testopt -ab
     aflag = 1, bflag = 1, cvalue = (null)

     % testopt -c foo
     aflag = 0, bflag = 0, cvalue = foo

     % testopt -cfoo
     aflag = 0, bflag = 0, cvalue = foo

     % testopt arg1
     aflag = 0, bflag = 0, cvalue = (null)
     Non-option argument arg1

     % testopt -a arg1
     aflag = 1, bflag = 0, cvalue = (null)
     Non-option argument arg1

     % testopt -c foo arg1
     aflag = 0, bflag = 0, cvalue = foo
     Non-option argument arg1

     % testopt -a -- -b
     aflag = 1, bflag = 0, cvalue = (null)
     Non-option argument -b

     % testopt -a -
     aflag = 1, bflag = 0, cvalue = (null)
     Non-option argument -


File: libc.info,  Node: Getopt Long Options,  Next: Getopt Long Option Example,  Prev: Example of Getopt,  Up: Getopt

25.2.3 Parsing Long Options with `getopt_long'
----------------------------------------------

To accept GNU-style long options as well as single-character options,
use `getopt_long' instead of `getopt'.  This function is declared in
`getopt.h', not `unistd.h'.  You should make every program accept long
options if it uses any options, for this takes little extra work and
helps beginners remember how to use the program.

 -- Data Type: struct option
     This structure describes a single long option name for the sake of
     `getopt_long'.  The argument LONGOPTS must be an array of these
     structures, one for each long option.  Terminate the array with an
     element containing all zeros.

     The `struct option' structure has these fields:

    `const char *name'
          This field is the name of the option.  It is a string.

    `int has_arg'
          This field says whether the option takes an argument.  It is
          an integer, and there are three legitimate values:
          `no_argument', `required_argument' and `optional_argument'.

    `int *flag'
    `int val'
          These fields control how to report or act on the option when
          it occurs.

          If `flag' is a null pointer, then the `val' is a value which
          identifies this option.  Often these values are chosen to
          uniquely identify particular long options.

          If `flag' is not a null pointer, it should be the address of
          an `int' variable which is the flag for this option.  The
          value in `val' is the value to store in the flag to indicate
          that the option was seen.

 -- Function: int getopt_long (int ARGC, char *const *ARGV, const char
          *SHORTOPTS, const struct option *LONGOPTS, int *INDEXPTR)
     Decode options from the vector ARGV (whose length is ARGC).  The
     argument SHORTOPTS describes the short options to accept, just as
     it does in `getopt'.  The argument LONGOPTS describes the long
     options to accept (see above).

     When `getopt_long' encounters a short option, it does the same
     thing that `getopt' would do: it returns the character code for the
     option, and stores the options argument (if it has one) in
     `optarg'.

     When `getopt_long' encounters a long option, it takes actions based
     on the `flag' and `val' fields of the definition of that option.

     If `flag' is a null pointer, then `getopt_long' returns the
     contents of `val' to indicate which option it found.  You should
     arrange distinct values in the `val' field for options with
     different meanings, so you can decode these values after
     `getopt_long' returns.  If the long option is equivalent to a short
     option, you can use the short option's character code in `val'.

     If `flag' is not a null pointer, that means this option should just
     set a flag in the program.  The flag is a variable of type `int'
     that you define.  Put the address of the flag in the `flag' field.
     Put in the `val' field the value you would like this option to
     store in the flag.  In this case, `getopt_long' returns `0'.

     For any long option, `getopt_long' tells you the index in the array
     LONGOPTS of the options definition, by storing it into
     `*INDEXPTR'.  You can get the name of the option with
     `LONGOPTS[*INDEXPTR].name'.  So you can distinguish among long
     options either by the values in their `val' fields or by their
     indices.  You can also distinguish in this way among long options
     that set flags.

     When a long option has an argument, `getopt_long' puts the argument
     value in the variable `optarg' before returning.  When the option
     has no argument, the value in `optarg' is a null pointer.  This is
     how you can tell whether an optional argument was supplied.

     When `getopt_long' has no more options to handle, it returns `-1',
     and leaves in the variable `optind' the index in ARGV of the next
     remaining argument.

   Since long option names were used before the `getopt_long' options
was invented there are program interfaces which require programs to
recognize options like `-option value' instead of `--option value'.  To
enable these programs to use the GNU getopt functionality there is one
more function available.

 -- Function: int getopt_long_only (int ARGC, char *const *ARGV, const
          char *SHORTOPTS, const struct option *LONGOPTS, int *INDEXPTR)
     The `getopt_long_only' function is equivalent to the `getopt_long'
     function but it allows to specify the user of the application to
     pass long options with only `-' instead of `--'.  The `--' prefix
     is still recognized but instead of looking through the short
     options if a `-' is seen it is first tried whether this parameter
     names a long option.  If not, it is parsed as a short option.

     Assuming `getopt_long_only' is used starting an application with

            app -foo

     the `getopt_long_only' will first look for a long option named
     `foo'.  If this is not found, the short options `f', `o', and
     again `o' are recognized.


File: libc.info,  Node: Getopt Long Option Example,  Prev: Getopt Long Options,  Up: Getopt

25.2.4 Example of Parsing Long Options with `getopt_long'
---------------------------------------------------------

     #include <stdio.h>
     #include <stdlib.h>
     #include <getopt.h>

     /* Flag set by `--verbose'. */
     static int verbose_flag;

     int
     main (argc, argv)
          int argc;
          char **argv;
     {
       int c;

       while (1)
         {
           static struct option long_options[] =
             {
               /* These options set a flag. */
               {"verbose", no_argument,       &verbose_flag, 1},
               {"brief",   no_argument,       &verbose_flag, 0},
               /* These options don't set a flag.
                  We distinguish them by their indices. */
               {"add",     no_argument,       0, 'a'},
               {"append",  no_argument,       0, 'b'},
               {"delete",  required_argument, 0, 'd'},
               {"create",  required_argument, 0, 'c'},
               {"file",    required_argument, 0, 'f'},
               {0, 0, 0, 0}
             };
           /* `getopt_long' stores the option index here. */
           int option_index = 0;

           c = getopt_long (argc, argv, "abc:d:f:",
                            long_options, &option_index);

           /* Detect the end of the options. */
           if (c == -1)
             break;

           switch (c)
             {
             case 0:
               /* If this option set a flag, do nothing else now. */
               if (long_options[option_index].flag != 0)
                 break;
               printf ("option %s", long_options[option_index].name);
               if (optarg)
                 printf (" with arg %s", optarg);
               printf ("\n");
               break;

             case 'a':
               puts ("option -a\n");
               break;

             case 'b':
               puts ("option -b\n");
               break;

             case 'c':
               printf ("option -c with value `%s'\n", optarg);
               break;

             case 'd':
               printf ("option -d with value `%s'\n", optarg);
               break;

             case 'f':
               printf ("option -f with value `%s'\n", optarg);
               break;

             case '?':
               /* `getopt_long' already printed an error message. */
               break;

             default:
               abort ();
             }
         }

       /* Instead of reporting `--verbose'
          and `--brief' as they are encountered,
          we report the final status resulting from them. */
       if (verbose_flag)
         puts ("verbose flag is set");

       /* Print any remaining command line arguments (not options). */
       if (optind < argc)
         {
           printf ("non-option ARGV-elements: ");
           while (optind < argc)
             printf ("%s ", argv[optind++]);
           putchar ('\n');
         }

       exit (0);
     }


File: libc.info,  Node: Argp,  Next: Suboptions,  Prev: Getopt,  Up: Parsing Program Arguments

25.3 Parsing Program Options with Argp
======================================

"Argp" is an interface for parsing unix-style argument vectors.  *Note
Program Arguments::.

   Argp provides features unavailable in the more commonly used
`getopt' interface.  These features include automatically producing
output in response to the `--help' and `--version' options, as
described in the GNU coding standards.  Using argp makes it less likely
that programmers will neglect to implement these additional options or
keep them up to date.

   Argp also provides the ability to merge several independently defined
option parsers into one, mediating conflicts between them and making the
result appear seamless.  A library can export an argp option parser that
user programs might employ in conjunction with their own option parsers,
resulting in less work for the user programs.  Some programs may use
only argument parsers exported by libraries, thereby achieving
consistent and efficient option-parsing for abstractions implemented by
the libraries.

   The header file `<argp.h>' should be included to use argp.

25.3.1 The `argp_parse' Function
--------------------------------

The main interface to argp is the `argp_parse' function.  In many
cases, calling `argp_parse' is the only argument-parsing code needed in
`main'.  *Note Program Arguments::.

 -- Function: error_t argp_parse (const struct argp *ARGP, int ARGC,
          char **ARGV, unsigned FLAGS, int *ARG_INDEX, void *INPUT)
     The `argp_parse' function parses the arguments in ARGV, of length
     ARGC, using the argp parser ARGP.  *Note Argp Parsers::.

     A value of zero is the same as a `struct argp'containing all
     zeros.  FLAGS is a set of flag bits that modify the parsing
     behavior.  *Note Argp Flags::.  INPUT is passed through to the argp
     parser ARGP, and has meaning defined by ARGP.  A typical usage is
     to pass a pointer to a structure which is used for specifying
     parameters to the parser and passing back the results.

     Unless the `ARGP_NO_EXIT' or `ARGP_NO_HELP' flags are included in
     FLAGS, calling `argp_parse' may result in the program exiting.
     This behavior is true if an error is detected, or when an unknown
     option is encountered.  *Note Program Termination::.

     If ARG_INDEX is non-null, the index of the first unparsed option
     in ARGV is returned as a value.

     The return value is zero for successful parsing, or an error code
     (*note Error Codes::) if an error is detected.  Different argp
     parsers may return arbitrary error codes, but the standard error
     codes are: `ENOMEM' if a memory allocation error occurred, or
     `EINVAL' if an unknown option or option argument is encountered.

* Menu:

* Globals: Argp Global Variables.  Global argp parameters.
* Parsers: Argp Parsers.        Defining parsers for use with `argp_parse'.
* Flags: Argp Flags.            Flags that modify the behavior of `argp_parse'.
* Help: Argp Help.              Printing help messages when not parsing.
* Examples: Argp Examples.      Simple examples of programs using argp.
* Customization: Argp User Customization.
                                Users may control the `--help' output format.


File: libc.info,  Node: Argp Global Variables,  Next: Argp Parsers,  Up: Argp

25.3.2 Argp Global Variables
----------------------------

These variables make it easy for user programs to implement the
`--version' option and provide a bug-reporting address in the `--help'
output.  These are implemented in argp by default.

 -- Variable: const char * argp_program_version
     If defined or set by the user program to a non-zero value, then a
     `--version' option is added when parsing with `argp_parse', which
     will print the `--version' string followed by a newline and exit.
     The exception to this is if the `ARGP_NO_EXIT' flag is used.

 -- Variable: const char * argp_program_bug_address
     If defined or set by the user program to a non-zero value,
     `argp_program_bug_address' should point to a string that will be
     printed at the end of the standard output for the `--help' option,
     embedded in a sentence that says `Report bugs to ADDRESS.'.

 -- Variable: argp_program_version_hook
     If defined or set by the user program to a non-zero value, a
     `--version' option is added when parsing with `arg_parse', which
     prints the program version and exits with a status of zero.  This
     is not the case if the `ARGP_NO_HELP' flag is used.  If the
     `ARGP_NO_EXIT' flag is set, the exit behavior of the program is
     suppressed or modified, as when the argp parser is going to be
     used by other programs.

     It should point to a function with this type of signature:

          void PRINT-VERSION (FILE *STREAM, struct argp_state *STATE)

     *Note Argp Parsing State::, for an explanation of STATE.

     This variable takes precedence over `argp_program_version', and is
     useful if a program has version information not easily expressed
     in a simple string.

 -- Variable: error_t argp_err_exit_status
     This is the exit status used when argp exits due to a parsing
     error.  If not defined or set by the user program, this defaults
     to: `EX_USAGE' from `<sysexits.h>'.


File: libc.info,  Node: Argp Parsers,  Next: Argp Flags,  Prev: Argp Global Variables,  Up: Argp

25.3.3 Specifying Argp Parsers
------------------------------

The first argument to the `argp_parse' function is a pointer to a
`struct argp', which is known as an "argp parser":

 -- Data Type: struct argp
     This structure specifies how to parse a given set of options and
     arguments, perhaps in conjunction with other argp parsers.  It has
     the following fields:

    `const struct argp_option *options'
          A pointer to a vector of `argp_option' structures specifying
          which options this argp parser understands; it may be zero if
          there are no options at all.  *Note Argp Option Vectors::.

    `argp_parser_t parser'
          A pointer to a function that defines actions for this parser;
          it is called for each option parsed, and at other
          well-defined points in the parsing process.  A value of zero
          is the same as a pointer to a function that always returns
          `ARGP_ERR_UNKNOWN'.  *Note Argp Parser Functions::.

    `const char *args_doc'
          If non-zero, a string describing what non-option arguments
          are called by this parser.  This is only used to print the
          `Usage:' message.  If it contains newlines, the strings
          separated by them are considered alternative usage patterns
          and printed on separate lines.  Lines after the first are
          prefixed by ` or: ' instead of `Usage:'.

    `const char *doc'
          If non-zero, a string containing extra text to be printed
          before and after the options in a long help message, with the
          two sections separated by a vertical tab (`'\v'', `'\013'')
          character.  By convention, the documentation before the
          options is just a short string explaining what the program
          does.  Documentation printed after the options describe
          behavior in more detail.

    `const struct argp_child *children'
          A pointer to a vector of `argp_children' structures.  This
          pointer specifies which additional argp parsers should be
          combined with this one.  *Note Argp Children::.

    `char *(*help_filter)(int KEY, const char *TEXT, void *INPUT)'
          If non-zero, a pointer to a function that filters the output
          of help messages.  *Note Argp Help Filtering::.

    `const char *argp_domain'
          If non-zero, the strings used in the argp library are
          translated using the domain described by this string.  If
          zero, the current default domain is used.


   Of the above group, `options', `parser', `args_doc', and the `doc'
fields are usually all that are needed.  If an argp parser is defined
as an initialized C variable, only the fields used need be specified in
the initializer.  The rest will default to zero due to the way C
structure initialization works.  This design is exploited in most argp
structures; the most-used fields are grouped near the beginning, the
unused fields left unspecified.

* Menu:

* Options: Argp Option Vectors.   Specifying options in an argp parser.
* Argp Parser Functions::         Defining actions for an argp parser.
* Children: Argp Children.        Combining multiple argp parsers.
* Help Filtering: Argp Help Filtering.  Customizing help output for an argp parser.


File: libc.info,  Node: Argp Option Vectors,  Next: Argp Parser Functions,  Prev: Argp Parsers,  Up: Argp Parsers

25.3.4 Specifying Options in an Argp Parser
-------------------------------------------

The `options' field in a `struct argp' points to a vector of `struct
argp_option' structures, each of which specifies an option that the
argp parser supports.  Multiple entries may be used for a single option
provided it has multiple names.  This should be terminated by an entry
with zero in all fields.  Note that when using an initialized C array
for options, writing `{ 0 }' is enough to achieve this.

 -- Data Type: struct argp_option
     This structure specifies a single option that an argp parser
     understands, as well as how to parse and document that option.  It
     has the following fields:

    `const char *name'
          The long name for this option, corresponding to the long
          option `--NAME'; this field may be zero if this option _only_
          has a short name.  To specify multiple names for an option,
          additional entries may follow this one, with the
          `OPTION_ALIAS' flag set.  *Note Argp Option Flags::.

    `int key'
          The integer key provided by the current option to the option
          parser.  If KEY has a value that is a printable ASCII
          character (i.e., `isascii (KEY)' is true), it _also_
          specifies a short option `-CHAR', where CHAR is the ASCII
          character with the code KEY.

    `const char *arg'
          If non-zero, this is the name of an argument associated with
          this option, which must be provided (e.g., with the
          `--NAME=VALUE' or `-CHAR VALUE' syntaxes), unless the
          `OPTION_ARG_OPTIONAL' flag (*note Argp Option Flags::) is
          set, in which case it _may_ be provided.

    `int flags'
          Flags associated with this option, some of which are referred
          to above.  *Note Argp Option Flags::.

    `const char *doc'
          A documentation string for this option, for printing in help
          messages.

          If both the `name' and `key' fields are zero, this string
          will be printed tabbed left from the normal option column,
          making it useful as a group header.  This will be the first
          thing printed in its group.  In this usage, it's conventional
          to end the string with a `:' character.

    `int group'
          Group identity for this option.

          In a long help message, options are sorted alphabetically
          within each group, and the groups presented in the order 0,
          1, 2, ..., N, -M, ..., -2, -1.

          Every entry in an options array with this field 0 will
          inherit the group number of the previous entry, or zero if
          it's the first one.  If it's a group header with `name' and
          `key' fields both zero, the previous entry + 1 is the
          default.  Automagic options such as `--help' are put into
          group -1.

          Note that because of C structure initialization rules, this
          field often need not be specified, because 0 is the correct
          value.

* Menu:

* Flags: Argp Option Flags.     Flags for options.


File: libc.info,  Node: Argp Option Flags,  Up: Argp Option Vectors

25.3.4.1 Flags for Argp Options
...............................

The following flags may be or'd together in the `flags' field of a
`struct argp_option'.  These flags control various aspects of how that
option is parsed or displayed in help messages:

`OPTION_ARG_OPTIONAL'
     The argument associated with this option is optional.

`OPTION_HIDDEN'
     This option isn't displayed in any help messages.

`OPTION_ALIAS'
     This option is an alias for the closest previous non-alias option.
     This means that it will be displayed in the same help entry, and
     will inherit fields other than `name' and `key' from the option
     being aliased.

`OPTION_DOC'
     This option isn't actually an option and should be ignored by the
     actual option parser.  It is an arbitrary section of documentation
     that should be displayed in much the same manner as the options.
     This is known as a "documentation option".

     If this flag is set, then the option `name' field is displayed
     unmodified (e.g., no `--' prefix is added) at the left-margin where
     a _short_ option would normally be displayed, and this
     documentation string is left in it's usual place.  For purposes of
     sorting, any leading whitespace and punctuation is ignored, unless
     the first non-whitespace character is `-'.  This entry is displayed
     after all options, after `OPTION_DOC' entries with a leading `-',
     in the same group.

`OPTION_NO_USAGE'
     This option shouldn't be included in `long' usage messages, but
     should still be included in other help messages.  This is intended
     for options that are completely documented in an argp's `args_doc'
     field.  *Note Argp Parsers::.  Including this option in the
     generic usage list would be redundant, and should be avoided.

     For instance, if `args_doc' is `"FOO BAR\n-x BLAH"', and the `-x'
     option's purpose is to distinguish these two cases, `-x' should
     probably be marked `OPTION_NO_USAGE'.


File: libc.info,  Node: Argp Parser Functions,  Next: Argp Children,  Prev: Argp Option Vectors,  Up: Argp Parsers

25.3.5 Argp Parser Functions
----------------------------

The function pointed to by the `parser' field in a `struct argp' (*note
Argp Parsers::) defines what actions take place in response to each
option or argument parsed.  It is also used as a hook, allowing a
parser to perform tasks at certain other points during parsing.

   Argp parser functions have the following type signature:

     error_t PARSER (int KEY, char *ARG, struct argp_state *STATE)

where the arguments are as follows:

KEY
     For each option that is parsed, PARSER is called with a value of
     KEY from that option's `key' field in the option vector.  *Note
     Argp Option Vectors::.  PARSER is also called at other times with
     special reserved keys, such as `ARGP_KEY_ARG' for non-option
     arguments.  *Note Argp Special Keys::.

ARG
     If KEY is an option, ARG is its given value.  This defaults to
     zero if no value is specified.  Only options that have a non-zero
     `arg' field can ever have a value.  These must _always_ have a
     value unless the `OPTION_ARG_OPTIONAL' flag is specified.  If the
     input being parsed specifies a value for an option that doesn't
     allow one, an error results before PARSER ever gets called.

     If KEY is `ARGP_KEY_ARG', ARG is a non-option argument.  Other
     special keys always have a zero ARG.

STATE
     STATE points to a `struct argp_state', containing useful
     information about the current parsing state for use by PARSER.
     *Note Argp Parsing State::.

   When PARSER is called, it should perform whatever action is
appropriate for KEY, and return `0' for success, `ARGP_ERR_UNKNOWN' if
the value of KEY is not handled by this parser function, or a unix
error code if a real error occurred.  *Note Error Codes::.

 -- Macro: int ARGP_ERR_UNKNOWN
     Argp parser functions should return `ARGP_ERR_UNKNOWN' for any KEY
     value they do not recognize, or for non-option arguments (`KEY ==
     ARGP_KEY_ARG') that they are not equipped to handle.

   A typical parser function uses a switch statement on KEY:

     error_t
     parse_opt (int key, char *arg, struct argp_state *state)
     {
       switch (key)
         {
         case OPTION_KEY:
           ACTION
           break;
         ...
         default:
           return ARGP_ERR_UNKNOWN;
         }
       return 0;
     }

* Menu:

* Keys: Argp Special Keys.           Special values for the KEY argument.
* State: Argp Parsing State.         What the STATE argument refers to.
* Functions: Argp Helper Functions.  Functions to help during argp parsing.


File: libc.info,  Node: Argp Special Keys,  Next: Argp Parsing State,  Up: Argp Parser Functions

25.3.5.1 Special Keys for Argp Parser Functions
...............................................

In addition to key values corresponding to user options, the KEY
argument to argp parser functions may have a number of other special
values.  In the following example ARG and STATE refer to parser
function arguments.  *Note Argp Parser Functions::.

`ARGP_KEY_ARG'
     This is not an option at all, but rather a command line argument,
     whose value is pointed to by ARG.

     When there are multiple parser functions in play due to argp
     parsers being combined, it's impossible to know which one will
     handle a specific argument.  Each is called until one returns 0 or
     an error other than `ARGP_ERR_UNKNOWN'; if an argument is not
     handled, `argp_parse' immediately returns success, without parsing
     any more arguments.

     Once a parser function returns success for this key, that fact is
     recorded, and the `ARGP_KEY_NO_ARGS' case won't be used.
     _However_, if while processing the argument a parser function
     decrements the `next' field of its STATE argument, the option
     won't be considered processed; this is to allow you to actually
     modify the argument, perhaps into an option, and have it processed
     again.

`ARGP_KEY_ARGS'
     If a parser function returns `ARGP_ERR_UNKNOWN' for
     `ARGP_KEY_ARG', it is immediately called again with the key
     `ARGP_KEY_ARGS', which has a similar meaning, but is slightly more
     convenient for consuming all remaining arguments.  ARG is 0, and
     the tail of the argument vector may be found at `STATE->argv +
     STATE->next'.  If success is returned for this key, and
     `STATE->next' is unchanged, all remaining arguments are considered
     to have been consumed.  Otherwise, the amount by which
     `STATE->next' has been adjusted indicates how many were used.
     Here's an example that uses both, for different args:

          ...
          case ARGP_KEY_ARG:
            if (STATE->arg_num == 0)
              /* First argument */
              first_arg = ARG;
            else
              /* Let the next case parse it.  */
              return ARGP_KEY_UNKNOWN;
            break;
          case ARGP_KEY_ARGS:
            remaining_args = STATE->argv + STATE->next;
            num_remaining_args = STATE->argc - STATE->next;
            break;

`ARGP_KEY_END'
     This indicates that there are no more command line arguments.
     Parser functions are called in a different order, children first.
     This allows each parser to clean up its state for the parent.

`ARGP_KEY_NO_ARGS'
     Because it's common to do some special processing if there aren't
     any non-option args, parser functions are called with this key if
     they didn't successfully process any non-option arguments.  This
     is called just before `ARGP_KEY_END', where more general validity
     checks on previously parsed arguments take place.

`ARGP_KEY_INIT'
     This is passed in before any parsing is done.  Afterwards, the
     values of each element of the `child_input' field of STATE, if
     any, are copied to each child's state to be the initial value of
     the `input' when _their_ parsers are called.

`ARGP_KEY_SUCCESS'
     Passed in when parsing has successfully been completed, even if
     arguments remain.

`ARGP_KEY_ERROR'
     Passed in if an error has occurred and parsing is terminated.  In
     this case a call with a key of `ARGP_KEY_SUCCESS' is never made.

`ARGP_KEY_FINI'
     The final key ever seen by any parser, even after
     `ARGP_KEY_SUCCESS' and `ARGP_KEY_ERROR'.  Any resources allocated
     by `ARGP_KEY_INIT' may be freed here.  At times, certain resources
     allocated are to be returned to the caller after a successful
     parse.  In that case, those particular resources can be freed in
     the `ARGP_KEY_ERROR' case.

   In all cases, `ARGP_KEY_INIT' is the first key seen by parser
functions, and `ARGP_KEY_FINI' the last, unless an error was returned
by the parser for `ARGP_KEY_INIT'.  Other keys can occur in one the
following orders.  OPT refers to an arbitrary option key:

OPT... `ARGP_KEY_NO_ARGS' `ARGP_KEY_END' `ARGP_KEY_SUCCESS'
     The arguments being parsed did not contain any non-option
     arguments.

( OPT | `ARGP_KEY_ARG' )... `ARGP_KEY_END' `ARGP_KEY_SUCCESS'
     All non-option arguments were successfully handled by a parser
     function.  There may be multiple parser functions if multiple argp
     parsers were combined.

( OPT | `ARGP_KEY_ARG' )... `ARGP_KEY_SUCCESS'
     Some non-option argument went unrecognized.

     This occurs when every parser function returns `ARGP_KEY_UNKNOWN'
     for an argument, in which case parsing stops at that argument if
     ARG_INDEX is a null pointer.  Otherwise an error occurs.

   In all cases, if a non-null value for ARG_INDEX gets passed to
`argp_parse', the index of the first unparsed command-line argument is
passed back in that value.

   If an error occurs and is either detected by argp or because a parser
function returned an error value, each parser is called with
`ARGP_KEY_ERROR'.  No further calls are made, except the final call
with `ARGP_KEY_FINI'.


File: libc.info,  Node: Argp Helper Functions,  Prev: Argp Parsing State,  Up: Argp Parser Functions

25.3.5.2 Functions For Use in Argp Parsers
..........................................

Argp provides a number of functions available to the user of argp
(*note Argp Parser Functions::), mostly for producing error messages.
These take as their first argument the STATE argument to the parser
function.  *Note Argp Parsing State::.

 -- Function: void argp_usage (const struct argp_state *STATE)
     Outputs the standard usage message for the argp parser referred to
     by STATE to `STATE->err_stream' and terminate the program with
     `exit (argp_err_exit_status)'.  *Note Argp Global Variables::.

 -- Function: void argp_error (const struct argp_state *STATE, const
          char *FMT, ...)
     Prints the printf format string FMT and following args, preceded
     by the program name and `:', and followed by a `Try ... --help'
     message, and terminates the program with an exit status of
     `argp_err_exit_status'.  *Note Argp Global Variables::.

 -- Function: void argp_failure (const struct argp_state *STATE, int
          STATUS, int ERRNUM, const char *FMT, ...)
     Similar to the standard gnu error-reporting function `error', this
     prints the program name and `:', the printf format string FMT, and
     the appropriate following args.  If it is non-zero, the standard
     unix error text for ERRNUM is printed.  If STATUS is non-zero, it
     terminates the program with that value as its exit status.

     The difference between `argp_failure' and `argp_error' is that
     `argp_error' is for _parsing errors_, whereas `argp_failure' is
     for other problems that occur during parsing but don't reflect a
     syntactic problem with the input, such as illegal values for
     options, bad phase of the moon, etc.

 -- Function: void argp_state_help (const struct argp_state *STATE,
          FILE *STREAM, unsigned FLAGS)
     Outputs a help message for the argp parser referred to by STATE,
     to STREAM.  The FLAGS argument determines what sort of help
     message is produced.  *Note Argp Help Flags::.

   Error output is sent to `STATE->err_stream', and the program name
printed is `STATE->name'.

   The output or program termination behavior of these functions may be
suppressed if the `ARGP_NO_EXIT' or `ARGP_NO_ERRS' flags are passed to
`argp_parse'.  *Note Argp Flags::.

   This behavior is useful if an argp parser is exported for use by
other programs (e.g., by a library), and may be used in a context where
it is not desirable to terminate the program in response to parsing
errors.  In argp parsers intended for such general use, and for the
case where the program _doesn't_ terminate, calls to any of these
functions should be followed by code that returns the appropriate error
code:

     if (BAD ARGUMENT SYNTAX)
       {
          argp_usage (STATE);
          return EINVAL;
       }

If a parser function will _only_ be used when `ARGP_NO_EXIT' is not
set, the return may be omitted.


File: libc.info,  Node: Argp Parsing State,  Next: Argp Helper Functions,  Prev: Argp Special Keys,  Up: Argp Parser Functions

25.3.5.3 Argp Parsing State
...........................

The third argument to argp parser functions (*note Argp Parser
Functions::) is a pointer to a `struct argp_state', which contains
information about the state of the option parsing.

 -- Data Type: struct argp_state
     This structure has the following fields, which may be modified as
     noted:

    `const struct argp *const root_argp'
          The top level argp parser being parsed.  Note that this is
          often _not_ the same `struct argp' passed into `argp_parse' by
          the invoking program.  *Note Argp::.  It is an internal argp
          parser that contains options implemented by `argp_parse'
          itself, such as `--help'.

    `int argc'
    `char **argv'
          The argument vector being parsed.  This may be modified.

    `int next'
          The index in `argv' of the next argument to be parsed.  This
          may be modified.

          One way to consume all remaining arguments in the input is to
          set `STATE->next = STATE->argc', perhaps after recording the
          value of the `next' field to find the consumed arguments.  The
          current option can be re-parsed immediately by decrementing
          this field, then modifying `STATE->argv[STATE->next]' to
          reflect the option that should be reexamined.

    `unsigned flags'
          The flags supplied to `argp_parse'.  These may be modified,
          although some flags may only take effect when `argp_parse' is
          first invoked.  *Note Argp Flags::.

    `unsigned arg_num'
          While calling a parsing function with the KEY argument
          `ARGP_KEY_ARG', this represents the number of the current arg,
          starting at 0.  It is incremented after each `ARGP_KEY_ARG'
          call returns.  At all other times, this is the number of
          `ARGP_KEY_ARG' arguments that have been processed.

    `int quoted'
          If non-zero, the index in `argv' of the first argument
          following a special `--' argument.  This prevents anything
          that follows from being interpreted as an option.  It is only
          set after argument parsing has proceeded past this point.

    `void *input'
          An arbitrary pointer passed in from the caller of
          `argp_parse', in the INPUT argument.

    `void **child_inputs'
          These are values that will be passed to child parsers.  This
          vector will be the same length as the number of children in
          the current parser.  Each child parser will be given the
          value of `STATE->child_inputs[I]' as _its_ `STATE->input'
          field, where I is the index of the child in the this parser's
          `children' field.  *Note Argp Children::.

    `void *hook'
          For the parser function's use.  Initialized to 0, but
          otherwise ignored by argp.

    `char *name'
          The name used when printing messages.  This is initialized to
          `argv[0]', or `program_invocation_name' if `argv[0]' is
          unavailable.

    `FILE *err_stream'
    `FILE *out_stream'
          The stdio streams used when argp prints.  Error messages are
          printed to `err_stream', all other output, such as `--help'
          output) to `out_stream'.  These are initialized to `stderr'
          and `stdout' respectively.  *Note Standard Streams::.

    `void *pstate'
          Private, for use by the argp implementation.


File: libc.info,  Node: Argp Children,  Next: Argp Help Filtering,  Prev: Argp Parser Functions,  Up: Argp Parsers

25.3.6 Combining Multiple Argp Parsers
--------------------------------------

The `children' field in a `struct argp' enables other argp parsers to
be combined with the referencing one for the parsing of a single set of
arguments.  This field should point to a vector of `struct argp_child',
which is terminated by an entry having a value of zero in the `argp'
field.

   Where conflicts between combined parsers arise, as when two specify
an option with the same name, the parser conflicts are resolved in
favor of the parent argp parser(s), or the earlier of the argp parsers
in the list of children.

 -- Data Type: struct argp_child
     An entry in the list of subsidiary argp parsers pointed to by the
     `children' field in a `struct argp'.  The fields are as follows:

    `const struct argp *argp'
          The child argp parser, or zero to end of the list.

    `int flags'
          Flags for this child.

    `const char *header'
          If non-zero, this is an optional header to be printed within
          help output before the child options.  As a side-effect, a
          non-zero value forces the child options to be grouped
          together.  To achieve this effect without actually printing a
          header string, use a value of `""'.  As with header strings
          specified in an option entry, the conventional value of the
          last character is `:'.  *Note Argp Option Vectors::.

    `int group'
          This is where the child options are grouped relative to the
          other `consolidated' options in the parent argp parser.  The
          values are the same as the `group' field in `struct
          argp_option'.  *Note Argp Option Vectors::.  All
          child-groupings follow parent options at a particular group
          level.  If both this field and `header' are zero, then the
          child's options aren't grouped together, they are merged with
          parent options at the parent option group level.



File: libc.info,  Node: Argp Flags,  Next: Argp Help,  Prev: Argp Parsers,  Up: Argp

25.3.7 Flags for `argp_parse'
-----------------------------

The default behavior of `argp_parse' is designed to be convenient for
the most common case of parsing program command line argument.  To
modify these defaults, the following flags may be or'd together in the
FLAGS argument to `argp_parse':

`ARGP_PARSE_ARGV0'
     Don't ignore the first element of the ARGV argument to
     `argp_parse'.  Unless `ARGP_NO_ERRS' is set, the first element of
     the argument vector is skipped for option parsing purposes, as it
     corresponds to the program name in a command line.

`ARGP_NO_ERRS'
     Don't print error messages for unknown options to `stderr'; unless
     this flag is set, `ARGP_PARSE_ARGV0' is ignored, as `argv[0]' is
     used as the program name in the error messages.  This flag implies
     `ARGP_NO_EXIT'.  This is based on the assumption that silent
     exiting upon errors is bad behavior.

`ARGP_NO_ARGS'
     Don't parse any non-option args.  Normally these are parsed by
     calling the parse functions with a key of `ARGP_KEY_ARG', the
     actual argument being the value.  This flag needn't normally be
     set, as the default behavior is to stop parsing as soon as an
     argument fails to be parsed.  *Note Argp Parser Functions::.

`ARGP_IN_ORDER'
     Parse options and arguments in the same order they occur on the
     command line.  Normally they're rearranged so that all options
     come first.

`ARGP_NO_HELP'
     Don't provide the standard long option `--help', which ordinarily
     causes usage and option help information to be output to `stdout'
     and `exit (0)'.

`ARGP_NO_EXIT'
     Don't exit on errors, although they may still result in error
     messages.

`ARGP_LONG_ONLY'
     Use the gnu getopt `long-only' rules for parsing arguments.  This
     allows long-options to be recognized with only a single `-' (i.e.,
     `-help').  This results in a less useful interface, and its use is
     discouraged as it conflicts with the way most GNU programs work as
     well as the GNU coding standards.

`ARGP_SILENT'
     Turns off any message-printing/exiting options, specifically
     `ARGP_NO_EXIT', `ARGP_NO_ERRS', and `ARGP_NO_HELP'.


File: libc.info,  Node: Argp Help Filtering,  Prev: Argp Children,  Up: Argp Parsers

25.3.8 Customizing Argp Help Output
-----------------------------------

The `help_filter' field in a `struct argp' is a pointer to a function
that filters the text of help messages before displaying them.  They
have a function signature like:

     char *HELP-FILTER (int KEY, const char *TEXT, void *INPUT)

Where KEY is either a key from an option, in which case TEXT is that
option's help text.  *Note Argp Option Vectors::.  Alternately, one of
the special keys with names beginning with `ARGP_KEY_HELP_' might be
used, describing which other help text TEXT will contain.  *Note Argp
Help Filter Keys::.

   The function should return either TEXT if it remains as-is, or a
replacement string allocated using `malloc'.  This will be either be
freed by argp or zero, which prints nothing.  The value of TEXT is
supplied _after_ any translation has been done, so if any of the
replacement text needs translation, it will be done by the filter
function.  INPUT is either the input supplied to `argp_parse' or it is
zero, if `argp_help' was called directly by the user.

* Menu:

* Keys: Argp Help Filter Keys.  Special KEY values for help filter functions.


File: libc.info,  Node: Argp Help Filter Keys,  Up: Argp Help Filtering

25.3.8.1 Special Keys for Argp Help Filter Functions
....................................................

The following special values may be passed to an argp help filter
function as the first argument in addition to key values for user
options.  They specify which help text the TEXT argument contains:

`ARGP_KEY_HELP_PRE_DOC'
     The help text preceding options.

`ARGP_KEY_HELP_POST_DOC'
     The help text following options.

`ARGP_KEY_HELP_HEADER'
     The option header string.

`ARGP_KEY_HELP_EXTRA'
     This is used after all other documentation; TEXT is zero for this
     key.

`ARGP_KEY_HELP_DUP_ARGS_NOTE'
     The explanatory note printed when duplicate option arguments have
     been suppressed.

`ARGP_KEY_HELP_ARGS_DOC'
     The argument doc string; formally the `args_doc' field from the
     argp parser.  *Note Argp Parsers::.


File: libc.info,  Node: Argp Help,  Next: Argp Examples,  Prev: Argp Flags,  Up: Argp

25.3.9 The `argp_help' Function
-------------------------------

Normally programs using argp need not be written with particular
printing argument-usage-type help messages in mind as the standard
`--help' option is handled automatically by argp.  Typical error cases
can be handled using `argp_usage' and `argp_error'.  *Note Argp Helper
Functions::.  However, if it's desirable to print a help message in
some context other than parsing the program options, argp offers the
`argp_help' interface.

 -- Function: void argp_help (const struct argp *ARGP, FILE *STREAM,
          unsigned FLAGS, char *NAME)
     This outputs a help message for the argp parser ARGP to STREAM.
     The type of messages printed will be determined by FLAGS.

     Any options such as `--help' that are implemented automatically by
     argp itself will _not_ be present in the help output; for this
     reason it is best to use `argp_state_help' if calling from within
     an argp parser function.  *Note Argp Helper Functions::.

* Menu:

* Flags: Argp Help Flags.       Specifying what sort of help message to print.


File: libc.info,  Node: Argp Help Flags,  Up: Argp Help

25.3.10 Flags for the `argp_help' Function
------------------------------------------

When calling `argp_help' (*note Argp Help::) or `argp_state_help'
(*note Argp Helper Functions::) the exact output is determined by the
FLAGS argument.  This should consist of any of the following flags,
or'd together:

`ARGP_HELP_USAGE'
     A unix `Usage:' message that explicitly lists all options.

`ARGP_HELP_SHORT_USAGE'
     A unix `Usage:' message that displays an appropriate placeholder to
     indicate where the options go; useful for showing the non-option
     argument syntax.

`ARGP_HELP_SEE'
     A `Try ... for more help' message; `...' contains the program name
     and `--help'.

`ARGP_HELP_LONG'
     A verbose option help message that gives each option available
     along with its documentation string.

`ARGP_HELP_PRE_DOC'
     The part of the argp parser doc string preceding the verbose
     option help.

`ARGP_HELP_POST_DOC'
     The part of the argp parser doc string that following the verbose
     option help.

`ARGP_HELP_DOC'
     `(ARGP_HELP_PRE_DOC | ARGP_HELP_POST_DOC)'

`ARGP_HELP_BUG_ADDR'
     A message that prints where to report bugs for this program, if the
     `argp_program_bug_address' variable contains this information.

`ARGP_HELP_LONG_ONLY'
     This will modify any output to reflect the `ARGP_LONG_ONLY' mode.

   The following flags are only understood when used with
`argp_state_help'.  They control whether the function returns after
printing its output, or terminates the program:

`ARGP_HELP_EXIT_ERR'
     This will terminate the program with `exit (argp_err_exit_status)'.

`ARGP_HELP_EXIT_OK'
     This will terminate the program with `exit (0)'.

   The following flags are combinations of the basic flags for printing
standard messages:

`ARGP_HELP_STD_ERR'
     Assuming that an error message for a parsing error has printed,
     this prints a message on how to get help, and terminates the
     program with an error.

`ARGP_HELP_STD_USAGE'
     This prints a standard usage message and terminates the program
     with an error.  This is used when no other specific error messages
     are appropriate or available.

`ARGP_HELP_STD_HELP'
     This prints the standard response for a `--help' option, and
     terminates the program successfully.


File: libc.info,  Node: Argp Examples,  Next: Argp User Customization,  Prev: Argp Help,  Up: Argp

25.3.11 Argp Examples
---------------------

These example programs demonstrate the basic usage of argp.

* Menu:

* 1: Argp Example 1.            A minimal program using argp.
* 2: Argp Example 2.            A program using only default options.
* 3: Argp Example 3.            A simple program with user options.
* 4: Argp Example 4.            Combining multiple argp parsers.


File: libc.info,  Node: Argp Example 1,  Next: Argp Example 2,  Up: Argp Examples

25.3.11.1 A Minimal Program Using Argp
......................................

This is perhaps the smallest program possible that uses argp.  It won't
do much except give an error messages and exit when there are any
arguments, and prints a rather pointless message for `--help'.

     /* Argp example #1 - a minimal program using argp */

     /* This is (probably) the smallest possible program that
        uses argp.  It won't do much except give an error
        messages and exit when there are any arguments, and print
        a (rather pointless) messages for -help. */

     #include <argp.h>

     int main (int argc, char **argv)
     {
       argp_parse (0, argc, argv, 0, 0, 0);
       exit (0);
     }


File: libc.info,  Node: Argp Example 2,  Next: Argp Example 3,  Prev: Argp Example 1,  Up: Argp Examples

25.3.11.2 A Program Using Argp with Only Default Options
........................................................

This program doesn't use any options or arguments, it uses argp to be
compliant with the GNU standard command line format.

   In addition to giving no arguments and implementing a `--help'
option, this example has a `--version' option, which will put the given
documentation string and bug address in the `--help' output, as per GNU
standards.

   The variable `argp' contains the argument parser specification.
Adding fields to this structure is the way most parameters are passed
to `argp_parse'.  The first three fields are normally used, but they
are not in this small program.  There are also two global variables
that argp can use defined here, `argp_program_version' and
`argp_program_bug_address'.  They are considered global variables
because they will almost always be constant for a given program, even
if they use different argument parsers for various tasks.

     /* Argp example #2 - a pretty minimal program using argp */

     /* This program doesn't use any options or arguments, but uses
        argp to be compliant with the GNU standard command line
        format.

        In addition to making sure no arguments are given, and
        implementing a -help option, this example will have a
        -version option, and will put the given documentation string
        and bug address in the -help output, as per GNU standards.

        The variable ARGP contains the argument parser specification;
        adding fields to this structure is the way most parameters are
        passed to argp_parse (the first three fields are usually used,
        but not in this small program).  There are also two global
        variables that argp knows about defined here,
        ARGP_PROGRAM_VERSION and ARGP_PROGRAM_BUG_ADDRESS (they are
        global variables because they will almost always be constant
        for a given program, even if it uses different argument
        parsers for various tasks). */

     #include <argp.h>

     const char *argp_program_version =
       "argp-ex2 1.0";
     const char *argp_program_bug_address =
       "<bug-gnu-utils@gnu.org>";

     /* Program documentation. */
     static char doc[] =
       "Argp example #2 -- a pretty minimal program using argp";

     /* Our argument parser.  The `options', `parser', and
        `args_doc' fields are zero because we have neither options or
        arguments; `doc' and `argp_program_bug_address' will be
        used in the output for `--help', and the `--version'
        option will print out `argp_program_version'. */
     static struct argp argp = { 0, 0, 0, doc };

     int main (int argc, char **argv)
     {
       argp_parse (&argp, argc, argv, 0, 0, 0);
       exit (0);
     }


File: libc.info,  Node: Argp Example 3,  Next: Argp Example 4,  Prev: Argp Example 2,  Up: Argp Examples

25.3.11.3 A Program Using Argp with User Options
................................................

This program uses the same features as example 2, adding user options
and arguments.

   We now use the first four fields in `argp' (*note Argp Parsers::)
and specify `parse_opt' as the parser function.  *Note Argp Parser
Functions::.

   Note that in this example, `main' uses a structure to communicate
with the `parse_opt' function, a pointer to which it passes in the
`input' argument to `argp_parse'.  *Note Argp::.  It is retrieved by
`parse_opt' through the `input' field in its `state' argument.  *Note
Argp Parsing State::.  Of course, it's also possible to use global
variables instead, but using a structure like this is somewhat more
flexible and clean.

     /* Argp example #3 - a program with options and arguments using argp */

     /* This program uses the same features as example 2, and uses options and
        arguments.

        We now use the first four fields in ARGP, so here's a description of them:
          OPTIONS  - A pointer to a vector of struct argp_option (see below)
          PARSER   - A function to parse a single option, called by argp
          ARGS_DOC - A string describing how the non-option arguments should look
          DOC      - A descriptive string about this program; if it contains a
                      vertical tab character (\v), the part after it will be
                      printed *following* the options

        The function PARSER takes the following arguments:
          KEY  - An integer specifying which option this is (taken
                  from the KEY field in each struct argp_option), or
                  a special key specifying something else; the only
                  special keys we use here are ARGP_KEY_ARG, meaning
                  a non-option argument, and ARGP_KEY_END, meaning
                  that all arguments have been parsed
          ARG  - For an option KEY, the string value of its
                  argument, or NULL if it has none
          STATE- A pointer to a struct argp_state, containing
                  various useful information about the parsing state; used here
                  are the INPUT field, which reflects the INPUT argument to
                  argp_parse, and the ARG_NUM field, which is the number of the
                  current non-option argument being parsed
        It should return either 0, meaning success, ARGP_ERR_UNKNOWN, meaning the
        given KEY wasn't recognized, or an errno value indicating some other
        error.

        Note that in this example, main uses a structure to communicate with the
        parse_opt function, a pointer to which it passes in the INPUT argument to
        argp_parse.  Of course, it's also possible to use global variables
        instead, but this is somewhat more flexible.

        The OPTIONS field contains a pointer to a vector of struct argp_option's;
        that structure has the following fields (if you assign your option
        structures using array initialization like this example, unspecified
        fields will be defaulted to 0, and need not be specified):
          NAME   - The name of this option's long option (may be zero)
          KEY    - The KEY to pass to the PARSER function when parsing this option,
                    *and* the name of this option's short option, if it is a
                    printable ascii character
          ARG    - The name of this option's argument, if any
          FLAGS  - Flags describing this option; some of them are:
                      OPTION_ARG_OPTIONAL - The argument to this option is optional
                      OPTION_ALIAS        - This option is an alias for the
                                             previous option
                      OPTION_HIDDEN       - Don't show this option in -help output
          DOC    - A documentation string for this option, shown in -help output

        An options vector should be terminated by an option with all fields zero. */

     #include <argp.h>

     const char *argp_program_version =
       "argp-ex3 1.0";
     const char *argp_program_bug_address =
       "<bug-gnu-utils@gnu.org>";

     /* Program documentation. */
     static char doc[] =
       "Argp example #3 -- a program with options and arguments using argp";

     /* A description of the arguments we accept. */
     static char args_doc[] = "ARG1 ARG2";

     /* The options we understand. */
     static struct argp_option options[] = {
       {"verbose",  'v', 0,      0,  "Produce verbose output" },
       {"quiet",    'q', 0,      0,  "Don't produce any output" },
       {"silent",   's', 0,      OPTION_ALIAS },
       {"output",   'o', "FILE", 0,
        "Output to FILE instead of standard output" },
       { 0 }
     };

     /* Used by `main' to communicate with `parse_opt'. */
     struct arguments
     {
       char *args[2];                /* ARG1 & ARG2 */
       int silent, verbose;
       char *output_file;
     };

     /* Parse a single option. */
     static error_t
     parse_opt (int key, char *arg, struct argp_state *state)
     {
       /* Get the INPUT argument from `argp_parse', which we
          know is a pointer to our arguments structure. */
       struct arguments *arguments = state->input;

       switch (key)
         {
         case 'q': case 's':
           arguments->silent = 1;
           break;
         case 'v':
           arguments->verbose = 1;
           break;
         case 'o':
           arguments->output_file = arg;
           break;

         case ARGP_KEY_ARG:
           if (state->arg_num >= 2)
             /* Too many arguments. */
             argp_usage (state);

           arguments->args[state->arg_num] = arg;

           break;

         case ARGP_KEY_END:
           if (state->arg_num < 2)
             /* Not enough arguments. */
             argp_usage (state);
           break;

         default:
           return ARGP_ERR_UNKNOWN;
         }
       return 0;
     }

     /* Our argp parser. */
     static struct argp argp = { options, parse_opt, args_doc, doc };

     int main (int argc, char **argv)
     {
       struct arguments arguments;

       /* Default values. */
       arguments.silent = 0;
       arguments.verbose = 0;
       arguments.output_file = "-";

       /* Parse our arguments; every option seen by `parse_opt' will
          be reflected in `arguments'. */
       argp_parse (&argp, argc, argv, 0, 0, &arguments);

       printf ("ARG1 = %s\nARG2 = %s\nOUTPUT_FILE = %s\n"
               "VERBOSE = %s\nSILENT = %s\n",
               arguments.args[0], arguments.args[1],
               arguments.output_file,
               arguments.verbose ? "yes" : "no",
               arguments.silent ? "yes" : "no");

       exit (0);
     }


File: libc.info,  Node: Argp Example 4,  Prev: Argp Example 3,  Up: Argp Examples

25.3.11.4 A Program Using Multiple Combined Argp Parsers
........................................................

This program uses the same features as example 3, but has more options,
and presents more structure in the `--help' output.  It also
illustrates how you can `steal' the remainder of the input arguments
past a certain point for programs that accept a list of items.  It also
illustrates the KEY value `ARGP_KEY_NO_ARGS', which is only given if no
non-option arguments were supplied to the program.  *Note Argp Special
Keys::.

   For structuring help output, two features are used: _headers_ and a
two part option string.  The _headers_ are entries in the options
vector.  *Note Argp Option Vectors::.  The first four fields are zero.
The two part documentation string are in the variable `doc', which
allows documentation both before and after the options.  *Note Argp
Parsers::, the two parts of `doc' are separated by a vertical-tab
character (`'\v'', or `'\013'').  By convention, the documentation
before the options is a short string stating what the program does, and
after any options it is longer, describing the behavior in more detail.
All documentation strings are automatically filled for output,
although newlines may be included to force a line break at a particular
point.  In addition, documentation strings are passed to the `gettext'
function, for possible translation into the current locale.

     /* Argp example #4 - a program with somewhat more complicated options */

     /* This program uses the same features as example 3, but has more
        options, and somewhat more structure in the -help output.  It
        also shows how you can `steal' the remainder of the input
        arguments past a certain point, for programs that accept a
        list of items.  It also shows the special argp KEY value
        ARGP_KEY_NO_ARGS, which is only given if no non-option
        arguments were supplied to the program.

        For structuring the help output, two features are used,
        *headers* which are entries in the options vector with the
        first four fields being zero, and a two part documentation
        string (in the variable DOC), which allows documentation both
        before and after the options; the two parts of DOC are
        separated by a vertical-tab character ('\v', or '\013').  By
        convention, the documentation before the options is just a
        short string saying what the program does, and that afterwards
        is longer, describing the behavior in more detail.  All
        documentation strings are automatically filled for output,
        although newlines may be included to force a line break at a
        particular point.  All documentation strings are also passed to
        the `gettext' function, for possible translation into the
        current locale. */

     #include <stdlib.h>
     #include <error.h>
     #include <argp.h>

     const char *argp_program_version =
       "argp-ex4 1.0";
     const char *argp_program_bug_address =
       "<bug-gnu-utils@prep.ai.mit.edu>";

     /* Program documentation. */
     static char doc[] =
       "Argp example #4 -- a program with somewhat more complicated\
     options\
     \vThis part of the documentation comes *after* the options;\
      note that the text is automatically filled, but it's possible\
      to force a line-break, e.g.\n<-- here.";

     /* A description of the arguments we accept. */
     static char args_doc[] = "ARG1 [STRING...]";

     /* Keys for options without short-options. */
     #define OPT_ABORT  1            /* -abort */

     /* The options we understand. */
     static struct argp_option options[] = {
       {"verbose",  'v', 0,       0, "Produce verbose output" },
       {"quiet",    'q', 0,       0, "Don't produce any output" },
       {"silent",   's', 0,       OPTION_ALIAS },
       {"output",   'o', "FILE",  0,
        "Output to FILE instead of standard output" },

       {0,0,0,0, "The following options should be grouped together:" },
       {"repeat",   'r', "COUNT", OPTION_ARG_OPTIONAL,
        "Repeat the output COUNT (default 10) times"},
       {"abort",    OPT_ABORT, 0, 0, "Abort before showing any output"},

       { 0 }
     };

     /* Used by `main' to communicate with `parse_opt'. */
     struct arguments
     {
       char *arg1;                   /* ARG1 */
       char **strings;               /* [STRING...] */
       int silent, verbose, abort;   /* `-s', `-v', `--abort' */
       char *output_file;            /* FILE arg to `--output' */
       int repeat_count;             /* COUNT arg to `--repeat' */
     };

     /* Parse a single option. */
     static error_t
     parse_opt (int key, char *arg, struct argp_state *state)
     {
       /* Get the `input' argument from `argp_parse', which we
          know is a pointer to our arguments structure. */
       struct arguments *arguments = state->input;

       switch (key)
         {
         case 'q': case 's':
           arguments->silent = 1;
           break;
         case 'v':
           arguments->verbose = 1;
           break;
         case 'o':
           arguments->output_file = arg;
           break;
         case 'r':
           arguments->repeat_count = arg ? atoi (arg) : 10;
           break;
         case OPT_ABORT:
           arguments->abort = 1;
           break;

         case ARGP_KEY_NO_ARGS:
           argp_usage (state);

         case ARGP_KEY_ARG:
           /* Here we know that `state->arg_num == 0', since we
              force argument parsing to end before any more arguments can
              get here. */
           arguments->arg1 = arg;

           /* Now we consume all the rest of the arguments.
              `state->next' is the index in `state->argv' of the
              next argument to be parsed, which is the first STRING
              we're interested in, so we can just use
              `&state->argv[state->next]' as the value for
              arguments->strings.

              _In addition_, by setting `state->next' to the end
              of the arguments, we can force argp to stop parsing here and
              return. */
           arguments->strings = &state->argv[state->next];
           state->next = state->argc;

           break;

         default:
           return ARGP_ERR_UNKNOWN;
         }
       return 0;
     }

     /* Our argp parser. */
     static struct argp argp = { options, parse_opt, args_doc, doc };

     int main (int argc, char **argv)
     {
       int i, j;
       struct arguments arguments;

       /* Default values. */
       arguments.silent = 0;
       arguments.verbose = 0;
       arguments.output_file = "-";
       arguments.repeat_count = 1;
       arguments.abort = 0;

       /* Parse our arguments; every option seen by `parse_opt' will be
          reflected in `arguments'. */
       argp_parse (&argp, argc, argv, 0, 0, &arguments);

       if (arguments.abort)
         error (10, 0, "ABORTED");

       for (i = 0; i < arguments.repeat_count; i++)
         {
           printf ("ARG1 = %s\n", arguments.arg1);
           printf ("STRINGS = ");
           for (j = 0; arguments.strings[j]; j++)
             printf (j == 0 ? "%s" : ", %s", arguments.strings[j]);
           printf ("\n");
           printf ("OUTPUT_FILE = %s\nVERBOSE = %s\nSILENT = %s\n",
                   arguments.output_file,
                   arguments.verbose ? "yes" : "no",
                   arguments.silent ? "yes" : "no");
         }

       exit (0);
     }


File: libc.info,  Node: Argp User Customization,  Prev: Argp Examples,  Up: Argp

25.3.12 Argp User Customization
-------------------------------

The formatting of argp `--help' output may be controlled to some extent
by a program's users, by setting the `ARGP_HELP_FMT' environment
variable to a comma-separated list of tokens.  Whitespace is ignored:

`dup-args'
`no-dup-args'
     These turn "duplicate-argument-mode" on or off.  In duplicate
     argument mode, if an option that accepts an argument has multiple
     names, the argument is shown for each name.  Otherwise, it is only
     shown for the first long option.  A note is subsequently printed
     so the user knows that it applies to other names as well.  The
     default is `no-dup-args', which is less consistent, but prettier.

`dup-args-note'

`no-dup-args-note'
     These will enable or disable the note informing the user of
     suppressed option argument duplication.  The default is
     `dup-args-note'.

`short-opt-col=N'
     This prints the first short option in column N.  The default is 2.

`long-opt-col=N'
     This prints the first long option in column N.  The default is 6.

`doc-opt-col=N'
     This prints `documentation options' (*note Argp Option Flags::) in
     column N.  The default is 2.

`opt-doc-col=N'
     This prints the documentation for options starting in column N.
     The default is 29.

`header-col=N'
     This will indent the group headers that document groups of options
     to column N.  The default is 1.

`usage-indent=N'
     This will indent continuation lines in `Usage:' messages to column
     N.  The default is 12.

`rmargin=N'
     This will word wrap help output at or before column N.  The default
     is 79.


File: libc.info,  Node: Suboptions,  Next: Suboptions Example,  Prev: Argp,  Up: Parsing Program Arguments

25.3.12.1 Parsing of Suboptions
...............................

Having a single level of options is sometimes not enough.  There might
be too many options which have to be available or a set of options is
closely related.

   For this case some programs use suboptions.  One of the most
prominent programs is certainly `mount'(8).  The `-o' option take one
argument which itself is a comma separated list of options.  To ease the
programming of code like this the function `getsubopt' is available.

 -- Function: int getsubopt (char **OPTIONP, const char* const *TOKENS,
          char **VALUEP)
     The OPTIONP parameter must be a pointer to a variable containing
     the address of the string to process.  When the function returns
     the reference is updated to point to the next suboption or to the
     terminating `\0' character if there is no more suboption available.

     The TOKENS parameter references an array of strings containing the
     known suboptions.  All strings must be `\0' terminated and to mark
     the end a null pointer must be stored.  When `getsubopt' finds a
     possible legal suboption it compares it with all strings available
     in the TOKENS array and returns the index in the string as the
     indicator.

     In case the suboption has an associated value introduced by a `='
     character, a pointer to the value is returned in VALUEP.  The
     string is `\0' terminated.  If no argument is available VALUEP is
     set to the null pointer.  By doing this the caller can check
     whether a necessary value is given or whether no unexpected value
     is present.

     In case the next suboption in the string is not mentioned in the
     TOKENS array the starting address of the suboption including a
     possible value is returned in VALUEP and the return value of the
     function is `-1'.


File: libc.info,  Node: Suboptions Example,  Prev: Suboptions,  Up: Parsing Program Arguments

25.3.13 Parsing of Suboptions Example
-------------------------------------

The code which might appear in the `mount'(8) program is a perfect
example of the use of `getsubopt':

     #include <stdio.h>
     #include <stdlib.h>
     #include <unistd.h>

     int do_all;
     const char *type;
     int read_size;
     int write_size;
     int read_only;

     enum
     {
       RO_OPTION = 0,
       RW_OPTION,
       READ_SIZE_OPTION,
       WRITE_SIZE_OPTION,
       THE_END
     };

     const char *mount_opts[] =
     {
       [RO_OPTION] = "ro",
       [RW_OPTION] = "rw",
       [READ_SIZE_OPTION] = "rsize",
       [WRITE_SIZE_OPTION] = "wsize",
       [THE_END] = NULL
     };

     int
     main (int argc, char *argv[])
     {
       char *subopts, *value;
       int opt;

       while ((opt = getopt (argc, argv, "at:o:")) != -1)
         switch (opt)
           {
           case 'a':
             do_all = 1;
             break;
           case 't':
             type = optarg;
             break;
           case 'o':
             subopts = optarg;
             while (*subopts != '\0')
               switch (getsubopt (&subopts, mount_opts, &value))
                 {
                 case RO_OPTION:
                   read_only = 1;
                   break;
                 case RW_OPTION:
                   read_only = 0;
                   break;
                 case READ_SIZE_OPTION:
                   if (value == NULL)
                     abort ();
                   read_size = atoi (value);
                   break;
                 case WRITE_SIZE_OPTION:
                   if (value == NULL)
                     abort ();
                   write_size = atoi (value);
                   break;
                 default:
                   /* Unknown suboption. */
                   printf ("Unknown suboption `%s'\n", value);
                   break;
                 }
             break;
           default:
             abort ();
           }

       /* Do the real work. */

       return 0;
     }


File: libc.info,  Node: Environment Variables,  Next: System Calls,  Prev: Program Arguments,  Up: Program Basics

25.4 Environment Variables
==========================

When a program is executed, it receives information about the context in
which it was invoked in two ways.  The first mechanism uses the ARGV
and ARGC arguments to its `main' function, and is discussed in *Note
Program Arguments::.  The second mechanism uses "environment variables"
and is discussed in this section.

   The ARGV mechanism is typically used to pass command-line arguments
specific to the particular program being invoked.  The environment, on
the other hand, keeps track of information that is shared by many
programs, changes infrequently, and that is less frequently used.

   The environment variables discussed in this section are the same
environment variables that you set using assignments and the `export'
command in the shell.  Programs executed from the shell inherit all of
the environment variables from the shell.

   Standard environment variables are used for information about the
user's home directory, terminal type, current locale, and so on; you
can define additional variables for other purposes.  The set of all
environment variables that have values is collectively known as the
"environment".

   Names of environment variables are case-sensitive and must not
contain the character `='.  System-defined environment variables are
invariably uppercase.

   The values of environment variables can be anything that can be
represented as a string.  A value must not contain an embedded null
character, since this is assumed to terminate the string.

* Menu:

* Environment Access::          How to get and set the values of
				 environment variables.
* Standard Environment::        These environment variables have
                		 standard interpretations.


File: libc.info,  Node: Environment Access,  Next: Standard Environment,  Up: Environment Variables

25.4.1 Environment Access
-------------------------

The value of an environment variable can be accessed with the `getenv'
function.  This is declared in the header file `stdlib.h'.
Modifications of enviroment variables are not allowed in Multi-threaded
programs.  The `getenv' function can be safely used in multi-threaded
programs 

 -- Function: char * getenv (const char *NAME)
     This function returns a string that is the value of the environment
     variable NAME.  You must not modify this string.  In some non-Unix
     systems not using the GNU library, it might be overwritten by
     subsequent calls to `getenv' (but not by any other library
     function).  If the environment variable NAME is not defined, the
     value is a null pointer.

 -- Function: int putenv (char *STRING)
     The `putenv' function adds or removes definitions from the
     environment.  If the STRING is of the form `NAME=VALUE', the
     definition is added to the environment.  Otherwise, the STRING is
     interpreted as the name of an environment variable, and any
     definition for this variable in the environment is removed.

     The difference to the `setenv' function is that the exact string
     given as the parameter STRING is put into the environment.  If the
     user should change the string after the `putenv' call this will
     reflect in automatically in the environment.  This also requires
     that STRING is no automatic variable which scope is left before the
     variable is removed from the environment.  The same applies of
     course to dynamically allocated variables which are freed later.

     This function is part of the extended Unix interface.  Since it
     was also available in old SVID libraries you should define either
     _XOPEN_SOURCE or _SVID_SOURCE before including any header.

 -- Function: int setenv (const char *NAME, const char *VALUE, int
          REPLACE)
     The `setenv' function can be used to add a new definition to the
     environment.  The entry with the name NAME is replaced by the
     value `NAME=VALUE'.  Please note that this is also true if VALUE
     is the empty string.  To do this a new string is created and the
     strings NAME and VALUE are copied.  A null pointer for the VALUE
     parameter is illegal.  If the environment already contains an
     entry with key NAME the REPLACE parameter controls the action.  If
     replace is zero, nothing happens.  Otherwise the old entry is
     replaced by the new one.

     Please note that you cannot remove an entry completely using this
     function.

     This function was originally part of the BSD library but is now
     part of the Unix standard.

 -- Function: int unsetenv (const char *NAME)
     Using this function one can remove an entry completely from the
     environment.  If the environment contains an entry with the key
     NAME this whole entry is removed.  A call to this function is
     equivalent to a call to `putenv' when the VALUE part of the string
     is empty.

     The function return `-1' if NAME is a null pointer, points to an
     empty string, or points to a string containing a `=' character.
     It returns `0' if the call succeeded.

     This function was originally part of the BSD library but is now
     part of the Unix standard.  The BSD version had no return value,
     though.

   There is one more function to modify the whole environment.  This
function is said to be used in the POSIX.9 (POSIX bindings for Fortran
77) and so one should expect it did made it into POSIX.1.  But this
never happened.  But we still provide this function as a GNU extension
to enable writing standard compliant Fortran environments.

 -- Function: int clearenv (void)
     The `clearenv' function removes all entries from the environment.
     Using `putenv' and `setenv' new entries can be added again later.

     If the function is successful it returns `0'.  Otherwise the return
     value is nonzero.

   You can deal directly with the underlying representation of
environment objects to add more variables to the environment (for
example, to communicate with another program you are about to execute;
*note Executing a File::).

 -- Variable: char ** environ
     The environment is represented as an array of strings.  Each
     string is of the format `NAME=VALUE'.  The order in which strings
     appear in the environment is not significant, but the same NAME
     must not appear more than once.  The last element of the array is
     a null pointer.

     This variable is declared in the header file `unistd.h'.

     If you just want to get the value of an environment variable, use
     `getenv'.

   Unix systems, and the GNU system, pass the initial value of
`environ' as the third argument to `main'.  *Note Program Arguments::.


File: libc.info,  Node: Standard Environment,  Prev: Environment Access,  Up: Environment Variables

25.4.2 Standard Environment Variables
-------------------------------------

These environment variables have standard meanings.  This doesn't mean
that they are always present in the environment; but if these variables
_are_ present, they have these meanings.  You shouldn't try to use
these environment variable names for some other purpose.

`HOME'
     This is a string representing the user's "home directory", or
     initial default working directory.

     The user can set `HOME' to any value.  If you need to make sure to
     obtain the proper home directory for a particular user, you should
     not use `HOME'; instead, look up the user's name in the user
     database (*note User Database::).

     For most purposes, it is better to use `HOME', precisely because
     this lets the user specify the value.

`LOGNAME'
     This is the name that the user used to log in.  Since the value in
     the environment can be tweaked arbitrarily, this is not a reliable
     way to identify the user who is running a program; a function like
     `getlogin' (*note Who Logged In::) is better for that purpose.

     For most purposes, it is better to use `LOGNAME', precisely because
     this lets the user specify the value.

`PATH'
     A "path" is a sequence of directory names which is used for
     searching for a file.  The variable `PATH' holds a path used for
     searching for programs to be run.

     The `execlp' and `execvp' functions (*note Executing a File::) use
     this environment variable, as do many shells and other utilities
     which are implemented in terms of those functions.

     The syntax of a path is a sequence of directory names separated by
     colons.  An empty string instead of a directory name stands for the
     current directory (*note Working Directory::).

     A typical value for this environment variable might be a string
     like:

          :/bin:/etc:/usr/bin:/usr/new/X11:/usr/new:/usr/local/bin

     This means that if the user tries to execute a program named `foo',
     the system will look for files named `foo', `/bin/foo',
     `/etc/foo', and so on.  The first of these files that exists is
     the one that is executed.

`TERM'
     This specifies the kind of terminal that is receiving program
     output.  Some programs can make use of this information to take
     advantage of special escape sequences or terminal modes supported
     by particular kinds of terminals.  Many programs which use the
     termcap library (*note Find: (termcap)Finding a Terminal
     Description.) use the `TERM' environment variable, for example.

`TZ'
     This specifies the time zone.  *Note TZ Variable::, for
     information about the format of this string and how it is used.

`LANG'
     This specifies the default locale to use for attribute categories
     where neither `LC_ALL' nor the specific environment variable for
     that category is set.  *Note Locales::, for more information about
     locales.

`LC_ALL'
     If this environment variable is set it overrides the selection for
     all the locales done using the other `LC_*' environment variables.
     The value of the other `LC_*' environment variables is simply
     ignored in this case.

`LC_COLLATE'
     This specifies what locale to use for string sorting.

`LC_CTYPE'
     This specifies what locale to use for character sets and character
     classification.

`LC_MESSAGES'
     This specifies what locale to use for printing messages and to
     parse responses.

`LC_MONETARY'
     This specifies what locale to use for formatting monetary values.

`LC_NUMERIC'
     This specifies what locale to use for formatting numbers.

`LC_TIME'
     This specifies what locale to use for formatting date/time values.

`NLSPATH'
     This specifies the directories in which the `catopen' function
     looks for message translation catalogs.

`_POSIX_OPTION_ORDER'
     If this environment variable is defined, it suppresses the usual
     reordering of command line arguments by `getopt' and `argp_parse'.
     *Note Argument Syntax::.



File: libc.info,  Node: System Calls,  Next: Program Termination,  Prev: Environment Variables,  Up: Program Basics

25.5 System Calls
=================

A system call is a request for service that a program makes of the
kernel.  The service is generally something that only the kernel has
the privilege to do, such as doing I/O.  Programmers don't normally
need to be concerned with system calls because there are functions in
the GNU C library to do virtually everything that system calls do.
These functions work by making system calls themselves.  For example,
there is a system call that changes the permissions of a file, but you
don't need to know about it because you can just use the GNU C
library's `chmod' function.

   System calls are sometimes called kernel calls.

   However, there are times when you want to make a system call
explicitly, and for that, the GNU C library provides the `syscall'
function.  `syscall' is harder to use and less portable than functions
like `chmod', but easier and more portable than coding the system call
in assembler instructions.

   `syscall' is most useful when you are working with a system call
which is special to your system or is newer than the GNU C library you
are using.  `syscall' is implemented in an entirely generic way; the
function does not know anything about what a particular system call
does or even if it is valid.

   The description of `syscall' in this section assumes a certain
protocol for system calls on the various platforms on which the GNU C
library runs.  That protocol is not defined by any strong authority, but
we won't describe it here either because anyone who is coding `syscall'
probably won't accept anything less than kernel and C library source
code as a specification of the interface between them anyway.

   `syscall' is declared in `unistd.h'.

 -- Function: long int syscall (long int SYSNO, ...)
     `syscall' performs a generic system call.

     SYSNO is the system call number.  Each kind of system call is
     identified by a number.  Macros for all the possible system call
     numbers are defined in `sys/syscall.h'

     The remaining arguments are the arguments for the system call, in
     order, and their meanings depend on the kind of system call.  Each
     kind of system call has a definite number of arguments, from zero
     to five.  If you code more arguments than the system call takes,
     the extra ones to the right are ignored.

     The return value is the return value from the system call, unless
     the system call failed.  In that case, `syscall' returns `-1' and
     sets `errno' to an error code that the system call returned.  Note
     that system calls do not return `-1' when they succeed.  

     If you specify an invalid SYSNO, `syscall' returns `-1' with
     `errno' = `ENOSYS'.

     Example:


          #include <unistd.h>
          #include <sys/syscall.h>
          #include <errno.h>

          ...

          int rc;

          rc = syscall(SYS_chmod, "/etc/passwd", 0444);

          if (rc == -1)
             fprintf(stderr, "chmod failed, errno = %d\n", errno);

     This, if all the compatibility stars are aligned, is equivalent to
     the following preferable code:


          #include <sys/types.h>
          #include <sys/stat.h>
          #include <errno.h>

          ...

          int rc;

          rc = chmod("/etc/passwd", 0444);
          if (rc == -1)
             fprintf(stderr, "chmod failed, errno = %d\n", errno);



File: libc.info,  Node: Program Termination,  Prev: System Calls,  Up: Program Basics

25.6 Program Termination
========================

The usual way for a program to terminate is simply for its `main'
function to return.  The "exit status value" returned from the `main'
function is used to report information back to the process's parent
process or shell.

   A program can also terminate normally by calling the `exit' function.

   In addition, programs can be terminated by signals; this is
discussed in more detail in *Note Signal Handling::.  The `abort'
function causes a signal that kills the program.

* Menu:

* Normal Termination::          If a program calls `exit', a
                                 process terminates normally.
* Exit Status::                 The `exit status' provides information
                                 about why the process terminated.
* Cleanups on Exit::            A process can run its own cleanup
                                 functions upon normal termination.
* Aborting a Program::          The `abort' function causes
                                 abnormal program termination.
* Termination Internals::       What happens when a process terminates.


File: libc.info,  Node: Normal Termination,  Next: Exit Status,  Up: Program Termination

25.6.1 Normal Termination
-------------------------

A process terminates normally when its program signals it is done by
calling `exit'.  Returning from `main' is equivalent to calling `exit',
and the value that `main' returns is used as the argument to `exit'.

 -- Function: void exit (int STATUS)
     The `exit' function tells the system that the program is done,
     which causes it to terminate the process.

     STATUS is the program's exit status, which becomes part of the
     process' termination status.  This function does not return.

   Normal termination causes the following actions:

  1. Functions that were registered with the `atexit' or `on_exit'
     functions are called in the reverse order of their registration.
     This mechanism allows your application to specify its own
     "cleanup" actions to be performed at program termination.
     Typically, this is used to do things like saving program state
     information in a file, or unlocking locks in shared data bases.

  2. All open streams are closed, writing out any buffered output data.
     See *Note Closing Streams::.  In addition, temporary files opened
     with the `tmpfile' function are removed; see *Note Temporary
     Files::.

  3. `_exit' is called, terminating the program.  *Note Termination
     Internals::.


File: libc.info,  Node: Exit Status,  Next: Cleanups on Exit,  Prev: Normal Termination,  Up: Program Termination

25.6.2 Exit Status
------------------

When a program exits, it can return to the parent process a small
amount of information about the cause of termination, using the "exit
status".  This is a value between 0 and 255 that the exiting process
passes as an argument to `exit'.

   Normally you should use the exit status to report very broad
information about success or failure.  You can't provide a lot of
detail about the reasons for the failure, and most parent processes
would not want much detail anyway.

   There are conventions for what sorts of status values certain
programs should return.  The most common convention is simply 0 for
success and 1 for failure.  Programs that perform comparison use a
different convention: they use status 1 to indicate a mismatch, and
status 2 to indicate an inability to compare.  Your program should
follow an existing convention if an existing convention makes sense for
it.

   A general convention reserves status values 128 and up for special
purposes.  In particular, the value 128 is used to indicate failure to
execute another program in a subprocess.  This convention is not
universally obeyed, but it is a good idea to follow it in your programs.

   *Warning:* Don't try to use the number of errors as the exit status.
This is actually not very useful; a parent process would generally not
care how many errors occurred.  Worse than that, it does not work,
because the status value is truncated to eight bits.  Thus, if the
program tried to report 256 errors, the parent would receive a report
of 0 errors--that is, success.

   For the same reason, it does not work to use the value of `errno' as
the exit status--these can exceed 255.

   *Portability note:* Some non-POSIX systems use different conventions
for exit status values.  For greater portability, you can use the
macros `EXIT_SUCCESS' and `EXIT_FAILURE' for the conventional status
value for success and failure, respectively.  They are declared in the
file `stdlib.h'.  

 -- Macro: int EXIT_SUCCESS
     This macro can be used with the `exit' function to indicate
     successful program completion.

     On POSIX systems, the value of this macro is `0'.  On other
     systems, the value might be some other (possibly non-constant)
     integer expression.

 -- Macro: int EXIT_FAILURE
     This macro can be used with the `exit' function to indicate
     unsuccessful program completion in a general sense.

     On POSIX systems, the value of this macro is `1'.  On other
     systems, the value might be some other (possibly non-constant)
     integer expression.  Other nonzero status values also indicate
     failures.  Certain programs use different nonzero status values to
     indicate particular kinds of "non-success".  For example, `diff'
     uses status value `1' to mean that the files are different, and
     `2' or more to mean that there was difficulty in opening the files.

   Don't confuse a program's exit status with a process' termination
status.  There are lots of ways a process can terminate besides having
it's program finish.  In the event that the process termination _is_
caused by program termination (i.e., `exit'), though, the program's
exit status becomes part of the process' termination status.


File: libc.info,  Node: Cleanups on Exit,  Next: Aborting a Program,  Prev: Exit Status,  Up: Program Termination

25.6.3 Cleanups on Exit
-----------------------

Your program can arrange to run its own cleanup functions if normal
termination happens.  If you are writing a library for use in various
application programs, then it is unreliable to insist that all
applications call the library's cleanup functions explicitly before
exiting.  It is much more robust to make the cleanup invisible to the
application, by setting up a cleanup function in the library itself
using `atexit' or `on_exit'.

 -- Function: int atexit (void (*FUNCTION) (void))
     The `atexit' function registers the function FUNCTION to be called
     at normal program termination.  The FUNCTION is called with no
     arguments.

     The return value from `atexit' is zero on success and nonzero if
     the function cannot be registered.

 -- Function: int on_exit (void (*FUNCTION)(int STATUS, void *ARG),
          void *ARG)
     This function is a somewhat more powerful variant of `atexit'.  It
     accepts two arguments, a function FUNCTION and an arbitrary
     pointer ARG.  At normal program termination, the FUNCTION is
     called with two arguments:  the STATUS value passed to `exit', and
     the ARG.

     This function is included in the GNU C library only for
     compatibility for SunOS, and may not be supported by other
     implementations.

   Here's a trivial program that illustrates the use of `exit' and
`atexit':

     #include <stdio.h>
     #include <stdlib.h>

     void
     bye (void)
     {
       puts ("Goodbye, cruel world....");
     }

     int
     main (void)
     {
       atexit (bye);
       exit (EXIT_SUCCESS);
     }

When this program is executed, it just prints the message and exits.


File: libc.info,  Node: Aborting a Program,  Next: Termination Internals,  Prev: Cleanups on Exit,  Up: Program Termination

25.6.4 Aborting a Program
-------------------------

You can abort your program using the `abort' function.  The prototype
for this function is in `stdlib.h'.  

 -- Function: void abort (void)
     The `abort' function causes abnormal program termination.  This
     does not execute cleanup functions registered with `atexit' or
     `on_exit'.

     This function actually terminates the process by raising a
     `SIGABRT' signal, and your program can include a handler to
     intercept this signal; see *Note Signal Handling::.

   *Future Change Warning:* Proposed Federal censorship regulations may
prohibit us from giving you information about the possibility of
calling this function.  We would be required to say that this is not an
acceptable way of terminating a program.


File: libc.info,  Node: Termination Internals,  Prev: Aborting a Program,  Up: Program Termination

25.6.5 Termination Internals
----------------------------

The `_exit' function is the primitive used for process termination by
`exit'.  It is declared in the header file `unistd.h'.  

 -- Function: void _exit (int STATUS)
     The `_exit' function is the primitive for causing a process to
     terminate with status STATUS.  Calling this function does not
     execute cleanup functions registered with `atexit' or `on_exit'.

 -- Function: void _Exit (int STATUS)
     The `_Exit' function is the ISO C equivalent to `_exit'.  The
     ISO C committee members were not sure whether the definitions of
     `_exit' and `_Exit' were compatible so they have not used the
     POSIX name.

     This function was introduced in ISO C99 and is declared in
     `stdlib.h'.

   When a process terminates for any reason--either because the program
terminates, or as a result of a signal--the following things happen:

   * All open file descriptors in the process are closed.  *Note
     Low-Level I/O::.  Note that streams are not flushed automatically
     when the process terminates; see *Note I/O on Streams::.

   * A process exit status is saved to be reported back to the parent
     process via `wait' or `waitpid'; see *Note Process Completion::.
     If the program exited, this status includes as its low-order 8
     bits the program exit status.

   * Any child processes of the process being terminated are assigned a
     new parent process.  (On most systems, including GNU, this is the
     `init' process, with process ID 1.)

   * A `SIGCHLD' signal is sent to the parent process.

   * If the process is a session leader that has a controlling
     terminal, then a `SIGHUP' signal is sent to each process in the
     foreground job, and the controlling terminal is disassociated from
     that session.  *Note Job Control::.

   * If termination of a process causes a process group to become
     orphaned, and any member of that process group is stopped, then a
     `SIGHUP' signal and a `SIGCONT' signal are sent to each process in
     the group.  *Note Job Control::.


File: libc.info,  Node: Processes,  Next: Job Control,  Prev: Program Basics,  Up: Top

26 Processes
************

"Processes" are the primitive units for allocation of system resources.
Each process has its own address space and (usually) one thread of
control.  A process executes a program; you can have multiple processes
executing the same program, but each process has its own copy of the
program within its own address space and executes it independently of
the other copies.

   Processes are organized hierarchically.  Each process has a "parent
process" which explicitly arranged to create it.  The processes created
by a given parent are called its "child processes".  A child inherits
many of its attributes from the parent process.

   This chapter describes how a program can create, terminate, and
control child processes.  Actually, there are three distinct operations
involved: creating a new child process, causing the new process to
execute a program, and coordinating the completion of the child process
with the original program.

   The `system' function provides a simple, portable mechanism for
running another program; it does all three steps automatically.  If you
need more control over the details of how this is done, you can use the
primitive functions to do each step individually instead.

* Menu:

* Running a Command::           The easy way to run another program.
* Process Creation Concepts::   An overview of the hard way to do it.
* Process Identification::      How to get the process ID of a process.
* Creating a Process::          How to fork a child process.
* Executing a File::            How to make a process execute another program.
* Process Completion::          How to tell when a child process has completed.
* Process Completion Status::   How to interpret the status value
                                 returned from a child process.
* BSD Wait Functions::  	More functions, for backward compatibility.
* Process Creation Example::    A complete example program.


File: libc.info,  Node: Running a Command,  Next: Process Creation Concepts,  Up: Processes

26.1 Running a Command
======================

The easy way to run another program is to use the `system' function.
This function does all the work of running a subprogram, but it doesn't
give you much control over the details: you have to wait until the
subprogram terminates before you can do anything else.

 -- Function: int system (const char *COMMAND)
     This function executes COMMAND as a shell command.  In the GNU C
     library, it always uses the default shell `sh' to run the command.
     In particular, it searches the directories in `PATH' to find
     programs to execute.  The return value is `-1' if it wasn't
     possible to create the shell process, and otherwise is the status
     of the shell process.  *Note Process Completion::, for details on
     how this status code can be interpreted.

     If the COMMAND argument is a null pointer, a return value of zero
     indicates that no command processor is available.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `system' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `system' should be protected using cancellation handlers.

     The `system' function is declared in the header file `stdlib.h'.

   *Portability Note:* Some C implementations may not have any notion
of a command processor that can execute other programs.  You can
determine whether a command processor exists by executing
`system (NULL)'; if the return value is nonzero, a command processor is
available.

   The `popen' and `pclose' functions (*note Pipe to a Subprocess::)
are closely related to the `system' function.  They allow the parent
process to communicate with the standard input and output channels of
the command being executed.


File: libc.info,  Node: Process Creation Concepts,  Next: Process Identification,  Prev: Running a Command,  Up: Processes

26.2 Process Creation Concepts
==============================

This section gives an overview of processes and of the steps involved in
creating a process and making it run another program.

   Each process is named by a "process ID" number.  A unique process ID
is allocated to each process when it is created.  The "lifetime" of a
process ends when its termination is reported to its parent process; at
that time, all of the process resources, including its process ID, are
freed.

   Processes are created with the `fork' system call (so the operation
of creating a new process is sometimes called "forking" a process).
The "child process" created by `fork' is a copy of the original "parent
process", except that it has its own process ID.

   After forking a child process, both the parent and child processes
continue to execute normally.  If you want your program to wait for a
child process to finish executing before continuing, you must do this
explicitly after the fork operation, by calling `wait' or `waitpid'
(*note Process Completion::).  These functions give you limited
information about why the child terminated--for example, its exit
status code.

   A newly forked child process continues to execute the same program as
its parent process, at the point where the `fork' call returns.  You
can use the return value from `fork' to tell whether the program is
running in the parent process or the child.

   Having several processes run the same program is only occasionally
useful.  But the child can execute another program using one of the
`exec' functions; see *Note Executing a File::.  The program that the
process is executing is called its "process image".  Starting execution
of a new program causes the process to forget all about its previous
process image; when the new program exits, the process exits too,
instead of returning to the previous process image.


File: libc.info,  Node: Process Identification,  Next: Creating a Process,  Prev: Process Creation Concepts,  Up: Processes

26.3 Process Identification
===========================

The `pid_t' data type represents process IDs.  You can get the process
ID of a process by calling `getpid'.  The function `getppid' returns
the process ID of the parent of the current process (this is also known
as the "parent process ID").  Your program should include the header
files `unistd.h' and `sys/types.h' to use these functions.  

 -- Data Type: pid_t
     The `pid_t' data type is a signed integer type which is capable of
     representing a process ID.  In the GNU library, this is an `int'.

 -- Function: pid_t getpid (void)
     The `getpid' function returns the process ID of the current
     process.

 -- Function: pid_t getppid (void)
     The `getppid' function returns the process ID of the parent of the
     current process.


File: libc.info,  Node: Creating a Process,  Next: Executing a File,  Prev: Process Identification,  Up: Processes

26.4 Creating a Process
=======================

The `fork' function is the primitive for creating a process.  It is
declared in the header file `unistd.h'.  

 -- Function: pid_t fork (void)
     The `fork' function creates a new process.

     If the operation is successful, there are then both parent and
     child processes and both see `fork' return, but with different
     values: it returns a value of `0' in the child process and returns
     the child's process ID in the parent process.

     If process creation failed, `fork' returns a value of `-1' in the
     parent process.  The following `errno' error conditions are
     defined for `fork':

    `EAGAIN'
          There aren't enough system resources to create another
          process, or the user already has too many processes running.
          This means exceeding the `RLIMIT_NPROC' resource limit, which
          can usually be increased; *note Limits on Resources::.

    `ENOMEM'
          The process requires more space than the system can supply.

   The specific attributes of the child process that differ from the
parent process are:

   * The child process has its own unique process ID.

   * The parent process ID of the child process is the process ID of its
     parent process.

   * The child process gets its own copies of the parent process's open
     file descriptors.  Subsequently changing attributes of the file
     descriptors in the parent process won't affect the file
     descriptors in the child, and vice versa.  *Note Control
     Operations::.  However, the file position associated with each
     descriptor is shared by both processes; *note File Position::.

   * The elapsed processor times for the child process are set to zero;
     see *Note Processor Time::.

   * The child doesn't inherit file locks set by the parent process.
     *Note Control Operations::.

   * The child doesn't inherit alarms set by the parent process.  *Note
     Setting an Alarm::.

   * The set of pending signals (*note Delivery of Signal::) for the
     child process is cleared.  (The child process inherits its mask of
     blocked signals and signal actions from the parent process.)

 -- Function: pid_t vfork (void)
     The `vfork' function is similar to `fork' but on some systems it
     is more efficient; however, there are restrictions you must follow
     to use it safely.

     While `fork' makes a complete copy of the calling process's address
     space and allows both the parent and child to execute
     independently, `vfork' does not make this copy.  Instead, the
     child process created with `vfork' shares its parent's address
     space until it calls `_exit' or one of the `exec' functions.  In
     the meantime, the parent process suspends execution.

     You must be very careful not to allow the child process created
     with `vfork' to modify any global data or even local variables
     shared with the parent.  Furthermore, the child process cannot
     return from (or do a long jump out of) the function that called
     `vfork'!  This would leave the parent process's control
     information very confused.  If in doubt, use `fork' instead.

     Some operating systems don't really implement `vfork'.  The GNU C
     library permits you to use `vfork' on all systems, but actually
     executes `fork' if `vfork' isn't available.  If you follow the
     proper precautions for using `vfork', your program will still work
     even if the system uses `fork' instead.


File: libc.info,  Node: Executing a File,  Next: Process Completion,  Prev: Creating a Process,  Up: Processes

26.5 Executing a File
=====================

This section describes the `exec' family of functions, for executing a
file as a process image.  You can use these functions to make a child
process execute a new program after it has been forked.

   To see the effects of `exec' from the point of view of the called
program, see *Note Program Basics::.

   The functions in this family differ in how you specify the arguments,
but otherwise they all do the same thing.  They are declared in the
header file `unistd.h'.

 -- Function: int execv (const char *FILENAME, char *const ARGV[])
     The `execv' function executes the file named by FILENAME as a new
     process image.

     The ARGV argument is an array of null-terminated strings that is
     used to provide a value for the `argv' argument to the `main'
     function of the program to be executed.  The last element of this
     array must be a null pointer.  By convention, the first element of
     this array is the file name of the program sans directory names.
     *Note Program Arguments::, for full details on how programs can
     access these arguments.

     The environment for the new process image is taken from the
     `environ' variable of the current process image; see *Note
     Environment Variables::, for information about environments.

 -- Function: int execl (const char *FILENAME, const char *ARG0, ...)
     This is similar to `execv', but the ARGV strings are specified
     individually instead of as an array.  A null pointer must be
     passed as the last such argument.

 -- Function: int execve (const char *FILENAME, char *const ARGV[],
          char *const ENV[])
     This is similar to `execv', but permits you to specify the
     environment for the new program explicitly as the ENV argument.
     This should be an array of strings in the same format as for the
     `environ' variable; see *Note Environment Access::.

 -- Function: int execle (const char *FILENAME, const char *ARG0, char
          *const ENV[], ...)
     This is similar to `execl', but permits you to specify the
     environment for the new program explicitly.  The environment
     argument is passed following the null pointer that marks the last
     ARGV argument, and should be an array of strings in the same
     format as for the `environ' variable.

 -- Function: int execvp (const char *FILENAME, char *const ARGV[])
     The `execvp' function is similar to `execv', except that it
     searches the directories listed in the `PATH' environment variable
     (*note Standard Environment::) to find the full file name of a
     file from FILENAME if FILENAME does not contain a slash.

     This function is useful for executing system utility programs,
     because it looks for them in the places that the user has chosen.
     Shells use it to run the commands that users type.

 -- Function: int execlp (const char *FILENAME, const char *ARG0, ...)
     This function is like `execl', except that it performs the same
     file name searching as the `execvp' function.

   The size of the argument list and environment list taken together
must not be greater than `ARG_MAX' bytes.  *Note General Limits::.  In
the GNU system, the size (which compares against `ARG_MAX') includes,
for each string, the number of characters in the string, plus the size
of a `char *', plus one, rounded up to a multiple of the size of a
`char *'.  Other systems may have somewhat different rules for counting.

   These functions normally don't return, since execution of a new
program causes the currently executing program to go away completely.
A value of `-1' is returned in the event of a failure.  In addition to
the usual file name errors (*note File Name Errors::), the following
`errno' error conditions are defined for these functions:

`E2BIG'
     The combined size of the new program's argument list and
     environment list is larger than `ARG_MAX' bytes.  The GNU system
     has no specific limit on the argument list size, so this error
     code cannot result, but you may get `ENOMEM' instead if the
     arguments are too big for available memory.

`ENOEXEC'
     The specified file can't be executed because it isn't in the right
     format.

`ENOMEM'
     Executing the specified file requires more storage than is
     available.

   If execution of the new file succeeds, it updates the access time
field of the file as if the file had been read.  *Note File Times::,
for more details about access times of files.

   The point at which the file is closed again is not specified, but is
at some point before the process exits or before another process image
is executed.

   Executing a new process image completely changes the contents of
memory, copying only the argument and environment strings to new
locations.  But many other attributes of the process are unchanged:

   * The process ID and the parent process ID.  *Note Process Creation
     Concepts::.

   * Session and process group membership.  *Note Concepts of Job
     Control::.

   * Real user ID and group ID, and supplementary group IDs.  *Note
     Process Persona::.

   * Pending alarms.  *Note Setting an Alarm::.

   * Current working directory and root directory.  *Note Working
     Directory::.  In the GNU system, the root directory is not copied
     when executing a setuid program; instead the system default root
     directory is used for the new program.

   * File mode creation mask.  *Note Setting Permissions::.

   * Process signal mask; see *Note Process Signal Mask::.

   * Pending signals; see *Note Blocking Signals::.

   * Elapsed processor time associated with the process; see *Note
     Processor Time::.

   If the set-user-ID and set-group-ID mode bits of the process image
file are set, this affects the effective user ID and effective group ID
(respectively) of the process.  These concepts are discussed in detail
in *Note Process Persona::.

   Signals that are set to be ignored in the existing process image are
also set to be ignored in the new process image.  All other signals are
set to the default action in the new process image.  For more
information about signals, see *Note Signal Handling::.

   File descriptors open in the existing process image remain open in
the new process image, unless they have the `FD_CLOEXEC'
(close-on-exec) flag set.  The files that remain open inherit all
attributes of the open file description from the existing process image,
including file locks.  File descriptors are discussed in *Note
Low-Level I/O::.

   Streams, by contrast, cannot survive through `exec' functions,
because they are located in the memory of the process itself.  The new
process image has no streams except those it creates afresh.  Each of
the streams in the pre-`exec' process image has a descriptor inside it,
and these descriptors do survive through `exec' (provided that they do
not have `FD_CLOEXEC' set).  The new process image can reconnect these
to new streams using `fdopen' (*note Descriptors and Streams::).


File: libc.info,  Node: Process Completion,  Next: Process Completion Status,  Prev: Executing a File,  Up: Processes

26.6 Process Completion
=======================

The functions described in this section are used to wait for a child
process to terminate or stop, and determine its status.  These functions
are declared in the header file `sys/wait.h'.  

 -- Function: pid_t waitpid (pid_t PID, int *STATUS-PTR, int OPTIONS)
     The `waitpid' function is used to request status information from a
     child process whose process ID is PID.  Normally, the calling
     process is suspended until the child process makes status
     information available by terminating.

     Other values for the PID argument have special interpretations.  A
     value of `-1' or `WAIT_ANY' requests status information for any
     child process; a value of `0' or `WAIT_MYPGRP' requests
     information for any child process in the same process group as the
     calling process; and any other negative value - PGID requests
     information for any child process whose process group ID is PGID.

     If status information for a child process is available
     immediately, this function returns immediately without waiting.
     If more than one eligible child process has status information
     available, one of them is chosen randomly, and its status is
     returned immediately.  To get the status from the other eligible
     child processes, you need to call `waitpid' again.

     The OPTIONS argument is a bit mask.  Its value should be the
     bitwise OR (that is, the `|' operator) of zero or more of the
     `WNOHANG' and `WUNTRACED' flags.  You can use the `WNOHANG' flag
     to indicate that the parent process shouldn't wait; and the
     `WUNTRACED' flag to request status information from stopped
     processes as well as processes that have terminated.

     The status information from the child process is stored in the
     object that STATUS-PTR points to, unless STATUS-PTR is a null
     pointer.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `waitpid' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `waitpid' should be protected using cancellation handlers.

     The return value is normally the process ID of the child process
     whose status is reported.  If there are child processes but none
     of them is waiting to be noticed, `waitpid' will block until one
     is.  However, if the `WNOHANG' option was specified, `waitpid'
     will return zero instead of blocking.

     If a specific PID to wait for was given to `waitpid', it will
     ignore all other children (if any).  Therefore if there are
     children waiting to be noticed but the child whose PID was
     specified is not one of them, `waitpid' will block or return zero
     as described above.

     A value of `-1' is returned in case of error.  The following
     `errno' error conditions are defined for this function:

    `EINTR'
          The function was interrupted by delivery of a signal to the
          calling process.  *Note Interrupted Primitives::.

    `ECHILD'
          There are no child processes to wait for, or the specified PID
          is not a child of the calling process.

    `EINVAL'
          An invalid value was provided for the OPTIONS argument.

   These symbolic constants are defined as values for the PID argument
to the `waitpid' function.

`WAIT_ANY'
     This constant macro (whose value is `-1') specifies that `waitpid'
     should return status information about any child process.

`WAIT_MYPGRP'
     This constant (with value `0') specifies that `waitpid' should
     return status information about any child process in the same
     process group as the calling process.

   These symbolic constants are defined as flags for the OPTIONS
argument to the `waitpid' function.  You can bitwise-OR the flags
together to obtain a value to use as the argument.

`WNOHANG'
     This flag specifies that `waitpid' should return immediately
     instead of waiting, if there is no child process ready to be
     noticed.

`WUNTRACED'
     This flag specifies that `waitpid' should report the status of any
     child processes that have been stopped as well as those that have
     terminated.

 -- Function: pid_t wait (int *STATUS-PTR)
     This is a simplified version of `waitpid', and is used to wait
     until any one child process terminates.  The call:

          wait (&status)

     is exactly equivalent to:

          waitpid (-1, &status, 0)

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `wait' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `wait' should be protected using cancellation handlers.

 -- Function: pid_t wait4 (pid_t PID, int *STATUS-PTR, int OPTIONS,
          struct rusage *USAGE)
     If USAGE is a null pointer, `wait4' is equivalent to `waitpid
     (PID, STATUS-PTR, OPTIONS)'.

     If USAGE is not null, `wait4' stores usage figures for the child
     process in `*RUSAGE' (but only if the child has terminated, not if
     it has stopped).  *Note Resource Usage::.

     This function is a BSD extension.

   Here's an example of how to use `waitpid' to get the status from all
child processes that have terminated, without ever waiting.  This
function is designed to be a handler for `SIGCHLD', the signal that
indicates that at least one child process has terminated.

     void
     sigchld_handler (int signum)
     {
       int pid, status, serrno;
       serrno = errno;
       while (1)
         {
           pid = waitpid (WAIT_ANY, &status, WNOHANG);
           if (pid < 0)
             {
               perror ("waitpid");
               break;
             }
           if (pid == 0)
             break;
           notice_termination (pid, status);
         }
       errno = serrno;
     }


File: libc.info,  Node: Process Completion Status,  Next: BSD Wait Functions,  Prev: Process Completion,  Up: Processes

26.7 Process Completion Status
==============================

If the exit status value (*note Program Termination::) of the child
process is zero, then the status value reported by `waitpid' or `wait'
is also zero.  You can test for other kinds of information encoded in
the returned status value using the following macros.  These macros are
defined in the header file `sys/wait.h'.  

 -- Macro: int WIFEXITED (int STATUS)
     This macro returns a nonzero value if the child process terminated
     normally with `exit' or `_exit'.

 -- Macro: int WEXITSTATUS (int STATUS)
     If `WIFEXITED' is true of STATUS, this macro returns the low-order
     8 bits of the exit status value from the child process.  *Note
     Exit Status::.

 -- Macro: int WIFSIGNALED (int STATUS)
     This macro returns a nonzero value if the child process terminated
     because it received a signal that was not handled.  *Note Signal
     Handling::.

 -- Macro: int WTERMSIG (int STATUS)
     If `WIFSIGNALED' is true of STATUS, this macro returns the signal
     number of the signal that terminated the child process.

 -- Macro: int WCOREDUMP (int STATUS)
     This macro returns a nonzero value if the child process terminated
     and produced a core dump.

 -- Macro: int WIFSTOPPED (int STATUS)
     This macro returns a nonzero value if the child process is stopped.

 -- Macro: int WSTOPSIG (int STATUS)
     If `WIFSTOPPED' is true of STATUS, this macro returns the signal
     number of the signal that caused the child process to stop.


File: libc.info,  Node: BSD Wait Functions,  Next: Process Creation Example,  Prev: Process Completion Status,  Up: Processes

26.8 BSD Process Wait Functions
===============================

The GNU library also provides these related facilities for compatibility
with BSD Unix.  BSD uses the `union wait' data type to represent status
values rather than an `int'.  The two representations are actually
interchangeable; they describe the same bit patterns.  The GNU C
Library defines macros such as `WEXITSTATUS' so that they will work on
either kind of object, and the `wait' function is defined to accept
either type of pointer as its STATUS-PTR argument.

   These functions are declared in `sys/wait.h'.  

 -- Data Type: union wait
     This data type represents program termination status values.  It
     has the following members:

    `int w_termsig'
          The value of this member is the same as that of the
          `WTERMSIG' macro.

    `int w_coredump'
          The value of this member is the same as that of the
          `WCOREDUMP' macro.

    `int w_retcode'
          The value of this member is the same as that of the
          `WEXITSTATUS' macro.

    `int w_stopsig'
          The value of this member is the same as that of the
          `WSTOPSIG' macro.

     Instead of accessing these members directly, you should use the
     equivalent macros.

   The `wait3' function is the predecessor to `wait4', which is more
flexible.  `wait3' is now obsolete.

 -- Function: pid_t wait3 (union wait *STATUS-PTR, int OPTIONS, struct
          rusage *USAGE)
     If USAGE is a null pointer, `wait3' is equivalent to `waitpid (-1,
     STATUS-PTR, OPTIONS)'.

     If USAGE is not null, `wait3' stores usage figures for the child
     process in `*RUSAGE' (but only if the child has terminated, not if
     it has stopped).  *Note Resource Usage::.


File: libc.info,  Node: Process Creation Example,  Prev: BSD Wait Functions,  Up: Processes

26.9 Process Creation Example
=============================

Here is an example program showing how you might write a function
similar to the built-in `system'.  It executes its COMMAND argument
using the equivalent of `sh -c COMMAND'.

     #include <stddef.h>
     #include <stdlib.h>
     #include <unistd.h>
     #include <sys/types.h>
     #include <sys/wait.h>

     /* Execute the command using this shell program.  */
     #define SHELL "/bin/sh"

     int
     my_system (const char *command)
     {
       int status;
       pid_t pid;

       pid = fork ();
       if (pid == 0)
         {
           /* This is the child process.  Execute the shell command. */
           execl (SHELL, SHELL, "-c", command, NULL);
           _exit (EXIT_FAILURE);
         }
       else if (pid < 0)
         /* The fork failed.  Report failure.  */
         status = -1;
       else
         /* This is the parent process.  Wait for the child to complete.  */
         if (waitpid (pid, &status, 0) != pid)
           status = -1;
       return status;
     }

   There are a couple of things you should pay attention to in this
example.

   Remember that the first `argv' argument supplied to the program
represents the name of the program being executed.  That is why, in the
call to `execl', `SHELL' is supplied once to name the program to
execute and a second time to supply a value for `argv[0]'.

   The `execl' call in the child process doesn't return if it is
successful.  If it fails, you must do something to make the child
process terminate.  Just returning a bad status code with `return'
would leave two processes running the original program.  Instead, the
right behavior is for the child process to report failure to its parent
process.

   Call `_exit' to accomplish this.  The reason for using `_exit'
instead of `exit' is to avoid flushing fully buffered streams such as
`stdout'.  The buffers of these streams probably contain data that was
copied from the parent process by the `fork', data that will be output
eventually by the parent process.  Calling `exit' in the child would
output the data twice.  *Note Termination Internals::.


File: libc.info,  Node: Job Control,  Next: Name Service Switch,  Prev: Processes,  Up: Top

27 Job Control
**************

"Job control" refers to the protocol for allowing a user to move
between multiple "process groups" (or "jobs") within a single "login
session".  The job control facilities are set up so that appropriate
behavior for most programs happens automatically and they need not do
anything special about job control.  So you can probably ignore the
material in this chapter unless you are writing a shell or login
program.

   You need to be familiar with concepts relating to process creation
(*note Process Creation Concepts::) and signal handling (*note Signal
Handling::) in order to understand this material presented in this
chapter.

* Menu:

* Concepts of Job Control::     Jobs can be controlled by a shell.
* Job Control is Optional::     Not all POSIX systems support job control.
* Controlling Terminal::        How a process gets its controlling terminal.
* Access to the Terminal::      How processes share the controlling terminal.
* Orphaned Process Groups::     Jobs left after the user logs out.
* Implementing a Shell::        What a shell must do to implement job control.
* Functions for Job Control::   Functions to control process groups.


File: libc.info,  Node: Concepts of Job Control,  Next: Job Control is Optional,  Up: Job Control

27.1 Concepts of Job Control
============================

The fundamental purpose of an interactive shell is to read commands
from the user's terminal and create processes to execute the programs
specified by those commands.  It can do this using the `fork' (*note
Creating a Process::) and `exec' (*note Executing a File::) functions.

   A single command may run just one process--but often one command uses
several processes.  If you use the `|' operator in a shell command, you
explicitly request several programs in their own processes.  But even
if you run just one program, it can use multiple processes internally.
For example, a single compilation command such as `cc -c foo.c'
typically uses four processes (though normally only two at any given
time).  If you run `make', its job is to run other programs in separate
processes.

   The processes belonging to a single command are called a "process
group" or "job".  This is so that you can operate on all of them at
once.  For example, typing `C-c' sends the signal `SIGINT' to terminate
all the processes in the foreground process group.

   A "session" is a larger group of processes.  Normally all the
processes that stem from a single login belong to the same session.

   Every process belongs to a process group.  When a process is
created, it becomes a member of the same process group and session as
its parent process.  You can put it in another process group using the
`setpgid' function, provided the process group belongs to the same
session.

   The only way to put a process in a different session is to make it
the initial process of a new session, or a "session leader", using the
`setsid' function.  This also puts the session leader into a new
process group, and you can't move it out of that process group again.

   Usually, new sessions are created by the system login program, and
the session leader is the process running the user's login shell.

   A shell that supports job control must arrange to control which job
can use the terminal at any time.  Otherwise there might be multiple
jobs trying to read from the terminal at once, and confusion about which
process should receive the input typed by the user.  To prevent this,
the shell must cooperate with the terminal driver using the protocol
described in this chapter.

   The shell can give unlimited access to the controlling terminal to
only one process group at a time.  This is called the "foreground job"
on that controlling terminal.  Other process groups managed by the shell
that are executing without such access to the terminal are called
"background jobs".

   If a background job needs to read from its controlling terminal, it
is "stopped" by the terminal driver; if the `TOSTOP' mode is set,
likewise for writing.  The user can stop a foreground job by typing the
SUSP character (*note Special Characters::) and a program can stop any
job by sending it a `SIGSTOP' signal.  It's the responsibility of the
shell to notice when jobs stop, to notify the user about them, and to
provide mechanisms for allowing the user to interactively continue
stopped jobs and switch jobs between foreground and background.

   *Note Access to the Terminal::, for more information about I/O to the
controlling terminal,


File: libc.info,  Node: Job Control is Optional,  Next: Controlling Terminal,  Prev: Concepts of Job Control,  Up: Job Control

27.2 Job Control is Optional
============================

Not all operating systems support job control.  The GNU system does
support job control, but if you are using the GNU library on some other
system, that system may not support job control itself.

   You can use the `_POSIX_JOB_CONTROL' macro to test at compile-time
whether the system supports job control.  *Note System Options::.

   If job control is not supported, then there can be only one process
group per session, which behaves as if it were always in the foreground.
The functions for creating additional process groups simply fail with
the error code `ENOSYS'.

   The macros naming the various job control signals (*note Job Control
Signals::) are defined even if job control is not supported.  However,
the system never generates these signals, and attempts to send a job
control signal or examine or specify their actions report errors or do
nothing.


File: libc.info,  Node: Controlling Terminal,  Next: Access to the Terminal,  Prev: Job Control is Optional,  Up: Job Control

27.3 Controlling Terminal of a Process
======================================

One of the attributes of a process is its controlling terminal.  Child
processes created with `fork' inherit the controlling terminal from
their parent process.  In this way, all the processes in a session
inherit the controlling terminal from the session leader.  A session
leader that has control of a terminal is called the "controlling
process" of that terminal.

   You generally do not need to worry about the exact mechanism used to
allocate a controlling terminal to a session, since it is done for you
by the system when you log in.

   An individual process disconnects from its controlling terminal when
it calls `setsid' to become the leader of a new session.  *Note Process
Group Functions::.


File: libc.info,  Node: Access to the Terminal,  Next: Orphaned Process Groups,  Prev: Controlling Terminal,  Up: Job Control

27.4 Access to the Controlling Terminal
=======================================

Processes in the foreground job of a controlling terminal have
unrestricted access to that terminal; background processes do not.  This
section describes in more detail what happens when a process in a
background job tries to access its controlling terminal.

   When a process in a background job tries to read from its controlling
terminal, the process group is usually sent a `SIGTTIN' signal.  This
normally causes all of the processes in that group to stop (unless they
handle the signal and don't stop themselves).  However, if the reading
process is ignoring or blocking this signal, then `read' fails with an
`EIO' error instead.

   Similarly, when a process in a background job tries to write to its
controlling terminal, the default behavior is to send a `SIGTTOU'
signal to the process group.  However, the behavior is modified by the
`TOSTOP' bit of the local modes flags (*note Local Modes::).  If this
bit is not set (which is the default), then writing to the controlling
terminal is always permitted without sending a signal.  Writing is also
permitted if the `SIGTTOU' signal is being ignored or blocked by the
writing process.

   Most other terminal operations that a program can do are treated as
reading or as writing.  (The description of each operation should say
which.)

   For more information about the primitive `read' and `write'
functions, see *Note I/O Primitives::.


File: libc.info,  Node: Orphaned Process Groups,  Next: Implementing a Shell,  Prev: Access to the Terminal,  Up: Job Control

27.5 Orphaned Process Groups
============================

When a controlling process terminates, its terminal becomes free and a
new session can be established on it.  (In fact, another user could log
in on the terminal.)  This could cause a problem if any processes from
the old session are still trying to use that terminal.

   To prevent problems, process groups that continue running even after
the session leader has terminated are marked as "orphaned process
groups".

   When a process group becomes an orphan, its processes are sent a
`SIGHUP' signal.  Ordinarily, this causes the processes to terminate.
However, if a program ignores this signal or establishes a handler for
it (*note Signal Handling::), it can continue running as in the orphan
process group even after its controlling process terminates; but it
still cannot access the terminal any more.


File: libc.info,  Node: Implementing a Shell,  Next: Functions for Job Control,  Prev: Orphaned Process Groups,  Up: Job Control

27.6 Implementing a Job Control Shell
=====================================

This section describes what a shell must do to implement job control, by
presenting an extensive sample program to illustrate the concepts
involved.

* Menu:

* Data Structures::             Introduction to the sample shell.
* Initializing the Shell::      What the shell must do to take
				 responsibility for job control.
* Launching Jobs::              Creating jobs to execute commands.
* Foreground and Background::   Putting a job in foreground of background.
* Stopped and Terminated Jobs::  Reporting job status.
* Continuing Stopped Jobs::     How to continue a stopped job in
				 the foreground or background.
* Missing Pieces::              Other parts of the shell.


File: libc.info,  Node: Data Structures,  Next: Initializing the Shell,  Up: Implementing a Shell

27.6.1 Data Structures for the Shell
------------------------------------

All of the program examples included in this chapter are part of a
simple shell program.  This section presents data structures and
utility functions which are used throughout the example.

   The sample shell deals mainly with two data structures.  The `job'
type contains information about a job, which is a set of subprocesses
linked together with pipes.  The `process' type holds information about
a single subprocess.  Here are the relevant data structure declarations:

     /* A process is a single process.  */
     typedef struct process
     {
       struct process *next;       /* next process in pipeline */
       char **argv;                /* for exec */
       pid_t pid;                  /* process ID */
       char completed;             /* true if process has completed */
       char stopped;               /* true if process has stopped */
       int status;                 /* reported status value */
     } process;

     /* A job is a pipeline of processes.  */
     typedef struct job
     {
       struct job *next;           /* next active job */
       char *command;              /* command line, used for messages */
       process *first_process;     /* list of processes in this job */
       pid_t pgid;                 /* process group ID */
       char notified;              /* true if user told about stopped job */
       struct termios tmodes;      /* saved terminal modes */
       int stdin, stdout, stderr;  /* standard i/o channels */
     } job;

     /* The active jobs are linked into a list.  This is its head.   */
     job *first_job = NULL;

   Here are some utility functions that are used for operating on `job'
objects.

     /* Find the active job with the indicated PGID.  */
     job *
     find_job (pid_t pgid)
     {
       job *j;

       for (j = first_job; j; j = j->next)
         if (j->pgid == pgid)
           return j;
       return NULL;
     }

     /* Return true if all processes in the job have stopped or completed.  */
     int
     job_is_stopped (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed && !p->stopped)
           return 0;
       return 1;
     }

     /* Return true if all processes in the job have completed.  */
     int
     job_is_completed (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed)
           return 0;
       return 1;
     }


File: libc.info,  Node: Initializing the Shell,  Next: Launching Jobs,  Prev: Data Structures,  Up: Implementing a Shell

27.6.2 Initializing the Shell
-----------------------------

When a shell program that normally performs job control is started, it
has to be careful in case it has been invoked from another shell that is
already doing its own job control.

   A subshell that runs interactively has to ensure that it has been
placed in the foreground by its parent shell before it can enable job
control itself.  It does this by getting its initial process group ID
with the `getpgrp' function, and comparing it to the process group ID
of the current foreground job associated with its controlling terminal
(which can be retrieved using the `tcgetpgrp' function).

   If the subshell is not running as a foreground job, it must stop
itself by sending a `SIGTTIN' signal to its own process group.  It may
not arbitrarily put itself into the foreground; it must wait for the
user to tell the parent shell to do this.  If the subshell is continued
again, it should repeat the check and stop itself again if it is still
not in the foreground.

   Once the subshell has been placed into the foreground by its parent
shell, it can enable its own job control.  It does this by calling
`setpgid' to put itself into its own process group, and then calling
`tcsetpgrp' to place this process group into the foreground.

   When a shell enables job control, it should set itself to ignore all
the job control stop signals so that it doesn't accidentally stop
itself.  You can do this by setting the action for all the stop signals
to `SIG_IGN'.

   A subshell that runs non-interactively cannot and should not support
job control.  It must leave all processes it creates in the same process
group as the shell itself; this allows the non-interactive shell and its
child processes to be treated as a single job by the parent shell.  This
is easy to do--just don't use any of the job control primitives--but
you must remember to make the shell do it.

   Here is the initialization code for the sample shell that shows how
to do all of this.

     /* Keep track of attributes of the shell.  */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Make sure the shell is running interactively as the foreground job
        before proceeding. */

     void
     init_shell ()
     {

       /* See if we are running interactively.  */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Loop until we are in the foreground.  */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Ignore interactive and job-control signals.  */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Put ourselves in our own process group.  */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Grab control of the terminal.  */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Save default terminal attributes for shell.  */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }


File: libc.info,  Node: Launching Jobs,  Next: Foreground and Background,  Prev: Initializing the Shell,  Up: Implementing a Shell

27.6.3 Launching Jobs
---------------------

Once the shell has taken responsibility for performing job control on
its controlling terminal, it can launch jobs in response to commands
typed by the user.

   To create the processes in a process group, you use the same `fork'
and `exec' functions described in *Note Process Creation Concepts::.
Since there are multiple child processes involved, though, things are a
little more complicated and you must be careful to do things in the
right order.  Otherwise, nasty race conditions can result.

   You have two choices for how to structure the tree of parent-child
relationships among the processes.  You can either make all the
processes in the process group be children of the shell process, or you
can make one process in group be the ancestor of all the other processes
in that group.  The sample shell program presented in this chapter uses
the first approach because it makes bookkeeping somewhat simpler.

   As each process is forked, it should put itself in the new process
group by calling `setpgid'; see *Note Process Group Functions::.  The
first process in the new group becomes its "process group leader", and
its process ID becomes the "process group ID" for the group.

   The shell should also call `setpgid' to put each of its child
processes into the new process group.  This is because there is a
potential timing problem: each child process must be put in the process
group before it begins executing a new program, and the shell depends on
having all the child processes in the group before it continues
executing.  If both the child processes and the shell call `setpgid',
this ensures that the right things happen no matter which process gets
to it first.

   If the job is being launched as a foreground job, the new process
group also needs to be put into the foreground on the controlling
terminal using `tcsetpgrp'.  Again, this should be done by the shell as
well as by each of its child processes, to avoid race conditions.

   The next thing each child process should do is to reset its signal
actions.

   During initialization, the shell process set itself to ignore job
control signals; see *Note Initializing the Shell::.  As a result, any
child processes it creates also ignore these signals by inheritance.
This is definitely undesirable, so each child process should explicitly
set the actions for these signals back to `SIG_DFL' just after it is
forked.

   Since shells follow this convention, applications can assume that
they inherit the correct handling of these signals from the parent
process.  But every application has a responsibility not to mess up the
handling of stop signals.  Applications that disable the normal
interpretation of the SUSP character should provide some other
mechanism for the user to stop the job.  When the user invokes this
mechanism, the program should send a `SIGTSTP' signal to the process
group of the process, not just to the process itself.  *Note Signaling
Another Process::.

   Finally, each child process should call `exec' in the normal way.
This is also the point at which redirection of the standard input and
output channels should be handled.  *Note Duplicating Descriptors::,
for an explanation of how to do this.

   Here is the function from the sample shell program that is
responsible for launching a program.  The function is executed by each
child process immediately after it has been forked by the shell, and
never returns.

     void
     launch_process (process *p, pid_t pgid,
                     int infile, int outfile, int errfile,
                     int foreground)
     {
       pid_t pid;

       if (shell_is_interactive)
         {
           /* Put the process into the process group and give the process group
              the terminal, if appropriate.
              This has to be done both by the shell and in the individual
              child processes because of potential race conditions.  */
           pid = getpid ();
           if (pgid == 0) pgid = pid;
           setpgid (pid, pgid);
           if (foreground)
             tcsetpgrp (shell_terminal, pgid);

           /* Set the handling for job control signals back to the default.  */
           signal (SIGINT, SIG_DFL);
           signal (SIGQUIT, SIG_DFL);
           signal (SIGTSTP, SIG_DFL);
           signal (SIGTTIN, SIG_DFL);
           signal (SIGTTOU, SIG_DFL);
           signal (SIGCHLD, SIG_DFL);
         }

       /* Set the standard input/output channels of the new process.  */
       if (infile != STDIN_FILENO)
         {
           dup2 (infile, STDIN_FILENO);
           close (infile);
         }
       if (outfile != STDOUT_FILENO)
         {
           dup2 (outfile, STDOUT_FILENO);
           close (outfile);
         }
       if (errfile != STDERR_FILENO)
         {
           dup2 (errfile, STDERR_FILENO);
           close (errfile);
         }

       /* Exec the new process.  Make sure we exit.  */
       execvp (p->argv[0], p->argv);
       perror ("execvp");
       exit (1);
     }

   If the shell is not running interactively, this function does not do
anything with process groups or signals.  Remember that a shell not
performing job control must keep all of its subprocesses in the same
process group as the shell itself.

   Next, here is the function that actually launches a complete job.
After creating the child processes, this function calls some other
functions to put the newly created job into the foreground or
background; these are discussed in *Note Foreground and Background::.

     void
     launch_job (job *j, int foreground)
     {
       process *p;
       pid_t pid;
       int mypipe[2], infile, outfile;

       infile = j->stdin;
       for (p = j->first_process; p; p = p->next)
         {
           /* Set up pipes, if necessary.  */
           if (p->next)
             {
               if (pipe (mypipe) < 0)
                 {
                   perror ("pipe");
                   exit (1);
                 }
               outfile = mypipe[1];
             }
           else
             outfile = j->stdout;

           /* Fork the child processes.  */
           pid = fork ();
           if (pid == 0)
             /* This is the child process.  */
             launch_process (p, j->pgid, infile,
                             outfile, j->stderr, foreground);
           else if (pid < 0)
             {
               /* The fork failed.  */
               perror ("fork");
               exit (1);
             }
           else
             {
               /* This is the parent process.  */
               p->pid = pid;
               if (shell_is_interactive)
                 {
                   if (!j->pgid)
                     j->pgid = pid;
                   setpgid (pid, j->pgid);
                 }
             }

           /* Clean up after pipes.  */
           if (infile != j->stdin)
             close (infile);
           if (outfile != j->stdout)
             close (outfile);
           infile = mypipe[0];
         }

       format_job_info (j, "launched");

       if (!shell_is_interactive)
         wait_for_job (j);
       else if (foreground)
         put_job_in_foreground (j, 0);
       else
         put_job_in_background (j, 0);
     }


File: libc.info,  Node: Foreground and Background,  Next: Stopped and Terminated Jobs,  Prev: Launching Jobs,  Up: Implementing a Shell

27.6.4 Foreground and Background
--------------------------------

Now let's consider what actions must be taken by the shell when it
launches a job into the foreground, and how this differs from what must
be done when a background job is launched.

   When a foreground job is launched, the shell must first give it
access to the controlling terminal by calling `tcsetpgrp'.  Then, the
shell should wait for processes in that process group to terminate or
stop.  This is discussed in more detail in *Note Stopped and Terminated
Jobs::.

   When all of the processes in the group have either completed or
stopped, the shell should regain control of the terminal for its own
process group by calling `tcsetpgrp' again.  Since stop signals caused
by I/O from a background process or a SUSP character typed by the user
are sent to the process group, normally all the processes in the job
stop together.

   The foreground job may have left the terminal in a strange state, so
the shell should restore its own saved terminal modes before
continuing.  In case the job is merely stopped, the shell should first
save the current terminal modes so that it can restore them later if
the job is continued.  The functions for dealing with terminal modes are
`tcgetattr' and `tcsetattr'; these are described in *Note Terminal
Modes::.

   Here is the sample shell's function for doing all of this.

     /* Put job J in the foreground.  If CONT is nonzero,
        restore the saved terminal modes and send the process group a
        `SIGCONT' signal to wake it up before we block.  */

     void
     put_job_in_foreground (job *j, int cont)
     {
       /* Put the job into the foreground.  */
       tcsetpgrp (shell_terminal, j->pgid);

       /* Send the job a continue signal, if necessary.  */
       if (cont)
         {
           tcsetattr (shell_terminal, TCSADRAIN, &j->tmodes);
           if (kill (- j->pgid, SIGCONT) < 0)
             perror ("kill (SIGCONT)");
         }

       /* Wait for it to report.  */
       wait_for_job (j);

       /* Put the shell back in the foreground.  */
       tcsetpgrp (shell_terminal, shell_pgid);

       /* Restore the shell's terminal modes.  */
       tcgetattr (shell_terminal, &j->tmodes);
       tcsetattr (shell_terminal, TCSADRAIN, &shell_tmodes);
     }

   If the process group is launched as a background job, the shell
should remain in the foreground itself and continue to read commands
from the terminal.

   In the sample shell, there is not much that needs to be done to put
a job into the background.  Here is the function it uses:

     /* Put a job in the background.  If the cont argument is true, send
        the process group a `SIGCONT' signal to wake it up.  */

     void
     put_job_in_background (job *j, int cont)
     {
       /* Send the job a continue signal, if necessary.  */
       if (cont)
         if (kill (-j->pgid, SIGCONT) < 0)
           perror ("kill (SIGCONT)");
     }


File: libc.info,  Node: Stopped and Terminated Jobs,  Next: Continuing Stopped Jobs,  Prev: Foreground and Background,  Up: Implementing a Shell

27.6.5 Stopped and Terminated Jobs
----------------------------------

When a foreground process is launched, the shell must block until all of
the processes in that job have either terminated or stopped.  It can do
this by calling the `waitpid' function; see *Note Process Completion::.
Use the `WUNTRACED' option so that status is reported for processes
that stop as well as processes that terminate.

   The shell must also check on the status of background jobs so that it
can report terminated and stopped jobs to the user; this can be done by
calling `waitpid' with the `WNOHANG' option.  A good place to put a
such a check for terminated and stopped jobs is just before prompting
for a new command.

   The shell can also receive asynchronous notification that there is
status information available for a child process by establishing a
handler for `SIGCHLD' signals.  *Note Signal Handling::.

   In the sample shell program, the `SIGCHLD' signal is normally
ignored.  This is to avoid reentrancy problems involving the global data
structures the shell manipulates.  But at specific times when the shell
is not using these data structures--such as when it is waiting for
input on the terminal--it makes sense to enable a handler for
`SIGCHLD'.  The same function that is used to do the synchronous status
checks (`do_job_notification', in this case) can also be called from
within this handler.

   Here are the parts of the sample shell program that deal with
checking the status of jobs and reporting the information to the user.

     /* Store the status of the process PID that was returned by waitpid.
        Return 0 if all went well, nonzero otherwise.  */

     int
     mark_process_status (pid_t pid, int status)
     {
       job *j;
       process *p;

       if (pid > 0)
         {
           /* Update the record for the process.  */
           for (j = first_job; j; j = j->next)
             for (p = j->first_process; p; p = p->next)
               if (p->pid == pid)
                 {
                   p->status = status;
                   if (WIFSTOPPED (status))
                     p->stopped = 1;
                   else
                     {
                       p->completed = 1;
                       if (WIFSIGNALED (status))
                         fprintf (stderr, "%d: Terminated by signal %d.\n",
                                  (int) pid, WTERMSIG (p->status));
                     }
                   return 0;
                  }
           fprintf (stderr, "No child process %d.\n", pid);
           return -1;
         }
       else if (pid == 0 || errno == ECHILD)
         /* No processes ready to report.  */
         return -1;
       else {
         /* Other weird errors.  */
         perror ("waitpid");
         return -1;
       }
     }

     /* Check for processes that have status information available,
        without blocking.  */

     void
     update_status (void)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED|WNOHANG);
       while (!mark_process_status (pid, status));
     }

     /* Check for processes that have status information available,
        blocking until all processes in the given job have reported.  */

     void
     wait_for_job (job *j)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED);
       while (!mark_process_status (pid, status)
              && !job_is_stopped (j)
              && !job_is_completed (j));
     }

     /* Format information about job status for the user to look at.  */

     void
     format_job_info (job *j, const char *status)
     {
       fprintf (stderr, "%ld (%s): %s\n", (long)j->pgid, status, j->command);
     }

     /* Notify the user about stopped or terminated jobs.
        Delete terminated jobs from the active job list.  */

     void
     do_job_notification (void)
     {
       job *j, *jlast, *jnext;
       process *p;

       /* Update status information for child processes.  */
       update_status ();

       jlast = NULL;
       for (j = first_job; j; j = jnext)
         {
           jnext = j->next;

           /* If all processes have completed, tell the user the job has
              completed and delete it from the list of active jobs.  */
           if (job_is_completed (j)) {
             format_job_info (j, "completed");
             if (jlast)
               jlast->next = jnext;
             else
               first_job = jnext;
             free_job (j);
           }

           /* Notify the user about stopped jobs,
              marking them so that we won't do this more than once.  */
           else if (job_is_stopped (j) && !j->notified) {
             format_job_info (j, "stopped");
             j->notified = 1;
             jlast = j;
           }

           /* Don't say anything about jobs that are still running.  */
           else
             jlast = j;
         }
     }


File: libc.info,  Node: Continuing Stopped Jobs,  Next: Missing Pieces,  Prev: Stopped and Terminated Jobs,  Up: Implementing a Shell

27.6.6 Continuing Stopped Jobs
------------------------------

The shell can continue a stopped job by sending a `SIGCONT' signal to
its process group.  If the job is being continued in the foreground,
the shell should first invoke `tcsetpgrp' to give the job access to the
terminal, and restore the saved terminal settings.  After continuing a
job in the foreground, the shell should wait for the job to stop or
complete, as if the job had just been launched in the foreground.

   The sample shell program handles both newly created and continued
jobs with the same pair of functions, `put_job_in_foreground' and
`put_job_in_background'.  The definitions of these functions were given
in *Note Foreground and Background::.  When continuing a stopped job, a
nonzero value is passed as the CONT argument to ensure that the
`SIGCONT' signal is sent and the terminal modes reset, as appropriate.

   This leaves only a function for updating the shell's internal
bookkeeping about the job being continued:

     /* Mark a stopped job J as being running again.  */

     void
     mark_job_as_running (job *j)
     {
       Process *p;

       for (p = j->first_process; p; p = p->next)
         p->stopped = 0;
       j->notified = 0;
     }

     /* Continue the job J.  */

     void
     continue_job (job *j, int foreground)
     {
       mark_job_as_running (j);
       if (foreground)
         put_job_in_foreground (j, 1);
       else
         put_job_in_background (j, 1);
     }


File: libc.info,  Node: Missing Pieces,  Prev: Continuing Stopped Jobs,  Up: Implementing a Shell

27.6.7 The Missing Pieces
-------------------------

The code extracts for the sample shell included in this chapter are only
a part of the entire shell program.  In particular, nothing at all has
been said about how `job' and `program' data structures are allocated
and initialized.

   Most real shells provide a complex user interface that has support
for a command language; variables; abbreviations, substitutions, and
pattern matching on file names; and the like.  All of this is far too
complicated to explain here!  Instead, we have concentrated on showing
how to implement the core process creation and job control functions
that can be called from such a shell.

   Here is a table summarizing the major entry points we have presented:

`void init_shell (void)'
     Initialize the shell's internal state.  *Note Initializing the
     Shell::.

`void launch_job (job *J, int FOREGROUND)'
     Launch the job J as either a foreground or background job.  *Note
     Launching Jobs::.

`void do_job_notification (void)'
     Check for and report any jobs that have terminated or stopped.
     Can be called synchronously or within a handler for `SIGCHLD'
     signals.  *Note Stopped and Terminated Jobs::.

`void continue_job (job *J, int FOREGROUND)'
     Continue the job J.  *Note Continuing Stopped Jobs::.

   Of course, a real shell would also want to provide other functions
for managing jobs.  For example, it would be useful to have commands to
list all active jobs or to send a signal (such as `SIGKILL') to a job.


File: libc.info,  Node: Functions for Job Control,  Prev: Implementing a Shell,  Up: Job Control

27.7 Functions for Job Control
==============================

This section contains detailed descriptions of the functions relating
to job control.

* Menu:

* Identifying the Terminal::    Determining the controlling terminal's name.
* Process Group Functions::     Functions for manipulating process groups.
* Terminal Access Functions::   Functions for controlling terminal access.


File: libc.info,  Node: Identifying the Terminal,  Next: Process Group Functions,  Up: Functions for Job Control

27.7.1 Identifying the Controlling Terminal
-------------------------------------------

You can use the `ctermid' function to get a file name that you can use
to open the controlling terminal.  In the GNU library, it returns the
same string all the time: `"/dev/tty"'.  That is a special "magic" file
name that refers to the controlling terminal of the current process (if
it has one).  To find the name of the specific terminal device, use
`ttyname'; *note Is It a Terminal::.

   The function `ctermid' is declared in the header file `stdio.h'.  

 -- Function: char * ctermid (char *STRING)
     The `ctermid' function returns a string containing the file name of
     the controlling terminal for the current process.  If STRING is
     not a null pointer, it should be an array that can hold at least
     `L_ctermid' characters; the string is returned in this array.
     Otherwise, a pointer to a string in a static area is returned,
     which might get overwritten on subsequent calls to this function.

     An empty string is returned if the file name cannot be determined
     for any reason.  Even if a file name is returned, access to the
     file it represents is not guaranteed.

 -- Macro: int L_ctermid
     The value of this macro is an integer constant expression that
     represents the size of a string large enough to hold the file name
     returned by `ctermid'.

   See also the `isatty' and `ttyname' functions, in *Note Is It a
Terminal::.


File: libc.info,  Node: Process Group Functions,  Next: Terminal Access Functions,  Prev: Identifying the Terminal,  Up: Functions for Job Control

27.7.2 Process Group Functions
------------------------------

Here are descriptions of the functions for manipulating process groups.
Your program should include the header files `sys/types.h' and
`unistd.h' to use these functions.  

 -- Function: pid_t setsid (void)
     The `setsid' function creates a new session.  The calling process
     becomes the session leader, and is put in a new process group whose
     process group ID is the same as the process ID of that process.
     There are initially no other processes in the new process group,
     and no other process groups in the new session.

     This function also makes the calling process have no controlling
     terminal.

     The `setsid' function returns the new process group ID of the
     calling process if successful.  A return value of `-1' indicates an
     error.  The following `errno' error conditions are defined for this
     function:

    `EPERM'
          The calling process is already a process group leader, or
          there is already another process group around that has the
          same process group ID.

 -- Function: pid_t getsid (pid_t PID)
     The `getsid' function returns the process group ID of the session
     leader of the specified process.  If a PID is `0', the process
     group ID of the session leader of the current process is returned.

     In case of error `-1' is returned and `errno' is set.  The
     following `errno' error conditions are defined for this function:

    `ESRCH'
          There is no process with the given process ID PID.

    `EPERM'
          The calling process and the process specified by PID are in
          different sessions, and the implementation doesn't allow to
          access the process group ID of the session leader of the
          process with ID PID from the calling process.

   The `getpgrp' function has two definitions: one derived from BSD
Unix, and one from the POSIX.1 standard.  The feature test macros you
have selected (*note Feature Test Macros::) determine which definition
you get.  Specifically, you get the BSD version if you define
`_BSD_SOURCE'; otherwise, you get the POSIX version if you define
`_POSIX_SOURCE' or `_GNU_SOURCE'.  Programs written for old BSD systems
will not include `unistd.h', which defines `getpgrp' specially under
`_BSD_SOURCE'.  You must link such programs with the `-lbsd-compat'
option to get the BSD definition.  

 -- POSIX.1 Function: pid_t getpgrp (void)
     The POSIX.1 definition of `getpgrp' returns the process group ID of
     the calling process.

 -- BSD Function: pid_t getpgrp (pid_t PID)
     The BSD definition of `getpgrp' returns the process group ID of the
     process PID.  You can supply a value of `0' for the PID argument
     to get information about the calling process.

 -- System V Function: int getpgid (pid_t PID)
     `getpgid' is the same as the BSD function `getpgrp'.  It returns
     the process group ID of the process PID.  You can supply a value
     of `0' for the PID argument to get information about the calling
     process.

     In case of error `-1' is returned and `errno' is set.  The
     following `errno' error conditions are defined for this function:

    `ESRCH'
          There is no process with the given process ID PID.  The
          calling process and the process specified by PID are in
          different sessions, and the implementation doesn't allow to
          access the process group ID of the process with ID PID from
          the calling process.

 -- Function: int setpgid (pid_t PID, pid_t PGID)
     The `setpgid' function puts the process PID into the process group
     PGID.  As a special case, either PID or PGID can be zero to
     indicate the process ID of the calling process.

     This function fails on a system that does not support job control.
     *Note Job Control is Optional::, for more information.

     If the operation is successful, `setpgid' returns zero.  Otherwise
     it returns `-1'.  The following `errno' error conditions are
     defined for this function:

    `EACCES'
          The child process named by PID has executed an `exec'
          function since it was forked.

    `EINVAL'
          The value of the PGID is not valid.

    `ENOSYS'
          The system doesn't support job control.

    `EPERM'
          The process indicated by the PID argument is a session leader,
          or is not in the same session as the calling process, or the
          value of the PGID argument doesn't match a process group ID
          in the same session as the calling process.

    `ESRCH'
          The process indicated by the PID argument is not the calling
          process or a child of the calling process.

 -- Function: int setpgrp (pid_t PID, pid_t PGID)
     This is the BSD Unix name for `setpgid'.  Both functions do exactly
     the same thing.


File: libc.info,  Node: Terminal Access Functions,  Prev: Process Group Functions,  Up: Functions for Job Control

27.7.3 Functions for Controlling Terminal Access
------------------------------------------------

These are the functions for reading or setting the foreground process
group of a terminal.  You should include the header files `sys/types.h'
and `unistd.h' in your application to use these functions.  

   Although these functions take a file descriptor argument to specify
the terminal device, the foreground job is associated with the terminal
file itself and not a particular open file descriptor.

 -- Function: pid_t tcgetpgrp (int FILEDES)
     This function returns the process group ID of the foreground
     process group associated with the terminal open on descriptor
     FILEDES.

     If there is no foreground process group, the return value is a
     number greater than `1' that does not match the process group ID
     of any existing process group.  This can happen if all of the
     processes in the job that was formerly the foreground job have
     terminated, and no other job has yet been moved into the
     foreground.

     In case of an error, a value of `-1' is returned.  The following
     `errno' error conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOSYS'
          The system doesn't support job control.

    `ENOTTY'
          The terminal file associated with the FILEDES argument isn't
          the controlling terminal of the calling process.

 -- Function: int tcsetpgrp (int FILEDES, pid_t PGID)
     This function is used to set a terminal's foreground process group
     ID.  The argument FILEDES is a descriptor which specifies the
     terminal; PGID specifies the process group.  The calling process
     must be a member of the same session as PGID and must have the same
     controlling terminal.

     For terminal access purposes, this function is treated as output.
     If it is called from a background process on its controlling
     terminal, normally all processes in the process group are sent a
     `SIGTTOU' signal.  The exception is if the calling process itself
     is ignoring or blocking `SIGTTOU' signals, in which case the
     operation is performed and no signal is sent.

     If successful, `tcsetpgrp' returns `0'.  A return value of `-1'
     indicates an error.  The following `errno' error conditions are
     defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The PGID argument is not valid.

    `ENOSYS'
          The system doesn't support job control.

    `ENOTTY'
          The FILEDES isn't the controlling terminal of the calling
          process.

    `EPERM'
          The PGID isn't a process group in the same session as the
          calling process.

 -- Function: pid_t tcgetsid (int FILDES)
     This function is used to obtain the process group ID of the session
     for which the terminal specified by FILDES is the controlling
     terminal.  If the call is successful the group ID is returned.
     Otherwise the return value is `(pid_t) -1' and the global variable
     ERRNO is set to the following value:
    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The calling process does not have a controlling terminal, or
          the file is not the controlling terminal.


File: libc.info,  Node: Name Service Switch,  Next: Users and Groups,  Prev: Job Control,  Up: Top

28 System Databases and Name Service Switch
*******************************************

Various functions in the C Library need to be configured to work
correctly in the local environment.  Traditionally, this was done by
using files (e.g., `/etc/passwd'), but other nameservices (like the
Network Information Service (NIS) and the Domain Name Service (DNS))
became popular, and were hacked into the C library, usually with a fixed
search order (*note frobnicate: (jargon)frobnicate.).

   The GNU C Library contains a cleaner solution of this problem.  It is
designed after a method used by Sun Microsystems in the C library of
Solaris 2.  GNU C Library follows their name and calls this scheme
"Name Service Switch" (NSS).

   Though the interface might be similar to Sun's version there is no
common code.  We never saw any source code of Sun's implementation and
so the internal interface is incompatible.  This also manifests in the
file names we use as we will see later.

* Menu:

* NSS Basics::                  What is this NSS good for.
* NSS Configuration File::      Configuring NSS.
* NSS Module Internals::        How does it work internally.
* Extending NSS::               What to do to add services or databases.


File: libc.info,  Node: NSS Basics,  Next: NSS Configuration File,  Prev: Name Service Switch,  Up: Name Service Switch

28.1 NSS Basics
===============

The basic idea is to put the implementation of the different services
offered to access the databases in separate modules.  This has some
advantages:

  1. Contributors can add new services without adding them to GNU C
     Library.

  2. The modules can be updated separately.

  3. The C library image is smaller.

   To fulfill the first goal above the ABI of the modules will be
described below.  For getting the implementation of a new service right
it is important to understand how the functions in the modules get
called.  They are in no way designed to be used by the programmer
directly.  Instead the programmer should only use the documented and
standardized functions to access the databases.

The databases available in the NSS are

`aliases'
     Mail aliases

`ethers'
     Ethernet numbers,

`group'
     Groups of users, *note Group Database::.

`hosts'
     Host names and numbers, *note Host Names::.

`netgroup'
     Network wide list of host and users, *note Netgroup Database::.

`networks'
     Network names and numbers, *note Networks Database::.

`protocols'
     Network protocols, *note Protocols Database::.

`passwd'
     User passwords, *note User Database::.

`rpc'
     Remote procedure call names and numbers,

`services'
     Network services, *note Services Database::.

`shadow'
     Shadow user passwords,

There will be some more added later (`automount', `bootparams',
`netmasks', and `publickey').


File: libc.info,  Node: NSS Configuration File,  Next: NSS Module Internals,  Prev: NSS Basics,  Up: Name Service Switch

28.2 The NSS Configuration File
===============================

Somehow the NSS code must be told about the wishes of the user.  For
this reason there is the file `/etc/nsswitch.conf'.  For each database
this file contain a specification how the lookup process should work.
The file could look like this:

     # /etc/nsswitch.conf
     #
     # Name Service Switch configuration file.
     #

     passwd:     db files nis
     shadow:     files
     group:      db files nis

     hosts:      files nisplus nis dns
     networks:   nisplus [NOTFOUND=return] files

     ethers:     nisplus [NOTFOUND=return] db files
     protocols:  nisplus [NOTFOUND=return] db files
     rpc:        nisplus [NOTFOUND=return] db files
     services:   nisplus [NOTFOUND=return] db files

   The first column is the database as you can guess from the table
above.  The rest of the line specifies how the lookup process works.
Please note that you specify the way it works for each database
individually.  This cannot be done with the old way of a monolithic
implementation.

   The configuration specification for each database can contain two
different items:

   * the service specification like `files', `db', or `nis'.

   * the reaction on lookup result like `[NOTFOUND=return]'.

* Menu:

* Services in the NSS configuration::  Service names in the NSS configuration.
* Actions in the NSS configuration::  React appropriately to the lookup result.
* Notes on NSS Configuration File::  Things to take care about while
                                     configuring NSS.


File: libc.info,  Node: Services in the NSS configuration,  Next: Actions in the NSS configuration,  Prev: NSS Configuration File,  Up: NSS Configuration File

28.2.1 Services in the NSS configuration File
---------------------------------------------

The above example file mentions four different services: `files', `db',
`nis', and `nisplus'.  This does not mean these services are available
on all sites and it does also not mean these are all the services which
will ever be available.

   In fact, these names are simply strings which the NSS code uses to
find the implicitly addressed functions.  The internal interface will be
described later.  Visible to the user are the modules which implement an
individual service.

   Assume the service NAME shall be used for a lookup.  The code for
this service is implemented in a module called `libnss_NAME'.  On a
system supporting shared libraries this is in fact a shared library
with the name (for example) `libnss_NAME.so.2'.  The number at the end
is the currently used version of the interface which will not change
frequently.  Normally the user should not have to be cognizant of these
files since they should be placed in a directory where they are found
automatically.  Only the names of all available services are important.


File: libc.info,  Node: Actions in the NSS configuration,  Next: Notes on NSS Configuration File,  Prev: Services in the NSS configuration,  Up: NSS Configuration File

28.2.2 Actions in the NSS configuration
---------------------------------------

The second item in the specification gives the user much finer control
on the lookup process.  Action items are placed between two service
names and are written within brackets.  The general form is

     `[' ( `!'? STATUS `=' ACTION )+ `]'

where

     STATUS => success | notfound | unavail | tryagain
     ACTION => return | continue

   The case of the keywords is insignificant.  The STATUS values are
the results of a call to a lookup function of a specific service.  They
mean

`success'
     No error occurred and the wanted entry is returned.  The default
     action for this is `return'.

`notfound'
     The lookup process works ok but the needed value was not found.
     The default action is `continue'.

`unavail'
     The service is permanently unavailable.  This can either mean the
     needed file is not available, or, for DNS, the server is not
     available or does not allow queries.  The default action is
     `continue'.

`tryagain'
     The service is temporarily unavailable.  This could mean a file is
     locked or a server currently cannot accept more connections.  The
     default action is `continue'.

If we have a line like

     ethers: nisplus [NOTFOUND=return] db files

this is equivalent to

     ethers: nisplus [SUCCESS=return NOTFOUND=return UNAVAIL=continue
                      TRYAGAIN=continue]
             db      [SUCCESS=return NOTFOUND=continue UNAVAIL=continue
                      TRYAGAIN=continue]
             files

(except that it would have to be written on one line).  The default
value for the actions are normally what you want, and only need to be
changed in exceptional cases.

   If the optional `!' is placed before the STATUS this means the
following action is used for all statuses but STATUS itself.  I.e., `!'
is negation as in the C language (and others).

   Before we explain the exception which makes this action item
necessary one more remark: obviously it makes no sense to add another
action item after the `files' service.  Since there is no other service
following the action _always_ is `return'.

   Now, why is this `[NOTFOUND=return]' action useful?  To understand
this we should know that the `nisplus' service is often complete; i.e.,
if an entry is not available in the NIS+ tables it is not available
anywhere else.  This is what is expressed by this action item: it is
useless to examine further services since they will not give us a
result.

   The situation would be different if the NIS+ service is not available
because the machine is booting.  In this case the return value of the
lookup function is not `notfound' but instead `unavail'.  And as you
can see in the complete form above: in this situation the `db' and
`files' services are used.  Neat, isn't it?  The system administrator
need not pay special care for the time the system is not completely
ready to work (while booting or shutdown or network problems).


File: libc.info,  Node: Notes on NSS Configuration File,  Prev: Actions in the NSS configuration,  Up: NSS Configuration File

28.2.3 Notes on the NSS Configuration File
------------------------------------------

Finally a few more hints.  The NSS implementation is not completely
helpless if `/etc/nsswitch.conf' does not exist.  For all supported
databases there is a default value so it should normally be possible to
get the system running even if the file is corrupted or missing.

   For the `hosts' and `networks' databases the default value is `dns
[!UNAVAIL=return] files'.  I.e., the system is prepared for the DNS
service not to be available but if it is available the answer it
returns is definitive.

   The `passwd', `group', and `shadow' databases are traditionally
handled in a special way.  The appropriate files in the `/etc'
directory are read but if an entry with a name starting with a `+'
character is found NIS is used.  This kind of lookup remains possible
by using the special lookup service `compat' and the default value for
the three databases above is `compat [NOTFOUND=return] files'.

   For all other databases the default value is `nis [NOTFOUND=return]
files'.  This solution give the best chance to be correct since NIS and
file based lookup is used.

   A second point is that the user should try to optimize the lookup
process.  The different service have different response times.  A
simple file look up on a local file could be fast, but if the file is
long and the needed entry is near the end of the file this may take
quite some time.  In this case it might be better to use the `db'
service which allows fast local access to large data sets.

   Often the situation is that some global information like NIS must be
used.  So it is unavoidable to use service entries like `nis' etc.  But
one should avoid slow services like this if possible.


File: libc.info,  Node: NSS Module Internals,  Next: Extending NSS,  Prev: NSS Configuration File,  Up: Name Service Switch

28.3 NSS Module Internals
=========================

Now it is time to describe what the modules look like.  The functions
contained in a module are identified by their names.  I.e., there is no
jump table or the like.  How this is done is of no interest here; those
interested in this topic should read about Dynamic Linking.

* Menu:

* NSS Module Names::            Construction of the interface function of
                                the NSS modules.
* NSS Modules Interface::       Programming interface in the NSS module
                                functions.


File: libc.info,  Node: NSS Module Names,  Next: NSS Modules Interface,  Prev: NSS Module Internals,  Up: NSS Module Internals

28.3.1 The Naming Scheme of the NSS Modules
-------------------------------------------

The name of each function consist of various parts:

            _nss_SERVICE_FUNCTION

   SERVICE of course corresponds to the name of the module this
function is found in.(1)  The FUNCTION part is derived from the
interface function in the C library itself.  If the user calls the
function `gethostbyname' and the service used is `files' the function

            _nss_files_gethostbyname_r

in the module

            libnss_files.so.2

is used.  You see, what is explained above in not the whole truth.  In
fact the NSS modules only contain reentrant versions of the lookup
functions.  I.e., if the user would call the `gethostbyname_r' function
this also would end in the above function.  For all user interface
functions the C library maps this call to a call to the reentrant
function.  For reentrant functions this is trivial since the interface
is (nearly) the same.  For the non-reentrant version The library keeps
internal buffers which are used to replace the user supplied buffer.

   I.e., the reentrant functions _can_ have counterparts.  No service
module is forced to have functions for all databases and all kinds to
access them.  If a function is not available it is simply treated as if
the function would return `unavail' (*note Actions in the NSS
configuration::).

   The file name `libnss_files.so.2' would be on a Solaris 2 system
`nss_files.so.2'.  This is the difference mentioned above.  Sun's NSS
modules are usable as modules which get indirectly loaded only.

   The NSS modules in the GNU C Library are prepared to be used as
normal libraries themselves.  This is _not_ true at the moment, though.
However,  the organization of the name space in the modules does not
make it impossible like it is for Solaris.  Now you can see why the
modules are still libraries.(2)

   ---------- Footnotes ----------

   (1) Now you might ask why this information is duplicated.  The
answer is that we want to make it possible to link directly with these
shared objects.

   (2) There is a second explanation: we were too lazy to change the
Makefiles to allow the generation of shared objects not starting with
`lib' but don't tell this to anybody.


File: libc.info,  Node: NSS Modules Interface,  Prev: NSS Module Names,  Up: NSS Module Internals

28.3.2 The Interface of the Function in NSS Modules
---------------------------------------------------

Now we know about the functions contained in the modules.  It is now
time to describe the types.  When we mentioned the reentrant versions of
the functions above, this means there are some additional arguments
(compared with the standard, non-reentrant version).  The prototypes for
the non-reentrant and reentrant versions of our function above are:

     struct hostent *gethostbyname (const char *name)

     int gethostbyname_r (const char *name, struct hostent *result_buf,
                          char *buf, size_t buflen, struct hostent **result,
                          int *h_errnop)

The actual prototype of the function in the NSS modules in this case is

     enum nss_status _nss_files_gethostbyname_r (const char *name,
                                                 struct hostent *result_buf,
                                                 char *buf, size_t buflen,
                                                 int *errnop, int *h_errnop)

   I.e., the interface function is in fact the reentrant function with
the change of the return value and the omission of the RESULT
parameter.  While the user-level function returns a pointer to the
result the reentrant function return an `enum nss_status' value:

`NSS_STATUS_TRYAGAIN'
     numeric value `-2'

`NSS_STATUS_UNAVAIL'
     numeric value `-1'

`NSS_STATUS_NOTFOUND'
     numeric value `0'

`NSS_STATUS_SUCCESS'
     numeric value `1'

Now you see where the action items of the `/etc/nsswitch.conf' file are
used.

   If you study the source code you will find there is a fifth value:
`NSS_STATUS_RETURN'.  This is an internal use only value, used by a few
functions in places where none of the above value can be used.  If
necessary the source code should be examined to learn about the details.

   In case the interface function has to return an error it is important
that the correct error code is stored in `*ERRNOP'.  Some return status
value have only one associated error code, others have more.

`NSS_STATUS_TRYAGAIN'   `EAGAIN'      One of the functions used ran
                                      temporarily out of resources or a
                                      service is currently not available.
                       `ERANGE'       The provided buffer is not large
                                      enough.  The function should be
                                      called again with a larger buffer.
`NSS_STATUS_UNAVAIL'    `ENOENT'      A necessary input file cannot be
                                      found.
`NSS_STATUS_NOTFOUND'   `ENOENT'      The requested entry is not
                                      available.

   These are proposed values.  There can be other error codes and the
described error codes can have different meaning.  *With one
exception:* when returning `NSS_STATUS_TRYAGAIN' the error code
`ERANGE' _must_ mean that the user provided buffer is too small.
Everything is non-critical.

   The above function has something special which is missing for almost
all the other module functions.  There is an argument H_ERRNOP.  This
points to a variable which will be filled with the error code in case
the execution of the function fails for some reason.  The reentrant
function cannot use the global variable H_ERRNO; `gethostbyname' calls
`gethostbyname_r' with the last argument set to `&h_errno'.

   The `getXXXbyYYY' functions are the most important functions in the
NSS modules.  But there are others which implement the other ways to
access system databases (say for the password database, there are
`setpwent', `getpwent', and `endpwent').  These will be described in
more detail later.  Here we give a general way to determine the
signature of the module function:

   * the return value is `int';

   * the name is as explained in *note NSS Module Names::;

   * the first arguments are identical to the arguments of the
     non-reentrant function;

   * the next three arguments are:

    `STRUCT_TYPE *result_buf'
          pointer to buffer where the result is stored.  `STRUCT_TYPE'
          is normally a struct which corresponds to the database.

    `char *buffer'
          pointer to a buffer where the function can store additional
          data for the result etc.

    `size_t buflen'
          length of the buffer pointed to by BUFFER.

   * possibly a last argument H_ERRNOP, for the host name and network
     name lookup functions.

This table is correct for all functions but the `set...ent' and
`end...ent' functions.


File: libc.info,  Node: Extending NSS,  Prev: NSS Module Internals,  Up: Name Service Switch

28.4 Extending NSS
==================

One of the advantages of NSS mentioned above is that it can be extended
quite easily.  There are two ways in which the extension can happen:
adding another database or adding another service.  The former is
normally done only by the C library developers.  It is here only
important to remember that adding another database is independent from
adding another service because a service need not support all databases
or lookup functions.

   A designer/implementor of a new service is therefore free to choose
the databases s/he is interested in and leave the rest for later (or
completely aside).

* Menu:

* Adding another Service to NSS::  What is to do to add a new service.
* NSS Module Function Internals::  Guidelines for writing new NSS
                                        service functions.


File: libc.info,  Node: Adding another Service to NSS,  Next: NSS Module Function Internals,  Prev: Extending NSS,  Up: Extending NSS

28.4.1 Adding another Service to NSS
------------------------------------

The sources for a new service need not (and should not) be part of the
GNU C Library itself.  The developer retains complete control over the
sources and its development.  The links between the C library and the
new service module consists solely of the interface functions.

   Each module is designed following a specific interface specification.
For now the version is 2 (the interface in version 1 was not adequate)
and this manifests in the version number of the shared library object of
the NSS modules: they have the extension `.2'.  If the interface
changes again in an incompatible way, this number will be increased.
Modules using the old interface will still be usable.

   Developers of a new service will have to make sure that their module
is created using the correct interface number.  This means the file
itself must have the correct name and on ELF systems the "soname"
(Shared Object Name) must also have this number.  Building a module
from a bunch of object files on an ELF system using GNU CC could be
done like this:

     gcc -shared -o libnss_NAME.so.2 -Wl,-soname,libnss_NAME.so.2 OBJECTS

*Note Options for Linking: (gcc)Link Options, to learn more about this
command line.

   To use the new module the library must be able to find it.  This can
be achieved by using options for the dynamic linker so that it will
search the directory where the binary is placed.  For an ELF system
this could be done by adding the wanted directory to the value of
`LD_LIBRARY_PATH'.

   But this is not always possible since some programs (those which run
under IDs which do not belong to the user) ignore this variable.
Therefore the stable version of the module should be placed into a
directory which is searched by the dynamic linker.  Normally this should
be the directory `$prefix/lib', where `$prefix' corresponds to the
value given to configure using the `--prefix' option.  But be careful:
this should only be done if it is clear the module does not cause any
harm.  System administrators should be careful.


File: libc.info,  Node: NSS Module Function Internals,  Prev: Adding another Service to NSS,  Up: Extending NSS

28.4.2 Internals of the NSS Module Functions
--------------------------------------------

Until now we only provided the syntactic interface for the functions in
the NSS module.  In fact there is not much more we can say since the
implementation obviously is different for each function.  But a few
general rules must be followed by all functions.

   In fact there are four kinds of different functions which may appear
in the interface.  All derive from the traditional ones for system
databases.  DB in the following table is normally an abbreviation for
the database (e.g., it is `pw' for the password database).

`enum nss_status _nss_DATABASE_setDBent (void)'
     This function prepares the service for following operations.  For a
     simple file based lookup this means files could be opened, for
     other services this function simply is a noop.

     One special case for this function is that it takes an additional
     argument for some DATABASEs (i.e., the interface is `int setDBent
     (int)').  *Note Host Names::, which describes the `sethostent'
     function.

     The return value should be NSS_STATUS_SUCCESS or according to the
     table above in case of an error (*note NSS Modules Interface::).

`enum nss_status _nss_DATABASE_endDBent (void)'
     This function simply closes all files which are still open or
     removes buffer caches.  If there are no files or buffers to remove
     this is again a simple noop.

     There normally is no return value different to NSS_STATUS_SUCCESS.

`enum nss_status _nss_DATABASE_getDBent_r (STRUCTURE *result, char *buffer, size_t buflen, int *errnop)'
     Since this function will be called several times in a row to
     retrieve one entry after the other it must keep some kind of
     state.  But this also means the functions are not really
     reentrant.  They are reentrant only in that simultaneous calls to
     this function will not try to write the retrieved data in the same
     place (as it would be the case for the non-reentrant functions);
     instead, it writes to the structure pointed to by the RESULT
     parameter.  But the calls share a common state and in the case of
     a file access this means they return neighboring entries in the
     file.

     The buffer of length BUFLEN pointed to by BUFFER can be used for
     storing some additional data for the result.  It is _not_
     guaranteed that the same buffer will be passed for the next call
     of this function.  Therefore one must not misuse this buffer to
     save some state information from one call to another.

     Before the function returns the implementation should store the
     value of the local ERRNO variable in the variable pointed to be
     ERRNOP.  This is important to guarantee the module working in
     statically linked programs.

     As explained above this function could also have an additional last
     argument.  This depends on the database used; it happens only for
     `host' and `networks'.

     The function shall return `NSS_STATUS_SUCCESS' as long as there are
     more entries.  When the last entry was read it should return
     `NSS_STATUS_NOTFOUND'.  When the buffer given as an argument is too
     small for the data to be returned `NSS_STATUS_TRYAGAIN' should be
     returned.  When the service was not formerly initialized by a call
     to `_nss_DATABASE_setDBent' all return value allowed for this
     function can also be returned here.

`enum nss_status _nss_DATABASE_getDBbyXX_r (PARAMS, STRUCTURE *result, char *buffer, size_t buflen, int *errnop)'
     This function shall return the entry from the database which is
     addressed by the PARAMS.  The type and number of these arguments
     vary.  It must be individually determined by looking to the
     user-level interface functions.  All arguments given to the
     non-reentrant version are here described by PARAMS.

     The result must be stored in the structure pointed to by RESULT.
     If there is additional data to return (say strings, where the
     RESULT structure only contains pointers) the function must use the
     BUFFER or length BUFLEN.  There must not be any references to
     non-constant global data.

     The implementation of this function should honor the STAYOPEN flag
     set by the `setDBent' function whenever this makes sense.

     Before the function returns the implementation should store the
     value of the local ERRNO variable in the variable pointed to be
     ERRNOP.  This is important to guarantee the module working in
     statically linked programs.

     Again, this function takes an additional last argument for the
     `host' and `networks' database.

     The return value should as always follow the rules given above
     (*note NSS Modules Interface::).



File: libc.info,  Node: Users and Groups,  Next: System Management,  Prev: Name Service Switch,  Up: Top

29 Users and Groups
*******************

Every user who can log in on the system is identified by a unique number
called the "user ID".  Each process has an effective user ID which says
which user's access permissions it has.

   Users are classified into "groups" for access control purposes.  Each
process has one or more "group ID values" which say which groups the
process can use for access to files.

   The effective user and group IDs of a process collectively form its
"persona".  This determines which files the process can access.
Normally, a process inherits its persona from the parent process, but
under special circumstances a process can change its persona and thus
change its access permissions.

   Each file in the system also has a user ID and a group ID.  Access
control works by comparing the user and group IDs of the file with those
of the running process.

   The system keeps a database of all the registered users, and another
database of all the defined groups.  There are library functions you
can use to examine these databases.

* Menu:

* User and Group IDs::          Each user has a unique numeric ID;
				 likewise for groups.
* Process Persona::             The user IDs and group IDs of a process.
* Why Change Persona::          Why a program might need to change
				 its user and/or group IDs.
* How Change Persona::          Changing the user and group IDs.
* Reading Persona::             How to examine the user and group IDs.

* Setting User ID::             Functions for setting the user ID.
* Setting Groups::              Functions for setting the group IDs.

* Enable/Disable Setuid::       Turning setuid access on and off.
* Setuid Program Example::      The pertinent parts of one sample program.
* Tips for Setuid::             How to avoid granting unlimited access.

* Who Logged In::               Getting the name of the user who logged in,
				 or of the real user ID of the current process.

* User Accounting Database::    Keeping information about users and various
                                 actions in databases.

* User Database::               Functions and data structures for
                        	 accessing the user database.
* Group Database::              Functions and data structures for
                        	 accessing the group database.
* Database Example::            Example program showing the use of database
				 inquiry functions.
* Netgroup Database::           Functions for accessing the netgroup database.


File: libc.info,  Node: User and Group IDs,  Next: Process Persona,  Up: Users and Groups

29.1 User and Group IDs
=======================

Each user account on a computer system is identified by a "user name"
(or "login name") and "user ID".  Normally, each user name has a unique
user ID, but it is possible for several login names to have the same
user ID.  The user names and corresponding user IDs are stored in a
data base which you can access as described in *Note User Database::.

   Users are classified in "groups".  Each user name belongs to one
"default group" and may also belong to any number of "supplementary
groups". Users who are members of the same group can share resources
(such as files) that are not accessible to users who are not a member
of that group.  Each group has a "group name" and "group ID".  *Note
Group Database::, for how to find information about a group ID or group
name.


File: libc.info,  Node: Process Persona,  Next: Why Change Persona,  Prev: User and Group IDs,  Up: Users and Groups

29.2 The Persona of a Process
=============================

At any time, each process has an "effective user ID", a "effective
group ID", and a set of "supplementary group IDs".  These IDs determine
the privileges of the process.  They are collectively called the
"persona" of the process, because they determine "who it is" for
purposes of access control.

   Your login shell starts out with a persona which consists of your
user ID, your default group ID, and your supplementary group IDs (if
you are in more than one group).  In normal circumstances, all your
other processes inherit these values.

   A process also has a "real user ID" which identifies the user who
created the process, and a "real group ID" which identifies that user's
default group.  These values do not play a role in access control, so
we do not consider them part of the persona.  But they are also
important.

   Both the real and effective user ID can be changed during the
lifetime of a process.  *Note Why Change Persona::.

   For details on how a process's effective user ID and group IDs affect
its permission to access files, see *Note Access Permission::.

   The effective user ID of a process also controls permissions for
sending signals using the `kill' function.  *Note Signaling Another
Process::.

   Finally, there are many operations which can only be performed by a
process whose effective user ID is zero.  A process with this user ID is
a "privileged process".  Commonly the user name `root' is associated
with user ID 0, but there may be other user names with this ID.


File: libc.info,  Node: Why Change Persona,  Next: How Change Persona,  Prev: Process Persona,  Up: Users and Groups

29.3 Why Change the Persona of a Process?
=========================================

The most obvious situation where it is necessary for a process to change
its user and/or group IDs is the `login' program.  When `login' starts
running, its user ID is `root'.  Its job is to start a shell whose user
and group IDs are those of the user who is logging in.  (To accomplish
this fully, `login' must set the real user and group IDs as well as its
persona.  But this is a special case.)

   The more common case of changing persona is when an ordinary user
program needs access to a resource that wouldn't ordinarily be
accessible to the user actually running it.

   For example, you may have a file that is controlled by your program
but that shouldn't be read or modified directly by other users, either
because it implements some kind of locking protocol, or because you want
to preserve the integrity or privacy of the information it contains.
This kind of restricted access can be implemented by having the program
change its effective user or group ID to match that of the resource.

   Thus, imagine a game program that saves scores in a file.  The game
program itself needs to be able to update this file no matter who is
running it, but if users can write the file without going through the
game, they can give themselves any scores they like.  Some people
consider this undesirable, or even reprehensible.  It can be prevented
by creating a new user ID and login name (say, `games') to own the
scores file, and make the file writable only by this user.  Then, when
the game program wants to update this file, it can change its effective
user ID to be that for `games'.  In effect, the program must adopt the
persona of `games' so it can write the scores file.


File: libc.info,  Node: How Change Persona,  Next: Reading Persona,  Prev: Why Change Persona,  Up: Users and Groups

29.4 How an Application Can Change Persona
==========================================

The ability to change the persona of a process can be a source of
unintentional privacy violations, or even intentional abuse.  Because of
the potential for problems, changing persona is restricted to special
circumstances.

   You can't arbitrarily set your user ID or group ID to anything you
want; only privileged processes can do that.  Instead, the normal way
for a program to change its persona is that it has been set up in
advance to change to a particular user or group.  This is the function
of the setuid and setgid bits of a file's access mode.  *Note
Permission Bits::.

   When the setuid bit of an executable file is on, executing that file
gives the process a third user ID: the "file user ID".  This ID is set
to the owner ID of the file.  The system then changes the effective
user ID to the file user ID.  The real user ID remains as it was.
Likewise, if the setgid bit is on, the process is given a "file group
ID" equal to the group ID of the file, and its effective group ID is
changed to the file group ID.

   If a process has a file ID (user or group), then it can at any time
change its effective ID to its real ID and back to its file ID.
Programs use this feature to relinquish their special privileges except
when they actually need them.  This makes it less likely that they can
be tricked into doing something inappropriate with their privileges.

   *Portability Note:* Older systems do not have file IDs.  To
determine if a system has this feature, you can test the compiler
define `_POSIX_SAVED_IDS'.  (In the POSIX standard, file IDs are known
as saved IDs.)

   *Note File Attributes::, for a more general discussion of file modes
and accessibility.


File: libc.info,  Node: Reading Persona,  Next: Setting User ID,  Prev: How Change Persona,  Up: Users and Groups

29.5 Reading the Persona of a Process
=====================================

Here are detailed descriptions of the functions for reading the user and
group IDs of a process, both real and effective.  To use these
facilities, you must include the header files `sys/types.h' and
`unistd.h'.  

 -- Data Type: uid_t
     This is an integer data type used to represent user IDs.  In the
     GNU library, this is an alias for `unsigned int'.

 -- Data Type: gid_t
     This is an integer data type used to represent group IDs.  In the
     GNU library, this is an alias for `unsigned int'.

 -- Function: uid_t getuid (void)
     The `getuid' function returns the real user ID of the process.

 -- Function: gid_t getgid (void)
     The `getgid' function returns the real group ID of the process.

 -- Function: uid_t geteuid (void)
     The `geteuid' function returns the effective user ID of the
     process.

 -- Function: gid_t getegid (void)
     The `getegid' function returns the effective group ID of the
     process.

 -- Function: int getgroups (int COUNT, gid_t *GROUPS)
     The `getgroups' function is used to inquire about the supplementary
     group IDs of the process.  Up to COUNT of these group IDs are
     stored in the array GROUPS; the return value from the function is
     the number of group IDs actually stored.  If COUNT is smaller than
     the total number of supplementary group IDs, then `getgroups'
     returns a value of `-1' and `errno' is set to `EINVAL'.

     If COUNT is zero, then `getgroups' just returns the total number
     of supplementary group IDs.  On systems that do not support
     supplementary groups, this will always be zero.

     Here's how to use `getgroups' to read all the supplementary group
     IDs:

          gid_t *
          read_all_groups (void)
          {
            int ngroups = getgroups (0, NULL);
            gid_t *groups
              = (gid_t *) xmalloc (ngroups * sizeof (gid_t));
            int val = getgroups (ngroups, groups);
            if (val < 0)
              {
                free (groups);
                return NULL;
              }
            return groups;
          }


File: libc.info,  Node: Setting User ID,  Next: Setting Groups,  Prev: Reading Persona,  Up: Users and Groups

29.6 Setting the User ID
========================

This section describes the functions for altering the user ID (real
and/or effective) of a process.  To use these facilities, you must
include the header files `sys/types.h' and `unistd.h'.  

 -- Function: int seteuid (uid_t NEWEUID)
     This function sets the effective user ID of a process to NEWUID,
     provided that the process is allowed to change its effective user
     ID.  A privileged process (effective user ID zero) can change its
     effective user ID to any legal value.  An unprivileged process
     with a file user ID can change its effective user ID to its real
     user ID or to its file user ID.  Otherwise, a process may not
     change its effective user ID at all.

     The `seteuid' function returns a value of `0' to indicate
     successful completion, and a value of `-1' to indicate an error.
     The following `errno' error conditions are defined for this
     function:

    `EINVAL'
          The value of the NEWUID argument is invalid.

    `EPERM'
          The process may not change to the specified ID.

     Older systems (those without the `_POSIX_SAVED_IDS' feature) do not
     have this function.

 -- Function: int setuid (uid_t NEWUID)
     If the calling process is privileged, this function sets both the
     real and effective user ID of the process to NEWUID.  It also
     deletes the file user ID of the process, if any.  NEWUID may be any
     legal value.  (Once this has been done, there is no way to recover
     the old effective user ID.)

     If the process is not privileged, and the system supports the
     `_POSIX_SAVED_IDS' feature, then this function behaves like
     `seteuid'.

     The return values and error conditions are the same as for
     `seteuid'.

 -- Function: int setreuid (uid_t RUID, uid_t EUID)
     This function sets the real user ID of the process to RUID and the
     effective user ID to EUID.  If RUID is `-1', it means not to
     change the real user ID; likewise if EUID is `-1', it means not to
     change the effective user ID.

     The `setreuid' function exists for compatibility with 4.3 BSD Unix,
     which does not support file IDs.  You can use this function to
     swap the effective and real user IDs of the process.  (Privileged
     processes are not limited to this particular usage.)  If file IDs
     are supported, you should use that feature instead of this
     function.  *Note Enable/Disable Setuid::.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EPERM'
          The process does not have the appropriate privileges; you do
          not have permission to change to the specified ID.


File: libc.info,  Node: Setting Groups,  Next: Enable/Disable Setuid,  Prev: Setting User ID,  Up: Users and Groups

29.7 Setting the Group IDs
==========================

This section describes the functions for altering the group IDs (real
and effective) of a process.  To use these facilities, you must include
the header files `sys/types.h' and `unistd.h'.  

 -- Function: int setegid (gid_t NEWGID)
     This function sets the effective group ID of the process to
     NEWGID, provided that the process is allowed to change its group
     ID.  Just as with `seteuid', if the process is privileged it may
     change its effective group ID to any value; if it isn't, but it
     has a file group ID, then it may change to its real group ID or
     file group ID; otherwise it may not change its effective group ID.

     Note that a process is only privileged if its effective _user_ ID
     is zero.  The effective group ID only affects access permissions.

     The return values and error conditions for `setegid' are the same
     as those for `seteuid'.

     This function is only present if `_POSIX_SAVED_IDS' is defined.

 -- Function: int setgid (gid_t NEWGID)
     This function sets both the real and effective group ID of the
     process to NEWGID, provided that the process is privileged.  It
     also deletes the file group ID, if any.

     If the process is not privileged, then `setgid' behaves like
     `setegid'.

     The return values and error conditions for `setgid' are the same
     as those for `seteuid'.

 -- Function: int setregid (gid_t RGID, gid_t EGID)
     This function sets the real group ID of the process to RGID and
     the effective group ID to EGID.  If RGID is `-1', it means not to
     change the real group ID; likewise if EGID is `-1', it means not
     to change the effective group ID.

     The `setregid' function is provided for compatibility with 4.3 BSD
     Unix, which does not support file IDs.  You can use this function
     to swap the effective and real group IDs of the process.
     (Privileged processes are not limited to this usage.)  If file IDs
     are supported, you should use that feature instead of using this
     function.  *Note Enable/Disable Setuid::.

     The return values and error conditions for `setregid' are the same
     as those for `setreuid'.

   `setuid' and `setgid' behave differently depending on whether the
effective user ID at the time is zero.  If it is not zero, they behave
like `seteuid' and `setegid'.  If it is, they change both effective and
real IDs and delete the file ID.  To avoid confusion, we recommend you
always use `seteuid' and `setegid' except when you know the effective
user ID is zero and your intent is to change the persona permanently.
This case is rare--most of the programs that need it, such as `login'
and `su', have already been written.

   Note that if your program is setuid to some user other than `root',
there is no way to drop privileges permanently.

   The system also lets privileged processes change their supplementary
group IDs.  To use `setgroups' or `initgroups', your programs should
include the header file `grp.h'.  

 -- Function: int setgroups (size_t COUNT, gid_t *GROUPS)
     This function sets the process's supplementary group IDs.  It can
     only be called from privileged processes.  The COUNT argument
     specifies the number of group IDs in the array GROUPS.

     This function returns `0' if successful and `-1' on error.  The
     following `errno' error conditions are defined for this function:

    `EPERM'
          The calling process is not privileged.

 -- Function: int initgroups (const char *USER, gid_t GROUP)
     The `initgroups' function sets the process's supplementary group
     IDs to be the normal default for the user name USER.  The group
     GROUP is automatically included.

     This function works by scanning the group database for all the
     groups USER belongs to.  It then calls `setgroups' with the list it
     has constructed.

     The return values and error conditions are the same as for
     `setgroups'.

   If you are interested in the groups a particular user belongs to,
but do not want to change the process's supplementary group IDs, you
can use `getgrouplist'.  To use `getgrouplist', your programs should
include the header file `grp.h'.  

 -- Function: int getgrouplist (const char *USER, gid_t GROUP, gid_t
          *GROUPS, int *NGROUPS)
     The `getgrouplist' function scans the group database for all the
     groups USER belongs to.  Up to *NGROUPS group IDs corresponding to
     these groups are stored in the array GROUPS; the return value from
     the function is the number of group IDs actually stored.  If
     *NGROUPS is smaller than the total number of groups found, then
     `getgrouplist' returns a value of `-1' and stores the actual
     number of groups in *NGROUPS.  The group GROUP is automatically
     included in the list of groups returned by `getgrouplist'.

     Here's how to use `getgrouplist' to read all supplementary groups
     for USER:

          gid_t *
          supplementary_groups (char *user)
          {
            int ngroups = 16;
            gid_t *groups
              = (gid_t *) xmalloc (ngroups * sizeof (gid_t));
            struct passwd *pw = getpwnam (user);

            if (pw == NULL)
              return NULL;

            if (getgrouplist (pw->pw_name, pw->pw_gid, groups, &ngroups) < 0)
              {
                groups = xrealloc (ngroups * sizeof (gid_t));
                getgrouplist (pw->pw_name, pw->pw_gid, groups, &ngroups);
              }
            return groups;
          }


File: libc.info,  Node: Enable/Disable Setuid,  Next: Setuid Program Example,  Prev: Setting Groups,  Up: Users and Groups

29.8 Enabling and Disabling Setuid Access
=========================================

A typical setuid program does not need its special access all of the
time.  It's a good idea to turn off this access when it isn't needed,
so it can't possibly give unintended access.

   If the system supports the `_POSIX_SAVED_IDS' feature, you can
accomplish this with `seteuid'.  When the game program starts, its real
user ID is `jdoe', its effective user ID is `games', and its saved user
ID is also `games'.  The program should record both user ID values once
at the beginning, like this:

     user_user_id = getuid ();
     game_user_id = geteuid ();

   Then it can turn off game file access with

     seteuid (user_user_id);

and turn it on with

     seteuid (game_user_id);

Throughout this process, the real user ID remains `jdoe' and the file
user ID remains `games', so the program can always set its effective
user ID to either one.

   On other systems that don't support file user IDs, you can turn
setuid access on and off by using `setreuid' to swap the real and
effective user IDs of the process, as follows:

     setreuid (geteuid (), getuid ());

This special case is always allowed--it cannot fail.

   Why does this have the effect of toggling the setuid access?
Suppose a game program has just started, and its real user ID is `jdoe'
while its effective user ID is `games'.  In this state, the game can
write the scores file.  If it swaps the two uids, the real becomes
`games' and the effective becomes `jdoe'; now the program has only
`jdoe' access.  Another swap brings `games' back to the effective user
ID and restores access to the scores file.

   In order to handle both kinds of systems, test for the saved user ID
feature with a preprocessor conditional, like this:

     #ifdef _POSIX_SAVED_IDS
       seteuid (user_user_id);
     #else
       setreuid (geteuid (), getuid ());
     #endif


File: libc.info,  Node: Setuid Program Example,  Next: Tips for Setuid,  Prev: Enable/Disable Setuid,  Up: Users and Groups

29.9 Setuid Program Example
===========================

Here's an example showing how to set up a program that changes its
effective user ID.

   This is part of a game program called `caber-toss' that manipulates
a file `scores' that should be writable only by the game program
itself.  The program assumes that its executable file will be installed
with the setuid bit set and owned by the same user as the `scores'
file.  Typically, a system administrator will set up an account like
`games' for this purpose.

   The executable file is given mode `4755', so that doing an `ls -l'
on it produces output like:

     -rwsr-xr-x   1 games    184422 Jul 30 15:17 caber-toss

The setuid bit shows up in the file modes as the `s'.

   The scores file is given mode `644', and doing an `ls -l' on it
shows:

     -rw-r--r--  1 games           0 Jul 31 15:33 scores

   Here are the parts of the program that show how to set up the changed
user ID.  This program is conditionalized so that it makes use of the
file IDs feature if it is supported, and otherwise uses `setreuid' to
swap the effective and real user IDs.

     #include <stdio.h>
     #include <sys/types.h>
     #include <unistd.h>
     #include <stdlib.h>


     /* Remember the effective and real UIDs. */

     static uid_t euid, ruid;


     /* Restore the effective UID to its original value. */

     void
     do_setuid (void)
     {
       int status;

     #ifdef _POSIX_SAVED_IDS
       status = seteuid (euid);
     #else
       status = setreuid (ruid, euid);
     #endif
       if (status < 0) {
         fprintf (stderr, "Couldn't set uid.\n");
         exit (status);
         }
     }


     /* Set the effective UID to the real UID. */

     void
     undo_setuid (void)
     {
       int status;

     #ifdef _POSIX_SAVED_IDS
       status = seteuid (ruid);
     #else
       status = setreuid (euid, ruid);
     #endif
       if (status < 0) {
         fprintf (stderr, "Couldn't set uid.\n");
         exit (status);
         }
     }

     /* Main program. */

     int
     main (void)
     {
       /* Remember the real and effective user IDs.  */
       ruid = getuid ();
       euid = geteuid ();
       undo_setuid ();

       /* Do the game and record the score.  */
       ...
     }

   Notice how the first thing the `main' function does is to set the
effective user ID back to the real user ID.  This is so that any other
file accesses that are performed while the user is playing the game use
the real user ID for determining permissions.  Only when the program
needs to open the scores file does it switch back to the file user ID,
like this:

     /* Record the score. */

     int
     record_score (int score)
     {
       FILE *stream;
       char *myname;

       /* Open the scores file. */
       do_setuid ();
       stream = fopen (SCORES_FILE, "a");
       undo_setuid ();

       /* Write the score to the file. */
       if (stream)
         {
           myname = cuserid (NULL);
           if (score < 0)
             fprintf (stream, "%10s: Couldn't lift the caber.\n", myname);
           else
             fprintf (stream, "%10s: %d feet.\n", myname, score);
           fclose (stream);
           return 0;
         }
       else
         return -1;
     }


File: libc.info,  Node: Tips for Setuid,  Next: Who Logged In,  Prev: Setuid Program Example,  Up: Users and Groups

29.10 Tips for Writing Setuid Programs
======================================

It is easy for setuid programs to give the user access that isn't
intended--in fact, if you want to avoid this, you need to be careful.
Here are some guidelines for preventing unintended access and
minimizing its consequences when it does occur:

   * Don't have `setuid' programs with privileged user IDs such as
     `root' unless it is absolutely necessary.  If the resource is
     specific to your particular program, it's better to define a new,
     nonprivileged user ID or group ID just to manage that resource.
     It's better if you can write your program to use a special group
     than a special user.

   * Be cautious about using the `exec' functions in combination with
     changing the effective user ID.  Don't let users of your program
     execute arbitrary programs under a changed user ID.  Executing a
     shell is especially bad news. Less obviously, the `execlp' and
     `execvp' functions are a potential risk (since the program they
     execute depends on the user's `PATH' environment variable).

     If you must `exec' another program under a changed ID, specify an
     absolute file name (*note File Name Resolution::) for the
     executable, and make sure that the protections on that executable
     and _all_ containing directories are such that ordinary users
     cannot replace it with some other program.

     You should also check the arguments passed to the program to make
     sure they do not have unexpected effects.  Likewise, you should
     examine the environment variables.  Decide which arguments and
     variables are safe, and reject all others.

     You should never use `system' in a privileged program, because it
     invokes a shell.

   * Only use the user ID controlling the resource in the part of the
     program that actually uses that resource.  When you're finished
     with it, restore the effective user ID back to the actual user's
     user ID.  *Note Enable/Disable Setuid::.

   * If the `setuid' part of your program needs to access other files
     besides the controlled resource, it should verify that the real
     user would ordinarily have permission to access those files.  You
     can use the `access' function (*note Access Permission::) to check
     this; it uses the real user and group IDs, rather than the
     effective IDs.


File: libc.info,  Node: Who Logged In,  Next: User Accounting Database,  Prev: Tips for Setuid,  Up: Users and Groups

29.11 Identifying Who Logged In
===============================

You can use the functions listed in this section to determine the login
name of the user who is running a process, and the name of the user who
logged in the current session.  See also the function `getuid' and
friends (*note Reading Persona::).  How this information is collected by
the system and how to control/add/remove information from the background
storage is described in *Note User Accounting Database::.

   The `getlogin' function is declared in `unistd.h', while `cuserid'
and `L_cuserid' are declared in `stdio.h'.  

 -- Function: char * getlogin (void)
     The `getlogin' function returns a pointer to a string containing
     the name of the user logged in on the controlling terminal of the
     process, or a null pointer if this information cannot be
     determined.  The string is statically allocated and might be
     overwritten on subsequent calls to this function or to `cuserid'.

 -- Function: char * cuserid (char *STRING)
     The `cuserid' function returns a pointer to a string containing a
     user name associated with the effective ID of the process.  If
     STRING is not a null pointer, it should be an array that can hold
     at least `L_cuserid' characters; the string is returned in this
     array.  Otherwise, a pointer to a string in a static area is
     returned.  This string is statically allocated and might be
     overwritten on subsequent calls to this function or to `getlogin'.

     The use of this function is deprecated since it is marked to be
     withdrawn in XPG4.2 and has already been removed from newer
     revisions of POSIX.1.

 -- Macro: int L_cuserid
     An integer constant that indicates how long an array you might
     need to store a user name.

   These functions let your program identify positively the user who is
running or the user who logged in this session.  (These can differ when
setuid programs are involved; see *Note Process Persona::.)  The user
cannot do anything to fool these functions.

   For most purposes, it is more useful to use the environment variable
`LOGNAME' to find out who the user is.  This is more flexible precisely
because the user can set `LOGNAME' arbitrarily.  *Note Standard
Environment::.


File: libc.info,  Node: User Accounting Database,  Next: User Database,  Prev: Who Logged In,  Up: Users and Groups

29.12 The User Accounting Database
==================================

Most Unix-like operating systems keep track of logged in users by
maintaining a user accounting database.  This user accounting database
stores for each terminal, who has logged on, at what time, the process
ID of the user's login shell, etc., etc., but also stores information
about the run level of the system, the time of the last system reboot,
and possibly more.

   The user accounting database typically lives in `/etc/utmp',
`/var/adm/utmp' or `/var/run/utmp'.  However, these files should
*never* be accessed directly.  For reading information from and writing
information to the user accounting database, the functions described in
this section should be used.

* Menu:

* Manipulating the Database::   Scanning and modifying the user
                                 accounting database.
* XPG Functions::               A standardized way for doing the same thing.
* Logging In and Out::          Functions from BSD that modify the user
                                 accounting database.


File: libc.info,  Node: Manipulating the Database,  Next: XPG Functions,  Up: User Accounting Database

29.12.1 Manipulating the User Accounting Database
-------------------------------------------------

These functions and the corresponding data structures are declared in
the header file `utmp.h'.  

 -- Data Type: struct exit_status
     The `exit_status' data structure is used to hold information about
     the exit status of processes marked as `DEAD_PROCESS' in the user
     accounting database.

    `short int e_termination'
          The exit status of the process.

    `short int e_exit'
          The exit status of the process.

 -- Data Type: struct utmp
     The `utmp' data structure is used to hold information about entries
     in the user accounting database.  On the GNU system it has the
     following members:

    `short int ut_type'
          Specifies the type of login; one of `EMPTY', `RUN_LVL',
          `BOOT_TIME', `OLD_TIME', `NEW_TIME', `INIT_PROCESS',
          `LOGIN_PROCESS', `USER_PROCESS', `DEAD_PROCESS' or
          `ACCOUNTING'.

    `pid_t ut_pid'
          The process ID number of the login process.

    `char ut_line[]'
          The device name of the tty (without `/dev/').

    `char ut_id[]'
          The inittab ID of the process.

    `char ut_user[]'
          The user's login name.

    `char ut_host[]'
          The name of the host from which the user logged in.

    `struct exit_status ut_exit'
          The exit status of a process marked as `DEAD_PROCESS'.

    `long ut_session'
          The Session ID, used for windowing.

    `struct timeval ut_tv'
          Time the entry was made.  For entries of type `OLD_TIME' this
          is the time when the system clock changed, and for entries of
          type `NEW_TIME' this is the time the system clock was set to.

    `int32_t ut_addr_v6[4]'
          The Internet address of a remote host.

   The `ut_type', `ut_pid', `ut_id', `ut_tv', and `ut_host' fields are
not available on all systems.  Portable applications therefore should
be prepared for these situations.  To help doing this the `utmp.h'
header provides macros `_HAVE_UT_TYPE', `_HAVE_UT_PID', `_HAVE_UT_ID',
`_HAVE_UT_TV', and `_HAVE_UT_HOST' if the respective field is
available.  The programmer can handle the situations by using `#ifdef'
in the program code.

   The following macros are defined for use as values for the `ut_type'
member of the `utmp' structure.  The values are integer constants.

`EMPTY'
     This macro is used to indicate that the entry contains no valid
     user accounting information.

`RUN_LVL'
     This macro is used to identify the systems runlevel.

`BOOT_TIME'
     This macro is used to identify the time of system boot.

`OLD_TIME'
     This macro is used to identify the time when the system clock
     changed.

`NEW_TIME'
     This macro is used to identify the time after the system changed.

`INIT_PROCESS'
     This macro is used to identify a process spawned by the init
     process.

`LOGIN_PROCESS'
     This macro is used to identify the session leader of a logged in
     user.

`USER_PROCESS'
     This macro is used to identify a user process.

`DEAD_PROCESS'
     This macro is used to identify a terminated process.

`ACCOUNTING'
     ???

   The size of the `ut_line', `ut_id', `ut_user' and `ut_host' arrays
can be found using the `sizeof' operator.

   Many older systems have, instead of an `ut_tv' member, an `ut_time'
member, usually of type `time_t', for representing the time associated
with the entry.  Therefore, for backwards compatibility only, `utmp.h'
defines `ut_time' as an alias for `ut_tv.tv_sec'.

 -- Function: void setutent (void)
     This function opens the user accounting database to begin scanning
     it.  You can then call `getutent', `getutid' or `getutline' to
     read entries and `pututline' to write entries.

     If the database is already open, it resets the input to the
     beginning of the database.

 -- Function: struct utmp * getutent (void)
     The `getutent' function reads the next entry from the user
     accounting database.  It returns a pointer to the entry, which is
     statically allocated and may be overwritten by subsequent calls to
     `getutent'.  You must copy the contents of the structure if you
     wish to save the information or you can use the `getutent_r'
     function which stores the data in a user-provided buffer.

     A null pointer is returned in case no further entry is available.

 -- Function: void endutent (void)
     This function closes the user accounting database.

 -- Function: struct utmp * getutid (const struct utmp *ID)
     This function searches forward from the current point in the
     database for an entry that matches ID.  If the `ut_type' member of
     the ID structure is one of `RUN_LVL', `BOOT_TIME', `OLD_TIME' or
     `NEW_TIME' the entries match if the `ut_type' members are
     identical.  If the `ut_type' member of the ID structure is
     `INIT_PROCESS', `LOGIN_PROCESS', `USER_PROCESS' or `DEAD_PROCESS',
     the entries match if the `ut_type' member of the entry read from
     the database is one of these four, and the `ut_id' members match.
     However if the `ut_id' member of either the ID structure or the
     entry read from the database is empty it checks if the `ut_line'
     members match instead.  If a matching entry is found, `getutid'
     returns a pointer to the entry, which is statically allocated, and
     may be overwritten by a subsequent call to `getutent', `getutid'
     or `getutline'.  You must copy the contents of the structure if
     you wish to save the information.

     A null pointer is returned in case the end of the database is
     reached without a match.

     The `getutid' function may cache the last read entry.  Therefore,
     if you are using `getutid' to search for multiple occurrences, it
     is necessary to zero out the static data after each call.
     Otherwise `getutid' could just return a pointer to the same entry
     over and over again.

 -- Function: struct utmp * getutline (const struct utmp *LINE)
     This function searches forward from the current point in the
     database until it finds an entry whose `ut_type' value is
     `LOGIN_PROCESS' or `USER_PROCESS', and whose `ut_line' member
     matches the `ut_line' member of the LINE structure.  If it finds
     such an entry, it returns a pointer to the entry which is
     statically allocated, and may be overwritten by a subsequent call
     to `getutent', `getutid' or `getutline'.  You must copy the
     contents of the structure if you wish to save the information.

     A null pointer is returned in case the end of the database is
     reached without a match.

     The `getutline' function may cache the last read entry.  Therefore
     if you are using `getutline' to search for multiple occurrences, it
     is necessary to zero out the static data after each call.
     Otherwise `getutline' could just return a pointer to the same
     entry over and over again.

 -- Function: struct utmp * pututline (const struct utmp *UTMP)
     The `pututline' function inserts the entry `*UTMP' at the
     appropriate place in the user accounting database.  If it finds
     that it is not already at the correct place in the database, it
     uses `getutid' to search for the position to insert the entry,
     however this will not modify the static structure returned by
     `getutent', `getutid' and `getutline'.  If this search fails, the
     entry is appended to the database.

     The `pututline' function returns a pointer to a copy of the entry
     inserted in the user accounting database, or a null pointer if the
     entry could not be added.  The following `errno' error conditions
     are defined for this function:

    `EPERM'
          The process does not have the appropriate privileges; you
          cannot modify the user accounting database.

   All the `get*' functions mentioned before store the information they
return in a static buffer.  This can be a problem in multi-threaded
programs since the data returned for the request is overwritten by the
return value data in another thread.  Therefore the GNU C Library
provides as extensions three more functions which return the data in a
user-provided buffer.

 -- Function: int getutent_r (struct utmp *BUFFER, struct utmp **RESULT)
     The `getutent_r' is equivalent to the `getutent' function.  It
     returns the next entry from the database.  But instead of storing
     the information in a static buffer it stores it in the buffer
     pointed to by the parameter BUFFER.

     If the call was successful, the function returns `0' and the
     pointer variable pointed to by the parameter RESULT contains a
     pointer to the buffer which contains the result (this is most
     probably the same value as BUFFER).  If something went wrong
     during the execution of `getutent_r' the function returns `-1'.

     This function is a GNU extension.

 -- Function: int getutid_r (const struct utmp *ID, struct utmp
          *BUFFER, struct utmp **RESULT)
     This function retrieves just like `getutid' the next entry matching
     the information stored in ID.  But the result is stored in the
     buffer pointed to by the parameter BUFFER.

     If successful the function returns `0' and the pointer variable
     pointed to by the parameter RESULT contains a pointer to the
     buffer with the result (probably the same as RESULT.  If not
     successful the function return `-1'.

     This function is a GNU extension.

 -- Function: int getutline_r (const struct utmp *LINE, struct utmp
          *BUFFER, struct utmp **RESULT)
     This function retrieves just like `getutline' the next entry
     matching the information stored in LINE.  But the result is stored
     in the buffer pointed to by the parameter BUFFER.

     If successful the function returns `0' and the pointer variable
     pointed to by the parameter RESULT contains a pointer to the
     buffer with the result (probably the same as RESULT.  If not
     successful the function return `-1'.

     This function is a GNU extension.

   In addition to the user accounting database, most systems keep a
number of similar databases.  For example most systems keep a log file
with all previous logins (usually in `/etc/wtmp' or `/var/log/wtmp').

   For specifying which database to examine, the following function
should be used.

 -- Function: int utmpname (const char *FILE)
     The `utmpname' function changes the name of the database to be
     examined to FILE, and closes any previously opened database.  By
     default `getutent', `getutid', `getutline' and `pututline' read
     from and write to the user accounting database.

     The following macros are defined for use as the FILE argument:

      -- Macro: char * _PATH_UTMP
          This macro is used to specify the user accounting database.

      -- Macro: char * _PATH_WTMP
          This macro is used to specify the user accounting log file.

     The `utmpname' function returns a value of `0' if the new name was
     successfully stored, and a value of `-1' to indicate an error.
     Note that `utmpname' does not try to open the database, and that
     therefore the return value does not say anything about whether the
     database can be successfully opened.

   Specially for maintaining log-like databases the GNU C Library
provides the following function:

 -- Function: void updwtmp (const char *WTMP_FILE, const struct utmp
          *UTMP)
     The `updwtmp' function appends the entry *UTMP to the database
     specified by WTMP_FILE.  For possible values for the WTMP_FILE
     argument see the `utmpname' function.

   *Portability Note:* Although many operating systems provide a subset
of these functions, they are not standardized.  There are often subtle
differences in the return types, and there are considerable differences
between the various definitions of `struct utmp'.  When programming for
the GNU system, it is probably best to stick with the functions
described in this section.  If however, you want your program to be
portable, consider using the XPG functions described in *Note XPG
Functions::, or take a look at the BSD compatible functions in *Note
Logging In and Out::.


File: libc.info,  Node: XPG Functions,  Next: Logging In and Out,  Prev: Manipulating the Database,  Up: User Accounting Database

29.12.2 XPG User Accounting Database Functions
----------------------------------------------

These functions, described in the X/Open Portability Guide, are declared
in the header file `utmpx.h'.  

 -- Data Type: struct utmpx
     The `utmpx' data structure contains at least the following members:

    `short int ut_type'
          Specifies the type of login; one of `EMPTY', `RUN_LVL',
          `BOOT_TIME', `OLD_TIME', `NEW_TIME', `INIT_PROCESS',
          `LOGIN_PROCESS', `USER_PROCESS' or `DEAD_PROCESS'.

    `pid_t ut_pid'
          The process ID number of the login process.

    `char ut_line[]'
          The device name of the tty (without `/dev/').

    `char ut_id[]'
          The inittab ID of the process.

    `char ut_user[]'
          The user's login name.

    `struct timeval ut_tv'
          Time the entry was made.  For entries of type `OLD_TIME' this
          is the time when the system clock changed, and for entries of
          type `NEW_TIME' this is the time the system clock was set to.
     On the GNU system, `struct utmpx' is identical to `struct utmp'
     except for the fact that including `utmpx.h' does not make visible
     the declaration of `struct exit_status'.

   The following macros are defined for use as values for the `ut_type'
member of the `utmpx' structure.  The values are integer constants and
are, on the GNU system, identical to the definitions in `utmp.h'.

`EMPTY'
     This macro is used to indicate that the entry contains no valid
     user accounting information.

`RUN_LVL'
     This macro is used to identify the systems runlevel.

`BOOT_TIME'
     This macro is used to identify the time of system boot.

`OLD_TIME'
     This macro is used to identify the time when the system clock
     changed.

`NEW_TIME'
     This macro is used to identify the time after the system changed.

`INIT_PROCESS'
     This macro is used to identify a process spawned by the init
     process.

`LOGIN_PROCESS'
     This macro is used to identify the session leader of a logged in
     user.

`USER_PROCESS'
     This macro is used to identify a user process.

`DEAD_PROCESS'
     This macro is used to identify a terminated process.

   The size of the `ut_line', `ut_id' and `ut_user' arrays can be found
using the `sizeof' operator.

 -- Function: void setutxent (void)
     This function is similar to `setutent'.  On the GNU system it is
     simply an alias for `setutent'.

 -- Function: struct utmpx * getutxent (void)
     The `getutxent' function is similar to `getutent', but returns a
     pointer to a `struct utmpx' instead of `struct utmp'.  On the GNU
     system it simply is an alias for `getutent'.

 -- Function: void endutxent (void)
     This function is similar to `endutent'.  On the GNU system it is
     simply an alias for `endutent'.

 -- Function: struct utmpx * getutxid (const struct utmpx *ID)
     This function is similar to `getutid', but uses `struct utmpx'
     instead of `struct utmp'.  On the GNU system it is simply an alias
     for `getutid'.

 -- Function: struct utmpx * getutxline (const struct utmpx *LINE)
     This function is similar to `getutid', but uses `struct utmpx'
     instead of `struct utmp'.  On the GNU system it is simply an alias
     for `getutline'.

 -- Function: struct utmpx * pututxline (const struct utmpx *UTMP)
     The `pututxline' function is functionally identical to
     `pututline', but uses `struct utmpx' instead of `struct utmp'.  On
     the GNU system, `pututxline' is simply an alias for `pututline'.

 -- Function: int utmpxname (const char *FILE)
     The `utmpxname' function is functionally identical to `utmpname'.
     On the GNU system, `utmpxname' is simply an alias for `utmpname'.

   You can translate between a traditional `struct utmp' and an XPG
`struct utmpx' with the following functions.  On the GNU system, these
functions are merely copies, since the two structures are identical.

 -- Function: int getutmp (const struct utmpx *utmpx, struct utmp *utmp)
     `getutmp' copies the information, insofar as the structures are
     compatible, from UTMPX to UTMP.

 -- Function: int getutmpx (const struct utmp *utmp, struct utmpx
          *utmpx)
     `getutmpx' copies the information, insofar as the structures are
     compatible, from UTMP to UTMPX.


File: libc.info,  Node: Logging In and Out,  Prev: XPG Functions,  Up: User Accounting Database

29.12.3 Logging In and Out
--------------------------

These functions, derived from BSD, are available in the separate
`libutil' library, and declared in `utmp.h'.  

   Note that the `ut_user' member of `struct utmp' is called `ut_name'
in BSD.  Therefore, `ut_name' is defined as an alias for `ut_user' in
`utmp.h'.

 -- Function: int login_tty (int FILEDES)
     This function makes FILEDES the controlling terminal of the
     current process, redirects standard input, standard output and
     standard error output to this terminal, and closes FILEDES.

     This function returns `0' on successful completion, and `-1' on
     error.

 -- Function: void login (const struct utmp *ENTRY)
     The `login' functions inserts an entry into the user accounting
     database.  The `ut_line' member is set to the name of the terminal
     on standard input.  If standard input is not a terminal `login'
     uses standard output or standard error output to determine the
     name of the terminal.  If `struct utmp' has a `ut_type' member,
     `login' sets it to `USER_PROCESS', and if there is an `ut_pid'
     member, it will be set to the process ID of the current process.
     The remaining entries are copied from ENTRY.

     A copy of the entry is written to the user accounting log file.

 -- Function: int logout (const char *UT_LINE)
     This function modifies the user accounting database to indicate
     that the user on UT_LINE has logged out.

     The `logout' function returns `1' if the entry was successfully
     written to the database, or `0' on error.

 -- Function: void logwtmp (const char *UT_LINE, const char *UT_NAME,
          const char *UT_HOST)
     The `logwtmp' function appends an entry to the user accounting log
     file, for the current time and the information provided in the
     UT_LINE, UT_NAME and UT_HOST arguments.

   *Portability Note:* The BSD `struct utmp' only has the `ut_line',
`ut_name', `ut_host' and `ut_time' members.  Older systems do not even
have the `ut_host' member.


File: libc.info,  Node: User Database,  Next: Group Database,  Prev: User Accounting Database,  Up: Users and Groups

29.13 User Database
===================

This section describes how to search and scan the database of registered
users.  The database itself is kept in the file `/etc/passwd' on most
systems, but on some systems a special network server gives access to
it.

* Menu:

* User Data Structure::         What each user record contains.
* Lookup User::                 How to look for a particular user.
* Scanning All Users::          Scanning the list of all users, one by one.
* Writing a User Entry::        How a program can rewrite a user's record.


File: libc.info,  Node: User Data Structure,  Next: Lookup User,  Up: User Database

29.13.1 The Data Structure that Describes a User
------------------------------------------------

The functions and data structures for accessing the system user database
are declared in the header file `pwd.h'.  

 -- Data Type: struct passwd
     The `passwd' data structure is used to hold information about
     entries in the system user data base.  It has at least the
     following members:

    `char *pw_name'
          The user's login name.

    `char *pw_passwd.'
          The encrypted password string.

    `uid_t pw_uid'
          The user ID number.

    `gid_t pw_gid'
          The user's default group ID number.

    `char *pw_gecos'
          A string typically containing the user's real name, and
          possibly other information such as a phone number.

    `char *pw_dir'
          The user's home directory, or initial working directory.
          This might be a null pointer, in which case the
          interpretation is system-dependent.

    `char *pw_shell'
          The user's default shell, or the initial program run when the
          user logs in.  This might be a null pointer, indicating that
          the system default should be used.


File: libc.info,  Node: Lookup User,  Next: Scanning All Users,  Prev: User Data Structure,  Up: User Database

29.13.2 Looking Up One User
---------------------------

You can search the system user database for information about a
specific user using `getpwuid' or `getpwnam'.  These functions are
declared in `pwd.h'.

 -- Function: struct passwd * getpwuid (uid_t UID)
     This function returns a pointer to a statically-allocated structure
     containing information about the user whose user ID is UID.  This
     structure may be overwritten on subsequent calls to `getpwuid'.

     A null pointer value indicates there is no user in the data base
     with user ID UID.

 -- Function: int getpwuid_r (uid_t UID, struct passwd *RESULT_BUF,
          char *BUFFER, size_t BUFLEN, struct passwd **RESULT)
     This function is similar to `getpwuid' in that it returns
     information about the user whose user ID is UID.  However, it
     fills the user supplied structure pointed to by RESULT_BUF with
     the information instead of using a static buffer.  The first
     BUFLEN bytes of the additional buffer pointed to by BUFFER are
     used to contain additional information, normally strings which are
     pointed to by the elements of the result structure.

     If a user with ID UID is found, the pointer returned in RESULT
     points to the record which contains the wanted data (i.e., RESULT
     contains the value RESULT_BUF).  If no user is found or if an
     error occurred, the pointer returned in RESULT is a null pointer.
     The function returns zero or an error code.  If the buffer BUFFER
     is too small to contain all the needed information, the error code
     `ERANGE' is returned and ERRNO is set to `ERANGE'.

 -- Function: struct passwd * getpwnam (const char *NAME)
     This function returns a pointer to a statically-allocated structure
     containing information about the user whose user name is NAME.
     This structure may be overwritten on subsequent calls to
     `getpwnam'.

     A null pointer return indicates there is no user named NAME.

 -- Function: int getpwnam_r (const char *NAME, struct passwd
          *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd
          **RESULT)
     This function is similar to `getpwnam' in that is returns
     information about the user whose user name is NAME.  However, like
     `getpwuid_r', it fills the user supplied buffers in RESULT_BUF and
     BUFFER with the information instead of using a static buffer.

     The return values are the same as for `getpwuid_r'.


File: libc.info,  Node: Scanning All Users,  Next: Writing a User Entry,  Prev: Lookup User,  Up: User Database

29.13.3 Scanning the List of All Users
--------------------------------------

This section explains how a program can read the list of all users in
the system, one user at a time.  The functions described here are
declared in `pwd.h'.

   You can use the `fgetpwent' function to read user entries from a
particular file.

 -- Function: struct passwd * fgetpwent (FILE *STREAM)
     This function reads the next user entry from STREAM and returns a
     pointer to the entry.  The structure is statically allocated and is
     rewritten on subsequent calls to `fgetpwent'.  You must copy the
     contents of the structure if you wish to save the information.

     The stream must correspond to a file in the same format as the
     standard password database file.

 -- Function: int fgetpwent_r (FILE *STREAM, struct passwd *RESULT_BUF,
          char *BUFFER, size_t BUFLEN, struct passwd **RESULT)
     This function is similar to `fgetpwent' in that it reads the next
     user entry from STREAM.  But the result is returned in the
     structure pointed to by RESULT_BUF.  The first BUFLEN bytes of the
     additional buffer pointed to by BUFFER are used to contain
     additional information, normally strings which are pointed to by
     the elements of the result structure.

     The stream must correspond to a file in the same format as the
     standard password database file.

     If the function returns zero RESULT points to the structure with
     the wanted data (normally this is in RESULT_BUF).  If errors
     occurred the return value is nonzero and RESULT contains a null
     pointer.

   The way to scan all the entries in the user database is with
`setpwent', `getpwent', and `endpwent'.

 -- Function: void setpwent (void)
     This function initializes a stream which `getpwent' and
     `getpwent_r' use to read the user database.

 -- Function: struct passwd * getpwent (void)
     The `getpwent' function reads the next entry from the stream
     initialized by `setpwent'.  It returns a pointer to the entry.  The
     structure is statically allocated and is rewritten on subsequent
     calls to `getpwent'.  You must copy the contents of the structure
     if you wish to save the information.

     A null pointer is returned when no more entries are available.

 -- Function: int getpwent_r (struct passwd *RESULT_BUF, char *BUFFER,
          int BUFLEN, struct passwd **RESULT)
     This function is similar to `getpwent' in that it returns the next
     entry from the stream initialized by `setpwent'.  Like
     `fgetpwent_r', it uses the user-supplied buffers in RESULT_BUF and
     BUFFER to return the information requested.

     The return values are the same as for `fgetpwent_r'.


 -- Function: void endpwent (void)
     This function closes the internal stream used by `getpwent' or
     `getpwent_r'.


File: libc.info,  Node: Writing a User Entry,  Prev: Scanning All Users,  Up: User Database

29.13.4 Writing a User Entry
----------------------------

 -- Function: int putpwent (const struct passwd *P, FILE *STREAM)
     This function writes the user entry `*P' to the stream STREAM, in
     the format used for the standard user database file.  The return
     value is zero on success and nonzero on failure.

     This function exists for compatibility with SVID.  We recommend
     that you avoid using it, because it makes sense only on the
     assumption that the `struct passwd' structure has no members
     except the standard ones; on a system which merges the traditional
     Unix data base with other extended information about users, adding
     an entry using this function would inevitably leave out much of
     the important information.

     The group and user ID fields are left empty if the group or user
     name starts with a - or +.

     The function `putpwent' is declared in `pwd.h'.


File: libc.info,  Node: Group Database,  Next: Database Example,  Prev: User Database,  Up: Users and Groups

29.14 Group Database
====================

This section describes how to search and scan the database of
registered groups.  The database itself is kept in the file
`/etc/group' on most systems, but on some systems a special network
service provides access to it.

* Menu:

* Group Data Structure::        What each group record contains.
* Lookup Group::                How to look for a particular group.
* Scanning All Groups::         Scanning the list of all groups.


File: libc.info,  Node: Group Data Structure,  Next: Lookup Group,  Up: Group Database

29.14.1 The Data Structure for a Group
--------------------------------------

The functions and data structures for accessing the system group
database are declared in the header file `grp.h'.  

 -- Data Type: struct group
     The `group' structure is used to hold information about an entry in
     the system group database.  It has at least the following members:

    `char *gr_name'
          The name of the group.

    `gid_t gr_gid'
          The group ID of the group.

    `char **gr_mem'
          A vector of pointers to the names of users in the group.
          Each user name is a null-terminated string, and the vector
          itself is terminated by a null pointer.


File: libc.info,  Node: Lookup Group,  Next: Scanning All Groups,  Prev: Group Data Structure,  Up: Group Database

29.14.2 Looking Up One Group
----------------------------

You can search the group database for information about a specific
group using `getgrgid' or `getgrnam'.  These functions are declared in
`grp.h'.

 -- Function: struct group * getgrgid (gid_t GID)
     This function returns a pointer to a statically-allocated structure
     containing information about the group whose group ID is GID.
     This structure may be overwritten by subsequent calls to
     `getgrgid'.

     A null pointer indicates there is no group with ID GID.

 -- Function: int getgrgid_r (gid_t GID, struct group *RESULT_BUF, char
          *BUFFER, size_t BUFLEN, struct group **RESULT)
     This function is similar to `getgrgid' in that it returns
     information about the group whose group ID is GID.  However, it
     fills the user supplied structure pointed to by RESULT_BUF with
     the information instead of using a static buffer.  The first
     BUFLEN bytes of the additional buffer pointed to by BUFFER are
     used to contain additional information, normally strings which are
     pointed to by the elements of the result structure.

     If a group with ID GID is found, the pointer returned in RESULT
     points to the record which contains the wanted data (i.e., RESULT
     contains the value RESULT_BUF).  If no group is found or if an
     error occurred, the pointer returned in RESULT is a null pointer.
     The function returns zero or an error code.  If the buffer BUFFER
     is too small to contain all the needed information, the error code
     `ERANGE' is returned and ERRNO is set to `ERANGE'.

 -- Function: struct group * getgrnam (const char *NAME)
     This function returns a pointer to a statically-allocated structure
     containing information about the group whose group name is NAME.
     This structure may be overwritten by subsequent calls to
     `getgrnam'.

     A null pointer indicates there is no group named NAME.

 -- Function: int getgrnam_r (const char *NAME, struct group
          *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group
          **RESULT)
     This function is similar to `getgrnam' in that is returns
     information about the group whose group name is NAME.  Like
     `getgrgid_r', it uses the user supplied buffers in RESULT_BUF and
     BUFFER, not a static buffer.

     The return values are the same as for `getgrgid_r' `ERANGE'.


File: libc.info,  Node: Scanning All Groups,  Prev: Lookup Group,  Up: Group Database

29.14.3 Scanning the List of All Groups
---------------------------------------

This section explains how a program can read the list of all groups in
the system, one group at a time.  The functions described here are
declared in `grp.h'.

   You can use the `fgetgrent' function to read group entries from a
particular file.

 -- Function: struct group * fgetgrent (FILE *STREAM)
     The `fgetgrent' function reads the next entry from STREAM.  It
     returns a pointer to the entry.  The structure is statically
     allocated and is overwritten on subsequent calls to `fgetgrent'.
     You must copy the contents of the structure if you wish to save the
     information.

     The stream must correspond to a file in the same format as the
     standard group database file.

 -- Function: int fgetgrent_r (FILE *STREAM, struct group *RESULT_BUF,
          char *BUFFER, size_t BUFLEN, struct group **RESULT)
     This function is similar to `fgetgrent' in that it reads the next
     user entry from STREAM.  But the result is returned in the
     structure pointed to by RESULT_BUF.  The first BUFLEN bytes of the
     additional buffer pointed to by BUFFER are used to contain
     additional information, normally strings which are pointed to by
     the elements of the result structure.

     This stream must correspond to a file in the same format as the
     standard group database file.

     If the function returns zero RESULT points to the structure with
     the wanted data (normally this is in RESULT_BUF).  If errors
     occurred the return value is non-zero and RESULT contains a null
     pointer.

   The way to scan all the entries in the group database is with
`setgrent', `getgrent', and `endgrent'.

 -- Function: void setgrent (void)
     This function initializes a stream for reading from the group data
     base.  You use this stream by calling `getgrent' or `getgrent_r'.

 -- Function: struct group * getgrent (void)
     The `getgrent' function reads the next entry from the stream
     initialized by `setgrent'.  It returns a pointer to the entry.  The
     structure is statically allocated and is overwritten on subsequent
     calls to `getgrent'.  You must copy the contents of the structure
     if you wish to save the information.

 -- Function: int getgrent_r (struct group *RESULT_BUF, char *BUFFER,
          size_t BUFLEN, struct group **RESULT)
     This function is similar to `getgrent' in that it returns the next
     entry from the stream initialized by `setgrent'.  Like
     `fgetgrent_r', it places the result in user-supplied buffers
     pointed to RESULT_BUF and BUFFER.

     If the function returns zero RESULT contains a pointer to the data
     (normally equal to RESULT_BUF).  If errors occurred the return
     value is non-zero and RESULT contains a null pointer.

 -- Function: void endgrent (void)
     This function closes the internal stream used by `getgrent' or
     `getgrent_r'.


File: libc.info,  Node: Database Example,  Next: Netgroup Database,  Prev: Group Database,  Up: Users and Groups

29.15 User and Group Database Example
=====================================

Here is an example program showing the use of the system database
inquiry functions.  The program prints some information about the user
running the program.

     #include <grp.h>
     #include <pwd.h>
     #include <sys/types.h>
     #include <unistd.h>
     #include <stdlib.h>

     int
     main (void)
     {
       uid_t me;
       struct passwd *my_passwd;
       struct group *my_group;
       char **members;

       /* Get information about the user ID. */
       me = getuid ();
       my_passwd = getpwuid (me);
       if (!my_passwd)
         {
           printf ("Couldn't find out about user %d.\n", (int) me);
           exit (EXIT_FAILURE);
         }

       /* Print the information. */
       printf ("I am %s.\n", my_passwd->pw_gecos);
       printf ("My login name is %s.\n", my_passwd->pw_name);
       printf ("My uid is %d.\n", (int) (my_passwd->pw_uid));
       printf ("My home directory is %s.\n", my_passwd->pw_dir);
       printf ("My default shell is %s.\n", my_passwd->pw_shell);

       /* Get information about the default group ID. */
       my_group = getgrgid (my_passwd->pw_gid);
       if (!my_group)
         {
           printf ("Couldn't find out about group %d.\n",
                   (int) my_passwd->pw_gid);
           exit (EXIT_FAILURE);
         }

       /* Print the information. */
       printf ("My default group is %s (%d).\n",
               my_group->gr_name, (int) (my_passwd->pw_gid));
       printf ("The members of this group are:\n");
       members = my_group->gr_mem;
       while (*members)
         {
           printf ("  %s\n", *(members));
           members++;
         }

       return EXIT_SUCCESS;
     }

   Here is some output from this program:

     I am Throckmorton Snurd.
     My login name is snurd.
     My uid is 31093.
     My home directory is /home/fsg/snurd.
     My default shell is /bin/sh.
     My default group is guest (12).
     The members of this group are:
       friedman
       tami


File: libc.info,  Node: Netgroup Database,  Prev: Database Example,  Up: Users and Groups

29.16 Netgroup Database
=======================

* Menu:

* Netgroup Data::                  Data in the Netgroup database and where
                                   it comes from.
* Lookup Netgroup::                How to look for a particular netgroup.
* Netgroup Membership::            How to test for netgroup membership.


File: libc.info,  Node: Netgroup Data,  Next: Lookup Netgroup,  Up: Netgroup Database

29.16.1 Netgroup Data
---------------------

Sometimes it is useful to group users according to other criteria
(*note Group Database::).  E.g., it is useful to associate a certain
group of users with a certain machine.  On the other hand grouping of
host names is not supported so far.

   In Sun Microsystems SunOS appeared a new kind of database, the
netgroup database.  It allows grouping hosts, users, and domains
freely, giving them individual names.  To be more concrete, a netgroup
is a list of triples consisting of a host name, a user name, and a
domain name where any of the entries can be a wildcard entry matching
all inputs.  A last possibility is that names of other netgroups can
also be given in the list specifying a netgroup.  So one can construct
arbitrary hierarchies without loops.

   Sun's implementation allows netgroups only for the `nis' or
`nisplus' service, *note Services in the NSS configuration::.  The
implementation in the GNU C library has no such restriction.  An entry
in either of the input services must have the following form:

     GROUPNAME ( GROUPNAME | `('HOSTNAME`,'USERNAME`,'`domainname'`)' )+

   Any of the fields in the triple can be empty which means anything
matches.  While describing the functions we will see that the opposite
case is useful as well.  I.e., there may be entries which will not
match any input.  For entries like this, a name consisting of the single
character `-' shall be used.


File: libc.info,  Node: Lookup Netgroup,  Next: Netgroup Membership,  Prev: Netgroup Data,  Up: Netgroup Database

29.16.2 Looking up one Netgroup
-------------------------------

The lookup functions for netgroups are a bit different to all other
system database handling functions.  Since a single netgroup can contain
many entries a two-step process is needed.  First a single netgroup is
selected and then one can iterate over all entries in this netgroup.
These functions are declared in `netdb.h'.

 -- Function: int setnetgrent (const char *NETGROUP)
     A call to this function initializes the internal state of the
     library to allow following calls of the `getnetgrent' to iterate
     over all entries in the netgroup with name NETGROUP.

     When the call is successful (i.e., when a netgroup with this name
     exists) the return value is `1'.  When the return value is `0' no
     netgroup of this name is known or some other error occurred.

   It is important to remember that there is only one single state for
iterating the netgroups.  Even if the programmer uses the
`getnetgrent_r' function the result is not really reentrant since
always only one single netgroup at a time can be processed.  If the
program needs to process more than one netgroup simultaneously she must
protect this by using external locking.  This problem was introduced in
the original netgroups implementation in SunOS and since we must stay
compatible it is not possible to change this.

   Some other functions also use the netgroups state.  Currently these
are the `innetgr' function and parts of the implementation of the
`compat' service part of the NSS implementation.

 -- Function: int getnetgrent (char **HOSTP, char **USERP, char
          **DOMAINP)
     This function returns the next unprocessed entry of the currently
     selected netgroup.  The string pointers, in which addresses are
     passed in the arguments HOSTP, USERP, and DOMAINP, will contain
     after a successful call pointers to appropriate strings.  If the
     string in the next entry is empty the pointer has the value `NULL'.
     The returned string pointers are only valid if none of the netgroup
     related functions are called.

     The return value is `1' if the next entry was successfully read.  A
     value of `0' means no further entries exist or internal errors
     occurred.

 -- Function: int getnetgrent_r (char **HOSTP, char **USERP, char
          **DOMAINP, char *BUFFER, int BUFLEN)
     This function is similar to `getnetgrent' with only one exception:
     the strings the three string pointers HOSTP, USERP, and DOMAINP
     point to, are placed in the buffer of BUFLEN bytes starting at
     BUFFER.  This means the returned values are valid even after other
     netgroup related functions are called.

     The return value is `1' if the next entry was successfully read and
     the buffer contains enough room to place the strings in it.  `0' is
     returned in case no more entries are found, the buffer is too
     small, or internal errors occurred.

     This function is a GNU extension.  The original implementation in
     the SunOS libc does not provide this function.

 -- Function: void endnetgrent (void)
     This function frees all buffers which were allocated to process
     the last selected netgroup.  As a result all string pointers
     returned by calls to `getnetgrent' are invalid afterwards.


File: libc.info,  Node: Netgroup Membership,  Prev: Lookup Netgroup,  Up: Netgroup Database

29.16.3 Testing for Netgroup Membership
---------------------------------------

It is often not necessary to scan the whole netgroup since often the
only interesting question is whether a given entry is part of the
selected netgroup.

 -- Function: int innetgr (const char *NETGROUP, const char *HOST,
          const char *USER, const char *DOMAIN)
     This function tests whether the triple specified by the parameters
     HOSTP, USERP, and DOMAINP is part of the netgroup NETGROUP.  Using
     this function has the advantage that

       1. no other netgroup function can use the global netgroup state
          since internal locking is used and

       2. the function is implemented more efficiently than successive
          calls to the other `set'/`get'/`endnetgrent' functions.

     Any of the pointers HOSTP, USERP, and DOMAINP can be `NULL' which
     means any value is accepted in this position.  This is also true
     for the name `-' which should not match any other string otherwise.

     The return value is `1' if an entry matching the given triple is
     found in the netgroup.  The return value is `0' if the netgroup
     itself is not found, the netgroup does not contain the triple or
     internal errors occurred.


File: libc.info,  Node: System Management,  Next: System Configuration,  Prev: Users and Groups,  Up: Top

30 System Management
********************

This chapter describes facilities for controlling the system that
underlies a process (including the operating system and hardware) and
for getting information about it.  Anyone can generally use the
informational facilities, but usually only a properly privileged process
can make changes.

* Menu:

* Host Identification::         Determining the name of the machine.
* Platform Type::               Determining operating system and basic
                                  machine type
* Filesystem Handling::         Controlling/querying mounts
* System Parameters::           Getting and setting various system parameters

   To get information on parameters of the system that are built into
the system, such as the maximum length of a filename, *Note System
Configuration::.


File: libc.info,  Node: Host Identification,  Next: Platform Type,  Up: System Management

30.1 Host Identification
========================

This section explains how to identify the particular system on which
your program is running.  First, let's review the various ways computer
systems are named, which is a little complicated because of the history
of the development of the Internet.

   Every Unix system (also known as a host) has a host name, whether
it's connected to a network or not.  In its simplest form, as used
before computer networks were an issue, it's just a word like `chicken'.  

   But any system attached to the Internet or any network like it
conforms to a more rigorous naming convention as part of the Domain
Name System (DNS).  In DNS, every host name is composed of two parts: 

  1. hostname 

  2. domain name 

   You will note that "hostname" looks a lot like "host name", but is
not the same thing, and that people often incorrectly refer to entire
host names as "domain names."

   In DNS, the full host name is properly called the FQDN (Fully
Qualified Domain Name) and consists of the hostname, then a period,
then the domain name.  The domain name itself usually has multiple
components separated by periods.  So for example, a system's hostname
may be `chicken' and its domain name might be `ai.mit.edu', so its FQDN
(which is its host name) is `chicken.ai.mit.edu'.  

   Adding to the confusion, though, is that DNS is not the only name
space in which a computer needs to be known.  Another name space is the
NIS (aka YP) name space.  For NIS purposes, there is another domain
name, which is called the NIS domain name or the YP domain name.  It
need not have anything to do with the DNS domain name.  

   Confusing things even more is the fact that in DNS, it is possible
for multiple FQDNs to refer to the same system.  However, there is
always exactly one of them that is the true host name, and it is called
the canonical FQDN.

   In some contexts, the host name is called a "node name."

   For more information on DNS host naming, see *Note Host Names::.

   Prototypes for these functions appear in `unistd.h'.

   The programs `hostname', `hostid', and `domainname' work by calling
these functions.

 -- Function: int gethostname (char *NAME, size_t SIZE)
     This function returns the host name of the system on which it is
     called, in the array NAME.  The SIZE argument specifies the size of
     this array, in bytes.  Note that this is _not_ the DNS hostname.
     If the system participates in DNS, this is the FQDN (see above).

     The return value is `0' on success and `-1' on failure.  In the
     GNU C library, `gethostname' fails if SIZE is not large enough;
     then you can try again with a larger array.  The following `errno'
     error condition is defined for this function:

    `ENAMETOOLONG'
          The SIZE argument is less than the size of the host name plus
          one.

     On some systems, there is a symbol for the maximum possible host
     name length: `MAXHOSTNAMELEN'.  It is defined in `sys/param.h'.
     But you can't count on this to exist, so it is cleaner to handle
     failure and try again.

     `gethostname' stores the beginning of the host name in NAME even
     if the host name won't entirely fit.  For some purposes, a
     truncated host name is good enough.  If it is, you can ignore the
     error code.

 -- Function: int sethostname (const char *NAME, size_t LENGTH)
     The `sethostname' function sets the host name of the system that
     calls it to NAME, a string with length LENGTH.  Only privileged
     processes are permitted to do this.

     Usually `sethostname' gets called just once, at system boot time.
     Often, the program that calls it sets it to the value it finds in
     the file `/etc/hostname'.  

     Be sure to set the host name to the full host name, not just the
     DNS hostname (see above).

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error condition is defined for this function:

    `EPERM'
          This process cannot set the host name because it is not
          privileged.

 -- Function: int getdomainnname (char *NAME, size_t LENGTH)
     `getdomainname' returns the NIS (aka YP) domain name of the system
     on which it is called.  Note that this is not the more popular DNS
     domain name.  Get that with `gethostname'.

     The specifics of this function are analogous to `gethostname',
     above.


 -- Function: int setdomainname (const char *NAME, size_t LENGTH)
     `getdomainname' sets the NIS (aka YP) domain name of the system on
     which it is called.  Note that this is not the more popular DNS
     domain name.  Set that with `sethostname'.

     The specifics of this function are analogous to `sethostname',
     above.


 -- Function: long int gethostid (void)
     This function returns the "host ID" of the machine the program is
     running on.  By convention, this is usually the primary Internet
     IP address of that machine, converted to a `long int'.  However,
     on some systems it is a meaningless but unique number which is
     hard-coded for each machine.

     This is not widely used.  It arose in BSD 4.2, but was dropped in
     BSD 4.4.  It is not required by POSIX.

     The proper way to query the IP address is to use `gethostbyname'
     on the results of `gethostname'.  For more information on IP
     addresses, *Note Host Addresses::.

 -- Function: int sethostid (long int ID)
     The `sethostid' function sets the "host ID" of the host machine to
     ID.  Only privileged processes are permitted to do this.  Usually
     it happens just once, at system boot time.

     The proper way to establish the primary IP address of a system is
     to configure the IP address resolver to associate that IP address
     with the system's host name as returned by `gethostname'.  For
     example, put a record for the system in `/etc/hosts'.

     See `gethostid' above for more information on host ids.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EPERM'
          This process cannot set the host name because it is not
          privileged.

    `ENOSYS'
          The operating system does not support setting the host ID.
          On some systems, the host ID is a meaningless but unique
          number hard-coded for each machine.


File: libc.info,  Node: Platform Type,  Next: Filesystem Handling,  Prev: Host Identification,  Up: System Management

30.2 Platform Type Identification
=================================

You can use the `uname' function to find out some information about the
type of computer your program is running on.  This function and the
associated data type are declared in the header file `sys/utsname.h'.  

   As a bonus, `uname' also gives some information identifying the
particular system your program is running on.  This is the same
information which you can get with functions targetted to this purpose
described in *Note Host Identification::.

 -- Data Type: struct utsname
     The `utsname' structure is used to hold information returned by
     the `uname' function.  It has the following members:

    `char sysname[]'
          This is the name of the operating system in use.

    `char release[]'
          This is the current release level of the operating system
          implementation.

    `char version[]'
          This is the current version level within the release of the
          operating system.

    `char machine[]'
          This is a description of the type of hardware that is in use.

          Some systems provide a mechanism to interrogate the kernel
          directly for this information.  On systems without such a
          mechanism, the GNU C library fills in this field based on the
          configuration name that was specified when building and
          installing the library.

          GNU uses a three-part name to describe a system
          configuration; the three parts are CPU, MANUFACTURER and
          SYSTEM-TYPE, and they are separated with dashes.  Any
          possible combination of three names is potentially
          meaningful, but most such combinations are meaningless in
          practice and even the meaningful ones are not necessarily
          supported by any particular GNU program.

          Since the value in `machine' is supposed to describe just the
          hardware, it consists of the first two parts of the
          configuration name: `CPU-MANUFACTURER'.  For example, it
          might be one of these:

               `"sparc-sun"', `"i386-ANYTHING"', `"m68k-hp"',
               `"m68k-sony"', `"m68k-sun"', `"mips-dec"'

    `char nodename[]'
          This is the host name of this particular computer.  In the
          GNU C library, the value is the same as that returned by
          `gethostname'; see *Note Host Identification::.

          gethostname() is implemented with a call to uname().

    `char domainname[]'
          This is the NIS or YP domain name.  It is the same value
          returned by `getdomainname'; see *Note Host Identification::.
          This element is a relatively recent invention and use of it
          is not as portable as use of the rest of the structure.


 -- Function: int uname (struct utsname *INFO)
     The `uname' function fills in the structure pointed to by INFO
     with information about the operating system and host machine.  A
     non-negative value indicates that the data was successfully stored.

     `-1' as the value indicates an error.  The only error possible is
     `EFAULT', which we normally don't mention as it is always a
     possibility.


File: libc.info,  Node: Filesystem Handling,  Next: System Parameters,  Prev: Platform Type,  Up: System Management

30.3 Controlling and Querying Mounts
====================================

All files are in filesystems, and before you can access any file, its
filesystem must be mounted.  Because of Unix's concept of _Everything
is a file_, mounting of filesystems is central to doing almost
anything.  This section explains how to find out what filesystems are
currently mounted and what filesystems are available for mounting, and
how to change what is mounted.

   The classic filesystem is the contents of a disk drive.  The concept
is considerably more abstract, though, and lots of things other than
disk drives can be mounted.

   Some block devices don't correspond to traditional devices like disk
drives.  For example, a loop device is a block device whose driver uses
a regular file in another filesystem as its medium.  So if that regular
file contains appropriate data for a filesystem, you can by mounting the
loop device essentially mount a regular file.

   Some filesystems aren't based on a device of any kind.  The "proc"
filesystem, for example, contains files whose data is made up by the
filesystem driver on the fly whenever you ask for it.  And when you
write to it, the data you write causes changes in the system.  No data
gets stored.

* Menu:

* Mount Information::           What is or could be mounted?
* Mount-Unmount-Remount::       Controlling what is mounted and how


File: libc.info,  Node: Mount Information,  Next: Mount-Unmount-Remount,  Up: Filesystem Handling

30.3.1 Mount Information
------------------------

For some programs it is desirable and necessary to access information
about whether a certain filesystem is mounted and, if it is, where, or
simply to get lists of all the available filesystems.  The GNU libc
provides some functions to retrieve this information portably.

   Traditionally Unix systems have a file named `/etc/fstab' which
describes all possibly mounted filesystems.  The `mount' program uses
this file to mount at startup time of the system all the necessary
filesystems.  The information about all the filesystems actually
mounted is normally kept in a file named either `/var/run/mtab' or
`/etc/mtab'.  Both files share the same syntax and it is crucial that
this syntax is followed all the time.  Therefore it is best to never
directly write the files.  The functions described in this section can
do this and they also provide the functionality to convert the external
textual representation to the internal representation.

   Note that the `fstab' and `mtab' files are maintained on a system by
_convention_.  It is possible for the files not to exist or not to be
consistent with what is really mounted or available to mount, if the
system's administration policy allows it.  But programs that mount and
unmount filesystems typically maintain and use these files as described
herein.

   The filenames given above should never be used directly.  The
portable way to handle these file is to use the macro `_PATH_FSTAB',
defined in `fstab.h', or `_PATH_MNTTAB', defined in `mntent.h' and
`paths.h', for `fstab'; and the macro `_PATH_MOUNTED', also defined in
`mntent.h' and `paths.h', for `mtab'.  There are also two alternate
macro names `FSTAB', `MNTTAB', and `MOUNTED' defined but these names
are deprecated and kept only for backward compatibility.  The names
`_PATH_MNTTAB' and `_PATH_MOUNTED' should always be used.

* Menu:

* fstab::                       The `fstab' file
* mtab::                        The `mtab' file
* Other Mount Information::     Other (non-libc) sources of mount information


File: libc.info,  Node: fstab,  Next: mtab,  Up: Mount Information

30.3.1.1 The `fstab' file
.........................

The internal representation for entries of the file is `struct fstab',
defined in `fstab.h'.

 -- Data Type: struct fstab
     This structure is used with the `getfsent', `getfsspec', and
     `getfsfile' functions.

    `char *fs_spec'
          This element describes the device from which the filesystem
          is mounted.  Normally this is the name of a special device,
          such as a hard disk partition, but it could also be a more or
          less generic string.  For "NFS" it would be a hostname and
          directory name combination.

          Even though the element is not declared `const' it shouldn't
          be modified.  The missing `const' has historic reasons, since
          this function predates ISO C.  The same is true for the other
          string elements of this structure.

    `char *fs_file'
          This describes the mount point on the local system.  I.e.,
          accessing any file in this filesystem has implicitly or
          explicitly this string as a prefix.

    `char *fs_vfstype'
          This is the type of the filesystem.  Depending on what the
          underlying kernel understands it can be any string.

    `char *fs_mntops'
          This is a string containing options passed to the kernel with
          the `mount' call.  Again, this can be almost anything.  There
          can be more than one option, separated from the others by a
          comma.  Each option consists of a name and an optional value
          part, introduced by an `=' character.

          If the value of this element must be processed it should
          ideally be done using the `getsubopt' function; see *Note
          Suboptions::.

    `const char *fs_type'
          This name is poorly chosen.  This element points to a string
          (possibly in the `fs_mntops' string) which describes the
          modes with which the filesystem is mounted.  `fstab' defines
          five macros to describe the possible values:

         `FSTAB_RW'
               The filesystems gets mounted with read and write enabled.

         `FSTAB_RQ'
               The filesystems gets mounted with read and write
               enabled.  Write access is restricted by quotas.

         `FSTAB_RO'
               The filesystem gets mounted read-only.

         `FSTAB_SW'
               This is not a real filesystem, it is a swap device.

         `FSTAB_XX'
               This entry from the `fstab' file is totally ignored.

          Testing for equality with these value must happen using
          `strcmp' since these are all strings.  Comparing the pointer
          will probably always fail.

    `int fs_freq'
          This element describes the dump frequency in days.

    `int fs_passno'
          This element describes the pass number on parallel dumps.  It
          is closely related to the `dump' utility used on Unix systems.

   To read the entire content of the of the `fstab' file the GNU libc
contains a set of three functions which are designed in the usual way.

 -- Function: int setfsent (void)
     This function makes sure that the internal read pointer for the
     `fstab' file is at the beginning of the file.  This is done by
     either opening the file or resetting the read pointer.

     Since the file handle is internal to the libc this function is not
     thread-safe.

     This function returns a non-zero value if the operation was
     successful and the `getfs*' functions can be used to read the
     entries of the file.

 -- Function: void endfsent (void)
     This function makes sure that all resources acquired by a prior
     call to `setfsent' (explicitly or implicitly by calling
     `getfsent') are freed.

 -- Function: struct fstab * getfsent (void)
     This function returns the next entry of the `fstab' file.  If this
     is the first call to any of the functions handling `fstab' since
     program start or the last call of `endfsent', the file will be
     opened.

     The function returns a pointer to a variable of type `struct
     fstab'.  This variable is shared by all threads and therefore this
     function is not thread-safe.  If an error occurred `getfsent'
     returns a `NULL' pointer.

 -- Function: struct fstab * getfsspec (const char *NAME)
     This function returns the next entry of the `fstab' file which has
     a string equal to NAME pointed to by the `fs_spec' element.  Since
     there is normally exactly one entry for each special device it
     makes no sense to call this function more than once for the same
     argument.  If this is the first call to any of the functions
     handling `fstab' since program start or the last call of
     `endfsent', the file will be opened.

     The function returns a pointer to a variable of type `struct
     fstab'.  This variable is shared by all threads and therefore this
     function is not thread-safe.  If an error occurred `getfsent'
     returns a `NULL' pointer.

 -- Function: struct fstab * getfsfile (const char *NAME)
     This function returns the next entry of the `fstab' file which has
     a string equal to NAME pointed to by the `fs_file' element.  Since
     there is normally exactly one entry for each mount point it makes
     no sense to call this function more than once for the same
     argument.  If this is the first call to any of the functions
     handling `fstab' since program start or the last call of
     `endfsent', the file will be opened.

     The function returns a pointer to a variable of type `struct
     fstab'.  This variable is shared by all threads and therefore this
     function is not thread-safe.  If an error occurred `getfsent'
     returns a `NULL' pointer.


File: libc.info,  Node: mtab,  Next: Other Mount Information,  Prev: fstab,  Up: Mount Information

30.3.1.2 The `mtab' file
........................

The following functions and data structure access the `mtab' file.

 -- Data Type: struct mntent
     This structure is used with the `getmntent', `getmntent_t',
     `addmntent', and `hasmntopt' functions.

    `char *mnt_fsname'
          This element contains a pointer to a string describing the
          name of the special device from which the filesystem is
          mounted.  It corresponds to the `fs_spec' element in `struct
          fstab'.

    `char *mnt_dir'
          This element points to a string describing the mount point of
          the filesystem.  It corresponds to the `fs_file' element in
          `struct fstab'.

    `char *mnt_type'
          `mnt_type' describes the filesystem type and is therefore
          equivalent to `fs_vfstype' in `struct fstab'.  `mntent.h'
          defines a few symbolic names for some of the values this
          string can have.  But since the kernel can support arbitrary
          filesystems it does not make much sense to give them symbolic
          names.  If one knows the symbol name one also knows the
          filesystem name.  Nevertheless here follows the list of the
          symbols provided in `mntent.h'.

         `MNTTYPE_IGNORE'
               This symbol expands to `"ignore"'.  The value is
               sometime used in `fstab' files to make sure entries are
               not used without removing them.

         `MNTTYPE_NFS'
               Expands to `"nfs"'.  Using this macro sometimes could
               make sense since it names the default NFS
               implementation, in case both version 2 and 3 are
               supported.

         `MNTTYPE_SWAP'
               This symbol expands to `"swap"'.  It names the special
               `fstab' entry which names one of the possibly multiple
               swap partitions.

    `char *mnt_opts'
          The element contains a string describing the options used
          while mounting the filesystem.  As for the equivalent element
          `fs_mntops' of `struct fstab' it is best to use the function
          `getsubopt' (*note Suboptions::) to access the parts of this
          string.

          The `mntent.h' file defines a number of macros with string
          values which correspond to some of the options understood by
          the kernel.  There might be many more options which are
          possible so it doesn't make much sense to rely on these
          macros but to be consistent here is the list:

         `MNTOPT_DEFAULTS'
               Expands to `"defaults"'.  This option should be used
               alone since it indicates all values for the customizable
               values are chosen to be the default.

         `MNTOPT_RO'
               Expands to `"ro"'.  See the `FSTAB_RO' value, it means
               the filesystem is mounted read-only.

         `MNTOPT_RW'
               Expand to `"rw"'.  See the `FSTAB_RW' value, it means the
               filesystem is mounted with read and write permissions.

         `MNTOPT_SUID'
               Expands to `"suid"'.  This means that the SUID bit
               (*note How Change Persona::) is respected when a program
               from the filesystem is started.

         `MNTOPT_NOSUID'
               Expands to `"nosuid"'.  This is the opposite of
               `MNTOPT_SUID', the SUID bit for all files from the
               filesystem is ignored.

         `MNTOPT_NOAUTO'
               Expands to `"noauto"'.  At startup time the `mount'
               program will ignore this entry if it is started with the
               `-a' option to mount all filesystems mentioned in the
               `fstab' file.

          As for the `FSTAB_*' entries introduced above it is important
          to use `strcmp' to check for equality.

    `mnt_freq'
          This elements corresponds to `fs_freq' and also specifies the
          frequency in days in which dumps are made.

    `mnt_passno'
          This element is equivalent to `fs_passno' with the same
          meaning which is uninteresting for all programs beside `dump'.

   For accessing the `mtab' file there is again a set of three
functions to access all entries in a row.  Unlike the functions to
handle `fstab' these functions do not access a fixed file and there is
even a thread safe variant of the get function.  Beside this the GNU
libc contains functions to alter the file and test for specific options.

 -- Function: FILE * setmntent (const char *FILE, const char *MODE)
     The `setmntent' function prepares the file named FILE which must
     be in the format of a `fstab' and `mtab' file for the upcoming
     processing through the other functions of the family.  The MODE
     parameter can be chosen in the way the OPENTYPE parameter for
     `fopen' (*note Opening Streams::) can be chosen.  If the file is
     opened for writing the file is also allowed to be empty.

     If the file was successfully opened `setmntent' returns a file
     descriptor for future use.  Otherwise the return value is `NULL'
     and `errno' is set accordingly.

 -- Function: int endmntent (FILE *STREAM)
     This function takes for the STREAM parameter a file handle which
     previously was returned from the `setmntent' call.  `endmntent'
     closes the stream and frees all resources.

     The return value is 1 unless an error occurred in which case it is
     0.

 -- Function: struct mntent * getmntent (FILE *STREAM)
     The `getmntent' function takes as the parameter a file handle
     previously returned by successful call to `setmntent'.  It returns
     a pointer to a static variable of type `struct mntent' which is
     filled with the information from the next entry from the file
     currently read.

     The file format used prescribes the use of spaces or tab
     characters to separate the fields.  This makes it harder to use
     name containing one of these characters (e.g., mount points using
     spaces).  Therefore these characters are encoded in the files and
     the `getmntent' function takes care of the decoding while reading
     the entries back in.  `'\040'' is used to encode a space
     character, `'\011'' to encode a tab character, `'\012'' to encode
     a newline character, and `'\\'' to encode a backslash.

     If there was an error or the end of the file is reached the return
     value is `NULL'.

     This function is not thread-safe since all calls to this function
     return a pointer to the same static variable.  `getmntent_r'
     should be used in situations where multiple threads access the
     file.

 -- Function: struct mntent * getmntent_r (FILE *STREAM, struct mentent
          *RESULT, char *BUFFER, int BUFSIZE)
     The `getmntent_r' function is the reentrant variant of
     `getmntent'.  It also returns the next entry from the file and
     returns a pointer.  The actual variable the values are stored in
     is not static, though.  Instead the function stores the values in
     the variable pointed to by the RESULT parameter.  Additional
     information (e.g., the strings pointed to by the elements of the
     result) are kept in the buffer of size BUFSIZE pointed to by
     BUFFER.

     Escaped characters (space, tab, backslash) are converted back in
     the same way as it happens for `getmentent'.

     The function returns a `NULL' pointer in error cases.  Errors
     could be:
        * error while reading the file,

        * end of file reached,

        * BUFSIZE is too small for reading a complete new entry.

 -- Function: int addmntent (FILE *STREAM, const struct mntent *MNT)
     The `addmntent' function allows adding a new entry to the file
     previously opened with `setmntent'.  The new entries are always
     appended.  I.e., even if the position of the file descriptor is
     not at the end of the file this function does not overwrite an
     existing entry following the current position.

     The implication of this is that to remove an entry from a file one
     has to create a new file while leaving out the entry to be removed
     and after closing the file remove the old one and rename the new
     file to the chosen name.

     This function takes care of spaces and tab characters in the names
     to be written to the file.  It converts them and the backslash
     character into the format describe in the `getmntent' description
     above.

     This function returns 0 in case the operation was successful.
     Otherwise the return value is 1 and `errno' is set appropriately.

 -- Function: char * hasmntopt (const struct mntent *MNT, const char
          *OPT)
     This function can be used to check whether the string pointed to
     by the `mnt_opts' element of the variable pointed to by MNT
     contains the option OPT.  If this is true a pointer to the
     beginning of the option in the `mnt_opts' element is returned.  If
     no such option exists the function returns `NULL'.

     This function is useful to test whether a specific option is
     present but when all options have to be processed one is better
     off with using the `getsubopt' function to iterate over all
     options in the string.


File: libc.info,  Node: Other Mount Information,  Prev: mtab,  Up: Mount Information

30.3.1.3 Other (Non-libc) Sources of Mount Information
......................................................

On a system with a Linux kernel and the `proc' filesystem, you can get
information on currently mounted filesystems from the file `mounts' in
the `proc' filesystem.  Its format is similar to that of the `mtab'
file, but represents what is truly mounted without relying on
facilities outside the kernel to keep `mtab' up to date.


File: libc.info,  Node: Mount-Unmount-Remount,  Prev: Mount Information,  Up: Filesystem Handling

30.3.2 Mount, Unmount, Remount
------------------------------

This section describes the functions for mounting, unmounting, and
remounting filesystems.

   Only the superuser can mount, unmount, or remount a filesystem.

   These functions do not access the `fstab' and `mtab' files.  You
should maintain and use these separately.  *Note Mount Information::.

   The symbols in this section are declared in `sys/mount.h'.

 -- Function: int mount (const char *SPECIAL_FILE, const char *DIR,
          const char *FSTYPE, unsigned long int OPTIONS, const void
          *DATA)
     `mount' mounts or remounts a filesystem.  The two operations are
     quite different and are merged rather unnaturally into this one
     function.  The `MS_REMOUNT' option, explained below, determines
     whether `mount' mounts or remounts.

     For a mount, the filesystem on the block device represented by the
     device special file named SPECIAL_FILE gets mounted over the mount
     point DIR.  This means that the directory DIR (along with any
     files in it) is no longer visible; in its place (and still with
     the name DIR) is the root directory of the filesystem on the
     device.

     As an exception, if the filesystem type (see below) is one which
     is not based on a device (e.g. "proc"), `mount' instantiates a
     filesystem and mounts it over DIR and ignores SPECIAL_FILE.

     For a remount, DIR specifies the mount point where the filesystem
     to be remounted is (and remains) mounted and SPECIAL_FILE is
     ignored.  Remounting a filesystem means changing the options that
     control operations on the filesystem while it is mounted.  It does
     not mean unmounting and mounting again.

     For a mount, you must identify the type of the filesystem as
     FSTYPE.  This type tells the kernel how to access the filesystem
     and can be thought of as the name of a filesystem driver.  The
     acceptable values are system dependent.  On a system with a Linux
     kernel and the `proc' filesystem, the list of possible values is
     in the file `filesystems' in the `proc' filesystem (e.g. type `cat
     /proc/filesystems' to see the list).  With a Linux kernel, the
     types of filesystems that `mount' can mount, and their type names,
     depends on what filesystem drivers are configured into the kernel
     or loaded as loadable kernel modules.  An example of a common
     value for FSTYPE is `ext2'.

     For a remount, `mount' ignores FSTYPE.

     OPTIONS specifies a variety of options that apply until the
     filesystem is unmounted or remounted.  The precise meaning of an
     option depends on the filesystem and with some filesystems, an
     option may have no effect at all.  Furthermore, for some
     filesystems, some of these options (but never `MS_RDONLY') can be
     overridden for individual file accesses via `ioctl'.

     OPTIONS is a bit string with bit fields defined using the
     following mask and masked value macros:

    `MS_MGC_MASK'
          This multibit field contains a magic number.  If it does not
          have the value `MS_MGC_VAL', `mount' assumes all the
          following bits are zero and the DATA argument is a null
          string, regardless of their actual values.

    `MS_REMOUNT'
          This bit on means to remount the filesystem.  Off means to
          mount it.

    `MS_RDONLY'
          This bit on specifies that no writing to the filesystem shall
          be allowed while it is mounted.  This cannot be overridden by
          `ioctl'.  This option is available on nearly all filesystems.

    `S_IMMUTABLE'
          This bit on specifies that no writing to the files in the
          filesystem shall be allowed while it is mounted.  This can be
          overridden for a particular file access by a properly
          privileged call to `ioctl'.  This option is a relatively new
          invention and is not available on many filesystems.

    `S_APPEND'
          This bit on specifies that the only file writing that shall
          be allowed while the filesystem is mounted is appending.
          Some filesystems allow this to be overridden for a particular
          process by a properly privileged call to `ioctl'.  This is a
          relatively new invention and is not available on many
          filesystems.

    `MS_NOSUID'
          This bit on specifies that Setuid and Setgid permissions on
          files in the filesystem shall be ignored while it is mounted.

    `MS_NOEXEC'
          This bit on specifies that no files in the filesystem shall
          be executed while the filesystem is mounted.

    `MS_NODEV'
          This bit on specifies that no device special files in the
          filesystem shall be accessible while the filesystem is
          mounted.

    `MS_SYNCHRONOUS'
          This bit on specifies that all writes to the filesystem while
          it is mounted shall be synchronous; i.e., data shall be
          synced before each write completes rather than held in the
          buffer cache.

    `MS_MANDLOCK'
          This bit on specifies that mandatory locks on files shall be
          permitted while the filesystem is mounted.

    `MS_NOATIME'
          This bit on specifies that access times of files shall not be
          updated when the files are accessed while the filesystem is
          mounted.

    `MS_NODIRATIME'
          This bit on specifies that access times of directories shall
          not be updated when the directories are accessed while the
          filesystem in mounted.


     Any bits not covered by the above masks should be set off;
     otherwise, results are undefined.

     The meaning of DATA depends on the filesystem type and is
     controlled entirely by the filesystem driver in the kernel.

     Example:

          #include <sys/mount.h>

          mount("/dev/hdb", "/cdrom", MS_MGC_VAL | MS_RDONLY | MS_NOSUID, "");

          mount("/dev/hda2", "/mnt", MS_MGC_VAL | MS_REMOUNT, "");

     Appropriate arguments for `mount' are conventionally recorded in
     the `fstab' table.  *Note Mount Information::.

     The return value is zero if the mount or remount is successful.
     Otherwise, it is `-1' and `errno' is set appropriately.  The
     values of `errno' are filesystem dependent, but here is a general
     list:

    `EPERM'
          The process is not superuser.

    `ENODEV'
          The file system type FSTYPE is not known to the kernel.

    `ENOTBLK'
          The file DEV is not a block device special file.

    `EBUSY'
             * The device is already mounted.

             * The mount point is busy.  (E.g. it is some process'
               working directory or has a filesystem mounted on it
               already).

             * The request is to remount read-only, but there are files
               open for write.

    `EINVAL'
             * A remount was attempted, but there is no filesystem
               mounted over the specified mount point.

             * The supposed filesystem has an invalid superblock.


    `EACCES'
             * The filesystem is inherently read-only (possibly due to
               a switch on the device) and the process attempted to
               mount it read/write (by setting the `MS_RDONLY' bit off).

             * SPECIAL_FILE or DIR is not accessible due to file
               permissions.

             * SPECIAL_FILE is not accessible because it is in a
               filesystem that is mounted with the `MS_NODEV' option.


    `EM_FILE'
          The table of dummy devices is full.  `mount' needs to create a
          dummy device (aka "unnamed" device) if the filesystem being
          mounted is not one that uses a device.



 -- Function: int umount2 (const char *FILE, int FLAGS)
     `umount2' unmounts a filesystem.

     You can identify the filesystem to unmount either by the device
     special file that contains the filesystem or by the mount point.
     The effect is the same.  Specify either as the string FILE.

     FLAGS contains the one-bit field identified by the following mask
     macro:

    `MNT_FORCE'
          This bit on means to force the unmounting even if the
          filesystem is busy, by making it unbusy first.  If the bit is
          off and the filesystem is busy, `umount2' fails with `errno'
          = `EBUSY'.  Depending on the filesystem, this may override
          all, some, or no busy conditions.


     All other bits in FLAGS should be set to zero; otherwise, the
     result is undefined.

     Example:

          #include <sys/mount.h>

          umount2("/mnt", MNT_FORCE);

          umount2("/dev/hdd1", 0);

     After the filesystem is unmounted, the directory that was the
     mount point is visible, as are any files in it.

     As part of unmounting, `umount2' syncs the filesystem.

     If the unmounting is successful, the return value is zero.
     Otherwise, it is `-1' and `errno' is set accordingly:

    `EPERM'
          The process is not superuser.

    `EBUSY'
          The filesystem cannot be unmounted because it is busy.  E.g.
          it contains a directory that is some process's working
          directory or a file that some process has open.  With some
          filesystems in some cases, you can avoid this failure with
          the `MNT_FORCE' option.

    `EINVAL'
          FILE validly refers to a file, but that file is neither a
          mount point nor a device special file of a currently mounted
          filesystem.


     This function is not available on all systems.

 -- Function: int umount (const char *FILE)
     `umount' does the same thing as `umount2' with FLAGS set to
     zeroes.  It is more widely available than `umount2' but since it
     lacks the possibility to forcefully unmount a filesystem is
     deprecated when `umount2' is also available.


File: libc.info,  Node: System Parameters,  Prev: Filesystem Handling,  Up: System Management

30.4 System Parameters
======================

This section describes the `sysctl' function, which gets and sets a
variety of system parameters.

   The symbols used in this section are declared in the file `sysctl.h'.

 -- Function: int sysctl (int *NAMES, int NLEN, void *OLDVAL, size_t
          *OLDLENP, void *NEWVAL, size_t NEWLEN)
     `sysctl' gets or sets a specified system parameter.  There are so
     many of these parameters that it is not practical to list them all
     here, but here are some examples:

        * network domain name

        * paging parameters

        * network Address Resolution Protocol timeout time

        * maximum number of files that may be open

        * root filesystem device

        * when kernel was built

     The set of available parameters depends on the kernel
     configuration and can change while the system is running,
     particularly when you load and unload loadable kernel modules.

     The system parameters with which `syslog' is concerned are arranged
     in a hierarchical structure like a hierarchical filesystem.  To
     identify a particular parameter, you specify a path through the
     structure in a way analogous to specifying the pathname of a file.
     Each component of the path is specified by an integer and each of
     these integers has a macro defined for it by `sysctl.h'.  NAMES is
     the path, in the form of an array of integers.  Each component of
     the path is one element of the array, in order.  NLEN is the
     number of components in the path.

     For example, the first component of the path for all the paging
     parameters is the value `CTL_VM'.  For the free page thresholds,
     the second component of the path is `VM_FREEPG'.  So to get the
     free page threshold values, make NAMES an array containing the two
     elements `CTL_VM' and `VM_FREEPG' and make NLEN = 2.

     The format of the value of a parameter depends on the parameter.
     Sometimes it is an integer; sometimes it is an ASCII string;
     sometimes it is an elaborate structure.  In the case of the free
     page thresholds used in the example above, the parameter value is
     a structure containing several integers.

     In any case, you identify a place to return the parameter's value
     with OLDVAL and specify the amount of storage available at that
     location as *OLDLENP.  *OLDLENP does double duty because it is
     also the output location that contains the actual length of the
     returned value.

     If you don't want the parameter value returned, specify a null
     pointer for OLDVAL.

     To set the parameter, specify the address and length of the new
     value as NEWVAL and NEWLEN.  If you don't want to set the
     parameter, specify a null pointer as NEWVAL.

     If you get and set a parameter in the same `sysctl' call, the value
     returned is the value of the parameter before it was set.

     Each system parameter has a set of permissions similar to the
     permissions for a file (including the permissions on directories
     in its path) that determine whether you may get or set it.  For
     the purposes of these permissions, every parameter is considered
     to be owned by the superuser and Group 0 so processes with that
     effective uid or gid may have more access to system parameters.
     Unlike with files, the superuser does not invariably have full
     permission to all system parameters, because some of them are
     designed not to be changed ever.

     `sysctl' returns a zero return value if it succeeds.  Otherwise, it
     returns `-1' and sets `errno' appropriately.  Besides the failures
     that apply to all system calls, the following are the `errno'
     codes for all possible failures:

    `EPERM'
          The process is not permitted to access one of the components
          of the path of the system parameter or is not permitted to
          access the system parameter itself in the way (read or write)
          that it requested.

    `ENOTDIR'
          There is no system parameter corresponding to NAME.

    `EFAULT'
          OLDVAL is not null, which means the process wanted to read
          the parameter, but *OLDLENP is zero, so there is no place to
          return it.

    `EINVAL'
             * The process attempted to set a system parameter to a
               value that is not valid for that parameter.

             * The space provided for the return of the system
               parameter is not the right size for that parameter.

    `ENOMEM'
          This value may be returned instead of the more correct
          `EINVAL' in some cases where the space provided for the
          return of the system parameter is too small.



   If you have a Linux kernel with the `proc' filesystem, you can get
and set most of the same parameters by reading and writing to files in
the `sys' directory of the `proc' filesystem.  In the `sys' directory,
the directory structure represents the hierarchical structure of the
parameters.  E.g. you can display the free page thresholds with
     cat /proc/sys/vm/freepages

   Some more traditional and more widely available, though less general,
GNU C library functions for getting and setting some of the same system
parameters are:

   * `getdomainname', `setdomainname'

   * `gethostname', `sethostname' (*Note Host Identification::.)

   * `uname' (*Note Platform Type::.)

   * `bdflush'


File: libc.info,  Node: System Configuration,  Next: Cryptographic Functions,  Prev: System Management,  Up: Top

31 System Configuration Parameters
**********************************

The functions and macros listed in this chapter give information about
configuration parameters of the operating system--for example, capacity
limits, presence of optional POSIX features, and the default path for
executable files (*note String Parameters::).

* Menu:

* General Limits::           Constants and functions that describe
				various process-related limits that have
				one uniform value for any given machine.
* System Options::           Optional POSIX features.
* Version Supported::        Version numbers of POSIX.1 and POSIX.2.
* Sysconf::                  Getting specific configuration values
                                of general limits and system options.
* Minimums::                 Minimum values for general limits.

* Limits for Files::         Size limitations that pertain to individual files.
                                These can vary between file systems
                                or even from file to file.
* Options for Files::        Optional features that some files may support.
* File Minimums::            Minimum values for file limits.
* Pathconf::                 Getting the limit values for a particular file.

* Utility Limits::           Capacity limits of some POSIX.2 utility programs.
* Utility Minimums::         Minimum allowable values of those limits.

* String Parameters::        Getting the default search path.


File: libc.info,  Node: General Limits,  Next: System Options,  Up: System Configuration

31.1 General Capacity Limits
============================

The POSIX.1 and POSIX.2 standards specify a number of parameters that
describe capacity limitations of the system.  These limits can be fixed
constants for a given operating system, or they can vary from machine to
machine.  For example, some limit values may be configurable by the
system administrator, either at run time or by rebuilding the kernel,
and this should not require recompiling application programs.

   Each of the following limit parameters has a macro that is defined in
`limits.h' only if the system has a fixed, uniform limit for the
parameter in question.  If the system allows different file systems or
files to have different limits, then the macro is undefined; use
`sysconf' to find out the limit that applies at a particular time on a
particular machine.  *Note Sysconf::.

   Each of these parameters also has another macro, with a name starting
with `_POSIX', which gives the lowest value that the limit is allowed
to have on _any_ POSIX system.  *Note Minimums::.

 -- Macro: int ARG_MAX
     If defined, the unvarying maximum combined length of the ARGV and
     ENVIRON arguments that can be passed to the `exec' functions.

 -- Macro: int CHILD_MAX
     If defined, the unvarying maximum number of processes that can
     exist with the same real user ID at any one time.  In BSD and GNU,
     this is controlled by the `RLIMIT_NPROC' resource limit; *note
     Limits on Resources::.

 -- Macro: int OPEN_MAX
     If defined, the unvarying maximum number of files that a single
     process can have open simultaneously.  In BSD and GNU, this is
     controlled by the `RLIMIT_NOFILE' resource limit; *note Limits on
     Resources::.

 -- Macro: int STREAM_MAX
     If defined, the unvarying maximum number of streams that a single
     process can have open simultaneously.  *Note Opening Streams::.

 -- Macro: int TZNAME_MAX
     If defined, the unvarying maximum length of a time zone name.
     *Note Time Zone Functions::.

   These limit macros are always defined in `limits.h'.

 -- Macro: int NGROUPS_MAX
     The maximum number of supplementary group IDs that one process can
     have.

     The value of this macro is actually a lower bound for the maximum.
     That is, you can count on being able to have that many
     supplementary group IDs, but a particular machine might let you
     have even more.  You can use `sysconf' to see whether a particular
     machine will let you have more (*note Sysconf::).

 -- Macro: int SSIZE_MAX
     The largest value that can fit in an object of type `ssize_t'.
     Effectively, this is the limit on the number of bytes that can be
     read or written in a single operation.

     This macro is defined in all POSIX systems because this limit is
     never configurable.

 -- Macro: int RE_DUP_MAX
     The largest number of repetitions you are guaranteed is allowed in
     the construct `\{MIN,MAX\}' in a regular expression.

     The value of this macro is actually a lower bound for the maximum.
     That is, you can count on being able to have that many
     repetitions, but a particular machine might let you have even
     more.  You can use `sysconf' to see whether a particular machine
     will let you have more (*note Sysconf::).  And even the value that
     `sysconf' tells you is just a lower bound--larger values might
     work.

     This macro is defined in all POSIX.2 systems, because POSIX.2 says
     it should always be defined even if there is no specific imposed
     limit.


File: libc.info,  Node: System Options,  Next: Version Supported,  Prev: General Limits,  Up: System Configuration

31.2 Overall System Options
===========================

POSIX defines certain system-specific options that not all POSIX systems
support.  Since these options are provided in the kernel, not in the
library, simply using the GNU C library does not guarantee any of these
features is supported; it depends on the system you are using.

   You can test for the availability of a given option using the macros
in this section, together with the function `sysconf'.  The macros are
defined only if you include `unistd.h'.

   For the following macros, if the macro is defined in `unistd.h',
then the option is supported.  Otherwise, the option may or may not be
supported; use `sysconf' to find out.  *Note Sysconf::.

 -- Macro: int _POSIX_JOB_CONTROL
     If this symbol is defined, it indicates that the system supports
     job control.  Otherwise, the implementation behaves as if all
     processes within a session belong to a single process group.
     *Note Job Control::.

 -- Macro: int _POSIX_SAVED_IDS
     If this symbol is defined, it indicates that the system remembers
     the effective user and group IDs of a process before it executes an
     executable file with the set-user-ID or set-group-ID bits set, and
     that explicitly changing the effective user or group IDs back to
     these values is permitted.  If this option is not defined, then if
     a nonprivileged process changes its effective user or group ID to
     the real user or group ID of the process, it can't change it back
     again.  *Note Enable/Disable Setuid::.

   For the following macros, if the macro is defined in `unistd.h',
then its value indicates whether the option is supported.  A value of
`-1' means no, and any other value means yes.  If the macro is not
defined, then the option may or may not be supported; use `sysconf' to
find out.  *Note Sysconf::.

 -- Macro: int _POSIX2_C_DEV
     If this symbol is defined, it indicates that the system has the
     POSIX.2 C compiler command, `c89'.  The GNU C library always
     defines this as `1', on the assumption that you would not have
     installed it if you didn't have a C compiler.

 -- Macro: int _POSIX2_FORT_DEV
     If this symbol is defined, it indicates that the system has the
     POSIX.2 Fortran compiler command, `fort77'.  The GNU C library
     never defines this, because we don't know what the system has.

 -- Macro: int _POSIX2_FORT_RUN
     If this symbol is defined, it indicates that the system has the
     POSIX.2 `asa' command to interpret Fortran carriage control.  The
     GNU C library never defines this, because we don't know what the
     system has.

 -- Macro: int _POSIX2_LOCALEDEF
     If this symbol is defined, it indicates that the system has the
     POSIX.2 `localedef' command.  The GNU C library never defines
     this, because we don't know what the system has.

 -- Macro: int _POSIX2_SW_DEV
     If this symbol is defined, it indicates that the system has the
     POSIX.2 commands `ar', `make', and `strip'.  The GNU C library
     always defines this as `1', on the assumption that you had to have
     `ar' and `make' to install the library, and it's unlikely that
     `strip' would be absent when those are present.


File: libc.info,  Node: Version Supported,  Next: Sysconf,  Prev: System Options,  Up: System Configuration

31.3 Which Version of POSIX is Supported
========================================

 -- Macro: long int _POSIX_VERSION
     This constant represents the version of the POSIX.1 standard to
     which the implementation conforms.  For an implementation
     conforming to the 1995 POSIX.1 standard, the value is the integer
     `199506L'.

     `_POSIX_VERSION' is always defined (in `unistd.h') in any POSIX
     system.

     *Usage Note:* Don't try to test whether the system supports POSIX
     by including `unistd.h' and then checking whether `_POSIX_VERSION'
     is defined.  On a non-POSIX system, this will probably fail
     because there is no `unistd.h'.  We do not know of _any_ way you
     can reliably test at compilation time whether your target system
     supports POSIX or whether `unistd.h' exists.

     The GNU C compiler predefines the symbol `__POSIX__' if the target
     system is a POSIX system.  Provided you do not use any other
     compilers on POSIX systems, testing `defined (__POSIX__)' will
     reliably detect such systems.

 -- Macro: long int _POSIX2_C_VERSION
     This constant represents the version of the POSIX.2 standard which
     the library and system kernel support.  We don't know what value
     this will be for the first version of the POSIX.2 standard,
     because the value is based on the year and month in which the
     standard is officially adopted.

     The value of this symbol says nothing about the utilities
     installed on the system.

     *Usage Note:* You can use this macro to tell whether a POSIX.1
     system library supports POSIX.2 as well.  Any POSIX.1 system
     contains `unistd.h', so include that file and then test `defined
     (_POSIX2_C_VERSION)'.


File: libc.info,  Node: Sysconf,  Next: Minimums,  Prev: Version Supported,  Up: System Configuration

31.4 Using `sysconf'
====================

When your system has configurable system limits, you can use the
`sysconf' function to find out the value that applies to any particular
machine.  The function and the associated PARAMETER constants are
declared in the header file `unistd.h'.

* Menu:

* Sysconf Definition::        Detailed specifications of `sysconf'.
* Constants for Sysconf::     The list of parameters `sysconf' can read.
* Examples of Sysconf::       How to use `sysconf' and the parameter
				 macros properly together.


File: libc.info,  Node: Sysconf Definition,  Next: Constants for Sysconf,  Up: Sysconf

31.4.1 Definition of `sysconf'
------------------------------

 -- Function: long int sysconf (int PARAMETER)
     This function is used to inquire about runtime system parameters.
     The PARAMETER argument should be one of the `_SC_' symbols listed
     below.

     The normal return value from `sysconf' is the value you requested.
     A value of `-1' is returned both if the implementation does not
     impose a limit, and in case of an error.

     The following `errno' error conditions are defined for this
     function:

    `EINVAL'
          The value of the PARAMETER is invalid.


File: libc.info,  Node: Constants for Sysconf,  Next: Examples of Sysconf,  Prev: Sysconf Definition,  Up: Sysconf

31.4.2 Constants for `sysconf' Parameters
-----------------------------------------

Here are the symbolic constants for use as the PARAMETER argument to
`sysconf'.  The values are all integer constants (more specifically,
enumeration type values).

`_SC_ARG_MAX'
     Inquire about the parameter corresponding to `ARG_MAX'.

`_SC_CHILD_MAX'
     Inquire about the parameter corresponding to `CHILD_MAX'.

`_SC_OPEN_MAX'
     Inquire about the parameter corresponding to `OPEN_MAX'.

`_SC_STREAM_MAX'
     Inquire about the parameter corresponding to `STREAM_MAX'.

`_SC_TZNAME_MAX'
     Inquire about the parameter corresponding to `TZNAME_MAX'.

`_SC_NGROUPS_MAX'
     Inquire about the parameter corresponding to `NGROUPS_MAX'.

`_SC_JOB_CONTROL'
     Inquire about the parameter corresponding to `_POSIX_JOB_CONTROL'.

`_SC_SAVED_IDS'
     Inquire about the parameter corresponding to `_POSIX_SAVED_IDS'.

`_SC_VERSION'
     Inquire about the parameter corresponding to `_POSIX_VERSION'.

`_SC_CLK_TCK'
     Inquire about the parameter corresponding to `CLOCKS_PER_SEC';
     *note CPU Time::.

`_SC_CHARCLASS_NAME_MAX'
     Inquire about the parameter corresponding to maximal length
     allowed for a character class name in an extended locale
     specification.  These extensions are not yet standardized and so
     this option is not standardized as well.

`_SC_REALTIME_SIGNALS'
     Inquire about the parameter corresponding to
     `_POSIX_REALTIME_SIGNALS'.

`_SC_PRIORITY_SCHEDULING'
     Inquire about the parameter corresponding to
     `_POSIX_PRIORITY_SCHEDULING'.

`_SC_TIMERS'
     Inquire about the parameter corresponding to `_POSIX_TIMERS'.

`_SC_ASYNCHRONOUS_IO'
     Inquire about the parameter corresponding to
     `_POSIX_ASYNCHRONOUS_IO'.

`_SC_PRIORITIZED_IO'
     Inquire about the parameter corresponding to
     `_POSIX_PRIORITIZED_IO'.

`_SC_SYNCHRONIZED_IO'
     Inquire about the parameter corresponding to
     `_POSIX_SYNCHRONIZED_IO'.

`_SC_FSYNC'
     Inquire about the parameter corresponding to `_POSIX_FSYNC'.

`_SC_MAPPED_FILES'
     Inquire about the parameter corresponding to `_POSIX_MAPPED_FILES'.

`_SC_MEMLOCK'
     Inquire about the parameter corresponding to `_POSIX_MEMLOCK'.

`_SC_MEMLOCK_RANGE'
     Inquire about the parameter corresponding to
     `_POSIX_MEMLOCK_RANGE'.

`_SC_MEMORY_PROTECTION'
     Inquire about the parameter corresponding to
     `_POSIX_MEMORY_PROTECTION'.

`_SC_MESSAGE_PASSING'
     Inquire about the parameter corresponding to
     `_POSIX_MESSAGE_PASSING'.

`_SC_SEMAPHORES'
     Inquire about the parameter corresponding to `_POSIX_SEMAPHORES'.

`_SC_SHARED_MEMORY_OBJECTS'
     Inquire about the parameter corresponding to
     `_POSIX_SHARED_MEMORY_OBJECTS'.

`_SC_AIO_LISTIO_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_AIO_LISTIO_MAX'.

`_SC_AIO_MAX'
     Inquire about the parameter corresponding to `_POSIX_AIO_MAX'.

`_SC_AIO_PRIO_DELTA_MAX'
     Inquire the value by which a process can decrease its asynchronous
     I/O priority level from its own scheduling priority.  This
     corresponds to the run-time invariant value `AIO_PRIO_DELTA_MAX'.

`_SC_DELAYTIMER_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_DELAYTIMER_MAX'.

`_SC_MQ_OPEN_MAX'
     Inquire about the parameter corresponding to `_POSIX_MQ_OPEN_MAX'.

`_SC_MQ_PRIO_MAX'
     Inquire about the parameter corresponding to `_POSIX_MQ_PRIO_MAX'.

`_SC_RTSIG_MAX'
     Inquire about the parameter corresponding to `_POSIX_RTSIG_MAX'.

`_SC_SEM_NSEMS_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_SEM_NSEMS_MAX'.

`_SC_SEM_VALUE_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_SEM_VALUE_MAX'.

`_SC_SIGQUEUE_MAX'
     Inquire about the parameter corresponding to `_POSIX_SIGQUEUE_MAX'.

`_SC_TIMER_MAX'
     Inquire about the parameter corresponding to `_POSIX_TIMER_MAX'.

`_SC_PII'
     Inquire about the parameter corresponding to `_POSIX_PII'.

`_SC_PII_XTI'
     Inquire about the parameter corresponding to `_POSIX_PII_XTI'.

`_SC_PII_SOCKET'
     Inquire about the parameter corresponding to `_POSIX_PII_SOCKET'.

`_SC_PII_INTERNET'
     Inquire about the parameter corresponding to `_POSIX_PII_INTERNET'.

`_SC_PII_OSI'
     Inquire about the parameter corresponding to `_POSIX_PII_OSI'.

`_SC_SELECT'
     Inquire about the parameter corresponding to `_POSIX_SELECT'.

`_SC_UIO_MAXIOV'
     Inquire about the parameter corresponding to `_POSIX_UIO_MAXIOV'.

`_SC_PII_INTERNET_STREAM'
     Inquire about the parameter corresponding to
     `_POSIX_PII_INTERNET_STREAM'.

`_SC_PII_INTERNET_DGRAM'
     Inquire about the parameter corresponding to
     `_POSIX_PII_INTERNET_DGRAM'.

`_SC_PII_OSI_COTS'
     Inquire about the parameter corresponding to `_POSIX_PII_OSI_COTS'.

`_SC_PII_OSI_CLTS'
     Inquire about the parameter corresponding to `_POSIX_PII_OSI_CLTS'.

`_SC_PII_OSI_M'
     Inquire about the parameter corresponding to `_POSIX_PII_OSI_M'.

`_SC_T_IOV_MAX'
     Inquire the value of the value associated with the `T_IOV_MAX'
     variable.

`_SC_THREADS'
     Inquire about the parameter corresponding to `_POSIX_THREADS'.

`_SC_THREAD_SAFE_FUNCTIONS'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_SAFE_FUNCTIONS'.

`_SC_GETGR_R_SIZE_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_GETGR_R_SIZE_MAX'.

`_SC_GETPW_R_SIZE_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_GETPW_R_SIZE_MAX'.

`_SC_LOGIN_NAME_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_LOGIN_NAME_MAX'.

`_SC_TTY_NAME_MAX'
     Inquire about the parameter corresponding to `_POSIX_TTY_NAME_MAX'.

`_SC_THREAD_DESTRUCTOR_ITERATIONS'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_DESTRUCTOR_ITERATIONS'.

`_SC_THREAD_KEYS_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_KEYS_MAX'.

`_SC_THREAD_STACK_MIN'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_STACK_MIN'.

`_SC_THREAD_THREADS_MAX'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_THREADS_MAX'.

`_SC_THREAD_ATTR_STACKADDR'
     Inquire about the parameter corresponding to
     a `_POSIX_THREAD_ATTR_STACKADDR'.

`_SC_THREAD_ATTR_STACKSIZE'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_ATTR_STACKSIZE'.

`_SC_THREAD_PRIORITY_SCHEDULING'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_PRIORITY_SCHEDULING'.

`_SC_THREAD_PRIO_INHERIT'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_PRIO_INHERIT'.

`_SC_THREAD_PRIO_PROTECT'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_PRIO_PROTECT'.

`_SC_THREAD_PROCESS_SHARED'
     Inquire about the parameter corresponding to
     `_POSIX_THREAD_PROCESS_SHARED'.

`_SC_2_C_DEV'
     Inquire about whether the system has the POSIX.2 C compiler
     command, `c89'.

`_SC_2_FORT_DEV'
     Inquire about whether the system has the POSIX.2 Fortran compiler
     command, `fort77'.

`_SC_2_FORT_RUN'
     Inquire about whether the system has the POSIX.2 `asa' command to
     interpret Fortran carriage control.

`_SC_2_LOCALEDEF'
     Inquire about whether the system has the POSIX.2 `localedef'
     command.

`_SC_2_SW_DEV'
     Inquire about whether the system has the POSIX.2 commands `ar',
     `make', and `strip'.

`_SC_BC_BASE_MAX'
     Inquire about the maximum value of `obase' in the `bc' utility.

`_SC_BC_DIM_MAX'
     Inquire about the maximum size of an array in the `bc' utility.

`_SC_BC_SCALE_MAX'
     Inquire about the maximum value of `scale' in the `bc' utility.

`_SC_BC_STRING_MAX'
     Inquire about the maximum size of a string constant in the `bc'
     utility.

`_SC_COLL_WEIGHTS_MAX'
     Inquire about the maximum number of weights that can necessarily
     be used in defining the collating sequence for a locale.

`_SC_EXPR_NEST_MAX'
     Inquire about the maximum number of expressions nested within
     parentheses when using the `expr' utility.

`_SC_LINE_MAX'
     Inquire about the maximum size of a text line that the POSIX.2 text
     utilities can handle.

`_SC_EQUIV_CLASS_MAX'
     Inquire about the maximum number of weights that can be assigned
     to an entry of the `LC_COLLATE' category `order' keyword in a
     locale definition.  The GNU C library does not presently support
     locale definitions.

`_SC_VERSION'
     Inquire about the version number of POSIX.1 that the library and
     kernel support.

`_SC_2_VERSION'
     Inquire about the version number of POSIX.2 that the system
     utilities support.

`_SC_PAGESIZE'
     Inquire about the virtual memory page size of the machine.
     `getpagesize' returns the same value (*note Query Memory
     Parameters::).

`_SC_NPROCESSORS_CONF'
     Inquire about the number of configured processors.

`_SC_NPROCESSORS_ONLN'
     Inquire about the number of processors online.

`_SC_PHYS_PAGES'
     Inquire about the number of physical pages in the system.

`_SC_AVPHYS_PAGES'
     Inquire about the number of available physical pages in the system.

`_SC_ATEXIT_MAX'
     Inquire about the number of functions which can be registered as
     termination functions for `atexit'; *note Cleanups on Exit::.

`_SC_XOPEN_VERSION'
     Inquire about the parameter corresponding to `_XOPEN_VERSION'.

`_SC_XOPEN_XCU_VERSION'
     Inquire about the parameter corresponding to `_XOPEN_XCU_VERSION'.

`_SC_XOPEN_UNIX'
     Inquire about the parameter corresponding to `_XOPEN_UNIX'.

`_SC_XOPEN_REALTIME'
     Inquire about the parameter corresponding to `_XOPEN_REALTIME'.

`_SC_XOPEN_REALTIME_THREADS'
     Inquire about the parameter corresponding to
     `_XOPEN_REALTIME_THREADS'.

`_SC_XOPEN_LEGACY'
     Inquire about the parameter corresponding to `_XOPEN_LEGACY'.

`_SC_XOPEN_CRYPT'
     Inquire about the parameter corresponding to `_XOPEN_CRYPT'.

`_SC_XOPEN_ENH_I18N'
     Inquire about the parameter corresponding to `_XOPEN_ENH_I18N'.

`_SC_XOPEN_SHM'
     Inquire about the parameter corresponding to `_XOPEN_SHM'.

`_SC_XOPEN_XPG2'
     Inquire about the parameter corresponding to `_XOPEN_XPG2'.

`_SC_XOPEN_XPG3'
     Inquire about the parameter corresponding to `_XOPEN_XPG3'.

`_SC_XOPEN_XPG4'
     Inquire about the parameter corresponding to `_XOPEN_XPG4'.

`_SC_CHAR_BIT'
     Inquire about the number of bits in a variable of type `char'.

`_SC_CHAR_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `char'.

`_SC_CHAR_MIN'
     Inquire about the minimum value which can be stored in a variable
     of type `char'.

`_SC_INT_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `int'.

`_SC_INT_MIN'
     Inquire about the minimum value which can be stored in a variable
     of type `int'.

`_SC_LONG_BIT'
     Inquire about the number of bits in a variable of type `long int'.

`_SC_WORD_BIT'
     Inquire about the number of bits in a variable of a register word.

`_SC_MB_LEN_MAX'
     Inquire the maximum length of a multi-byte representation of a wide
     character value.

`_SC_NZERO'
     Inquire about the value used to internally represent the zero
     priority level for the process execution.

`SC_SSIZE_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `ssize_t'.

`_SC_SCHAR_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `signed char'.

`_SC_SCHAR_MIN'
     Inquire about the minimum value which can be stored in a variable
     of type `signed char'.

`_SC_SHRT_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `short int'.

`_SC_SHRT_MIN'
     Inquire about the minimum value which can be stored in a variable
     of type `short int'.

`_SC_UCHAR_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `unsigned char'.

`_SC_UINT_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `unsigned int'.

`_SC_ULONG_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `unsigned long int'.

`_SC_USHRT_MAX'
     Inquire about the maximum value which can be stored in a variable
     of type `unsigned short int'.

`_SC_NL_ARGMAX'
     Inquire about the parameter corresponding to `NL_ARGMAX'.

`_SC_NL_LANGMAX'
     Inquire about the parameter corresponding to `NL_LANGMAX'.

`_SC_NL_MSGMAX'
     Inquire about the parameter corresponding to `NL_MSGMAX'.

`_SC_NL_NMAX'
     Inquire about  the parameter corresponding to `NL_NMAX'.

`_SC_NL_SETMAX'
     Inquire about the parameter corresponding to `NL_SETMAX'.

`_SC_NL_TEXTMAX'
     Inquire about the parameter corresponding to `NL_TEXTMAX'.


File: libc.info,  Node: Examples of Sysconf,  Prev: Constants for Sysconf,  Up: Sysconf

31.4.3 Examples of `sysconf'
----------------------------

We recommend that you first test for a macro definition for the
parameter you are interested in, and call `sysconf' only if the macro
is not defined.  For example, here is how to test whether job control
is supported:

     int
     have_job_control (void)
     {
     #ifdef _POSIX_JOB_CONTROL
       return 1;
     #else
       int value = sysconf (_SC_JOB_CONTROL);
       if (value < 0)
         /* If the system is that badly wedged,
            there's no use trying to go on.  */
         fatal (strerror (errno));
       return value;
     #endif
     }

   Here is how to get the value of a numeric limit:

     int
     get_child_max ()
     {
     #ifdef CHILD_MAX
       return CHILD_MAX;
     #else
       int value = sysconf (_SC_CHILD_MAX);
       if (value < 0)
         fatal (strerror (errno));
       return value;
     #endif
     }


File: libc.info,  Node: Minimums,  Next: Limits for Files,  Prev: Sysconf,  Up: System Configuration

31.5 Minimum Values for General Capacity Limits
===============================================

Here are the names for the POSIX minimum upper bounds for the system
limit parameters.  The significance of these values is that you can
safely push to these limits without checking whether the particular
system you are using can go that far.

`_POSIX_AIO_LISTIO_MAX'
     The most restrictive limit permitted by POSIX for the maximum
     number of I/O operations that can be specified in a list I/O call.
     The value of this constant is `2'; thus you can add up to two new
     entries of the list of outstanding operations.

`_POSIX_AIO_MAX'
     The most restrictive limit permitted by POSIX for the maximum
     number of outstanding asynchronous I/O operations.  The value of
     this constant is `1'.  So you cannot expect that you can issue
     more than one operation and immediately continue with the normal
     work, receiving the notifications asynchronously.

`_POSIX_ARG_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum combined length of the ARGV and ENVIRON
     arguments that can be passed to the `exec' functions.  Its value
     is `4096'.

`_POSIX_CHILD_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of simultaneous processes per real
     user ID.  Its value is `6'.

`_POSIX_NGROUPS_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of supplementary group IDs per
     process.  Its value is `0'.

`_POSIX_OPEN_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of files that a single process can
     have open simultaneously.  Its value is `16'.

`_POSIX_SSIZE_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum value that can be stored in an object of type
     `ssize_t'.  Its value is `32767'.

`_POSIX_STREAM_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of streams that a single process can
     have open simultaneously.  Its value is `8'.

`_POSIX_TZNAME_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum length of a time zone name.  Its value is
     `3'.

`_POSIX2_RE_DUP_MAX'
     The value of this macro is the most restrictive limit permitted by
     POSIX for the numbers used in the `\{MIN,MAX\}' construct in a
     regular expression.  Its value is `255'.


File: libc.info,  Node: Limits for Files,  Next: Options for Files,  Prev: Minimums,  Up: System Configuration

31.6 Limits on File System Capacity
===================================

The POSIX.1 standard specifies a number of parameters that describe the
limitations of the file system.  It's possible for the system to have a
fixed, uniform limit for a parameter, but this isn't the usual case.  On
most systems, it's possible for different file systems (and, for some
parameters, even different files) to have different maximum limits.  For
example, this is very likely if you use NFS to mount some of the file
systems from other machines.

   Each of the following macros is defined in `limits.h' only if the
system has a fixed, uniform limit for the parameter in question.  If the
system allows different file systems or files to have different limits,
then the macro is undefined; use `pathconf' or `fpathconf' to find out
the limit that applies to a particular file.  *Note Pathconf::.

   Each parameter also has another macro, with a name starting with
`_POSIX', which gives the lowest value that the limit is allowed to
have on _any_ POSIX system.  *Note File Minimums::.

 -- Macro: int LINK_MAX
     The uniform system limit (if any) for the number of names for a
     given file.  *Note Hard Links::.

 -- Macro: int MAX_CANON
     The uniform system limit (if any) for the amount of text in a line
     of input when input editing is enabled.  *Note Canonical or Not::.

 -- Macro: int MAX_INPUT
     The uniform system limit (if any) for the total number of
     characters typed ahead as input.  *Note I/O Queues::.

 -- Macro: int NAME_MAX
     The uniform system limit (if any) for the length of a file name
     component.

 -- Macro: int PATH_MAX
     The uniform system limit (if any) for the length of an entire file
     name (that is, the argument given to system calls such as `open').

 -- Macro: int PIPE_BUF
     The uniform system limit (if any) for the number of bytes that can
     be written atomically to a pipe.  If multiple processes are
     writing to the same pipe simultaneously, output from different
     processes might be interleaved in chunks of this size.  *Note
     Pipes and FIFOs::.

   These are alternative macro names for some of the same information.

 -- Macro: int MAXNAMLEN
     This is the BSD name for `NAME_MAX'.  It is defined in `dirent.h'.

 -- Macro: int FILENAME_MAX
     The value of this macro is an integer constant expression that
     represents the maximum length of a file name string.  It is
     defined in `stdio.h'.

     Unlike `PATH_MAX', this macro is defined even if there is no actual
     limit imposed.  In such a case, its value is typically a very large
     number.  *This is always the case on the GNU system.*

     *Usage Note:* Don't use `FILENAME_MAX' as the size of an array in
     which to store a file name!  You can't possibly make an array that
     big!  Use dynamic allocation (*note Memory Allocation::) instead.


File: libc.info,  Node: Options for Files,  Next: File Minimums,  Prev: Limits for Files,  Up: System Configuration

31.7 Optional Features in File Support
======================================

POSIX defines certain system-specific options in the system calls for
operating on files.  Some systems support these options and others do
not.  Since these options are provided in the kernel, not in the
library, simply using the GNU C library does not guarantee that any of
these features is supported; it depends on the system you are using.
They can also vary between file systems on a single machine.

   This section describes the macros you can test to determine whether a
particular option is supported on your machine.  If a given macro is
defined in `unistd.h', then its value says whether the corresponding
feature is supported.  (A value of `-1' indicates no; any other value
indicates yes.)  If the macro is undefined, it means particular files
may or may not support the feature.

   Since all the machines that support the GNU C library also support
NFS, one can never make a general statement about whether all file
systems support the `_POSIX_CHOWN_RESTRICTED' and `_POSIX_NO_TRUNC'
features.  So these names are never defined as macros in the GNU C
library.

 -- Macro: int _POSIX_CHOWN_RESTRICTED
     If this option is in effect, the `chown' function is restricted so
     that the only changes permitted to nonprivileged processes is to
     change the group owner of a file to either be the effective group
     ID of the process, or one of its supplementary group IDs.  *Note
     File Owner::.

 -- Macro: int _POSIX_NO_TRUNC
     If this option is in effect, file name components longer than
     `NAME_MAX' generate an `ENAMETOOLONG' error.  Otherwise, file name
     components that are too long are silently truncated.

 -- Macro: unsigned char _POSIX_VDISABLE
     This option is only meaningful for files that are terminal devices.
     If it is enabled, then handling for special control characters can
     be disabled individually.  *Note Special Characters::.

   If one of these macros is undefined, that means that the option
might be in effect for some files and not for others.  To inquire about
a particular file, call `pathconf' or `fpathconf'.  *Note Pathconf::.


File: libc.info,  Node: File Minimums,  Next: Pathconf,  Prev: Options for Files,  Up: System Configuration

31.8 Minimum Values for File System Limits
==========================================

Here are the names for the POSIX minimum upper bounds for some of the
above parameters.  The significance of these values is that you can
safely push to these limits without checking whether the particular
system you are using can go that far.  In most cases GNU systems do not
have these strict limitations.  The actual limit should be requested if
necessary.

`_POSIX_LINK_MAX'
     The most restrictive limit permitted by POSIX for the maximum
     value of a file's link count.  The value of this constant is `8';
     thus, you can always make up to eight names for a file without
     running into a system limit.

`_POSIX_MAX_CANON'
     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a canonical input line from a terminal device.
     The value of this constant is `255'.

`_POSIX_MAX_INPUT'
     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a terminal device input queue (or typeahead
     buffer).  *Note Input Modes::.  The value of this constant is
     `255'.

`_POSIX_NAME_MAX'
     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a file name component.  The value of this
     constant is `14'.

`_POSIX_PATH_MAX'
     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a file name.  The value of this constant is
     `256'.

`_POSIX_PIPE_BUF'
     The most restrictive limit permitted by POSIX for the maximum
     number of bytes that can be written atomically to a pipe.  The
     value of this constant is `512'.

`SYMLINK_MAX'
     Maximum number of bytes in a symbolic link.

`POSIX_REC_INCR_XFER_SIZE'
     Recommended increment for file transfer sizes between the
     `POSIX_REC_MIN_XFER_SIZE' and `POSIX_REC_MAX_XFER_SIZE' values.

`POSIX_REC_MAX_XFER_SIZE'
     Maximum recommended file transfer size.

`POSIX_REC_MIN_XFER_SIZE'
     Minimum recommended file transfer size.

`POSIX_REC_XFER_ALIGN'
     Recommended file transfer buffer alignment.


File: libc.info,  Node: Pathconf,  Next: Utility Limits,  Prev: File Minimums,  Up: System Configuration

31.9 Using `pathconf'
=====================

When your machine allows different files to have different values for a
file system parameter, you can use the functions in this section to find
out the value that applies to any particular file.

   These functions and the associated constants for the PARAMETER
argument are declared in the header file `unistd.h'.

 -- Function: long int pathconf (const char *FILENAME, int PARAMETER)
     This function is used to inquire about the limits that apply to
     the file named FILENAME.

     The PARAMETER argument should be one of the `_PC_' constants
     listed below.

     The normal return value from `pathconf' is the value you requested.
     A value of `-1' is returned both if the implementation does not
     impose a limit, and in case of an error.  In the former case,
     `errno' is not set, while in the latter case, `errno' is set to
     indicate the cause of the problem.  So the only way to use this
     function robustly is to store `0' into `errno' just before calling
     it.

     Besides the usual file name errors (*note File Name Errors::), the
     following error condition is defined for this function:

    `EINVAL'
          The value of PARAMETER is invalid, or the implementation
          doesn't support the PARAMETER for the specific file.

 -- Function: long int fpathconf (int FILEDES, int PARAMETER)
     This is just like `pathconf' except that an open file descriptor
     is used to specify the file for which information is requested,
     instead of a file name.

     The following `errno' error conditions are defined for this
     function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The value of PARAMETER is invalid, or the implementation
          doesn't support the PARAMETER for the specific file.

   Here are the symbolic constants that you can use as the PARAMETER
argument to `pathconf' and `fpathconf'.  The values are all integer
constants.

`_PC_LINK_MAX'
     Inquire about the value of `LINK_MAX'.

`_PC_MAX_CANON'
     Inquire about the value of `MAX_CANON'.

`_PC_MAX_INPUT'
     Inquire about the value of `MAX_INPUT'.

`_PC_NAME_MAX'
     Inquire about the value of `NAME_MAX'.

`_PC_PATH_MAX'
     Inquire about the value of `PATH_MAX'.

`_PC_PIPE_BUF'
     Inquire about the value of `PIPE_BUF'.

`_PC_CHOWN_RESTRICTED'
     Inquire about the value of `_POSIX_CHOWN_RESTRICTED'.

`_PC_NO_TRUNC'
     Inquire about the value of `_POSIX_NO_TRUNC'.

`_PC_VDISABLE'
     Inquire about the value of `_POSIX_VDISABLE'.

`_PC_SYNC_IO'
     Inquire about the value of `_POSIX_SYNC_IO'.

`_PC_ASYNC_IO'
     Inquire about the value of `_POSIX_ASYNC_IO'.

`_PC_PRIO_IO'
     Inquire about the value of `_POSIX_PRIO_IO'.

`_PC_FILESIZEBITS'
     Inquire about the availability of large files on the filesystem.

`_PC_REC_INCR_XFER_SIZE'
     Inquire about the value of `POSIX_REC_INCR_XFER_SIZE'.

`_PC_REC_MAX_XFER_SIZE'
     Inquire about the value of `POSIX_REC_MAX_XFER_SIZE'.

`_PC_REC_MIN_XFER_SIZE'
     Inquire about the value of `POSIX_REC_MIN_XFER_SIZE'.

`_PC_REC_XFER_ALIGN'
     Inquire about the value of `POSIX_REC_XFER_ALIGN'.


File: libc.info,  Node: Utility Limits,  Next: Utility Minimums,  Prev: Pathconf,  Up: System Configuration

31.10 Utility Program Capacity Limits
=====================================

The POSIX.2 standard specifies certain system limits that you can access
through `sysconf' that apply to utility behavior rather than the
behavior of the library or the operating system.

   The GNU C library defines macros for these limits, and `sysconf'
returns values for them if you ask; but these values convey no
meaningful information.  They are simply the smallest values that
POSIX.2 permits.

 -- Macro: int BC_BASE_MAX
     The largest value of `obase' that the `bc' utility is guaranteed
     to support.

 -- Macro: int BC_DIM_MAX
     The largest number of elements in one array that the `bc' utility
     is guaranteed to support.

 -- Macro: int BC_SCALE_MAX
     The largest value of `scale' that the `bc' utility is guaranteed
     to support.

 -- Macro: int BC_STRING_MAX
     The largest number of characters in one string constant that the
     `bc' utility is guaranteed to support.

 -- Macro: int COLL_WEIGHTS_MAX
     The largest number of weights that can necessarily be used in
     defining the collating sequence for a locale.

 -- Macro: int EXPR_NEST_MAX
     The maximum number of expressions that can be nested within
     parenthesis by the `expr' utility.

 -- Macro: int LINE_MAX
     The largest text line that the text-oriented POSIX.2 utilities can
     support.  (If you are using the GNU versions of these utilities,
     then there is no actual limit except that imposed by the available
     virtual memory, but there is no way that the library can tell you
     this.)

 -- Macro: int EQUIV_CLASS_MAX
     The maximum number of weights that can be assigned to an entry of
     the `LC_COLLATE' category `order' keyword in a locale definition.
     The GNU C library does not presently support locale definitions.


File: libc.info,  Node: Utility Minimums,  Next: String Parameters,  Prev: Utility Limits,  Up: System Configuration

31.11 Minimum Values for Utility Limits
=======================================

`_POSIX2_BC_BASE_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     value of `obase' in the `bc' utility.  Its value is `99'.

`_POSIX2_BC_DIM_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     size of an array in the `bc' utility.  Its value is `2048'.

`_POSIX2_BC_SCALE_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     value of `scale' in the `bc' utility.  Its value is `99'.

`_POSIX2_BC_STRING_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     size of a string constant in the `bc' utility.  Its value is
     `1000'.

`_POSIX2_COLL_WEIGHTS_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     number of weights that can necessarily be used in defining the
     collating sequence for a locale.  Its value is `2'.

`_POSIX2_EXPR_NEST_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     number of expressions nested within parenthesis when using the
     `expr' utility.  Its value is `32'.

`_POSIX2_LINE_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     size of a text line that the text utilities can handle.  Its value
     is `2048'.

`_POSIX2_EQUIV_CLASS_MAX'
     The most restrictive limit permitted by POSIX.2 for the maximum
     number of weights that can be assigned to an entry of the
     `LC_COLLATE' category `order' keyword in a locale definition.  Its
     value is `2'.  The GNU C library does not presently support locale
     definitions.


File: libc.info,  Node: String Parameters,  Prev: Utility Minimums,  Up: System Configuration

31.12 String-Valued Parameters
==============================

POSIX.2 defines a way to get string-valued parameters from the operating
system with the function `confstr':

 -- Function: size_t confstr (int PARAMETER, char *BUF, size_t LEN)
     This function reads the value of a string-valued system parameter,
     storing the string into LEN bytes of memory space starting at BUF.
     The PARAMETER argument should be one of the `_CS_' symbols listed
     below.

     The normal return value from `confstr' is the length of the string
     value that you asked for.  If you supply a null pointer for BUF,
     then `confstr' does not try to store the string; it just returns
     its length.  A value of `0' indicates an error.

     If the string you asked for is too long for the buffer (that is,
     longer than `LEN - 1'), then `confstr' stores just that much
     (leaving room for the terminating null character).  You can tell
     that this has happened because `confstr' returns a value greater
     than or equal to LEN.

     The following `errno' error conditions are defined for this
     function:

    `EINVAL'
          The value of the PARAMETER is invalid.

   Currently there is just one parameter you can read with `confstr':

`_CS_PATH'
     This parameter's value is the recommended default path for
     searching for executable files.  This is the path that a user has
     by default just after logging in.

`_CS_LFS_CFLAGS'
     The returned string specifies which additional flags must be given
     to the C compiler if a source is compiled using the
     `_LARGEFILE_SOURCE' feature select macro; *note Feature Test
     Macros::.

`_CS_LFS_LDFLAGS'
     The returned string specifies which additional flags must be given
     to the linker if a source is compiled using the
     `_LARGEFILE_SOURCE' feature select macro; *note Feature Test
     Macros::.

`_CS_LFS_LIBS'
     The returned string specifies which additional libraries must be
     linked to the application if a source is compiled using the
     `_LARGEFILE_SOURCE' feature select macro; *note Feature Test
     Macros::.

`_CS_LFS_LINTFLAGS'
     The returned string specifies which additional flags must be given
     to the lint tool if a source is compiled using the
     `_LARGEFILE_SOURCE' feature select macro; *note Feature Test
     Macros::.

`_CS_LFS64_CFLAGS'
     The returned string specifies which additional flags must be given
     to the C compiler if a source is compiled using the
     `_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

`_CS_LFS64_LDFLAGS'
     The returned string specifies which additional flags must be given
     to the linker if a source is compiled using the
     `_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

`_CS_LFS64_LIBS'
     The returned string specifies which additional libraries must be
     linked to the application if a source is compiled using the
     `_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

`_CS_LFS64_LINTFLAGS'
     The returned string specifies which additional flags must be given
     to the lint tool if a source is compiled using the
     `_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

   The way to use `confstr' without any arbitrary limit on string size
is to call it twice: first call it to get the length, allocate the
buffer accordingly, and then call `confstr' again to fill the buffer,
like this:

     char *
     get_default_path (void)
     {
       size_t len = confstr (_CS_PATH, NULL, 0);
       char *buffer = (char *) xmalloc (len);

       if (confstr (_CS_PATH, buf, len + 1) == 0)
         {
           free (buffer);
           return NULL;
         }

       return buffer;
     }


File: libc.info,  Node: Cryptographic Functions,  Next: Debugging Support,  Prev: System Configuration,  Up: Top

32 DES Encryption and Password Handling
***************************************

On many systems, it is unnecessary to have any kind of user
authentication; for instance, a workstation which is not connected to a
network probably does not need any user authentication, because to use
the machine an intruder must have physical access.

   Sometimes, however, it is necessary to be sure that a user is
authorized to use some service a machine provides--for instance, to log
in as a particular user id (*note Users and Groups::).  One traditional
way of doing this is for each user to choose a secret "password"; then,
the system can ask someone claiming to be a user what the user's
password is, and if the person gives the correct password then the
system can grant the appropriate privileges.

   If all the passwords are just stored in a file somewhere, then this
file has to be very carefully protected.  To avoid this, passwords are
run through a "one-way function", a function which makes it difficult to
work out what its input was by looking at its output, before storing in
the file.

   The GNU C library provides a one-way function that is compatible with
the behavior of the `crypt' function introduced in FreeBSD 2.0.  It
supports two one-way algorithms: one based on the MD5 message-digest
algorithm that is compatible with modern BSD systems, and the other
based on the Data Encryption Standard (DES) that is compatible with
Unix systems.

   It also provides support for Secure RPC, and some library functions
that can be used to perform normal DES encryption.

* Menu:

* Legal Problems::              This software can get you locked up, or worse.
* getpass::                     Prompting the user for a password.
* crypt::                       A one-way function for passwords.
* DES Encryption::              Routines for DES encryption.


File: libc.info,  Node: Legal Problems,  Next: getpass,  Up: Cryptographic Functions

32.1 Legal Problems
===================

Because of the continuously changing state of the law, it's not possible
to provide a definitive survey of the laws affecting cryptography.
Instead, this section warns you of some of the known trouble spots; this
may help you when you try to find out what the laws of your country are.

   Some countries require that you have a licence to use, possess, or
import cryptography.  These countries are believed to include
Byelorussia, Burma, India, Indonesia, Israel, Kazakhstan, Pakistan,
Russia, and Saudi Arabia.

   Some countries restrict the transmission of encrypted messages by
radio; some telecommunications carriers restrict the transmission of
encrypted messages over their network.

   Many countries have some form of export control for encryption
software.  The Wassenaar Arrangement is a multilateral agreement
between 33 countries (Argentina, Australia, Austria, Belgium, Bulgaria,
Canada, the Czech Republic, Denmark, Finland, France, Germany, Greece,
Hungary, Ireland, Italy, Japan, Luxembourg, the Netherlands, New
Zealand, Norway, Poland, Portugal, the Republic of Korea, Romania, the
Russian Federation, the Slovak Republic, Spain, Sweden, Switzerland,
Turkey, Ukraine, the United Kingdom and the United States) which
restricts some kinds of encryption exports.  Different countries apply
the arrangement in different ways; some do not allow the exception for
certain kinds of "public domain" software (which would include this
library), some only restrict the export of software in tangible form,
and others impose significant additional restrictions.

   The United States has additional rules.  This software would
generally be exportable under 15 CFR 740.13(e), which permits exports of
"encryption source code" which is "publicly available" and which is
"not subject to an express agreement for the payment of a licensing fee
or royalty for commercial production or sale of any product developed
with the source code" to most countries.

   The rules in this area are continuously changing.  If you know of any
information in this manual that is out-of-date, please report it to the
bug database.  *Note Reporting Bugs::.


File: libc.info,  Node: getpass,  Next: crypt,  Prev: Legal Problems,  Up: Cryptographic Functions

32.2 Reading Passwords
======================

When reading in a password, it is desirable to avoid displaying it on
the screen, to help keep it secret.  The following function handles this
in a convenient way.

 -- Function: char * getpass (const char *PROMPT)
     `getpass' outputs PROMPT, then reads a string in from the terminal
     without echoing it.  It tries to connect to the real terminal,
     `/dev/tty', if possible, to encourage users not to put plaintext
     passwords in files; otherwise, it uses `stdin' and `stderr'.
     `getpass' also disables the INTR, QUIT, and SUSP characters on the
     terminal using the `ISIG' terminal attribute (*note Local Modes::).
     The terminal is flushed before and after `getpass', so that
     characters of a mistyped password are not accidentally visible.

     In other C libraries, `getpass' may only return the first
     `PASS_MAX' bytes of a password.  The GNU C library has no limit, so
     `PASS_MAX' is undefined.

     The prototype for this function is in `unistd.h'.  `PASS_MAX'
     would be defined in `limits.h'.

   This precise set of operations may not suit all possible situations.
In this case, it is recommended that users write their own `getpass'
substitute.  For instance, a very simple substitute is as follows:

     #include <termios.h>
     #include <stdio.h>

     ssize_t
     my_getpass (char **lineptr, size_t *n, FILE *stream)
     {
       struct termios old, new;
       int nread;

       /* Turn echoing off and fail if we can't. */
       if (tcgetattr (fileno (stream), &old) != 0)
         return -1;
       new = old;
       new.c_lflag &= ~ECHO;
       if (tcsetattr (fileno (stream), TCSAFLUSH, &new) != 0)
         return -1;

       /* Read the password. */
       nread = getline (lineptr, n, stream);

       /* Restore terminal. */
       (void) tcsetattr (fileno (stream), TCSAFLUSH, &old);

       return nread;
     }

   The substitute takes the same parameters as `getline' (*note Line
Input::); the user must print any prompt desired.


File: libc.info,  Node: crypt,  Next: DES Encryption,  Prev: getpass,  Up: Cryptographic Functions

32.3 Encrypting Passwords
=========================

 -- Function: char * crypt (const char *KEY, const char *SALT)
     The `crypt' function takes a password, KEY, as a string, and a
     SALT character array which is described below, and returns a
     printable ASCII string which starts with another salt.  It is
     believed that, given the output of the function, the best way to
     find a KEY that will produce that output is to guess values of KEY
     until the original value of KEY is found.

     The SALT parameter does two things.  Firstly, it selects which
     algorithm is used, the MD5-based one or the DES-based one.
     Secondly, it makes life harder for someone trying to guess
     passwords against a file containing many passwords; without a
     SALT, an intruder can make a guess, run `crypt' on it once, and
     compare the result with all the passwords.  With a SALT, the
     intruder must run `crypt' once for each different salt.

     For the MD5-based algorithm, the SALT should consist of the string
     `$1$', followed by up to 8 characters, terminated by either
     another `$' or the end of the string.  The result of `crypt' will
     be the SALT, followed by a `$' if the salt didn't end with one,
     followed by 22 characters from the alphabet `./0-9A-Za-z', up to
     34 characters total.  Every character in the KEY is significant.

     For the DES-based algorithm, the SALT should consist of two
     characters from the alphabet `./0-9A-Za-z', and the result of
     `crypt' will be those two characters followed by 11 more from the
     same alphabet, 13 in total.  Only the first 8 characters in the
     KEY are significant.

     The MD5-based algorithm has no limit on the useful length of the
     password used, and is slightly more secure.  It is therefore
     preferred over the DES-based algorithm.

     When the user enters their password for the first time, the SALT
     should be set to a new string which is reasonably random.  To
     verify a password against the result of a previous call to
     `crypt', pass the result of the previous call as the SALT.

   The following short program is an example of how to use `crypt' the
first time a password is entered.  Note that the SALT generation is
just barely acceptable; in particular, it is not unique between
machines, and in many applications it would not be acceptable to let an
attacker know what time the user's password was last set.

     #include <stdio.h>
     #include <time.h>
     #include <unistd.h>
     #include <crypt.h>

     int
     main(void)
     {
       unsigned long seed[2];
       char salt[] = "$1$........";
       const char *const seedchars =
         "./0123456789ABCDEFGHIJKLMNOPQRST"
         "UVWXYZabcdefghijklmnopqrstuvwxyz";
       char *password;
       int i;

       /* Generate a (not very) random seed.
          You should do it better than this... */
       seed[0] = time(NULL);
       seed[1] = getpid() ^ (seed[0] >> 14 & 0x30000);

       /* Turn it into printable characters from `seedchars'. */
       for (i = 0; i < 8; i++)
         salt[3+i] = seedchars[(seed[i/5] >> (i%5)*6) & 0x3f];

       /* Read in the user's password and encrypt it. */
       password = crypt(getpass("Password:"), salt);

       /* Print the results. */
       puts(password);
       return 0;
     }

   The next program shows how to verify a password.  It prompts the user
for a password and prints "Access granted." if the user types `GNU libc
manual'.

     #include <stdio.h>
     #include <string.h>
     #include <unistd.h>
     #include <crypt.h>

     int
     main(void)
     {
       /* Hashed form of "GNU libc manual". */
       const char *const pass = "$1$/iSaq7rB$EoUw5jJPPvAPECNaaWzMK/";

       char *result;
       int ok;

       /* Read in the user's password and encrypt it,
          passing the expected password in as the salt. */
       result = crypt(getpass("Password:"), pass);

       /* Test the result. */
       ok = strcmp (result, pass) == 0;

       puts(ok ? "Access granted." : "Access denied.");
       return ok ? 0 : 1;
     }

 -- Function: char * crypt_r (const char *KEY, const char *SALT, struct
          crypt_data * DATA)
     The `crypt_r' function does the same thing as `crypt', but takes
     an extra parameter which includes space for its result (among
     other things), so it can be reentrant.  `data->initialized' must be
     cleared to zero before the first time `crypt_r' is called.

     The `crypt_r' function is a GNU extension.

   The `crypt' and `crypt_r' functions are prototyped in the header
`crypt.h'.


File: libc.info,  Node: DES Encryption,  Prev: crypt,  Up: Cryptographic Functions

32.4 DES Encryption
===================

The Data Encryption Standard is described in the US Government Federal
Information Processing Standards (FIPS) 46-3 published by the National
Institute of Standards and Technology.  The DES has been very thoroughly
analyzed since it was developed in the late 1970s, and no new
significant flaws have been found.

   However, the DES uses only a 56-bit key (plus 8 parity bits), and a
machine has been built in 1998 which can search through all possible
keys in about 6 days, which cost about US$200000; faster searches would
be possible with more money.  This makes simple DES insecure for most
purposes, and NIST no longer permits new US government systems to use
simple DES.

   For serious encryption functionality, it is recommended that one of
the many free encryption libraries be used instead of these routines.

   The DES is a reversible operation which takes a 64-bit block and a
64-bit key, and produces another 64-bit block.  Usually the bits are
numbered so that the most-significant bit, the first bit, of each block
is numbered 1.

   Under that numbering, every 8th bit of the key (the 8th, 16th, and so
on) is not used by the encryption algorithm itself.  But the key must
have odd parity; that is, out of bits 1 through 8, and 9 through 16, and
so on, there must be an odd number of `1' bits, and this completely
specifies the unused bits.

 -- Function: void setkey (const char *KEY)
     The `setkey' function sets an internal data structure to be an
     expanded form of KEY.  KEY is specified as an array of 64 bits
     each stored in a `char', the first bit is `key[0]' and the 64th
     bit is `key[63]'.  The KEY should have the correct parity.

 -- Function: void encrypt (char *BLOCK, int EDFLAG)
     The `encrypt' function encrypts BLOCK if EDFLAG is 0, otherwise it
     decrypts BLOCK, using a key previously set by `setkey'.  The
     result is placed in BLOCK.

     Like `setkey', BLOCK is specified as an array of 64 bits each
     stored in a `char', but there are no parity bits in BLOCK.

 -- Function: void setkey_r (const char *KEY, struct crypt_data * DATA)
 -- Function: void encrypt_r (char *BLOCK, int EDFLAG, struct
          crypt_data * DATA)
     These are reentrant versions of `setkey' and `encrypt'.  The only
     difference is the extra parameter, which stores the expanded
     version of KEY.  Before calling `setkey_r' the first time,
     `data->initialized' must be cleared to zero.

   The `setkey_r' and `encrypt_r' functions are GNU extensions.
`setkey', `encrypt', `setkey_r', and `encrypt_r' are defined in
`crypt.h'.

 -- Function: int ecb_crypt (char *KEY, char *BLOCKS, unsigned LEN,
          unsigned MODE)
     The function `ecb_crypt' encrypts or decrypts one or more blocks
     using DES.  Each block is encrypted independently.

     The BLOCKS and the KEY are stored packed in 8-bit bytes, so that
     the first bit of the key is the most-significant bit of `key[0]'
     and the 63rd bit of the key is stored as the least-significant bit
     of `key[7]'.  The KEY should have the correct parity.

     LEN is the number of bytes in BLOCKS.  It should be a multiple of
     8 (so that there is a whole number of blocks to encrypt).  LEN is
     limited to a maximum of `DES_MAXDATA' bytes.

     The result of the encryption replaces the input in BLOCKS.

     The MODE parameter is the bitwise OR of two of the following:

    `DES_ENCRYPT'
          This constant, used in the MODE parameter, specifies that
          BLOCKS is to be encrypted.

    `DES_DECRYPT'
          This constant, used in the MODE parameter, specifies that
          BLOCKS is to be decrypted.

    `DES_HW'
          This constant, used in the MODE parameter, asks to use a
          hardware device.  If no hardware device is available,
          encryption happens anyway, but in software.

    `DES_SW'
          This constant, used in the MODE parameter, specifies that no
          hardware device is to be used.

     The result of the function will be one of these values:

    `DESERR_NONE'
          The encryption succeeded.

    `DESERR_NOHWDEVICE'
          The encryption succeeded, but there was no hardware device
          available.

    `DESERR_HWERROR'
          The encryption failed because of a hardware problem.

    `DESERR_BADPARAM'
          The encryption failed because of a bad parameter, for
          instance LEN is not a multiple of 8 or LEN is larger than
          `DES_MAXDATA'.

 -- Function: int DES_FAILED (int ERR)
     This macro returns 1 if ERR is a `success' result code from
     `ecb_crypt' or `cbc_crypt', and 0 otherwise.

 -- Function: int cbc_crypt (char *KEY, char *BLOCKS, unsigned LEN,
          unsigned MODE, char *IVEC)
     The function `cbc_crypt' encrypts or decrypts one or more blocks
     using DES in Cipher Block Chaining mode.

     For encryption in CBC mode, each block is exclusive-ored with IVEC
     before being encrypted, then IVEC is replaced with the result of
     the encryption, then the next block is processed.  Decryption is
     the reverse of this process.

     This has the advantage that blocks which are the same before being
     encrypted are very unlikely to be the same after being encrypted,
     making it much harder to detect patterns in the data.

     Usually, IVEC is set to 8 random bytes before encryption starts.
     Then the 8 random bytes are transmitted along with the encrypted
     data (without themselves being encrypted), and passed back in as
     IVEC for decryption.  Another possibility is to set IVEC to 8
     zeroes initially, and have the first the block encrypted consist
     of 8 random bytes.

     Otherwise, all the parameters are similar to those for `ecb_crypt'.

 -- Function: void des_setparity (char *KEY)
     The function `des_setparity' changes the 64-bit KEY, stored packed
     in 8-bit bytes, to have odd parity by altering the low bits of
     each byte.

   The `ecb_crypt', `cbc_crypt', and `des_setparity' functions and
their accompanying macros are all defined in the header
`rpc/des_crypt.h'.


File: libc.info,  Node: Debugging Support,  Next: Language Features,  Prev: Cryptographic Functions,  Up: Top

33 Debugging support
********************

Applications are usually debugged using dedicated debugger programs.
But sometimes this is not possible and, in any case, it is useful to
provide the developer with as much information as possible at the time
the problems are experienced.  For this reason a few functions are
provided which a program can use to help the developer more easily
locate the problem.

* Menu:

* Backtraces::                Obtaining and printing a back trace of the
                               current stack.


File: libc.info,  Node: Backtraces,  Up: Debugging Support

33.1 Backtraces
===============

A "backtrace" is a list of the function calls that are currently active
in a thread.  The usual way to inspect a backtrace of a program is to
use an external debugger such as gdb.  However, sometimes it is useful
to obtain a backtrace programmatically from within a program, e.g., for
the purposes of logging or diagnostics.

   The header file `execinfo.h' declares three functions that obtain
and manipulate backtraces of the current thread.  

 -- Function: int backtrace (void **BUFFER, int SIZE)
     The `backtrace' function obtains a backtrace for the current
     thread, as a list of pointers, and places the information into
     BUFFER.  The argument SIZE should be the number of `void *'
     elements that will fit into BUFFER.  The return value is the
     actual number of entries of BUFFER that are obtained, and is at
     most SIZE.

     The pointers placed in BUFFER are actually return addresses
     obtained by inspecting the stack, one return address per stack
     frame.

     Note that certain compiler optimizations may interfere with
     obtaining a valid backtrace.  Function inlining causes the inlined
     function to not have a stack frame; tail call optimization
     replaces one stack frame with another; frame pointer elimination
     will stop `backtrace' from interpreting the stack contents
     correctly.

 -- Function: char ** backtrace_symbols (void *const *BUFFER, int SIZE)
     The `backtrace_symbols' function translates the information
     obtained from the `backtrace' function into an array of strings.
     The argument BUFFER should be a pointer to an array of addresses
     obtained via the `backtrace' function, and SIZE is the number of
     entries in that array (the return value of `backtrace').

     The return value is a pointer to an array of strings, which has
     SIZE entries just like the array BUFFER.  Each string contains a
     printable representation of the corresponding element of BUFFER.
     It includes the function name (if this can be determined), an
     offset into the function, and the actual return address (in
     hexadecimal).

     Currently, the function name and offset only be obtained on
     systems that use the ELF binary format for programs and libraries.
     On other systems, only the hexadecimal return address will be
     present.  Also, you may need to pass additional flags to the
     linker to make the function names available to the program.  (For
     example, on systems using GNU ld, you must pass (`-rdynamic'.)

     The return value of `backtrace_symbols' is a pointer obtained via
     the `malloc' function, and it is the responsibility of the caller
     to `free' that pointer.  Note that only the return value need be
     freed, not the individual strings.

     The return value is `NULL' if sufficient memory for the strings
     cannot be obtained.

 -- Function: void backtrace_symbols_fd (void *const *BUFFER, int SIZE,
          int FD)
     The `backtrace_symbols_fd' function performs the same translation
     as the function `backtrace_symbols' function.  Instead of returning
     the strings to the caller, it writes the strings to the file
     descriptor FD, one per line.  It does not use the `malloc'
     function, and can therefore be used in situations where that
     function might fail.

   The following program illustrates the use of these functions.  Note
that the array to contain the return addresses returned by `backtrace'
is allocated on the stack.  Therefore code like this can be used in
situations where the memory handling via `malloc' does not work anymore
(in which case the `backtrace_symbols' has to be replaced by a
`backtrace_symbols_fd' call as well).  The number of return addresses
is normally not very large.  Even complicated programs rather seldom
have a nesting level of more than, say, 50 and with 200 possible
entries probably all programs should be covered.

     #include <execinfo.h>
     #include <stdio.h>
     #include <stdlib.h>

     /* Obtain a backtrace and print it to `stdout'. */
     void
     print_trace (void)
     {
       void *array[10];
       size_t size;
       char **strings;
       size_t i;

       size = backtrace (array, 10);
       strings = backtrace_symbols (array, size);

       printf ("Obtained %zd stack frames.\n", size);

       for (i = 0; i < size; i++)
          printf ("%s\n", strings[i]);

       free (strings);
     }

     /* A dummy function to make the backtrace more interesting. */
     void
     dummy_function (void)
     {
       print_trace ();
     }

     int
     main (void)
     {
       dummy_function ();
       return 0;
     }


File: libc.info,  Node: Language Features,  Next: Library Summary,  Prev: Debugging Support,  Up: Top

Appendix A C Language Facilities in the Library
***********************************************

Some of the facilities implemented by the C library really should be
thought of as parts of the C language itself.  These facilities ought to
be documented in the C Language Manual, not in the library manual; but
since we don't have the language manual yet, and documentation for these
features has been written, we are publishing it here.

* Menu:

* Consistency Checking::        Using `assert' to abort if
				 something ``impossible'' happens.
* Variadic Functions::          Defining functions with varying numbers
                                 of args.
* Null Pointer Constant::       The macro `NULL'.
* Important Data Types::        Data types for object sizes.
* Data Type Measurements::      Parameters of data type representations.


File: libc.info,  Node: Consistency Checking,  Next: Variadic Functions,  Up: Language Features

A.1 Explicitly Checking Internal Consistency
============================================

When you're writing a program, it's often a good idea to put in checks
at strategic places for "impossible" errors or violations of basic
assumptions.  These kinds of checks are helpful in debugging problems
with the interfaces between different parts of the program, for example.

   The `assert' macro, defined in the header file `assert.h', provides
a convenient way to abort the program while printing a message about
where in the program the error was detected.

   Once you think your program is debugged, you can disable the error
checks performed by the `assert' macro by recompiling with the macro
`NDEBUG' defined.  This means you don't actually have to change the
program source code to disable these checks.

   But disabling these consistency checks is undesirable unless they
make the program significantly slower.  All else being equal, more error
checking is good no matter who is running the program.  A wise user
would rather have a program crash, visibly, than have it return nonsense
without indicating anything might be wrong.

 -- Macro: void assert (int EXPRESSION)
     Verify the programmer's belief that EXPRESSION is nonzero at this
     point in the program.

     If `NDEBUG' is not defined, `assert' tests the value of
     EXPRESSION.  If it is false (zero), `assert' aborts the program
     (*note Aborting a Program::) after printing a message of the form:

          `FILE':LINENUM: FUNCTION: Assertion `EXPRESSION' failed.

     on the standard error stream `stderr' (*note Standard Streams::).
     The filename and line number are taken from the C preprocessor
     macros `__FILE__' and `__LINE__' and specify where the call to
     `assert' was made.  When using the GNU C compiler, the name of the
     function which calls `assert' is taken from the built-in variable
     `__PRETTY_FUNCTION__'; with older compilers, the function name and
     following colon are omitted.

     If the preprocessor macro `NDEBUG' is defined before `assert.h' is
     included, the `assert' macro is defined to do absolutely nothing.

     *Warning:* Even the argument expression EXPRESSION is not
     evaluated if `NDEBUG' is in effect.  So never use `assert' with
     arguments that involve side effects.  For example, `assert (++i >
     0);' is a bad idea, because `i' will not be incremented if
     `NDEBUG' is defined.

   Sometimes the "impossible" condition you want to check for is an
error return from an operating system function.  Then it is useful to
display not only where the program crashes, but also what error was
returned.  The `assert_perror' macro makes this easy.

 -- Macro: void assert_perror (int ERRNUM)
     Similar to `assert', but verifies that ERRNUM is zero.

     If `NDEBUG' is not defined, `assert_perror' tests the value of
     ERRNUM.  If it is nonzero, `assert_perror' aborts the program
     after printing a message of the form:

          `FILE':LINENUM: FUNCTION: ERROR TEXT

     on the standard error stream.  The file name, line number, and
     function name are as for `assert'.  The error text is the result of
     `strerror (ERRNUM)'.  *Note Error Messages::.

     Like `assert', if `NDEBUG' is defined before `assert.h' is
     included, the `assert_perror' macro does absolutely nothing.  It
     does not evaluate the argument, so ERRNUM should not have any side
     effects.  It is best for ERRNUM to be just a simple variable
     reference; often it will be `errno'.

     This macro is a GNU extension.

   *Usage note:* The `assert' facility is designed for detecting
_internal inconsistency_; it is not suitable for reporting invalid
input or improper usage by the _user_ of the program.

   The information in the diagnostic messages printed by the `assert'
and `assert_perror' macro is intended to help you, the programmer,
track down the cause of a bug, but is not really useful for telling a
user of your program why his or her input was invalid or why a command
could not be carried out.  What's more, your program should not abort
when given invalid input, as `assert' would do--it should exit with
nonzero status (*note Exit Status::) after printing its error messages,
or perhaps read another command or move on to the next input file.

   *Note Error Messages::, for information on printing error messages
for problems that _do not_ represent bugs in the program.


File: libc.info,  Node: Variadic Functions,  Next: Null Pointer Constant,  Prev: Consistency Checking,  Up: Language Features

A.2 Variadic Functions
======================

ISO C defines a syntax for declaring a function to take a variable
number or type of arguments.  (Such functions are referred to as
"varargs functions" or "variadic functions".)  However, the language
itself provides no mechanism for such functions to access their
non-required arguments; instead, you use the variable arguments macros
defined in `stdarg.h'.

   This section describes how to declare variadic functions, how to
write them, and how to call them properly.

   *Compatibility Note:* Many older C dialects provide a similar, but
incompatible, mechanism for defining functions with variable numbers of
arguments, using `varargs.h'.

* Menu:

* Why Variadic::                Reasons for making functions take
                                 variable arguments.
* How Variadic::                How to define and call variadic functions.
* Variadic Example::            A complete example.


File: libc.info,  Node: Why Variadic,  Next: How Variadic,  Up: Variadic Functions

A.2.1 Why Variadic Functions are Used
-------------------------------------

Ordinary C functions take a fixed number of arguments.  When you define
a function, you specify the data type for each argument.  Every call to
the function should supply the expected number of arguments, with types
that can be converted to the specified ones.  Thus, if the function
`foo' is declared with `int foo (int, char *);' then you must call it
with two arguments, a number (any kind will do) and a string pointer.

   But some functions perform operations that can meaningfully accept an
unlimited number of arguments.

   In some cases a function can handle any number of values by
operating on all of them as a block.  For example, consider a function
that allocates a one-dimensional array with `malloc' to hold a
specified set of values.  This operation makes sense for any number of
values, as long as the length of the array corresponds to that number.
Without facilities for variable arguments, you would have to define a
separate function for each possible array size.

   The library function `printf' (*note Formatted Output::) is an
example of another class of function where variable arguments are
useful.  This function prints its arguments (which can vary in type as
well as number) under the control of a format template string.

   These are good reasons to define a "variadic" function which can
handle as many arguments as the caller chooses to pass.

   Some functions such as `open' take a fixed set of arguments, but
occasionally ignore the last few.  Strict adherence to ISO C requires
these functions to be defined as variadic; in practice, however, the GNU
C compiler and most other C compilers let you define such a function to
take a fixed set of arguments--the most it can ever use--and then only
_declare_ the function as variadic (or not declare its arguments at
all!).


File: libc.info,  Node: How Variadic,  Next: Variadic Example,  Prev: Why Variadic,  Up: Variadic Functions

A.2.2 How Variadic Functions are Defined and Used
-------------------------------------------------

Defining and using a variadic function involves three steps:

   * _Define_ the function as variadic, using an ellipsis (`...') in
     the argument list, and using special macros to access the variable
     arguments.  *Note Receiving Arguments::.

   * _Declare_ the function as variadic, using a prototype with an
     ellipsis (`...'), in all the files which call it.  *Note Variadic
     Prototypes::.

   * _Call_ the function by writing the fixed arguments followed by the
     additional variable arguments.  *Note Calling Variadics::.

* Menu:

* Variadic Prototypes::  How to make a prototype for a function
			  with variable arguments.
* Receiving Arguments::  Steps you must follow to access the
			  optional argument values.
* How Many Arguments::   How to decide whether there are more arguments.
* Calling Variadics::    Things you need to know about calling
			  variable arguments functions.
* Argument Macros::      Detailed specification of the macros
        		  for accessing variable arguments.
* Old Varargs::		 The pre-ISO way of defining variadic functions.


File: libc.info,  Node: Variadic Prototypes,  Next: Receiving Arguments,  Up: How Variadic

A.2.2.1 Syntax for Variable Arguments
.....................................

A function that accepts a variable number of arguments must be declared
with a prototype that says so.   You write the fixed arguments as usual,
and then tack on `...' to indicate the possibility of additional
arguments.  The syntax of ISO C requires at least one fixed argument
before the `...'.  For example,

     int
     func (const char *a, int b, ...)
     {
       ...
     }

defines a function `func' which returns an `int' and takes two required
arguments, a `const char *' and an `int'.  These are followed by any
number of anonymous arguments.

   *Portability note:* For some C compilers, the last required argument
must not be declared `register' in the function definition.
Furthermore, this argument's type must be "self-promoting": that is,
the default promotions must not change its type.  This rules out array
and function types, as well as `float', `char' (whether signed or not)
and `short int' (whether signed or not).  This is actually an ISO C
requirement.


File: libc.info,  Node: Receiving Arguments,  Next: How Many Arguments,  Prev: Variadic Prototypes,  Up: How Variadic

A.2.2.2 Receiving the Argument Values
.....................................

Ordinary fixed arguments have individual names, and you can use these
names to access their values.  But optional arguments have no
names--nothing but `...'.  How can you access them?

   The only way to access them is sequentially, in the order they were
written, and you must use special macros from `stdarg.h' in the
following three step process:

  1. You initialize an argument pointer variable of type `va_list' using
     `va_start'.  The argument pointer when initialized points to the
     first optional argument.

  2. You access the optional arguments by successive calls to `va_arg'.
     The first call to `va_arg' gives you the first optional argument,
     the next call gives you the second, and so on.

     You can stop at any time if you wish to ignore any remaining
     optional arguments.  It is perfectly all right for a function to
     access fewer arguments than were supplied in the call, but you
     will get garbage values if you try to access too many arguments.

  3. You indicate that you are finished with the argument pointer
     variable by calling `va_end'.

     (In practice, with most C compilers, calling `va_end' does nothing.
     This is always true in the GNU C compiler.  But you might as well
     call `va_end' just in case your program is someday compiled with a
     peculiar compiler.)

   *Note Argument Macros::, for the full definitions of `va_start',
`va_arg' and `va_end'.

   Steps 1 and 3 must be performed in the function that accepts the
optional arguments.  However, you can pass the `va_list' variable as an
argument to another function and perform all or part of step 2 there.

   You can perform the entire sequence of three steps multiple times
within a single function invocation.  If you want to ignore the optional
arguments, you can do these steps zero times.

   You can have more than one argument pointer variable if you like.
You can initialize each variable with `va_start' when you wish, and
then you can fetch arguments with each argument pointer as you wish.
Each argument pointer variable will sequence through the same set of
argument values, but at its own pace.

   *Portability note:* With some compilers, once you pass an argument
pointer value to a subroutine, you must not keep using the same
argument pointer value after that subroutine returns.  For full
portability, you should just pass it to `va_end'.  This is actually an
ISO C requirement, but most ANSI C compilers work happily regardless.


File: libc.info,  Node: How Many Arguments,  Next: Calling Variadics,  Prev: Receiving Arguments,  Up: How Variadic

A.2.2.3 How Many Arguments Were Supplied
........................................

There is no general way for a function to determine the number and type
of the optional arguments it was called with.  So whoever designs the
function typically designs a convention for the caller to specify the
number and type of arguments.  It is up to you to define an appropriate
calling convention for each variadic function, and write all calls
accordingly.

   One kind of calling convention is to pass the number of optional
arguments as one of the fixed arguments.  This convention works provided
all of the optional arguments are of the same type.

   A similar alternative is to have one of the required arguments be a
bit mask, with a bit for each possible purpose for which an optional
argument might be supplied.  You would test the bits in a predefined
sequence; if the bit is set, fetch the value of the next argument,
otherwise use a default value.

   A required argument can be used as a pattern to specify both the
number and types of the optional arguments.  The format string argument
to `printf' is one example of this (*note Formatted Output Functions::).

   Another possibility is to pass an "end marker" value as the last
optional argument.  For example, for a function that manipulates an
arbitrary number of pointer arguments, a null pointer might indicate the
end of the argument list.  (This assumes that a null pointer isn't
otherwise meaningful to the function.)  The `execl' function works in
just this way; see *Note Executing a File::.


File: libc.info,  Node: Calling Variadics,  Next: Argument Macros,  Prev: How Many Arguments,  Up: How Variadic

A.2.2.4 Calling Variadic Functions
..................................

You don't have to do anything special to call a variadic function.
Just put the arguments (required arguments, followed by optional ones)
inside parentheses, separated by commas, as usual.  But you must declare
the function with a prototype and know how the argument values are
converted.

   In principle, functions that are _defined_ to be variadic must also
be _declared_ to be variadic using a function prototype whenever you
call them.  (*Note Variadic Prototypes::, for how.)  This is because
some C compilers use a different calling convention to pass the same set
of argument values to a function depending on whether that function
takes variable arguments or fixed arguments.

   In practice, the GNU C compiler always passes a given set of argument
types in the same way regardless of whether they are optional or
required.  So, as long as the argument types are self-promoting, you can
safely omit declaring them.  Usually it is a good idea to declare the
argument types for variadic functions, and indeed for all functions.
But there are a few functions which it is extremely convenient not to
have to declare as variadic--for example, `open' and `printf'.

   Since the prototype doesn't specify types for optional arguments, in
a call to a variadic function the "default argument promotions" are
performed on the optional argument values.  This means the objects of
type `char' or `short int' (whether signed or not) are promoted to
either `int' or `unsigned int', as appropriate; and that objects of
type `float' are promoted to type `double'.  So, if the caller passes a
`char' as an optional argument, it is promoted to an `int', and the
function can access it with `va_arg (AP, int)'.

   Conversion of the required arguments is controlled by the function
prototype in the usual way: the argument expression is converted to the
declared argument type as if it were being assigned to a variable of
that type.


File: libc.info,  Node: Argument Macros,  Next: Old Varargs,  Prev: Calling Variadics,  Up: How Variadic

A.2.2.5 Argument Access Macros
..............................

Here are descriptions of the macros used to retrieve variable arguments.
These macros are defined in the header file `stdarg.h'.  

 -- Data Type: va_list
     The type `va_list' is used for argument pointer variables.

 -- Macro: void va_start (va_list AP, LAST-REQUIRED)
     This macro initializes the argument pointer variable AP to point
     to the first of the optional arguments of the current function;
     LAST-REQUIRED must be the last required argument to the function.

     *Note Old Varargs::, for an alternate definition of `va_start'
     found in the header file `varargs.h'.

 -- Macro: TYPE va_arg (va_list AP, TYPE)
     The `va_arg' macro returns the value of the next optional argument,
     and modifies the value of AP to point to the subsequent argument.
     Thus, successive uses of `va_arg' return successive optional
     arguments.

     The type of the value returned by `va_arg' is TYPE as specified in
     the call.  TYPE must be a self-promoting type (not `char' or
     `short int' or `float') that matches the type of the actual
     argument.

 -- Macro: void va_end (va_list AP)
     This ends the use of AP.  After a `va_end' call, further `va_arg'
     calls with the same AP may not work.  You should invoke `va_end'
     before returning from the function in which `va_start' was invoked
     with the same AP argument.

     In the GNU C library, `va_end' does nothing, and you need not ever
     use it except for reasons of portability.


   Sometimes it is necessary to parse the list of parameters more than
once or one wants to remember a certain position in the parameter list.
To do this, one will have to make a copy of the current value of the
argument.  But `va_list' is an opaque type and one cannot necessarily
assign the value of one variable of type `va_list' to another variable
of the same type.

 -- Macro: void __va_copy (va_list DEST, va_list SRC)
     The `__va_copy' macro allows copying of objects of type `va_list'
     even if this is not an integral type.  The argument pointer in
     DEST is initialized to point to the same argument as the pointer
     in SRC.

     This macro is a GNU extension but it will hopefully also be
     available in the next update of the ISO C standard.

   If you want to use `__va_copy' you should always be prepared for the
possibility that this macro will not be available.  On architectures
where a simple assignment is invalid, hopefully `__va_copy' _will_ be
available, so one should always write something like this:

     {
       va_list ap, save;
       ...
     #ifdef __va_copy
       __va_copy (save, ap);
     #else
       save = ap;
     #endif
       ...
     }


File: libc.info,  Node: Variadic Example,  Prev: How Variadic,  Up: Variadic Functions

A.2.3 Example of a Variadic Function
------------------------------------

Here is a complete sample function that accepts a variable number of
arguments.  The first argument to the function is the count of remaining
arguments, which are added up and the result returned.  While trivial,
this function is sufficient to illustrate how to use the variable
arguments facility.

     #include <stdarg.h>
     #include <stdio.h>

     int
     add_em_up (int count,...)
     {
       va_list ap;
       int i, sum;

       va_start (ap, count);         /* Initialize the argument list. */

       sum = 0;
       for (i = 0; i < count; i++)
         sum += va_arg (ap, int);    /* Get the next argument value. */

       va_end (ap);                  /* Clean up. */
       return sum;
     }

     int
     main (void)
     {
       /* This call prints 16. */
       printf ("%d\n", add_em_up (3, 5, 5, 6));

       /* This call prints 55. */
       printf ("%d\n", add_em_up (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

       return 0;
     }


File: libc.info,  Node: Old Varargs,  Prev: Argument Macros,  Up: How Variadic

A.2.3.1 Old-Style Variadic Functions
....................................

Before ISO C, programmers used a slightly different facility for
writing variadic functions.  The GNU C compiler still supports it;
currently, it is more portable than the ISO C facility, since support
for ISO C is still not universal.  The header file which defines the
old-fashioned variadic facility is called `varargs.h'.

   Using `varargs.h' is almost the same as using `stdarg.h'.  There is
no difference in how you call a variadic function; see *Note Calling
Variadics::.  The only difference is in how you define them.  First of
all, you must use old-style non-prototype syntax, like this:

     tree
     build (va_alist)
          va_dcl
     {

   Secondly, you must give `va_start' only one argument, like this:

       va_list p;
       va_start (p);

   These are the special macros used for defining old-style variadic
functions:

 -- Macro: va_alist
     This macro stands for the argument name list required in a variadic
     function.

 -- Macro: va_dcl
     This macro declares the implicit argument or arguments for a
     variadic function.

 -- Macro: void va_start (va_list AP)
     This macro, as defined in `varargs.h', initializes the argument
     pointer variable AP to point to the first argument of the current
     function.

   The other argument macros, `va_arg' and `va_end', are the same in
`varargs.h' as in `stdarg.h'; see *Note Argument Macros::, for details.

   It does not work to include both `varargs.h' and `stdarg.h' in the
same compilation; they define `va_start' in conflicting ways.


File: libc.info,  Node: Null Pointer Constant,  Next: Important Data Types,  Prev: Variadic Functions,  Up: Language Features

A.3 Null Pointer Constant
=========================

The null pointer constant is guaranteed not to point to any real object.
You can assign it to any pointer variable since it has type `void *'.
The preferred way to write a null pointer constant is with `NULL'.

 -- Macro: void * NULL
     This is a null pointer constant.

   You can also use `0' or `(void *)0' as a null pointer constant, but
using `NULL' is cleaner because it makes the purpose of the constant
more evident.

   If you use the null pointer constant as a function argument, then for
complete portability you should make sure that the function has a
prototype declaration.  Otherwise, if the target machine has two
different pointer representations, the compiler won't know which
representation to use for that argument.  You can avoid the problem by
explicitly casting the constant to the proper pointer type, but we
recommend instead adding a prototype for the function you are calling.


File: libc.info,  Node: Important Data Types,  Next: Data Type Measurements,  Prev: Null Pointer Constant,  Up: Language Features

A.4 Important Data Types
========================

The result of subtracting two pointers in C is always an integer, but
the precise data type varies from C compiler to C compiler.  Likewise,
the data type of the result of `sizeof' also varies between compilers.
ISO defines standard aliases for these two types, so you can refer to
them in a portable fashion.  They are defined in the header file
`stddef.h'.  

 -- Data Type: ptrdiff_t
     This is the signed integer type of the result of subtracting two
     pointers.  For example, with the declaration `char *p1, *p2;', the
     expression `p2 - p1' is of type `ptrdiff_t'.  This will probably
     be one of the standard signed integer types (`short int', `int' or
     `long int'), but might be a nonstandard type that exists only for
     this purpose.

 -- Data Type: size_t
     This is an unsigned integer type used to represent the sizes of
     objects.  The result of the `sizeof' operator is of this type, and
     functions such as `malloc' (*note Unconstrained Allocation::) and
     `memcpy' (*note Copying and Concatenation::) accept arguments of
     this type to specify object sizes.

     *Usage Note:* `size_t' is the preferred way to declare any
     arguments or variables that hold the size of an object.

   In the GNU system `size_t' is equivalent to either `unsigned int' or
`unsigned long int'.  These types have identical properties on the GNU
system and, for most purposes, you can use them interchangeably.
However, they are distinct as data types, which makes a difference in
certain contexts.

   For example, when you specify the type of a function argument in a
function prototype, it makes a difference which one you use.  If the
system header files declare `malloc' with an argument of type `size_t'
and you declare `malloc' with an argument of type `unsigned int', you
will get a compilation error if `size_t' happens to be `unsigned long
int' on your system.  To avoid any possibility of error, when a
function argument or value is supposed to have type `size_t', never
declare its type in any other way.

   *Compatibility Note:* Implementations of C before the advent of
ISO C generally used `unsigned int' for representing object sizes and
`int' for pointer subtraction results.  They did not necessarily define
either `size_t' or `ptrdiff_t'.  Unix systems did define `size_t', in
`sys/types.h', but the definition was usually a signed type.


File: libc.info,  Node: Data Type Measurements,  Prev: Important Data Types,  Up: Language Features

A.5 Data Type Measurements
==========================

Most of the time, if you choose the proper C data type for each object
in your program, you need not be concerned with just how it is
represented or how many bits it uses.  When you do need such
information, the C language itself does not provide a way to get it.
The header files `limits.h' and `float.h' contain macros which give you
this information in full detail.

* Menu:

* Width of Type::           How many bits does an integer type hold?
* Range of Type::           What are the largest and smallest values
			     that an integer type can hold?
* Floating Type Macros::    Parameters that measure the floating point types.
* Structure Measurement::   Getting measurements on structure types.


File: libc.info,  Node: Width of Type,  Next: Range of Type,  Up: Data Type Measurements

A.5.1 Computing the Width of an Integer Data Type
-------------------------------------------------

The most common reason that a program needs to know how many bits are in
an integer type is for using an array of `long int' as a bit vector.
You can access the bit at index N with

     vector[N / LONGBITS] & (1 << (N % LONGBITS))

provided you define `LONGBITS' as the number of bits in a `long int'.

   There is no operator in the C language that can give you the number
of bits in an integer data type.  But you can compute it from the macro
`CHAR_BIT', defined in the header file `limits.h'.

`CHAR_BIT'
     This is the number of bits in a `char'--eight, on most systems.
     The value has type `int'.

     You can compute the number of bits in any data type TYPE like this:

          sizeof (TYPE) * CHAR_BIT


File: libc.info,  Node: Range of Type,  Next: Floating Type Macros,  Prev: Width of Type,  Up: Data Type Measurements

A.5.2 Range of an Integer Type
------------------------------

Suppose you need to store an integer value which can range from zero to
one million.  Which is the smallest type you can use?  There is no
general rule; it depends on the C compiler and target machine.  You can
use the `MIN' and `MAX' macros in `limits.h' to determine which type
will work.

   Each signed integer type has a pair of macros which give the smallest
and largest values that it can hold.  Each unsigned integer type has one
such macro, for the maximum value; the minimum value is, of course,
zero.

   The values of these macros are all integer constant expressions.  The
`MAX' and `MIN' macros for `char' and `short int' types have values of
type `int'.  The `MAX' and `MIN' macros for the other types have values
of the same type described by the macro--thus, `ULONG_MAX' has type
`unsigned long int'.

`SCHAR_MIN'
     This is the minimum value that can be represented by a
     `signed char'.

`SCHAR_MAX'
`UCHAR_MAX'
     These are the maximum values that can be represented by a
     `signed char' and `unsigned char', respectively.

`CHAR_MIN'
     This is the minimum value that can be represented by a `char'.
     It's equal to `SCHAR_MIN' if `char' is signed, or zero otherwise.

`CHAR_MAX'
     This is the maximum value that can be represented by a `char'.
     It's equal to `SCHAR_MAX' if `char' is signed, or `UCHAR_MAX'
     otherwise.

`SHRT_MIN'
     This is the minimum value that can be represented by a
     `signed short int'.  On most machines that the GNU C library runs
     on, `short' integers are 16-bit quantities.

`SHRT_MAX'
`USHRT_MAX'
     These are the maximum values that can be represented by a
     `signed short int' and `unsigned short int', respectively.

`INT_MIN'
     This is the minimum value that can be represented by a
     `signed int'.  On most machines that the GNU C system runs on, an
     `int' is a 32-bit quantity.

`INT_MAX'
`UINT_MAX'
     These are the maximum values that can be represented by,
     respectively, the type `signed int' and the type `unsigned int'.

`LONG_MIN'
     This is the minimum value that can be represented by a
     `signed long int'.  On most machines that the GNU C system runs
     on, `long' integers are 32-bit quantities, the same size as `int'.

`LONG_MAX'
`ULONG_MAX'
     These are the maximum values that can be represented by a
     `signed long int' and `unsigned long int', respectively.

`LONG_LONG_MIN'
     This is the minimum value that can be represented by a
     `signed long long int'.  On most machines that the GNU C system
     runs on, `long long' integers are 64-bit quantities.

`LONG_LONG_MAX'
`ULONG_LONG_MAX'
     These are the maximum values that can be represented by a `signed
     long long int' and `unsigned long long int', respectively.

`WCHAR_MAX'
     This is the maximum value that can be represented by a `wchar_t'.
     *Note Extended Char Intro::.

   The header file `limits.h' also defines some additional constants
that parameterize various operating system and file system limits.
These constants are described in *Note System Configuration::.


File: libc.info,  Node: Floating Type Macros,  Next: Structure Measurement,  Prev: Range of Type,  Up: Data Type Measurements

A.5.3 Floating Type Macros
--------------------------

The specific representation of floating point numbers varies from
machine to machine.  Because floating point numbers are represented
internally as approximate quantities, algorithms for manipulating
floating point data often need to take account of the precise details of
the machine's floating point representation.

   Some of the functions in the C library itself need this information;
for example, the algorithms for printing and reading floating point
numbers (*note I/O on Streams::) and for calculating trigonometric and
irrational functions (*note Mathematics::) use it to avoid round-off
error and loss of accuracy.  User programs that implement numerical
analysis techniques also often need this information in order to
minimize or compute error bounds.

   The header file `float.h' describes the format used by your machine.

* Menu:

* Floating Point Concepts::     Definitions of terminology.
* Floating Point Parameters::   Details of specific macros.
* IEEE Floating Point::         The measurements for one common
                                 representation.


File: libc.info,  Node: Floating Point Concepts,  Next: Floating Point Parameters,  Up: Floating Type Macros

A.5.3.1 Floating Point Representation Concepts
..............................................

This section introduces the terminology for describing floating point
representations.

   You are probably already familiar with most of these concepts in
terms of scientific or exponential notation for floating point numbers.
For example, the number `123456.0' could be expressed in exponential
notation as `1.23456e+05', a shorthand notation indicating that the
mantissa `1.23456' is multiplied by the base `10' raised to power `5'.

   More formally, the internal representation of a floating point number
can be characterized in terms of the following parameters:

   * The "sign" is either `-1' or `1'.

   * The "base" or "radix" for exponentiation, an integer greater than
     `1'.  This is a constant for a particular representation.

   * The "exponent" to which the base is raised.  The upper and lower
     bounds of the exponent value are constants for a particular
     representation.

     Sometimes, in the actual bits representing the floating point
     number, the exponent is "biased" by adding a constant to it, to
     make it always be represented as an unsigned quantity.  This is
     only important if you have some reason to pick apart the bit
     fields making up the floating point number by hand, which is
     something for which the GNU library provides no support.  So this
     is ignored in the discussion that follows.

   * The "mantissa" or "significand" is an unsigned integer which is a
     part of each floating point number.

   * The "precision" of the mantissa.  If the base of the representation
     is B, then the precision is the number of base-B digits in the
     mantissa.  This is a constant for a particular representation.

     Many floating point representations have an implicit "hidden bit"
     in the mantissa.  This is a bit which is present virtually in the
     mantissa, but not stored in memory because its value is always 1
     in a normalized number.  The precision figure (see above) includes
     any hidden bits.

     Again, the GNU library provides no facilities for dealing with such
     low-level aspects of the representation.

   The mantissa of a floating point number represents an implicit
fraction whose denominator is the base raised to the power of the
precision.  Since the largest representable mantissa is one less than
this denominator, the value of the fraction is always strictly less
than `1'.  The mathematical value of a floating point number is then
the product of this fraction, the sign, and the base raised to the
exponent.

   We say that the floating point number is "normalized" if the
fraction is at least `1/B', where B is the base.  In other words, the
mantissa would be too large to fit if it were multiplied by the base.
Non-normalized numbers are sometimes called "denormal"; they contain
less precision than the representation normally can hold.

   If the number is not normalized, then you can subtract `1' from the
exponent while multiplying the mantissa by the base, and get another
floating point number with the same value.  "Normalization" consists of
doing this repeatedly until the number is normalized.  Two distinct
normalized floating point numbers cannot be equal in value.

   (There is an exception to this rule: if the mantissa is zero, it is
considered normalized.  Another exception happens on certain machines
where the exponent is as small as the representation can hold.  Then it
is impossible to subtract `1' from the exponent, so a number may be
normalized even if its fraction is less than `1/B'.)


File: libc.info,  Node: Floating Point Parameters,  Next: IEEE Floating Point,  Prev: Floating Point Concepts,  Up: Floating Type Macros

A.5.3.2 Floating Point Parameters
.................................

These macro definitions can be accessed by including the header file
`float.h' in your program.

   Macro names starting with `FLT_' refer to the `float' type, while
names beginning with `DBL_' refer to the `double' type and names
beginning with `LDBL_' refer to the `long double' type.  (If GCC does
not support `long double' as a distinct data type on a target machine
then the values for the `LDBL_' constants are equal to the
corresponding constants for the `double' type.)

   Of these macros, only `FLT_RADIX' is guaranteed to be a constant
expression.  The other macros listed here cannot be reliably used in
places that require constant expressions, such as `#if' preprocessing
directives or in the dimensions of static arrays.

   Although the ISO C standard specifies minimum and maximum values for
most of these parameters, the GNU C implementation uses whatever values
describe the floating point representation of the target machine.  So in
principle GNU C actually satisfies the ISO C requirements only if the
target machine is suitable.  In practice, all the machines currently
supported are suitable.

`FLT_ROUNDS'
     This value characterizes the rounding mode for floating point
     addition.  The following values indicate standard rounding modes:

    `-1'
          The mode is indeterminable.

    `0'
          Rounding is towards zero.

    `1'
          Rounding is to the nearest number.

    `2'
          Rounding is towards positive infinity.

    `3'
          Rounding is towards negative infinity.

     Any other value represents a machine-dependent nonstandard rounding
     mode.

     On most machines, the value is `1', in accordance with the IEEE
     standard for floating point.

     Here is a table showing how certain values round for each possible
     value of `FLT_ROUNDS', if the other aspects of the representation
     match the IEEE single-precision standard.

                          0      1             2             3
           1.00000003    1.0    1.0           1.00000012    1.0
           1.00000007    1.0    1.00000012    1.00000012    1.0
          -1.00000003   -1.0   -1.0          -1.0          -1.00000012
          -1.00000007   -1.0   -1.00000012   -1.0          -1.00000012

`FLT_RADIX'
     This is the value of the base, or radix, of the exponent
     representation.  This is guaranteed to be a constant expression,
     unlike the other macros described in this section.  The value is 2
     on all machines we know of except the IBM 360 and derivatives.

`FLT_MANT_DIG'
     This is the number of base-`FLT_RADIX' digits in the floating point
     mantissa for the `float' data type.  The following expression
     yields `1.0' (even though mathematically it should not) due to the
     limited number of mantissa digits:

          float radix = FLT_RADIX;

          1.0f + 1.0f / radix / radix / ... / radix

     where `radix' appears `FLT_MANT_DIG' times.

`DBL_MANT_DIG'
`LDBL_MANT_DIG'
     This is the number of base-`FLT_RADIX' digits in the floating point
     mantissa for the data types `double' and `long double',
     respectively.

`FLT_DIG'
     This is the number of decimal digits of precision for the `float'
     data type.  Technically, if P and B are the precision and base
     (respectively) for the representation, then the decimal precision
     Q is the maximum number of decimal digits such that any floating
     point number with Q base 10 digits can be rounded to a floating
     point number with P base B digits and back again, without change
     to the Q decimal digits.

     The value of this macro is supposed to be at least `6', to satisfy
     ISO C.

`DBL_DIG'
`LDBL_DIG'
     These are similar to `FLT_DIG', but for the data types `double'
     and `long double', respectively.  The values of these macros are
     supposed to be at least `10'.

`FLT_MIN_EXP'
     This is the smallest possible exponent value for type `float'.
     More precisely, is the minimum negative integer such that the value
     `FLT_RADIX' raised to this power minus 1 can be represented as a
     normalized floating point number of type `float'.

`DBL_MIN_EXP'
`LDBL_MIN_EXP'
     These are similar to `FLT_MIN_EXP', but for the data types
     `double' and `long double', respectively.

`FLT_MIN_10_EXP'
     This is the minimum negative integer such that `10' raised to this
     power minus 1 can be represented as a normalized floating point
     number of type `float'.  This is supposed to be `-37' or even less.

`DBL_MIN_10_EXP'
`LDBL_MIN_10_EXP'
     These are similar to `FLT_MIN_10_EXP', but for the data types
     `double' and `long double', respectively.

`FLT_MAX_EXP'
     This is the largest possible exponent value for type `float'.  More
     precisely, this is the maximum positive integer such that value
     `FLT_RADIX' raised to this power minus 1 can be represented as a
     floating point number of type `float'.

`DBL_MAX_EXP'
`LDBL_MAX_EXP'
     These are similar to `FLT_MAX_EXP', but for the data types
     `double' and `long double', respectively.

`FLT_MAX_10_EXP'
     This is the maximum positive integer such that `10' raised to this
     power minus 1 can be represented as a normalized floating point
     number of type `float'.  This is supposed to be at least `37'.

`DBL_MAX_10_EXP'
`LDBL_MAX_10_EXP'
     These are similar to `FLT_MAX_10_EXP', but for the data types
     `double' and `long double', respectively.

`FLT_MAX'
     The value of this macro is the maximum number representable in type
     `float'.  It is supposed to be at least `1E+37'.  The value has
     type `float'.

     The smallest representable number is `- FLT_MAX'.

`DBL_MAX'
`LDBL_MAX'
     These are similar to `FLT_MAX', but for the data types `double'
     and `long double', respectively.  The type of the macro's value is
     the same as the type it describes.

`FLT_MIN'
     The value of this macro is the minimum normalized positive floating
     point number that is representable in type `float'.  It is supposed
     to be no more than `1E-37'.

`DBL_MIN'
`LDBL_MIN'
     These are similar to `FLT_MIN', but for the data types `double'
     and `long double', respectively.  The type of the macro's value is
     the same as the type it describes.

`FLT_EPSILON'
     This is the minimum positive floating point number of type `float'
     such that `1.0 + FLT_EPSILON != 1.0' is true.  It's supposed to be
     no greater than `1E-5'.

`DBL_EPSILON'
`LDBL_EPSILON'
     These are similar to `FLT_EPSILON', but for the data types
     `double' and `long double', respectively.  The type of the macro's
     value is the same as the type it describes.  The values are not
     supposed to be greater than `1E-9'.


File: libc.info,  Node: IEEE Floating Point,  Prev: Floating Point Parameters,  Up: Floating Type Macros

A.5.3.3 IEEE Floating Point
...........................

Here is an example showing how the floating type measurements come out
for the most common floating point representation, specified by the
`IEEE Standard for Binary Floating Point Arithmetic (ANSI/IEEE Std
754-1985)'.  Nearly all computers designed since the 1980s use this
format.

   The IEEE single-precision float representation uses a base of 2.
There is a sign bit, a mantissa with 23 bits plus one hidden bit (so
the total precision is 24 base-2 digits), and an 8-bit exponent that
can represent values in the range -125 to 128, inclusive.

   So, for an implementation that uses this representation for the
`float' data type, appropriate values for the corresponding parameters
are:

     FLT_RADIX                             2
     FLT_MANT_DIG                         24
     FLT_DIG                               6
     FLT_MIN_EXP                        -125
     FLT_MIN_10_EXP                      -37
     FLT_MAX_EXP                         128
     FLT_MAX_10_EXP                      +38
     FLT_MIN                 1.17549435E-38F
     FLT_MAX                 3.40282347E+38F
     FLT_EPSILON             1.19209290E-07F

   Here are the values for the `double' data type:

     DBL_MANT_DIG                         53
     DBL_DIG                              15
     DBL_MIN_EXP                       -1021
     DBL_MIN_10_EXP                     -307
     DBL_MAX_EXP                        1024
     DBL_MAX_10_EXP                      308
     DBL_MAX         1.7976931348623157E+308
     DBL_MIN         2.2250738585072014E-308
     DBL_EPSILON     2.2204460492503131E-016


File: libc.info,  Node: Structure Measurement,  Prev: Floating Type Macros,  Up: Data Type Measurements

A.5.4 Structure Field Offset Measurement
----------------------------------------

You can use `offsetof' to measure the location within a structure type
of a particular structure member.

 -- Macro: size_t offsetof (TYPE, MEMBER)
     This expands to a integer constant expression that is the offset
     of the structure member named MEMBER in the structure type TYPE.
     For example, `offsetof (struct s, elem)' is the offset, in bytes,
     of the member `elem' in a `struct s'.

     This macro won't work if MEMBER is a bit field; you get an error
     from the C compiler in that case.


File: libc.info,  Node: Library Summary,  Next: Installation,  Prev: Language Features,  Up: Top

Appendix B Summary of Library Facilities
****************************************

This appendix is a complete list of the facilities declared within the
header files supplied with the GNU C library.  Each entry also lists the
standard or other source from which each facility is derived, and tells
you where in the manual you can find more information about how to use
it.

`long int a64l (const char *STRING)'
     `stdlib.h' (XPG):  *Note Encode Binary Data::.

`void abort (void)'
     `stdlib.h' (ISO):  *Note Aborting a Program::.

`int abs (int NUMBER)'
     `stdlib.h' (ISO):  *Note Absolute Value::.

`int accept (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH_PTR)'
     `sys/socket.h' (BSD):  *Note Accepting Connections::.

`int access (const char *FILENAME, int HOW)'
     `unistd.h' (POSIX.1):  *Note Testing File Access::.

`ACCOUNTING'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`double acos (double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`float acosf (float X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`double acosh (double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`float acoshf (float X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double acoshl (long double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double acosl (long double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`int addmntent (FILE *STREAM, const struct mntent *MNT)'
     `mntent.h' (BSD):  *Note mtab::.

`int adjtime (const struct timeval *DELTA, struct timeval *OLDDELTA)'
     `sys/time.h' (BSD):  *Note High-Resolution Calendar::.

`int adjtimex (struct timex *TIMEX)'
     `sys/timex.h' (GNU):  *Note High-Resolution Calendar::.

`AF_FILE'
     `sys/socket.h' (GNU):  *Note Address Formats::.

`AF_INET'
     `sys/socket.h' (BSD):  *Note Address Formats::.

`AF_INET6'
     `sys/socket.h' (IPv6 Basic API):  *Note Address Formats::.

`AF_LOCAL'
     `sys/socket.h' (POSIX):  *Note Address Formats::.

`AF_UNIX'
     `sys/socket.h' (BSD, Unix98):  *Note Address Formats::.

`AF_UNSPEC'
     `sys/socket.h' (BSD):  *Note Address Formats::.

`int aio_cancel (int FILDES, struct aiocb *AIOCBP)'
     `aio.h' (POSIX.1b):  *Note Cancel AIO Operations::.

`int aio_cancel64 (int FILDES, struct aiocb64 *AIOCBP)'
     `aio.h' (Unix98):  *Note Cancel AIO Operations::.

`int aio_error (const struct aiocb *AIOCBP)'
     `aio.h' (POSIX.1b):  *Note Status of AIO Operations::.

`int aio_error64 (const struct aiocb64 *AIOCBP)'
     `aio.h' (Unix98):  *Note Status of AIO Operations::.

`int aio_fsync (int OP, struct aiocb *AIOCBP)'
     `aio.h' (POSIX.1b):  *Note Synchronizing AIO Operations::.

`int aio_fsync64 (int OP, struct aiocb64 *AIOCBP)'
     `aio.h' (Unix98):  *Note Synchronizing AIO Operations::.

`void aio_init (const struct aioinit *INIT)'
     `aio.h' (GNU):  *Note Configuration of AIO::.

`int aio_read (struct aiocb *AIOCBP)'
     `aio.h' (POSIX.1b):  *Note Asynchronous Reads/Writes::.

`int aio_read64 (struct aiocb *AIOCBP)'
     `aio.h' (Unix98):  *Note Asynchronous Reads/Writes::.

`ssize_t aio_return (const struct aiocb *AIOCBP)'
     `aio.h' (POSIX.1b):  *Note Status of AIO Operations::.

`int aio_return64 (const struct aiocb64 *AIOCBP)'
     `aio.h' (Unix98):  *Note Status of AIO Operations::.

`int aio_suspend (const struct aiocb *const LIST[], int NENT, const struct timespec *TIMEOUT)'
     `aio.h' (POSIX.1b):  *Note Synchronizing AIO Operations::.

`int aio_suspend64 (const struct aiocb64 *const LIST[], int NENT, const struct timespec *TIMEOUT)'
     `aio.h' (Unix98):  *Note Synchronizing AIO Operations::.

`int aio_write (struct aiocb *AIOCBP)'
     `aio.h' (POSIX.1b):  *Note Asynchronous Reads/Writes::.

`int aio_write64 (struct aiocb *AIOCBP)'
     `aio.h' (Unix98):  *Note Asynchronous Reads/Writes::.

`unsigned int alarm (unsigned int SECONDS)'
     `unistd.h' (POSIX.1):  *Note Setting an Alarm::.

`void * alloca (size_t SIZE);'
     `stdlib.h' (GNU, BSD):  *Note Variable Size Automatic::.

`int alphasort (const void *A, const void *B)'
     `dirent.h' (BSD/SVID):  *Note Scanning Directory Content::.

`int alphasort64 (const void *A, const void *B)'
     `dirent.h' (GNU):  *Note Scanning Directory Content::.

`tcflag_t ALTWERASE'
     `termios.h' (BSD):  *Note Local Modes::.

`int ARG_MAX'
     `limits.h' (POSIX.1):  *Note General Limits::.

`error_t argp_err_exit_status'
     `argp.h' (GNU):  *Note Argp Global Variables::.

`void argp_error (const struct argp_state *STATE, const char *FMT, ...)'
     `argp.h' (GNU):  *Note Argp Helper Functions::.

`int ARGP_ERR_UNKNOWN'
     `argp.h' (GNU):  *Note Argp Parser Functions::.

`void argp_failure (const struct argp_state *STATE, int STATUS, int ERRNUM, const char *FMT, ...)'
     `argp.h' (GNU):  *Note Argp Helper Functions::.

`void argp_help (const struct argp *ARGP, FILE *STREAM, unsigned FLAGS, char *NAME)'
     `argp.h' (GNU):  *Note Argp Help::.

`ARGP_IN_ORDER'
     `argp.h' (GNU):  *Note Argp Flags::.

`ARGP_KEY_ARG'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_KEY_ARGS'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_KEY_END'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_KEY_ERROR'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_KEY_FINI'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_KEY_HELP_ARGS_DOC'
     `argp.h' (GNU):  *Note Argp Help Filter Keys::.

`ARGP_KEY_HELP_DUP_ARGS_NOTE'
     `argp.h' (GNU):  *Note Argp Help Filter Keys::.

`ARGP_KEY_HELP_EXTRA'
     `argp.h' (GNU):  *Note Argp Help Filter Keys::.

`ARGP_KEY_HELP_HEADER'
     `argp.h' (GNU):  *Note Argp Help Filter Keys::.

`ARGP_KEY_HELP_POST_DOC'
     `argp.h' (GNU):  *Note Argp Help Filter Keys::.

`ARGP_KEY_HELP_PRE_DOC'
     `argp.h' (GNU):  *Note Argp Help Filter Keys::.

`ARGP_KEY_INIT'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_KEY_NO_ARGS'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_KEY_SUCCESS'
     `argp.h' (GNU):  *Note Argp Special Keys::.

`ARGP_LONG_ONLY'
     `argp.h' (GNU):  *Note Argp Flags::.

`ARGP_NO_ARGS'
     `argp.h' (GNU):  *Note Argp Flags::.

`ARGP_NO_ERRS'
     `argp.h' (GNU):  *Note Argp Flags::.

`ARGP_NO_EXIT'
     `argp.h' (GNU):  *Note Argp Flags::.

`ARGP_NO_HELP'
     `argp.h' (GNU):  *Note Argp Flags::.

`error_t argp_parse (const struct argp *ARGP, int ARGC, char **ARGV, unsigned FLAGS, int *ARG_INDEX, void *INPUT)'
     `argp.h' (GNU):  *Note Suboptions: Argp.

`ARGP_PARSE_ARGV0'
     `argp.h' (GNU):  *Note Argp Flags::.

`const char * argp_program_bug_address'
     `argp.h' (GNU):  *Note Argp Global Variables::.

`const char * argp_program_version'
     `argp.h' (GNU):  *Note Argp Global Variables::.

`argp_program_version_hook'
     `argp.h' (GNU):  *Note Argp Global Variables::.

`ARGP_SILENT'
     `argp.h' (GNU):  *Note Argp Flags::.

`void argp_state_help (const struct argp_state *STATE, FILE *STREAM, unsigned FLAGS)'
     `argp.h' (GNU):  *Note Argp Helper Functions::.

`void argp_usage (const struct argp_state *STATE)'
     `argp.h' (GNU):  *Note Argp Helper Functions::.

`error_t argz_add (char **ARGZ, size_t *ARGZ_LEN, const char *STR)'
     `argz.h' (GNU):  *Note Argz Functions::.

`error_t argz_add_sep (char **ARGZ, size_t *ARGZ_LEN, const char *STR, int DELIM)'
     `argz.h' (GNU):  *Note Argz Functions::.

`error_t argz_append (char **ARGZ, size_t *ARGZ_LEN, const char *BUF, size_t BUF_LEN)'
     `argz.h' (GNU):  *Note Argz Functions::.

`size_t argz_count (const char *ARGZ, size_t ARG_LEN)'
     `argz.h' (GNU):  *Note Argz Functions::.

`error_t argz_create (char *const ARGV[], char **ARGZ, size_t *ARGZ_LEN)'
     `argz.h' (GNU):  *Note Argz Functions::.

`error_t argz_create_sep (const char *STRING, int SEP, char **ARGZ, size_t *ARGZ_LEN)'
     `argz.h' (GNU):  *Note Argz Functions::.

`void argz_delete (char **ARGZ, size_t *ARGZ_LEN, char *ENTRY)'
     `argz.h' (GNU):  *Note Argz Functions::.

`void argz_extract (char *ARGZ, size_t ARGZ_LEN, char **ARGV)'
     `argz.h' (GNU):  *Note Argz Functions::.

`error_t argz_insert (char **ARGZ, size_t *ARGZ_LEN, char *BEFORE, const char *ENTRY)'
     `argz.h' (GNU):  *Note Argz Functions::.

`char * argz_next (char *ARGZ, size_t ARGZ_LEN, const char *ENTRY)'
     `argz.h' (GNU):  *Note Argz Functions::.

`error_t argz_replace (char **ARGZ, size_t *ARGZ_LEN, const char *STR, const char *WITH, unsigned *REPLACE_COUNT)'
     `argz.h' (GNU):  *Note Argz Functions::.

`void argz_stringify (char *ARGZ, size_t LEN, int SEP)'
     `argz.h' (GNU):  *Note Argz Functions::.

`char * asctime (const struct tm *BROKENTIME)'
     `time.h' (ISO):  *Note Formatting Calendar Time::.

`char * asctime_r (const struct tm *BROKENTIME, char *BUFFER)'
     `time.h' (POSIX.1c):  *Note Formatting Calendar Time::.

`double asin (double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`float asinf (float X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`double asinh (double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`float asinhf (float X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double asinhl (long double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double asinl (long double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`int asprintf (char **PTR, const char *TEMPLATE, ...)'
     `stdio.h' (GNU):  *Note Dynamic Output::.

`void assert (int EXPRESSION)'
     `assert.h' (ISO):  *Note Consistency Checking::.

`void assert_perror (int ERRNUM)'
     `assert.h' (GNU):  *Note Consistency Checking::.

`double atan (double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`double atan2 (double Y, double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`float atan2f (float Y, float X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`long double atan2l (long double Y, long double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`float atanf (float X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`double atanh (double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`float atanhf (float X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double atanhl (long double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double atanl (long double X)'
     `math.h' (ISO):  *Note Inverse Trig Functions::.

`int atexit (void (*FUNCTION) (void))'
     `stdlib.h' (ISO):  *Note Cleanups on Exit::.

`double atof (const char *STRING)'
     `stdlib.h' (ISO):  *Note Parsing of Floats::.

`int atoi (const char *STRING)'
     `stdlib.h' (ISO):  *Note Parsing of Integers::.

`long int atol (const char *STRING)'
     `stdlib.h' (ISO):  *Note Parsing of Integers::.

`long long int atoll (const char *STRING)'
     `stdlib.h' (ISO):  *Note Parsing of Integers::.

`B0'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B110'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B115200'
     `termios.h' (GNU):  *Note Line Speed::.

`B1200'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B134'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B150'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B1800'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B19200'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B200'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B230400'
     `termios.h' (GNU):  *Note Line Speed::.

`B2400'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B300'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B38400'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B460800'
     `termios.h' (GNU):  *Note Line Speed::.

`B4800'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B50'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B57600'
     `termios.h' (GNU):  *Note Line Speed::.

`B600'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B75'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`B9600'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`int backtrace (void **BUFFER, int SIZE)'
     `execinfo.h' (GNU):  *Note Backtraces::.

`char ** backtrace_symbols (void *const *BUFFER, int SIZE)'
     `execinfo.h' (GNU):  *Note Backtraces::.

`void backtrace_symbols_fd (void *const *BUFFER, int SIZE, int FD)'
     `execinfo.h' (GNU):  *Note Backtraces::.

`char * basename (char *PATH)'
     `libgen.h' (XPG):  *Note Finding Tokens in a String::.

`char * basename (const char *FILENAME)'
     `string.h' (GNU):  *Note Finding Tokens in a String::.

`int BC_BASE_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`int BC_DIM_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`int bcmp (const void *A1, const void *A2, size_t SIZE)'
     `string.h' (BSD):  *Note String/Array Comparison::.

`void bcopy (const void *FROM, void *TO, size_t SIZE)'
     `string.h' (BSD):  *Note Copying and Concatenation::.

`int BC_SCALE_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`int BC_STRING_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`int bind (int SOCKET, struct sockaddr *ADDR, socklen_t LENGTH)'
     `sys/socket.h' (BSD):  *Note Setting Address::.

`char * bindtextdomain (const char *DOMAINNAME, const char *DIRNAME)'
     `libintl.h' (GNU):  *Note Locating gettext catalog::.

`char * bind_textdomain_codeset (const char *DOMAINNAME, const char *CODESET)'
     `libintl.h' (GNU):  *Note Charset conversion in gettext::.

`blkcnt64_t'
     `sys/types.h' (Unix98):  *Note Attribute Meanings::.

`blkcnt_t'
     `sys/types.h' (Unix98):  *Note Attribute Meanings::.

`BOOT_TIME'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`BOOT_TIME'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int brk (void *ADDR)'
     `unistd.h' (BSD):  *Note Resizing the Data Segment::.

`tcflag_t BRKINT'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`_BSD_SOURCE'
     (GNU):  *Note Feature Test Macros::.

`void * bsearch (const void *KEY, const void *ARRAY, size_t COUNT, size_t SIZE, comparison_fn_t COMPARE)'
     `stdlib.h' (ISO):  *Note Array Search Function::.

`wint_t btowc (int C)'
     `wchar.h' (ISO):  *Note Converting a Character::.

`int BUFSIZ'
     `stdio.h' (ISO):  *Note Controlling Buffering::.

`void bzero (void *BLOCK, size_t SIZE)'
     `string.h' (BSD):  *Note Copying and Concatenation::.

`double cabs (complex double Z)'
     `complex.h' (ISO):  *Note Absolute Value::.

`float cabsf (complex float Z)'
     `complex.h' (ISO):  *Note Absolute Value::.

`long double cabsl (complex long double Z)'
     `complex.h' (ISO):  *Note Absolute Value::.

`complex double cacos (complex double Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`complex float cacosf (complex float Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`complex double cacosh (complex double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex float cacoshf (complex float Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double cacoshl (complex long double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double cacosl (complex long double Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`void * calloc (size_t COUNT, size_t ELTSIZE)'
     `malloc.h', `stdlib.h' (ISO):  *Note Allocating Cleared Space::.

`char * canonicalize_file_name (const char *NAME)'
     `stdlib.h' (GNU):  *Note Symbolic Links::.

`double carg (complex double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`float cargf (complex float Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`long double cargl (complex long double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`complex double casin (complex double Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`complex float casinf (complex float Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`complex double casinh (complex double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex float casinhf (complex float Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double casinhl (complex long double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double casinl (complex long double Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`complex double catan (complex double Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`complex float catanf (complex float Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`complex double catanh (complex double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex float catanhf (complex float Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double catanhl (complex long double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double catanl (complex long double Z)'
     `complex.h' (ISO):  *Note Inverse Trig Functions::.

`nl_catd catopen (const char *CAT_NAME, int FLAG)'
     `nl_types.h' (X/Open):  *Note The catgets Functions::.

`int cbc_crypt (char *KEY, char *BLOCKS, unsigned LEN, unsigned MODE, char *IVEC)'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`double cbrt (double X)'
     `math.h' (BSD):  *Note Exponents and Logarithms::.

`float cbrtf (float X)'
     `math.h' (BSD):  *Note Exponents and Logarithms::.

`long double cbrtl (long double X)'
     `math.h' (BSD):  *Note Exponents and Logarithms::.

`complex double ccos (complex double Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`complex float ccosf (complex float Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`complex double ccosh (complex double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex float ccoshf (complex float Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double ccoshl (complex long double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double ccosl (complex long double Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`cc_t'
     `termios.h' (POSIX.1):  *Note Mode Data Types::.

`tcflag_t CCTS_OFLOW'
     `termios.h' (BSD):  *Note Control Modes::.

`double ceil (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`float ceilf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long double ceill (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`complex double cexp (complex double Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex float cexpf (complex float Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex long double cexpl (complex long double Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`speed_t cfgetispeed (const struct termios *TERMIOS-P)'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`speed_t cfgetospeed (const struct termios *TERMIOS-P)'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`void cfmakeraw (struct termios *TERMIOS-P)'
     `termios.h' (BSD):  *Note Noncanonical Input::.

`void cfree (void *PTR)'
     `stdlib.h' (Sun):  *Note Freeing after Malloc::.

`int cfsetispeed (struct termios *TERMIOS-P, speed_t SPEED)'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`int cfsetospeed (struct termios *TERMIOS-P, speed_t SPEED)'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`int cfsetspeed (struct termios *TERMIOS-P, speed_t SPEED)'
     `termios.h' (BSD):  *Note Line Speed::.

`CHAR_BIT'
     `limits.h' (ISO):  *Note Width of Type::.

`CHAR_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`CHAR_MIN'
     `limits.h' (ISO):  *Note Range of Type::.

`int chdir (const char *FILENAME)'
     `unistd.h' (POSIX.1):  *Note Working Directory::.

`int CHILD_MAX'
     `limits.h' (POSIX.1):  *Note General Limits::.

`int chmod (const char *FILENAME, mode_t MODE)'
     `sys/stat.h' (POSIX.1):  *Note Setting Permissions::.

`int chown (const char *FILENAME, uid_t OWNER, gid_t GROUP)'
     `unistd.h' (POSIX.1):  *Note File Owner::.

`tcflag_t CIGNORE'
     `termios.h' (BSD):  *Note Control Modes::.

`double cimag (complex double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`float cimagf (complex float Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`long double cimagl (complex long double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`int clearenv (void)'
     `stdlib.h' (GNU):  *Note Environment Access::.

`void clearerr (FILE *STREAM)'
     `stdio.h' (ISO):  *Note Error Recovery::.

`void clearerr_unlocked (FILE *STREAM)'
     `stdio.h' (GNU):  *Note Error Recovery::.

`int CLK_TCK'
     `time.h' (POSIX.1):  *Note CPU Time::.

`tcflag_t CLOCAL'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`clock_t clock (void)'
     `time.h' (ISO):  *Note CPU Time::.

`int CLOCKS_PER_SEC'
     `time.h' (ISO):  *Note CPU Time::.

`clock_t'
     `time.h' (ISO):  *Note CPU Time::.

`complex double clog (complex double Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex double clog10 (complex double Z)'
     `complex.h' (GNU):  *Note Exponents and Logarithms::.

`complex float clog10f (complex float Z)'
     `complex.h' (GNU):  *Note Exponents and Logarithms::.

`complex long double clog10l (complex long double Z)'
     `complex.h' (GNU):  *Note Exponents and Logarithms::.

`complex float clogf (complex float Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex long double clogl (complex long double Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`int close (int FILEDES)'
     `unistd.h' (POSIX.1):  *Note Opening and Closing Files::.

`int closedir (DIR *DIRSTREAM)'
     `dirent.h' (POSIX.1):  *Note Reading/Closing Directory::.

`void closelog (void)'
     `syslog.h' (BSD):  *Note closelog::.

`int COLL_WEIGHTS_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`size_t confstr (int PARAMETER, char *BUF, size_t LEN)'
     `unistd.h' (POSIX.2):  *Note String Parameters::.

`complex double conj (complex double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`complex float conjf (complex float Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`complex long double conjl (complex long double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`int connect (int SOCKET, struct sockaddr *ADDR, socklen_t LENGTH)'
     `sys/socket.h' (BSD):  *Note Connecting::.

`cookie_close_function'
     `stdio.h' (GNU):  *Note Hook Functions::.

`cookie_io_functions_t'
     `stdio.h' (GNU):  *Note Streams and Cookies::.

`cookie_read_function'
     `stdio.h' (GNU):  *Note Hook Functions::.

`cookie_seek_function'
     `stdio.h' (GNU):  *Note Hook Functions::.

`cookie_write_function'
     `stdio.h' (GNU):  *Note Hook Functions::.

`double copysign (double X, double Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`float copysignf (float X, float Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`long double copysignl (long double X, long double Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`double cos (double X)'
     `math.h' (ISO):  *Note Trig Functions::.

`float cosf (float X)'
     `math.h' (ISO):  *Note Trig Functions::.

`double cosh (double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`float coshf (float X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double coshl (long double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double cosl (long double X)'
     `math.h' (ISO):  *Note Trig Functions::.

`complex double cpow (complex double BASE, complex double POWER)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex float cpowf (complex float BASE, complex float POWER)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex long double cpowl (complex long double BASE, complex long double POWER)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex double cproj (complex double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`complex float cprojf (complex float Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`complex long double cprojl (complex long double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`void CPU_CLR (int CPU, cpu_set_t *SET)'
     `sched.h' (GNU):  *Note CPU Affinity::.

`int CPU_ISSET (int CPU, const cpu_set_t *SET)'
     `sched.h' (GNU):  *Note CPU Affinity::.

`void CPU_SET (int CPU, cpu_set_t *SET)'
     `sched.h' (GNU):  *Note CPU Affinity::.

`int CPU_SETSIZE'
     `sched.h' (GNU):  *Note CPU Affinity::.

`cpu_set_t'
     `sched.h' (GNU):  *Note CPU Affinity::.

`void CPU_ZERO (cpu_set_t *SET)'
     `sched.h' (GNU):  *Note CPU Affinity::.

`tcflag_t CREAD'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`double creal (complex double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`float crealf (complex float Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`long double creall (complex long double Z)'
     `complex.h' (ISO):  *Note Operations on Complex::.

`int creat (const char *FILENAME, mode_t MODE)'
     `fcntl.h' (POSIX.1):  *Note Opening and Closing Files::.

`int creat64 (const char *FILENAME, mode_t MODE)'
     `fcntl.h' (Unix98):  *Note Opening and Closing Files::.

`tcflag_t CRTS_IFLOW'
     `termios.h' (BSD):  *Note Control Modes::.

`char * crypt (const char *KEY, const char *SALT)'
     `crypt.h' (BSD, SVID):  *Note crypt::.

`char * crypt_r (const char *KEY, const char *SALT, struct crypt_data * DATA)'
     `crypt.h' (GNU):  *Note crypt::.

`tcflag_t CS5'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`tcflag_t CS6'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`tcflag_t CS7'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`tcflag_t CS8'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`complex double csin (complex double Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`complex float csinf (complex float Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`complex double csinh (complex double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex float csinhf (complex float Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double csinhl (complex long double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double csinl (complex long double Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`tcflag_t CSIZE'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`_CS_LFS64_CFLAGS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_LFS64_LDFLAGS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_LFS64_LIBS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_LFS64_LINTFLAGS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_LFS_CFLAGS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_LFS_LDFLAGS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_LFS_LIBS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_LFS_LINTFLAGS'
     `unistd.h' (Unix98):  *Note String Parameters::.

`_CS_PATH'
     `unistd.h' (POSIX.2):  *Note String Parameters::.

`complex double csqrt (complex double Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex float csqrtf (complex float Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`complex long double csqrtl (complex long double Z)'
     `complex.h' (ISO):  *Note Exponents and Logarithms::.

`tcflag_t CSTOPB'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`complex double ctan (complex double Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`complex float ctanf (complex float Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`complex double ctanh (complex double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex float ctanhf (complex float Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double ctanhl (complex long double Z)'
     `complex.h' (ISO):  *Note Hyperbolic Functions::.

`complex long double ctanl (complex long double Z)'
     `complex.h' (ISO):  *Note Trig Functions::.

`char * ctermid (char *STRING)'
     `stdio.h' (POSIX.1):  *Note Identifying the Terminal::.

`char * ctime (const time_t *TIME)'
     `time.h' (ISO):  *Note Formatting Calendar Time::.

`char * ctime_r (const time_t *TIME, char *BUFFER)'
     `time.h' (POSIX.1c):  *Note Formatting Calendar Time::.

`char * cuserid (char *STRING)'
     `stdio.h' (POSIX.1):  *Note Who Logged In::.

`int daylight'
     `time.h' (SVID):  *Note Time Zone Functions::.

`DBL_DIG'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_EPSILON'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_MANT_DIG'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_MAX'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_MAX_10_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_MAX_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_MIN'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_MIN_10_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`DBL_MIN_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`char * dcgettext (const char *DOMAINNAME, const char *MSGID, int CATEGORY)'
     `libintl.h' (GNU):  *Note Translation with gettext::.

`char * dcngettext (const char *DOMAIN, const char *MSGID1, const char *MSGID2, unsigned long int N, int CATEGORY)'
     `libintl.h' (GNU):  *Note Advanced gettext functions::.

`DEAD_PROCESS'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`DEAD_PROCESS'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`DES_DECRYPT'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`DES_ENCRYPT'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`DESERR_BADPARAM'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`DESERR_HWERROR'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`DESERR_NOHWDEVICE'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`DESERR_NONE'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`int DES_FAILED (int ERR)'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`DES_HW'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`void des_setparity (char *KEY)'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`DES_SW'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`dev_t'
     `sys/types.h' (POSIX.1):  *Note Attribute Meanings::.

`char * dgettext (const char *DOMAINNAME, const char *MSGID)'
     `libintl.h' (GNU):  *Note Translation with gettext::.

`double difftime (time_t TIME1, time_t TIME0)'
     `time.h' (ISO):  *Note Elapsed Time::.

`DIR'
     `dirent.h' (POSIX.1):  *Note Opening a Directory::.

`int dirfd (DIR *DIRSTREAM)'
     `dirent.h' (GNU):  *Note Opening a Directory::.

`char * dirname (char *PATH)'
     `libgen.h' (XPG):  *Note Finding Tokens in a String::.

`div_t div (int NUMERATOR, int DENOMINATOR)'
     `stdlib.h' (ISO):  *Note Integer Division::.

`div_t'
     `stdlib.h' (ISO):  *Note Integer Division::.

`char * dngettext (const char *DOMAIN, const char *MSGID1, const char *MSGID2, unsigned long int N)'
     `libintl.h' (GNU):  *Note Advanced gettext functions::.

`double drand48 (void)'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int drand48_r (struct drand48_data *BUFFER, double *RESULT)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`double drem (double NUMERATOR, double DENOMINATOR)'
     `math.h' (BSD):  *Note Remainder Functions::.

`float dremf (float NUMERATOR, float DENOMINATOR)'
     `math.h' (BSD):  *Note Remainder Functions::.

`long double dreml (long double NUMERATOR, long double DENOMINATOR)'
     `math.h' (BSD):  *Note Remainder Functions::.

`mode_t DTTOIF (int DTYPE)'
     `dirent.h' (BSD):  *Note Directory Entries::.

`int dup (int OLD)'
     `unistd.h' (POSIX.1):  *Note Duplicating Descriptors::.

`int dup2 (int OLD, int NEW)'
     `unistd.h' (POSIX.1):  *Note Duplicating Descriptors::.

`int E2BIG'
     `errno.h' (POSIX.1: Argument list too long):  *Note Error Codes::.

`int EACCES'
     `errno.h' (POSIX.1: Permission denied):  *Note Error Codes::.

`int EADDRINUSE'
     `errno.h' (BSD: Address already in use):  *Note Error Codes::.

`int EADDRNOTAVAIL'
     `errno.h' (BSD: Cannot assign requested address):  *Note Error
     Codes::.

`int EADV'
     `errno.h' (Linux???: Advertise error):  *Note Error Codes::.

`int EAFNOSUPPORT'
     `errno.h' (BSD: Address family not supported by protocol):  *Note
     Error Codes::.

`int EAGAIN'
     `errno.h' (POSIX.1: Resource temporarily unavailable):  *Note
     Error Codes::.

`int EALREADY'
     `errno.h' (BSD: Operation already in progress):  *Note Error
     Codes::.

`int EAUTH'
     `errno.h' (BSD: Authentication error):  *Note Error Codes::.

`int EBACKGROUND'
     `errno.h' (GNU: Inappropriate operation for background process):
     *Note Error Codes::.

`int EBADE'
     `errno.h' (Linux???: Invalid exchange):  *Note Error Codes::.

`int EBADF'
     `errno.h' (POSIX.1: Bad file descriptor):  *Note Error Codes::.

`int EBADFD'
     `errno.h' (Linux???: File descriptor in bad state):  *Note Error
     Codes::.

`int EBADMSG'
     `errno.h' (XOPEN: Bad message):  *Note Error Codes::.

`int EBADR'
     `errno.h' (Linux???: Invalid request descriptor):  *Note Error
     Codes::.

`int EBADRPC'
     `errno.h' (BSD: RPC struct is bad):  *Note Error Codes::.

`int EBADRQC'
     `errno.h' (Linux???: Invalid request code):  *Note Error Codes::.

`int EBADSLT'
     `errno.h' (Linux???: Invalid slot):  *Note Error Codes::.

`int EBFONT'
     `errno.h' (Linux???: Bad font file format):  *Note Error Codes::.

`int EBUSY'
     `errno.h' (POSIX.1: Device or resource busy):  *Note Error Codes::.

`int ECANCELED'
     `errno.h' (POSIX.1: Operation canceled):  *Note Error Codes::.

`int ecb_crypt (char *KEY, char *BLOCKS, unsigned LEN, unsigned MODE)'
     `rpc/des_crypt.h' (SUNRPC):  *Note DES Encryption::.

`int ECHILD'
     `errno.h' (POSIX.1: No child processes):  *Note Error Codes::.

`tcflag_t ECHO'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`tcflag_t ECHOCTL'
     `termios.h' (BSD):  *Note Local Modes::.

`tcflag_t ECHOE'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`tcflag_t ECHOK'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`tcflag_t ECHOKE'
     `termios.h' (BSD):  *Note Local Modes::.

`tcflag_t ECHONL'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`tcflag_t ECHOPRT'
     `termios.h' (BSD):  *Note Local Modes::.

`int ECHRNG'
     `errno.h' (Linux???: Channel number out of range):  *Note Error
     Codes::.

`int ECOMM'
     `errno.h' (Linux???: Communication error on send):  *Note Error
     Codes::.

`int ECONNABORTED'
     `errno.h' (BSD: Software caused connection abort):  *Note Error
     Codes::.

`int ECONNREFUSED'
     `errno.h' (BSD: Connection refused):  *Note Error Codes::.

`int ECONNRESET'
     `errno.h' (BSD: Connection reset by peer):  *Note Error Codes::.

`char * ecvt (double VALUE, int NDIGIT, int *DECPT, int *NEG)'
     `stdlib.h' (SVID, Unix98):  *Note System V Number Conversion::.

`int ecvt_r (double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)'
     `stdlib.h' (GNU):  *Note System V Number Conversion::.

`int ED'
     `errno.h' (GNU: ?):  *Note Error Codes::.

`int EDEADLK'
     `errno.h' (POSIX.1: Resource deadlock avoided):  *Note Error
     Codes::.

`int EDEADLOCK'
     `errno.h' (Linux???: File locking deadlock error):  *Note Error
     Codes::.

`int EDESTADDRREQ'
     `errno.h' (BSD: Destination address required):  *Note Error
     Codes::.

`int EDIED'
     `errno.h' (GNU: Translator died):  *Note Error Codes::.

`int EDOM'
     `errno.h' (ISO: Numerical argument out of domain):  *Note Error
     Codes::.

`int EDOTDOT'
     `errno.h' (Linux???: RFS specific error):  *Note Error Codes::.

`int EDQUOT'
     `errno.h' (BSD: Disk quota exceeded):  *Note Error Codes::.

`int EEXIST'
     `errno.h' (POSIX.1: File exists):  *Note Error Codes::.

`int EFAULT'
     `errno.h' (POSIX.1: Bad address):  *Note Error Codes::.

`int EFBIG'
     `errno.h' (POSIX.1: File too large):  *Note Error Codes::.

`int EFTYPE'
     `errno.h' (BSD: Inappropriate file type or format):  *Note Error
     Codes::.

`int EGRATUITOUS'
     `errno.h' (GNU: Gratuitous error):  *Note Error Codes::.

`int EGREGIOUS'
     `errno.h' (GNU: You really blew it this time):  *Note Error
     Codes::.

`int EHOSTDOWN'
     `errno.h' (BSD: Host is down):  *Note Error Codes::.

`int EHOSTUNREACH'
     `errno.h' (BSD: No route to host):  *Note Error Codes::.

`int EIDRM'
     `errno.h' (XOPEN: Identifier removed):  *Note Error Codes::.

`int EIEIO'
     `errno.h' (GNU: Computer bought the farm):  *Note Error Codes::.

`int EILSEQ'
     `errno.h' (ISO: Invalid or incomplete multibyte or wide
     character):  *Note Error Codes::.

`int EINPROGRESS'
     `errno.h' (BSD: Operation now in progress):  *Note Error Codes::.

`int EINTR'
     `errno.h' (POSIX.1: Interrupted system call):  *Note Error Codes::.

`int EINVAL'
     `errno.h' (POSIX.1: Invalid argument):  *Note Error Codes::.

`int EIO'
     `errno.h' (POSIX.1: Input/output error):  *Note Error Codes::.

`int EISCONN'
     `errno.h' (BSD: Transport endpoint is already connected):  *Note
     Error Codes::.

`int EISDIR'
     `errno.h' (POSIX.1: Is a directory):  *Note Error Codes::.

`int EISNAM'
     `errno.h' (Linux???: Is a named type file):  *Note Error Codes::.

`int EKEYEXPIRED'
     `errno.h' (Linux: Key has expired):  *Note Error Codes::.

`int EKEYREJECTED'
     `errno.h' (Linux: Key was rejected by service):  *Note Error
     Codes::.

`int EKEYREVOKED'
     `errno.h' (Linux: Key has been revoked):  *Note Error Codes::.

`int EL2HLT'
     `errno.h' (Obsolete: Level 2 halted):  *Note Error Codes::.

`int EL2NSYNC'
     `errno.h' (Obsolete: Level 2 not synchronized):  *Note Error
     Codes::.

`int EL3HLT'
     `errno.h' (Obsolete: Level 3 halted):  *Note Error Codes::.

`int EL3RST'
     `errno.h' (Obsolete: Level 3 reset):  *Note Error Codes::.

`int ELIBACC'
     `errno.h' (Linux???: Can not access a needed shared library):
     *Note Error Codes::.

`int ELIBBAD'
     `errno.h' (Linux???: Accessing a corrupted shared library):  *Note
     Error Codes::.

`int ELIBEXEC'
     `errno.h' (Linux???: Cannot exec a shared library directly):
     *Note Error Codes::.

`int ELIBMAX'
     `errno.h' (Linux???: Attempting to link in too many shared
     libraries):  *Note Error Codes::.

`int ELIBSCN'
     `errno.h' (Linux???: .lib section in a.out corrupted):  *Note
     Error Codes::.

`int ELNRNG'
     `errno.h' (Linux???: Link number out of range):  *Note Error
     Codes::.

`int ELOOP'
     `errno.h' (BSD: Too many levels of symbolic links):  *Note Error
     Codes::.

`int EMEDIUMTYPE'
     `errno.h' (Linux???: Wrong medium type):  *Note Error Codes::.

`int EMFILE'
     `errno.h' (POSIX.1: Too many open files):  *Note Error Codes::.

`int EMLINK'
     `errno.h' (POSIX.1: Too many links):  *Note Error Codes::.

`EMPTY'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`EMPTY'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int EMSGSIZE'
     `errno.h' (BSD: Message too long):  *Note Error Codes::.

`int EMULTIHOP'
     `errno.h' (XOPEN: Multihop attempted):  *Note Error Codes::.

`int ENAMETOOLONG'
     `errno.h' (POSIX.1: File name too long):  *Note Error Codes::.

`int ENAVAIL'
     `errno.h' (Linux???: No XENIX semaphores available):  *Note Error
     Codes::.

`void encrypt (char *BLOCK, int EDFLAG)'
     `crypt.h' (BSD, SVID):  *Note DES Encryption::.

`void encrypt_r (char *BLOCK, int EDFLAG, struct crypt_data * DATA)'
     `crypt.h' (GNU):  *Note DES Encryption::.

`void endfsent (void)'
     `fstab.h' (BSD):  *Note fstab::.

`void endgrent (void)'
     `grp.h' (SVID, BSD):  *Note Scanning All Groups::.

`void endhostent (void)'
     `netdb.h' (BSD):  *Note Host Names::.

`int endmntent (FILE *STREAM)'
     `mntent.h' (BSD):  *Note mtab::.

`void endnetent (void)'
     `netdb.h' (BSD):  *Note Networks Database::.

`void endnetgrent (void)'
     `netdb.h' (BSD):  *Note Lookup Netgroup::.

`void endprotoent (void)'
     `netdb.h' (BSD):  *Note Protocols Database::.

`void endpwent (void)'
     `pwd.h' (SVID, BSD):  *Note Scanning All Users::.

`void endservent (void)'
     `netdb.h' (BSD):  *Note Services Database::.

`void endutent (void)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`void endutxent (void)'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int ENEEDAUTH'
     `errno.h' (BSD: Need authenticator):  *Note Error Codes::.

`int ENETDOWN'
     `errno.h' (BSD: Network is down):  *Note Error Codes::.

`int ENETRESET'
     `errno.h' (BSD: Network dropped connection on reset):  *Note Error
     Codes::.

`int ENETUNREACH'
     `errno.h' (BSD: Network is unreachable):  *Note Error Codes::.

`int ENFILE'
     `errno.h' (POSIX.1: Too many open files in system):  *Note Error
     Codes::.

`int ENOANO'
     `errno.h' (Linux???: No anode):  *Note Error Codes::.

`int ENOBUFS'
     `errno.h' (BSD: No buffer space available):  *Note Error Codes::.

`int ENOCSI'
     `errno.h' (Linux???: No CSI structure available):  *Note Error
     Codes::.

`int ENODATA'
     `errno.h' (XOPEN: No data available):  *Note Error Codes::.

`int ENODEV'
     `errno.h' (POSIX.1: No such device):  *Note Error Codes::.

`int ENOENT'
     `errno.h' (POSIX.1: No such file or directory):  *Note Error
     Codes::.

`int ENOEXEC'
     `errno.h' (POSIX.1: Exec format error):  *Note Error Codes::.

`int ENOKEY'
     `errno.h' (Linux: Required key not available):  *Note Error
     Codes::.

`int ENOLCK'
     `errno.h' (POSIX.1: No locks available):  *Note Error Codes::.

`int ENOLINK'
     `errno.h' (XOPEN: Link has been severed):  *Note Error Codes::.

`int ENOMEDIUM'
     `errno.h' (Linux???: No medium found):  *Note Error Codes::.

`int ENOMEM'
     `errno.h' (POSIX.1: Cannot allocate memory):  *Note Error Codes::.

`int ENOMSG'
     `errno.h' (XOPEN: No message of desired type):  *Note Error
     Codes::.

`int ENONET'
     `errno.h' (Linux???: Machine is not on the network):  *Note Error
     Codes::.

`int ENOPKG'
     `errno.h' (Linux???: Package not installed):  *Note Error Codes::.

`int ENOPROTOOPT'
     `errno.h' (BSD: Protocol not available):  *Note Error Codes::.

`int ENOSPC'
     `errno.h' (POSIX.1: No space left on device):  *Note Error Codes::.

`int ENOSR'
     `errno.h' (XOPEN: Out of streams resources):  *Note Error Codes::.

`int ENOSTR'
     `errno.h' (XOPEN: Device not a stream):  *Note Error Codes::.

`int ENOSYS'
     `errno.h' (POSIX.1: Function not implemented):  *Note Error
     Codes::.

`int ENOTBLK'
     `errno.h' (BSD: Block device required):  *Note Error Codes::.

`int ENOTCONN'
     `errno.h' (BSD: Transport endpoint is not connected):  *Note Error
     Codes::.

`int ENOTDIR'
     `errno.h' (POSIX.1: Not a directory):  *Note Error Codes::.

`int ENOTEMPTY'
     `errno.h' (POSIX.1: Directory not empty):  *Note Error Codes::.

`int ENOTNAM'
     `errno.h' (Linux???: Not a XENIX named type file):  *Note Error
     Codes::.

`int ENOTRECOVERABLE'
     `errno.h' (Linux: State not recoverable):  *Note Error Codes::.

`int ENOTSOCK'
     `errno.h' (BSD: Socket operation on non-socket):  *Note Error
     Codes::.

`int ENOTSUP'
     `errno.h' (POSIX.1: Not supported):  *Note Error Codes::.

`int ENOTTY'
     `errno.h' (POSIX.1: Inappropriate ioctl for device):  *Note Error
     Codes::.

`int ENOTUNIQ'
     `errno.h' (Linux???: Name not unique on network):  *Note Error
     Codes::.

`char ** environ'
     `unistd.h' (POSIX.1):  *Note Environment Access::.

`error_t envz_add (char **ENVZ, size_t *ENVZ_LEN, const char *NAME, const char *VALUE)'
     `envz.h' (GNU):  *Note Envz Functions::.

`char * envz_entry (const char *ENVZ, size_t ENVZ_LEN, const char *NAME)'
     `envz.h' (GNU):  *Note Envz Functions::.

`char * envz_get (const char *ENVZ, size_t ENVZ_LEN, const char *NAME)'
     `envz.h' (GNU):  *Note Envz Functions::.

`error_t envz_merge (char **ENVZ, size_t *ENVZ_LEN, const char *ENVZ2, size_t ENVZ2_LEN, int OVERRIDE)'
     `envz.h' (GNU):  *Note Envz Functions::.

`void envz_strip (char **ENVZ, size_t *ENVZ_LEN)'
     `envz.h' (GNU):  *Note Envz Functions::.

`int ENXIO'
     `errno.h' (POSIX.1: No such device or address):  *Note Error
     Codes::.

`int EOF'
     `stdio.h' (ISO):  *Note EOF and Errors::.

`int EOPNOTSUPP'
     `errno.h' (BSD: Operation not supported):  *Note Error Codes::.

`int EOVERFLOW'
     `errno.h' (XOPEN: Value too large for defined data type):  *Note
     Error Codes::.

`int EOWNERDEAD'
     `errno.h' (Linux: Owner died):  *Note Error Codes::.

`int EPERM'
     `errno.h' (POSIX.1: Operation not permitted):  *Note Error Codes::.

`int EPFNOSUPPORT'
     `errno.h' (BSD: Protocol family not supported):  *Note Error
     Codes::.

`int EPIPE'
     `errno.h' (POSIX.1: Broken pipe):  *Note Error Codes::.

`int EPROCLIM'
     `errno.h' (BSD: Too many processes):  *Note Error Codes::.

`int EPROCUNAVAIL'
     `errno.h' (BSD: RPC bad procedure for program):  *Note Error
     Codes::.

`int EPROGMISMATCH'
     `errno.h' (BSD: RPC program version wrong):  *Note Error Codes::.

`int EPROGUNAVAIL'
     `errno.h' (BSD: RPC program not available):  *Note Error Codes::.

`int EPROTO'
     `errno.h' (XOPEN: Protocol error):  *Note Error Codes::.

`int EPROTONOSUPPORT'
     `errno.h' (BSD: Protocol not supported):  *Note Error Codes::.

`int EPROTOTYPE'
     `errno.h' (BSD: Protocol wrong type for socket):  *Note Error
     Codes::.

`int EQUIV_CLASS_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`double erand48 (unsigned short int XSUBI[3])'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int erand48_r (unsigned short int XSUBI[3], struct drand48_data *BUFFER, double *RESULT)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`int ERANGE'
     `errno.h' (ISO: Numerical result out of range):  *Note Error
     Codes::.

`int EREMCHG'
     `errno.h' (Linux???: Remote address changed):  *Note Error Codes::.

`int EREMOTE'
     `errno.h' (BSD: Object is remote):  *Note Error Codes::.

`int EREMOTEIO'
     `errno.h' (Linux???: Remote I/O error):  *Note Error Codes::.

`int ERESTART'
     `errno.h' (Linux???: Interrupted system call should be restarted):
     *Note Error Codes::.

`double erf (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`double erfc (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float erfcf (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double erfcl (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float erff (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`int ERFKILL'
     `errno.h' (Linux: Operation not possible due to RF-kill):  *Note
     Error Codes::.

`long double erfl (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`int EROFS'
     `errno.h' (POSIX.1: Read-only file system):  *Note Error Codes::.

`int ERPCMISMATCH'
     `errno.h' (BSD: RPC version wrong):  *Note Error Codes::.

`void err (int STATUS, const char *FORMAT, ...)'
     `err.h' (BSD):  *Note Error Messages::.

`volatile int errno'
     `errno.h' (ISO):  *Note Checking for Errors::.

`void error (int STATUS, int ERRNUM, const char *FORMAT, ...)'
     `error.h' (GNU):  *Note Error Messages::.

`void error_at_line (int STATUS, int ERRNUM, const char *FNAME, unsigned int LINENO, const char *FORMAT, ...)'
     `error.h' (GNU):  *Note Error Messages::.

`unsigned int error_message_count'
     `error.h' (GNU):  *Note Error Messages::.

`int error_one_per_line'
     `error.h' (GNU):  *Note Error Messages::.

`void errx (int STATUS, const char *FORMAT, ...)'
     `err.h' (BSD):  *Note Error Messages::.

`int ESHUTDOWN'
     `errno.h' (BSD: Cannot send after transport endpoint shutdown):
     *Note Error Codes::.

`int ESOCKTNOSUPPORT'
     `errno.h' (BSD: Socket type not supported):  *Note Error Codes::.

`int ESPIPE'
     `errno.h' (POSIX.1: Illegal seek):  *Note Error Codes::.

`int ESRCH'
     `errno.h' (POSIX.1: No such process):  *Note Error Codes::.

`int ESRMNT'
     `errno.h' (Linux???: Srmount error):  *Note Error Codes::.

`int ESTALE'
     `errno.h' (BSD: Stale NFS file handle):  *Note Error Codes::.

`int ESTRPIPE'
     `errno.h' (Linux???: Streams pipe error):  *Note Error Codes::.

`int ETIME'
     `errno.h' (XOPEN: Timer expired):  *Note Error Codes::.

`int ETIMEDOUT'
     `errno.h' (BSD: Connection timed out):  *Note Error Codes::.

`int ETOOMANYREFS'
     `errno.h' (BSD: Too many references: cannot splice):  *Note Error
     Codes::.

`int ETXTBSY'
     `errno.h' (BSD: Text file busy):  *Note Error Codes::.

`int EUCLEAN'
     `errno.h' (Linux???: Structure needs cleaning):  *Note Error
     Codes::.

`int EUNATCH'
     `errno.h' (Linux???: Protocol driver not attached):  *Note Error
     Codes::.

`int EUSERS'
     `errno.h' (BSD: Too many users):  *Note Error Codes::.

`int EWOULDBLOCK'
     `errno.h' (BSD: Operation would block):  *Note Error Codes::.

`int EXDEV'
     `errno.h' (POSIX.1: Invalid cross-device link):  *Note Error
     Codes::.

`int execl (const char *FILENAME, const char *ARG0, ...)'
     `unistd.h' (POSIX.1):  *Note Executing a File::.

`int execle (const char *FILENAME, const char *ARG0, char *const ENV[], ...)'
     `unistd.h' (POSIX.1):  *Note Executing a File::.

`int execlp (const char *FILENAME, const char *ARG0, ...)'
     `unistd.h' (POSIX.1):  *Note Executing a File::.

`int execv (const char *FILENAME, char *const ARGV[])'
     `unistd.h' (POSIX.1):  *Note Executing a File::.

`int execve (const char *FILENAME, char *const ARGV[], char *const ENV[])'
     `unistd.h' (POSIX.1):  *Note Executing a File::.

`int execvp (const char *FILENAME, char *const ARGV[])'
     `unistd.h' (POSIX.1):  *Note Executing a File::.

`int EXFULL'
     `errno.h' (Linux???: Exchange full):  *Note Error Codes::.

`void _Exit (int STATUS)'
     `stdlib.h' (ISO):  *Note Termination Internals::.

`void _exit (int STATUS)'
     `unistd.h' (POSIX.1):  *Note Termination Internals::.

`void exit (int STATUS)'
     `stdlib.h' (ISO):  *Note Normal Termination::.

`int EXIT_FAILURE'
     `stdlib.h' (ISO):  *Note Exit Status::.

`int EXIT_SUCCESS'
     `stdlib.h' (ISO):  *Note Exit Status::.

`double exp (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`double exp10 (double X)'
     `math.h' (GNU):  *Note Exponents and Logarithms::.

`float exp10f (float X)'
     `math.h' (GNU):  *Note Exponents and Logarithms::.

`long double exp10l (long double X)'
     `math.h' (GNU):  *Note Exponents and Logarithms::.

`double exp2 (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float exp2f (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double exp2l (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float expf (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double expl (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`double expm1 (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float expm1f (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double expm1l (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`int EXPR_NEST_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`double fabs (double NUMBER)'
     `math.h' (ISO):  *Note Absolute Value::.

`float fabsf (float NUMBER)'
     `math.h' (ISO):  *Note Absolute Value::.

`long double fabsl (long double NUMBER)'
     `math.h' (ISO):  *Note Absolute Value::.

`size_t __fbufsize (FILE *STREAM)'
     `stdio_ext.h' (GNU):  *Note Controlling Buffering::.

`int fchdir (int FILEDES)'
     `unistd.h' (XPG):  *Note Working Directory::.

`int fchmod (int FILEDES, int MODE)'
     `sys/stat.h' (BSD):  *Note Setting Permissions::.

`int fchown (int FILEDES, int OWNER, int GROUP)'
     `unistd.h' (BSD):  *Note File Owner::.

`int fclean (FILE *STREAM)'
     `stdio.h' (GNU):  *Note Cleaning Streams::.

`int fclose (FILE *STREAM)'
     `stdio.h' (ISO):  *Note Closing Streams::.

`int fcloseall (void)'
     `stdio.h' (GNU):  *Note Closing Streams::.

`int fcntl (int FILEDES, int COMMAND, ...)'
     `fcntl.h' (POSIX.1):  *Note Control Operations::.

`char * fcvt (double VALUE, int NDIGIT, int *DECPT, int *NEG)'
     `stdlib.h' (SVID, Unix98):  *Note System V Number Conversion::.

`int fcvt_r (double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)'
     `stdlib.h' (SVID, Unix98):  *Note System V Number Conversion::.

`int fdatasync (int FILDES)'
     `unistd.h' (POSIX):  *Note Synchronizing I/O::.

`int FD_CLOEXEC'
     `fcntl.h' (POSIX.1):  *Note Descriptor Flags::.

`void FD_CLR (int FILEDES, fd_set *SET)'
     `sys/types.h' (BSD):  *Note Waiting for I/O::.

`double fdim (double X, double Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`float fdimf (float X, float Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`long double fdiml (long double X, long double Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`int FD_ISSET (int FILEDES, const fd_set *SET)'
     `sys/types.h' (BSD):  *Note Waiting for I/O::.

`FILE * fdopen (int FILEDES, const char *OPENTYPE)'
     `stdio.h' (POSIX.1):  *Note Descriptors and Streams::.

`DIR * fdopendir (int FD)'
     `dirent.h' (GNU):  *Note Opening a Directory::.

`void FD_SET (int FILEDES, fd_set *SET)'
     `sys/types.h' (BSD):  *Note Waiting for I/O::.

`fd_set'
     `sys/types.h' (BSD):  *Note Waiting for I/O::.

`int FD_SETSIZE'
     `sys/types.h' (BSD):  *Note Waiting for I/O::.

`int F_DUPFD'
     `fcntl.h' (POSIX.1):  *Note Duplicating Descriptors::.

`void FD_ZERO (fd_set *SET)'
     `sys/types.h' (BSD):  *Note Waiting for I/O::.

`int feclearexcept (int EXCEPTS)'
     `fenv.h' (ISO):  *Note Status bit operations::.

`int fedisableexcept (int EXCEPTS)'
     `fenv.h' (GNU):  *Note Control Functions::.

`FE_DIVBYZERO'
     `fenv.h' (ISO):  *Note Status bit operations::.

`FE_DOWNWARD'
     `fenv.h' (ISO):  *Note Rounding::.

`int feenableexcept (int EXCEPTS)'
     `fenv.h' (GNU):  *Note Control Functions::.

`int fegetenv (fenv_t *ENVP)'
     `fenv.h' (ISO):  *Note Control Functions::.

`int fegetexcept (int EXCEPTS)'
     `fenv.h' (GNU):  *Note Control Functions::.

`int fegetexceptflag (fexcept_t *FLAGP, int EXCEPTS)'
     `fenv.h' (ISO):  *Note Status bit operations::.

`int fegetround (void)'
     `fenv.h' (ISO):  *Note Rounding::.

`int feholdexcept (fenv_t *ENVP)'
     `fenv.h' (ISO):  *Note Control Functions::.

`FE_INEXACT'
     `fenv.h' (ISO):  *Note Status bit operations::.

`FE_INVALID'
     `fenv.h' (ISO):  *Note Status bit operations::.

`int feof (FILE *STREAM)'
     `stdio.h' (ISO):  *Note EOF and Errors::.

`int feof_unlocked (FILE *STREAM)'
     `stdio.h' (GNU):  *Note EOF and Errors::.

`FE_OVERFLOW'
     `fenv.h' (ISO):  *Note Status bit operations::.

`int feraiseexcept (int EXCEPTS)'
     `fenv.h' (ISO):  *Note Status bit operations::.

`int ferror (FILE *STREAM)'
     `stdio.h' (ISO):  *Note EOF and Errors::.

`int ferror_unlocked (FILE *STREAM)'
     `stdio.h' (GNU):  *Note EOF and Errors::.

`int fesetenv (const fenv_t *ENVP)'
     `fenv.h' (ISO):  *Note Control Functions::.

`int fesetexceptflag (const fexcept_t *FLAGP, int EXCEPTS)'
     `fenv.h' (ISO):  *Note Status bit operations::.

`int fesetround (int ROUND)'
     `fenv.h' (ISO):  *Note Rounding::.

`int fetestexcept (int EXCEPTS)'
     `fenv.h' (ISO):  *Note Status bit operations::.

`FE_TONEAREST'
     `fenv.h' (ISO):  *Note Rounding::.

`FE_TOWARDZERO'
     `fenv.h' (ISO):  *Note Rounding::.

`FE_UNDERFLOW'
     `fenv.h' (ISO):  *Note Status bit operations::.

`int feupdateenv (const fenv_t *ENVP)'
     `fenv.h' (ISO):  *Note Control Functions::.

`FE_UPWARD'
     `fenv.h' (ISO):  *Note Rounding::.

`int fflush (FILE *STREAM)'
     `stdio.h' (ISO):  *Note Flushing Buffers::.

`int fflush_unlocked (FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Flushing Buffers::.

`int fgetc (FILE *STREAM)'
     `stdio.h' (ISO):  *Note Character Input::.

`int fgetc_unlocked (FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Character Input::.

`int F_GETFD'
     `fcntl.h' (POSIX.1):  *Note Descriptor Flags::.

`int F_GETFL'
     `fcntl.h' (POSIX.1):  *Note Getting File Status Flags::.

`struct group * fgetgrent (FILE *STREAM)'
     `grp.h' (SVID):  *Note Scanning All Groups::.

`int fgetgrent_r (FILE *STREAM, struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)'
     `grp.h' (GNU):  *Note Scanning All Groups::.

`int F_GETLK'
     `fcntl.h' (POSIX.1):  *Note File Locks::.

`int F_GETOWN'
     `fcntl.h' (BSD):  *Note Interrupt Input::.

`int fgetpos (FILE *STREAM, fpos_t *POSITION)'
     `stdio.h' (ISO):  *Note Portable Positioning::.

`int fgetpos64 (FILE *STREAM, fpos64_t *POSITION)'
     `stdio.h' (Unix98):  *Note Portable Positioning::.

`struct passwd * fgetpwent (FILE *STREAM)'
     `pwd.h' (SVID):  *Note Scanning All Users::.

`int fgetpwent_r (FILE *STREAM, struct passwd *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd **RESULT)'
     `pwd.h' (GNU):  *Note Scanning All Users::.

`char * fgets (char *S, int COUNT, FILE *STREAM)'
     `stdio.h' (ISO):  *Note Line Input::.

`char * fgets_unlocked (char *S, int COUNT, FILE *STREAM)'
     `stdio.h' (GNU):  *Note Line Input::.

`wint_t fgetwc (FILE *STREAM)'
     `wchar.h' (ISO):  *Note Character Input::.

`wint_t fgetwc_unlocked (FILE *STREAM)'
     `wchar.h' (GNU):  *Note Character Input::.

`wchar_t * fgetws (wchar_t *WS, int COUNT, FILE *STREAM)'
     `wchar.h' (ISO):  *Note Line Input::.

`wchar_t * fgetws_unlocked (wchar_t *WS, int COUNT, FILE *STREAM)'
     `wchar.h' (GNU):  *Note Line Input::.

`FILE'
     `stdio.h' (ISO):  *Note Streams::.

`int FILENAME_MAX'
     `stdio.h' (ISO):  *Note Limits for Files::.

`int fileno (FILE *STREAM)'
     `stdio.h' (POSIX.1):  *Note Descriptors and Streams::.

`int fileno_unlocked (FILE *STREAM)'
     `stdio.h' (GNU):  *Note Descriptors and Streams::.

`int finite (double X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int finitef (float X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int finitel (long double X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int __flbf (FILE *STREAM)'
     `stdio_ext.h' (GNU):  *Note Controlling Buffering::.

`void flockfile (FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Streams and Threads::.

`double floor (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`float floorf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long double floorl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`FLT_DIG'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_EPSILON'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_MANT_DIG'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_MAX'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_MAX_10_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_MAX_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_MIN'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_MIN_10_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_MIN_EXP'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_RADIX'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`FLT_ROUNDS'
     `float.h' (ISO):  *Note Floating Point Parameters::.

`void _flushlbf (void)'
     `stdio_ext.h' (GNU):  *Note Flushing Buffers::.

`tcflag_t FLUSHO'
     `termios.h' (BSD):  *Note Local Modes::.

`double fma (double X, double Y, double Z)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`float fmaf (float X, float Y, float Z)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`long double fmal (long double X, long double Y, long double Z)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`double fmax (double X, double Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`float fmaxf (float X, float Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`long double fmaxl (long double X, long double Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`FILE * fmemopen (void *BUF, size_t SIZE, const char *OPENTYPE)'
     `stdio.h' (GNU):  *Note String Streams::.

`double fmin (double X, double Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`float fminf (float X, float Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`long double fminl (long double X, long double Y)'
     `math.h' (ISO):  *Note Misc FP Arithmetic::.

`double fmod (double NUMERATOR, double DENOMINATOR)'
     `math.h' (ISO):  *Note Remainder Functions::.

`float fmodf (float NUMERATOR, float DENOMINATOR)'
     `math.h' (ISO):  *Note Remainder Functions::.

`long double fmodl (long double NUMERATOR, long double DENOMINATOR)'
     `math.h' (ISO):  *Note Remainder Functions::.

`int fmtmsg (long int CLASSIFICATION, const char *LABEL, int SEVERITY, const char *TEXT, const char *ACTION, const char *TAG)'
     `fmtmsg.h' (XPG):  *Note Printing Formatted Messages::.

`int fnmatch (const char *PATTERN, const char *STRING, int FLAGS)'
     `fnmatch.h' (POSIX.2):  *Note Wildcard Matching::.

`FNM_CASEFOLD'
     `fnmatch.h' (GNU):  *Note Wildcard Matching::.

`FNM_EXTMATCH'
     `fnmatch.h' (GNU):  *Note Wildcard Matching::.

`FNM_FILE_NAME'
     `fnmatch.h' (GNU):  *Note Wildcard Matching::.

`FNM_LEADING_DIR'
     `fnmatch.h' (GNU):  *Note Wildcard Matching::.

`FNM_NOESCAPE'
     `fnmatch.h' (POSIX.2):  *Note Wildcard Matching::.

`FNM_PATHNAME'
     `fnmatch.h' (POSIX.2):  *Note Wildcard Matching::.

`FNM_PERIOD'
     `fnmatch.h' (POSIX.2):  *Note Wildcard Matching::.

`int F_OK'
     `unistd.h' (POSIX.1):  *Note Testing File Access::.

`FILE * fopen (const char *FILENAME, const char *OPENTYPE)'
     `stdio.h' (ISO):  *Note Opening Streams::.

`FILE * fopen64 (const char *FILENAME, const char *OPENTYPE)'
     `stdio.h' (Unix98):  *Note Opening Streams::.

`FILE * fopencookie (void *COOKIE, const char *OPENTYPE, cookie_io_functions_t IO-FUNCTIONS)'
     `stdio.h' (GNU):  *Note Streams and Cookies::.

`int FOPEN_MAX'
     `stdio.h' (ISO):  *Note Opening Streams::.

`pid_t fork (void)'
     `unistd.h' (POSIX.1):  *Note Creating a Process::.

`int forkpty (int *AMASTER, char *NAME, const struct termios *TERMP, const struct winsize *WINP)'
     `pty.h' (BSD):  *Note Pseudo-Terminal Pairs::.

`long int fpathconf (int FILEDES, int PARAMETER)'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`int fpclassify (_float-type_ X)'
     `math.h' (ISO):  *Note Floating Point Classes::.

`FPE_DECOVF_TRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_FLTDIV_FAULT'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_FLTDIV_TRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_FLTOVF_FAULT'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_FLTOVF_TRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_FLTUND_FAULT'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_FLTUND_TRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_INTDIV_TRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`FPE_INTOVF_TRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`size_t __fpending (FILE *STREAM) The `__fpending''
     `stdio_ext.h' (GNU):  *Note Controlling Buffering::.

`FPE_SUBRNG_TRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`int FP_ILOGB0'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`int FP_ILOGBNAN'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`fpos64_t'
     `stdio.h' (Unix98):  *Note Portable Positioning::.

`fpos_t'
     `stdio.h' (ISO):  *Note Portable Positioning::.

`int fprintf (FILE *STREAM, const char *TEMPLATE, ...)'
     `stdio.h' (ISO):  *Note Formatted Output Functions::.

`void __fpurge (FILE *STREAM)'
     `stdio_ext.h' (GNU):  *Note Flushing Buffers::.

`int fputc (int C, FILE *STREAM)'
     `stdio.h' (ISO):  *Note Simple Output::.

`int fputc_unlocked (int C, FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Simple Output::.

`int fputs (const char *S, FILE *STREAM)'
     `stdio.h' (ISO):  *Note Simple Output::.

`int fputs_unlocked (const char *S, FILE *STREAM)'
     `stdio.h' (GNU):  *Note Simple Output::.

`wint_t fputwc (wchar_t WC, FILE *STREAM)'
     `wchar.h' (ISO):  *Note Simple Output::.

`wint_t fputwc_unlocked (wint_t WC, FILE *STREAM)'
     `wchar.h' (POSIX):  *Note Simple Output::.

`int fputws (const wchar_t *WS, FILE *STREAM)'
     `wchar.h' (ISO):  *Note Simple Output::.

`int fputws_unlocked (const wchar_t *WS, FILE *STREAM)'
     `wchar.h' (GNU):  *Note Simple Output::.

`F_RDLCK'
     `fcntl.h' (POSIX.1):  *Note File Locks::.

`size_t fread (void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)'
     `stdio.h' (ISO):  *Note Block Input/Output::.

`int __freadable (FILE *STREAM)'
     `stdio_ext.h' (GNU):  *Note Opening Streams::.

`int __freading (FILE *STREAM)'
     `stdio_ext.h' (GNU):  *Note Opening Streams::.

`size_t fread_unlocked (void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)'
     `stdio.h' (GNU):  *Note Block Input/Output::.

`void free (void *PTR)'
     `malloc.h', `stdlib.h' (ISO):  *Note Freeing after Malloc::.

`__free_hook'
     `malloc.h' (GNU):  *Note Hooks for Malloc::.

`FILE * freopen (const char *FILENAME, const char *OPENTYPE, FILE *STREAM)'
     `stdio.h' (ISO):  *Note Opening Streams::.

`FILE * freopen64 (const char *FILENAME, const char *OPENTYPE, FILE *STREAM)'
     `stdio.h' (Unix98):  *Note Opening Streams::.

`double frexp (double VALUE, int *EXPONENT)'
     `math.h' (ISO):  *Note Normalization Functions::.

`float frexpf (float VALUE, int *EXPONENT)'
     `math.h' (ISO):  *Note Normalization Functions::.

`long double frexpl (long double VALUE, int *EXPONENT)'
     `math.h' (ISO):  *Note Normalization Functions::.

`int fscanf (FILE *STREAM, const char *TEMPLATE, ...)'
     `stdio.h' (ISO):  *Note Formatted Input Functions::.

`int fseek (FILE *STREAM, long int OFFSET, int WHENCE)'
     `stdio.h' (ISO):  *Note File Positioning::.

`int fseeko (FILE *STREAM, off_t OFFSET, int WHENCE)'
     `stdio.h' (Unix98):  *Note File Positioning::.

`int fseeko64 (FILE *STREAM, off64_t OFFSET, int WHENCE)'
     `stdio.h' (Unix98):  *Note File Positioning::.

`int F_SETFD'
     `fcntl.h' (POSIX.1):  *Note Descriptor Flags::.

`int F_SETFL'
     `fcntl.h' (POSIX.1):  *Note Getting File Status Flags::.

`int F_SETLK'
     `fcntl.h' (POSIX.1):  *Note File Locks::.

`int F_SETLKW'
     `fcntl.h' (POSIX.1):  *Note File Locks::.

`int __fsetlocking (FILE *STREAM, int TYPE)'
     `stdio_ext.h' (GNU):  *Note Streams and Threads::.

`int F_SETOWN'
     `fcntl.h' (BSD):  *Note Interrupt Input::.

`int fsetpos (FILE *STREAM, const fpos_t *POSITION)'
     `stdio.h' (ISO):  *Note Portable Positioning::.

`int fsetpos64 (FILE *STREAM, const fpos64_t *POSITION)'
     `stdio.h' (Unix98):  *Note Portable Positioning::.

`int fstat (int FILEDES, struct stat *BUF)'
     `sys/stat.h' (POSIX.1):  *Note Reading Attributes::.

`int fstat64 (int FILEDES, struct stat64 *BUF)'
     `sys/stat.h' (Unix98):  *Note Reading Attributes::.

`int fsync (int FILDES)'
     `unistd.h' (POSIX):  *Note Synchronizing I/O::.

`long int ftell (FILE *STREAM)'
     `stdio.h' (ISO):  *Note File Positioning::.

`off_t ftello (FILE *STREAM)'
     `stdio.h' (Unix98):  *Note File Positioning::.

`off64_t ftello64 (FILE *STREAM)'
     `stdio.h' (Unix98):  *Note File Positioning::.

`int ftruncate (int FD, off_t LENGTH)'
     `unistd.h' (POSIX):  *Note File Size::.

`int ftruncate64 (int ID, off64_t LENGTH)'
     `unistd.h' (Unix98):  *Note File Size::.

`int ftrylockfile (FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Streams and Threads::.

`int ftw (const char *FILENAME, __ftw_func_t FUNC, int DESCRIPTORS)'
     `ftw.h' (SVID):  *Note Working with Directory Trees::.

`int ftw64 (const char *FILENAME, __ftw64_func_t FUNC, int DESCRIPTORS)'
     `ftw.h' (Unix98):  *Note Working with Directory Trees::.

`__ftw64_func_t'
     `ftw.h' (GNU):  *Note Working with Directory Trees::.

`__ftw_func_t'
     `ftw.h' (GNU):  *Note Working with Directory Trees::.

`F_UNLCK'
     `fcntl.h' (POSIX.1):  *Note File Locks::.

`void funlockfile (FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Streams and Threads::.

`int futimes (int FD, struct timeval TVP[2])'
     `sys/time.h' (BSD):  *Note File Times::.

`int fwide (FILE *STREAM, int MODE)'
     `wchar.h' (ISO):  *Note Streams and I18N::.

`int fwprintf (FILE *STREAM, const wchar_t *TEMPLATE, ...)'
     `wchar.h' (ISO):  *Note Formatted Output Functions::.

`int __fwritable (FILE *STREAM)'
     `stdio_ext.h' (GNU):  *Note Opening Streams::.

`size_t fwrite (const void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)'
     `stdio.h' (ISO):  *Note Block Input/Output::.

`size_t fwrite_unlocked (const void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)'
     `stdio.h' (GNU):  *Note Block Input/Output::.

`int __fwriting (FILE *STREAM)'
     `stdio_ext.h' (GNU):  *Note Opening Streams::.

`F_WRLCK'
     `fcntl.h' (POSIX.1):  *Note File Locks::.

`int fwscanf (FILE *STREAM, const wchar_t *TEMPLATE, ...)'
     `wchar.h' (ISO):  *Note Formatted Input Functions::.

`double gamma (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float gammaf (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double gammal (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`void (*__gconv_end_fct) (struct gconv_step *)'
     `gconv.h' (GNU):  *Note glibc iconv Implementation::.

`int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *, const char **, const char *, size_t *, int)'
     `gconv.h' (GNU):  *Note glibc iconv Implementation::.

`int (*__gconv_init_fct) (struct __gconv_step *)'
     `gconv.h' (GNU):  *Note glibc iconv Implementation::.

`char * gcvt (double VALUE, int NDIGIT, char *BUF)'
     `stdlib.h' (SVID, Unix98):  *Note System V Number Conversion::.

`long int get_avphys_pages (void)'
     `sys/sysinfo.h' (GNU):  *Note Query Memory Parameters::.

`int getc (FILE *STREAM)'
     `stdio.h' (ISO):  *Note Character Input::.

`int getchar (void)'
     `stdio.h' (ISO):  *Note Character Input::.

`int getchar_unlocked (void)'
     `stdio.h' (POSIX):  *Note Character Input::.

`int getcontext (ucontext_t *UCP)'
     `ucontext.h' (SVID):  *Note System V contexts::.

`int getc_unlocked (FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Character Input::.

`char * get_current_dir_name (void)'
     `unistd.h' (GNU):  *Note Working Directory::.

`char * getcwd (char *BUFFER, size_t SIZE)'
     `unistd.h' (POSIX.1):  *Note Working Directory::.

`struct tm * getdate (const char *STRING)'
     `time.h' (Unix98):  *Note General Time String Parsing::.

`getdate_err'
     `time.h' (Unix98):  *Note General Time String Parsing::.

`int getdate_r (const char *STRING, struct tm *TP)'
     `time.h' (GNU):  *Note General Time String Parsing::.

`ssize_t getdelim (char **LINEPTR, size_t *N, int DELIMITER, FILE *STREAM)'
     `stdio.h' (GNU):  *Note Line Input::.

`int getdomainnname (char *NAME, size_t LENGTH)'
     `unistd.h' (???):  *Note Host Identification::.

`gid_t getegid (void)'
     `unistd.h' (POSIX.1):  *Note Reading Persona::.

`char * getenv (const char *NAME)'
     `stdlib.h' (ISO):  *Note Environment Access::.

`uid_t geteuid (void)'
     `unistd.h' (POSIX.1):  *Note Reading Persona::.

`struct fstab * getfsent (void)'
     `fstab.h' (BSD):  *Note fstab::.

`struct fstab * getfsfile (const char *NAME)'
     `fstab.h' (BSD):  *Note fstab::.

`struct fstab * getfsspec (const char *NAME)'
     `fstab.h' (BSD):  *Note fstab::.

`gid_t getgid (void)'
     `unistd.h' (POSIX.1):  *Note Reading Persona::.

`struct group * getgrent (void)'
     `grp.h' (SVID, BSD):  *Note Scanning All Groups::.

`int getgrent_r (struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)'
     `grp.h' (GNU):  *Note Scanning All Groups::.

`struct group * getgrgid (gid_t GID)'
     `grp.h' (POSIX.1):  *Note Lookup Group::.

`int getgrgid_r (gid_t GID, struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)'
     `grp.h' (POSIX.1c):  *Note Lookup Group::.

`struct group * getgrnam (const char *NAME)'
     `grp.h' (SVID, BSD):  *Note Lookup Group::.

`int getgrnam_r (const char *NAME, struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)'
     `grp.h' (POSIX.1c):  *Note Lookup Group::.

`int getgrouplist (const char *USER, gid_t GROUP, gid_t *GROUPS, int *NGROUPS)'
     `grp.h' (BSD):  *Note Setting Groups::.

`int getgroups (int COUNT, gid_t *GROUPS)'
     `unistd.h' (POSIX.1):  *Note Reading Persona::.

`struct hostent * gethostbyaddr (const char *ADDR, size_t LENGTH, int FORMAT)'
     `netdb.h' (BSD):  *Note Host Names::.

`int gethostbyaddr_r (const char *ADDR, size_t LENGTH, int FORMAT, struct hostent *restrict RESULT_BUF, char *restrict BUF, size_t BUFLEN, struct hostent **restrict RESULT, int *restrict H_ERRNOP)'
     `netdb.h' (GNU):  *Note Host Names::.

`struct hostent * gethostbyname (const char *NAME)'
     `netdb.h' (BSD):  *Note Host Names::.

`struct hostent * gethostbyname2 (const char *NAME, int AF)'
     `netdb.h' (IPv6 Basic API):  *Note Host Names::.

`int gethostbyname2_r (const char *NAME, int AF, struct hostent *restrict RESULT_BUF, char *restrict BUF, size_t BUFLEN, struct hostent **restrict RESULT, int *restrict H_ERRNOP)'
     `netdb.h' (GNU):  *Note Host Names::.

`int gethostbyname_r (const char *restrict NAME, struct hostent *restrict RESULT_BUF, char *restrict BUF, size_t BUFLEN, struct hostent **restrict RESULT, int *restrict H_ERRNOP)'
     `netdb.h' (GNU):  *Note Host Names::.

`struct hostent * gethostent (void)'
     `netdb.h' (BSD):  *Note Host Names::.

`long int gethostid (void)'
     `unistd.h' (BSD):  *Note Host Identification::.

`int gethostname (char *NAME, size_t SIZE)'
     `unistd.h' (BSD):  *Note Host Identification::.

`int getitimer (int WHICH, struct itimerval *OLD)'
     `sys/time.h' (BSD):  *Note Setting an Alarm::.

`ssize_t getline (char **LINEPTR, size_t *N, FILE *STREAM)'
     `stdio.h' (GNU):  *Note Line Input::.

`int getloadavg (double LOADAVG[], int NELEM)'
     `stdlib.h' (BSD):  *Note Processor Resources::.

`char * getlogin (void)'
     `unistd.h' (POSIX.1):  *Note Who Logged In::.

`struct mntent * getmntent (FILE *STREAM)'
     `mntent.h' (BSD):  *Note mtab::.

`struct mntent * getmntent_r (FILE *STREAM, struct mentent *RESULT, char *BUFFER, int BUFSIZE)'
     `mntent.h' (BSD):  *Note mtab::.

`struct netent * getnetbyaddr (unsigned long int NET, int TYPE)'
     `netdb.h' (BSD):  *Note Networks Database::.

`struct netent * getnetbyname (const char *NAME)'
     `netdb.h' (BSD):  *Note Networks Database::.

`struct netent * getnetent (void)'
     `netdb.h' (BSD):  *Note Networks Database::.

`int getnetgrent (char **HOSTP, char **USERP, char **DOMAINP)'
     `netdb.h' (BSD):  *Note Lookup Netgroup::.

`int getnetgrent_r (char **HOSTP, char **USERP, char **DOMAINP, char *BUFFER, int BUFLEN)'
     `netdb.h' (GNU):  *Note Lookup Netgroup::.

`int get_nprocs (void)'
     `sys/sysinfo.h' (GNU):  *Note Processor Resources::.

`int get_nprocs_conf (void)'
     `sys/sysinfo.h' (GNU):  *Note Processor Resources::.

`int getopt (int ARGC, char **ARGV, const char *OPTIONS)'
     `unistd.h' (POSIX.2):  *Note Using Getopt::.

`int getopt_long (int ARGC, char *const *ARGV, const char *SHORTOPTS, const struct option *LONGOPTS, int *INDEXPTR)'
     `getopt.h' (GNU):  *Note Getopt Long Options::.

`int getopt_long_only (int ARGC, char *const *ARGV, const char *SHORTOPTS, const struct option *LONGOPTS, int *INDEXPTR)'
     `getopt.h' (GNU):  *Note Getopt Long Options::.

`int getpagesize (void)'
     `unistd.h' (BSD):  *Note Query Memory Parameters::.

`char * getpass (const char *PROMPT)'
     `unistd.h' (BSD):  *Note getpass::.

`int getpeername (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)'
     `sys/socket.h' (BSD):  *Note Who is Connected::.

`int getpgid (pid_t PID)'
     `unistd.h' (SVID):  *Note Process Group Functions::.

`pid_t getpgrp (pid_t PID)'
     `unistd.h' (BSD):  *Note Process Group Functions::.

`pid_t getpgrp (void)'
     `unistd.h' (POSIX.1):  *Note Process Group Functions::.

`long int get_phys_pages (void)'
     `sys/sysinfo.h' (GNU):  *Note Query Memory Parameters::.

`pid_t getpid (void)'
     `unistd.h' (POSIX.1):  *Note Process Identification::.

`pid_t getppid (void)'
     `unistd.h' (POSIX.1):  *Note Process Identification::.

`int getpriority (int CLASS, int ID)'
     `sys/resource.h' (BSD,POSIX):  *Note Traditional Scheduling
     Functions::.

`struct protoent * getprotobyname (const char *NAME)'
     `netdb.h' (BSD):  *Note Protocols Database::.

`struct protoent * getprotobynumber (int PROTOCOL)'
     `netdb.h' (BSD):  *Note Protocols Database::.

`struct protoent * getprotoent (void)'
     `netdb.h' (BSD):  *Note Protocols Database::.

`int getpt (void)'
     `stdlib.h' (GNU):  *Note Allocation::.

`struct passwd * getpwent (void)'
     `pwd.h' (POSIX.1):  *Note Scanning All Users::.

`int getpwent_r (struct passwd *RESULT_BUF, char *BUFFER, int BUFLEN, struct passwd **RESULT)'
     `pwd.h' (GNU):  *Note Scanning All Users::.

`struct passwd * getpwnam (const char *NAME)'
     `pwd.h' (POSIX.1):  *Note Lookup User::.

`int getpwnam_r (const char *NAME, struct passwd *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd **RESULT)'
     `pwd.h' (POSIX.1c):  *Note Lookup User::.

`struct passwd * getpwuid (uid_t UID)'
     `pwd.h' (POSIX.1):  *Note Lookup User::.

`int getpwuid_r (uid_t UID, struct passwd *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd **RESULT)'
     `pwd.h' (POSIX.1c):  *Note Lookup User::.

`int getrlimit (int RESOURCE, struct rlimit *RLP)'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`int getrlimit64 (int RESOURCE, struct rlimit64 *RLP)'
     `sys/resource.h' (Unix98):  *Note Limits on Resources::.

`int getrusage (int PROCESSES, struct rusage *RUSAGE)'
     `sys/resource.h' (BSD):  *Note Resource Usage::.

`char * gets (char *S)'
     `stdio.h' (ISO):  *Note Line Input::.

`struct servent * getservbyname (const char *NAME, const char *PROTO)'
     `netdb.h' (BSD):  *Note Services Database::.

`struct servent * getservbyport (int PORT, const char *PROTO)'
     `netdb.h' (BSD):  *Note Services Database::.

`struct servent * getservent (void)'
     `netdb.h' (BSD):  *Note Services Database::.

`pid_t getsid (pid_t PID)'
     `unistd.h' (SVID):  *Note Process Group Functions::.

`int getsockname (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)'
     `sys/socket.h' (BSD):  *Note Reading Address::.

`int getsockopt (int SOCKET, int LEVEL, int OPTNAME, void *OPTVAL, socklen_t *OPTLEN-PTR)'
     `sys/socket.h' (BSD):  *Note Socket Option Functions::.

`int getsubopt (char **OPTIONP, const char* const *TOKENS, char **VALUEP)'
     `stdlib.h' (stdlib.h):  *Note Suboptions Example: Suboptions.

`char * gettext (const char *MSGID)'
     `libintl.h' (GNU):  *Note Translation with gettext::.

`int gettimeofday (struct timeval *TP, struct timezone *TZP)'
     `sys/time.h' (BSD):  *Note High-Resolution Calendar::.

`uid_t getuid (void)'
     `unistd.h' (POSIX.1):  *Note Reading Persona::.

`mode_t getumask (void)'
     `sys/stat.h' (GNU):  *Note Setting Permissions::.

`struct utmp * getutent (void)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`int getutent_r (struct utmp *BUFFER, struct utmp **RESULT)'
     `utmp.h' (GNU):  *Note Manipulating the Database::.

`struct utmp * getutid (const struct utmp *ID)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`int getutid_r (const struct utmp *ID, struct utmp *BUFFER, struct utmp **RESULT)'
     `utmp.h' (GNU):  *Note Manipulating the Database::.

`struct utmp * getutline (const struct utmp *LINE)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`int getutline_r (const struct utmp *LINE, struct utmp *BUFFER, struct utmp **RESULT)'
     `utmp.h' (GNU):  *Note Manipulating the Database::.

`int getutmp (const struct utmpx *utmpx, struct utmp *utmp)'
     `utmp.h' (GNU):  *Note XPG Functions::.

`int getutmpx (const struct utmp *utmp, struct utmpx *utmpx)'
     `utmp.h' (GNU):  *Note XPG Functions::.

`struct utmpx * getutxent (void)'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`struct utmpx * getutxid (const struct utmpx *ID)'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`struct utmpx * getutxline (const struct utmpx *LINE)'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int getw (FILE *STREAM)'
     `stdio.h' (SVID):  *Note Character Input::.

`wint_t getwc (FILE *STREAM)'
     `wchar.h' (ISO):  *Note Character Input::.

`wint_t getwchar (void)'
     `wchar.h' (ISO):  *Note Character Input::.

`wint_t getwchar_unlocked (void)'
     `wchar.h' (GNU):  *Note Character Input::.

`wint_t getwc_unlocked (FILE *STREAM)'
     `wchar.h' (GNU):  *Note Character Input::.

`char * getwd (char *BUFFER)'
     `unistd.h' (BSD):  *Note Working Directory::.

`gid_t'
     `sys/types.h' (POSIX.1):  *Note Reading Persona::.

`int glob (const char *PATTERN, int FLAGS, int (*ERRFUNC) (const char *FILENAME, int ERROR-CODE), glob_t *VECTOR-PTR)'
     `glob.h' (POSIX.2):  *Note Calling Glob::.

`int glob64 (const char *PATTERN, int FLAGS, int (*ERRFUNC) (const char *FILENAME, int ERROR-CODE), glob64_t *VECTOR-PTR)'
     `glob.h' (GNU):  *Note Calling Glob::.

`glob64_t'
     `glob.h' (GNU):  *Note Calling Glob::.

`GLOB_ABORTED'
     `glob.h' (POSIX.2):  *Note Calling Glob::.

`GLOB_ALTDIRFUNC'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`GLOB_APPEND'
     `glob.h' (POSIX.2):  *Note Flags for Globbing::.

`GLOB_BRACE'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`GLOB_DOOFFS'
     `glob.h' (POSIX.2):  *Note Flags for Globbing::.

`GLOB_ERR'
     `glob.h' (POSIX.2):  *Note Flags for Globbing::.

`void globfree (glob_t *PGLOB)'
     `glob.h' (POSIX.2):  *Note More Flags for Globbing::.

`void globfree64 (glob64_t *PGLOB)'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`GLOB_MAGCHAR'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`GLOB_MARK'
     `glob.h' (POSIX.2):  *Note Flags for Globbing::.

`GLOB_NOCHECK'
     `glob.h' (POSIX.2):  *Note Flags for Globbing::.

`GLOB_NOESCAPE'
     `glob.h' (POSIX.2):  *Note Flags for Globbing::.

`GLOB_NOMAGIC'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`GLOB_NOMATCH'
     `glob.h' (POSIX.2):  *Note Calling Glob::.

`GLOB_NOSORT'
     `glob.h' (POSIX.2):  *Note Flags for Globbing::.

`GLOB_NOSPACE'
     `glob.h' (POSIX.2):  *Note Calling Glob::.

`GLOB_ONLYDIR'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`GLOB_PERIOD'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`glob_t'
     `glob.h' (POSIX.2):  *Note Calling Glob::.

`GLOB_TILDE'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`GLOB_TILDE_CHECK'
     `glob.h' (GNU):  *Note More Flags for Globbing::.

`struct tm * gmtime (const time_t *TIME)'
     `time.h' (ISO):  *Note Broken-down Time::.

`struct tm * gmtime_r (const time_t *TIME, struct tm *RESULTP)'
     `time.h' (POSIX.1c):  *Note Broken-down Time::.

`_GNU_SOURCE'
     (GNU):  *Note Feature Test Macros::.

`int grantpt (int FILEDES)'
     `stdlib.h' (SVID, XPG4.2):  *Note Allocation::.

`int gsignal (int SIGNUM)'
     `signal.h' (SVID):  *Note Signaling Yourself::.

`int gtty (int FILEDES, struct sgttyb *ATTRIBUTES)'
     `sgtty.h' (BSD):  *Note BSD Terminal Modes::.

`char * hasmntopt (const struct mntent *MNT, const char *OPT)'
     `mntent.h' (BSD):  *Note mtab::.

`int hcreate (size_t NEL)'
     `search.h' (SVID):  *Note Hash Search Function::.

`int hcreate_r (size_t NEL, struct hsearch_data *HTAB)'
     `search.h' (GNU):  *Note Hash Search Function::.

`void hdestroy (void)'
     `search.h' (SVID):  *Note Hash Search Function::.

`void hdestroy_r (struct hsearch_data *HTAB)'
     `search.h' (GNU):  *Note Hash Search Function::.

`HOST_NOT_FOUND'
     `netdb.h' (BSD):  *Note Host Names::.

`ENTRY * hsearch (ENTRY ITEM, ACTION ACTION)'
     `search.h' (SVID):  *Note Hash Search Function::.

`int hsearch_r (ENTRY ITEM, ACTION ACTION, ENTRY **RETVAL, struct hsearch_data *HTAB)'
     `search.h' (GNU):  *Note Hash Search Function::.

`uint32_t htonl (uint32_t HOSTLONG)'
     `netinet/in.h' (BSD):  *Note Byte Order::.

`uint16_t htons (uint16_t HOSTSHORT)'
     `netinet/in.h' (BSD):  *Note Byte Order::.

`double HUGE_VAL'
     `math.h' (ISO):  *Note Math Error Reporting::.

`float HUGE_VALF'
     `math.h' (ISO):  *Note Math Error Reporting::.

`long double HUGE_VALL'
     `math.h' (ISO):  *Note Math Error Reporting::.

`tcflag_t HUPCL'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`double hypot (double X, double Y)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float hypotf (float X, float Y)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double hypotl (long double X, long double Y)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`tcflag_t ICANON'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`size_t iconv (iconv_t CD, char **INBUF, size_t *INBYTESLEFT, char **OUTBUF, size_t *OUTBYTESLEFT)'
     `iconv.h' (XPG2):  *Note Generic Conversion Interface::.

`int iconv_close (iconv_t CD)'
     `iconv.h' (XPG2):  *Note Generic Conversion Interface::.

`iconv_t iconv_open (const char *TOCODE, const char *FROMCODE)'
     `iconv.h' (XPG2):  *Note Generic Conversion Interface::.

`iconv_t'
     `iconv.h' (XPG2):  *Note Generic Conversion Interface::.

`tcflag_t ICRNL'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`tcflag_t IEXTEN'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`void if_freenameindex (struct if_nameindex *ptr)'
     `net/if.h' (IPv6 basic API):  *Note Interface Naming::.

`char * if_indextoname (unsigned int ifindex, char *ifname)'
     `net/if.h' (IPv6 basic API):  *Note Interface Naming::.

`struct if_nameindex * if_nameindex (void)'
     `net/if.h' (IPv6 basic API):  *Note Interface Naming::.

`unsigned int if_nametoindex (const char *ifname)'
     `net/if.h' (IPv6 basic API):  *Note Interface Naming::.

`size_t IFNAMSIZ'
     `net/if.h' (net/if.h):  *Note Interface Naming::.

`int IFTODT (mode_t MODE)'
     `dirent.h' (BSD):  *Note Directory Entries::.

`tcflag_t IGNBRK'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`tcflag_t IGNCR'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`tcflag_t IGNPAR'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`int ilogb (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`int ilogbf (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`int ilogbl (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`intmax_t imaxabs (intmax_t NUMBER)'
     `inttypes.h' (ISO):  *Note Absolute Value::.

`tcflag_t IMAXBEL'
     `termios.h' (BSD):  *Note Input Modes::.

`imaxdiv_t imaxdiv (intmax_t NUMERATOR, intmax_t DENOMINATOR)'
     `inttypes.h' (ISO):  *Note Integer Division::.

`imaxdiv_t'
     `inttypes.h' (ISO):  *Note Integer Division::.

`struct in6_addr in6addr_any'
     `netinet/in.h' (IPv6 basic API):  *Note Host Address Data Type::.

`struct in6_addr in6addr_loopback'
     `netinet/in.h' (IPv6 basic API):  *Note Host Address Data Type::.

`uint32_t INADDR_ANY'
     `netinet/in.h' (BSD):  *Note Host Address Data Type::.

`uint32_t INADDR_BROADCAST'
     `netinet/in.h' (BSD):  *Note Host Address Data Type::.

`uint32_t INADDR_LOOPBACK'
     `netinet/in.h' (BSD):  *Note Host Address Data Type::.

`uint32_t INADDR_NONE'
     `netinet/in.h' (BSD):  *Note Host Address Data Type::.

`char * index (const char *STRING, int C)'
     `string.h' (BSD):  *Note Search Functions::.

`uint32_t inet_addr (const char *NAME)'
     `arpa/inet.h' (BSD):  *Note Host Address Functions::.

`int inet_aton (const char *NAME, struct in_addr *ADDR)'
     `arpa/inet.h' (BSD):  *Note Host Address Functions::.

`uint32_t inet_lnaof (struct in_addr ADDR)'
     `arpa/inet.h' (BSD):  *Note Host Address Functions::.

`struct in_addr inet_makeaddr (uint32_t NET, uint32_t LOCAL)'
     `arpa/inet.h' (BSD):  *Note Host Address Functions::.

`uint32_t inet_netof (struct in_addr ADDR)'
     `arpa/inet.h' (BSD):  *Note Host Address Functions::.

`uint32_t inet_network (const char *NAME)'
     `arpa/inet.h' (BSD):  *Note Host Address Functions::.

`char * inet_ntoa (struct in_addr ADDR)'
     `arpa/inet.h' (BSD):  *Note Host Address Functions::.

`const char * inet_ntop (int AF, const void *CP, char *BUF, size_t LEN)'
     `arpa/inet.h' (IPv6 basic API):  *Note Host Address Functions::.

`int inet_pton (int AF, const char *CP, void *BUF)'
     `arpa/inet.h' (IPv6 basic API):  *Note Host Address Functions::.

`float INFINITY'
     `math.h' (ISO):  *Note Infinity and NaN::.

`int initgroups (const char *USER, gid_t GROUP)'
     `grp.h' (BSD):  *Note Setting Groups::.

`INIT_PROCESS'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`INIT_PROCESS'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`void * initstate (unsigned int SEED, void *STATE, size_t SIZE)'
     `stdlib.h' (BSD):  *Note BSD Random::.

`int initstate_r (unsigned int SEED, char *restrict STATEBUF, size_t STATELEN, struct random_data *restrict BUF)'
     `stdlib.h' (GNU):  *Note BSD Random::.

`tcflag_t INLCR'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`int innetgr (const char *NETGROUP, const char *HOST, const char *USER, const char *DOMAIN)'
     `netdb.h' (BSD):  *Note Netgroup Membership::.

`ino64_t'
     `sys/types.h' (Unix98):  *Note Attribute Meanings::.

`ino_t'
     `sys/types.h' (POSIX.1):  *Note Attribute Meanings::.

`tcflag_t INPCK'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`long int telldir (DIR *DIRSTREAM)'
     `dirent.h' (BSD):  *Note Random Access Directory::.

`INT_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`INT_MIN'
     `limits.h' (ISO):  *Note Range of Type::.

`int ioctl (int FILEDES, int COMMAND, ...)'
     `sys/ioctl.h' (BSD):  *Note IOCTLs::.

`int _IOFBF'
     `stdio.h' (ISO):  *Note Controlling Buffering::.

`int _IOLBF'
     `stdio.h' (ISO):  *Note Controlling Buffering::.

`int _IONBF'
     `stdio.h' (ISO):  *Note Controlling Buffering::.

`int IPPORT_RESERVED'
     `netinet/in.h' (BSD):  *Note Ports::.

`int IPPORT_USERRESERVED'
     `netinet/in.h' (BSD):  *Note Ports::.

`int isalnum (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int isalpha (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int isascii (int C)'
     `ctype.h' (SVID, BSD):  *Note Classification of Characters::.

`int isatty (int FILEDES)'
     `unistd.h' (POSIX.1):  *Note Is It a Terminal::.

`int isblank (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int iscntrl (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int isdigit (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int isfinite (_float-type_ X)'
     `math.h' (ISO):  *Note Floating Point Classes::.

`int isgraph (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int isgreater (_real-floating_ X, _real-floating_ Y)'
     `math.h' (ISO):  *Note FP Comparison Functions::.

`int isgreaterequal (_real-floating_ X, _real-floating_ Y)'
     `math.h' (ISO):  *Note FP Comparison Functions::.

`tcflag_t ISIG'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`int isinf (double X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int isinff (float X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int isinfl (long double X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int isless (_real-floating_ X, _real-floating_ Y)'
     `math.h' (ISO):  *Note FP Comparison Functions::.

`int islessequal (_real-floating_ X, _real-floating_ Y)'
     `math.h' (ISO):  *Note FP Comparison Functions::.

`int islessgreater (_real-floating_ X, _real-floating_ Y)'
     `math.h' (ISO):  *Note FP Comparison Functions::.

`int islower (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int isnan (_float-type_ X)'
     `math.h' (ISO):  *Note Floating Point Classes::.

`int isnan (double X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int isnanf (float X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int isnanl (long double X)'
     `math.h' (BSD):  *Note Floating Point Classes::.

`int isnormal (_float-type_ X)'
     `math.h' (ISO):  *Note Floating Point Classes::.

`_ISOC99_SOURCE'
     (GNU):  *Note Feature Test Macros::.

`int isprint (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int ispunct (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int isspace (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`tcflag_t ISTRIP'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`int isunordered (_real-floating_ X, _real-floating_ Y)'
     `math.h' (ISO):  *Note FP Comparison Functions::.

`int isupper (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`int iswalnum (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswalpha (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswblank (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswcntrl (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswctype (wint_t WC, wctype_t DESC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswdigit (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswgraph (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswlower (wint_t WC)'
     `ctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswprint (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswpunct (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswspace (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswupper (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int iswxdigit (wint_t WC)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int isxdigit (int C)'
     `ctype.h' (ISO):  *Note Classification of Characters::.

`ITIMER_PROF'
     `sys/time.h' (BSD):  *Note Setting an Alarm::.

`ITIMER_REAL'
     `sys/time.h' (BSD):  *Note Setting an Alarm::.

`ITIMER_VIRTUAL'
     `sys/time.h' (BSD):  *Note Setting an Alarm::.

`tcflag_t IXANY'
     `termios.h' (BSD):  *Note Input Modes::.

`tcflag_t IXOFF'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`tcflag_t IXON'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`double j0 (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float j0f (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double j0l (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`double j1 (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float j1f (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double j1l (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`jmp_buf'
     `setjmp.h' (ISO):  *Note Non-Local Details::.

`double jn (int n, double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float jnf (int n, float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double jnl (int n, long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`long int jrand48 (unsigned short int XSUBI[3])'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int jrand48_r (unsigned short int XSUBI[3], struct drand48_data *BUFFER, long int *RESULT)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`int kill (pid_t PID, int SIGNUM)'
     `signal.h' (POSIX.1):  *Note Signaling Another Process::.

`int killpg (int PGID, int SIGNUM)'
     `signal.h' (BSD):  *Note Signaling Another Process::.

`char * l64a (long int N)'
     `stdlib.h' (XPG):  *Note Encode Binary Data::.

`long int labs (long int NUMBER)'
     `stdlib.h' (ISO):  *Note Absolute Value::.

`LANG'
     `locale.h' (ISO):  *Note Locale Categories::.

`LC_ALL'
     `locale.h' (ISO):  *Note Locale Categories::.

`LC_COLLATE'
     `locale.h' (ISO):  *Note Locale Categories::.

`LC_CTYPE'
     `locale.h' (ISO):  *Note Locale Categories::.

`LC_MESSAGES'
     `locale.h' (XOPEN):  *Note Locale Categories::.

`LC_MONETARY'
     `locale.h' (ISO):  *Note Locale Categories::.

`LC_NUMERIC'
     `locale.h' (ISO):  *Note Locale Categories::.

`void lcong48 (unsigned short int PARAM[7])'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int lcong48_r (unsigned short int PARAM[7], struct drand48_data *BUFFER)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`int L_ctermid'
     `stdio.h' (POSIX.1):  *Note Identifying the Terminal::.

`LC_TIME'
     `locale.h' (ISO):  *Note Locale Categories::.

`int L_cuserid'
     `stdio.h' (POSIX.1):  *Note Who Logged In::.

`double ldexp (double VALUE, int EXPONENT)'
     `math.h' (ISO):  *Note Normalization Functions::.

`float ldexpf (float VALUE, int EXPONENT)'
     `math.h' (ISO):  *Note Normalization Functions::.

`long double ldexpl (long double VALUE, int EXPONENT)'
     `math.h' (ISO):  *Note Normalization Functions::.

`ldiv_t ldiv (long int NUMERATOR, long int DENOMINATOR)'
     `stdlib.h' (ISO):  *Note Integer Division::.

`ldiv_t'
     `stdlib.h' (ISO):  *Note Integer Division::.

`void * lfind (const void *KEY, void *BASE, size_t *NMEMB, size_t SIZE, comparison_fn_t COMPAR)'
     `search.h' (SVID):  *Note Array Search Function::.

`double lgamma (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float lgammaf (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`float lgammaf_r (float X, int *SIGNP)'
     `math.h' (XPG):  *Note Special Functions::.

`long double lgammal (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double lgammal_r (long double X, int *SIGNP)'
     `math.h' (XPG):  *Note Special Functions::.

`double lgamma_r (double X, int *SIGNP)'
     `math.h' (XPG):  *Note Special Functions::.

`L_INCR'
     `sys/file.h' (BSD):  *Note File Positioning::.

`int LINE_MAX'
     `limits.h' (POSIX.2):  *Note Utility Limits::.

`int link (const char *OLDNAME, const char *NEWNAME)'
     `unistd.h' (POSIX.1):  *Note Hard Links::.

`int LINK_MAX'
     `limits.h' (POSIX.1):  *Note Limits for Files::.

`int lio_listio (int MODE, struct aiocb *const LIST[], int NENT, struct sigevent *SIG)'
     `aio.h' (POSIX.1b):  *Note Asynchronous Reads/Writes::.

`int lio_listio64 (int MODE, struct aiocb *const LIST, int NENT, struct sigevent *SIG)'
     `aio.h' (Unix98):  *Note Asynchronous Reads/Writes::.

`int listen (int SOCKET, int N)'
     `sys/socket.h' (BSD):  *Note Listening::.

`long long int llabs (long long int NUMBER)'
     `stdlib.h' (ISO):  *Note Absolute Value::.

`lldiv_t lldiv (long long int NUMERATOR, long long int DENOMINATOR)'
     `stdlib.h' (ISO):  *Note Integer Division::.

`lldiv_t'
     `stdlib.h' (ISO):  *Note Integer Division::.

`long long int llrint (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long long int llrintf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long long int llrintl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long long int llround (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long long int llroundf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long long int llroundl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`struct lconv * localeconv (void)'
     `locale.h' (ISO):  *Note The Lame Way to Locale Data::.

`struct tm * localtime (const time_t *TIME)'
     `time.h' (ISO):  *Note Broken-down Time::.

`struct tm * localtime_r (const time_t *TIME, struct tm *RESULTP)'
     `time.h' (POSIX.1c):  *Note Broken-down Time::.

`double log (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`double log10 (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float log10f (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double log10l (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`double log1p (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float log1pf (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double log1pl (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`double log2 (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float log2f (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double log2l (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`double logb (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float logbf (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double logbl (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float logf (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`void login (const struct utmp *ENTRY)'
     `utmp.h' (BSD):  *Note Logging In and Out::.

`LOGIN_PROCESS'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`LOGIN_PROCESS'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int login_tty (int FILEDES)'
     `utmp.h' (BSD):  *Note Logging In and Out::.

`long double logl (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`int logout (const char *UT_LINE)'
     `utmp.h' (BSD):  *Note Logging In and Out::.

`void logwtmp (const char *UT_LINE, const char *UT_NAME, const char *UT_HOST)'
     `utmp.h' (BSD):  *Note Logging In and Out::.

`void longjmp (jmp_buf STATE, int VALUE)'
     `setjmp.h' (ISO):  *Note Non-Local Details::.

`LONG_LONG_MAX'
     `limits.h' (GNU):  *Note Range of Type::.

`LONG_LONG_MIN'
     `limits.h' (GNU):  *Note Range of Type::.

`LONG_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`LONG_MIN'
     `limits.h' (ISO):  *Note Range of Type::.

`long int lrand48 (void)'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int lrand48_r (struct drand48_data *BUFFER, double *RESULT)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`long int lrint (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long int lrintf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long int lrintl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long int lround (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long int lroundf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long int lroundl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`void * lsearch (const void *KEY, void *BASE, size_t *NMEMB, size_t SIZE, comparison_fn_t COMPAR)'
     `search.h' (SVID):  *Note Array Search Function::.

`off_t lseek (int FILEDES, off_t OFFSET, int WHENCE)'
     `unistd.h' (POSIX.1):  *Note File Position Primitive::.

`off64_t lseek64 (int FILEDES, off64_t OFFSET, int WHENCE)'
     `unistd.h' (Unix98):  *Note File Position Primitive::.

`L_SET'
     `sys/file.h' (BSD):  *Note File Positioning::.

`int lstat (const char *FILENAME, struct stat *BUF)'
     `sys/stat.h' (BSD):  *Note Reading Attributes::.

`int lstat64 (const char *FILENAME, struct stat64 *BUF)'
     `sys/stat.h' (Unix98):  *Note Reading Attributes::.

`int L_tmpnam'
     `stdio.h' (ISO):  *Note Temporary Files::.

`int lutimes (const char *FILENAME, struct timeval TVP[2])'
     `sys/time.h' (BSD):  *Note File Times::.

`L_XTND'
     `sys/file.h' (BSD):  *Note File Positioning::.

`int madvise (void *ADDR, size_t LENGTH, int ADVICE)'
     `sys/mman.h' (POSIX):  *Note Memory-mapped I/O::.

`void makecontext (ucontext_t *UCP, void (*FUNC) (void), int ARGC, ...)'
     `ucontext.h' (SVID):  *Note System V contexts::.

`struct mallinfo mallinfo (void)'
     `malloc.h' (SVID):  *Note Statistics of Malloc::.

`void * malloc (size_t SIZE)'
     `malloc.h', `stdlib.h' (ISO):  *Note Basic Allocation::.

`__malloc_hook'
     `malloc.h' (GNU):  *Note Hooks for Malloc::.

`__malloc_initialize_hook'
     `malloc.h' (GNU):  *Note Hooks for Malloc::.

`int MAX_CANON'
     `limits.h' (POSIX.1):  *Note Limits for Files::.

`int MAX_INPUT'
     `limits.h' (POSIX.1):  *Note Limits for Files::.

`int MAXNAMLEN'
     `dirent.h' (BSD):  *Note Limits for Files::.

`int MAXSYMLINKS'
     `sys/param.h' (BSD):  *Note Symbolic Links::.

`int MB_CUR_MAX'
     `stdlib.h' (ISO):  *Note Selecting the Conversion::.

`int mblen (const char *STRING, size_t SIZE)'
     `stdlib.h' (ISO):  *Note Non-reentrant Character Conversion::.

`int MB_LEN_MAX'
     `limits.h' (ISO):  *Note Selecting the Conversion::.

`size_t mbrlen (const char *restrict S, size_t N, mbstate_t *PS)'
     `wchar.h' (ISO):  *Note Converting a Character::.

`size_t mbrtowc (wchar_t *restrict PWC, const char *restrict S, size_t N, mbstate_t *restrict PS)'
     `wchar.h' (ISO):  *Note Converting a Character::.

`int mbsinit (const mbstate_t *PS)'
     `wchar.h' (ISO):  *Note Keeping the state::.

`size_t mbsnrtowcs (wchar_t *restrict DST, const char **restrict SRC, size_t NMC, size_t LEN, mbstate_t *restrict PS)'
     `wchar.h' (GNU):  *Note Converting Strings::.

`size_t mbsrtowcs (wchar_t *restrict DST, const char **restrict SRC, size_t LEN, mbstate_t *restrict PS)'
     `wchar.h' (ISO):  *Note Converting Strings::.

`mbstate_t'
     `wchar.h' (ISO):  *Note Keeping the state::.

`size_t mbstowcs (wchar_t *WSTRING, const char *STRING, size_t SIZE)'
     `stdlib.h' (ISO):  *Note Non-reentrant String Conversion::.

`int mbtowc (wchar_t *restrict RESULT, const char *restrict STRING, size_t SIZE)'
     `stdlib.h' (ISO):  *Note Non-reentrant Character Conversion::.

`int mcheck (void (*ABORTFN) (enum mcheck_status STATUS))'
     `mcheck.h' (GNU):  *Note Heap Consistency Checking::.

`tcflag_t MDMBUF'
     `termios.h' (BSD):  *Note Control Modes::.

`void * memalign (size_t BOUNDARY, size_t SIZE)'
     `malloc.h' (BSD):  *Note Aligned Memory Blocks::.

`__memalign_hook'
     `malloc.h' (GNU):  *Note Hooks for Malloc::.

`void * memccpy (void *restrict TO, const void *restrict FROM, int C, size_t SIZE)'
     `string.h' (SVID):  *Note Copying and Concatenation::.

`void * memchr (const void *BLOCK, int C, size_t SIZE)'
     `string.h' (ISO):  *Note Search Functions::.

`int memcmp (const void *A1, const void *A2, size_t SIZE)'
     `string.h' (ISO):  *Note String/Array Comparison::.

`void * memcpy (void *restrict TO, const void *restrict FROM, size_t SIZE)'
     `string.h' (ISO):  *Note Copying and Concatenation::.

`void * memfrob (void *MEM, size_t LENGTH)'
     `string.h' (GNU):  *Note Trivial Encryption::.

`void * memmem (const void *HAYSTACK, size_t HAYSTACK-LEN,
     const void *NEEDLE, size_t NEEDLE-LEN)'
     `string.h' (GNU):  *Note Search Functions::.

`void * memmove (void *TO, const void *FROM, size_t SIZE)'
     `string.h' (ISO):  *Note Copying and Concatenation::.

`void * mempcpy (void *restrict TO, const void *restrict FROM, size_t SIZE)'
     `string.h' (GNU):  *Note Copying and Concatenation::.

`void * memrchr (const void *BLOCK, int C, size_t SIZE)'
     `string.h' (GNU):  *Note Search Functions::.

`void * memset (void *BLOCK, int C, size_t SIZE)'
     `string.h' (ISO):  *Note Copying and Concatenation::.

`int mkdir (const char *FILENAME, mode_t MODE)'
     `sys/stat.h' (POSIX.1):  *Note Creating Directories::.

`char * mkdtemp (char *TEMPLATE)'
     `stdlib.h' (BSD):  *Note Temporary Files::.

`int mkfifo (const char *FILENAME, mode_t MODE)'
     `sys/stat.h' (POSIX.1):  *Note FIFO Special Files::.

`int mknod (const char *FILENAME, int MODE, int DEV)'
     `sys/stat.h' (BSD):  *Note Making Special Files::.

`int mkstemp (char *TEMPLATE)'
     `stdlib.h' (BSD):  *Note Temporary Files::.

`char * mktemp (char *TEMPLATE)'
     `stdlib.h' (Unix):  *Note Temporary Files::.

`time_t mktime (struct tm *BROKENTIME)'
     `time.h' (ISO):  *Note Broken-down Time::.

`int mlock (const void *ADDR, size_t LEN)'
     `sys/mman.h' (POSIX.1b):  *Note Page Lock Functions::.

`int mlockall (int FLAGS)'
     `sys/mman.h' (POSIX.1b):  *Note Page Lock Functions::.

`void * mmap (void *ADDRESS, size_t LENGTH,int PROTECT, int FLAGS, int FILEDES, off_t OFFSET)'
     `sys/mman.h' (POSIX):  *Note Memory-mapped I/O::.

`void * mmap64 (void *ADDRESS, size_t LENGTH,int PROTECT, int FLAGS, int FILEDES, off64_t OFFSET)'
     `sys/mman.h' (LFS):  *Note Memory-mapped I/O::.

`mode_t'
     `sys/types.h' (POSIX.1):  *Note Attribute Meanings::.

`double modf (double VALUE, double *INTEGER-PART)'
     `math.h' (ISO):  *Note Rounding Functions::.

`float modff (float VALUE, float *INTEGER-PART)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long double modfl (long double VALUE, long double *INTEGER-PART)'
     `math.h' (ISO):  *Note Rounding Functions::.

`int mount (const char *SPECIAL_FILE, const char *DIR, const char *FSTYPE, unsigned long int OPTIONS, const void *DATA)'
     `sys/mount.h' (SVID, BSD):  *Note Mount-Unmount-Remount::.

`long int mrand48 (void)'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int mrand48_r (struct drand48_data *BUFFER, double *RESULT)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`void * mremap (void *ADDRESS, size_t LENGTH, size_t NEW_LENGTH, int FLAG)'
     `sys/mman.h' (GNU):  *Note Memory-mapped I/O::.

`int MSG_DONTROUTE'
     `sys/socket.h' (BSD):  *Note Socket Data Options::.

`int MSG_OOB'
     `sys/socket.h' (BSD):  *Note Socket Data Options::.

`int MSG_PEEK'
     `sys/socket.h' (BSD):  *Note Socket Data Options::.

`int msync (void *ADDRESS, size_t LENGTH, int FLAGS)'
     `sys/mman.h' (POSIX):  *Note Memory-mapped I/O::.

`void mtrace (void)'
     `mcheck.h' (GNU):  *Note Tracing malloc::.

`int munlock (const void *ADDR, size_t LEN)'
     `sys/mman.h' (POSIX.1b):  *Note Page Lock Functions::.

`int munlockall (void)'
     `sys/mman.h' (POSIX.1b):  *Note Page Lock Functions::.

`int munmap (void *ADDR, size_t LENGTH)'
     `sys/mman.h' (POSIX):  *Note Memory-mapped I/O::.

`void muntrace (void)'
     `mcheck.h' (GNU):  *Note Tracing malloc::.

`int NAME_MAX'
     `limits.h' (POSIX.1):  *Note Limits for Files::.

`float NAN'
     `math.h' (GNU):  *Note Infinity and NaN::.

`double nan (const char *TAGP)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`float nanf (const char *TAGP)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`long double nanl (const char *TAGP)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`int nanosleep (const struct timespec *REQUESTED_TIME, struct timespec *REMAINING)'
     `time.h' (POSIX.1):  *Note Sleeping::.

`int NCCS'
     `termios.h' (POSIX.1):  *Note Mode Data Types::.

`double nearbyint (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`float nearbyintf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long double nearbyintl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`NEW_TIME'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`NEW_TIME'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`double nextafter (double X, double Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`float nextafterf (float X, float Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`long double nextafterl (long double X, long double Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`double nexttoward (double X, long double Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`float nexttowardf (float X, long double Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`long double nexttowardl (long double X, long double Y)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`int nftw (const char *FILENAME, __nftw_func_t FUNC, int DESCRIPTORS, int FLAG)'
     `ftw.h' (XPG4.2):  *Note Working with Directory Trees::.

`int nftw64 (const char *FILENAME, __nftw64_func_t FUNC, int DESCRIPTORS, int FLAG)'
     `ftw.h' (Unix98):  *Note Working with Directory Trees::.

`__nftw64_func_t'
     `ftw.h' (GNU):  *Note Working with Directory Trees::.

`__nftw_func_t'
     `ftw.h' (GNU):  *Note Working with Directory Trees::.

`char * ngettext (const char *MSGID1, const char *MSGID2, unsigned long int N)'
     `libintl.h' (GNU):  *Note Advanced gettext functions::.

`int NGROUPS_MAX'
     `limits.h' (POSIX.1):  *Note General Limits::.

`int nice (int INCREMENT)'
     `unistd.h' (BSD):  *Note Traditional Scheduling Functions::.

`nlink_t'
     `sys/types.h' (POSIX.1):  *Note Attribute Meanings::.

`char * nl_langinfo (nl_item ITEM)'
     `langinfo.h' (XOPEN):  *Note The Elegant and Fast Way::.

`NO_ADDRESS'
     `netdb.h' (BSD):  *Note Host Names::.

`tcflag_t NOFLSH'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`tcflag_t NOKERNINFO'
     `termios.h' (BSD):  *Note Local Modes::.

`NO_RECOVERY'
     `netdb.h' (BSD):  *Note Host Names::.

`long int nrand48 (unsigned short int XSUBI[3])'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int nrand48_r (unsigned short int XSUBI[3], struct drand48_data *BUFFER, long int *RESULT)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`int NSIG'
     `signal.h' (BSD):  *Note Standard Signals::.

`uint32_t ntohl (uint32_t NETLONG)'
     `netinet/in.h' (BSD):  *Note Byte Order::.

`uint16_t ntohs (uint16_t NETSHORT)'
     `netinet/in.h' (BSD):  *Note Byte Order::.

`int ntp_adjtime (struct timex *TPTR)'
     `sys/timex.h' (GNU):  *Note High Accuracy Clock::.

`int ntp_gettime (struct ntptimeval *TPTR)'
     `sys/timex.h' (GNU):  *Note High Accuracy Clock::.

`void * NULL'
     `stddef.h' (ISO):  *Note Null Pointer Constant::.

`int O_ACCMODE'
     `fcntl.h' (POSIX.1):  *Note Access Modes::.

`int O_APPEND'
     `fcntl.h' (POSIX.1):  *Note Operating Modes::.

`int O_ASYNC'
     `fcntl.h' (BSD):  *Note Operating Modes::.

`void obstack_1grow (struct obstack *OBSTACK-PTR, char C)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`void obstack_1grow_fast (struct obstack *OBSTACK-PTR, char C)'
     `obstack.h' (GNU):  *Note Extra Fast Growing::.

`int obstack_alignment_mask (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Obstacks Data Alignment::.

`void * obstack_alloc (struct obstack *OBSTACK-PTR, int SIZE)'
     `obstack.h' (GNU):  *Note Allocation in an Obstack::.

`obstack_alloc_failed_handler'
     `obstack.h' (GNU):  *Note Preparing for Obstacks::.

`void * obstack_base (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Status of an Obstack::.

`void obstack_blank (struct obstack *OBSTACK-PTR, int SIZE)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`void obstack_blank_fast (struct obstack *OBSTACK-PTR, int SIZE)'
     `obstack.h' (GNU):  *Note Extra Fast Growing::.

`int obstack_chunk_size (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Obstack Chunks::.

`void * obstack_copy (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)'
     `obstack.h' (GNU):  *Note Allocation in an Obstack::.

`void * obstack_copy0 (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)'
     `obstack.h' (GNU):  *Note Allocation in an Obstack::.

`void * obstack_finish (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`void obstack_free (struct obstack *OBSTACK-PTR, void *OBJECT)'
     `obstack.h' (GNU):  *Note Freeing Obstack Objects::.

`void obstack_grow (struct obstack *OBSTACK-PTR, void *DATA, int SIZE)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`void obstack_grow0 (struct obstack *OBSTACK-PTR, void *DATA, int SIZE)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`int obstack_init (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Preparing for Obstacks::.

`void obstack_int_grow (struct obstack *OBSTACK-PTR, int DATA)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`void obstack_int_grow_fast (struct obstack *OBSTACK-PTR, int DATA)'
     `obstack.h' (GNU):  *Note Extra Fast Growing::.

`void * obstack_next_free (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Status of an Obstack::.

`int obstack_object_size (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`int obstack_object_size (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Status of an Obstack::.

`int obstack_printf (struct obstack *OBSTACK, const char *TEMPLATE, ...)'
     `stdio.h' (GNU):  *Note Dynamic Output::.

`void obstack_ptr_grow (struct obstack *OBSTACK-PTR, void *DATA)'
     `obstack.h' (GNU):  *Note Growing Objects::.

`void obstack_ptr_grow_fast (struct obstack *OBSTACK-PTR, void *DATA)'
     `obstack.h' (GNU):  *Note Extra Fast Growing::.

`int obstack_room (struct obstack *OBSTACK-PTR)'
     `obstack.h' (GNU):  *Note Extra Fast Growing::.

`int obstack_vprintf (struct obstack *OBSTACK, const char *TEMPLATE, va_list AP)'
     `stdio.h' (GNU):  *Note Variable Arguments Output::.

`int O_CREAT'
     `fcntl.h' (POSIX.1):  *Note Open-time Flags::.

`int O_EXCL'
     `fcntl.h' (POSIX.1):  *Note Open-time Flags::.

`int O_EXEC'
     `fcntl.h' (GNU):  *Note Access Modes::.

`int O_EXLOCK'
     `fcntl.h' (BSD):  *Note Open-time Flags::.

`off64_t'
     `sys/types.h' (Unix98):  *Note File Position Primitive::.

`size_t offsetof (TYPE, MEMBER)'
     `stddef.h' (ISO):  *Note Structure Measurement::.

`off_t'
     `sys/types.h' (POSIX.1):  *Note File Position Primitive::.

`int O_FSYNC'
     `fcntl.h' (BSD):  *Note Operating Modes::.

`int O_IGNORE_CTTY'
     `fcntl.h' (GNU):  *Note Open-time Flags::.

`OLD_TIME'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`OLD_TIME'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int O_NDELAY'
     `fcntl.h' (BSD):  *Note Operating Modes::.

`int on_exit (void (*FUNCTION)(int STATUS, void *ARG), void *ARG)'
     `stdlib.h' (SunOS):  *Note Cleanups on Exit::.

`tcflag_t ONLCR'
     `termios.h' (BSD):  *Note Output Modes::.

`int O_NOATIME'
     `fcntl.h' (GNU):  *Note Operating Modes::.

`int O_NOCTTY'
     `fcntl.h' (POSIX.1):  *Note Open-time Flags::.

`tcflag_t ONOEOT'
     `termios.h' (BSD):  *Note Output Modes::.

`int O_NOLINK'
     `fcntl.h' (GNU):  *Note Open-time Flags::.

`int O_NONBLOCK'
     `fcntl.h' (POSIX.1):  *Note Open-time Flags::.

`int O_NONBLOCK'
     `fcntl.h' (POSIX.1):  *Note Operating Modes::.

`int O_NOTRANS'
     `fcntl.h' (GNU):  *Note Open-time Flags::.

`int open (const char *FILENAME, int FLAGS[, mode_t MODE])'
     `fcntl.h' (POSIX.1):  *Note Opening and Closing Files::.

`int open64 (const char *FILENAME, int FLAGS[, mode_t MODE])'
     `fcntl.h' (Unix98):  *Note Opening and Closing Files::.

`DIR * opendir (const char *DIRNAME)'
     `dirent.h' (POSIX.1):  *Note Opening a Directory::.

`void openlog (const char *IDENT, int OPTION, int FACILITY)'
     `syslog.h' (BSD):  *Note openlog::.

`int OPEN_MAX'
     `limits.h' (POSIX.1):  *Note General Limits::.

`FILE * open_memstream (char **PTR, size_t *SIZELOC)'
     `stdio.h' (GNU):  *Note String Streams::.

`FILE * open_obstack_stream (struct obstack *OBSTACK)'
     `stdio.h' (GNU):  *Note Obstack Streams::.

`int openpty (int *AMASTER, int *ASLAVE, char *NAME, const struct termios *TERMP, const struct winsize *WINP)'
     `pty.h' (BSD):  *Note Pseudo-Terminal Pairs::.

`tcflag_t OPOST'
     `termios.h' (POSIX.1):  *Note Output Modes::.

`char * optarg'
     `unistd.h' (POSIX.2):  *Note Using Getopt::.

`int opterr'
     `unistd.h' (POSIX.2):  *Note Using Getopt::.

`int optind'
     `unistd.h' (POSIX.2):  *Note Using Getopt::.

`OPTION_ALIAS'
     `argp.h' (GNU):  *Note Argp Option Flags::.

`OPTION_ARG_OPTIONAL'
     `argp.h' (GNU):  *Note Argp Option Flags::.

`OPTION_DOC'
     `argp.h' (GNU):  *Note Argp Option Flags::.

`OPTION_HIDDEN'
     `argp.h' (GNU):  *Note Argp Option Flags::.

`OPTION_NO_USAGE'
     `argp.h' (GNU):  *Note Argp Option Flags::.

`int optopt'
     `unistd.h' (POSIX.2):  *Note Using Getopt::.

`int O_RDONLY'
     `fcntl.h' (POSIX.1):  *Note Access Modes::.

`int O_RDWR'
     `fcntl.h' (POSIX.1):  *Note Access Modes::.

`int O_READ'
     `fcntl.h' (GNU):  *Note Access Modes::.

`int O_SHLOCK'
     `fcntl.h' (BSD):  *Note Open-time Flags::.

`int O_SYNC'
     `fcntl.h' (BSD):  *Note Operating Modes::.

`int O_TRUNC'
     `fcntl.h' (POSIX.1):  *Note Open-time Flags::.

`int O_WRITE'
     `fcntl.h' (GNU):  *Note Access Modes::.

`int O_WRONLY'
     `fcntl.h' (POSIX.1):  *Note Access Modes::.

`tcflag_t OXTABS'
     `termios.h' (BSD):  *Note Output Modes::.

`PA_CHAR'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_DOUBLE'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_FLAG_LONG'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_FLAG_LONG_DOUBLE'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_FLAG_LONG_LONG'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`int PA_FLAG_MASK'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_FLAG_PTR'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_FLAG_SHORT'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_FLOAT'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_INT'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_LAST'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_POINTER'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`tcflag_t PARENB'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`tcflag_t PARMRK'
     `termios.h' (POSIX.1):  *Note Input Modes::.

`tcflag_t PARODD'
     `termios.h' (POSIX.1):  *Note Control Modes::.

`size_t parse_printf_format (const char *TEMPLATE, size_t N, int *ARGTYPES)'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`PA_STRING'
     `printf.h' (GNU):  *Note Parsing a Template String::.

`long int pathconf (const char *FILENAME, int PARAMETER)'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`int PATH_MAX'
     `limits.h' (POSIX.1):  *Note Limits for Files::.

`int pause ()'
     `unistd.h' (POSIX.1):  *Note Using Pause::.

`_PC_ASYNC_IO'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_CHOWN_RESTRICTED'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_FILESIZEBITS'
     `unistd.h' (LFS):  *Note Pathconf::.

`_PC_LINK_MAX'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`int pclose (FILE *STREAM)'
     `stdio.h' (POSIX.2, SVID, BSD):  *Note Pipe to a Subprocess::.

`_PC_MAX_CANON'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_MAX_INPUT'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_NAME_MAX'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_NO_TRUNC'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_PATH_MAX'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_PIPE_BUF'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_PRIO_IO'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_REC_INCR_XFER_SIZE'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_REC_MAX_XFER_SIZE'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_REC_MIN_XFER_SIZE'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_REC_XFER_ALIGN'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_SYNC_IO'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`_PC_VDISABLE'
     `unistd.h' (POSIX.1):  *Note Pathconf::.

`tcflag_t PENDIN'
     `termios.h' (BSD):  *Note Local Modes::.

`void perror (const char *MESSAGE)'
     `stdio.h' (ISO):  *Note Error Messages::.

`int PF_FILE'
     `sys/socket.h' (GNU):  *Note Local Namespace Details::.

`int PF_INET'
     `sys/socket.h' (BSD):  *Note Internet Namespace::.

`int PF_INET6'
     `sys/socket.h' (X/Open):  *Note Internet Namespace::.

`int PF_LOCAL'
     `sys/socket.h' (POSIX):  *Note Local Namespace Details::.

`int PF_UNIX'
     `sys/socket.h' (BSD):  *Note Local Namespace Details::.

`pid_t'
     `sys/types.h' (POSIX.1):  *Note Process Identification::.

`int pipe (int FILEDES[2])'
     `unistd.h' (POSIX.1):  *Note Creating a Pipe::.

`int PIPE_BUF'
     `limits.h' (POSIX.1):  *Note Limits for Files::.

`FILE * popen (const char *COMMAND, const char *MODE)'
     `stdio.h' (POSIX.2, SVID, BSD):  *Note Pipe to a Subprocess::.

`_POSIX2_BC_BASE_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`_POSIX2_BC_DIM_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`_POSIX2_BC_SCALE_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`_POSIX2_BC_STRING_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`int _POSIX2_C_DEV'
     `unistd.h' (POSIX.2):  *Note System Options::.

`_POSIX2_COLL_WEIGHTS_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`long int _POSIX2_C_VERSION'
     `unistd.h' (POSIX.2):  *Note Version Supported::.

`_POSIX2_EQUIV_CLASS_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`_POSIX2_EXPR_NEST_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`int _POSIX2_FORT_DEV'
     `unistd.h' (POSIX.2):  *Note System Options::.

`int _POSIX2_FORT_RUN'
     `unistd.h' (POSIX.2):  *Note System Options::.

`_POSIX2_LINE_MAX'
     `limits.h' (POSIX.2):  *Note Utility Minimums::.

`int _POSIX2_LOCALEDEF'
     `unistd.h' (POSIX.2):  *Note System Options::.

`_POSIX2_RE_DUP_MAX'
     `limits.h' (POSIX.2):  *Note Minimums::.

`int _POSIX2_SW_DEV'
     `unistd.h' (POSIX.2):  *Note System Options::.

`_POSIX_AIO_LISTIO_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`_POSIX_AIO_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`_POSIX_ARG_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`_POSIX_CHILD_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`int _POSIX_CHOWN_RESTRICTED'
     `unistd.h' (POSIX.1):  *Note Options for Files::.

`_POSIX_C_SOURCE'
     (POSIX.2):  *Note Feature Test Macros::.

`int _POSIX_JOB_CONTROL'
     `unistd.h' (POSIX.1):  *Note System Options::.

`_POSIX_LINK_MAX'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`_POSIX_MAX_CANON'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`_POSIX_MAX_INPUT'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`int posix_memalign (void **MEMPTR, size_t ALIGNMENT, size_t SIZE)'
     `stdlib.h' (POSIX):  *Note Aligned Memory Blocks::.

`_POSIX_NAME_MAX'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`_POSIX_NGROUPS_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`int _POSIX_NO_TRUNC'
     `unistd.h' (POSIX.1):  *Note Options for Files::.

`_POSIX_OPEN_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`_POSIX_PATH_MAX'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`_POSIX_PIPE_BUF'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`POSIX_REC_INCR_XFER_SIZE'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`POSIX_REC_MAX_XFER_SIZE'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`POSIX_REC_MIN_XFER_SIZE'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`POSIX_REC_XFER_ALIGN'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`int _POSIX_SAVED_IDS'
     `unistd.h' (POSIX.1):  *Note System Options::.

`_POSIX_SOURCE'
     (POSIX.1):  *Note Feature Test Macros::.

`_POSIX_SSIZE_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`_POSIX_STREAM_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`_POSIX_TZNAME_MAX'
     `limits.h' (POSIX.1):  *Note Minimums::.

`unsigned char _POSIX_VDISABLE'
     `unistd.h' (POSIX.1):  *Note Options for Files::.

`long int _POSIX_VERSION'
     `unistd.h' (POSIX.1):  *Note Version Supported::.

`double pow (double BASE, double POWER)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`double pow10 (double X)'
     `math.h' (GNU):  *Note Exponents and Logarithms::.

`float pow10f (float X)'
     `math.h' (GNU):  *Note Exponents and Logarithms::.

`long double pow10l (long double X)'
     `math.h' (GNU):  *Note Exponents and Logarithms::.

`float powf (float BASE, float POWER)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double powl (long double BASE, long double POWER)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`ssize_t pread (int FILEDES, void *BUFFER, size_t SIZE, off_t OFFSET)'
     `unistd.h' (Unix98):  *Note I/O Primitives::.

`ssize_t pread64 (int FILEDES, void *BUFFER, size_t SIZE, off64_t OFFSET)'
     `unistd.h' (Unix98):  *Note I/O Primitives::.

`int printf (const char *TEMPLATE, ...)'
     `stdio.h' (ISO):  *Note Formatted Output Functions::.

`printf_arginfo_function'
     `printf.h' (GNU):  *Note Defining the Output Handler::.

`printf_function'
     `printf.h' (GNU):  *Note Defining the Output Handler::.

`int printf_size (FILE *FP, const struct printf_info *INFO, const void *const *ARGS)'
     `printf.h' (GNU):  *Note Predefined Printf Handlers::.

`int printf_size_info (const struct printf_info *INFO, size_t N, int *ARGTYPES)'
     `printf.h' (GNU):  *Note Predefined Printf Handlers::.

`PRIO_MAX'
     `sys/resource.h' (BSD):  *Note Traditional Scheduling Functions::.

`PRIO_MIN'
     `sys/resource.h' (BSD):  *Note Traditional Scheduling Functions::.

`PRIO_PGRP'
     `sys/resource.h' (BSD):  *Note Traditional Scheduling Functions::.

`PRIO_PROCESS'
     `sys/resource.h' (BSD):  *Note Traditional Scheduling Functions::.

`PRIO_USER'
     `sys/resource.h' (BSD):  *Note Traditional Scheduling Functions::.

`char * program_invocation_name'
     `errno.h' (GNU):  *Note Error Messages::.

`char * program_invocation_short_name'
     `errno.h' (GNU):  *Note Error Messages::.

`void psignal (int SIGNUM, const char *MESSAGE)'
     `signal.h' (BSD):  *Note Signal Messages::.

`char * P_tmpdir'
     `stdio.h' (SVID):  *Note Temporary Files::.

`ptrdiff_t'
     `stddef.h' (ISO):  *Note Important Data Types::.

`char * ptsname (int FILEDES)'
     `stdlib.h' (SVID, XPG4.2):  *Note Allocation::.

`int ptsname_r (int FILEDES, char *BUF, size_t LEN)'
     `stdlib.h' (GNU):  *Note Allocation::.

`int putc (int C, FILE *STREAM)'
     `stdio.h' (ISO):  *Note Simple Output::.

`int putchar (int C)'
     `stdio.h' (ISO):  *Note Simple Output::.

`int putchar_unlocked (int C)'
     `stdio.h' (POSIX):  *Note Simple Output::.

`int putc_unlocked (int C, FILE *STREAM)'
     `stdio.h' (POSIX):  *Note Simple Output::.

`int putenv (char *STRING)'
     `stdlib.h' (SVID):  *Note Environment Access::.

`int putpwent (const struct passwd *P, FILE *STREAM)'
     `pwd.h' (SVID):  *Note Writing a User Entry::.

`int puts (const char *S)'
     `stdio.h' (ISO):  *Note Simple Output::.

`struct utmp * pututline (const struct utmp *UTMP)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`struct utmpx * pututxline (const struct utmpx *UTMP)'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int putw (int W, FILE *STREAM)'
     `stdio.h' (SVID):  *Note Simple Output::.

`wint_t putwc (wchar_t WC, FILE *STREAM)'
     `wchar.h' (ISO):  *Note Simple Output::.

`wint_t putwchar (wchar_t WC)'
     `wchar.h' (ISO):  *Note Simple Output::.

`wint_t putwchar_unlocked (wchar_t WC)'
     `wchar.h' (GNU):  *Note Simple Output::.

`wint_t putwc_unlocked (wchar_t WC, FILE *STREAM)'
     `wchar.h' (GNU):  *Note Simple Output::.

`ssize_t pwrite (int FILEDES, const void *BUFFER, size_t SIZE, off_t OFFSET)'
     `unistd.h' (Unix98):  *Note I/O Primitives::.

`ssize_t pwrite64 (int FILEDES, const void *BUFFER, size_t SIZE, off64_t OFFSET)'
     `unistd.h' (Unix98):  *Note I/O Primitives::.

`char * qecvt (long double VALUE, int NDIGIT, int *DECPT, int *NEG)'
     `stdlib.h' (GNU):  *Note System V Number Conversion::.

`int qecvt_r (long double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)'
     `stdlib.h' (GNU):  *Note System V Number Conversion::.

`char * qfcvt (long double VALUE, int NDIGIT, int *DECPT, int *NEG)'
     `stdlib.h' (GNU):  *Note System V Number Conversion::.

`int qfcvt_r (long double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)'
     `stdlib.h' (GNU):  *Note System V Number Conversion::.

`char * qgcvt (long double VALUE, int NDIGIT, char *BUF)'
     `stdlib.h' (GNU):  *Note System V Number Conversion::.

`void qsort (void *ARRAY, size_t COUNT, size_t SIZE, comparison_fn_t COMPARE)'
     `stdlib.h' (ISO):  *Note Array Sort Function::.

`int raise (int SIGNUM)'
     `signal.h' (ISO):  *Note Signaling Yourself::.

`int rand (void)'
     `stdlib.h' (ISO):  *Note ISO Random::.

`int RAND_MAX'
     `stdlib.h' (ISO):  *Note ISO Random::.

`long int random (void)'
     `stdlib.h' (BSD):  *Note BSD Random::.

`int random_r (struct random_data *restrict BUF, int32_t *restrict RESULT)'
     `stdlib.h' (GNU):  *Note BSD Random::.

`int rand_r (unsigned int *SEED)'
     `stdlib.h' (POSIX.1):  *Note ISO Random::.

`void * rawmemchr (const void *BLOCK, int C)'
     `string.h' (GNU):  *Note Search Functions::.

`ssize_t read (int FILEDES, void *BUFFER, size_t SIZE)'
     `unistd.h' (POSIX.1):  *Note I/O Primitives::.

`struct dirent * readdir (DIR *DIRSTREAM)'
     `dirent.h' (POSIX.1):  *Note Reading/Closing Directory::.

`struct dirent64 * readdir64 (DIR *DIRSTREAM)'
     `dirent.h' (LFS):  *Note Reading/Closing Directory::.

`int readdir64_r (DIR *DIRSTREAM, struct dirent64 *ENTRY, struct dirent64 **RESULT)'
     `dirent.h' (LFS):  *Note Reading/Closing Directory::.

`int readdir_r (DIR *DIRSTREAM, struct dirent *ENTRY, struct dirent **RESULT)'
     `dirent.h' (GNU):  *Note Reading/Closing Directory::.

`int readlink (const char *FILENAME, char *BUFFER, size_t SIZE)'
     `unistd.h' (BSD):  *Note Symbolic Links::.

`ssize_t readv (int FILEDES, const struct iovec *VECTOR, int COUNT)'
     `sys/uio.h' (BSD):  *Note Scatter-Gather::.

`void * realloc (void *PTR, size_t NEWSIZE)'
     `malloc.h', `stdlib.h' (ISO):  *Note Changing Block Size::.

`__realloc_hook'
     `malloc.h' (GNU):  *Note Hooks for Malloc::.

`char * realpath (const char *restrict NAME, char *restrict RESOLVED)'
     `stdlib.h' (XPG):  *Note Symbolic Links::.

`int recv (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS)'
     `sys/socket.h' (BSD):  *Note Receiving Data::.

`int recvfrom (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)'
     `sys/socket.h' (BSD):  *Note Receiving Datagrams::.

`int recvmsg (int SOCKET, struct msghdr *MESSAGE, int FLAGS)'
     `sys/socket.h' (BSD):  *Note Receiving Datagrams::.

`int RE_DUP_MAX'
     `limits.h' (POSIX.2):  *Note General Limits::.

`_REENTRANT'
     (GNU):  *Note Feature Test Macros::.

`REG_BADBR'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_BADPAT'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_BADRPT'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`int regcomp (regex_t *restrict COMPILED, const char *restrict PATTERN, int CFLAGS)'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_EBRACE'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_EBRACK'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_ECOLLATE'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_ECTYPE'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_EESCAPE'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_EPAREN'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_ERANGE'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`size_t regerror (int ERRCODE, const regex_t *restrict COMPILED, char *restrict BUFFER, size_t LENGTH)'
     `regex.h' (POSIX.2):  *Note Regexp Cleanup::.

`REG_ESPACE'
     `regex.h' (POSIX.2):  *Note Matching POSIX Regexps::.

`REG_ESPACE'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_ESUBREG'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`int regexec (const regex_t *restrict COMPILED, const char *restrict STRING, size_t NMATCH, regmatch_t MATCHPTR[restrict], int EFLAGS)'
     `regex.h' (POSIX.2):  *Note Matching POSIX Regexps::.

`regex_t'
     `regex.h' (POSIX.2):  *Note POSIX Regexp Compilation::.

`REG_EXTENDED'
     `regex.h' (POSIX.2):  *Note Flags for POSIX Regexps::.

`void regfree (regex_t *COMPILED)'
     `regex.h' (POSIX.2):  *Note Regexp Cleanup::.

`REG_ICASE'
     `regex.h' (POSIX.2):  *Note Flags for POSIX Regexps::.

`int register_printf_function (int SPEC, printf_function HANDLER-FUNCTION, printf_arginfo_function ARGINFO-FUNCTION)'
     `printf.h' (GNU):  *Note Registering New Conversions::.

`regmatch_t'
     `regex.h' (POSIX.2):  *Note Regexp Subexpressions::.

`REG_NEWLINE'
     `regex.h' (POSIX.2):  *Note Flags for POSIX Regexps::.

`REG_NOMATCH'
     `regex.h' (POSIX.2):  *Note Matching POSIX Regexps::.

`REG_NOSUB'
     `regex.h' (POSIX.2):  *Note Flags for POSIX Regexps::.

`REG_NOTBOL'
     `regex.h' (POSIX.2):  *Note Matching POSIX Regexps::.

`REG_NOTEOL'
     `regex.h' (POSIX.2):  *Note Matching POSIX Regexps::.

`regoff_t'
     `regex.h' (POSIX.2):  *Note Regexp Subexpressions::.

`double remainder (double NUMERATOR, double DENOMINATOR)'
     `math.h' (BSD):  *Note Remainder Functions::.

`float remainderf (float NUMERATOR, float DENOMINATOR)'
     `math.h' (BSD):  *Note Remainder Functions::.

`long double remainderl (long double NUMERATOR, long double DENOMINATOR)'
     `math.h' (BSD):  *Note Remainder Functions::.

`int remove (const char *FILENAME)'
     `stdio.h' (ISO):  *Note Deleting Files::.

`int rename (const char *OLDNAME, const char *NEWNAME)'
     `stdio.h' (ISO):  *Note Renaming Files::.

`void rewind (FILE *STREAM)'
     `stdio.h' (ISO):  *Note File Positioning::.

`void rewinddir (DIR *DIRSTREAM)'
     `dirent.h' (POSIX.1):  *Note Random Access Directory::.

`char * rindex (const char *STRING, int C)'
     `string.h' (BSD):  *Note Search Functions::.

`double rint (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`float rintf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long double rintl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`int RLIM_INFINITY'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_AS'
     `sys/resource.h' (Unix98):  *Note Limits on Resources::.

`RLIMIT_CORE'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_CPU'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_DATA'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_FSIZE'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_MEMLOCK'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_NOFILE'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_NPROC'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_RSS'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIMIT_STACK'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`RLIM_NLIMITS'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`int rmdir (const char *FILENAME)'
     `unistd.h' (POSIX.1):  *Note Deleting Files::.

`int R_OK'
     `unistd.h' (POSIX.1):  *Note Testing File Access::.

`double round (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`float roundf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long double roundl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`int rpmatch (const char *RESPONSE)'
     `stdlib.h' (stdlib.h):  *Note Yes-or-No Questions::.

`RUN_LVL'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`RUN_LVL'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`RUSAGE_CHILDREN'
     `sys/resource.h' (BSD):  *Note Resource Usage::.

`RUSAGE_SELF'
     `sys/resource.h' (BSD):  *Note Resource Usage::.

`int SA_NOCLDSTOP'
     `signal.h' (POSIX.1):  *Note Flags for Sigaction::.

`int SA_ONSTACK'
     `signal.h' (BSD):  *Note Flags for Sigaction::.

`int SA_RESTART'
     `signal.h' (BSD):  *Note Flags for Sigaction::.

`void *sbrk (ptrdiff_t DELTA)'
     `unistd.h' (BSD):  *Note Resizing the Data Segment::.

`_SC_2_C_DEV'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_2_FORT_DEV'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_2_FORT_RUN'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_2_LOCALEDEF'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_2_SW_DEV'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_2_VERSION'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_AIO_LISTIO_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_AIO_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_AIO_PRIO_DELTA_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`double scalb (double VALUE, int EXPONENT)'
     `math.h' (BSD):  *Note Normalization Functions::.

`float scalbf (float VALUE, int EXPONENT)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long double scalbl (long double VALUE, int EXPONENT)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int scalbln (double X, long int n)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int scalblnf (float X, long int n)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int scalblnl (long double X, long int n)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int scalbn (double X, int n)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int scalbnf (float X, int n)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int scalbnl (long double X, int n)'
     `math.h' (BSD):  *Note Normalization Functions::.

`int scandir (const char *DIR, struct dirent ***NAMELIST, int (*SELECTOR) (const struct dirent *), int (*CMP) (const void *, const void *))'
     `dirent.h' (BSD/SVID):  *Note Scanning Directory Content::.

`int scandir64 (const char *DIR, struct dirent64 ***NAMELIST, int (*SELECTOR) (const struct dirent64 *), int (*CMP) (const void *, const void *))'
     `dirent.h' (GNU):  *Note Scanning Directory Content::.

`int scanf (const char *TEMPLATE, ...)'
     `stdio.h' (ISO):  *Note Formatted Input Functions::.

`_SC_ARG_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_ASYNCHRONOUS_IO'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_ATEXIT_MAX'
     `unistd.h' (GNU):  *Note Constants for Sysconf::.

`_SC_AVPHYS_PAGES'
     `unistd.h' (GNU):  *Note Constants for Sysconf::.

`_SC_BC_BASE_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_BC_DIM_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_BC_SCALE_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_BC_STRING_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_CHAR_BIT'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_CHARCLASS_NAME_MAX'
     `unistd.h' (GNU):  *Note Constants for Sysconf::.

`_SC_CHAR_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_CHAR_MIN'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_CHILD_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_CLK_TCK'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_COLL_WEIGHTS_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_DELAYTIMER_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_EQUIV_CLASS_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_EXPR_NEST_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_FSYNC'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_GETGR_R_SIZE_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_GETPW_R_SIZE_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`SCHAR_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`SCHAR_MIN'
     `limits.h' (ISO):  *Note Range of Type::.

`int sched_getaffinity (pid_t PID, size_t CPUSETSIZE, cpu_set_t *CPUSET)'
     `sched.h' (GNU):  *Note CPU Affinity::.

`int sched_getparam (pid_t PID, const struct sched_param *PARAM)'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`int sched_get_priority_max (int *POLICY);'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`int sched_get_priority_min (int *POLICY);'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`int sched_getscheduler (pid_t PID)'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`int sched_rr_get_interval (pid_t PID, struct timespec *INTERVAL)'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`int sched_setaffinity (pid_t PID, size_t CPUSETSIZE, const cpu_set_t *CPUSET)'
     `sched.h' (GNU):  *Note CPU Affinity::.

`int sched_setparam (pid_t PID, const struct sched_param *PARAM)'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`int sched_setscheduler (pid_t PID, int POLICY, const struct sched_param *PARAM)'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`int sched_yield (void)'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`_SC_INT_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_INT_MIN'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_JOB_CONTROL'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_LINE_MAX'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_LOGIN_NAME_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_LONG_BIT'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_MAPPED_FILES'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_MB_LEN_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_MEMLOCK'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_MEMLOCK_RANGE'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_MEMORY_PROTECTION'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_MESSAGE_PASSING'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_MQ_OPEN_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_MQ_PRIO_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_NGROUPS_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_NL_ARGMAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_NL_LANGMAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_NL_MSGMAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_NL_NMAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_NL_SETMAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_NL_TEXTMAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_NPROCESSORS_CONF'
     `unistd.h' (GNU):  *Note Constants for Sysconf::.

`_SC_NPROCESSORS_ONLN'
     `unistd.h' (GNU):  *Note Constants for Sysconf::.

`_SC_NZERO'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_OPEN_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_PAGESIZE'
     `unistd.h' (GNU):  *Note Constants for Sysconf::.

`_SC_PHYS_PAGES'
     `unistd.h' (GNU):  *Note Constants for Sysconf::.

`_SC_PII'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_INTERNET'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_INTERNET_DGRAM'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_INTERNET_STREAM'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_OSI'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_OSI_CLTS'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_OSI_COTS'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_OSI_M'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_SOCKET'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PII_XTI'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_PRIORITIZED_IO'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_PRIORITY_SCHEDULING'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_REALTIME_SIGNALS'
     `unistdh.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_RTSIG_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_SAVED_IDS'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_SCHAR_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_SCHAR_MIN'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_SELECT'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_SEMAPHORES'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_SEM_NSEMS_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_SEM_VALUE_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_SHARED_MEMORY_OBJECTS'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_SHRT_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_SHRT_MIN'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_SIGQUEUE_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`SC_SSIZE_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_STREAM_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_SYNCHRONIZED_IO'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_ATTR_STACKADDR'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_ATTR_STACKSIZE'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_DESTRUCTOR_ITERATIONS'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_KEYS_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_PRIO_INHERIT'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_PRIO_PROTECT'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_PRIORITY_SCHEDULING'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_PROCESS_SHARED'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREADS'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_SAFE_FUNCTIONS'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_STACK_MIN'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_THREAD_THREADS_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_TIMER_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_TIMERS'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_T_IOV_MAX'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_TTY_NAME_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_TZNAME_MAX'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_UCHAR_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_UINT_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_UIO_MAXIOV'
     `unistd.h' (POSIX.1g):  *Note Constants for Sysconf::.

`_SC_ULONG_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_USHRT_MAX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_VERSION'
     `unistd.h' (POSIX.1):  *Note Constants for Sysconf::.

`_SC_VERSION'
     `unistd.h' (POSIX.2):  *Note Constants for Sysconf::.

`_SC_WORD_BIT'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_CRYPT'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_ENH_I18N'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_LEGACY'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_REALTIME'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_REALTIME_THREADS'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_SHM'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_UNIX'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_VERSION'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_XCU_VERSION'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_XPG2'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_XPG3'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`_SC_XOPEN_XPG4'
     `unistd.h' (X/Open):  *Note Constants for Sysconf::.

`unsigned short int * seed48 (unsigned short int SEED16V[3])'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int seed48_r (unsigned short int SEED16V[3], struct drand48_data *BUFFER)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`int SEEK_CUR'
     `stdio.h' (ISO):  *Note File Positioning::.

`void seekdir (DIR *DIRSTREAM, long int POS)'
     `dirent.h' (BSD):  *Note Random Access Directory::.

`int SEEK_END'
     `stdio.h' (ISO):  *Note File Positioning::.

`int SEEK_SET'
     `stdio.h' (ISO):  *Note File Positioning::.

`int select (int NFDS, fd_set *READ-FDS, fd_set *WRITE-FDS, fd_set *EXCEPT-FDS, struct timeval *TIMEOUT)'
     `sys/types.h' (BSD):  *Note Waiting for I/O::.

`int send (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS)'
     `sys/socket.h' (BSD):  *Note Sending Data::.

`int sendmsg (int SOCKET, const struct msghdr *MESSAGE, int FLAGS)'
     `sys/socket.h' (BSD):  *Note Receiving Datagrams::.

`int sendto (int SOCKET, void *BUFFER. size_t SIZE, int FLAGS, struct sockaddr *ADDR, socklen_t LENGTH)'
     `sys/socket.h' (BSD):  *Note Sending Datagrams::.

`void setbuf (FILE *STREAM, char *BUF)'
     `stdio.h' (ISO):  *Note Controlling Buffering::.

`void setbuffer (FILE *STREAM, char *BUF, size_t SIZE)'
     `stdio.h' (BSD):  *Note Controlling Buffering::.

`int setcontext (const ucontext_t *UCP)'
     `ucontext.h' (SVID):  *Note System V contexts::.

`int setdomainname (const char *NAME, size_t LENGTH)'
     `unistd.h' (???):  *Note Host Identification::.

`int setegid (gid_t NEWGID)'
     `unistd.h' (POSIX.1):  *Note Setting Groups::.

`int setenv (const char *NAME, const char *VALUE, int REPLACE)'
     `stdlib.h' (BSD):  *Note Environment Access::.

`int seteuid (uid_t NEWEUID)'
     `unistd.h' (POSIX.1):  *Note Setting User ID::.

`int setfsent (void)'
     `fstab.h' (BSD):  *Note fstab::.

`int setgid (gid_t NEWGID)'
     `unistd.h' (POSIX.1):  *Note Setting Groups::.

`void setgrent (void)'
     `grp.h' (SVID, BSD):  *Note Scanning All Groups::.

`int setgroups (size_t COUNT, gid_t *GROUPS)'
     `grp.h' (BSD):  *Note Setting Groups::.

`void sethostent (int STAYOPEN)'
     `netdb.h' (BSD):  *Note Host Names::.

`int sethostid (long int ID)'
     `unistd.h' (BSD):  *Note Host Identification::.

`int sethostname (const char *NAME, size_t LENGTH)'
     `unistd.h' (BSD):  *Note Host Identification::.

`int setitimer (int WHICH, struct itimerval *NEW, struct itimerval *OLD)'
     `sys/time.h' (BSD):  *Note Setting an Alarm::.

`int setjmp (jmp_buf STATE)'
     `setjmp.h' (ISO):  *Note Non-Local Details::.

`void setkey (const char *KEY)'
     `crypt.h' (BSD, SVID):  *Note DES Encryption::.

`void setkey_r (const char *KEY, struct crypt_data * DATA)'
     `crypt.h' (GNU):  *Note DES Encryption::.

`void setlinebuf (FILE *STREAM)'
     `stdio.h' (BSD):  *Note Controlling Buffering::.

`char * setlocale (int CATEGORY, const char *LOCALE)'
     `locale.h' (ISO):  *Note Setting the Locale::.

`int setlogmask (int MASK)'
     `syslog.h' (BSD):  *Note setlogmask::.

`FILE * setmntent (const char *FILE, const char *MODE)'
     `mntent.h' (BSD):  *Note mtab::.

`void setnetent (int STAYOPEN)'
     `netdb.h' (BSD):  *Note Networks Database::.

`int setnetgrent (const char *NETGROUP)'
     `netdb.h' (BSD):  *Note Lookup Netgroup::.

`int setpgid (pid_t PID, pid_t PGID)'
     `unistd.h' (POSIX.1):  *Note Process Group Functions::.

`int setpgrp (pid_t PID, pid_t PGID)'
     `unistd.h' (BSD):  *Note Process Group Functions::.

`int setpriority (int CLASS, int ID, int NICEVAL)'
     `sys/resource.h' (BSD,POSIX):  *Note Traditional Scheduling
     Functions::.

`void setprotoent (int STAYOPEN)'
     `netdb.h' (BSD):  *Note Protocols Database::.

`void setpwent (void)'
     `pwd.h' (SVID, BSD):  *Note Scanning All Users::.

`int setregid (gid_t RGID, gid_t EGID)'
     `unistd.h' (BSD):  *Note Setting Groups::.

`int setreuid (uid_t RUID, uid_t EUID)'
     `unistd.h' (BSD):  *Note Setting User ID::.

`int setrlimit (int RESOURCE, const struct rlimit *RLP)'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`int setrlimit64 (int RESOURCE, const struct rlimit64 *RLP)'
     `sys/resource.h' (Unix98):  *Note Limits on Resources::.

`void setservent (int STAYOPEN)'
     `netdb.h' (BSD):  *Note Services Database::.

`pid_t setsid (void)'
     `unistd.h' (POSIX.1):  *Note Process Group Functions::.

`int setsockopt (int SOCKET, int LEVEL, int OPTNAME, void *OPTVAL, socklen_t OPTLEN)'
     `sys/socket.h' (BSD):  *Note Socket Option Functions::.

`void * setstate (void *STATE)'
     `stdlib.h' (BSD):  *Note BSD Random::.

`int setstate_r (char *restrict STATEBUF, struct random_data *restrict BUF)'
     `stdlib.h' (GNU):  *Note BSD Random::.

`int settimeofday (const struct timeval *TP, const struct timezone *TZP)'
     `sys/time.h' (BSD):  *Note High-Resolution Calendar::.

`int setuid (uid_t NEWUID)'
     `unistd.h' (POSIX.1):  *Note Setting User ID::.

`void setutent (void)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`void setutxent (void)'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`int setvbuf (FILE *STREAM, char *BUF, int MODE, size_t SIZE)'
     `stdio.h' (ISO):  *Note Controlling Buffering::.

`SHRT_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`SHRT_MIN'
     `limits.h' (ISO):  *Note Range of Type::.

`int shutdown (int SOCKET, int HOW)'
     `sys/socket.h' (BSD):  *Note Closing a Socket::.

`S_IEXEC'
     `sys/stat.h' (BSD):  *Note Permission Bits::.

`S_IFBLK'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`S_IFCHR'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`S_IFDIR'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`S_IFIFO'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`S_IFLNK'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`int S_IFMT'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`S_IFREG'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`S_IFSOCK'
     `sys/stat.h' (BSD):  *Note Testing File Type::.

`int SIGABRT'
     `signal.h' (ISO):  *Note Program Error Signals::.

`int sigaction (int SIGNUM, const struct sigaction *restrict ACTION, struct sigaction *restrict OLD-ACTION)'
     `signal.h' (POSIX.1):  *Note Advanced Signal Handling::.

`int sigaddset (sigset_t *SET, int SIGNUM)'
     `signal.h' (POSIX.1):  *Note Signal Sets::.

`int SIGALRM'
     `signal.h' (POSIX.1):  *Note Alarm Signals::.

`int sigaltstack (const stack_t *restrict STACK, stack_t *restrict OLDSTACK)'
     `signal.h' (XPG):  *Note Signal Stack::.

`sig_atomic_t'
     `signal.h' (ISO):  *Note Atomic Types::.

`SIG_BLOCK'
     `signal.h' (POSIX.1):  *Note Process Signal Mask::.

`int sigblock (int MASK)'
     `signal.h' (BSD):  *Note Blocking in BSD::.

`int SIGBUS'
     `signal.h' (BSD):  *Note Program Error Signals::.

`int SIGCHLD'
     `signal.h' (POSIX.1):  *Note Job Control Signals::.

`int SIGCLD'
     `signal.h' (SVID):  *Note Job Control Signals::.

`int SIGCONT'
     `signal.h' (POSIX.1):  *Note Job Control Signals::.

`int sigdelset (sigset_t *SET, int SIGNUM)'
     `signal.h' (POSIX.1):  *Note Signal Sets::.

`int sigemptyset (sigset_t *SET)'
     `signal.h' (POSIX.1):  *Note Signal Sets::.

`int SIGEMT'
     `signal.h' (BSD):  *Note Program Error Signals::.

`sighandler_t SIG_ERR'
     `signal.h' (ISO):  *Note Basic Signal Handling::.

`int sigfillset (sigset_t *SET)'
     `signal.h' (POSIX.1):  *Note Signal Sets::.

`int SIGFPE'
     `signal.h' (ISO):  *Note Program Error Signals::.

`sighandler_t'
     `signal.h' (GNU):  *Note Basic Signal Handling::.

`int SIGHUP'
     `signal.h' (POSIX.1):  *Note Termination Signals::.

`int SIGILL'
     `signal.h' (ISO):  *Note Program Error Signals::.

`int SIGINFO'
     `signal.h' (BSD):  *Note Miscellaneous Signals::.

`int SIGINT'
     `signal.h' (ISO):  *Note Termination Signals::.

`int siginterrupt (int SIGNUM, int FAILFLAG)'
     `signal.h' (BSD):  *Note BSD Handler::.

`int SIGIO'
     `signal.h' (BSD):  *Note Asynchronous I/O Signals::.

`int SIGIOT'
     `signal.h' (Unix):  *Note Program Error Signals::.

`int sigismember (const sigset_t *SET, int SIGNUM)'
     `signal.h' (POSIX.1):  *Note Signal Sets::.

`sigjmp_buf'
     `setjmp.h' (POSIX.1):  *Note Non-Local Exits and Signals::.

`int SIGKILL'
     `signal.h' (POSIX.1):  *Note Termination Signals::.

`void siglongjmp (sigjmp_buf STATE, int VALUE)'
     `setjmp.h' (POSIX.1):  *Note Non-Local Exits and Signals::.

`int SIGLOST'
     `signal.h' (GNU):  *Note Operation Error Signals::.

`int sigmask (int SIGNUM)'
     `signal.h' (BSD):  *Note Blocking in BSD::.

`sighandler_t signal (int SIGNUM, sighandler_t ACTION)'
     `signal.h' (ISO):  *Note Basic Signal Handling::.

`int signbit (_float-type_ X)'
     `math.h' (ISO):  *Note FP Bit Twiddling::.

`long long int significand (double X)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int significandf (float X)'
     `math.h' (BSD):  *Note Normalization Functions::.

`long long int significandl (long double X)'
     `math.h' (BSD):  *Note Normalization Functions::.

`int sigpause (int MASK)'
     `signal.h' (BSD):  *Note Blocking in BSD::.

`int sigpending (sigset_t *SET)'
     `signal.h' (POSIX.1):  *Note Checking for Pending Signals::.

`int SIGPIPE'
     `signal.h' (POSIX.1):  *Note Operation Error Signals::.

`int SIGPOLL'
     `signal.h' (SVID):  *Note Asynchronous I/O Signals::.

`int sigprocmask (int HOW, const sigset_t *restrict SET, sigset_t *restrict OLDSET)'
     `signal.h' (POSIX.1):  *Note Process Signal Mask::.

`int SIGPROF'
     `signal.h' (BSD):  *Note Alarm Signals::.

`int SIGQUIT'
     `signal.h' (POSIX.1):  *Note Termination Signals::.

`int SIGSEGV'
     `signal.h' (ISO):  *Note Program Error Signals::.

`int sigsetjmp (sigjmp_buf STATE, int SAVESIGS)'
     `setjmp.h' (POSIX.1):  *Note Non-Local Exits and Signals::.

`SIG_SETMASK'
     `signal.h' (POSIX.1):  *Note Process Signal Mask::.

`int sigsetmask (int MASK)'
     `signal.h' (BSD):  *Note Blocking in BSD::.

`sigset_t'
     `signal.h' (POSIX.1):  *Note Signal Sets::.

`int sigstack (const struct sigstack *STACK, struct sigstack *OLDSTACK)'
     `signal.h' (BSD):  *Note Signal Stack::.

`int SIGSTOP'
     `signal.h' (POSIX.1):  *Note Job Control Signals::.

`int sigsuspend (const sigset_t *SET)'
     `signal.h' (POSIX.1):  *Note Sigsuspend::.

`int SIGSYS'
     `signal.h' (Unix):  *Note Program Error Signals::.

`int SIGTERM'
     `signal.h' (ISO):  *Note Termination Signals::.

`int SIGTRAP'
     `signal.h' (BSD):  *Note Program Error Signals::.

`int SIGTSTP'
     `signal.h' (POSIX.1):  *Note Job Control Signals::.

`int SIGTTIN'
     `signal.h' (POSIX.1):  *Note Job Control Signals::.

`int SIGTTOU'
     `signal.h' (POSIX.1):  *Note Job Control Signals::.

`SIG_UNBLOCK'
     `signal.h' (POSIX.1):  *Note Process Signal Mask::.

`int SIGURG'
     `signal.h' (BSD):  *Note Asynchronous I/O Signals::.

`int SIGUSR1'
     `signal.h' (POSIX.1):  *Note Miscellaneous Signals::.

`int SIGUSR2'
     `signal.h' (POSIX.1):  *Note Miscellaneous Signals::.

`int sigvec (int SIGNUM, const struct sigvec *ACTION,struct sigvec *OLD-ACTION)'
     `signal.h' (BSD):  *Note BSD Handler::.

`int SIGVTALRM'
     `signal.h' (BSD):  *Note Alarm Signals::.

`int SIGWINCH'
     `signal.h' (BSD):  *Note Miscellaneous Signals::.

`int SIGXCPU'
     `signal.h' (BSD):  *Note Operation Error Signals::.

`int SIGXFSZ'
     `signal.h' (BSD):  *Note Operation Error Signals::.

`double sin (double X)'
     `math.h' (ISO):  *Note Trig Functions::.

`void sincos (double X, double *SINX, double *COSX)'
     `math.h' (GNU):  *Note Trig Functions::.

`void sincosf (float X, float *SINX, float *COSX)'
     `math.h' (GNU):  *Note Trig Functions::.

`void sincosl (long double X, long double *SINX, long double *COSX)'
     `math.h' (GNU):  *Note Trig Functions::.

`float sinf (float X)'
     `math.h' (ISO):  *Note Trig Functions::.

`double sinh (double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`float sinhf (float X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double sinhl (long double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double sinl (long double X)'
     `math.h' (ISO):  *Note Trig Functions::.

`S_IREAD'
     `sys/stat.h' (BSD):  *Note Permission Bits::.

`S_IRGRP'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IROTH'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IRUSR'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IRWXG'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IRWXO'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IRWXU'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`int S_ISBLK (mode_t M)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`int S_ISCHR (mode_t M)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`int S_ISDIR (mode_t M)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`int S_ISFIFO (mode_t M)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`S_ISGID'
     `sys/stat.h' (POSIX):  *Note Permission Bits::.

`int S_ISLNK (mode_t M)'
     `sys/stat.h' (GNU):  *Note Testing File Type::.

`int S_ISREG (mode_t M)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`int S_ISSOCK (mode_t M)'
     `sys/stat.h' (GNU):  *Note Testing File Type::.

`S_ISUID'
     `sys/stat.h' (POSIX):  *Note Permission Bits::.

`S_ISVTX'
     `sys/stat.h' (BSD):  *Note Permission Bits::.

`S_IWGRP'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IWOTH'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IWRITE'
     `sys/stat.h' (BSD):  *Note Permission Bits::.

`S_IWUSR'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IXGRP'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IXOTH'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`S_IXUSR'
     `sys/stat.h' (POSIX.1):  *Note Permission Bits::.

`size_t'
     `stddef.h' (ISO):  *Note Important Data Types::.

`unsigned int sleep (unsigned int SECONDS)'
     `unistd.h' (POSIX.1):  *Note Sleeping::.

`int snprintf (char *S, size_t SIZE, const char *TEMPLATE, ...)'
     `stdio.h' (GNU):  *Note Formatted Output Functions::.

`SO_BROADCAST'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`int SOCK_DGRAM'
     `sys/socket.h' (BSD):  *Note Communication Styles::.

`int socket (int NAMESPACE, int STYLE, int PROTOCOL)'
     `sys/socket.h' (BSD):  *Note Creating a Socket::.

`int socketpair (int NAMESPACE, int STYLE, int PROTOCOL, int FILEDES[2])'
     `sys/socket.h' (BSD):  *Note Socket Pairs::.

`int SOCK_RAW'
     `sys/socket.h' (BSD):  *Note Communication Styles::.

`int SOCK_RDM'
     `sys/socket.h' (BSD):  *Note Communication Styles::.

`int SOCK_SEQPACKET'
     `sys/socket.h' (BSD):  *Note Communication Styles::.

`int SOCK_STREAM'
     `sys/socket.h' (BSD):  *Note Communication Styles::.

`SO_DEBUG'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_DONTROUTE'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_ERROR'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_KEEPALIVE'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_LINGER'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`int SOL_SOCKET'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_OOBINLINE'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_RCVBUF'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_REUSEADDR'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_SNDBUF'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`SO_STYLE'
     `sys/socket.h' (GNU):  *Note Socket-Level Options::.

`SO_TYPE'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`speed_t'
     `termios.h' (POSIX.1):  *Note Line Speed::.

`int sprintf (char *S, const char *TEMPLATE, ...)'
     `stdio.h' (ISO):  *Note Formatted Output Functions::.

`double sqrt (double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`float sqrtf (float X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`long double sqrtl (long double X)'
     `math.h' (ISO):  *Note Exponents and Logarithms::.

`void srand (unsigned int SEED)'
     `stdlib.h' (ISO):  *Note ISO Random::.

`void srand48 (long int SEEDVAL)'
     `stdlib.h' (SVID):  *Note SVID Random::.

`int srand48_r (long int SEEDVAL, struct drand48_data *BUFFER)'
     `stdlib.h' (GNU):  *Note SVID Random::.

`void srandom (unsigned int SEED)'
     `stdlib.h' (BSD):  *Note BSD Random::.

`int srandom_r (unsigned int SEED, struct random_data *BUF)'
     `stdlib.h' (GNU):  *Note BSD Random::.

`int sscanf (const char *S, const char *TEMPLATE, ...)'
     `stdio.h' (ISO):  *Note Formatted Input Functions::.

`sighandler_t ssignal (int SIGNUM, sighandler_t ACTION)'
     `signal.h' (SVID):  *Note Basic Signal Handling::.

`int SSIZE_MAX'
     `limits.h' (POSIX.1):  *Note General Limits::.

`ssize_t'
     `unistd.h' (POSIX.1):  *Note I/O Primitives::.

`stack_t'
     `signal.h' (XPG):  *Note Signal Stack::.

`int stat (const char *FILENAME, struct stat *BUF)'
     `sys/stat.h' (POSIX.1):  *Note Reading Attributes::.

`int stat64 (const char *FILENAME, struct stat64 *BUF)'
     `sys/stat.h' (Unix98):  *Note Reading Attributes::.

`FILE * stderr'
     `stdio.h' (ISO):  *Note Standard Streams::.

`STDERR_FILENO'
     `unistd.h' (POSIX.1):  *Note Descriptors and Streams::.

`FILE * stdin'
     `stdio.h' (ISO):  *Note Standard Streams::.

`STDIN_FILENO'
     `unistd.h' (POSIX.1):  *Note Descriptors and Streams::.

`FILE * stdout'
     `stdio.h' (ISO):  *Note Standard Streams::.

`STDOUT_FILENO'
     `unistd.h' (POSIX.1):  *Note Descriptors and Streams::.

`int stime (time_t *NEWTIME)'
     `time.h' (SVID, XPG):  *Note Simple Calendar Time::.

`char * stpcpy (char *restrict TO, const char *restrict FROM)'
     `string.h' (Unknown origin):  *Note Copying and Concatenation::.

`char * stpncpy (char *restrict TO, const char *restrict FROM, size_t SIZE)'
     `string.h' (GNU):  *Note Copying and Concatenation::.

`int strcasecmp (const char *S1, const char *S2)'
     `string.h' (BSD):  *Note String/Array Comparison::.

`char * strcasestr (const char *HAYSTACK, const char *NEEDLE)'
     `string.h' (GNU):  *Note Search Functions::.

`char * strcat (char *restrict TO, const char *restrict FROM)'
     `string.h' (ISO):  *Note Copying and Concatenation::.

`char * strchr (const char *STRING, int C)'
     `string.h' (ISO):  *Note Search Functions::.

`char * strchrnul (const char *STRING, int C)'
     `string.h' (GNU):  *Note Search Functions::.

`int strcmp (const char *S1, const char *S2)'
     `string.h' (ISO):  *Note String/Array Comparison::.

`int strcoll (const char *S1, const char *S2)'
     `string.h' (ISO):  *Note Collation Functions::.

`char * strcpy (char *restrict TO, const char *restrict FROM)'
     `string.h' (ISO):  *Note Copying and Concatenation::.

`size_t strcspn (const char *STRING, const char *STOPSET)'
     `string.h' (ISO):  *Note Search Functions::.

`char * strdup (const char *S)'
     `string.h' (SVID):  *Note Copying and Concatenation::.

`char * strdupa (const char *S)'
     `string.h' (GNU):  *Note Copying and Concatenation::.

`int STREAM_MAX'
     `limits.h' (POSIX.1):  *Note General Limits::.

`char * strerror (int ERRNUM)'
     `string.h' (ISO):  *Note Error Messages::.

`char * strerror_r (int ERRNUM, char *BUF, size_t N)'
     `string.h' (GNU):  *Note Error Messages::.

`char * strfry (char *STRING)'
     `string.h' (GNU):  *Note strfry::.

`size_t strftime (char *S, size_t SIZE, const char *TEMPLATE, const struct tm *BROKENTIME)'
     `time.h' (ISO):  *Note Formatting Calendar Time::.

`size_t strlen (const char *S)'
     `string.h' (ISO):  *Note String Length::.

`int strncasecmp (const char *S1, const char *S2, size_t N)'
     `string.h' (BSD):  *Note String/Array Comparison::.

`char * strncat (char *restrict TO, const char *restrict FROM, size_t SIZE)'
     `string.h' (ISO):  *Note Copying and Concatenation::.

`int strncmp (const char *S1, const char *S2, size_t SIZE)'
     `string.h' (ISO):  *Note String/Array Comparison::.

`char * strncpy (char *restrict TO, const char *restrict FROM, size_t SIZE)'
     `string.h' (ISO):  *Note Copying and Concatenation::.

`char * strndup (const char *S, size_t SIZE)'
     `string.h' (GNU):  *Note Copying and Concatenation::.

`char * strndupa (const char *S, size_t SIZE)'
     `string.h' (GNU):  *Note Copying and Concatenation::.

`size_t strnlen (const char *S, size_t MAXLEN)'
     `string.h' (GNU):  *Note String Length::.

`char * strpbrk (const char *STRING, const char *STOPSET)'
     `string.h' (ISO):  *Note Search Functions::.

`char * strptime (const char *S, const char *FMT, struct tm *TP)'
     `time.h' (XPG4):  *Note Low-Level Time String Parsing::.

`char * strrchr (const char *STRING, int C)'
     `string.h' (ISO):  *Note Search Functions::.

`char * strsep (char **STRING_PTR, const char *DELIMITER)'
     `string.h' (BSD):  *Note Finding Tokens in a String::.

`char * strsignal (int SIGNUM)'
     `string.h' (GNU):  *Note Signal Messages::.

`size_t strspn (const char *STRING, const char *SKIPSET)'
     `string.h' (ISO):  *Note Search Functions::.

`char * strstr (const char *HAYSTACK, const char *NEEDLE)'
     `string.h' (ISO):  *Note Search Functions::.

`double strtod (const char *restrict STRING, char **restrict TAILPTR)'
     `stdlib.h' (ISO):  *Note Parsing of Floats::.

`float strtof (const char *STRING, char **TAILPTR)'
     `stdlib.h' (ISO):  *Note Parsing of Floats::.

`intmax_t strtoimax (const char *restrict STRING, char **restrict TAILPTR, int BASE)'
     `inttypes.h' (ISO):  *Note Parsing of Integers::.

`char * strtok (char *restrict NEWSTRING, const char *restrict DELIMITERS)'
     `string.h' (ISO):  *Note Finding Tokens in a String::.

`char * strtok_r (char *NEWSTRING, const char *DELIMITERS, char **SAVE_PTR)'
     `string.h' (POSIX):  *Note Finding Tokens in a String::.

`long int strtol (const char *restrict STRING, char **restrict TAILPTR, int BASE)'
     `stdlib.h' (ISO):  *Note Parsing of Integers::.

`long double strtold (const char *STRING, char **TAILPTR)'
     `stdlib.h' (ISO):  *Note Parsing of Floats::.

`long long int strtoll (const char *restrict STRING, char **restrict TAILPTR, int BASE)'
     `stdlib.h' (ISO):  *Note Parsing of Integers::.

`long long int strtoq (const char *restrict STRING, char **restrict TAILPTR, int BASE)'
     `stdlib.h' (BSD):  *Note Parsing of Integers::.

`unsigned long int strtoul (const char *retrict STRING, char **restrict TAILPTR, int BASE)'
     `stdlib.h' (ISO):  *Note Parsing of Integers::.

`unsigned long long int strtoull (const char *restrict STRING, char **restrict TAILPTR, int BASE)'
     `stdlib.h' (ISO):  *Note Parsing of Integers::.

`uintmax_t strtoumax (const char *restrict STRING, char **restrict TAILPTR, int BASE)'
     `inttypes.h' (ISO):  *Note Parsing of Integers::.

`unsigned long long int strtouq (const char *restrict STRING, char **restrict TAILPTR, int BASE)'
     `stdlib.h' (BSD):  *Note Parsing of Integers::.

`struct aiocb'
     `aio.h' (POSIX.1b):  *Note Asynchronous I/O::.

`struct aiocb64'
     `aio.h' (POSIX.1b):  *Note Asynchronous I/O::.

`struct aioinit'
     `aio.h' (GNU):  *Note Configuration of AIO::.

`struct argp'
     `argp.h' (GNU):  *Note Argp Parsers::.

`struct argp_child'
     `argp.h' (GNU):  *Note Argp Children::.

`struct argp_option'
     `argp.h' (GNU):  *Note Argp Option Vectors::.

`struct argp_state'
     `argp.h' (GNU):  *Note Argp Parsing State::.

`struct dirent'
     `dirent.h' (POSIX.1):  *Note Directory Entries::.

`struct exit_status'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`struct flock'
     `fcntl.h' (POSIX.1):  *Note File Locks::.

`struct fstab'
     `fstab.h' (BSD):  *Note fstab::.

`struct FTW'
     `ftw.h' (XPG4.2):  *Note Working with Directory Trees::.

`struct __gconv_step'
     `gconv.h' (GNU):  *Note glibc iconv Implementation::.

`struct __gconv_step_data'
     `gconv.h' (GNU):  *Note glibc iconv Implementation::.

`struct group'
     `grp.h' (POSIX.1):  *Note Group Data Structure::.

`struct hostent'
     `netdb.h' (BSD):  *Note Host Names::.

`struct if_nameindex'
     `net/if.h' (IPv6 basic API):  *Note Interface Naming::.

`struct in6_addr'
     `netinet/in.h' (IPv6 basic API):  *Note Host Address Data Type::.

`struct in_addr'
     `netinet/in.h' (BSD):  *Note Host Address Data Type::.

`struct iovec'
     `sys/uio.h' (BSD):  *Note Scatter-Gather::.

`struct itimerval'
     `sys/time.h' (BSD):  *Note Setting an Alarm::.

`struct lconv'
     `locale.h' (ISO):  *Note The Lame Way to Locale Data::.

`struct linger'
     `sys/socket.h' (BSD):  *Note Socket-Level Options::.

`struct mallinfo'
     `malloc.h' (GNU):  *Note Statistics of Malloc::.

`struct mntent'
     `mntent.h' (BSD):  *Note mtab::.

`struct msghdr'
     `sys/socket.h' (BSD):  *Note Receiving Datagrams::.

`struct netent'
     `netdb.h' (BSD):  *Note Networks Database::.

`struct obstack'
     `obstack.h' (GNU):  *Note Creating Obstacks::.

`struct option'
     `getopt.h' (GNU):  *Note Getopt Long Options::.

`struct passwd'
     `pwd.h' (POSIX.1):  *Note User Data Structure::.

`struct printf_info'
     `printf.h' (GNU):  *Note Conversion Specifier Options::.

`struct protoent'
     `netdb.h' (BSD):  *Note Protocols Database::.

`struct random_data'
     `stdlib.h' (GNU):  *Note BSD Random::.

`struct rlimit'
     `sys/resource.h' (BSD):  *Note Limits on Resources::.

`struct rlimit64'
     `sys/resource.h' (Unix98):  *Note Limits on Resources::.

`struct rusage'
     `sys/resource.h' (BSD):  *Note Resource Usage::.

`struct sched_param'
     `sched.h' (POSIX):  *Note Basic Scheduling Functions::.

`struct servent'
     `netdb.h' (BSD):  *Note Services Database::.

`struct sgttyb'
     `termios.h' (BSD):  *Note BSD Terminal Modes::.

`struct sigaction'
     `signal.h' (POSIX.1):  *Note Advanced Signal Handling::.

`struct sigstack'
     `signal.h' (BSD):  *Note Signal Stack::.

`struct sigvec'
     `signal.h' (BSD):  *Note BSD Handler::.

`struct sockaddr'
     `sys/socket.h' (BSD):  *Note Address Formats::.

`struct sockaddr_in'
     `netinet/in.h' (BSD):  *Note Internet Address Formats::.

`struct sockaddr_un'
     `sys/un.h' (BSD):  *Note Local Namespace Details::.

`struct stat'
     `sys/stat.h' (POSIX.1):  *Note Attribute Meanings::.

`struct stat64'
     `sys/stat.h' (LFS):  *Note Attribute Meanings::.

`struct termios'
     `termios.h' (POSIX.1):  *Note Mode Data Types::.

`struct timespec'
     `sys/time.h' (POSIX.1):  *Note Elapsed Time::.

`struct timeval'
     `sys/time.h' (BSD):  *Note Elapsed Time::.

`struct timezone'
     `sys/time.h' (BSD):  *Note High-Resolution Calendar::.

`struct tm'
     `time.h' (ISO):  *Note Broken-down Time::.

`struct tms'
     `sys/times.h' (POSIX.1):  *Note Processor Time::.

`struct utimbuf'
     `time.h' (POSIX.1):  *Note File Times::.

`struct utsname'
     `sys/utsname.h' (POSIX.1):  *Note Platform Type::.

`int strverscmp (const char *S1, const char *S2)'
     `string.h' (GNU):  *Note String/Array Comparison::.

`size_t strxfrm (char *restrict TO, const char *restrict FROM, size_t SIZE)'
     `string.h' (ISO):  *Note Collation Functions::.

`int stty (int FILEDES, struct sgttyb * attributes)'
     `sgtty.h' (BSD):  *Note BSD Terminal Modes::.

`int S_TYPEISMQ (struct stat *S)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`int S_TYPEISSEM (struct stat *S)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`int S_TYPEISSHM (struct stat *S)'
     `sys/stat.h' (POSIX):  *Note Testing File Type::.

`int SUN_LEN (_struct sockaddr_un *_ PTR)'
     `sys/un.h' (BSD):  *Note Local Namespace Details::.

`_SVID_SOURCE'
     (GNU):  *Note Feature Test Macros::.

`int SV_INTERRUPT'
     `signal.h' (BSD):  *Note BSD Handler::.

`int SV_ONSTACK'
     `signal.h' (BSD):  *Note BSD Handler::.

`int SV_RESETHAND'
     `signal.h' (Sun):  *Note BSD Handler::.

`int swapcontext (ucontext_t *restrict OUCP, const ucontext_t *restrict UCP)'
     `ucontext.h' (SVID):  *Note System V contexts::.

`int swprintf (wchar_t *S, size_t SIZE, const wchar_t *TEMPLATE, ...)'
     `wchar.h' (GNU):  *Note Formatted Output Functions::.

`int swscanf (const wchar_t *WS, const char *TEMPLATE, ...)'
     `wchar.h' (ISO):  *Note Formatted Input Functions::.

`int symlink (const char *OLDNAME, const char *NEWNAME)'
     `unistd.h' (BSD):  *Note Symbolic Links::.

`SYMLINK_MAX'
     `limits.h' (POSIX.1):  *Note File Minimums::.

`int sync (void)'
     `unistd.h' (X/Open):  *Note Synchronizing I/O::.

`long int syscall (long int SYSNO, ...)'
     `unistd.h' (???):  *Note System Calls::.

`long int sysconf (int PARAMETER)'
     `unistd.h' (POSIX.1):  *Note Sysconf Definition::.

`int sysctl (int *NAMES, int NLEN, void *OLDVAL, size_t *OLDLENP, void *NEWVAL, size_t NEWLEN)'
     `sysctl.h' (BSD):  *Note System Parameters::.

`void syslog (int FACILITY_PRIORITY, char *FORMAT, ...)'
     `syslog.h' (BSD):  *Note syslog; vsyslog::.

`int system (const char *COMMAND)'
     `stdlib.h' (ISO):  *Note Running a Command::.

`sighandler_t sysv_signal (int SIGNUM, sighandler_t ACTION)'
     `signal.h' (GNU):  *Note Basic Signal Handling::.

`double tan (double X)'
     `math.h' (ISO):  *Note Trig Functions::.

`float tanf (float X)'
     `math.h' (ISO):  *Note Trig Functions::.

`double tanh (double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`float tanhf (float X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double tanhl (long double X)'
     `math.h' (ISO):  *Note Hyperbolic Functions::.

`long double tanl (long double X)'
     `math.h' (ISO):  *Note Trig Functions::.

`int tcdrain (int FILEDES)'
     `termios.h' (POSIX.1):  *Note Line Control::.

`tcflag_t'
     `termios.h' (POSIX.1):  *Note Mode Data Types::.

`int tcflow (int FILEDES, int ACTION)'
     `termios.h' (POSIX.1):  *Note Line Control::.

`int tcflush (int FILEDES, int QUEUE)'
     `termios.h' (POSIX.1):  *Note Line Control::.

`int tcgetattr (int FILEDES, struct termios *TERMIOS-P)'
     `termios.h' (POSIX.1):  *Note Mode Functions::.

`pid_t tcgetpgrp (int FILEDES)'
     `unistd.h' (POSIX.1):  *Note Terminal Access Functions::.

`pid_t tcgetsid (int FILDES)'
     `termios.h' (Unix98):  *Note Terminal Access Functions::.

`TCSADRAIN'
     `termios.h' (POSIX.1):  *Note Mode Functions::.

`TCSAFLUSH'
     `termios.h' (POSIX.1):  *Note Mode Functions::.

`TCSANOW'
     `termios.h' (POSIX.1):  *Note Mode Functions::.

`TCSASOFT'
     `termios.h' (BSD):  *Note Mode Functions::.

`int tcsendbreak (int FILEDES, int DURATION)'
     `termios.h' (POSIX.1):  *Note Line Control::.

`int tcsetattr (int FILEDES, int WHEN, const struct termios *TERMIOS-P)'
     `termios.h' (POSIX.1):  *Note Mode Functions::.

`int tcsetpgrp (int FILEDES, pid_t PGID)'
     `unistd.h' (POSIX.1):  *Note Terminal Access Functions::.

`void * tdelete (const void *KEY, void **ROOTP, comparison_fn_t COMPAR)'
     `search.h' (SVID):  *Note Tree Search Function::.

`void tdestroy (void *VROOT, __free_fn_t FREEFCT)'
     `search.h' (GNU):  *Note Tree Search Function::.

`TEMP_FAILURE_RETRY (EXPRESSION)'
     `unistd.h' (GNU):  *Note Interrupted Primitives::.

`char * tempnam (const char *DIR, const char *PREFIX)'
     `stdio.h' (SVID):  *Note Temporary Files::.

`char * textdomain (const char *DOMAINNAME)'
     `libintl.h' (GNU):  *Note Locating gettext catalog::.

`void * tfind (const void *KEY, void *const *ROOTP, comparison_fn_t COMPAR)'
     `search.h' (SVID):  *Note Tree Search Function::.

`double tgamma (double X)'
     `math.h' (XPG, ISO):  *Note Special Functions::.

`float tgammaf (float X)'
     `math.h' (XPG, ISO):  *Note Special Functions::.

`long double tgammal (long double X)'
     `math.h' (XPG, ISO):  *Note Special Functions::.

`time_t time (time_t *RESULT)'
     `time.h' (ISO):  *Note Simple Calendar Time::.

`time_t timegm (struct tm *BROKENTIME)'
     `time.h' (???):  *Note Broken-down Time::.

`time_t timelocal (struct tm *BROKENTIME)'
     `time.h' (???):  *Note Broken-down Time::.

`clock_t times (struct tms *BUFFER)'
     `sys/times.h' (POSIX.1):  *Note Processor Time::.

`time_t'
     `time.h' (ISO):  *Note Simple Calendar Time::.

`long int timezone'
     `time.h' (SVID):  *Note Time Zone Functions::.

`FILE * tmpfile (void)'
     `stdio.h' (ISO):  *Note Temporary Files::.

`FILE * tmpfile64 (void)'
     `stdio.h' (Unix98):  *Note Temporary Files::.

`int TMP_MAX'
     `stdio.h' (ISO):  *Note Temporary Files::.

`char * tmpnam (char *RESULT)'
     `stdio.h' (ISO):  *Note Temporary Files::.

`char * tmpnam_r (char *RESULT)'
     `stdio.h' (GNU):  *Note Temporary Files::.

`int toascii (int C)'
     `ctype.h' (SVID, BSD):  *Note Case Conversion::.

`int _tolower (int C)'
     `ctype.h' (SVID):  *Note Case Conversion::.

`int tolower (int C)'
     `ctype.h' (ISO):  *Note Case Conversion::.

`tcflag_t TOSTOP'
     `termios.h' (POSIX.1):  *Note Local Modes::.

`int _toupper (int C)'
     `ctype.h' (SVID):  *Note Case Conversion::.

`int toupper (int C)'
     `ctype.h' (ISO):  *Note Case Conversion::.

`wint_t towctrans (wint_t WC, wctrans_t DESC)'
     `wctype.h' (ISO):  *Note Wide Character Case Conversion::.

`wint_t towlower (wint_t WC)'
     `wctype.h' (ISO):  *Note Wide Character Case Conversion::.

`wint_t towupper (wint_t WC)'
     `wctype.h' (ISO):  *Note Wide Character Case Conversion::.

`double trunc (double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`int truncate (const char *FILENAME, off_t LENGTH)'
     `unistd.h' (X/Open):  *Note File Size::.

`int truncate64 (const char *NAME, off64_t LENGTH)'
     `unistd.h' (Unix98):  *Note File Size::.

`float truncf (float X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`long double truncl (long double X)'
     `math.h' (ISO):  *Note Rounding Functions::.

`TRY_AGAIN'
     `netdb.h' (BSD):  *Note Host Names::.

`void * tsearch (const void *KEY, void **ROOTP, comparison_fn_t COMPAR)'
     `search.h' (SVID):  *Note Tree Search Function::.

`char * ttyname (int FILEDES)'
     `unistd.h' (POSIX.1):  *Note Is It a Terminal::.

`int ttyname_r (int FILEDES, char *BUF, size_t LEN)'
     `unistd.h' (POSIX.1):  *Note Is It a Terminal::.

`void twalk (const void *ROOT, __action_fn_t ACTION)'
     `search.h' (SVID):  *Note Tree Search Function::.

`char * tzname [2]'
     `time.h' (POSIX.1):  *Note Time Zone Functions::.

`int TZNAME_MAX'
     `limits.h' (POSIX.1):  *Note General Limits::.

`void tzset (void)'
     `time.h' (POSIX.1):  *Note Time Zone Functions::.

`UCHAR_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`ucontext_t'
     `ucontext.h' (SVID):  *Note System V contexts::.

`uid_t'
     `sys/types.h' (POSIX.1):  *Note Reading Persona::.

`UINT_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`int ulimit (int CMD, ...)'
     `ulimit.h' (BSD):  *Note Limits on Resources::.

`ULONG_LONG_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`ULONG_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`mode_t umask (mode_t MASK)'
     `sys/stat.h' (POSIX.1):  *Note Setting Permissions::.

`int umount (const char *FILE)'
     `sys/mount.h' (SVID, GNU):  *Note Mount-Unmount-Remount::.

`int umount2 (const char *FILE, int FLAGS)'
     `sys/mount.h' (GNU):  *Note Mount-Unmount-Remount::.

`int uname (struct utsname *INFO)'
     `sys/utsname.h' (POSIX.1):  *Note Platform Type::.

`int ungetc (int C, FILE *STREAM)'
     `stdio.h' (ISO):  *Note How Unread::.

`wint_t ungetwc (wint_t WC, FILE *STREAM)'
     `wchar.h' (ISO):  *Note How Unread::.

`union wait'
     `sys/wait.h' (BSD):  *Note BSD Wait Functions::.

`int unlink (const char *FILENAME)'
     `unistd.h' (POSIX.1):  *Note Deleting Files::.

`int unlockpt (int FILEDES)'
     `stdlib.h' (SVID, XPG4.2):  *Note Allocation::.

`int unsetenv (const char *NAME)'
     `stdlib.h' (BSD):  *Note Environment Access::.

`void updwtmp (const char *WTMP_FILE, const struct utmp *UTMP)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`USER_PROCESS'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`USER_PROCESS'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`USHRT_MAX'
     `limits.h' (ISO):  *Note Range of Type::.

`int utime (const char *FILENAME, const struct utimbuf *TIMES)'
     `time.h' (POSIX.1):  *Note File Times::.

`int utimes (const char *FILENAME, struct timeval TVP[2])'
     `sys/time.h' (BSD):  *Note File Times::.

`int utmpname (const char *FILE)'
     `utmp.h' (SVID):  *Note Manipulating the Database::.

`int utmpxname (const char *FILE)'
     `utmpx.h' (XPG4.2):  *Note XPG Functions::.

`va_alist'
     `varargs.h' (Unix):  *Note Old Varargs::.

`TYPE va_arg (va_list AP, TYPE)'
     `stdarg.h' (ISO):  *Note Argument Macros::.

`void __va_copy (va_list DEST, va_list SRC)'
     `stdarg.h' (GNU):  *Note Argument Macros::.

`va_dcl'
     `varargs.h' (Unix):  *Note Old Varargs::.

`void va_end (va_list AP)'
     `stdarg.h' (ISO):  *Note Argument Macros::.

`va_list'
     `stdarg.h' (ISO):  *Note Argument Macros::.

`void * valloc (size_t SIZE)'
     `malloc.h', `stdlib.h' (BSD):  *Note Aligned Memory Blocks::.

`int vasprintf (char **PTR, const char *TEMPLATE, va_list AP)'
     `stdio.h' (GNU):  *Note Variable Arguments Output::.

`void va_start (va_list AP)'
     `varargs.h' (Unix):  *Note Old Varargs::.

`void va_start (va_list AP, LAST-REQUIRED)'
     `stdarg.h' (ISO):  *Note Argument Macros::.

`int VDISCARD'
     `termios.h' (BSD):  *Note Other Special::.

`int VDSUSP'
     `termios.h' (BSD):  *Note Signal Characters::.

`int VEOF'
     `termios.h' (POSIX.1):  *Note Editing Characters::.

`int VEOL'
     `termios.h' (POSIX.1):  *Note Editing Characters::.

`int VEOL2'
     `termios.h' (BSD):  *Note Editing Characters::.

`int VERASE'
     `termios.h' (POSIX.1):  *Note Editing Characters::.

`void verr (int STATUS, const char *FORMAT, va_list)'
     `err.h' (BSD):  *Note Error Messages::.

`void verrx (int STATUS, const char *FORMAT, va_list)'
     `err.h' (BSD):  *Note Error Messages::.

`int versionsort (const void *A, const void *B)'
     `dirent.h' (GNU):  *Note Scanning Directory Content::.

`int versionsort64 (const void *A, const void *B)'
     `dirent.h' (GNU):  *Note Scanning Directory Content::.

`pid_t vfork (void)'
     `unistd.h' (BSD):  *Note Creating a Process::.

`int vfprintf (FILE *STREAM, const char *TEMPLATE, va_list AP)'
     `stdio.h' (ISO):  *Note Variable Arguments Output::.

`int vfscanf (FILE *STREAM, const char *TEMPLATE, va_list AP)'
     `stdio.h' (ISO):  *Note Variable Arguments Input::.

`int vfwprintf (FILE *STREAM, const wchar_t *TEMPLATE, va_list AP)'
     `wchar.h' (ISO):  *Note Variable Arguments Output::.

`int vfwscanf (FILE *STREAM, const wchar_t *TEMPLATE, va_list AP)'
     `wchar.h' (ISO):  *Note Variable Arguments Input::.

`int VINTR'
     `termios.h' (POSIX.1):  *Note Signal Characters::.

`int VKILL'
     `termios.h' (POSIX.1):  *Note Editing Characters::.

`int vlimit (int RESOURCE, int LIMIT)'
     `sys/vlimit.h' (BSD):  *Note Limits on Resources::.

`int VLNEXT'
     `termios.h' (BSD):  *Note Other Special::.

`int VMIN'
     `termios.h' (POSIX.1):  *Note Noncanonical Input::.

`void (*) error_print_progname  (void)'
     `error.h' (GNU):  *Note Error Messages::.

`int vprintf (const char *TEMPLATE, va_list AP)'
     `stdio.h' (ISO):  *Note Variable Arguments Output::.

`int VQUIT'
     `termios.h' (POSIX.1):  *Note Signal Characters::.

`int VREPRINT'
     `termios.h' (BSD):  *Note Editing Characters::.

`int vscanf (const char *TEMPLATE, va_list AP)'
     `stdio.h' (ISO):  *Note Variable Arguments Input::.

`int vsnprintf (char *S, size_t SIZE, const char *TEMPLATE, va_list AP)'
     `stdio.h' (GNU):  *Note Variable Arguments Output::.

`int vsprintf (char *S, const char *TEMPLATE, va_list AP)'
     `stdio.h' (ISO):  *Note Variable Arguments Output::.

`int vsscanf (const char *S, const char *TEMPLATE, va_list AP)'
     `stdio.h' (ISO):  *Note Variable Arguments Input::.

`int VSTART'
     `termios.h' (POSIX.1):  *Note Start/Stop Characters::.

`int VSTATUS'
     `termios.h' (BSD):  *Note Other Special::.

`int VSTOP'
     `termios.h' (POSIX.1):  *Note Start/Stop Characters::.

`int VSUSP'
     `termios.h' (POSIX.1):  *Note Signal Characters::.

`int vswprintf (wchar_t *S, size_t SIZE, const wchar_t *TEMPLATE, va_list AP)'
     `wchar.h' (GNU):  *Note Variable Arguments Output::.

`int vswscanf (const wchar_t *S, const wchar_t *TEMPLATE, va_list AP)'
     `wchar.h' (ISO):  *Note Variable Arguments Input::.

`void vsyslog (int FACILITY_PRIORITY, char *FORMAT, va_list arglist)'
     `syslog.h' (BSD):  *Note syslog; vsyslog::.

`int VTIME'
     `termios.h' (POSIX.1):  *Note Noncanonical Input::.

`int vtimes (struct vtimes CURRENT, struct vtimes CHILD)'
     `vtimes.h' (vtimes.h):  *Note Resource Usage::.

`void vwarn (const char *FORMAT, va_list)'
     `err.h' (BSD):  *Note Error Messages::.

`void vwarnx (const char *FORMAT, va_list)'
     `err.h' (BSD):  *Note Error Messages::.

`int VWERASE'
     `termios.h' (BSD):  *Note Editing Characters::.

`int vwprintf (const wchar_t *TEMPLATE, va_list AP)'
     `wchar.h' (ISO):  *Note Variable Arguments Output::.

`int vwscanf (const wchar_t *TEMPLATE, va_list AP)'
     `wchar.h' (ISO):  *Note Variable Arguments Input::.

`pid_t wait (int *STATUS-PTR)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion::.

`pid_t wait3 (union wait *STATUS-PTR, int OPTIONS, struct rusage *USAGE)'
     `sys/wait.h' (BSD):  *Note BSD Wait Functions::.

`pid_t wait4 (pid_t PID, int *STATUS-PTR, int OPTIONS, struct rusage *USAGE)'
     `sys/wait.h' (BSD):  *Note Process Completion::.

`pid_t waitpid (pid_t PID, int *STATUS-PTR, int OPTIONS)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion::.

`void warn (const char *FORMAT, ...)'
     `err.h' (BSD):  *Note Error Messages::.

`void warnx (const char *FORMAT, ...)'
     `err.h' (BSD):  *Note Error Messages::.

`WCHAR_MAX'
     `limits.h' (GNU):  *Note Range of Type::.

`wint_t WCHAR_MAX'
     `wchar.h' (ISO):  *Note Extended Char Intro::.

`wint_t WCHAR_MIN'
     `wchar.h' (ISO):  *Note Extended Char Intro::.

`wchar_t'
     `stddef.h' (ISO):  *Note Extended Char Intro::.

`int WCOREDUMP (int STATUS)'
     `sys/wait.h' (BSD):  *Note Process Completion Status::.

`wchar_t * wcpcpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM)'
     `wchar.h' (GNU):  *Note Copying and Concatenation::.

`wchar_t * wcpncpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)'
     `wchar.h' (GNU):  *Note Copying and Concatenation::.

`size_t wcrtomb (char *restrict S, wchar_t WC, mbstate_t *restrict PS)'
     `wchar.h' (ISO):  *Note Converting a Character::.

`int wcscasecmp (const wchar_t *WS1, const wchar_T *WS2)'
     `wchar.h' (GNU):  *Note String/Array Comparison::.

`wchar_t * wcscat (wchar_t *restrict WTO, const wchar_t *restrict WFROM)'
     `wchar.h' (ISO):  *Note Copying and Concatenation::.

`wchar_t * wcschr (const wchar_t *WSTRING, int WC)'
     `wchar.h' (ISO):  *Note Search Functions::.

`wchar_t * wcschrnul (const wchar_t *WSTRING, wchar_t WC)'
     `wchar.h' (GNU):  *Note Search Functions::.

`int wcscmp (const wchar_t *WS1, const wchar_t *WS2)'
     `wchar.h' (ISO):  *Note String/Array Comparison::.

`int wcscoll (const wchar_t *WS1, const wchar_t *WS2)'
     `wchar.h' (ISO):  *Note Collation Functions::.

`wchar_t * wcscpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM)'
     `wchar.h' (ISO):  *Note Copying and Concatenation::.

`size_t wcscspn (const wchar_t *WSTRING, const wchar_t *STOPSET)'
     `wchar.h' (ISO):  *Note Search Functions::.

`wchar_t * wcsdup (const wchar_t *WS)'
     `wchar.h' (GNU):  *Note Copying and Concatenation::.

`size_t wcsftime (wchar_t *S, size_t SIZE, const wchar_t *TEMPLATE, const struct tm *BROKENTIME)'
     `time.h' (ISO/Amend1):  *Note Formatting Calendar Time::.

`size_t wcslen (const wchar_t *WS)'
     `wchar.h' (ISO):  *Note String Length::.

`int wcsncasecmp (const wchar_t *WS1, const wchar_t *S2, size_t N)'
     `wchar.h' (GNU):  *Note String/Array Comparison::.

`wchar_t * wcsncat (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)'
     `wchar.h' (ISO):  *Note Copying and Concatenation::.

`int wcsncmp (const wchar_t *WS1, const wchar_t *WS2, size_t SIZE)'
     `wchar.h' (ISO):  *Note String/Array Comparison::.

`wchar_t * wcsncpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)'
     `wchar.h' (ISO):  *Note Copying and Concatenation::.

`size_t wcsnlen (const wchar_t *WS, size_t MAXLEN)'
     `wchar.h' (GNU):  *Note String Length::.

`size_t wcsnrtombs (char *restrict DST, const wchar_t **restrict SRC, size_t NWC, size_t LEN, mbstate_t *restrict PS)'
     `wchar.h' (GNU):  *Note Converting Strings::.

`wchar_t * wcspbrk (const wchar_t *WSTRING, const wchar_t *STOPSET)'
     `wchar.h' (ISO):  *Note Search Functions::.

`wchar_t * wcsrchr (const wchar_t *WSTRING, wchar_t C)'
     `wchar.h' (ISO):  *Note Search Functions::.

`size_t wcsrtombs (char *restrict DST, const wchar_t **restrict SRC, size_t LEN, mbstate_t *restrict PS)'
     `wchar.h' (ISO):  *Note Converting Strings::.

`size_t wcsspn (const wchar_t *WSTRING, const wchar_t *SKIPSET)'
     `wchar.h' (ISO):  *Note Search Functions::.

`wchar_t * wcsstr (const wchar_t *HAYSTACK, const wchar_t *NEEDLE)'
     `wchar.h' (ISO):  *Note Search Functions::.

`double wcstod (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR)'
     `wchar.h' (ISO):  *Note Parsing of Floats::.

`float wcstof (const wchar_t *STRING, wchar_t **TAILPTR)'
     `stdlib.h' (ISO):  *Note Parsing of Floats::.

`intmax_t wcstoimax (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (ISO):  *Note Parsing of Integers::.

`wchar_t * wcstok (wchar_t *NEWSTRING, const char *DELIMITERS)'
     `wchar.h' (ISO):  *Note Finding Tokens in a String::.

`long int wcstol (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (ISO):  *Note Parsing of Integers::.

`long double wcstold (const wchar_t *STRING, wchar_t **TAILPTR)'
     `stdlib.h' (ISO):  *Note Parsing of Floats::.

`long long int wcstoll (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (ISO):  *Note Parsing of Integers::.

`size_t wcstombs (char *STRING, const wchar_t *WSTRING, size_t SIZE)'
     `stdlib.h' (ISO):  *Note Non-reentrant String Conversion::.

`long long int wcstoq (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (GNU):  *Note Parsing of Integers::.

`unsigned long int wcstoul (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (ISO):  *Note Parsing of Integers::.

`unsigned long long int wcstoull (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (ISO):  *Note Parsing of Integers::.

`uintmax_t wcstoumax (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (ISO):  *Note Parsing of Integers::.

`unsigned long long int wcstouq (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)'
     `wchar.h' (GNU):  *Note Parsing of Integers::.

`wchar_t * wcswcs (const wchar_t *HAYSTACK, const wchar_t *NEEDLE)'
     `wchar.h' (XPG):  *Note Search Functions::.

`size_t wcsxfrm (wchar_t *restrict WTO, const wchar_t *WFROM, size_t SIZE)'
     `wchar.h' (ISO):  *Note Collation Functions::.

`int wctob (wint_t C)'
     `wchar.h' (ISO):  *Note Converting a Character::.

`int wctomb (char *STRING, wchar_t WCHAR)'
     `stdlib.h' (ISO):  *Note Non-reentrant Character Conversion::.

`wctrans_t wctrans (const char *PROPERTY)'
     `wctype.h' (ISO):  *Note Wide Character Case Conversion::.

`wctrans_t'
     `wctype.h' (ISO):  *Note Wide Character Case Conversion::.

`wctype_t wctype (const char *PROPERTY)'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`wctype_t'
     `wctype.h' (ISO):  *Note Classification of Wide Characters::.

`int WEOF'
     `wchar.h' (ISO):  *Note EOF and Errors::.

`wint_t WEOF'
     `wchar.h' (ISO):  *Note Extended Char Intro::.

`int WEXITSTATUS (int STATUS)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion Status::.

`int WIFEXITED (int STATUS)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion Status::.

`int WIFSIGNALED (int STATUS)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion Status::.

`int WIFSTOPPED (int STATUS)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion Status::.

`wint_t'
     `wchar.h' (ISO):  *Note Extended Char Intro::.

`wchar_t * wmemchr (const wchar_t *BLOCK, wchar_t WC, size_t SIZE)'
     `wchar.h' (ISO):  *Note Search Functions::.

`int wmemcmp (const wchar_t *A1, const wchar_t *A2, size_t SIZE)'
     `wcjar.h' (ISO):  *Note String/Array Comparison::.

`wchar_t * wmemcpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)'
     `wchar.h' (ISO):  *Note Copying and Concatenation::.

`wchar_t * wmemmove (wchar *WTO, const wchar_t *WFROM, size_t SIZE)'
     `wchar.h' (ISO):  *Note Copying and Concatenation::.

`wchar_t * wmempcpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)'
     `wchar.h' (GNU):  *Note Copying and Concatenation::.

`wchar_t * wmemset (wchar_t *BLOCK, wchar_t WC, size_t SIZE)'
     `wchar.h' (ISO):  *Note Copying and Concatenation::.

`int W_OK'
     `unistd.h' (POSIX.1):  *Note Testing File Access::.

`int wordexp (const char *WORDS, wordexp_t *WORD-VECTOR-PTR, int FLAGS)'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`wordexp_t'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`void wordfree (wordexp_t *WORD-VECTOR-PTR)'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`int wprintf (const wchar_t *TEMPLATE, ...)'
     `wchar.h' (ISO):  *Note Formatted Output Functions::.

`WRDE_APPEND'
     `wordexp.h' (POSIX.2):  *Note Flags for Wordexp::.

`WRDE_BADCHAR'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`WRDE_BADVAL'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`WRDE_CMDSUB'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`WRDE_DOOFFS'
     `wordexp.h' (POSIX.2):  *Note Flags for Wordexp::.

`WRDE_NOCMD'
     `wordexp.h' (POSIX.2):  *Note Flags for Wordexp::.

`WRDE_NOSPACE'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`WRDE_REUSE'
     `wordexp.h' (POSIX.2):  *Note Flags for Wordexp::.

`WRDE_SHOWERR'
     `wordexp.h' (POSIX.2):  *Note Flags for Wordexp::.

`WRDE_SYNTAX'
     `wordexp.h' (POSIX.2):  *Note Calling Wordexp::.

`WRDE_UNDEF'
     `wordexp.h' (POSIX.2):  *Note Flags for Wordexp::.

`ssize_t write (int FILEDES, const void *BUFFER, size_t SIZE)'
     `unistd.h' (POSIX.1):  *Note I/O Primitives::.

`ssize_t writev (int FILEDES, const struct iovec *VECTOR, int COUNT)'
     `sys/uio.h' (BSD):  *Note Scatter-Gather::.

`int wscanf (const wchar_t *TEMPLATE, ...)'
     `wchar.h' (ISO):  *Note Formatted Input Functions::.

`int WSTOPSIG (int STATUS)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion Status::.

`int WTERMSIG (int STATUS)'
     `sys/wait.h' (POSIX.1):  *Note Process Completion Status::.

`int X_OK'
     `unistd.h' (POSIX.1):  *Note Testing File Access::.

`_XOPEN_SOURCE'
     (X/Open):  *Note Feature Test Macros::.

`_XOPEN_SOURCE_EXTENDED'
     (X/Open):  *Note Feature Test Macros::.

`double y0 (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float y0f (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double y0l (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`double y1 (double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float y1f (float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double y1l (long double X)'
     `math.h' (SVID):  *Note Special Functions::.

`double yn (int n, double X)'
     `math.h' (SVID):  *Note Special Functions::.

`float ynf (int n, float X)'
     `math.h' (SVID):  *Note Special Functions::.

`long double ynl (int n, long double X)'
     `math.h' (SVID):  *Note Special Functions::.



File: libc.info,  Node: Installation,  Next: Maintenance,  Prev: Library Summary,  Up: Top

Appendix C Installing the GNU C Library
***************************************

Before you do anything else, you should read the file `FAQ' located at
the top level of the source tree.  This file answers common questions
and describes problems you may experience with compilation and
installation.  It is updated more frequently than this manual.

   Features can be added to GNU Libc via "add-on" bundles.  These are
separate tar files, which you unpack into the top level of the source
tree.  Then you give `configure' the `--enable-add-ons' option to
activate them, and they will be compiled into the library.

   You will need recent versions of several GNU tools: definitely GCC
and GNU Make, and possibly others.  *Note Tools for Compilation::,
below.

* Menu:

* Configuring and compiling::   How to compile and test GNU libc.
* Running make install::        How to install it once you've got it
 compiled.
* Tools for Compilation::       You'll need these first.
* Linux::                       Specific advice for GNU/Linux systems.
* Reporting Bugs::              So they'll get fixed.


File: libc.info,  Node: Configuring and compiling,  Next: Running make install,  Up: Installation

C.1 Configuring and compiling GNU Libc
======================================

GNU libc cannot be compiled in the source directory.  You must build it
in a separate build directory.  For example, if you have unpacked the
glibc sources in `/src/gnu/glibc-2.4', create a directory
`/src/gnu/glibc-build' to put the object files in.  This allows
removing the whole build directory in case an error occurs, which is
the safest way to get a fresh start and should always be done.

   From your object directory, run the shell script `configure' located
at the top level of the source tree.  In the scenario above, you'd type

     $ ../glibc-2.4/configure ARGS...

   Please note that even though you're building in a separate build
directory, the compilation needs to modify a few files in the source
directory, especially some files in the manual subdirectory.

`configure' takes many options, but the only one that is usually
mandatory is `--prefix'.  This option tells `configure' where you want
glibc installed.  This defaults to `/usr/local', but the normal setting
to install as the standard system library is `--prefix=/usr' for
GNU/Linux systems and `--prefix=' (an empty prefix) for GNU/Hurd
systems.

   It may also be useful to set the CC and CFLAGS variables in the
environment when running `configure'.  CC selects the C compiler that
will be used, and CFLAGS sets optimization options for the compiler.

   The following list describes all of the available options for
`configure':

`--prefix=DIRECTORY'
     Install machine-independent data files in subdirectories of
     `DIRECTORY'.  The default is to install in `/usr/local'.

`--exec-prefix=DIRECTORY'
     Install the library and other machine-dependent files in
     subdirectories of `DIRECTORY'.  The default is to the `--prefix'
     directory if that option is specified, or `/usr/local' otherwise.

`--with-headers=DIRECTORY'
     Look for kernel header files in DIRECTORY, not `/usr/include'.
     Glibc needs information from the kernel's private header files.
     Glibc will normally look in `/usr/include' for them, but if you
     specify this option, it will look in DIRECTORY instead.

     This option is primarily of use on a system where the headers in
     `/usr/include' come from an older version of glibc.  Conflicts can
     occasionally happen in this case.  Note that Linux libc5 qualifies
     as an older version of glibc.  You can also use this option if you
     want to compile glibc with a newer set of kernel headers than the
     ones found in `/usr/include'.

`--enable-add-ons[=LIST]'
     Specify add-on packages to include in the build.  If this option is
     specified with no list, it enables all the add-on packages it
     finds in the main source directory; this is the default behavior.
     You may specify an explicit list of add-ons to use in LIST,
     separated by spaces or commas (if you use spaces, remember to
     quote them from the shell).  Each add-on in LIST can be an
     absolute directory name or can be a directory name relative to the
     main source directory, or relative to the build directory (that
     is, the current working directory).  For example,
     `--enable-add-ons=nptl,../glibc-libidn-2.4'.

`--enable-kernel=VERSION'
     This option is currently only useful on GNU/Linux systems.  The
     VERSION parameter should have the form X.Y.Z and describes the
     smallest version of the Linux kernel the generated library is
     expected to support.  The higher the VERSION number is, the less
     compatibility code is added, and the faster the code gets.

`--with-binutils=DIRECTORY'
     Use the binutils (assembler and linker) in `DIRECTORY', not the
     ones the C compiler would default to.  You can use this option if
     the default binutils on your system cannot deal with all the
     constructs in the GNU C library.  In that case, `configure' will
     detect the problem and suppress these constructs, so that the
     library will still be usable, but functionality may be lost--for
     example, you can't build a shared libc with old binutils.

`--without-fp'
     Use this option if your computer lacks hardware floating-point
     support and your operating system does not emulate an FPU.

     these

`--disable-shared'
     Don't build shared libraries even if it is possible.  Not all
     systems support shared libraries; you need ELF support and
     (currently) the GNU linker.

`--disable-profile'
     Don't build libraries with profiling information.  You may want to
     use this option if you don't plan to do profiling.

`--enable-omitfp'
     Use maximum optimization for the normal (static and shared)
     libraries, and compile separate static libraries with debugging
     information and no optimization.  We recommend not doing this.
     The extra optimization doesn't gain you much, it may provoke
     compiler bugs, and you won't be able to trace bugs through the C
     library.

`--disable-versioning'
     Don't compile the shared libraries with symbol version information.
     Doing this will make the resulting library incompatible with old
     binaries, so it's not recommended.

`--enable-static-nss'
     Compile static versions of the NSS (Name Service Switch) libraries.
     This is not recommended because it defeats the purpose of NSS; a
     program linked statically with the NSS libraries cannot be
     dynamically reconfigured to use a different name database.

`--without-tls'
     By default the C library is built with support for thread-local
     storage if the used tools support it.  By using `--without-tls'
     this can be prevented though there generally is no reason since it
     creates compatibility problems.

`--build=BUILD-SYSTEM'
`--host=HOST-SYSTEM'
     These options are for cross-compiling.  If you specify both
     options and BUILD-SYSTEM is different from HOST-SYSTEM, `configure'
     will prepare to cross-compile glibc from BUILD-SYSTEM to be used
     on HOST-SYSTEM.  You'll probably need the `--with-headers' option
     too, and you may have to override CONFIGURE's selection of the
     compiler and/or binutils.

     If you only specify `--host', `configure' will prepare for a
     native compile but use what you specify instead of guessing what
     your system is. This is most useful to change the CPU submodel.
     For example, if `configure' guesses your machine as
     `i586-pc-linux-gnu' but you want to compile a library for 386es,
     give `--host=i386-pc-linux-gnu' or just `--host=i386-linux' and add
     the appropriate compiler flags (`-mcpu=i386' will do the trick) to
     CFLAGS.

     If you specify just `--build', `configure' will get confused.

   To build the library and related programs, type `make'.  This will
produce a lot of output, some of which may look like errors from `make'
but isn't.  Look for error messages from `make' containing `***'.
Those indicate that something is seriously wrong.

   The compilation process can take a long time, depending on the
configuration and the speed of your machine.  Some complex modules may
take a very long time to compile, as much as several minutes on slower
machines.  Do not panic if the compiler appears to hang.

   If you want to run a parallel make, simply pass the `-j' option with
an appropriate numeric parameter to `make'.  You need a recent GNU
`make' version, though.

   To build and run test programs which exercise some of the library
facilities, type `make check'.  If it does not complete successfully,
do not use the built library, and report a bug after verifying that the
problem is not already known.  *Note Reporting Bugs::, for instructions
on reporting bugs.  Note that some of the tests assume they are not
being run by `root'.  We recommend you compile and test glibc as an
unprivileged user.

   Before reporting bugs make sure there is no problem with your system.
The tests (and later installation) use some pre-existing files of the
system such as `/etc/passwd', `/etc/nsswitch.conf' and others.  These
files must all contain correct and sensible content.

   To format the `GNU C Library Reference Manual' for printing, type
`make dvi'.  You need a working TeX installation to do this.  The
distribution already includes the on-line formatted version of the
manual, as Info files.  You can regenerate those with `make info', but
it shouldn't be necessary.

   The library has a number of special-purpose configuration parameters
which you can find in `Makeconfig'.  These can be overwritten with the
file `configparms'.  To change them, create a `configparms' in your
build directory and add values as appropriate for your system.  The
file is included and parsed by `make' and has to follow the conventions
for makefiles.

   It is easy to configure the GNU C library for cross-compilation by
setting a few variables in `configparms'.  Set `CC' to the
cross-compiler for the target you configured the library for; it is
important to use this same `CC' value when running `configure', like
this: `CC=TARGET-gcc configure TARGET'.  Set `BUILD_CC' to the compiler
to use for programs run on the build system as part of compiling the
library.  You may need to set `AR' and `RANLIB' to cross-compiling
versions of `ar' and `ranlib' if the native tools are not configured to
work with object files for the target you configured for.


File: libc.info,  Node: Running make install,  Next: Tools for Compilation,  Prev: Configuring and compiling,  Up: Installation

C.2 Installing the C Library
============================

To install the library and its header files, and the Info files of the
manual, type `env LANGUAGE=C LC_ALL=C make install'.  This will build
things, if necessary, before installing them; however, you should still
compile everything first.  If you are installing glibc as your primary
C library, we recommend that you shut the system down to single-user
mode first, and reboot afterward.  This minimizes the risk of breaking
things when the library changes out from underneath.

   If you're upgrading from Linux libc5 or some other C library, you
need to replace the `/usr/include' with a fresh directory before
installing it.  The new `/usr/include' should contain the Linux
headers, but nothing else.

   You must first build the library (`make'), optionally check it
(`make check'), switch the include directories and then install (`make
install').  The steps must be done in this order.  Not moving the
directory before install will result in an unusable mixture of header
files from both libraries, but configuring, building, and checking the
library requires the ability to compile and run programs against the old
library.

   If you are upgrading from a previous installation of glibc 2.0 or
2.1, `make install' will do the entire job.  You do not need to remove
the old includes - if you want to do so anyway you must then follow the
order given above.

   You may also need to reconfigure GCC to work with the new library.
The easiest way to do that is to figure out the compiler switches to
make it work again (`-Wl,--dynamic-linker=/lib/ld-linux.so.2' should
work on GNU/Linux systems) and use them to recompile gcc.  You can also
edit the specs file (`/usr/lib/gcc-lib/TARGET/VERSION/specs'), but that
is a bit of a black art.

   You can install glibc somewhere other than where you configured it
to go by setting the `install_root' variable on the command line for
`make install'.  The value of this variable is prepended to all the
paths for installation.  This is useful when setting up a chroot
environment or preparing a binary distribution.  The directory should be
specified with an absolute file name.

   Glibc 2.2 includes a daemon called `nscd', which you may or may not
want to run.  `nscd' caches name service lookups; it can dramatically
improve performance with NIS+, and may help with DNS as well.

   One auxiliary program, `/usr/libexec/pt_chown', is installed setuid
`root'.  This program is invoked by the `grantpt' function; it sets the
permissions on a pseudoterminal so it can be used by the calling
process.  This means programs like `xterm' and `screen' do not have to
be setuid to get a pty.  (There may be other reasons why they need
privileges.)  If you are using a 2.1 or newer Linux kernel with the
`devptsfs' or `devfs' filesystems providing pty slaves, you don't need
this program; otherwise you do.  The source for `pt_chown' is in
`login/programs/pt_chown.c'.

   After installation you might want to configure the timezone and
locale installation of your system.  The GNU C library comes with a
locale database which gets configured with `localedef'.  For example, to
set up a German locale with name `de_DE', simply issue the command
`localedef -i de_DE -f ISO-8859-1 de_DE'.  To configure all locales
that are supported by glibc, you can issue from your build directory the
command `make localedata/install-locales'.

   To configure the locally used timezone, set the `TZ' environment
variable.  The script `tzselect' helps you to select the right value.
As an example, for Germany, `tzselect' would tell you to use
`TZ='Europe/Berlin''.  For a system wide installation (the given paths
are for an installation with `--prefix=/usr'), link the timezone file
which is in `/usr/share/zoneinfo' to the file `/etc/localtime'.  For
Germany, you might execute `ln -s /usr/share/zoneinfo/Europe/Berlin
/etc/localtime'.


File: libc.info,  Node: Tools for Compilation,  Next: Linux,  Prev: Running make install,  Up: Installation

C.3 Recommended Tools for Compilation
=====================================

We recommend installing the following GNU tools before attempting to
build the GNU C library:

   * GNU `make' 3.79 or newer

     You need the latest version of GNU `make'.  Modifying the GNU C
     Library to work with other `make' programs would be so difficult
     that we recommend you port GNU `make' instead.  *Really.*  We
     recommend GNU `make' version 3.79.  All earlier versions have
     severe bugs or lack features.

   * GCC 3.4 or newer, GCC 4.1 recommended

     For the 2.4 release or later, GCC 3.4 or higher is required; as of
     this writing, GCC 4.4 is the compiler we advise to use for current
     versions.  On certain machines including `powerpc64', compilers
     prior to GCC 4.0 have bugs that prevent them compiling the C
     library code in the 2.4 release.  On other machines, GCC 4.1 is
     required to build the C library with support for the correct `long
     double' type format; these include `powerpc' (32 bit), `s390' and
     `s390x'.  For other architectures special compiler-provided
     headers are needed (like `cpuid.h' on x86) which only come with
     later compiler versions.

     You can use whatever compiler you like to compile programs that
     use GNU libc, but be aware that both GCC 2.7 and 2.8 have bugs in
     their floating-point support that may be triggered by the math
     library.

     Check the FAQ for any special compiler issues on particular
     platforms.

   * GNU `binutils' 2.15 or later

     You must use GNU `binutils' (as and ld) to build the GNU C library.
     No other assembler or linker has the necessary functionality at the
     moment.

   * GNU `texinfo' 3.12f

     To correctly translate and install the Texinfo documentation you
     need this version of the `texinfo' package.  Earlier versions do
     not understand all the tags used in the document, and the
     installation mechanism for the info files is not present or works
     differently.

   * GNU `awk' 3.0, or higher

     `Awk' is used in several places to generate files.  `gawk' 3.0 is
     known to work.

   * Perl 5

     Perl is not required, but it is used if present to test the
     installation.  We may decide to use it elsewhere in the future.

   * GNU `sed' 3.02 or newer

     `Sed' is used in several places to generate files.  Most scripts
     work with any version of `sed'.  The known exception is the script
     `po2test.sed' in the `intl' subdirectory which is used to generate
     `msgs.h' for the test suite.  This script works correctly only
     with GNU `sed' 3.02.  If you like to run the test suite, you
     should definitely upgrade `sed'.


If you change any of the `configure.in' files you will also need

   * GNU `autoconf' 2.53 or higher

and if you change any of the message translation files you will need

   * GNU `gettext' 0.10.36 or later

You may also need these packages if you upgrade your source tree using
patches, although we try to avoid this.


File: libc.info,  Node: Linux,  Next: Reporting Bugs,  Prev: Tools for Compilation,  Up: Installation

C.4 Specific advice for GNU/Linux systems
=========================================

If you are installing GNU libc on a GNU/Linux system, you need to have
the header files from a 2.2 or newer kernel around for reference.  For
some architectures, like ia64, sh and hppa, you need at least headers
from kernel 2.3.99 (sh and hppa) or 2.4.0 (ia64).  You do not need to
use that kernel, just have its headers where glibc can access at them.
The easiest way to do this is to unpack it in a directory such as
`/usr/src/linux-2.2.1'.  In that directory, run `make config' and
accept all the defaults.  Then run `make include/linux/version.h'.
Finally, configure glibc with the option
`--with-headers=/usr/src/linux-2.2.1/include'.  Use the most recent
kernel you can get your hands on.

   An alternate tactic is to unpack the 2.2 kernel and run `make
config' as above; then, rename or delete `/usr/include', create a new
`/usr/include', and make symbolic links of `/usr/include/linux' and
`/usr/include/asm' into the kernel sources.  You can then configure
glibc with no special options.  This tactic is recommended if you are
upgrading from libc5, since you need to get rid of the old header files
anyway.

   After installing GNU libc, you may need to remove or rename
`/usr/include/linux' and `/usr/include/asm', and replace them with
copies of `include/linux' and `include/asm-$ARCHITECTURE' taken from
the Linux source package which supplied kernel headers for building the
library.  ARCHITECTURE will be the machine architecture for which the
library was built, such as `i386' or `alpha'.  You do not need to do
this if you did not specify an alternate kernel header source using
`--with-headers'.  The intent here is that these directories should be
copies of, *not* symlinks to, the kernel headers used to build the
library.

   Note that `/usr/include/net' and `/usr/include/scsi' should *not* be
symlinks into the kernel sources.  GNU libc provides its own versions
of these files.

   GNU/Linux expects some components of the libc installation to be in
`/lib' and some in `/usr/lib'.  This is handled automatically if you
configure glibc with `--prefix=/usr'.  If you set some other prefix or
allow it to default to `/usr/local', then all the components are
installed there.

   If you are upgrading from libc5, you need to recompile every shared
library on your system against the new library for the sake of new code,
but keep the old libraries around for old binaries to use.  This is
complicated and difficult.  Consult the Glibc2 HOWTO at
`http://www.imaxx.net/~thrytis/glibc' for details.

   You cannot use `nscd' with 2.0 kernels, due to bugs in the
kernel-side thread support.  `nscd' happens to hit these bugs
particularly hard, but you might have problems with any threaded
program.


File: libc.info,  Node: Reporting Bugs,  Prev: Linux,  Up: Installation

C.5 Reporting Bugs
==================

There are probably bugs in the GNU C library.  There are certainly
errors and omissions in this manual.  If you report them, they will get
fixed.  If you don't, no one will ever know about them and they will
remain unfixed for all eternity, if not longer.

   It is a good idea to verify that the problem has not already been
reported.  Bugs are documented in two places: The file `BUGS' describes
a number of well known bugs and the bug tracking system has a WWW
interface at `http://sources.redhat.com/bugzilla/'.  The WWW interface
gives you access to open and closed reports.  A closed report normally
includes a patch or a hint on solving the problem.

   To report a bug, first you must find it.  With any luck, this will
be the hard part.  Once you've found a bug, make sure it's really a
bug.  A good way to do this is to see if the GNU C library behaves the
same way some other C library does.  If so, probably you are wrong and
the libraries are right (but not necessarily).  If not, one of the
libraries is probably wrong.  It might not be the GNU library.  Many
historical Unix C libraries permit things that we don't, such as
closing a file twice.

   If you think you have found some way in which the GNU C library does
not conform to the ISO and POSIX standards (*note Standards and
Portability::), that is definitely a bug.  Report it!

   Once you're sure you've found a bug, try to narrow it down to the
smallest test case that reproduces the problem.  In the case of a C
library, you really only need to narrow it down to one library function
call, if possible.  This should not be too difficult.

   The final step when you have a simple test case is to report the bug.
Do this using the WWW interface to the bug database.

   If you are not sure how a function should behave, and this manual
doesn't tell you, that's a bug in the manual.  Report that too!  If the
function's behavior disagrees with the manual, then either the library
or the manual has a bug, so report the disagreement.  If you find any
errors or omissions in this manual, please report them to the bug
database.  If you refer to specific sections of the manual, please
include the section names for easier identification.


File: libc.info,  Node: Maintenance,  Next: Contributors,  Prev: Installation,  Up: Top

Appendix D Library Maintenance
******************************

* Menu:

* Source Layout::         How to add new functions or header files
                             to the GNU C library.
* Porting::               How to port the GNU C library to
                             a new machine or operating system.


File: libc.info,  Node: Source Layout,  Next: Porting,  Up: Maintenance

D.1 Adding New Functions
========================

The process of building the library is driven by the makefiles, which
make heavy use of special features of GNU `make'.  The makefiles are
very complex, and you probably don't want to try to understand them.
But what they do is fairly straightforward, and only requires that you
define a few variables in the right places.

   The library sources are divided into subdirectories, grouped by
topic.

   The `string' subdirectory has all the string-manipulation functions,
`math' has all the mathematical functions, etc.

   Each subdirectory contains a simple makefile, called `Makefile',
which defines a few `make' variables and then includes the global
makefile `Rules' with a line like:

     include ../Rules

The basic variables that a subdirectory makefile defines are:

`subdir'
     The name of the subdirectory, for example `stdio'.  This variable
     *must* be defined.

`headers'
     The names of the header files in this section of the library, such
     as `stdio.h'.

`routines'
`aux'
     The names of the modules (source files) in this section of the
     library.  These should be simple names, such as `strlen' (rather
     than complete file names, such as `strlen.c').  Use `routines' for
     modules that define functions in the library, and `aux' for
     auxiliary modules containing things like data definitions.  But the
     values of `routines' and `aux' are just concatenated, so there
     really is no practical difference.

`tests'
     The names of test programs for this section of the library.  These
     should be simple names, such as `tester' (rather than complete file
     names, such as `tester.c').  `make tests' will build and run all
     the test programs.  If a test program needs input, put the test
     data in a file called `TEST-PROGRAM.input'; it will be given to
     the test program on its standard input.  If a test program wants
     to be run with arguments, put the arguments (all on a single line)
     in a file called `TEST-PROGRAM.args'.  Test programs should exit
     with zero status when the test passes, and nonzero status when the
     test indicates a bug in the library or error in building.

`others'
     The names of "other" programs associated with this section of the
     library.  These are programs which are not tests per se, but are
     other small programs included with the library.  They are built by
     `make others'.

`install-lib'
`install-data'
`install'
     Files to be installed by `make install'.  Files listed in
     `install-lib' are installed in the directory specified by `libdir'
     in `configparms' or `Makeconfig' (*note Installation::).  Files
     listed in `install-data' are installed in the directory specified
     by `datadir' in `configparms' or `Makeconfig'.  Files listed in
     `install' are installed in the directory specified by `bindir' in
     `configparms' or `Makeconfig'.

`distribute'
     Other files from this subdirectory which should be put into a
     distribution tar file.  You need not list here the makefile itself
     or the source and header files listed in the other standard
     variables.  Only define `distribute' if there are files used in an
     unusual way that should go into the distribution.

`generated'
     Files which are generated by `Makefile' in this subdirectory.
     These files will be removed by `make clean', and they will never
     go into a distribution.

`extra-objs'
     Extra object files which are built by `Makefile' in this
     subdirectory.  This should be a list of file names like `foo.o';
     the files will actually be found in whatever directory object
     files are being built in.  These files will be removed by
     `make clean'.  This variable is used for secondary object files
     needed to build `others' or `tests'.


File: libc.info,  Node: Porting,  Prev: Source Layout,  Up: Maintenance

D.2 Porting the GNU C Library
=============================

The GNU C library is written to be easily portable to a variety of
machines and operating systems.  Machine- and operating system-dependent
functions are well separated to make it easy to add implementations for
new machines or operating systems.  This section describes the layout of
the library source tree and explains the mechanisms used to select
machine-dependent code to use.

   All the machine-dependent and operating system-dependent files in the
library are in the subdirectory `sysdeps' under the top-level library
source directory.  This directory contains a hierarchy of
subdirectories (*note Hierarchy Conventions::).

   Each subdirectory of `sysdeps' contains source files for a
particular machine or operating system, or for a class of machine or
operating system (for example, systems by a particular vendor, or all
machines that use IEEE 754 floating-point format).  A configuration
specifies an ordered list of these subdirectories.  Each subdirectory
implicitly appends its parent directory to the list.  For example,
specifying the list `unix/bsd/vax' is equivalent to specifying the list
`unix/bsd/vax unix/bsd unix'.  A subdirectory can also specify that it
implies other subdirectories which are not directly above it in the
directory hierarchy.  If the file `Implies' exists in a subdirectory,
it lists other subdirectories of `sysdeps' which are appended to the
list, appearing after the subdirectory containing the `Implies' file.
Lines in an `Implies' file that begin with a `#' character are ignored
as comments.  For example, `unix/bsd/Implies' contains:
     # BSD has Internet-related things.
     unix/inet
   and `unix/Implies' contains:
     posix

So the final list is `unix/bsd/vax unix/bsd unix/inet unix posix'.

   `sysdeps' has a "special" subdirectory called `generic'.  It is
always implicitly appended to the list of subdirectories, so you
needn't put it in an `Implies' file, and you should not create any
subdirectories under it intended to be new specific categories.
`generic' serves two purposes.  First, the makefiles do not bother to
look for a system-dependent version of a file that's not in `generic'.
This means that any system-dependent source file must have an analogue
in `generic', even if the routines defined by that file are not
implemented on other platforms.  Second, the `generic' version of a
system-dependent file is used if the makefiles do not find a version
specific to the system you're compiling for.

   If it is possible to implement the routines in a `generic' file in
machine-independent C, using only other machine-independent functions in
the C library, then you should do so.  Otherwise, make them stubs.  A
"stub" function is a function which cannot be implemented on a
particular machine or operating system.  Stub functions always return an
error, and set `errno' to `ENOSYS' (Function not implemented).  *Note
Error Reporting::.  If you define a stub function, you must place the
statement `stub_warning(FUNCTION)', where FUNCTION is the name of your
function, after its definition; also, you must include the file
`<stub-tag.h>' into your file.  This causes the function to be listed
in the installed `<gnu/stubs.h>', and makes GNU ld warn when the
function is used.

   Some rare functions are only useful on specific systems and aren't
defined at all on others; these do not appear anywhere in the
system-independent source code or makefiles (including the `generic'
directory), only in the system-dependent `Makefile' in the specific
system's subdirectory.

   If you come across a file that is in one of the main source
directories (`string', `stdio', etc.), and you want to write a machine-
or operating system-dependent version of it, move the file into
`sysdeps/generic' and write your new implementation in the appropriate
system-specific subdirectory.  Note that if a file is to be
system-dependent, it *must not* appear in one of the main source
directories.

   There are a few special files that may exist in each subdirectory of
`sysdeps':

`Makefile'
     A makefile for this machine or operating system, or class of
     machine or operating system.  This file is included by the library
     makefile `Makerules', which is used by the top-level makefile and
     the subdirectory makefiles.  It can change the variables set in the
     including makefile or add new rules.  It can use GNU `make'
     conditional directives based on the variable `subdir' (see above)
     to select different sets of variables and rules for different
     sections of the library.  It can also set the `make' variable
     `sysdep-routines', to specify extra modules to be included in the
     library.  You should use `sysdep-routines' rather than adding
     modules to `routines' because the latter is used in determining
     what to distribute for each subdirectory of the main source tree.

     Each makefile in a subdirectory in the ordered list of
     subdirectories to be searched is included in order.  Since several
     system-dependent makefiles may be included, each should append to
     `sysdep-routines' rather than simply setting it:

          sysdep-routines := $(sysdep-routines) foo bar

`Subdirs'
     This file contains the names of new whole subdirectories under the
     top-level library source tree that should be included for this
     system.  These subdirectories are treated just like the
     system-independent subdirectories in the library source tree, such
     as `stdio' and `math'.

     Use this when there are completely new sets of functions and header
     files that should go into the library for the system this
     subdirectory of `sysdeps' implements.  For example,
     `sysdeps/unix/inet/Subdirs' contains `inet'; the `inet' directory
     contains various network-oriented operations which only make sense
     to put in the library on systems that support the Internet.

`configure'
     This file is a shell script fragment to be run at configuration
     time.  The top-level `configure' script uses the shell `.' command
     to read the `configure' file in each system-dependent directory
     chosen, in order.  The `configure' files are often generated from
     `configure.in' files using Autoconf.

     A system-dependent `configure' script will usually add things to
     the shell variables `DEFS' and `config_vars'; see the top-level
     `configure' script for details.  The script can check for
     `--with-PACKAGE' options that were passed to the top-level
     `configure'.  For an option `--with-PACKAGE=VALUE' `configure'
     sets the shell variable `with_PACKAGE' (with any dashes in PACKAGE
     converted to underscores) to VALUE; if the option is just
     `--with-PACKAGE' (no argument), then it sets `with_PACKAGE' to
     `yes'.

`configure.in'
     This file is an Autoconf input fragment to be processed into the
     file `configure' in this subdirectory.  *Note Introduction:
     (autoconf.info)Introduction, for a description of Autoconf.  You
     should write either `configure' or `configure.in', but not both.
     The first line of `configure.in' should invoke the `m4' macro
     `GLIBC_PROVIDES'.  This macro does several `AC_PROVIDE' calls for
     Autoconf macros which are used by the top-level `configure'
     script; without this, those macros might be invoked again
     unnecessarily by Autoconf.

   That is the general system for how system-dependencies are isolated.

* Menu:

* Hierarchy Conventions::       The layout of the `sysdeps' hierarchy.
* Porting to Unix::             Porting the library to an average
                                   Unix-like system.


File: libc.info,  Node: Hierarchy Conventions,  Next: Porting to Unix,  Up: Porting

D.2.1 Layout of the `sysdeps' Directory Hierarchy
-------------------------------------------------

A GNU configuration name has three parts: the CPU type, the
manufacturer's name, and the operating system.  `configure' uses these
to pick the list of system-dependent directories to look for.  If the
`--nfp' option is _not_ passed to `configure', the directory
`MACHINE/fpu' is also used.  The operating system often has a "base
operating system"; for example, if the operating system is `Linux', the
base operating system is `unix/sysv'.  The algorithm used to pick the
list of directories is simple: `configure' makes a list of the base
operating system, manufacturer, CPU type, and operating system, in that
order.  It then concatenates all these together with slashes in
between, to produce a directory name; for example, the configuration
`i686-linux-gnu' results in `unix/sysv/linux/i386/i686'.  `configure'
then tries removing each element of the list in turn, so
`unix/sysv/linux' and `unix/sysv' are also tried, among others.  Since
the precise version number of the operating system is often not
important, and it would be very inconvenient, for example, to have
identical `irix6.2' and `irix6.3' directories, `configure' tries
successively less specific operating system names by removing trailing
suffixes starting with a period.

   As an example, here is the complete list of directories that would be
tried for the configuration `i686-linux-gnu' (with the `crypt' and
`linuxthreads' add-on):

     sysdeps/i386/elf
     crypt/sysdeps/unix
     linuxthreads/sysdeps/unix/sysv/linux
     linuxthreads/sysdeps/pthread
     linuxthreads/sysdeps/unix/sysv
     linuxthreads/sysdeps/unix
     linuxthreads/sysdeps/i386/i686
     linuxthreads/sysdeps/i386
     linuxthreads/sysdeps/pthread/no-cmpxchg
     sysdeps/unix/sysv/linux/i386
     sysdeps/unix/sysv/linux
     sysdeps/gnu
     sysdeps/unix/common
     sysdeps/unix/mman
     sysdeps/unix/inet
     sysdeps/unix/sysv/i386/i686
     sysdeps/unix/sysv/i386
     sysdeps/unix/sysv
     sysdeps/unix/i386
     sysdeps/unix
     sysdeps/posix
     sysdeps/i386/i686
     sysdeps/i386/i486
     sysdeps/libm-i387/i686
     sysdeps/i386/fpu
     sysdeps/libm-i387
     sysdeps/i386
     sysdeps/wordsize-32
     sysdeps/ieee754
     sysdeps/libm-ieee754
     sysdeps/generic

   Different machine architectures are conventionally subdirectories at
the top level of the `sysdeps' directory tree.  For example,
`sysdeps/sparc' and `sysdeps/m68k'.  These contain files specific to
those machine architectures, but not specific to any particular
operating system.  There might be subdirectories for specializations of
those architectures, such as `sysdeps/m68k/68020'. Code which is
specific to the floating-point coprocessor used with a particular
machine should go in `sysdeps/MACHINE/fpu'.

   There are a few directories at the top level of the `sysdeps'
hierarchy that are not for particular machine architectures.

`generic'
     As described above (*note Porting::), this is the subdirectory
     that every configuration implicitly uses after all others.

`ieee754'
     This directory is for code using the IEEE 754 floating-point
     format, where the C type `float' is IEEE 754 single-precision
     format, and `double' is IEEE 754 double-precision format.  Usually
     this directory is referred to in the `Implies' file in a machine
     architecture-specific directory, such as `m68k/Implies'.

`libm-ieee754'
     This directory contains an implementation of a mathematical library
     usable on platforms which use IEEE 754 conformant floating-point
     arithmetic.

`libm-i387'
     This is a special case.  Ideally the code should be in
     `sysdeps/i386/fpu' but for various reasons it is kept aside.

`posix'
     This directory contains implementations of things in the library in
     terms of POSIX.1 functions.  This includes some of the POSIX.1
     functions themselves.  Of course, POSIX.1 cannot be completely
     implemented in terms of itself, so a configuration using just
     `posix' cannot be complete.

`unix'
     This is the directory for Unix-like things.  *Note Porting to
     Unix::.  `unix' implies `posix'.  There are some special-purpose
     subdirectories of `unix':

    `unix/common'
          This directory is for things common to both BSD and System V
          release 4.  Both `unix/bsd' and `unix/sysv/sysv4' imply
          `unix/common'.

    `unix/inet'
          This directory is for `socket' and related functions on Unix
          systems.  `unix/inet/Subdirs' enables the `inet' top-level
          subdirectory.  `unix/common' implies `unix/inet'.

`mach'
     This is the directory for things based on the Mach microkernel
     from CMU (including the GNU operating system).  Other basic
     operating systems (VMS, for example) would have their own
     directories at the top level of the `sysdeps' hierarchy, parallel
     to `unix' and `mach'.


File: libc.info,  Node: Porting to Unix,  Prev: Hierarchy Conventions,  Up: Porting

D.2.2 Porting the GNU C Library to Unix Systems
-----------------------------------------------

Most Unix systems are fundamentally very similar.  There are variations
between different machines, and variations in what facilities are
provided by the kernel.  But the interface to the operating system
facilities is, for the most part, pretty uniform and simple.

   The code for Unix systems is in the directory `unix', at the top
level of the `sysdeps' hierarchy.  This directory contains
subdirectories (and subdirectory trees) for various Unix variants.

   The functions which are system calls in most Unix systems are
implemented in assembly code, which is generated automatically from
specifications in files named `syscalls.list'.  There are several such
files, one in `sysdeps/unix' and others in its subdirectories.  Some
special system calls are implemented in files that are named with a
suffix of `.S'; for example, `_exit.S'.  Files ending in `.S' are run
through the C preprocessor before being fed to the assembler.

   These files all use a set of macros that should be defined in
`sysdep.h'.  The `sysdep.h' file in `sysdeps/unix' partially defines
them; a `sysdep.h' file in another directory must finish defining them
for the particular machine and operating system variant.  See
`sysdeps/unix/sysdep.h' and the machine-specific `sysdep.h'
implementations to see what these macros are and what they should do.

   The system-specific makefile for the `unix' directory
(`sysdeps/unix/Makefile') gives rules to generate several files from
the Unix system you are building the library on (which is assumed to be
the target system you are building the library _for_).  All the
generated files are put in the directory where the object files are
kept; they should not affect the source tree itself.  The files
generated are `ioctls.h', `errnos.h', `sys/param.h', and `errlist.c'
(for the `stdio' section of the library).


File: libc.info,  Node: Contributors,  Next: Free Manuals,  Prev: Maintenance,  Up: Top

Appendix E Contributors to the GNU C Library
********************************************

The GNU C library was written originally by Roland McGrath, and is
currently maintained by Ulrich Drepper.  Some parts of the library were
contributed or worked on by other people.

   * The `getopt' function and related code was written by Richard
     Stallman, David J. MacKenzie, and Roland McGrath.

   * The merge sort function `qsort' was written by Michael J. Haertel.

   * The quick sort function used as a fallback by `qsort' was written
     by Douglas C. Schmidt.

   * The memory allocation functions `malloc', `realloc' and `free' and
     related code were written by Michael J. Haertel, Wolfram Gloger,
     and Doug Lea.

   * Fast implementations of many of the string functions (`memcpy',
     `strlen', etc.) were written by Torbjo"rn Granlund.

   * The `tar.h' header file was written by David J. MacKenzie.

   * The port to the MIPS DECStation running Ultrix 4
     (`mips-dec-ultrix4') was contributed by Brendan Kehoe and Ian
     Lance Taylor.

   * The DES encryption function `crypt' and related functions were
     contributed by Michael Glad.

   * The `ftw' and `nftw' functions were contributed by Ulrich Drepper.

   * The startup code to support SunOS shared libraries was contributed
     by Tom Quinn.

   * The `mktime' function was contributed by Paul Eggert.

   * The port to the Sequent Symmetry running Dynix version 3
     (`i386-sequent-bsd') was contributed by Jason Merrill.

   * The timezone support code is derived from the public-domain
     timezone package by Arthur David Olson and his many contributors.

   * The port to the DEC Alpha running OSF/1 (`alpha-dec-osf1') was
     contributed by Brendan Kehoe, using some code written by Roland
     McGrath.

   * The port to SGI machines running Irix 4 (`mips-sgi-irix4') was
     contributed by Tom Quinn.

   * The port of the Mach and Hurd code to the MIPS architecture
     (`mips-ANYTHING-gnu') was contributed by Kazumoto Kojima.

   * The floating-point printing function used by `printf' and friends
     and the floating-point reading function used by `scanf', `strtod'
     and friends were written by Ulrich Drepper.  The multi-precision
     integer functions used in those functions are taken from GNU MP,
     which was contributed by Torbjo"rn Granlund.

   * The internationalization support in the library, and the support
     programs `locale' and `localedef', were written by Ulrich Drepper.
     Ulrich Drepper adapted the support code for message catalogs
     (`libintl.h', etc.) from the GNU `gettext' package, which he also
     wrote.  He also contributed the `catgets' support and the entire
     suite of multi-byte and wide-character support functions
     (`wctype.h', `wchar.h', etc.).

   * The implementations of the `nsswitch.conf' mechanism and the files
     and DNS backends for it were designed and written by Ulrich
     Drepper and Roland McGrath, based on a backend interface defined
     by Peter Eriksson.

   * The port to Linux i386/ELF (`i386-ANYTHING-linux') was contributed
     by Ulrich Drepper, based in large part on work done in Hongjiu
     Lu's Linux version of the GNU C Library.

   * The port to Linux/m68k (`m68k-ANYTHING-linux') was contributed by
     Andreas Schwab.

   * The ports to Linux/ARM (`arm-ANYTHING-linuxaout') and ARM
     standalone (`arm-ANYTHING-none'), as well as parts of the IPv6
     support code, were contributed by Philip Blundell.

   * Richard Henderson contributed the ELF dynamic linking code and
     other support for the Alpha processor.

   * David Mosberger-Tang contributed the port to Linux/Alpha
     (`alpha-ANYTHING-linux').

   * The port to Linux on PowerPC (`powerpc-ANYTHING-linux') was
     contributed by Geoffrey Keating.

   * Miles Bader wrote the argp argument-parsing package, and the
     argz/envz interfaces.

   * Stephen R. van den Berg contributed a highly-optimized `strstr'
     function.

   * Ulrich Drepper contributed the `hsearch' and `drand48' families of
     functions; reentrant `...`_r'' versions of the `random' family;
     System V shared memory and IPC support code; and several
     highly-optimized string functions for iX86 processors.

   * The math functions are taken from `fdlibm-5.1' by Sun
     Microsystems, as modified by J.T. Conklin, Ian Lance Taylor,
     Ulrich Drepper, Andreas Schwab, and Roland McGrath.

   * The `libio' library used to implement `stdio' functions on some
     platforms was written by Per Bothner and modified by Ulrich
     Drepper.

   * Eric Youngdale and Ulrich Drepper implemented versioning of
     objects on the symbol level.

   * Thorsten Kukuk provided an implementation for NIS (YP) and NIS+,
     securelevel 0, 1 and 2.

   * Andreas Jaeger provided a test suite for the math library.

   * Mark Kettenis implemented the utmpx interface and an utmp daemon.

   * Ulrich Drepper added character conversion functions (`iconv').

   * Thorsten Kukuk provided an implementation for a caching daemon for
     NSS (nscd).

   * Tim Waugh provided an implementation of the POSIX.2 wordexp
     function family.

   * Mark Kettenis provided a Hesiod NSS module.

   * The Internet-related code (most of the `inet' subdirectory) and
     several other miscellaneous functions and header files have been
     included from 4.4 BSD with little or no modification.  The copying
     permission notice for this code can be found in the file `LICENSES'
     in the source distribution.

   * The random number generation functions `random', `srandom',
     `setstate' and `initstate', which are also the basis for the
     `rand' and `srand' functions, were written by Earl T. Cohen for
     the University of California at Berkeley and are copyrighted by the
     Regents of the University of California.  They have undergone minor
     changes to fit into the GNU C library and to fit the ISO C
     standard, but the functional code is Berkeley's.

   * The DNS resolver code is taken directly from BIND 4.9.5, which
     includes copyrighted code from UC Berkeley and from Digital
     Equipment Corporation.  See the file `LICENSES' for the text of
     the DEC license.

   * The code to support Sun RPC is taken verbatim from Sun's
     RPCSRC-4.0 distribution; see the file `LICENSES' for the text of
     the license.

   * Some of the support code for Mach is taken from Mach 3.0 by CMU;
     the file if_ppp.h is also copyright by CMU, but under a different
     license; see the file `LICENSES' for the text of the licenses.

   * Many of the IA64 math functions are taken from a collection of
     "Highly Optimized Mathematical Functions for Itanium" that Intel
     makes available under a free license; see the file `LICENSES' for
     details.

   * The `getaddrinfo' and `getnameinfo' functions and supporting code
     were written by Craig Metz; see the file `LICENSES' for details on
     their licensing.

   * Many of the IEEE 64-bit double precision math functions (in the
     `sysdeps/ieee754/dbl-64' subdirectory) come from the IBM Accurate
     Mathematical Library, contributed by IBM.



File: libc.info,  Node: Free Manuals,  Next: Copying,  Prev: Contributors,  Up: Top

Appendix F Free Software Needs Free Documentation
*************************************************

The biggest deficiency in the free software community today is not in
the software--it is the lack of good free documentation that we can
include with the free software.  Many of our most important programs do
not come with free reference manuals and free introductory texts.
Documentation is an essential part of any software package; when an
important free software package does not come with a free manual and a
free tutorial, that is a major gap.  We have many such gaps today.

   Consider Perl, for instance.  The tutorial manuals that people
normally use are non-free.  How did this come about?  Because the
authors of those manuals published them with restrictive terms--no
copying, no modification, source files not available--which exclude
them from the free software world.

   That wasn't the first time this sort of thing happened, and it was
far from the last.  Many times we have heard a GNU user eagerly
describe a manual that he is writing, his intended contribution to the
community, only to learn that he had ruined everything by signing a
publication contract to make it non-free.

   Free documentation, like free software, is a matter of freedom, not
price.  The problem with the non-free manual is not that publishers
charge a price for printed copies--that in itself is fine.  (The Free
Software Foundation sells printed copies of manuals, too.)  The problem
is the restrictions on the use of the manual.  Free manuals are
available in source code form, and give you permission to copy and
modify.  Non-free manuals do not allow this.

   The criteria of freedom for a free manual are roughly the same as for
free software.  Redistribution (including the normal kinds of
commercial redistribution) must be permitted, so that the manual can
accompany every copy of the program, both on-line and on paper.

   Permission for modification of the technical content is crucial too.
When people modify the software, adding or changing features, if they
are conscientious they will change the manual too--so they can provide
accurate and clear documentation for the modified program.  A manual
that leaves you no choice but to write a new manual to document a
changed version of the program is not really available to our community.

   Some kinds of limits on the way modification is handled are
acceptable.  For example, requirements to preserve the original
author's copyright notice, the distribution terms, or the list of
authors, are ok.  It is also no problem to require modified versions to
include notice that they were modified.  Even entire sections that may
not be deleted or changed are acceptable, as long as they deal with
nontechnical topics (like this one).  These kinds of restrictions are
acceptable because they don't obstruct the community's normal use of
the manual.

   However, it must be possible to modify all the _technical_ content
of the manual, and then distribute the result in all the usual media,
through all the usual channels.  Otherwise, the restrictions obstruct
the use of the manual, it is not free, and we need another manual to
replace it.

   Please spread the word about this issue.  Our community continues to
lose manuals to proprietary publishing.  If we spread the word that
free software needs free reference manuals and free tutorials, perhaps
the next person who wants to contribute by writing documentation will
realize, before it is too late, that only free manuals contribute to
the free software community.

   If you are writing documentation, please insist on publishing it
under the GNU Free Documentation License or another free documentation
license.  Remember that this decision requires your approval--you don't
have to let the publisher decide.  Some commercial publishers will use
a free license if you insist, but they will not propose the option; it
is up to you to raise the issue and say firmly that this is what you
want.  If the publisher you are dealing with refuses, please try other
publishers.  If you're not sure whether a proposed license is free,
write to <licensing@gnu.org>.

   You can encourage commercial publishers to sell more free, copylefted
manuals and tutorials by buying them, and particularly by buying copies
from the publishers that paid for their writing or for major
improvements.  Meanwhile, try to avoid buying non-free documentation at
all.  Check the distribution terms of a manual before you buy it, and
insist that whoever seeks your business must respect your freedom.
Check the history of the book, and try reward the publishers that have
paid or pay the authors to work on it.

   The Free Software Foundation maintains a list of free documentation
published by other publishers, at
`http://www.fsf.org/doc/other-free-books.html'.


File: libc.info,  Node: Copying,  Next: Documentation License,  Prev: Free Manuals,  Up: Top

Appendix G GNU Lesser General Public License
********************************************

                      Version 2.1, February 1999

     Copyright (C) 1991, 1999 Free Software Foundation, Inc.
     59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

     [This is the first released version of the Lesser GPL.  It also counts
     as the successor of the GNU Library Public License, version 2, hence the
     version number 2.1.]

G.0.1 Preamble
--------------

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public Licenses
are intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.

   This license, the Lesser General Public License, applies to some
specially designated software--typically libraries--of the Free
Software Foundation and other authors who decide to use it.  You can use
it too, but we suggest you first think carefully about whether this
license or the ordinary General Public License is the better strategy to
use in any particular case, based on the explanations below.

   When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of it
in new free programs; and that you are informed that you can do these
things.

   To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

   For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

   We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

   To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know that
what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

   Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

   Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and is
quite different from the ordinary General Public License.  We use this
license for certain libraries in order to permit linking those
libraries into non-free programs.

   When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

   We call this license the "Lesser" General Public License because it
does _Less_ to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

   For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it
becomes a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

   In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of free
software.  For example, permission to use the GNU C Library in non-free
programs enables many more people to use the whole GNU operating
system, as well as its variant, the GNU/Linux operating system.

   Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run that
program using a modified version of the Library.

   The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                   GNU LESSER GENERAL PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License Agreement applies to any software library or other
     program which contains a notice placed by the copyright holder or
     other authorized party saying it may be distributed under the
     terms of this Lesser General Public License (also called "this
     License").  Each licensee is addressed as "you".

     A "library" means a collection of software functions and/or data
     prepared so as to be conveniently linked with application programs
     (which use some of those functions and data) to form executables.

     The "Library", below, refers to any such software library or work
     which has been distributed under these terms.  A "work based on the
     Library" means either the Library or any derivative work under
     copyright law: that is to say, a work containing the Library or a
     portion of it, either verbatim or with modifications and/or
     translated straightforwardly into another language.  (Hereinafter,
     translation is included without limitation in the term
     "modification".)

     "Source code" for a work means the preferred form of the work for
     making modifications to it.  For a library, complete source code
     means all the source code for all modules it contains, plus any
     associated interface definition files, plus the scripts used to
     control compilation and installation of the library.

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running a program using the Library is not restricted, and
     output from such a program is covered only if its contents
     constitute a work based on the Library (independent of the use of
     the Library in a tool for writing it).  Whether that is true
     depends on what the Library does and what the program that uses
     the Library does.

  1. You may copy and distribute verbatim copies of the Library's
     complete source code as you receive it, in any medium, provided
     that you conspicuously and appropriately publish on each copy an
     appropriate copyright notice and disclaimer of warranty; keep
     intact all the notices that refer to this License and to the
     absence of any warranty; and distribute a copy of this License
     along with the Library.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Library or any portion
     of it, thus forming a work based on the Library, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. The modified work must itself be a software library.

       b. You must cause the files modified to carry prominent notices
          stating that you changed the files and the date of any change.

       c. You must cause the whole of the work to be licensed at no
          charge to all third parties under the terms of this License.

       d. If a facility in the modified Library refers to a function or
          a table of data to be supplied by an application program that
          uses the facility, other than as an argument passed when the
          facility is invoked, then you must make a good faith effort
          to ensure that, in the event an application does not supply
          such function or table, the facility still operates, and
          performs whatever part of its purpose remains meaningful.

          (For example, a function in a library to compute square roots
          has a purpose that is entirely well-defined independent of the
          application.  Therefore, Subsection 2d requires that any
          application-supplied function or table used by this function
          must be optional: if the application does not supply it, the
          square root function must still compute square roots.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Library, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Library, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Library.

     In addition, mere aggregation of another work not based on the
     Library with the Library (or with a work based on the Library) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
     License instead of this License to a given copy of the Library.
     To do this, you must alter all the notices that refer to this
     License, so that they refer to the ordinary GNU General Public
     License, version 2, instead of to this License.  (If a newer
     version than version 2 of the ordinary GNU General Public License
     has appeared, then you can specify that version instead if you
     wish.)  Do not make any other change in these notices.

     Once this change is made in a given copy, it is irreversible for
     that copy, so the ordinary GNU General Public License applies to
     all subsequent copies and derivative works made from that copy.

     This option is useful when you wish to copy part of the code of
     the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
     derivative of it, under Section 2) in object code or executable
     form under the terms of Sections 1 and 2 above provided that you
     accompany it with the complete corresponding machine-readable
     source code, which must be distributed under the terms of Sections
     1 and 2 above on a medium customarily used for software
     interchange.

     If distribution of object code is made by offering access to copy
     from a designated place, then offering equivalent access to copy
     the source code from the same place satisfies the requirement to
     distribute the source code, even though third parties are not
     compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
     Library, but is designed to work with the Library by being
     compiled or linked with it, is called a "work that uses the
     Library".  Such a work, in isolation, is not a derivative work of
     the Library, and therefore falls outside the scope of this License.

     However, linking a "work that uses the Library" with the Library
     creates an executable that is a derivative of the Library (because
     it contains portions of the Library), rather than a "work that
     uses the library".  The executable is therefore covered by this
     License.  Section 6 states terms for distribution of such
     executables.

     When a "work that uses the Library" uses material from a header
     file that is part of the Library, the object code for the work may
     be a derivative work of the Library even though the source code is
     not.  Whether this is true is especially significant if the work
     can be linked without the Library, or if the work is itself a
     library.  The threshold for this to be true is not precisely
     defined by law.

     If such an object file uses only numerical parameters, data
     structure layouts and accessors, and small macros and small inline
     functions (ten lines or less in length), then the use of the object
     file is unrestricted, regardless of whether it is legally a
     derivative work.  (Executables containing this object code plus
     portions of the Library will still fall under Section 6.)

     Otherwise, if the work is a derivative of the Library, you may
     distribute the object code for the work under the terms of Section
     6.  Any executables containing that work also fall under Section 6,
     whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
     link a "work that uses the Library" with the Library to produce a
     work containing portions of the Library, and distribute that work
     under terms of your choice, provided that the terms permit
     modification of the work for the customer's own use and reverse
     engineering for debugging such modifications.

     You must give prominent notice with each copy of the work that the
     Library is used in it and that the Library and its use are covered
     by this License.  You must supply a copy of this License.  If the
     work during execution displays copyright notices, you must include
     the copyright notice for the Library among them, as well as a
     reference directing the user to the copy of this License.  Also,
     you must do one of these things:

       a. Accompany the work with the complete corresponding
          machine-readable source code for the Library including
          whatever changes were used in the work (which must be
          distributed under Sections 1 and 2 above); and, if the work
          is an executable linked with the Library, with the complete
          machine-readable "work that uses the Library", as object code
          and/or source code, so that the user can modify the Library
          and then relink to produce a modified executable containing
          the modified Library.  (It is understood that the user who
          changes the contents of definitions files in the Library will
          not necessarily be able to recompile the application to use
          the modified definitions.)

       b. Use a suitable shared library mechanism for linking with the
          Library.  A suitable mechanism is one that (1) uses at run
          time a copy of the library already present on the user's
          computer system, rather than copying library functions into
          the executable, and (2) will operate properly with a modified
          version of the library, if the user installs one, as long as
          the modified version is interface-compatible with the version
          that the work was made with.

       c. Accompany the work with a written offer, valid for at least
          three years, to give the same user the materials specified in
          Subsection 6a, above, for a charge no more than the cost of
          performing this distribution.

       d. If distribution of the work is made by offering access to copy
          from a designated place, offer equivalent access to copy the
          above specified materials from the same place.

       e. Verify that the user has already received a copy of these
          materials or that you have already sent this user a copy.

     For an executable, the required form of the "work that uses the
     Library" must include any data and utility programs needed for
     reproducing the executable from it.  However, as a special
     exception, the materials to be distributed need not include
     anything that is normally distributed (in either source or binary
     form) with the major components (compiler, kernel, and so on) of
     the operating system on which the executable runs, unless that
     component itself accompanies the executable.

     It may happen that this requirement contradicts the license
     restrictions of other proprietary libraries that do not normally
     accompany the operating system.  Such a contradiction means you
     cannot use both them and the Library together in an executable
     that you distribute.

  7. You may place library facilities that are a work based on the
     Library side-by-side in a single library together with other
     library facilities not covered by this License, and distribute
     such a combined library, provided that the separate distribution
     of the work based on the Library and of the other library
     facilities is otherwise permitted, and provided that you do these
     two things:

       a. Accompany the combined library with a copy of the same work
          based on the Library, uncombined with any other library
          facilities.  This must be distributed under the terms of the
          Sections above.

       b. Give prominent notice with the combined library of the fact
          that part of it is a work based on the Library, and explaining
          where to find the accompanying uncombined form of the same
          work.

  8. You may not copy, modify, sublicense, link with, or distribute the
     Library except as expressly provided under this License.  Any
     attempt otherwise to copy, modify, sublicense, link with, or
     distribute the Library is void, and will automatically terminate
     your rights under this License.  However, parties who have
     received copies, or rights, from you under this License will not
     have their licenses terminated so long as such parties remain in
     full compliance.

  9. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Library or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Library (or any work
     based on the Library), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Library or works based on it.

 10. Each time you redistribute the Library (or any work based on the
     Library), the recipient automatically receives a license from the
     original licensor to copy, distribute, link with or modify the
     Library subject to these terms and conditions.  You may not impose
     any further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties with this License.

 11. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Library at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Library by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Library.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply, and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

 12. If the distribution and/or use of the Library is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Library under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

 13. The Free Software Foundation may publish revised and/or new
     versions of the Lesser General Public License from time to time.
     Such new versions will be similar in spirit to the present version,
     but may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Library specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Library
     does not specify a license version number, you may choose any
     version ever published by the Free Software Foundation.

 14. If you wish to incorporate parts of the Library into other free
     programs whose distribution conditions are incompatible with these,
     write to the author to ask for permission.  For software which is
     copyrighted by the Free Software Foundation, write to the Free
     Software Foundation; we sometimes make exceptions for this.  Our
     decision will be guided by the two goals of preserving the free
     status of all derivatives of our free software and of promoting
     the sharing and reuse of software generally.

                                NO WARRANTY
 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU.  SHOULD THE
     LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY
     OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
G.0.2 How to Apply These Terms to Your New Libraries
----------------------------------------------------

If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of
the ordinary General Public License).

   To apply these terms, attach the following notices to the library.
It is safest to attach them to the start of each source file to most
effectively convey the exclusion of warranty; and each file should have
at least the "copyright" line and a pointer to where the full notice is
found.

     ONE LINE TO GIVE THE LIBRARY'S NAME AND AN IDEA OF WHAT IT DOES.
     Copyright (C) YEAR  NAME OF AUTHOR

     This library is free software; you can redistribute it and/or modify it
     under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation; either version 2.1 of the License, or (at
     your option) any later version.

     This library is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Lesser General Public License for more details.

     You should have received a copy of the GNU Lesser General Public
     License along with this library; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
     USA.

   Also add information on how to contact you by electronic and paper
mail.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the library,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the library
     `Frob' (a library for tweaking knobs) written by James Random Hacker.

     SIGNATURE OF TY COON, 1 April 1990
     Ty Coon, President of Vice

   That's all there is to it!


File: libc.info,  Node: Documentation License,  Next: Concept Index,  Prev: Copying,  Up: Top

Appendix H GNU Free Documentation License
*****************************************

                        Version 1.1, March 2000

     Copyright (C) 2000 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you".

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has less than five).

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section entitled "History", and its title, and
          add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. In any section entitled "Acknowledgments" or "Dedications",
          preserve the section's title, and preserve in the section all
          the substance and tone of each of the contributor
          acknowledgments and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section as "Endorsements" or to
          conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgments", and any sections entitled "Dedications".  You
     must delete all sections entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.

H.0.1 ADDENDUM: How to use this License for your documents
----------------------------------------------------------

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.1
       or any later version published by the Free Software Foundation;
       with the Invariant Sections being LIST THEIR TITLES, with the
       Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
       A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no Front-Cover
Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
LIST"; likewise for Back-Cover Texts.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: libc.info,  Node: Concept Index,  Next: Type Index,  Prev: Documentation License,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* /etc/hostname:                         Host Identification. (line  86)
* /etc/nsswitch.conf:                    NSS Configuration File.
                                                              (line   6)
* 4.N BSD Unix:                          Berkeley Unix.       (line   6)
* __va_copy:                             Copying and Concatenation.
                                                              (line 447)
* _POSIX_OPTION_ORDER environment variable.: Standard Environment.
                                                              (line 104)
* _POSIX_SAVED_IDS:                      How Change Persona.  (line   6)
* abort signal:                          Program Error Signals.
                                                              (line 135)
* aborting a program:                    Aborting a Program.  (line   6)
* absolute file name:                    File Name Resolution.
                                                              (line  19)
* absolute priority:                     Absolute Priority.   (line   6)
* absolute value functions:              Absolute Value.      (line   6)
* accepting connections:                 Accepting Connections.
                                                              (line   6)
* access permission for a file:          Access Permission.   (line   6)
* access, testing for:                   Testing File Access. (line   6)
* accessing directories:                 Accessing Directories.
                                                              (line   6)
* address of socket:                     Socket Addresses.    (line   6)
* address space <1>:                     Memory Subsystem.    (line   6)
* address space:                         Program Basics.      (line   6)
* alarm signal:                          Alarm Signals.       (line  19)
* alarms, setting:                       Setting an Alarm.    (line  10)
* alignment (in obstacks):               Obstacks Data Alignment.
                                                              (line   6)
* alignment (with malloc):               Aligned Memory Blocks.
                                                              (line   6)
* alloca disadvantages:                  Disadvantages of Alloca.
                                                              (line   6)
* alloca function:                       Variable Size Automatic.
                                                              (line   6)
* allocating pseudo-terminals:           Allocation.          (line   6)
* allocation (obstacks):                 Allocation in an Obstack.
                                                              (line   6)
* allocation debugging:                  Allocation Debugging.
                                                              (line   6)
* allocation hooks, for malloc:          Hooks for Malloc.    (line   6)
* allocation of memory with malloc:      Basic Allocation.    (line   6)
* allocation size of string:             Representation of Strings.
                                                              (line  56)
* allocation statistics:                 Statistics of Malloc.
                                                              (line   6)
* alphabetic character <1>:              Classification of Wide Characters.
                                                              (line  80)
* alphabetic character:                  Classification of Characters.
                                                              (line  35)
* alphanumeric character <1>:            Classification of Characters.
                                                              (line  48)
* alphanumeric character:                Classification of Wide Characters.
                                                              (line  68)
* append-access files:                   File Position.       (line  29)
* argc (program argument count):         Program Arguments.   (line  16)
* argp (program argument parser):        Argp.                (line   6)
* argp parser functions:                 Argp Parser Functions.
                                                              (line  13)
* ARGP_HELP_FMT environment variable:    Argp User Customization.
                                                              (line   6)
* argument parsing with argp:            Argp.                (line   6)
* argument promotion:                    Calling Variadics.   (line  27)
* argument vectors, null-character separated: Argz and Envz Vectors.
                                                              (line   6)
* arguments (variadic functions):        Receiving Arguments. (line   6)
* arguments, how many:                   How Many Arguments.  (line   6)
* arguments, to program:                 Program Arguments.   (line   6)
* argv (program argument vector):        Program Arguments.   (line  16)
* argz vectors (string vectors):         Argz and Envz Vectors.
                                                              (line   6)
* arithmetic expansion:                  Expansion Stages.    (line  22)
* array comparison functions:            String/Array Comparison.
                                                              (line   6)
* array copy functions:                  Copying and Concatenation.
                                                              (line  10)
* array search function:                 Array Search Function.
                                                              (line   6)
* array sort function:                   Array Sort Function. (line   6)
* ASCII character:                       Classification of Characters.
                                                              (line 103)
* assertions:                            Consistency Checking.
                                                              (line   6)
* attributes of a file:                  Attribute Meanings.  (line   6)
* automatic freeing:                     Variable Size Automatic.
                                                              (line   6)
* automatic memory allocation:           Memory Allocation and C.
                                                              (line  19)
* automatic storage class:               Memory Allocation and C.
                                                              (line  19)
* automatic storage with variable size:  Variable Size Automatic.
                                                              (line   6)
* background job:                        Concepts of Job Control.
                                                              (line  49)
* background job, launching:             Foreground and Background.
                                                              (line  62)
* backtrace:                             Backtraces.          (line   6)
* backtrace_fd:                          Backtraces.          (line   6)
* backtrace_symbols:                     Backtraces.          (line   6)
* base (of floating point number):       Floating Point Concepts.
                                                              (line  20)
* baud rate:                             Line Speed.          (line   6)
* Berkeley Unix:                         Berkeley Unix.       (line   6)
* Bessel functions:                      Special Functions.   (line   6)
* bias (of floating point number exponent): Floating Point Concepts.
                                                              (line  27)
* big-endian:                            Byte Order.          (line   6)
* binary I/O to a stream:                Block Input/Output.  (line   9)
* binary search function (for arrays):   Array Search Function.
                                                              (line   6)
* binary stream:                         Binary Streams.      (line  13)
* binding a socket address:              Socket Addresses.    (line   6)
* blank character <1>:                   Classification of Wide Characters.
                                                              (line 221)
* blank character:                       Classification of Characters.
                                                              (line  85)
* block I/O to a stream:                 Block Input/Output.  (line   9)
* blocked signals:                       Delivery of Signal.  (line   6)
* blocked signals, checking for:         Checking for Pending Signals.
                                                              (line   6)
* blocking signals:                      Blocking Signals.    (line   6)
* blocking signals, in a handler:        Blocking for Handler.
                                                              (line   6)
* bootstrapping, and services:           Actions in the NSS configuration.
                                                              (line  72)
* break condition, detecting:            Input Modes.         (line  58)
* break condition, generating:           Line Control.        (line  14)
* breaking a string into tokens:         Finding Tokens in a String.
                                                              (line   6)
* broken pipe signal:                    Operation Error Signals.
                                                              (line  13)
* broken-down time <1>:                  Broken-down Time.    (line   6)
* broken-down time:                      Calendar Time.       (line  26)
* BSD compatibility library:             Process Group Functions.
                                                              (line  55)
* BSD compatibility library.:            Feature Test Macros. (line  88)
* BSD Unix:                              Berkeley Unix.       (line   6)
* buffering of streams:                  Stream Buffering.    (line   6)
* buffering, controlling:                Controlling Buffering.
                                                              (line   8)
* bugs, reporting:                       Reporting Bugs.      (line   6)
* bus error:                             Program Error Signals.
                                                              (line 133)
* butterfly:                             Misc FP Arithmetic.  (line  43)
* byte order conversion, for socket:     Byte Order.          (line   6)
* byte stream:                           Socket Concepts.     (line  12)
* C++ streams:                           Streams and I18N.    (line  30)
* calendar time:                         Time Basics.         (line  13)
* calendar time and broken-down time:    Broken-down Time.    (line   6)
* calendar, Gregorian:                   Calendar Time.       (line  26)
* calling variadic functions:            Calling Variadics.   (line   6)
* canonical input processing:            Canonical or Not.    (line   9)
* capacity limits, POSIX:                General Limits.      (line   6)
* carrier detect:                        Control Modes.       (line  21)
* case conversion of characters:         Case Conversion.     (line   6)
* catching signals:                      Delivery of Signal.  (line  13)
* categories for locales:                Locale Categories.   (line   6)
* change working directory:              Working Directory.   (line   6)
* changing the locale:                   Setting the Locale.  (line  18)
* changing the size of a block (malloc): Changing Block Size. (line   6)
* changing the size of a block (obstacks): Growing Objects.   (line   6)
* channels:                              Stream/Descriptor Precautions.
                                                              (line   6)
* character case conversion:             Case Conversion.     (line   6)
* character predicates:                  Classification of Characters.
                                                              (line   6)
* character testing:                     Classification of Characters.
                                                              (line   6)
* checking for pending signals:          Checking for Pending Signals.
                                                              (line   6)
* child process <1>:                     Process Creation Concepts.
                                                              (line  15)
* child process <2>:                     Processor Time.      (line  31)
* child process:                         Processes.           (line  13)
* child process signal:                  Job Control Signals. (line  14)
* chunks:                                Obstack Chunks.      (line   6)
* classes, floating-point:               Floating Point Classes.
                                                              (line   6)
* classification of characters:          Classification of Characters.
                                                              (line   6)
* cleaning up a stream:                  Linked Channels.     (line  15)
* clearing terminal input queue:         Line Control.        (line  59)
* client:                                Connections.         (line   6)
* clock ticks:                           Processor And CPU Time.
                                                              (line  19)
* clock, high accuracy:                  High Accuracy Clock. (line   6)
* close-on-exec (file descriptor flag):  Descriptor Flags.    (line  52)
* closing a file descriptor:             Opening and Closing Files.
                                                              (line   6)
* closing a socket:                      Closing a Socket.    (line   6)
* closing a stream:                      Closing Streams.     (line   6)
* collating strings:                     Collation Functions. (line   6)
* combining locales:                     Choosing Locale.     (line  17)
* command argument syntax:               Argument Syntax.     (line   6)
* command arguments, parsing:            Parsing Program Arguments.
                                                              (line   6)
* command line arguments:                Program Arguments.   (line   6)
* command substitution:                  Expansion Stages.    (line  18)
* communication style (of a socket):     Socket Concepts.     (line   6)
* comparing strings and arrays:          String/Array Comparison.
                                                              (line   6)
* Comparison Function:                   Comparison Functions.
                                                              (line   6)
* compiling:                             Configuring and compiling.
                                                              (line   6)
* complex exponentiation functions:      Exponents and Logarithms.
                                                              (line 160)
* complex logarithm functions:           Exponents and Logarithms.
                                                              (line 160)
* complex numbers:                       Complex Numbers.     (line   6)
* complex trigonometric functions:       Trig Functions.      (line  56)
* concatenating strings:                 Copying and Concatenation.
                                                              (line  10)
* configuring:                           Configuring and compiling.
                                                              (line   6)
* conjugate complex numbers:             Operations on Complex.
                                                              (line   6)
* connecting a socket:                   Connecting.          (line   6)
* connection:                            Connections.         (line   6)
* consistency checking:                  Consistency Checking.
                                                              (line   6)
* consistency checking, of heap:         Heap Consistency Checking.
                                                              (line   6)
* constants <1>:                         Memory Concepts.     (line  67)
* constants:                             Mathematical Constants.
                                                              (line   6)
* continue signal:                       Job Control Signals. (line  28)
* control character <1>:                 Classification of Wide Characters.
                                                              (line  96)
* control character:                     Classification of Characters.
                                                              (line  99)
* control operations on files:           Control Operations.  (line   6)
* controlling process:                   Controlling Terminal.
                                                              (line  13)
* controlling terminal:                  Concepts of Job Control.
                                                              (line  42)
* controlling terminal, access to:       Access to the Terminal.
                                                              (line   6)
* controlling terminal, determining:     Identifying the Terminal.
                                                              (line   6)
* controlling terminal, setting:         Open-time Flags.     (line  54)
* conversion specifications (printf):    Formatted Output Basics.
                                                              (line  14)
* conversion specifications (scanf):     Formatted Input Basics.
                                                              (line  18)
* converting byte order:                 Byte Order.          (line   6)
* converting case of characters:         Case Conversion.     (line   6)
* converting file descriptor to stream:  Descriptors and Streams.
                                                              (line   6)
* converting floats to integers:         Rounding Functions.  (line   6)
* converting group ID to group name:     Lookup Group.        (line   6)
* converting group name to group ID:     Lookup Group.        (line   6)
* converting host address to name:       Host Names.          (line   6)
* converting host name to address:       Host Names.          (line   6)
* converting network name to network number: Networks Database.
                                                              (line   6)
* converting network number to network name: Networks Database.
                                                              (line   6)
* converting port number to service name: Services Database.  (line   6)
* converting service name to port number: Services Database.  (line   6)
* converting string to collation order:  Collation Functions. (line  74)
* converting strings to numbers:         Parsing of Numbers.  (line   6)
* converting user ID to user name:       Lookup User.         (line   6)
* converting user name to user ID:       Lookup User.         (line   6)
* cookie, for custom stream:             Streams and Cookies. (line   6)
* copy-on-write page fault:              Locked Memory Details.
                                                              (line  40)
* copying strings and arrays:            Copying and Concatenation.
                                                              (line  10)
* cpu priority:                          Priority.            (line   6)
* CPU time <1>:                          Processor And CPU Time.
                                                              (line  19)
* CPU time <2>:                          Time Basics.         (line  37)
* CPU time:                              Processor Time.      (line   9)
* create on open (file status flag):     Open-time Flags.     (line  22)
* creating a directory:                  Creating Directories.
                                                              (line   6)
* creating a FIFO special file:          FIFO Special Files.  (line   6)
* creating a pipe:                       Creating a Pipe.     (line   6)
* creating a pipe to a subprocess:       Pipe to a Subprocess.
                                                              (line   6)
* creating a process:                    Process Creation Concepts.
                                                              (line  15)
* creating a socket:                     Creating a Socket.   (line   6)
* creating a socket pair:                Socket Pairs.        (line   6)
* creating special files:                Making Special Files.
                                                              (line   6)
* cube root function:                    Exponents and Logarithms.
                                                              (line 130)
* currency symbols:                      Currency Symbol.     (line   6)
* current limit:                         Limits on Resources. (line  17)
* current working directory:             Working Directory.   (line   6)
* custom streams:                        Custom Streams.      (line   6)
* customizing printf:                    Customizing Printf.  (line   6)
* data loss on sockets:                  Socket Concepts.     (line  17)
* databases:                             Name Service Switch. (line   6)
* datagram socket:                       Datagrams.           (line   6)
* datagrams, transmitting:               Sending Datagrams.   (line   6)
* date:                                  Time Basics.         (line  16)
* Daylight Saving Time:                  Broken-down Time.    (line  62)
* decimal digit character:               Classification of Characters.
                                                              (line  45)
* decimal-point separator:               General Numeric.     (line  13)
* declaration (compared to definition):  Header Files.        (line  17)
* declaring variadic functions:          Calling Variadics.   (line   6)
* decompose complex numbers:             Operations on Complex.
                                                              (line   6)
* default action (for a signal):         Delivery of Signal.  (line  13)
* default action for a signal:           Basic Signal Handling.
                                                              (line  35)
* default argument promotions:           Calling Variadics.   (line  27)
* default value, and NSS:                Notes on NSS Configuration File.
                                                              (line  11)
* defining new printf conversions:       Customizing Printf.  (line   6)
* definition (compared to declaration):  Header Files.        (line  17)
* delayed suspend character:             Signal Characters.   (line  53)
* deleting a directory:                  Deleting Files.      (line  52)
* deleting a file:                       Deleting Files.      (line   6)
* delivery of signals:                   Delivery of Signal.  (line   6)
* descriptors and streams:               Stream/Descriptor Precautions.
                                                              (line   6)
* digit character <1>:                   Classification of Wide Characters.
                                                              (line 106)
* digit character:                       Classification of Characters.
                                                              (line  45)
* directories, accessing:                Accessing Directories.
                                                              (line   6)
* directories, creating:                 Creating Directories.
                                                              (line   6)
* directories, deleting:                 Deleting Files.      (line  52)
* directory:                             Directories.         (line   9)
* directory entry:                       Directories.         (line   9)
* directory hierarchy:                   Working with Directory Trees.
                                                              (line   6)
* directory stream:                      Accessing Directories.
                                                              (line  10)
* disadvantages of alloca:               Disadvantages of Alloca.
                                                              (line   6)
* DISCARD character:                     Other Special.       (line  23)
* division by zero:                      FP Exceptions.       (line   6)
* DNS:                                   Host Identification. (line  17)
* DNS server unavailable:                Actions in the NSS configuration.
                                                              (line  30)
* domain (of socket):                    Socket Concepts.     (line  33)
* domain error:                          Math Error Reporting.
                                                              (line   6)
* domain name:                           Host Identification. (line  21)
* Domain Name System:                    Host Identification. (line  17)
* dot notation, for Internet addresses:  Abstract Host Addresses.
                                                              (line  48)
* DSUSP character:                       Signal Characters.   (line  53)
* duplicating file descriptors:          Duplicating Descriptors.
                                                              (line   6)
* dynamic memory allocation:             Memory Allocation and C.
                                                              (line  31)
* EBCDIC:                                Extended Char Intro. (line 156)
* echo of terminal input:                Local Modes.         (line  24)
* effective group ID:                    Process Persona.     (line   6)
* effective user ID:                     Process Persona.     (line   6)
* efficiency and malloc:                 Efficiency and Malloc.
                                                              (line   6)
* efficiency and obstacks:               Extra Fast Growing.  (line   6)
* efficiency of chunks:                  Obstack Chunks.      (line   6)
* EINTR, and restarting interrupted primitives: Interrupted Primitives.
                                                              (line  51)
* elapsed time <1>:                      Elapsed Time.        (line   6)
* elapsed time:                          Time Basics.         (line  24)
* encryption:                            Trivial Encryption.  (line   6)
* end of file, on a stream:              EOF and Errors.      (line   6)
* end-of-file, on a file descriptor:     I/O Primitives.      (line  21)
* environment:                           Environment Variables.
                                                              (line  22)
* environment access:                    Environment Access.  (line   6)
* environment representation:            Environment Access.  (line   6)
* environment variable:                  Environment Variables.
                                                              (line   6)
* environment vectors, null-character separated: Argz and Envz Vectors.
                                                              (line   9)
* envz vectors (environment vectors):    Argz and Envz Vectors.
                                                              (line   9)
* EOF character:                         Editing Characters.  (line  10)
* EOL character:                         Editing Characters.  (line  22)
* EOL2 character:                        Editing Characters.  (line  35)
* epoch:                                 Simple Calendar Time.
                                                              (line  10)
* ERASE character:                       Editing Characters.  (line  47)
* errno:                                 System Calls.        (line  55)
* error codes:                           Error Reporting.     (line   6)
* error messages, in argp:               Argp Helper Functions.
                                                              (line  23)
* error reporting:                       Error Reporting.     (line   6)
* errors, mathematical:                  Math Error Reporting.
                                                              (line   6)
* establishing a handler:                Signal Actions.      (line   6)
* ethers:                                NSS Basics.          (line  26)
* EUC:                                   Extended Char Intro. (line 188)
* EUC-JP:                                glibc iconv Implementation.
                                                              (line  53)
* exception <1>:                         FP Exceptions.       (line   6)
* exception:                             Program Error Signals.
                                                              (line  48)
* exclusive lock:                        File Locks.          (line  10)
* exec functions:                        Executing a File.    (line   6)
* execing a program:                     Memory Concepts.     (line  90)
* executable:                            Memory Concepts.     (line  67)
* executing a file:                      Executing a File.    (line   6)
* exit status:                           Exit Status.         (line   6)
* exit status value:                     Program Termination. (line   6)
* exiting a program:                     Memory Concepts.     (line  90)
* expansion of shell words:              Word Expansion.      (line   6)
* exponent (of floating point number):   Floating Point Concepts.
                                                              (line  23)
* exponentiation functions:              Exponents and Logarithms.
                                                              (line   6)
* extending printf:                      Customizing Printf.  (line   6)
* extracting file descriptor from stream: Descriptors and Streams.
                                                              (line   6)
* fcntl function:                        Control Operations.  (line   6)
* FDL, GNU Free Documentation License:   Documentation License.
                                                              (line   6)
* feature test macros:                   Feature Test Macros. (line   6)
* field splitting:                       Expansion Stages.    (line  25)
* FIFO special file:                     Pipes and FIFOs.     (line  12)
* file access permission:                Access Permission.   (line   6)
* file access time:                      File Times.          (line   6)
* file attribute modification time:      File Times.          (line   6)
* file attributes:                       Attribute Meanings.  (line   6)
* file creation mask:                    Setting Permissions. (line   6)
* file descriptor flags:                 Descriptor Flags.    (line   6)
* file descriptor sets, for select:      Waiting for I/O.     (line  30)
* file descriptors, standard:            Descriptors and Streams.
                                                              (line  49)
* file locks:                            File Locks.          (line   6)
* file modification time:                File Times.          (line   6)
* file name:                             File Names.          (line  14)
* file name component:                   Directories.         (line  15)
* file name errors:                      File Name Errors.    (line   6)
* file name resolution:                  File Name Resolution.
                                                              (line  10)
* file name translation flags:           Open-time Flags.     (line  14)
* file names, multiple:                  Hard Links.          (line   6)
* file owner:                            File Owner.          (line   6)
* file permission bits:                  Permission Bits.     (line  15)
* file pointer:                          Streams.             (line  12)
* file position:                         File Position.       (line  15)
* file positioning on a file descriptor: File Position Primitive.
                                                              (line  15)
* file positioning on a stream:          File Positioning.    (line   6)
* file status flags:                     File Status Flags.   (line   6)
* files, accessing:                      Memory Concepts.     (line  83)
* filtering i/o through subprocess:      Pipe to a Subprocess.
                                                              (line   6)
* flag character (printf):               Output Conversion Syntax.
                                                              (line  60)
* flag character (scanf):                Input Conversion Syntax.
                                                              (line  35)
* flags for sigaction:                   Flags for Sigaction. (line   6)
* flags, file name translation:          Open-time Flags.     (line  14)
* flags, open-time action:               Open-time Flags.     (line  17)
* floating point:                        Floating Point Numbers.
                                                              (line   6)
* floating point, IEEE:                  IEEE Floating Point. (line   6)
* floating type measurements:            Floating Type Macros.
                                                              (line   6)
* floating-point classes:                Floating Point Classes.
                                                              (line   6)
* floating-point exception:              Program Error Signals.
                                                              (line  48)
* flow control, terminal:                Line Control.        (line  93)
* flushing a stream:                     Flushing Buffers.    (line   6)
* flushing terminal output queue:        Line Control.        (line  34)
* foreground job:                        Concepts of Job Control.
                                                              (line  49)
* foreground job, launching:             Foreground and Background.
                                                              (line  10)
* forking a process:                     Process Creation Concepts.
                                                              (line  15)
* format string, for printf:             Formatted Output.    (line   6)
* format string, for scanf:              Formatted Input.     (line   6)
* formatted input from a stream:         Formatted Input.     (line   6)
* formatted messages:                    Formatted Messages.  (line   6)
* formatted output to a stream:          Formatted Output.    (line   6)
* FP arithmetic:                         FP Bit Twiddling.    (line   6)
* FQDN:                                  Host Identification. (line  32)
* frame, real memory:                    Memory Concepts.     (line  18)
* free documentation:                    Free Manuals.        (line   6)
* freeing (obstacks):                    Freeing Obstack Objects.
                                                              (line   6)
* freeing memory:                        Memory Concepts.     (line  90)
* freeing memory allocated with malloc:  Freeing after Malloc.
                                                              (line   6)
* fully buffered stream:                 Buffering Concepts.  (line  15)
* function prototypes (variadic):        Variadic Prototypes. (line   6)
* gamma function:                        Special Functions.   (line   6)
* gcvt_r:                                System V Number Conversion.
                                                              (line  82)
* gencat:                                The gencat program.  (line   6)
* generation of signals:                 Signal Generation.   (line   6)
* generic i/o control operations:        IOCTLs.              (line   6)
* globbing:                              Globbing.            (line   6)
* graphic character <1>:                 Classification of Characters.
                                                              (line  90)
* graphic character:                     Classification of Wide Characters.
                                                              (line 126)
* Gregorian calendar:                    Calendar Time.       (line  26)
* group:                                 NSS Basics.          (line  26)
* group database:                        Group Database.      (line   6)
* group ID:                              User and Group IDs.  (line  12)
* group name:                            User and Group IDs.  (line  12)
* group owner of a file:                 File Owner.          (line   6)
* grouping of digits:                    General Numeric.     (line  28)
* growing objects (in obstacks):         Growing Objects.     (line   6)
* handling multiple signals:             Merged Signals.      (line   6)
* hangup signal:                         Termination Signals. (line  72)
* hard limit:                            Limits on Resources. (line  24)
* hard link:                             Hard Links.          (line   6)
* header files:                          Header Files.        (line   6)
* heap consistency checking:             Heap Consistency Checking.
                                                              (line   6)
* heap, dynamic allocation from:         Unconstrained Allocation.
                                                              (line   6)
* heap, freeing memory from:             Freeing after Malloc.
                                                              (line   6)
* hexadecimal digit character <1>:       Classification of Wide Characters.
                                                              (line 206)
* hexadecimal digit character:           Classification of Characters.
                                                              (line  53)
* hidden bit (of floating point number mantissa): Floating Point Concepts.
                                                              (line  42)
* hierarchy, directory:                  Working with Directory Trees.
                                                              (line   6)
* high-priority data:                    Out-of-Band Data.    (line   6)
* high-resolution time:                  Calendar Time.       (line  20)
* holes in files:                        File Position Primitive.
                                                              (line  60)
* home directory:                        Standard Environment.
                                                              (line  12)
* HOME environment variable:             Standard Environment.
                                                              (line  12)
* hook functions (of custom streams):    Hook Functions.      (line   6)
* host address, Internet:                Abstract Host Addresses.
                                                              (line   6)
* host name:                             Host Identification. (line  13)
* hostname:                              Host Identification. (line  19)
* hosts:                                 NSS Basics.          (line  26)
* hosts database:                        Host Names.          (line   6)
* how many arguments:                    How Many Arguments.  (line   6)
* hyperbolic functions:                  Hyperbolic Functions.
                                                              (line   6)
* identifying terminals:                 Is It a Terminal.    (line   6)
* IEEE 754:                              Floating Point Numbers.
                                                              (line   6)
* IEEE floating point:                   Floating Point Numbers.
                                                              (line   6)
* IEEE floating point representation:    IEEE Floating Point. (line   6)
* IEEE Std 1003.1:                       POSIX.               (line   6)
* IEEE Std 1003.2:                       POSIX.               (line   6)
* ignore action for a signal:            Basic Signal Handling.
                                                              (line  40)
* illegal instruction:                   Program Error Signals.
                                                              (line 106)
* impossible events:                     Consistency Checking.
                                                              (line   6)
* independent channels:                  Independent Channels.
                                                              (line   6)
* inexact exception:                     FP Exceptions.       (line   6)
* infinity:                              Infinity and NaN.    (line   6)
* initial signal actions:                Initial Signal Actions.
                                                              (line   6)
* inode number:                          Attribute Meanings.  (line 191)
* input available signal:                Asynchronous I/O Signals.
                                                              (line  13)
* input conversions, for scanf:          Table of Input Conversions.
                                                              (line   6)
* input from multiple files:             Waiting for I/O.     (line   6)
* installation tools:                    Tools for Compilation.
                                                              (line   6)
* installing:                            Running make install.
                                                              (line   6)
* integer:                               Integers.            (line   6)
* integer division functions:            Integer Division.    (line   6)
* integer type range:                    Range of Type.       (line   6)
* integer type width:                    Width of Type.       (line   6)
* interactive signals, from terminal:    Local Modes.         (line  94)
* interactive stop signal:               Job Control Signals. (line  57)
* internal representation:               Extended Char Intro. (line  12)
* internationalization:                  Locales.             (line  11)
* Internet host address:                 Abstract Host Addresses.
                                                              (line   6)
* Internet namespace, for sockets:       Internet Namespace.  (line   6)
* interprocess communication, with FIFO: FIFO Special Files.  (line   6)
* interprocess communication, with pipes: Creating a Pipe.    (line   6)
* interprocess communication, with signals: Kill Example.     (line   6)
* interprocess communication, with sockets: Sockets.          (line   9)
* interrupt character:                   Signal Characters.   (line  11)
* interrupt signal:                      Termination Signals. (line  30)
* interrupt-driven input:                Interrupt Input.     (line   6)
* interrupting primitives:               Interrupted Primitives.
                                                              (line  51)
* interval:                              Time Basics.         (line  20)
* interval timer, setting:               Setting an Alarm.    (line  10)
* INTR character:                        Signal Characters.   (line  11)
* invalid exception:                     FP Exceptions.       (line   6)
* inverse complex hyperbolic functions:  Hyperbolic Functions.
                                                              (line  72)
* inverse complex trigonometric functions: Inverse Trig Functions.
                                                              (line  60)
* inverse hyperbolic functions:          Hyperbolic Functions.
                                                              (line  51)
* inverse trigonometric functions:       Inverse Trig Functions.
                                                              (line   6)
* invocation of program:                 Program Arguments.   (line   6)
* IOCTLs:                                IOCTLs.              (line   6)
* ISO 10646:                             Extended Char Intro. (line  37)
* ISO 2022:                              Extended Char Intro. (line 179)
* ISO 6937:                              Extended Char Intro. (line 202)
* ISO C:                                 ISO C.               (line   6)
* ISO-2022-JP:                           glibc iconv Implementation.
                                                              (line  53)
* ISO/IEC 9945-1:                        POSIX.               (line   6)
* ISO/IEC 9945-2:                        POSIX.               (line   6)
* job:                                   Job Control.         (line   6)
* job control:                           Job Control.         (line   6)
* job control functions:                 Functions for Job Control.
                                                              (line   6)
* job control is optional:               Job Control is Optional.
                                                              (line   6)
* job control signals:                   Job Control Signals. (line   6)
* job control, enabling:                 Initializing the Shell.
                                                              (line   6)
* Kermit the frog:                       Search/Sort Example. (line 103)
* kernel call:                           System Calls.        (line  16)
* kernel header files:                   Linux.               (line   6)
* KILL character:                        Editing Characters.  (line  85)
* kill signal:                           Termination Signals. (line  70)
* killing a process:                     Signaling Another Process.
                                                              (line   6)
* Korn Shell:                            Wildcard Matching.   (line  71)
* LANG environment variable <1>:         Standard Environment.
                                                              (line  68)
* LANG environment variable:             The catgets Functions.
                                                              (line  97)
* launching jobs:                        Launching Jobs.      (line   6)
* LC_ALL environment variable <1>:       Standard Environment.
                                                              (line  74)
* LC_ALL environment variable:           The catgets Functions.
                                                              (line  97)
* LC_COLLATE environment variable:       Standard Environment.
                                                              (line  80)
* LC_CTYPE environment variable:         Standard Environment.
                                                              (line  83)
* LC_MESSAGES environment variable <1>:  The catgets Functions.
                                                              (line  97)
* LC_MESSAGES environment variable:      Standard Environment.
                                                              (line  87)
* LC_MONETARY environment variable:      Standard Environment.
                                                              (line  91)
* LC_NUMERIC environment variable:       Standard Environment.
                                                              (line  94)
* LC_TIME environment variable:          Standard Environment.
                                                              (line  97)
* leap second:                           Broken-down Time.    (line  28)
* length of string:                      Representation of Strings.
                                                              (line  56)
* level, for socket options:             Socket Options.      (line   9)
* LGPL, Lesser General Public License:   Copying.             (line   6)
* library:                               Introduction.        (line   9)
* limit:                                 Limits on Resources. (line  12)
* limits on resource usage:              Limits on Resources. (line   6)
* limits, file name length:              Limits for Files.    (line  36)
* limits, floating types:                Floating Type Macros.
                                                              (line   6)
* limits, integer types:                 Range of Type.       (line   6)
* limits, link count of files:           Limits for Files.    (line  24)
* limits, number of open files:          General Limits.      (line  34)
* limits, number of processes:           General Limits.      (line  28)
* limits, number of supplementary group IDs: General Limits.  (line  50)
* limits, pipe buffer size:              Limits for Files.    (line  44)
* limits, POSIX:                         General Limits.      (line   6)
* limits, program argument size:         General Limits.      (line  24)
* limits, terminal input queue:          Limits for Files.    (line  28)
* limits, time zone name length:         General Limits.      (line  44)
* line buffered stream:                  Buffering Concepts.  (line  12)
* line speed:                            Line Speed.          (line   6)
* lines (in a text file):                Binary Streams.      (line  25)
* link:                                  Directories.         (line   9)
* link, hard:                            Hard Links.          (line   6)
* link, soft:                            Symbolic Links.      (line   6)
* link, symbolic:                        Symbolic Links.      (line   6)
* linked channels:                       Linked Channels.     (line   6)
* listening (sockets):                   Listening.           (line   6)
* literals:                              Memory Concepts.     (line  67)
* little-endian:                         Byte Order.          (line   6)
* LNEXT character:                       Other Special.       (line   9)
* load average:                          Processor Resources. (line  40)
* local namespace, for sockets:          Local Namespace.     (line   6)
* local network address number:          Abstract Host Addresses.
                                                              (line   9)
* local time:                            Calendar Time.       (line  26)
* locale categories:                     Locale Categories.   (line   6)
* locale, changing:                      Setting the Locale.  (line  18)
* locales:                               Locales.             (line  11)
* locking pages:                         Locking Pages.       (line   6)
* logarithm functions:                   Exponents and Logarithms.
                                                              (line   6)
* login name:                            User and Group IDs.  (line   6)
* login name, determining:               Who Logged In.       (line   6)
* LOGNAME environment variable:          Standard Environment.
                                                              (line  24)
* long jumps:                            Non-Local Exits.     (line   6)
* long-named options:                    Argument Syntax.     (line  50)
* longjmp:                               Advantages of Alloca.
                                                              (line  15)
* loss of data on sockets:               Socket Concepts.     (line  17)
* lost resource signal:                  Operation Error Signals.
                                                              (line  27)
* lower-case character <1>:              Classification of Characters.
                                                              (line  27)
* lower-case character:                  Classification of Wide Characters.
                                                              (line 137)
* macros:                                Obstack Functions.   (line   6)
* main function:                         Program Arguments.   (line   6)
* malloc debugger:                       Allocation Debugging.
                                                              (line   6)
* malloc function:                       Unconstrained Allocation.
                                                              (line   6)
* mantissa (of floating point number):   Floating Point Concepts.
                                                              (line  35)
* matching failure, in scanf:            Formatted Input Basics.
                                                              (line  32)
* math errors:                           Errors in Math Functions.
                                                              (line   6)
* mathematical constants:                Mathematical Constants.
                                                              (line   6)
* maximum:                               Misc FP Arithmetic.  (line   6)
* maximum field width (scanf):           Input Conversion Syntax.
                                                              (line  50)
* maximum limit:                         Limits on Resources. (line  24)
* maximum possible integer:              Integers.            (line 102)
* measurements of floating types:        Floating Type Macros.
                                                              (line   6)
* memory allocation:                     Memory.              (line   6)
* memory lock:                           Locking Pages.       (line   6)
* memory mapped file:                    Memory Concepts.     (line  83)
* memory mapped I/O:                     Memory Concepts.     (line  83)
* memory page:                           Memory Subsystem.    (line  33)
* merging of signals:                    Merged Signals.      (line   6)
* MIN termios slot:                      Noncanonical Input.  (line  26)
* minimum:                               Misc FP Arithmetic.  (line   6)
* minimum field width (printf):          Output Conversion Syntax.
                                                              (line  67)
* minimum possible integer:              Integers.            (line 102)
* mixing descriptors and streams:        Stream/Descriptor Precautions.
                                                              (line   6)
* modem disconnect:                      Control Modes.       (line  33)
* modem status lines:                    Control Modes.       (line  21)
* monetary value formatting:             The Lame Way to Locale Data.
                                                              (line  13)
* multi-threaded application:            Streams and Threads. (line   6)
* multibyte character:                   Extended Char Intro. (line 156)
* multibyte character string:            Representation of Strings.
                                                              (line  11)
* multibyte string:                      Representation of Strings.
                                                              (line  67)
* multiple names for one file:           Hard Links.          (line   6)
* multiplexing input:                    Waiting for I/O.     (line   6)
* multiply-add:                          Misc FP Arithmetic.  (line   6)
* name of running program:               Error Messages.      (line  70)
* name of socket:                        Socket Addresses.    (line   6)
* Name Service Switch:                   Name Service Switch. (line   6)
* name space:                            Reserved Names.      (line   6)
* names of signals:                      Standard Signals.    (line   6)
* namespace (of socket):                 Socket Concepts.     (line  33)
* NaN <1>:                               Infinity and NaN.    (line   6)
* NaN:                                   FP Bit Twiddling.    (line  54)
* Netgroup:                              Netgroup Data.       (line   6)
* netgroup:                              NSS Basics.          (line  26)
* network byte order:                    Byte Order.          (line  11)
* network number:                        Abstract Host Addresses.
                                                              (line   9)
* network protocol:                      Socket Concepts.     (line  42)
* networks:                              NSS Basics.          (line  26)
* networks database:                     Networks Database.   (line   6)
* NIS:                                   Host Identification. (line  38)
* NIS domain name:                       Host Identification. (line 108)
* nisplus, and booting:                  Actions in the NSS configuration.
                                                              (line  72)
* nisplus, and completeness:             Actions in the NSS configuration.
                                                              (line  65)
* NLSPATH environment variable <1>:      The catgets Functions.
                                                              (line  29)
* NLSPATH environment variable:          Standard Environment.
                                                              (line 100)
* non-blocking open:                     Open-time Flags.     (line  30)
* non-local exit, from signal handler:   Longjmp in Handler.  (line   6)
* non-local exits:                       Non-Local Exits.     (line   6)
* noncanonical input processing:         Canonical or Not.    (line  26)
* normalization functions (floating-point): Normalization Functions.
                                                              (line   6)
* normalized floating point number:      Floating Point Concepts.
                                                              (line  59)
* not a number:                          Infinity and NaN.    (line   6)
* NSS:                                   Name Service Switch. (line   6)
* nsswitch.conf:                         NSS Configuration File.
                                                              (line   6)
* null character:                        Representation of Strings.
                                                              (line  26)
* null pointer constant:                 Null Pointer Constant.
                                                              (line   6)
* null wide character:                   Representation of Strings.
                                                              (line  26)
* number of arguments passed:            How Many Arguments.  (line   6)
* number syntax, parsing:                Parsing of Numbers.  (line   6)
* numeric value formatting:              The Lame Way to Locale Data.
                                                              (line  13)
* obstack status:                        Status of an Obstack.
                                                              (line   6)
* obstacks:                              Obstacks.            (line   6)
* open-time action flags:                Open-time Flags.     (line  17)
* opening a file:                        I/O Concepts.        (line   9)
* opening a file descriptor:             Opening and Closing Files.
                                                              (line   6)
* opening a pipe:                        Creating a Pipe.     (line   6)
* opening a pseudo-terminal pair:        Pseudo-Terminal Pairs.
                                                              (line   6)
* opening a socket:                      Creating a Socket.   (line   6)
* opening a socket pair:                 Socket Pairs.        (line   6)
* opening a stream:                      Opening Streams.     (line   6)
* Optimization:                          FP Function Optimizations.
                                                              (line   6)
* optimizing NSS:                        Notes on NSS Configuration File.
                                                              (line  27)
* option parsing with argp:              Argp.                (line   6)
* optional arguments:                    Variadic Functions.  (line   6)
* optional POSIX features:               System Options.      (line   6)
* orientation, stream <1>:               Opening Streams.     (line  78)
* orientation, stream:                   Streams and I18N.    (line  38)
* orphaned process group:                Orphaned Process Groups.
                                                              (line   6)
* out-of-band data:                      Out-of-Band Data.    (line   6)
* output conversions, for printf:        Table of Output Conversions.
                                                              (line   6)
* output possible signal:                Asynchronous I/O Signals.
                                                              (line  13)
* overflow exception:                    FP Exceptions.       (line   6)
* owner of a file:                       File Owner.          (line   6)
* packet:                                Socket Concepts.     (line  12)
* page boundary:                         Aligned Memory Blocks.
                                                              (line   6)
* page fault:                            Memory Concepts.     (line  45)
* page fault, copy-on-write:             Locked Memory Details.
                                                              (line  40)
* page frame:                            Memory Concepts.     (line  18)
* page, memory:                          Memory Subsystem.    (line  33)
* page, virtual memory:                  Memory Concepts.     (line  18)
* paging <1>:                            Memory Concepts.     (line  45)
* paging:                                Locking Pages.       (line   6)
* parameter promotion:                   String/Array Conventions.
                                                              (line  41)
* parent directory:                      File Name Resolution.
                                                              (line  28)
* parent process <1>:                    Processes.           (line  13)
* parent process:                        Process Creation Concepts.
                                                              (line  15)
* parity checking:                       Input Modes.         (line  17)
* parsing a template string:             Parsing a Template String.
                                                              (line   6)
* parsing numbers (in formatted input):  Parsing of Numbers.  (line   6)
* parsing program arguments:             Parsing Program Arguments.
                                                              (line   6)
* parsing tokens from a string:          Finding Tokens in a String.
                                                              (line   6)
* passwd:                                NSS Basics.          (line  26)
* password database:                     User Database.       (line   6)
* PATH environment variable:             Standard Environment.
                                                              (line  33)
* pause function:                        Waiting for a Signal.
                                                              (line   6)
* peeking at input:                      Unreading.           (line   6)
* pending signals:                       Delivery of Signal.  (line   6)
* pending signals, checking for:         Checking for Pending Signals.
                                                              (line   6)
* period of time:                        Time Basics.         (line  33)
* permission to access a file:           Access Permission.   (line   6)
* persona:                               Process Persona.     (line   6)
* physical address:                      Memory Subsystem.    (line   6)
* physical memory:                       Memory Subsystem.    (line   6)
* pi (trigonometric constant):           Trig Functions.      (line  10)
* pipe:                                  Pipes and FIFOs.     (line   6)
* pipe signal:                           Operation Error Signals.
                                                              (line  13)
* pipe to a subprocess:                  Pipe to a Subprocess.
                                                              (line   6)
* port number:                           Ports.               (line   6)
* positioning a file descriptor:         File Position Primitive.
                                                              (line  15)
* positioning a stream:                  File Positioning.    (line   6)
* positive difference:                   Misc FP Arithmetic.  (line   6)
* POSIX:                                 POSIX.               (line   6)
* POSIX capacity limits:                 General Limits.      (line   6)
* POSIX optional features:               System Options.      (line   6)
* POSIX.1:                               POSIX.               (line   6)
* POSIX.2:                               POSIX.               (line   6)
* power functions:                       Exponents and Logarithms.
                                                              (line   6)
* precision (of floating point number):  Floating Point Concepts.
                                                              (line  38)
* precision (printf):                    Output Conversion Syntax.
                                                              (line  78)
* predicates on arrays:                  String/Array Comparison.
                                                              (line   6)
* predicates on characters:              Classification of Characters.
                                                              (line   6)
* predicates on strings:                 String/Array Comparison.
                                                              (line   6)
* preemptive scheduling:                 Absolute Priority.   (line  17)
* primitives, interrupting:              Interrupted Primitives.
                                                              (line  51)
* printing character <1>:                Classification of Wide Characters.
                                                              (line 147)
* printing character:                    Classification of Characters.
                                                              (line  95)
* priority of a process:                 Priority.            (line   6)
* priority, absolute:                    Absolute Priority.   (line   6)
* process <1>:                           Processes.           (line   6)
* process:                               Program Basics.      (line   6)
* process completion:                    Process Completion.  (line   6)
* process group functions:               Functions for Job Control.
                                                              (line   6)
* process group ID:                      Launching Jobs.      (line  23)
* process group leader:                  Launching Jobs.      (line  23)
* process groups:                        Job Control.         (line   6)
* process ID:                            Process Creation Concepts.
                                                              (line   9)
* process image:                         Process Creation Concepts.
                                                              (line  33)
* process lifetime:                      Process Creation Concepts.
                                                              (line   9)
* process priority:                      Priority.            (line   6)
* process signal mask:                   Process Signal Mask. (line   6)
* process termination:                   Program Termination. (line   6)
* processor time <1>:                    Processor Time.      (line   9)
* processor time:                        Time Basics.         (line  44)
* profiling alarm signal:                Alarm Signals.       (line  30)
* profiling timer:                       Setting an Alarm.    (line  22)
* program:                               Program Basics.      (line   6)
* program argument syntax:               Argument Syntax.     (line   6)
* program arguments:                     Program Arguments.   (line   6)
* program arguments, parsing:            Parsing Program Arguments.
                                                              (line   6)
* program error signals:                 Program Error Signals.
                                                              (line   6)
* program name:                          Error Messages.      (line  70)
* program startup:                       Program Arguments.   (line   6)
* program termination:                   Program Termination. (line   6)
* program termination signals:           Termination Signals. (line   6)
* programming your own streams:          Custom Streams.      (line   6)
* project complex numbers:               Operations on Complex.
                                                              (line   6)
* protocol (of socket):                  Socket Concepts.     (line  42)
* protocol family:                       Socket Concepts.     (line  42)
* protocols:                             NSS Basics.          (line  26)
* protocols database:                    Protocols Database.  (line   6)
* prototypes for variadic functions:     Variadic Prototypes. (line   6)
* pseudo-random numbers:                 Pseudo-Random Numbers.
                                                              (line   6)
* pseudo-terminals:                      Pseudo-Terminals.    (line   6)
* punctuation character <1>:             Classification of Wide Characters.
                                                              (line 157)
* punctuation character:                 Classification of Characters.
                                                              (line  58)
* pushing input back:                    Unreading.           (line   6)
* quick sort function (for arrays):      Array Sort Function. (line   6)
* QUIT character:                        Signal Characters.   (line  22)
* quit signal:                           Termination Signals. (line  36)
* quote removal:                         Expansion Stages.    (line  32)
* race conditions, relating to job control: Launching Jobs.   (line  28)
* race conditions, relating to signals:  Signals in Handler.  (line   6)
* radix (of floating point number):      Floating Point Concepts.
                                                              (line  20)
* raising signals:                       Generating Signals.  (line   6)
* random numbers:                        Pseudo-Random Numbers.
                                                              (line   6)
* random-access files:                   File Position.       (line  23)
* range error:                           Math Error Reporting.
                                                              (line   6)
* range of integer type:                 Range of Type.       (line   6)
* read lock:                             File Locks.          (line  14)
* reading from a directory:              Accessing Directories.
                                                              (line   6)
* reading from a file descriptor:        I/O Primitives.      (line  15)
* reading from a socket:                 Transferring Data.   (line   6)
* reading from a stream, by blocks:      Block Input/Output.  (line   9)
* reading from a stream, by characters:  Character Input.     (line   6)
* reading from a stream, formatted:      Formatted Input.     (line   6)
* ready to run:                          Absolute Priority.   (line  17)
* real group ID:                         Process Persona.     (line  17)
* real user ID:                          Process Persona.     (line  17)
* real-time timer:                       Setting an Alarm.    (line  13)
* realtime CPU scheduling:               Absolute Priority.   (line   9)
* realtime processing:                   Why Lock Pages.      (line  14)
* realtime scheduling:                   Realtime Scheduling. (line   6)
* receiving datagrams:                   Receiving Datagrams. (line   6)
* record locking:                        File Locks.          (line   6)
* redirecting input and output:          Duplicating Descriptors.
                                                              (line   6)
* reentrant functions:                   Nonreentrancy.       (line  26)
* reentrant NSS functions:               NSS Module Names.    (line  21)
* relative file name:                    File Name Resolution.
                                                              (line  24)
* removal of quotes:                     Expansion Stages.    (line  32)
* removing a file:                       Deleting Files.      (line   6)
* removing macros that shadow functions: Macro Definitions.   (line   6)
* renaming a file:                       Renaming Files.      (line   8)
* reporting bugs:                        Reporting Bugs.      (line   6)
* reporting errors:                      Error Reporting.     (line   6)
* REPRINT character:                     Editing Characters.  (line  96)
* reserved names:                        Reserved Names.      (line   6)
* resource limits:                       Limits on Resources. (line   6)
* restarting interrupted primitives:     Interrupted Primitives.
                                                              (line  51)
* restrictions on signal handler functions: Nonreentrancy.    (line   6)
* root directory:                        File Name Resolution.
                                                              (line  19)
* Rot13:                                 Trivial Encryption.  (line  11)
* rpc:                                   NSS Basics.          (line  26)
* runnable process:                      Absolute Priority.   (line  25)
* running a command:                     Running a Command.   (line   6)
* saved set-group-ID:                    How Change Persona.  (line   6)
* saved set-user-ID:                     How Change Persona.  (line   6)
* scanning the group list:               Scanning All Groups. (line   6)
* scanning the user list:                Scanning All Users.  (line   6)
* scatter-gather:                        Scatter-Gather.      (line   6)
* scheduling, traditional:               Traditional Scheduling.
                                                              (line   6)
* search function (for arrays):          Array Search Function.
                                                              (line   6)
* search functions (for strings):        Search Functions.    (line   8)
* seed (for random numbers):             Pseudo-Random Numbers.
                                                              (line   6)
* seeking on a file descriptor:          File Position Primitive.
                                                              (line  15)
* seeking on a stream:                   File Positioning.    (line   6)
* segmentation violation:                Program Error Signals.
                                                              (line 108)
* sending a datagram:                    Sending Datagrams.   (line   6)
* sending signals:                       Generating Signals.  (line   6)
* sequential-access files:               File Position.       (line  15)
* server:                                Connections.         (line   6)
* services:                              NSS Basics.          (line  26)
* services database:                     Services Database.   (line   6)
* session <1>:                           Concepts of Job Control.
                                                              (line  25)
* session:                               Job Control.         (line   6)
* session leader:                        Concepts of Job Control.
                                                              (line  34)
* setting an alarm:                      Setting an Alarm.    (line  10)
* setuid programs:                       How Change Persona.  (line   6)
* setuid programs and file access:       Testing File Access. (line   6)
* severity class <1>:                    Adding Severity Classes.
                                                              (line   6)
* severity class:                        Printing Formatted Messages.
                                                              (line  93)
* sgettext:                              GUI program problems.
                                                              (line  59)
* shadow:                                NSS Basics.          (line  26)
* shadowing functions with macros:       Macro Definitions.   (line   6)
* shared lock:                           File Locks.          (line  14)
* shared memory:                         Memory Subsystem.    (line  13)
* shell:                                 Concepts of Job Control.
                                                              (line   6)
* shift state:                           Keeping the state.   (line  15)
* Shift_JIS:                             Extended Char Intro. (line 188)
* shrinking objects:                     Growing Objects.     (line  90)
* shutting down a socket:                Closing a Socket.    (line   6)
* sigaction flags:                       Flags for Sigaction. (line   6)
* sigaction function:                    Advanced Signal Handling.
                                                              (line   6)
* SIGCHLD, handling of:                  Stopped and Terminated Jobs.
                                                              (line  18)
* sign (of floating point number):       Floating Point Concepts.
                                                              (line  18)
* signal <1>:                            FP Exceptions.       (line   6)
* signal:                                Signal Handling.     (line   6)
* signal action:                         Delivery of Signal.  (line  13)
* signal actions:                        Signal Actions.      (line   6)
* signal flags:                          Flags for Sigaction. (line   6)
* signal function:                       Basic Signal Handling.
                                                              (line   6)
* signal handler function:               Defining Handlers.   (line   6)
* signal mask:                           Process Signal Mask. (line   6)
* signal messages:                       Signal Messages.     (line   6)
* signal names:                          Standard Signals.    (line   6)
* signal number:                         Standard Signals.    (line   6)
* signal set:                            Signal Sets.         (line   9)
* signals, generating:                   Generating Signals.  (line   6)
* signedness:                            Integers.            (line   9)
* significand (of floating point number): Floating Point Concepts.
                                                              (line  35)
* SIGTTIN, from background job:          Access to the Terminal.
                                                              (line  11)
* SIGTTOU, from background job:          Access to the Terminal.
                                                              (line  18)
* simple time:                           Calendar Time.       (line  13)
* single-byte string:                    Representation of Strings.
                                                              (line  67)
* size of string:                        Representation of Strings.
                                                              (line  56)
* SJIS:                                  Extended Char Intro. (line 188)
* socket:                                Sockets.             (line   9)
* socket address (name) binding:         Socket Addresses.    (line   6)
* socket domain:                         Socket Concepts.     (line  33)
* socket namespace:                      Socket Concepts.     (line  33)
* socket option level:                   Socket Options.      (line   9)
* socket options:                        Socket Options.      (line   6)
* socket pair:                           Socket Pairs.        (line   6)
* socket protocol:                       Socket Concepts.     (line  42)
* socket shutdown:                       Closing a Socket.    (line   6)
* socket, client actions:                Connecting.          (line   6)
* socket, closing:                       Closing a Socket.    (line   6)
* socket, connecting:                    Connecting.          (line   6)
* socket, creating:                      Creating a Socket.   (line   6)
* socket, initiating a connection:       Connecting.          (line   6)
* sockets, accepting connections:        Accepting Connections.
                                                              (line   6)
* sockets, listening:                    Listening.           (line   6)
* sockets, server actions:               Listening.           (line   6)
* soft limit:                            Limits on Resources. (line  17)
* soft link:                             Symbolic Links.      (line   6)
* sort function (for arrays):            Array Sort Function. (line   6)
* sparse files:                          File Position Primitive.
                                                              (line  60)
* special files:                         Making Special Files.
                                                              (line   6)
* special functions:                     Special Functions.   (line   6)
* specified action (for a signal):       Delivery of Signal.  (line  13)
* speed of execution:                    Why Lock Pages.      (line  14)
* square root function:                  Exponents and Logarithms.
                                                              (line 122)
* stable sorting:                        Array Sort Function. (line  21)
* standard dot notation, for Internet addresses: Abstract Host Addresses.
                                                              (line  48)
* standard environment variables:        Standard Environment.
                                                              (line   6)
* standard error file descriptor:        Descriptors and Streams.
                                                              (line  64)
* standard error stream:                 Standard Streams.    (line  24)
* standard file descriptors:             Descriptors and Streams.
                                                              (line  49)
* standard input file descriptor:        Descriptors and Streams.
                                                              (line  55)
* standard input stream:                 Standard Streams.    (line  16)
* standard output file descriptor:       Descriptors and Streams.
                                                              (line  59)
* standard output stream:                Standard Streams.    (line  20)
* standard streams:                      Standard Streams.    (line   6)
* standards:                             Standards and Portability.
                                                              (line   6)
* START character:                       Start/Stop Characters.
                                                              (line  11)
* startup of program:                    Program Arguments.   (line   6)
* stateful <1>:                          glibc iconv Implementation.
                                                              (line 594)
* stateful <2>:                          Keeping the state.   (line   6)
* stateful <3>:                          Converting a Character.
                                                              (line  81)
* stateful <4>:                          Converting Strings.  (line  65)
* stateful <5>:                          Generic Conversion Interface.
                                                              (line 110)
* stateful:                              iconv Examples.      (line  96)
* static memory allocation:              Memory Allocation and C.
                                                              (line  13)
* static storage class:                  Memory Allocation and C.
                                                              (line  13)
* STATUS character:                      Other Special.       (line  35)
* status codes:                          Error Reporting.     (line   6)
* status of a file:                      Attribute Meanings.  (line   6)
* status of obstack:                     Status of an Obstack.
                                                              (line   6)
* sticky bit:                            Permission Bits.     (line  71)
* STOP character:                        Start/Stop Characters.
                                                              (line  28)
* stop signal:                           Job Control Signals. (line  44)
* stopped job:                           Concepts of Job Control.
                                                              (line  55)
* stopped jobs, continuing:              Continuing Stopped Jobs.
                                                              (line   6)
* stopped jobs, detecting:               Stopped and Terminated Jobs.
                                                              (line   6)
* storage allocation:                    Memory.              (line   6)
* stream (sockets):                      Socket Concepts.     (line  12)
* stream orientation <1>:                Streams and I18N.    (line  38)
* stream orientation:                    Opening Streams.     (line  78)
* stream, for I/O to a string:           String Streams.      (line   6)
* streams and descriptors:               Stream/Descriptor Precautions.
                                                              (line   6)
* streams, and file descriptors:         Descriptors and Streams.
                                                              (line   6)
* streams, C++:                          Streams and I18N.    (line  30)
* streams, standard:                     Standard Streams.    (line   6)
* string:                                Representation of Strings.
                                                              (line  11)
* string allocation:                     Representation of Strings.
                                                              (line  56)
* string collation functions:            Collation Functions. (line   6)
* string comparison functions:           String/Array Comparison.
                                                              (line   6)
* string concatenation functions:        Copying and Concatenation.
                                                              (line  10)
* string copy functions:                 Copying and Concatenation.
                                                              (line  10)
* string length:                         Representation of Strings.
                                                              (line  56)
* string literal:                        Representation of Strings.
                                                              (line  35)
* string search functions:               Search Functions.    (line   8)
* string stream:                         String Streams.      (line   6)
* string vectors, null-character separated: Argz and Envz Vectors.
                                                              (line   6)
* string, representation of:             Representation of Strings.
                                                              (line   6)
* style of communication (of a socket):  Socket Concepts.     (line   6)
* subshell:                              Initializing the Shell.
                                                              (line   6)
* substitution of variables and commands: Expansion Stages.   (line  15)
* successive signals:                    Merged Signals.      (line   6)
* summer time:                           Broken-down Time.    (line  62)
* SunOS:                                 Berkeley Unix.       (line   6)
* supplementary group IDs:               Process Persona.     (line   6)
* SUSP character:                        Signal Characters.   (line  33)
* suspend character:                     Signal Characters.   (line  33)
* SVID:                                  SVID.                (line   6)
* swap space:                            Memory Concepts.     (line  18)
* symbolic link:                         Symbolic Links.      (line   6)
* symbolic link, opening:                Open-time Flags.     (line  68)
* synchronizing <1>:                     Synchronizing I/O.   (line   6)
* synchronizing:                         Synchronizing AIO Operations.
                                                              (line  17)
* syntax error messages, in argp:        Argp Helper Functions.
                                                              (line  16)
* syntax, for program arguments:         Argument Syntax.     (line   6)
* syntax, for reading numbers:           Parsing of Numbers.  (line   6)
* sysconf <1>:                           Query Memory Parameters.
                                                              (line  49)
* sysconf <2>:                           Processor Resources. (line  13)
* sysconf <3>:                           Query Memory Parameters.
                                                              (line  43)
* sysconf:                               Processor Resources. (line  19)
* system call:                           System Calls.        (line   6)
* system call number:                    System Calls.        (line  42)
* System V Unix:                         SVID.                (line   6)
* TCP (Internet protocol):               Protocols Database.  (line  12)
* template, for printf:                  Formatted Output.    (line   6)
* template, for scanf:                   Formatted Input.     (line   6)
* TERM environment variable:             Standard Environment.
                                                              (line  56)
* terminal flow control:                 Line Control.        (line  93)
* terminal identification:               Is It a Terminal.    (line   6)
* terminal input queue:                  I/O Queues.          (line  11)
* terminal input queue, clearing:        Line Control.        (line  59)
* terminal input signal:                 Job Control Signals. (line  65)
* terminal line control functions:       Line Control.        (line   6)
* terminal line speed:                   Line Speed.          (line   6)
* terminal mode data types:              Mode Data Types.     (line   6)
* terminal mode functions:               Mode Functions.      (line   6)
* terminal modes, BSD:                   BSD Terminal Modes.  (line   6)
* terminal output queue:                 I/O Queues.          (line  27)
* terminal output queue, flushing:       Line Control.        (line  34)
* terminal output signal:                Job Control Signals. (line  72)
* terminated jobs, detecting:            Stopped and Terminated Jobs.
                                                              (line   6)
* termination signal:                    Termination Signals. (line  22)
* testing access permission:             Testing File Access. (line   6)
* testing exit status of child process:  Process Completion.  (line   6)
* text stream:                           Binary Streams.      (line  13)
* thrashing:                             Memory Subsystem.    (line  31)
* thread of control:                     Program Basics.      (line   6)
* threads:                               Streams and Threads. (line   6)
* ticks, clock:                          Processor And CPU Time.
                                                              (line  19)
* tilde expansion:                       Expansion Stages.    (line   9)
* time:                                  Time Basics.         (line   6)
* TIME termios slot:                     Noncanonical Input.  (line  34)
* time zone:                             TZ Variable.         (line   9)
* time zone database:                    TZ Variable.         (line 118)
* time, elapsed:                         Time Basics.         (line  24)
* time, high precision:                  High Accuracy Clock. (line   6)
* timer, profiling:                      Setting an Alarm.    (line  22)
* timer, real-time:                      Setting an Alarm.    (line  13)
* timer, virtual:                        Setting an Alarm.    (line  17)
* timers, setting:                       Setting an Alarm.    (line  10)
* timespec:                              Elapsed Time.        (line  40)
* timeval:                               Elapsed Time.        (line  27)
* timing error in signal handling:       Remembering a Signal.
                                                              (line  72)
* TMPDIR environment variable:           Temporary Files.     (line 125)
* tokenizing strings:                    Finding Tokens in a String.
                                                              (line   6)
* tools, for installing library:         Tools for Compilation.
                                                              (line   6)
* transmitting datagrams:                Sending Datagrams.   (line   6)
* tree, directory:                       Working with Directory Trees.
                                                              (line   6)
* triangulation:                         glibc iconv Implementation.
                                                              (line  42)
* trigonometric functions:               Trig Functions.      (line   6)
* type measurements, floating:           Floating Type Macros.
                                                              (line   6)
* type measurements, integer:            Width of Type.       (line   6)
* type modifier character (printf):      Output Conversion Syntax.
                                                              (line  92)
* type modifier character (scanf):       Input Conversion Syntax.
                                                              (line  55)
* typeahead buffer:                      I/O Queues.          (line  11)
* TZ environment variable:               Standard Environment.
                                                              (line  64)
* UCS-2:                                 Extended Char Intro. (line  49)
* UCS-4:                                 Extended Char Intro. (line  49)
* ulps:                                  Errors in Math Functions.
                                                              (line   6)
* umask:                                 Setting Permissions. (line   6)
* unbuffered stream:                     Buffering Concepts.  (line   9)
* unconstrained memory allocation:       Unconstrained Allocation.
                                                              (line   6)
* undefining macros that shadow functions: Macro Definitions. (line   6)
* underflow exception:                   FP Exceptions.       (line   6)
* Unicode:                               Extended Char Intro. (line  37)
* Unix, Berkeley:                        Berkeley Unix.       (line   6)
* Unix, System V:                        SVID.                (line   6)
* unlinking a file:                      Deleting Files.      (line   6)
* unordered comparison:                  FP Comparison Functions.
                                                              (line   6)
* unreading characters:                  Unreading.           (line   6)
* upgrading from libc5:                  Linux.               (line   6)
* upper-case character <1>:              Classification of Wide Characters.
                                                              (line 196)
* upper-case character:                  Classification of Characters.
                                                              (line  31)
* urgent data signal:                    Asynchronous I/O Signals.
                                                              (line  24)
* urgent socket condition:               Out-of-Band Data.    (line  18)
* usage limits:                          Limits on Resources. (line   6)
* usage messages, in argp:               Argp Helper Functions.
                                                              (line  11)
* user accounting database:              User Accounting Database.
                                                              (line   6)
* user database:                         User Database.       (line   6)
* user ID:                               User and Group IDs.  (line   6)
* user ID, determining:                  Who Logged In.       (line   6)
* user name:                             User and Group IDs.  (line   6)
* user signals:                          Miscellaneous Signals.
                                                              (line  12)
* usual file name errors:                File Name Errors.    (line   6)
* UTF-16:                                Extended Char Intro. (line  49)
* UTF-7:                                 Extended Char Intro. (line 222)
* UTF-8:                                 Extended Char Intro. (line 215)
* va_copy:                               Copying and Concatenation.
                                                              (line 447)
* variable number of arguments:          Variadic Functions.  (line   6)
* variable substitution:                 Expansion Stages.    (line  15)
* variable-sized arrays:                 GNU C Variable-Size Arrays.
                                                              (line   6)
* variadic function argument access:     Receiving Arguments. (line   6)
* variadic function prototypes:          Variadic Prototypes. (line   6)
* variadic functions:                    Variadic Functions.  (line   6)
* variadic functions, calling:           Calling Variadics.   (line   6)
* virtual time alarm signal:             Alarm Signals.       (line  24)
* virtual timer:                         Setting an Alarm.    (line  17)
* volatile declarations:                 Nonreentrancy.       (line  20)
* waiting for a signal:                  Waiting for a Signal.
                                                              (line   6)
* waiting for completion of child process: Process Completion.
                                                              (line   6)
* waiting for input or output:           Waiting for I/O.     (line   6)
* WERASE character:                      Editing Characters.  (line  61)
* whitespace character <1>:              Classification of Characters.
                                                              (line  62)
* whitespace character:                  Classification of Wide Characters.
                                                              (line 167)
* wide character:                        Extended Char Intro. (line  31)
* wide character string:                 Representation of Strings.
                                                              (line  82)
* width of integer type:                 Width of Type.       (line   6)
* wildcard expansion:                    Expansion Stages.    (line  27)
* wint_t:                                String/Array Conventions.
                                                              (line  41)
* word expansion:                        Word Expansion.      (line   6)
* working directory:                     Working Directory.   (line   6)
* write lock:                            File Locks.          (line  10)
* writing to a file descriptor:          I/O Primitives.      (line 155)
* writing to a socket:                   Transferring Data.   (line   6)
* writing to a stream, by blocks:        Block Input/Output.  (line   9)
* writing to a stream, by characters:    Simple Output.       (line   6)
* writing to a stream, formatted:        Formatted Output.    (line   6)
* YP:                                    Host Identification. (line  38)
* YP domain name:                        Host Identification. (line  38)
* zero divide:                           FP Exceptions.       (line   6)


File: libc.info,  Node: Type Index,  Next: Function Index,  Prev: Concept Index,  Up: Top

Type Index
**********

 [index ]
* Menu:

* __ftw64_func_t:                        Working with Directory Trees.
                                                              (line  65)
* __ftw_func_t:                          Working with Directory Trees.
                                                              (line  21)
* __nftw64_func_t:                       Working with Directory Trees.
                                                              (line  99)
* __nftw_func_t:                         Working with Directory Trees.
                                                              (line  73)
* blkcnt64_t:                            Attribute Meanings.  (line 224)
* blkcnt_t:                              Attribute Meanings.  (line 217)
* cc_t:                                  Mode Data Types.     (line  47)
* clock_t:                               CPU Time.            (line  42)
* comparison_fn_t:                       Comparison Functions.
                                                              (line  32)
* cookie_close_function:                 Hook Functions.      (line  60)
* cookie_io_functions_t:                 Streams and Cookies. (line  28)
* cookie_read_function:                  Hook Functions.      (line  49)
* cookie_seek_function:                  Hook Functions.      (line  57)
* cookie_write_function:                 Hook Functions.      (line  54)
* cpu_set_t:                             CPU Affinity.        (line  44)
* dev_t:                                 Attribute Meanings.  (line 209)
* DIR:                                   Opening a Directory. (line  10)
* div_t:                                 Integer Division.    (line  20)
* enum mcheck_status:                    Heap Consistency Checking.
                                                              (line  61)
* fd_set:                                Waiting for I/O.     (line  35)
* FILE:                                  Streams.             (line  17)
* fpos64_t:                              Portable Positioning.
                                                              (line  67)
* fpos_t:                                Portable Positioning.
                                                              (line  53)
* gid_t:                                 Reading Persona.     (line  16)
* glob64_t:                              Calling Glob.        (line  89)
* glob_t:                                Calling Glob.        (line  12)
* iconv_t:                               Generic Conversion Interface.
                                                              (line  16)
* imaxdiv_t:                             Integer Division.    (line  84)
* ino64_t:                               Attribute Meanings.  (line 201)
* ino_t:                                 Attribute Meanings.  (line 192)
* jmp_buf:                               Non-Local Details.   (line  11)
* ldiv_t:                                Integer Division.    (line  45)
* lldiv_t:                               Integer Division.    (line  63)
* mbstate_t:                             Keeping the state.   (line  15)
* mode_t:                                Attribute Meanings.  (line 188)
* nlink_t:                               Attribute Meanings.  (line 213)
* off64_t:                               File Position Primitive.
                                                              (line 155)
* off_t:                                 File Position Primitive.
                                                              (line 148)
* pid_t:                                 Process Identification.
                                                              (line  13)
* printf_arginfo_function:               Defining the Output Handler.
                                                              (line  55)
* printf_function:                       Defining the Output Handler.
                                                              (line  35)
* ptrdiff_t:                             Important Data Types.
                                                              (line  14)
* regex_t:                               POSIX Regexp Compilation.
                                                              (line  16)
* regmatch_t:                            Regexp Subexpressions.
                                                              (line  15)
* regoff_t:                              Regexp Subexpressions.
                                                              (line  26)
* sig_atomic_t:                          Atomic Types.        (line  17)
* sighandler_t:                          Basic Signal Handling.
                                                              (line  11)
* sigjmp_buf:                            Non-Local Exits and Signals.
                                                              (line  21)
* sigset_t:                              Signal Sets.         (line  14)
* size_t:                                Important Data Types.
                                                              (line  22)
* speed_t:                               Line Speed.          (line  57)
* ssize_t:                               I/O Primitives.      (line  11)
* stack_t:                               Signal Stack.        (line  27)
* struct __gconv_step:                   glibc iconv Implementation.
                                                              (line 206)
* struct __gconv_step_data:              glibc iconv Implementation.
                                                              (line 274)
* struct aiocb:                          Asynchronous I/O.    (line  28)
* struct aiocb64:                        Asynchronous I/O.    (line 111)
* struct aioinit:                        Configuration of AIO.
                                                              (line  18)
* struct argp:                           Argp Parsers.        (line  10)
* struct argp_child:                     Argp Children.       (line  18)
* struct argp_option:                    Argp Option Vectors. (line  14)
* struct argp_state:                     Argp Parsing State.  (line  11)
* struct dirent:                         Directory Entries.   (line  11)
* struct ENTRY:                          Hash Search Function.
                                                              (line  63)
* struct exit_status:                    Manipulating the Database.
                                                              (line  10)
* struct flock:                          File Locks.          (line  37)
* struct fstab:                          fstab.               (line  10)
* struct FTW:                            Working with Directory Trees.
                                                              (line 107)
* struct group:                          Group Data Structure.
                                                              (line  10)
* struct hostent:                        Host Names.          (line  21)
* struct if_nameindex:                   Interface Naming.    (line  37)
* struct in6_addr:                       Host Address Data Type.
                                                              (line  52)
* struct in_addr:                        Host Address Data Type.
                                                              (line  26)
* struct iovec:                          Scatter-Gather.      (line  21)
* struct itimerval:                      Setting an Alarm.    (line  54)
* struct lconv:                          The Lame Way to Locale Data.
                                                              (line  26)
* struct linger:                         Socket-Level Options.
                                                              (line  50)
* struct mallinfo:                       Statistics of Malloc.
                                                              (line  12)
* struct mntent:                         mtab.                (line   9)
* struct netent:                         Networks Database.   (line  14)
* struct ntptimeval:                     High Accuracy Clock. (line  18)
* struct obstack:                        Creating Obstacks.   (line  10)
* struct option:                         Getopt Long Options. (line  13)
* struct passwd:                         User Data Structure. (line  10)
* struct printf_info:                    Conversion Specifier Options.
                                                              (line  16)
* struct protoent:                       Protocols Database.  (line  30)
* struct random_data:                    BSD Random.          (line  68)
* struct rlimit:                         Limits on Resources. (line  79)
* struct rlimit64:                       Limits on Resources. (line  95)
* struct rusage:                         Resource Usage.      (line  37)
* struct sched_param:                    Basic Scheduling Functions.
                                                              (line  30)
* struct servent:                        Services Database.   (line  12)
* struct sgttyb:                         BSD Terminal Modes.  (line  16)
* struct sigaction:                      Advanced Signal Handling.
                                                              (line  15)
* struct sigstack:                       Signal Stack.        (line  97)
* struct sigvec:                         BSD Handler.         (line   7)
* struct sockaddr:                       Address Formats.     (line  24)
* struct sockaddr_in:                    Internet Address Formats.
                                                              (line  16)
* struct sockaddr_in6:                   Internet Address Formats.
                                                              (line  37)
* struct sockaddr_un:                    Local Namespace Details.
                                                              (line  25)
* struct stat:                           Attribute Meanings.  (line  15)
* struct stat64:                         Attribute Meanings.  (line 107)
* struct termios:                        Mode Data Types.     (line  11)
* struct timespec:                       Elapsed Time.        (line  40)
* struct timeval:                        Elapsed Time.        (line  27)
* struct timex:                          High Accuracy Clock. (line  51)
* struct timezone:                       High-Resolution Calendar.
                                                              (line  15)
* struct tm:                             Broken-down Time.    (line  20)
* struct tms:                            Processor Time.      (line  12)
* struct utimbuf:                        File Times.          (line  39)
* struct utmp:                           Manipulating the Database.
                                                              (line  21)
* struct utmpx:                          XPG Functions.       (line  10)
* struct utsname:                        Platform Type.       (line  16)
* struct vtimes:                         Resource Usage.      (line 117)
* tcflag_t:                              Mode Data Types.     (line  43)
* time_t:                                Simple Calendar Time.
                                                              (line  11)
* ucontext_t:                            System V contexts.   (line  23)
* uid_t:                                 Reading Persona.     (line  12)
* union wait:                            BSD Wait Functions.  (line  17)
* va_list:                               Argument Macros.     (line  10)
* VISIT:                                 Tree Search Function.
                                                              (line 102)
* wchar_t:                               Extended Char Intro. (line  65)
* wctrans_t:                             Wide Character Case Conversion.
                                                              (line  12)
* wctype_t:                              Classification of Wide Characters.
                                                              (line  30)
* wint_t:                                Extended Char Intro. (line  88)
* wordexp_t:                             Calling Wordexp.     (line  15)


File: libc.info,  Node: Function Index,  Next: Variable Index,  Prev: Type Index,  Up: Top

Function and Macro Index
************************

 [index ]
* Menu:

* *sbrk:                                 Resizing the Data Segment.
                                                              (line  44)
* __fbufsize:                            Controlling Buffering.
                                                              (line 116)
* __flbf:                                Controlling Buffering.
                                                              (line 106)
* __fpending:                            Controlling Buffering.
                                                              (line 123)
* __fpurge:                              Flushing Buffers.    (line  65)
* __freadable:                           Opening Streams.     (line 176)
* __freading:                            Opening Streams.     (line 193)
* __fsetlocking:                         Streams and Threads. (line 161)
* __fwritable:                           Opening Streams.     (line 183)
* __fwriting:                            Opening Streams.     (line 203)
* __va_copy:                             Argument Macros.     (line  49)
* _Exit:                                 Termination Internals.
                                                              (line  15)
* _exit:                                 Termination Internals.
                                                              (line  10)
* _flushlbf:                             Flushing Buffers.    (line  47)
* _tolower:                              Case Conversion.     (line  39)
* _toupper:                              Case Conversion.     (line  43)
* a64l:                                  Encode Binary Data.  (line  83)
* abort:                                 Aborting a Program.  (line  10)
* abs:                                   Absolute Value.      (line  18)
* accept:                                Accepting Connections.
                                                              (line  27)
* access:                                Testing File Access. (line  42)
* acos:                                  Inverse Trig Functions.
                                                              (line  23)
* acosf:                                 Inverse Trig Functions.
                                                              (line  24)
* acosh:                                 Hyperbolic Functions.
                                                              (line  58)
* acoshf:                                Hyperbolic Functions.
                                                              (line  59)
* acoshl:                                Hyperbolic Functions.
                                                              (line  60)
* acosl:                                 Inverse Trig Functions.
                                                              (line  25)
* addmntent:                             mtab.                (line 175)
* addseverity:                           Adding Severity Classes.
                                                              (line  13)
* adjtime:                               High-Resolution Calendar.
                                                              (line  88)
* adjtimex:                              High-Resolution Calendar.
                                                              (line 121)
* aio_cancel:                            Cancel AIO Operations.
                                                              (line  19)
* aio_cancel64:                          Cancel AIO Operations.
                                                              (line  63)
* aio_error:                             Status of AIO Operations.
                                                              (line  15)
* aio_error64:                           Status of AIO Operations.
                                                              (line  33)
* aio_fsync:                             Synchronizing AIO Operations.
                                                              (line  18)
* aio_fsync64:                           Synchronizing AIO Operations.
                                                              (line  66)
* aio_init:                              Configuration of AIO.
                                                              (line  47)
* aio_read:                              Asynchronous Reads/Writes.
                                                              (line   7)
* aio_read64:                            Asynchronous Reads/Writes.
                                                              (line  73)
* aio_return:                            Status of AIO Operations.
                                                              (line  43)
* aio_return64:                          Status of AIO Operations.
                                                              (line  63)
* aio_suspend:                           Synchronizing AIO Operations.
                                                              (line  90)
* aio_suspend64:                         Synchronizing AIO Operations.
                                                              (line 127)
* aio_write:                             Asynchronous Reads/Writes.
                                                              (line  89)
* aio_write64:                           Asynchronous Reads/Writes.
                                                              (line 155)
* alarm:                                 Setting an Alarm.    (line 103)
* alloca:                                Variable Size Automatic.
                                                              (line  19)
* alphasort:                             Scanning Directory Content.
                                                              (line  40)
* alphasort64:                           Scanning Directory Content.
                                                              (line  75)
* argp_error:                            Argp Helper Functions.
                                                              (line  18)
* argp_failure:                          Argp Helper Functions.
                                                              (line  25)
* argp_help:                             Argp Help.           (line  16)
* argp_parse:                            Argp.                (line  36)
* argp_state_help:                       Argp Helper Functions.
                                                              (line  39)
* argp_usage:                            Argp Helper Functions.
                                                              (line  12)
* argz_add:                              Argz Functions.      (line  66)
* argz_add_sep:                          Argz Functions.      (line  71)
* argz_append:                           Argz Functions.      (line  79)
* argz_count:                            Argz Functions.      (line  41)
* argz_create:                           Argz Functions.      (line  28)
* argz_create_sep:                       Argz Functions.      (line  35)
* argz_delete:                           Argz Functions.      (line  85)
* argz_extract:                          Argz Functions.      (line  46)
* argz_insert:                           Argz Functions.      (line  94)
* argz_next:                             Argz Functions.      (line 104)
* argz_replace:                          Argz Functions.      (line 132)
* argz_stringify:                        Argz Functions.      (line  59)
* asctime:                               Formatting Calendar Time.
                                                              (line  10)
* asctime_r:                             Formatting Calendar Time.
                                                              (line  28)
* asin:                                  Inverse Trig Functions.
                                                              (line  11)
* asinf:                                 Inverse Trig Functions.
                                                              (line  12)
* asinh:                                 Hyperbolic Functions.
                                                              (line  52)
* asinhf:                                Hyperbolic Functions.
                                                              (line  53)
* asinhl:                                Hyperbolic Functions.
                                                              (line  54)
* asinl:                                 Inverse Trig Functions.
                                                              (line  13)
* asprintf:                              Dynamic Output.      (line  10)
* assert:                                Consistency Checking.
                                                              (line  27)
* assert_perror:                         Consistency Checking.
                                                              (line  59)
* atan:                                  Inverse Trig Functions.
                                                              (line  35)
* atan2:                                 Inverse Trig Functions.
                                                              (line  44)
* atan2f:                                Inverse Trig Functions.
                                                              (line  45)
* atan2l:                                Inverse Trig Functions.
                                                              (line  46)
* atanf:                                 Inverse Trig Functions.
                                                              (line  36)
* atanh:                                 Hyperbolic Functions.
                                                              (line  65)
* atanhf:                                Hyperbolic Functions.
                                                              (line  66)
* atanhl:                                Hyperbolic Functions.
                                                              (line  67)
* atanl:                                 Inverse Trig Functions.
                                                              (line  37)
* atexit:                                Cleanups on Exit.    (line  15)
* atof:                                  Parsing of Floats.   (line 104)
* atoi:                                  Parsing of Integers. (line 196)
* atol:                                  Parsing of Integers. (line 190)
* atoll:                                 Parsing of Integers. (line 201)
* backtrace:                             Backtraces.          (line  16)
* backtrace_symbols:                     Backtraces.          (line  35)
* backtrace_symbols_fd:                  Backtraces.          (line  65)
* basename:                              Finding Tokens in a String.
                                                              (line 232)
* bcmp:                                  String/Array Comparison.
                                                              (line 220)
* bcopy:                                 Copying and Concatenation.
                                                              (line 625)
* bind:                                  Setting Address.     (line  13)
* bind_textdomain_codeset:               Charset conversion in gettext.
                                                              (line  28)
* bindtextdomain:                        Locating gettext catalog.
                                                              (line 100)
* brk:                                   Resizing the Data Segment.
                                                              (line  15)
* bsearch:                               Array Search Function.
                                                              (line  49)
* btowc:                                 Converting a Character.
                                                              (line  16)
* bzero:                                 Copying and Concatenation.
                                                              (line 631)
* cabs:                                  Absolute Value.      (line  39)
* cabsf:                                 Absolute Value.      (line  40)
* cabsl:                                 Absolute Value.      (line  41)
* cacos:                                 Inverse Trig Functions.
                                                              (line  72)
* cacosf:                                Inverse Trig Functions.
                                                              (line  73)
* cacosh:                                Hyperbolic Functions.
                                                              (line  79)
* cacoshf:                               Hyperbolic Functions.
                                                              (line  80)
* cacoshl:                               Hyperbolic Functions.
                                                              (line  81)
* cacosl:                                Inverse Trig Functions.
                                                              (line  74)
* calloc:                                Allocating Cleared Space.
                                                              (line  10)
* canonicalize_file_name:                Symbolic Links.      (line 121)
* carg:                                  Operations on Complex.
                                                              (line  29)
* cargf:                                 Operations on Complex.
                                                              (line  30)
* cargl:                                 Operations on Complex.
                                                              (line  31)
* casin:                                 Inverse Trig Functions.
                                                              (line  63)
* casinf:                                Inverse Trig Functions.
                                                              (line  64)
* casinh:                                Hyperbolic Functions.
                                                              (line  73)
* casinhf:                               Hyperbolic Functions.
                                                              (line  74)
* casinhl:                               Hyperbolic Functions.
                                                              (line  75)
* casinl:                                Inverse Trig Functions.
                                                              (line  65)
* catan:                                 Inverse Trig Functions.
                                                              (line  81)
* catanf:                                Inverse Trig Functions.
                                                              (line  82)
* catanh:                                Hyperbolic Functions.
                                                              (line  86)
* catanhf:                               Hyperbolic Functions.
                                                              (line  87)
* catanhl:                               Hyperbolic Functions.
                                                              (line  88)
* catanl:                                Inverse Trig Functions.
                                                              (line  83)
* catclose:                              The catgets Functions.
                                                              (line 183)
* catgets:                               The catgets Functions.
                                                              (line 149)
* catopen:                               The catgets Functions.
                                                              (line   7)
* cbc_crypt:                             DES Encryption.      (line 117)
* cbrt:                                  Exponents and Logarithms.
                                                              (line 131)
* cbrtf:                                 Exponents and Logarithms.
                                                              (line 132)
* cbrtl:                                 Exponents and Logarithms.
                                                              (line 133)
* ccos:                                  Trig Functions.      (line  71)
* ccosf:                                 Trig Functions.      (line  72)
* ccosh:                                 Hyperbolic Functions.
                                                              (line  40)
* ccoshf:                                Hyperbolic Functions.
                                                              (line  41)
* ccoshl:                                Hyperbolic Functions.
                                                              (line  42)
* ccosl:                                 Trig Functions.      (line  73)
* ceil:                                  Rounding Functions.  (line  19)
* ceilf:                                 Rounding Functions.  (line  20)
* ceill:                                 Rounding Functions.  (line  21)
* cexp:                                  Exponents and Logarithms.
                                                              (line 164)
* cexpf:                                 Exponents and Logarithms.
                                                              (line 165)
* cexpl:                                 Exponents and Logarithms.
                                                              (line 166)
* cfgetispeed:                           Line Speed.          (line  37)
* cfgetospeed:                           Line Speed.          (line  33)
* cfmakeraw:                             Noncanonical Input.  (line  93)
* cfree:                                 Freeing after Malloc.
                                                              (line  15)
* cfsetispeed:                           Line Speed.          (line  46)
* cfsetospeed:                           Line Speed.          (line  41)
* cfsetspeed:                            Line Speed.          (line  51)
* chdir:                                 Working Directory.   (line  98)
* chmod:                                 Setting Permissions. (line  68)
* chown:                                 File Owner.          (line  34)
* cimag:                                 Operations on Complex.
                                                              (line  17)
* cimagf:                                Operations on Complex.
                                                              (line  18)
* cimagl:                                Operations on Complex.
                                                              (line  19)
* clearenv:                              Environment Access.  (line  79)
* clearerr:                              Error Recovery.      (line  10)
* clearerr_unlocked:                     Error Recovery.      (line  17)
* clock:                                 CPU Time.            (line  46)
* clog:                                  Exponents and Logarithms.
                                                              (line 172)
* clog10:                                Exponents and Logarithms.
                                                              (line 183)
* clog10f:                               Exponents and Logarithms.
                                                              (line 184)
* clog10l:                               Exponents and Logarithms.
                                                              (line 185)
* clogf:                                 Exponents and Logarithms.
                                                              (line 173)
* clogl:                                 Exponents and Logarithms.
                                                              (line 174)
* close:                                 Opening and Closing Files.
                                                              (line 136)
* closedir:                              Reading/Closing Directory.
                                                              (line  91)
* closelog:                              closelog.            (line  10)
* confstr:                               String Parameters.   (line  10)
* conj:                                  Operations on Complex.
                                                              (line  22)
* conjf:                                 Operations on Complex.
                                                              (line  23)
* conjl:                                 Operations on Complex.
                                                              (line  24)
* connect:                               Connecting.          (line  13)
* copysign:                              FP Bit Twiddling.    (line  11)
* copysignf:                             FP Bit Twiddling.    (line  12)
* copysignl:                             FP Bit Twiddling.    (line  13)
* cos:                                   Trig Functions.      (line  25)
* cosf:                                  Trig Functions.      (line  26)
* cosh:                                  Hyperbolic Functions.
                                                              (line  17)
* coshf:                                 Hyperbolic Functions.
                                                              (line  18)
* coshl:                                 Hyperbolic Functions.
                                                              (line  19)
* cosl:                                  Trig Functions.      (line  27)
* cpow:                                  Exponents and Logarithms.
                                                              (line 201)
* cpowf:                                 Exponents and Logarithms.
                                                              (line 203)
* cpowl:                                 Exponents and Logarithms.
                                                              (line 205)
* cproj:                                 Operations on Complex.
                                                              (line  40)
* cprojf:                                Operations on Complex.
                                                              (line  41)
* cprojl:                                Operations on Complex.
                                                              (line  42)
* CPU_CLR:                               CPU Affinity.        (line  78)
* CPU_ISSET:                             CPU Affinity.        (line  86)
* CPU_SET:                               CPU Affinity.        (line  70)
* CPU_ZERO:                              CPU Affinity.        (line  65)
* creal:                                 Operations on Complex.
                                                              (line  12)
* crealf:                                Operations on Complex.
                                                              (line  13)
* creall:                                Operations on Complex.
                                                              (line  14)
* creat:                                 Opening and Closing Files.
                                                              (line 105)
* creat64:                               Opening and Closing Files.
                                                              (line 121)
* crypt:                                 crypt.               (line   7)
* crypt_r:                               crypt.               (line 114)
* csin:                                  Trig Functions.      (line  63)
* csinf:                                 Trig Functions.      (line  64)
* csinh:                                 Hyperbolic Functions.
                                                              (line  34)
* csinhf:                                Hyperbolic Functions.
                                                              (line  35)
* csinhl:                                Hyperbolic Functions.
                                                              (line  36)
* csinl:                                 Trig Functions.      (line  65)
* csqrt:                                 Exponents and Logarithms.
                                                              (line 193)
* csqrtf:                                Exponents and Logarithms.
                                                              (line 194)
* csqrtl:                                Exponents and Logarithms.
                                                              (line 195)
* ctan:                                  Trig Functions.      (line  79)
* ctanf:                                 Trig Functions.      (line  80)
* ctanh:                                 Hyperbolic Functions.
                                                              (line  46)
* ctanhf:                                Hyperbolic Functions.
                                                              (line  47)
* ctanhl:                                Hyperbolic Functions.
                                                              (line  48)
* ctanl:                                 Trig Functions.      (line  81)
* ctermid:                               Identifying the Terminal.
                                                              (line  16)
* ctime:                                 Formatting Calendar Time.
                                                              (line  38)
* ctime_r:                               Formatting Calendar Time.
                                                              (line  48)
* cuserid:                               Who Logged In.       (line  24)
* dcgettext:                             Translation with gettext.
                                                              (line  88)
* dcngettext:                            Advanced gettext functions.
                                                              (line  99)
* DES_FAILED:                            DES Encryption.      (line 112)
* des_setparity:                         DES Encryption.      (line 139)
* dgettext:                              Translation with gettext.
                                                              (line  76)
* difftime:                              Elapsed Time.        (line  11)
* dirfd:                                 Opening a Directory. (line  92)
* dirname:                               Finding Tokens in a String.
                                                              (line 262)
* div:                                   Integer Division.    (line  30)
* dngettext:                             Advanced gettext functions.
                                                              (line  91)
* drand48:                               SVID Random.         (line  34)
* drand48_r:                             SVID Random.         (line 158)
* drem:                                  Remainder Functions. (line  27)
* dremf:                                 Remainder Functions. (line  28)
* dreml:                                 Remainder Functions. (line  30)
* DTTOIF:                                Directory Entries.   (line  68)
* dup:                                   Duplicating Descriptors.
                                                              (line  24)
* dup2:                                  Duplicating Descriptors.
                                                              (line  29)
* ecb_crypt:                             DES Encryption.      (line  61)
* ecvt:                                  System V Number Conversion.
                                                              (line  18)
* ecvt_r:                                System V Number Conversion.
                                                              (line  94)
* encrypt:                               DES Encryption.      (line  40)
* encrypt_r:                             DES Encryption.      (line  50)
* endfsent:                              fstab.               (line  94)
* endgrent:                              Scanning All Groups. (line  66)
* endhostent:                            Host Names.          (line 207)
* endmntent:                             mtab.                (line 121)
* endnetent:                             Networks Database.   (line  67)
* endnetgrent:                           Lookup Netgroup.     (line  65)
* endprotoent:                           Protocols Database.  (line  78)
* endpwent:                              Scanning All Users.  (line  66)
* endservent:                            Services Database.   (line  69)
* endutent:                              Manipulating the Database.
                                                              (line 132)
* endutxent:                             XPG Functions.       (line  85)
* envz_add:                              Envz Functions.      (line  44)
* envz_entry:                            Envz Functions.      (line  30)
* envz_get:                              Envz Functions.      (line  37)
* envz_merge:                            Envz Functions.      (line  52)
* envz_strip:                            Envz Functions.      (line  62)
* erand48:                               SVID Random.         (line  44)
* erand48_r:                             SVID Random.         (line 173)
* erf:                                   Special Functions.   (line  10)
* erfc:                                  Special Functions.   (line  17)
* erfcf:                                 Special Functions.   (line  18)
* erfcl:                                 Special Functions.   (line  19)
* erff:                                  Special Functions.   (line  11)
* erfl:                                  Special Functions.   (line  12)
* err:                                   Error Messages.      (line 291)
* error:                                 Error Messages.      (line 145)
* error_at_line:                         Error Messages.      (line 179)
* errx:                                  Error Messages.      (line 302)
* execl:                                 Executing a File.    (line  34)
* execle:                                Executing a File.    (line  47)
* execlp:                                Executing a File.    (line  64)
* execv:                                 Executing a File.    (line  18)
* execve:                                Executing a File.    (line  40)
* execvp:                                Executing a File.    (line  54)
* exit:                                  Normal Termination.  (line  11)
* exp:                                   Exponents and Logarithms.
                                                              (line   7)
* exp10:                                 Exponents and Logarithms.
                                                              (line  22)
* exp10f:                                Exponents and Logarithms.
                                                              (line  23)
* exp10l:                                Exponents and Logarithms.
                                                              (line  24)
* exp2:                                  Exponents and Logarithms.
                                                              (line  16)
* exp2f:                                 Exponents and Logarithms.
                                                              (line  17)
* exp2l:                                 Exponents and Logarithms.
                                                              (line  18)
* expf:                                  Exponents and Logarithms.
                                                              (line   8)
* expl:                                  Exponents and Logarithms.
                                                              (line   9)
* expm1:                                 Exponents and Logarithms.
                                                              (line 147)
* expm1f:                                Exponents and Logarithms.
                                                              (line 148)
* expm1l:                                Exponents and Logarithms.
                                                              (line 149)
* fabs:                                  Absolute Value.      (line  33)
* fabsf:                                 Absolute Value.      (line  34)
* fabsl:                                 Absolute Value.      (line  35)
* fchdir:                                Working Directory.   (line 108)
* fchmod:                                Setting Permissions. (line 104)
* fchown:                                File Owner.          (line  65)
* fclean:                                Cleaning Streams.    (line   9)
* fclose:                                Closing Streams.     (line  11)
* fcloseall:                             Closing Streams.     (line  30)
* fcntl:                                 Control Operations.  (line  18)
* fcvt:                                  System V Number Conversion.
                                                              (line  40)
* fcvt_r:                                System V Number Conversion.
                                                              (line 103)
* FD_CLR:                                Waiting for I/O.     (line  59)
* FD_ISSET:                              Waiting for I/O.     (line  65)
* FD_SET:                                Waiting for I/O.     (line  53)
* FD_ZERO:                               Waiting for I/O.     (line  49)
* fdatasync:                             Synchronizing I/O.   (line  62)
* fdim:                                  Misc FP Arithmetic.  (line  31)
* fdimf:                                 Misc FP Arithmetic.  (line  32)
* fdiml:                                 Misc FP Arithmetic.  (line  33)
* fdopen:                                Descriptors and Streams.
                                                              (line  12)
* fdopendir:                             Opening a Directory. (line  53)
* feclearexcept:                         Status bit operations.
                                                              (line  39)
* fedisableexcept:                       Control Functions.   (line  98)
* feenableexcept:                        Control Functions.   (line  88)
* fegetenv:                              Control Functions.   (line  30)
* fegetexcept:                           Control Functions.   (line 108)
* fegetexceptflag:                       Status bit operations.
                                                              (line  89)
* fegetround:                            Rounding.            (line  71)
* feholdexcept:                          Control Functions.   (line  37)
* feof:                                  EOF and Errors.      (line  32)
* feof_unlocked:                         EOF and Errors.      (line  38)
* feraiseexcept:                         Status bit operations.
                                                              (line  46)
* ferror:                                EOF and Errors.      (line  46)
* ferror_unlocked:                       EOF and Errors.      (line  53)
* fesetenv:                              Control Functions.   (line  66)
* fesetexceptflag:                       Status bit operations.
                                                              (line  97)
* fesetround:                            Rounding.            (line  77)
* fetestexcept:                          Status bit operations.
                                                              (line  58)
* feupdateenv:                           Control Functions.   (line  72)
* fflush:                                Flushing Buffers.    (line  26)
* fflush_unlocked:                       Flushing Buffers.    (line  34)
* fgetc:                                 Character Input.     (line  23)
* fgetc_unlocked:                        Character Input.     (line  34)
* fgetgrent:                             Scanning All Groups. (line  14)
* fgetgrent_r:                           Scanning All Groups. (line  25)
* fgetpos:                               Portable Positioning.
                                                              (line  77)
* fgetpos64:                             Portable Positioning.
                                                              (line  88)
* fgetpwent:                             Scanning All Users.  (line  14)
* fgetpwent_r:                           Scanning All Users.  (line  24)
* fgets:                                 Line Input.          (line  74)
* fgets_unlocked:                        Line Input.          (line 115)
* fgetwc:                                Character Input.     (line  29)
* fgetwc_unlocked:                       Character Input.     (line  38)
* fgetws:                                Line Input.          (line  94)
* fgetws_unlocked:                       Line Input.          (line 122)
* fileno:                                Descriptors and Streams.
                                                              (line  37)
* fileno_unlocked:                       Descriptors and Streams.
                                                              (line  43)
* finite:                                Floating Point Classes.
                                                              (line  92)
* finitef:                               Floating Point Classes.
                                                              (line  93)
* finitel:                               Floating Point Classes.
                                                              (line  94)
* flockfile:                             Streams and Threads. (line  31)
* floor:                                 Rounding Functions.  (line  25)
* floorf:                                Rounding Functions.  (line  26)
* floorl:                                Rounding Functions.  (line  27)
* fma:                                   Misc FP Arithmetic.  (line  40)
* fmaf:                                  Misc FP Arithmetic.  (line  41)
* fmal:                                  Misc FP Arithmetic.  (line  43)
* fmax:                                  Misc FP Arithmetic.  (line  23)
* fmaxf:                                 Misc FP Arithmetic.  (line  24)
* fmaxl:                                 Misc FP Arithmetic.  (line  25)
* fmemopen:                              String Streams.      (line  11)
* fmin:                                  Misc FP Arithmetic.  (line  12)
* fminf:                                 Misc FP Arithmetic.  (line  13)
* fminl:                                 Misc FP Arithmetic.  (line  14)
* fmod:                                  Remainder Functions. (line  11)
* fmodf:                                 Remainder Functions. (line  12)
* fmodl:                                 Remainder Functions. (line  14)
* fmtmsg:                                Printing Formatted Messages.
                                                              (line  55)
* fnmatch:                               Wildcard Matching.   (line  13)
* fopen:                                 Opening Streams.     (line  14)
* fopen64:                               Opening Streams.     (line 110)
* fopencookie:                           Streams and Cookies. (line  58)
* fork:                                  Creating a Process.  (line  10)
* forkpty:                               Pseudo-Terminal Pairs.
                                                              (line  37)
* fpathconf:                             Pathconf.            (line  36)
* fpclassify:                            Floating Point Classes.
                                                              (line  10)
* fprintf:                               Formatted Output Functions.
                                                              (line  26)
* fputc:                                 Simple Output.       (line  13)
* fputc_unlocked:                        Simple Output.       (line  23)
* fputs:                                 Simple Output.       (line  75)
* fputs_unlocked:                        Simple Output.       (line 101)
* fputwc:                                Simple Output.       (line  18)
* fputwc_unlocked:                       Simple Output.       (line  27)
* fputws:                                Simple Output.       (line  92)
* fputws_unlocked:                       Simple Output.       (line 107)
* fread:                                 Block Input/Output.  (line  29)
* fread_unlocked:                        Block Input/Output.  (line  43)
* free:                                  Freeing after Malloc.
                                                              (line  11)
* freopen:                               Opening Streams.     (line 134)
* freopen64:                             Opening Streams.     (line 158)
* frexp:                                 Normalization Functions.
                                                              (line  17)
* frexpf:                                Normalization Functions.
                                                              (line  18)
* frexpl:                                Normalization Functions.
                                                              (line  19)
* fscanf:                                Formatted Input Functions.
                                                              (line  32)
* fseek:                                 File Positioning.    (line  63)
* fseeko:                                File Positioning.    (line  79)
* fseeko64:                              File Positioning.    (line  98)
* fsetpos:                               Portable Positioning.
                                                              (line  96)
* fsetpos64:                             Portable Positioning.
                                                              (line 110)
* fstat:                                 Reading Attributes.  (line  43)
* fstat64:                               Reading Attributes.  (line  58)
* fsync:                                 Synchronizing I/O.   (line  30)
* ftell:                                 File Positioning.    (line  22)
* ftello:                                File Positioning.    (line  31)
* ftello64:                              File Positioning.    (line  52)
* ftruncate:                             File Size.           (line  77)
* ftruncate64:                           File Size.           (line 131)
* ftrylockfile:                          Streams and Threads. (line  39)
* ftw:                                   Working with Directory Trees.
                                                              (line 127)
* ftw64:                                 Working with Directory Trees.
                                                              (line 176)
* funlockfile:                           Streams and Threads. (line  47)
* futimes:                               File Times.          (line 121)
* fwide:                                 Streams and I18N.    (line  59)
* fwprintf:                              Formatted Output Functions.
                                                              (line  30)
* fwrite:                                Block Input/Output.  (line  50)
* fwrite_unlocked:                       Block Input/Output.  (line  57)
* fwscanf:                               Formatted Input Functions.
                                                              (line  36)
* gamma:                                 Special Functions.   (line  51)
* gammaf:                                Special Functions.   (line  52)
* gammal:                                Special Functions.   (line  53)
* gcvt:                                  System V Number Conversion.
                                                              (line  55)
* get_avphys_pages:                      Query Memory Parameters.
                                                              (line  72)
* get_current_dir_name:                  Working Directory.   (line  87)
* get_nprocs:                            Processor Resources. (line  35)
* get_nprocs_conf:                       Processor Resources. (line  29)
* get_phys_pages:                        Query Memory Parameters.
                                                              (line  65)
* getc:                                  Character Input.     (line  44)
* getc_unlocked:                         Character Input.     (line  57)
* getchar:                               Character Input.     (line  67)
* getchar_unlocked:                      Character Input.     (line  75)
* getcontext:                            System V contexts.   (line  49)
* getcwd:                                Working Directory.   (line  24)
* getdate:                               General Time String Parsing.
                                                              (line  45)
* getdate_r:                             General Time String Parsing.
                                                              (line 146)
* getdelim:                              Line Input.          (line  55)
* getdomainnname:                        Host Identification. (line  99)
* getegid:                               Reading Persona.     (line  30)
* getenv:                                Environment Access.  (line  13)
* geteuid:                               Reading Persona.     (line  26)
* getfsent:                              fstab.               (line  99)
* getfsfile:                             fstab.               (line 124)
* getfsspec:                             fstab.               (line 110)
* getgid:                                Reading Persona.     (line  23)
* getgrent:                              Scanning All Groups. (line  48)
* getgrent_r:                            Scanning All Groups. (line  56)
* getgrgid:                              Lookup Group.        (line  11)
* getgrgid_r:                            Lookup Group.        (line  20)
* getgrnam:                              Lookup Group.        (line  37)
* getgrnam_r:                            Lookup Group.        (line  47)
* getgrouplist:                          Setting Groups.      (line  99)
* getgroups:                             Reading Persona.     (line  34)
* gethostbyaddr:                         Host Names.          (line  77)
* gethostbyaddr_r:                       Host Names.          (line 174)
* gethostbyname:                         Host Names.          (line  67)
* gethostbyname2:                        Host Names.          (line  71)
* gethostbyname2_r:                      Host Names.          (line 166)
* gethostbyname_r:                       Host Names.          (line 117)
* gethostent:                            Host Names.          (line 203)
* gethostid:                             Host Identification. (line 117)
* gethostname:                           Host Identification. (line  55)
* getitimer:                             Setting an Alarm.    (line  84)
* getline:                               Line Input.          (line  21)
* getloadavg:                            Processor Resources. (line  47)
* getlogin:                              Who Logged In.       (line  17)
* getmntent:                             mtab.                (line 129)
* getmntent_r:                           mtab.                (line 154)
* getnetbyaddr:                          Networks Database.   (line  43)
* getnetbyname:                          Networks Database.   (line  38)
* getnetent:                             Networks Database.   (line  63)
* getnetgrent:                           Lookup Netgroup.     (line  36)
* getnetgrent_r:                         Lookup Netgroup.     (line  50)
* getopt:                                Using Getopt.        (line  35)
* getopt_long:                           Getopt Long Options. (line  44)
* getopt_long_only:                      Getopt Long Options. (line  95)
* getpagesize:                           Query Memory Parameters.
                                                              (line  34)
* getpass:                               getpass.             (line  11)
* getpeername:                           Who is Connected.    (line   8)
* getpgid:                               Process Group Functions.
                                                              (line  67)
* getpgrp:                               Process Group Functions.
                                                              (line  62)
* getpid:                                Process Identification.
                                                              (line  17)
* getppid:                               Process Identification.
                                                              (line  21)
* getpriority:                           Traditional Scheduling Functions.
                                                              (line  25)
* getprotobyname:                        Protocols Database.  (line  51)
* getprotobynumber:                      Protocols Database.  (line  56)
* getprotoent:                           Protocols Database.  (line  74)
* getpt:                                 Allocation.          (line  11)
* getpwent:                              Scanning All Users.  (line  47)
* getpwent_r:                            Scanning All Users.  (line  57)
* getpwnam:                              Lookup User.         (line  37)
* getpwnam_r:                            Lookup User.         (line  47)
* getpwuid:                              Lookup User.         (line  11)
* getpwuid_r:                            Lookup User.         (line  20)
* getrlimit:                             Limits on Resources. (line  30)
* getrlimit64:                           Limits on Resources. (line  41)
* getrusage:                             Resource Usage.      (line  11)
* gets:                                  Line Input.          (line 128)
* getservbyname:                         Services Database.   (line  37)
* getservbyport:                         Services Database.   (line  47)
* getservent:                            Services Database.   (line  65)
* getsid:                                Process Group Functions.
                                                              (line  31)
* getsockname:                           Reading Address.     (line  12)
* getsockopt:                            Socket Option Functions.
                                                              (line  11)
* getsubopt:                             Suboptions.          (line  17)
* gettext:                               Translation with gettext.
                                                              (line  32)
* gettimeofday:                          High-Resolution Calendar.
                                                              (line  31)
* getuid:                                Reading Persona.     (line  20)
* getumask:                              Setting Permissions. (line  64)
* getutent:                              Manipulating the Database.
                                                              (line 122)
* getutent_r:                            Manipulating the Database.
                                                              (line 205)
* getutid:                               Manipulating the Database.
                                                              (line 135)
* getutid_r:                             Manipulating the Database.
                                                              (line 220)
* getutline:                             Manipulating the Database.
                                                              (line 161)
* getutline_r:                           Manipulating the Database.
                                                              (line 233)
* getutmp:                               XPG Functions.       (line 112)
* getutmpx:                              XPG Functions.       (line 117)
* getutxent:                             XPG Functions.       (line  80)
* getutxid:                              XPG Functions.       (line  89)
* getutxline:                            XPG Functions.       (line  94)
* getw:                                  Character Input.     (line 116)
* getwc:                                 Character Input.     (line  51)
* getwc_unlocked:                        Character Input.     (line  61)
* getwchar:                              Character Input.     (line  71)
* getwchar_unlocked:                     Character Input.     (line  79)
* getwd:                                 Working Directory.   (line  76)
* glob:                                  Calling Glob.        (line 162)
* glob64:                                Calling Glob.        (line 218)
* globfree:                              More Flags for Globbing.
                                                              (line 124)
* globfree64:                            More Flags for Globbing.
                                                              (line 130)
* gmtime:                                Broken-down Time.    (line 120)
* gmtime_r:                              Broken-down Time.    (line 132)
* grantpt:                               Allocation.          (line  23)
* gsignal:                               Signaling Yourself.  (line  16)
* gtty:                                  BSD Terminal Modes.  (line  35)
* hasmntopt:                             mtab.                (line 196)
* hcreate:                               Hash Search Function.
                                                              (line  14)
* hcreate_r:                             Hash Search Function.
                                                              (line 107)
* hdestroy:                              Hash Search Function.
                                                              (line  40)
* hdestroy_r:                            Hash Search Function.
                                                              (line 122)
* hsearch:                               Hash Search Function.
                                                              (line  80)
* hsearch_r:                             Hash Search Function.
                                                              (line 129)
* htonl:                                 Byte Order.          (line  44)
* htons:                                 Byte Order.          (line  36)
* hypot:                                 Exponents and Logarithms.
                                                              (line 137)
* hypotf:                                Exponents and Logarithms.
                                                              (line 138)
* hypotl:                                Exponents and Logarithms.
                                                              (line 139)
* iconv:                                 Generic Conversion Interface.
                                                              (line 110)
* iconv_close:                           Generic Conversion Interface.
                                                              (line  89)
* iconv_open:                            Generic Conversion Interface.
                                                              (line  28)
* if_freenameindex:                      Interface Naming.    (line  57)
* if_indextoname:                        Interface Naming.    (line  30)
* if_nameindex:                          Interface Naming.    (line  48)
* if_nametoindex:                        Interface Naming.    (line  25)
* IFTODT:                                Directory Entries.   (line  65)
* ilogb:                                 Exponents and Logarithms.
                                                              (line  69)
* ilogbf:                                Exponents and Logarithms.
                                                              (line  70)
* ilogbl:                                Exponents and Logarithms.
                                                              (line  71)
* imaxabs:                               Absolute Value.      (line  21)
* imaxdiv:                               Integer Division.    (line 101)
* index:                                 Search Functions.    (line 261)
* inet_addr:                             Host Address Functions.
                                                              (line  19)
* inet_aton:                             Host Address Functions.
                                                              (line  13)
* inet_lnaof:                            Host Address Functions.
                                                              (line  60)
* inet_makeaddr:                         Host Address Functions.
                                                              (line  55)
* inet_netof:                            Host Address Functions.
                                                              (line  68)
* inet_network:                          Host Address Functions.
                                                              (line  28)
* inet_ntoa:                             Host Address Functions.
                                                              (line  38)
* inet_ntop:                             Host Address Functions.
                                                              (line  85)
* inet_pton:                             Host Address Functions.
                                                              (line  76)
* initgroups:                            Setting Groups.      (line  81)
* initstate:                             BSD Random.          (line  32)
* initstate_r:                           BSD Random.          (line  89)
* innetgr:                               Netgroup Membership. (line  12)
* int:                                   Random Access Directory.
                                                              (line  20)
* ioctl:                                 IOCTLs.              (line  33)
* isalnum:                               Classification of Characters.
                                                              (line  49)
* isalpha:                               Classification of Characters.
                                                              (line  36)
* isascii:                               Classification of Characters.
                                                              (line 104)
* isatty:                                Is It a Terminal.    (line  14)
* isblank:                               Classification of Characters.
                                                              (line  86)
* iscntrl:                               Classification of Characters.
                                                              (line 100)
* isdigit:                               Classification of Characters.
                                                              (line  46)
* isfinite:                              Floating Point Classes.
                                                              (line  46)
* isgraph:                               Classification of Characters.
                                                              (line  91)
* isgreater:                             FP Comparison Functions.
                                                              (line  20)
* isgreaterequal:                        FP Comparison Functions.
                                                              (line  25)
* isinf:                                 Floating Point Classes.
                                                              (line  73)
* isinff:                                Floating Point Classes.
                                                              (line  74)
* isinfl:                                Floating Point Classes.
                                                              (line  75)
* isless:                                FP Comparison Functions.
                                                              (line  30)
* islessequal:                           FP Comparison Functions.
                                                              (line  35)
* islessgreater:                         FP Comparison Functions.
                                                              (line  40)
* islower:                               Classification of Characters.
                                                              (line  28)
* isnan:                                 Floating Point Classes.
                                                              (line  79)
* isnanf:                                Floating Point Classes.
                                                              (line  80)
* isnanl:                                Floating Point Classes.
                                                              (line  81)
* isnormal:                              Floating Point Classes.
                                                              (line  55)
* isprint:                               Classification of Characters.
                                                              (line  96)
* ispunct:                               Classification of Characters.
                                                              (line  59)
* isspace:                               Classification of Characters.
                                                              (line  63)
* isunordered:                           FP Comparison Functions.
                                                              (line  49)
* isupper:                               Classification of Characters.
                                                              (line  32)
* iswalnum:                              Classification of Wide Characters.
                                                              (line  69)
* iswalpha:                              Classification of Wide Characters.
                                                              (line  81)
* iswblank:                              Classification of Wide Characters.
                                                              (line 222)
* iswcntrl:                              Classification of Wide Characters.
                                                              (line  97)
* iswctype:                              Classification of Wide Characters.
                                                              (line  56)
* iswdigit:                              Classification of Wide Characters.
                                                              (line 107)
* iswgraph:                              Classification of Wide Characters.
                                                              (line 127)
* iswlower:                              Classification of Wide Characters.
                                                              (line 138)
* iswprint:                              Classification of Wide Characters.
                                                              (line 148)
* iswpunct:                              Classification of Wide Characters.
                                                              (line 158)
* iswspace:                              Classification of Wide Characters.
                                                              (line 168)
* iswupper:                              Classification of Wide Characters.
                                                              (line 197)
* iswxdigit:                             Classification of Wide Characters.
                                                              (line 207)
* isxdigit:                              Classification of Characters.
                                                              (line  54)
* j0:                                    Special Functions.   (line  68)
* j0f:                                   Special Functions.   (line  69)
* j0l:                                   Special Functions.   (line  70)
* j1:                                    Special Functions.   (line  74)
* j1f:                                   Special Functions.   (line  75)
* j1l:                                   Special Functions.   (line  76)
* jn:                                    Special Functions.   (line  80)
* jnf:                                   Special Functions.   (line  81)
* jnl:                                   Special Functions.   (line  82)
* jrand48:                               SVID Random.         (line  77)
* jrand48_r:                             SVID Random.         (line 226)
* kill:                                  Signaling Another Process.
                                                              (line  27)
* killpg:                                Signaling Another Process.
                                                              (line  79)
* l64a:                                  Encode Binary Data.  (line  13)
* labs:                                  Absolute Value.      (line  19)
* lcong48:                               SVID Random.         (line 129)
* lcong48_r:                             SVID Random.         (line 282)
* ldexp:                                 Normalization Functions.
                                                              (line  35)
* ldexpf:                                Normalization Functions.
                                                              (line  36)
* ldexpl:                                Normalization Functions.
                                                              (line  37)
* ldiv:                                  Integer Division.    (line  58)
* lfind:                                 Array Search Function.
                                                              (line  13)
* lgamma:                                Special Functions.   (line  23)
* lgamma_r:                              Special Functions.   (line  44)
* lgammaf:                               Special Functions.   (line  24)
* lgammaf_r:                             Special Functions.   (line  45)
* lgammal:                               Special Functions.   (line  25)
* lgammal_r:                             Special Functions.   (line  46)
* link:                                  Hard Links.          (line  28)
* lio_listio:                            Asynchronous Reads/Writes.
                                                              (line 175)
* lio_listio64:                          Asynchronous Reads/Writes.
                                                              (line 258)
* listen:                                Listening.           (line  30)
* llabs:                                 Absolute Value.      (line  20)
* lldiv:                                 Integer Division.    (line  77)
* llrint:                                Rounding Functions.  (line  71)
* llrintf:                               Rounding Functions.  (line  72)
* llrintl:                               Rounding Functions.  (line  73)
* llround:                               Rounding Functions.  (line  83)
* llroundf:                              Rounding Functions.  (line  84)
* llroundl:                              Rounding Functions.  (line  85)
* localeconv:                            The Lame Way to Locale Data.
                                                              (line  16)
* localtime:                             Broken-down Time.    (line  85)
* localtime_r:                           Broken-down Time.    (line 108)
* log:                                   Exponents and Logarithms.
                                                              (line  34)
* log10:                                 Exponents and Logarithms.
                                                              (line  44)
* log10f:                                Exponents and Logarithms.
                                                              (line  45)
* log10l:                                Exponents and Logarithms.
                                                              (line  46)
* log1p:                                 Exponents and Logarithms.
                                                              (line 155)
* log1pf:                                Exponents and Logarithms.
                                                              (line 156)
* log1pl:                                Exponents and Logarithms.
                                                              (line 157)
* log2:                                  Exponents and Logarithms.
                                                              (line  51)
* log2f:                                 Exponents and Logarithms.
                                                              (line  52)
* log2l:                                 Exponents and Logarithms.
                                                              (line  53)
* logb:                                  Exponents and Logarithms.
                                                              (line  57)
* logbf:                                 Exponents and Logarithms.
                                                              (line  58)
* logbl:                                 Exponents and Logarithms.
                                                              (line  59)
* logf:                                  Exponents and Logarithms.
                                                              (line  35)
* login:                                 Logging In and Out.  (line  22)
* login_tty:                             Logging In and Out.  (line  14)
* logl:                                  Exponents and Logarithms.
                                                              (line  36)
* logout:                                Logging In and Out.  (line  34)
* logwtmp:                               Logging In and Out.  (line  42)
* longjmp:                               Non-Local Details.   (line  22)
* lrand48:                               SVID Random.         (line  53)
* lrand48_r:                             SVID Random.         (line 187)
* lrint:                                 Rounding Functions.  (line  65)
* lrintf:                                Rounding Functions.  (line  66)
* lrintl:                                Rounding Functions.  (line  67)
* lround:                                Rounding Functions.  (line  77)
* lroundf:                               Rounding Functions.  (line  78)
* lroundl:                               Rounding Functions.  (line  79)
* lsearch:                               Array Search Function.
                                                              (line  29)
* lseek:                                 File Position Primitive.
                                                              (line  16)
* lseek64:                               File Position Primitive.
                                                              (line  97)
* lstat:                                 Reading Attributes.  (line  69)
* lstat64:                               Reading Attributes.  (line  79)
* lutimes:                               File Times.          (line 108)
* madvise:                               Memory-mapped I/O.   (line 237)
* main:                                  Program Arguments.   (line   6)
* makecontext:                           System V contexts.   (line  73)
* mallinfo:                              Statistics of Malloc.
                                                              (line  56)
* malloc:                                Basic Allocation.    (line  10)
* mallopt:                               Malloc Tunable Parameters.
                                                              (line  11)
* matherr:                               FP Exceptions.       (line  24)
* mblen:                                 Non-reentrant Character Conversion.
                                                              (line  73)
* mbrlen:                                Converting a Character.
                                                              (line 171)
* mbrtowc:                               Converting a Character.
                                                              (line  81)
* mbsinit:                               Keeping the state.   (line  47)
* mbsnrtowcs:                            Converting Strings.  (line 134)
* mbsrtowcs:                             Converting Strings.  (line  15)
* mbstowcs:                              Non-reentrant String Conversion.
                                                              (line  13)
* mbtowc:                                Non-reentrant Character Conversion.
                                                              (line   8)
* mcheck:                                Heap Consistency Checking.
                                                              (line  11)
* memalign:                              Aligned Memory Blocks.
                                                              (line  18)
* memccpy:                               Copying and Concatenation.
                                                              (line 150)
* memchr:                                Search Functions.    (line  11)
* memcmp:                                String/Array Comparison.
                                                              (line  25)
* memcpy:                                Copying and Concatenation.
                                                              (line  34)
* memfrob:                               Trivial Encryption.  (line  18)
* memmem:                                Search Functions.    (line 175)
* memmove:                               Copying and Concatenation.
                                                              (line 118)
* mempcpy:                               Copying and Concatenation.
                                                              (line  72)
* memrchr:                               Search Functions.    (line  49)
* memset:                                Copying and Concatenation.
                                                              (line 157)
* mkdir:                                 Creating Directories.
                                                              (line  10)
* mkdtemp:                               Temporary Files.     (line 177)
* mkfifo:                                FIFO Special Files.  (line  20)
* mknod:                                 Making Special Files.
                                                              (line  13)
* mkstemp:                               Temporary Files.     (line 159)
* mktemp:                                Temporary Files.     (line 145)
* mktime:                                Broken-down Time.    (line 139)
* mlock:                                 Page Lock Functions. (line  20)
* mlockall:                              Page Lock Functions. (line  72)
* mmap:                                  Memory-mapped I/O.   (line  35)
* mmap64:                                Memory-mapped I/O.   (line 128)
* modf:                                  Rounding Functions.  (line  89)
* modff:                                 Rounding Functions.  (line  90)
* modfl:                                 Rounding Functions.  (line  92)
* mount:                                 Mount-Unmount-Remount.
                                                              (line  19)
* mprobe:                                Heap Consistency Checking.
                                                              (line  50)
* mrand48:                               SVID Random.         (line  72)
* mrand48_r:                             SVID Random.         (line 214)
* mremap:                                Memory-mapped I/O.   (line 195)
* msync:                                 Memory-mapped I/O.   (line 161)
* mtrace:                                Tracing malloc.      (line   7)
* munlock:                               Page Lock Functions. (line  65)
* munlockall:                            Page Lock Functions. (line 138)
* munmap:                                Memory-mapped I/O.   (line 141)
* muntrace:                              Tracing malloc.      (line  27)
* nan:                                   FP Bit Twiddling.    (line  55)
* nanf:                                  FP Bit Twiddling.    (line  56)
* nanl:                                  FP Bit Twiddling.    (line  57)
* nanosleep:                             Sleeping.            (line  55)
* nearbyint:                             Rounding Functions.  (line  52)
* nearbyintf:                            Rounding Functions.  (line  53)
* nearbyintl:                            Rounding Functions.  (line  54)
* nextafter:                             FP Bit Twiddling.    (line  33)
* nextafterf:                            FP Bit Twiddling.    (line  34)
* nextafterl:                            FP Bit Twiddling.    (line  35)
* nexttoward:                            FP Bit Twiddling.    (line  49)
* nexttowardf:                           FP Bit Twiddling.    (line  50)
* nexttowardl:                           FP Bit Twiddling.    (line  51)
* nftw:                                  Working with Directory Trees.
                                                              (line 187)
* nftw64:                                Working with Directory Trees.
                                                              (line 250)
* ngettext:                              Advanced gettext functions.
                                                              (line  72)
* nice:                                  Traditional Scheduling Functions.
                                                              (line  90)
* nl_langinfo:                           The Elegant and Fast Way.
                                                              (line  13)
* notfound:                              Actions in the NSS configuration.
                                                              (line  25)
* nrand48:                               SVID Random.         (line  60)
* nrand48_r:                             SVID Random.         (line 200)
* ntohl:                                 Byte Order.          (line  50)
* ntohs:                                 Byte Order.          (line  40)
* ntp_adjtime:                           High Accuracy Clock. (line 151)
* ntp_gettime:                           High Accuracy Clock. (line  36)
* obstack_1grow:                         Growing Objects.     (line  46)
* obstack_1grow_fast:                    Extra Fast Growing.  (line  32)
* obstack_alignment_mask:                Obstacks Data Alignment.
                                                              (line  15)
* obstack_alloc:                         Allocation in an Obstack.
                                                              (line  11)
* obstack_base:                          Status of an Obstack.
                                                              (line  11)
* obstack_blank:                         Growing Objects.     (line  30)
* obstack_blank_fast:                    Extra Fast Growing.  (line  49)
* obstack_chunk_alloc:                   Preparing for Obstacks.
                                                              (line  11)
* obstack_chunk_free:                    Preparing for Obstacks.
                                                              (line  11)
* obstack_chunk_size:                    Obstack Chunks.      (line  38)
* obstack_copy:                          Allocation in an Obstack.
                                                              (line  41)
* obstack_copy0:                         Allocation in an Obstack.
                                                              (line  47)
* obstack_finish:                        Growing Objects.     (line  62)
* obstack_free:                          Freeing Obstack Objects.
                                                              (line  13)
* obstack_grow:                          Growing Objects.     (line  35)
* obstack_grow0:                         Growing Objects.     (line  41)
* obstack_init:                          Preparing for Obstacks.
                                                              (line  34)
* obstack_int_grow:                      Growing Objects.     (line  57)
* obstack_int_grow_fast:                 Extra Fast Growing.  (line  43)
* obstack_next_free:                     Status of an Obstack.
                                                              (line  22)
* obstack_object_size <1>:               Growing Objects.     (line  78)
* obstack_object_size:                   Status of an Obstack.
                                                              (line  28)
* obstack_printf:                        Dynamic Output.      (line  37)
* obstack_ptr_grow:                      Growing Objects.     (line  51)
* obstack_ptr_grow_fast:                 Extra Fast Growing.  (line  37)
* obstack_room:                          Extra Fast Growing.  (line  23)
* obstack_vprintf:                       Variable Arguments Output.
                                                              (line  98)
* offsetof:                              Structure Measurement.
                                                              (line  10)
* on_exit:                               Cleanups on Exit.    (line  24)
* open:                                  Opening and Closing Files.
                                                              (line  11)
* open64:                                Opening and Closing Files.
                                                              (line  93)
* open_memstream:                        String Streams.      (line  73)
* open_obstack_stream:                   Obstack Streams.     (line  10)
* opendir:                               Opening a Directory. (line  18)
* openlog:                               openlog.             (line  10)
* openpty:                               Pseudo-Terminal Pairs.
                                                              (line  11)
* parse_printf_format:                   Parsing a Template String.
                                                              (line  17)
* pathconf:                              Pathconf.            (line  14)
* pause:                                 Using Pause.         (line  11)
* pclose:                                Pipe to a Subprocess.
                                                              (line  39)
* perror:                                Error Messages.      (line  46)
* pipe:                                  Creating a Pipe.     (line  17)
* popen:                                 Pipe to a Subprocess.
                                                              (line  18)
* posix_memalign:                        Aligned Memory Blocks.
                                                              (line  26)
* pow:                                   Exponents and Logarithms.
                                                              (line 112)
* pow10:                                 Exponents and Logarithms.
                                                              (line  25)
* pow10f:                                Exponents and Logarithms.
                                                              (line  26)
* pow10l:                                Exponents and Logarithms.
                                                              (line  27)
* powf:                                  Exponents and Logarithms.
                                                              (line 113)
* powl:                                  Exponents and Logarithms.
                                                              (line 114)
* pread:                                 I/O Primitives.      (line 110)
* pread64:                               I/O Primitives.      (line 143)
* printf:                                Formatted Output Functions.
                                                              (line  14)
* printf_size:                           Predefined Printf Handlers.
                                                              (line  12)
* printf_size_info:                      Predefined Printf Handlers.
                                                              (line  43)
* psignal:                               Signal Messages.     (line  25)
* ptsname:                               Allocation.          (line  74)
* ptsname_r:                             Allocation.          (line  81)
* putc:                                  Simple Output.       (line  33)
* putc_unlocked:                         Simple Output.       (line  47)
* putchar:                               Simple Output.       (line  57)
* putchar_unlocked:                      Simple Output.       (line  65)
* putenv:                                Environment Access.  (line  21)
* putpwent:                              Writing a User Entry.
                                                              (line   7)
* puts:                                  Simple Output.       (line 113)
* pututline:                             Manipulating the Database.
                                                              (line 180)
* pututxline:                            XPG Functions.       (line  99)
* putw:                                  Simple Output.       (line 126)
* putwc:                                 Simple Output.       (line  40)
* putwc_unlocked:                        Simple Output.       (line  51)
* putwchar:                              Simple Output.       (line  61)
* putwchar_unlocked:                     Simple Output.       (line  69)
* pwrite:                                I/O Primitives.      (line 265)
* pwrite64:                              I/O Primitives.      (line 298)
* qecvt:                                 System V Number Conversion.
                                                              (line  67)
* qecvt_r:                               System V Number Conversion.
                                                              (line 112)
* qfcvt:                                 System V Number Conversion.
                                                              (line  73)
* qfcvt_r:                               System V Number Conversion.
                                                              (line 121)
* qgcvt:                                 System V Number Conversion.
                                                              (line  78)
* qsort:                                 Array Sort Function. (line  11)
* raise:                                 Signaling Yourself.  (line  10)
* rand:                                  ISO Random.          (line  20)
* rand_r:                                ISO Random.          (line  36)
* random:                                BSD Random.          (line  13)
* random_r:                              BSD Random.          (line  78)
* rawmemchr:                             Search Functions.    (line  24)
* read:                                  I/O Primitives.      (line  16)
* readdir:                               Reading/Closing Directory.
                                                              (line  11)
* readdir64:                             Reading/Closing Directory.
                                                              (line  75)
* readdir64_r:                           Reading/Closing Directory.
                                                              (line  84)
* readdir_r:                             Reading/Closing Directory.
                                                              (line  33)
* readlink:                              Symbolic Links.      (line  71)
* readv:                                 Scatter-Gather.      (line  32)
* realloc:                               Changing Block Size. (line  16)
* realpath:                              Symbolic Links.      (line 157)
* recv:                                  Receiving Data.      (line  12)
* recvfrom:                              Receiving Datagrams. (line  12)
* regcomp:                               POSIX Regexp Compilation.
                                                              (line  32)
* regerror:                              Regexp Cleanup.      (line  25)
* regexec:                               Matching POSIX Regexps.
                                                              (line  14)
* regfree:                               Regexp Cleanup.      (line  10)
* register_printf_function:              Registering New Conversions.
                                                              (line  11)
* remainder:                             Remainder Functions. (line  43)
* remainderf:                            Remainder Functions. (line  44)
* remainderl:                            Remainder Functions. (line  46)
* remove:                                Deleting Files.      (line  70)
* rename:                                Renaming Files.      (line   9)
* rewind:                                File Positioning.    (line 134)
* rewinddir:                             Random Access Directory.
                                                              (line  11)
* rindex:                                Search Functions.    (line 267)
* rint:                                  Rounding Functions.  (line  39)
* rintf:                                 Rounding Functions.  (line  40)
* rintl:                                 Rounding Functions.  (line  41)
* rmdir:                                 Deleting Files.      (line  52)
* round:                                 Rounding Functions.  (line  58)
* roundf:                                Rounding Functions.  (line  59)
* roundl:                                Rounding Functions.  (line  60)
* rpmatch:                               Yes-or-No Questions. (line  16)
* S_ISBLK:                               Testing File Type.   (line  34)
* S_ISCHR:                               Testing File Type.   (line  30)
* S_ISDIR:                               Testing File Type.   (line  27)
* S_ISFIFO:                              Testing File Type.   (line  41)
* S_ISLNK:                               Testing File Type.   (line  45)
* S_ISREG:                               Testing File Type.   (line  38)
* S_ISSOCK:                              Testing File Type.   (line  49)
* S_TYPEISMQ:                            Testing File Type.   (line  99)
* S_TYPEISSEM:                           Testing File Type.   (line 104)
* S_TYPEISSHM:                           Testing File Type.   (line 109)
* scalb:                                 Normalization Functions.
                                                              (line  49)
* scalbf:                                Normalization Functions.
                                                              (line  50)
* scalbl:                                Normalization Functions.
                                                              (line  51)
* scalbln:                               Normalization Functions.
                                                              (line  60)
* scalblnf:                              Normalization Functions.
                                                              (line  61)
* scalblnl:                              Normalization Functions.
                                                              (line  62)
* scalbn:                                Normalization Functions.
                                                              (line  54)
* scalbnf:                               Normalization Functions.
                                                              (line  55)
* scalbnl:                               Normalization Functions.
                                                              (line  56)
* scandir:                               Scanning Directory Content.
                                                              (line  14)
* scandir64:                             Scanning Directory Content.
                                                              (line  60)
* scanf:                                 Formatted Input Functions.
                                                              (line  10)
* sched_get_priority_max:                Basic Scheduling Functions.
                                                              (line 157)
* sched_get_priority_min:                Basic Scheduling Functions.
                                                              (line 143)
* sched_getaffinity:                     CPU Affinity.        (line  99)
* sched_getparam:                        Basic Scheduling Functions.
                                                              (line 122)
* sched_getscheduler:                    Basic Scheduling Functions.
                                                              (line  86)
* sched_rr_get_interval:                 Basic Scheduling Functions.
                                                              (line 172)
* sched_setaffinity:                     CPU Affinity.        (line 122)
* sched_setparam:                        Basic Scheduling Functions.
                                                              (line 114)
* sched_setscheduler:                    Basic Scheduling Functions.
                                                              (line  36)
* sched_yield:                           Basic Scheduling Functions.
                                                              (line 188)
* seed48:                                SVID Random.         (line 105)
* seed48_r:                              SVID Random.         (line 268)
* seekdir:                               Random Access Directory.
                                                              (line  25)
* select:                                Waiting for I/O.     (line  75)
* send:                                  Sending Data.        (line  14)
* sendto:                                Sending Datagrams.   (line  19)
* setbuf:                                Controlling Buffering.
                                                              (line  78)
* setbuffer:                             Controlling Buffering.
                                                              (line  87)
* setcontext:                            System V contexts.   (line 115)
* setdomainname:                         Host Identification. (line 108)
* setegid:                               Setting Groups.      (line  11)
* setenv:                                Environment Access.  (line  41)
* seteuid:                               Setting User ID.     (line  11)
* setfsent:                              fstab.               (line  82)
* setgid:                                Setting Groups.      (line  27)
* setgrent:                              Scanning All Groups. (line  44)
* setgroups:                             Setting Groups.      (line  70)
* sethostent:                            Host Names.          (line 193)
* sethostid:                             Host Identification. (line 131)
* sethostname:                           Host Identification. (line  80)
* setitimer:                             Setting an Alarm.    (line  69)
* setjmp:                                Non-Local Details.   (line  16)
* setkey:                                DES Encryption.      (line  34)
* setkey_r:                              DES Encryption.      (line  48)
* setlinebuf:                            Controlling Buffering.
                                                              (line  95)
* setlocale:                             Setting the Locale.  (line  25)
* setlogmask:                            setlogmask.          (line  10)
* setmntent:                             mtab.                (line 109)
* setnetent:                             Networks Database.   (line  54)
* setnetgrent:                           Lookup Netgroup.     (line  13)
* setpgid:                               Process Group Functions.
                                                              (line  83)
* setpgrp:                               Process Group Functions.
                                                              (line 115)
* setpriority:                           Traditional Scheduling Functions.
                                                              (line  47)
* setprotoent:                           Protocols Database.  (line  65)
* setpwent:                              Scanning All Users.  (line  43)
* setregid:                              Setting Groups.      (line  38)
* setreuid:                              Setting User ID.     (line  48)
* setrlimit:                             Limits on Resources. (line  51)
* setrlimit64:                           Limits on Resources. (line  69)
* setservent:                            Services Database.   (line  56)
* setsid:                                Process Group Functions.
                                                              (line  11)
* setsockopt:                            Socket Option Functions.
                                                              (line  35)
* setstate:                              BSD Random.          (line  43)
* setstate_r:                            BSD Random.          (line  95)
* settimeofday:                          High-Resolution Calendar.
                                                              (line  51)
* setuid:                                Setting User ID.     (line  34)
* setutent:                              Manipulating the Database.
                                                              (line 114)
* setutxent:                             XPG Functions.       (line  76)
* setvbuf:                               Controlling Buffering.
                                                              (line  15)
* shutdown:                              Closing a Socket.    (line  17)
* sigaction:                             Advanced Signal Handling.
                                                              (line  41)
* sigaddset:                             Signal Sets.         (line  44)
* sigaltstack:                           Signal Stack.        (line  71)
* sigblock:                              Blocking in BSD.     (line  17)
* sigdelset:                             Signal Sets.         (line  55)
* sigemptyset:                           Signal Sets.         (line  36)
* sigfillset:                            Signal Sets.         (line  40)
* siginterrupt:                          BSD Handler.         (line  52)
* sigismember:                           Signal Sets.         (line  64)
* siglongjmp:                            Non-Local Exits and Signals.
                                                              (line  30)
* sigmask:                               Blocking in BSD.     (line   7)
* signal:                                Basic Signal Handling.
                                                              (line  21)
* signbit:                               FP Bit Twiddling.    (line  24)
* significand:                           Normalization Functions.
                                                              (line  66)
* significandf:                          Normalization Functions.
                                                              (line  67)
* significandl:                          Normalization Functions.
                                                              (line  68)
* sigpause:                              Blocking in BSD.     (line  29)
* sigpending:                            Checking for Pending Signals.
                                                              (line  10)
* sigprocmask:                           Process Signal Mask. (line  22)
* sigsetjmp:                             Non-Local Exits and Signals.
                                                              (line  25)
* sigsetmask:                            Blocking in BSD.     (line  23)
* sigstack:                              Signal Stack.        (line 112)
* sigsuspend:                            Sigsuspend.          (line  12)
* sigvec:                                BSD Handler.         (line  46)
* sin:                                   Trig Functions.      (line  19)
* sincos:                                Trig Functions.      (line  46)
* sincosf:                               Trig Functions.      (line  47)
* sincosl:                               Trig Functions.      (line  49)
* sinf:                                  Trig Functions.      (line  20)
* sinh:                                  Hyperbolic Functions.
                                                              (line  10)
* sinhf:                                 Hyperbolic Functions.
                                                              (line  11)
* sinhl:                                 Hyperbolic Functions.
                                                              (line  12)
* sinl:                                  Trig Functions.      (line  21)
* sleep:                                 Sleeping.            (line  15)
* snprintf:                              Formatted Output Functions.
                                                              (line  78)
* socket:                                Creating a Socket.   (line  10)
* socketpair:                            Socket Pairs.        (line  15)
* sprintf:                               Formatted Output Functions.
                                                              (line  34)
* sqrt:                                  Exponents and Logarithms.
                                                              (line 123)
* sqrtf:                                 Exponents and Logarithms.
                                                              (line 124)
* sqrtl:                                 Exponents and Logarithms.
                                                              (line 125)
* srand:                                 ISO Random.          (line  24)
* srand48:                               SVID Random.         (line  87)
* srand48_r:                             SVID Random.         (line 255)
* srandom:                               BSD Random.          (line  22)
* srandom_r:                             BSD Random.          (line  83)
* sscanf:                                Formatted Input Functions.
                                                              (line  40)
* ssignal:                               Basic Signal Handling.
                                                              (line 138)
* stat:                                  Reading Attributes.  (line  12)
* stat64:                                Reading Attributes.  (line  33)
* stime:                                 Simple Calendar Time.
                                                              (line  40)
* stpcpy:                                Copying and Concatenation.
                                                              (line 261)
* stpncpy:                               Copying and Concatenation.
                                                              (line 304)
* strcasecmp:                            String/Array Comparison.
                                                              (line 112)
* strcasestr:                            Search Functions.    (line 163)
* strcat:                                Copying and Concatenation.
                                                              (line 402)
* strchr:                                Search Functions.    (line  56)
* strchrnul:                             Search Functions.    (line  86)
* strcmp:                                String/Array Comparison.
                                                              (line  80)
* strcoll:                               Collation Functions. (line  39)
* strcpy:                                Copying and Concatenation.
                                                              (line 169)
* strcspn:                               Search Functions.    (line 206)
* strdup:                                Copying and Concatenation.
                                                              (line 230)
* strdupa:                               Copying and Concatenation.
                                                              (line 351)
* strerror:                              Error Messages.      (line  14)
* strerror_r:                            Error Messages.      (line  28)
* strfmon:                               Formatting Numbers.  (line  17)
* strfry:                                strfry.              (line  16)
* strftime:                              Formatting Calendar Time.
                                                              (line  60)
* strlen:                                String Length.       (line  10)
* strncasecmp:                           String/Array Comparison.
                                                              (line 143)
* strncat:                               Copying and Concatenation.
                                                              (line 560)
* strncmp:                               String/Array Comparison.
                                                              (line 130)
* strncpy:                               Copying and Concatenation.
                                                              (line 183)
* strndup:                               Copying and Concatenation.
                                                              (line 247)
* strndupa:                              Copying and Concatenation.
                                                              (line 389)
* strnlen:                               String Length.       (line  79)
* strpbrk:                               Search Functions.    (line 232)
* strptime:                              Low-Level Time String Parsing.
                                                              (line  13)
* strrchr:                               Search Functions.    (line 120)
* strsep:                                Finding Tokens in a String.
                                                              (line 156)
* strsignal:                             Signal Messages.     (line  15)
* strspn:                                Search Functions.    (line 182)
* strstr:                                Search Functions.    (line 134)
* strtod:                                Parsing of Floats.   (line  14)
* strtof:                                Parsing of Floats.   (line  81)
* strtoimax:                             Parsing of Integers. (line 155)
* strtok:                                Finding Tokens in a String.
                                                              (line  13)
* strtok_r:                              Finding Tokens in a String.
                                                              (line 144)
* strtol:                                Parsing of Integers. (line  14)
* strtold:                               Parsing of Floats.   (line  82)
* strtoll:                               Parsing of Integers. (line  98)
* strtoq:                                Parsing of Integers. (line 119)
* strtoul:                               Parsing of Integers. (line  76)
* strtoull:                              Parsing of Integers. (line 130)
* strtoumax:                             Parsing of Integers. (line 176)
* strtouq:                               Parsing of Integers. (line 144)
* strverscmp:                            String/Array Comparison.
                                                              (line 178)
* strxfrm:                               Collation Functions. (line  76)
* stty:                                  BSD Terminal Modes.  (line  41)
* success:                               Actions in the NSS configuration.
                                                              (line  21)
* SUN_LEN:                               Local Namespace Details.
                                                              (line  47)
* swapcontext:                           System V contexts.   (line 143)
* swprintf:                              Formatted Output Functions.
                                                              (line  56)
* swscanf:                               Formatted Input Functions.
                                                              (line  50)
* symlink:                               Symbolic Links.      (line  46)
* sync:                                  Synchronizing I/O.   (line  16)
* syscall:                               System Calls.        (line  40)
* sysconf:                               Sysconf Definition.  (line   7)
* sysctl:                                System Parameters.   (line  13)
* syslog:                                syslog; vsyslog.     (line  10)
* system:                                Running a Command.   (line  12)
* sysv_signal:                           Basic Signal Handling.
                                                              (line 129)
* tan:                                   Trig Functions.      (line  31)
* tanf:                                  Trig Functions.      (line  32)
* tanh:                                  Hyperbolic Functions.
                                                              (line  24)
* tanhf:                                 Hyperbolic Functions.
                                                              (line  25)
* tanhl:                                 Hyperbolic Functions.
                                                              (line  26)
* tanl:                                  Trig Functions.      (line  33)
* tcdrain:                               Line Control.        (line  35)
* tcflow:                                Line Control.        (line  94)
* tcflush:                               Line Control.        (line  60)
* tcgetattr:                             Mode Functions.      (line   7)
* tcgetpgrp:                             Terminal Access Functions.
                                                              (line  15)
* tcgetsid:                              Terminal Access Functions.
                                                              (line  75)
* tcsendbreak:                           Line Control.        (line  15)
* tcsetattr:                             Mode Functions.      (line  23)
* tcsetpgrp:                             Terminal Access Functions.
                                                              (line  40)
* tdelete:                               Tree Search Function.
                                                              (line  67)
* tdestroy:                              Tree Search Function.
                                                              (line  77)
* TEMP_FAILURE_RETRY:                    Interrupted Primitives.
                                                              (line  21)
* tempnam:                               Temporary Files.     (line  94)
* textdomain:                            Locating gettext catalog.
                                                              (line  71)
* tfind:                                 Tree Search Function.
                                                              (line  55)
* tgamma:                                Special Functions.   (line  59)
* tgammaf:                               Special Functions.   (line  60)
* tgammal:                               Special Functions.   (line  61)
* time:                                  Simple Calendar Time.
                                                              (line  33)
* timegm:                                Broken-down Time.    (line 170)
* timelocal:                             Broken-down Time.    (line 161)
* times:                                 Processor Time.      (line  43)
* tmpfile:                               Temporary Files.     (line  20)
* tmpfile64:                             Temporary Files.     (line  33)
* tmpnam:                                Temporary Files.     (line  45)
* tmpnam_r:                              Temporary Files.     (line  67)
* toascii:                               Case Conversion.     (line  33)
* tolower:                               Case Conversion.     (line  24)
* toupper:                               Case Conversion.     (line  29)
* towctrans:                             Wide Character Case Conversion.
                                                              (line  34)
* towlower:                              Wide Character Case Conversion.
                                                              (line  45)
* towupper:                              Wide Character Case Conversion.
                                                              (line  56)
* trunc:                                 Rounding Functions.  (line  32)
* truncate:                              File Size.           (line  26)
* truncate64:                            File Size.           (line  66)
* truncf:                                Rounding Functions.  (line  33)
* truncl:                                Rounding Functions.  (line  34)
* tryagain:                              Actions in the NSS configuration.
                                                              (line  35)
* tsearch:                               Tree Search Function.
                                                              (line  28)
* ttyname:                               Is It a Terminal.    (line  22)
* ttyname_r:                             Is It a Terminal.    (line  30)
* twalk:                                 Tree Search Function.
                                                              (line 127)
* tzset:                                 Time Zone Functions. (line  33)
* ulimit:                                Limits on Resources. (line 178)
* umask:                                 Setting Permissions. (line  44)
* umount:                                Mount-Unmount-Remount.
                                                              (line 252)
* umount2:                               Mount-Unmount-Remount.
                                                              (line 197)
* uname:                                 Platform Type.       (line  70)
* unavail:                               Actions in the NSS configuration.
                                                              (line  29)
* ungetc:                                How Unread.          (line  10)
* ungetwc:                               How Unread.          (line  45)
* unlink:                                Deleting Files.      (line  14)
* unlockpt:                              Allocation.          (line  56)
* unsetenv:                              Environment Access.  (line  58)
* updwtmp:                               Manipulating the Database.
                                                              (line 276)
* utime:                                 File Times.          (line  51)
* utimes:                                File Times.          (line  97)
* utmpname:                              Manipulating the Database.
                                                              (line 252)
* utmpxname:                             XPG Functions.       (line 104)
* va_alist:                              Old Varargs.         (line  31)
* va_arg:                                Argument Macros.     (line  21)
* va_dcl:                                Old Varargs.         (line  35)
* va_end:                                Argument Macros.     (line  32)
* va_start <1>:                          Argument Macros.     (line  13)
* va_start:                              Old Varargs.         (line  39)
* valloc:                                Aligned Memory Blocks.
                                                              (line  40)
* vasprintf:                             Variable Arguments Output.
                                                              (line  93)
* verr:                                  Error Messages.      (line 297)
* verrx:                                 Error Messages.      (line 309)
* versionsort:                           Scanning Directory Content.
                                                              (line  49)
* versionsort64:                         Scanning Directory Content.
                                                              (line  84)
* vfork:                                 Creating a Process.  (line  59)
* vfprintf:                              Variable Arguments Output.
                                                              (line  69)
* vfscanf:                               Variable Arguments Input.
                                                              (line  28)
* vfwprintf:                             Variable Arguments Output.
                                                              (line  74)
* vfwscanf:                              Variable Arguments Input.
                                                              (line  33)
* vlimit:                                Limits on Resources. (line 215)
* vprintf:                               Variable Arguments Output.
                                                              (line  58)
* vscanf:                                Variable Arguments Input.
                                                              (line  17)
* vsnprintf:                             Variable Arguments Output.
                                                              (line  88)
* vsprintf:                              Variable Arguments Output.
                                                              (line  78)
* vsscanf:                               Variable Arguments Input.
                                                              (line  38)
* vswprintf:                             Variable Arguments Output.
                                                              (line  83)
* vswscanf:                              Variable Arguments Input.
                                                              (line  43)
* vsyslog:                               syslog; vsyslog.     (line 147)
* vtimes:                                Resource Usage.      (line 108)
* vwarn:                                 Error Messages.      (line 274)
* vwarnx:                                Error Messages.      (line 286)
* vwprintf:                              Variable Arguments Output.
                                                              (line  63)
* vwscanf:                               Variable Arguments Input.
                                                              (line  22)
* wait:                                  Process Completion.  (line 101)
* wait3:                                 BSD Wait Functions.  (line  44)
* wait4:                                 Process Completion.  (line 119)
* waitpid:                               Process Completion.  (line  11)
* warn:                                  Error Messages.      (line 268)
* warnx:                                 Error Messages.      (line 279)
* WCOREDUMP:                             Process Completion Status.
                                                              (line  31)
* wcpcpy:                                Copying and Concatenation.
                                                              (line 291)
* wcpncpy:                               Copying and Concatenation.
                                                              (line 327)
* wcrtomb:                               Converting a Character.
                                                              (line 245)
* wcscasecmp:                            String/Array Comparison.
                                                              (line 121)
* wcscat:                                Copying and Concatenation.
                                                              (line 420)
* wcschr:                                Search Functions.    (line  74)
* wcschrnul:                             Search Functions.    (line  93)
* wcscmp:                                String/Array Comparison.
                                                              (line  96)
* wcscoll:                               Collation Functions. (line  44)
* wcscpy:                                Copying and Concatenation.
                                                              (line 176)
* wcscspn:                               Search Functions.    (line 224)
* wcsdup:                                Copying and Concatenation.
                                                              (line 237)
* wcsftime:                              Formatting Calendar Time.
                                                              (line 395)
* wcslen:                                String Length.       (line  67)
* wcsncasecmp:                           String/Array Comparison.
                                                              (line 151)
* wcsncat:                               Copying and Concatenation.
                                                              (line 580)
* wcsncmp:                               String/Array Comparison.
                                                              (line 137)
* wcsncpy:                               Copying and Concatenation.
                                                              (line 207)
* wcsnlen:                               String Length.       (line  94)
* wcsnrtombs:                            Converting Strings.  (line 184)
* wcspbrk:                               Search Functions.    (line 251)
* wcsrchr:                               Search Functions.    (line 129)
* wcsrtombs:                             Converting Strings.  (line  91)
* wcsspn:                                Search Functions.    (line 199)
* wcsstr:                                Search Functions.    (line 148)
* wcstod:                                Parsing of Floats.   (line  93)
* wcstof:                                Parsing of Floats.   (line  94)
* wcstoimax:                             Parsing of Integers. (line 169)
* wcstok:                                Finding Tokens in a String.
                                                              (line  53)
* wcstol:                                Parsing of Integers. (line  69)
* wcstold:                               Parsing of Floats.   (line  96)
* wcstoll:                               Parsing of Integers. (line 112)
* wcstombs:                              Non-reentrant String Conversion.
                                                              (line  49)
* wcstoq:                                Parsing of Integers. (line 123)
* wcstoul:                               Parsing of Integers. (line  91)
* wcstoull:                              Parsing of Integers. (line 137)
* wcstoumax:                             Parsing of Integers. (line 184)
* wcstouq:                               Parsing of Integers. (line 148)
* wcswcs:                                Search Functions.    (line 157)
* wcsxfrm:                               Collation Functions. (line 104)
* wctob:                                 Converting a Character.
                                                              (line  65)
* wctomb:                                Non-reentrant Character Conversion.
                                                              (line  38)
* wctrans:                               Wide Character Case Conversion.
                                                              (line  20)
* wctype:                                Classification of Wide Characters.
                                                              (line  37)
* WEXITSTATUS:                           Process Completion Status.
                                                              (line  17)
* WIFEXITED:                             Process Completion Status.
                                                              (line  13)
* WIFSIGNALED:                           Process Completion Status.
                                                              (line  22)
* WIFSTOPPED:                            Process Completion Status.
                                                              (line  35)
* wmemchr:                               Search Functions.    (line  18)
* wmemcmp:                               String/Array Comparison.
                                                              (line  35)
* wmemcpy:                               Copying and Concatenation.
                                                              (line  51)
* wmemmove:                              Copying and Concatenation.
                                                              (line 128)
* wmempcpy:                              Copying and Concatenation.
                                                              (line  95)
* wmemset:                               Copying and Concatenation.
                                                              (line 163)
* wordexp:                               Calling Wordexp.     (line  41)
* wordfree:                              Calling Wordexp.     (line  89)
* wprintf:                               Formatted Output Functions.
                                                              (line  20)
* write:                                 I/O Primitives.      (line 157)
* writev:                                Scatter-Gather.      (line  47)
* wscanf:                                Formatted Input Functions.
                                                              (line  21)
* WSTOPSIG:                              Process Completion Status.
                                                              (line  38)
* WTERMSIG:                              Process Completion Status.
                                                              (line  27)
* y0:                                    Special Functions.   (line  86)
* y0f:                                   Special Functions.   (line  87)
* y0l:                                   Special Functions.   (line  88)
* y1:                                    Special Functions.   (line  94)
* y1f:                                   Special Functions.   (line  95)
* y1l:                                   Special Functions.   (line  96)
* yn:                                    Special Functions.   (line 102)
* ynf:                                   Special Functions.   (line 103)
* ynl:                                   Special Functions.   (line 104)


File: libc.info,  Node: Variable Index,  Next: File Index,  Prev: Function Index,  Up: Top

Variable and Constant Macro Index
*********************************

 [index ]
* Menu:

* (:                                     Error Messages.      (line 207)
* (*__gconv_end_fct):                    glibc iconv Implementation.
                                                              (line 560)
* (*__gconv_fct):                        glibc iconv Implementation.
                                                              (line 580)
* (*__gconv_init_fct):                   glibc iconv Implementation.
                                                              (line 404)
* __free_hook:                           Hooks for Malloc.    (line  36)
* __malloc_hook:                         Hooks for Malloc.    (line  14)
* __malloc_initialize_hook:              Hooks for Malloc.    (line  66)
* __memalign_hook:                       Hooks for Malloc.    (line  47)
* __realloc_hook:                        Hooks for Malloc.    (line  25)
* _BSD_SOURCE:                           Feature Test Macros. (line  71)
* _Complex_I:                            Complex Numbers.     (line  18)
* _FILE_OFFSET_BITS:                     Feature Test Macros. (line 142)
* _GNU_SOURCE:                           Feature Test Macros. (line 174)
* _IOFBF:                                Controlling Buffering.
                                                              (line  42)
* _IOLBF:                                Controlling Buffering.
                                                              (line  47)
* _IONBF:                                Controlling Buffering.
                                                              (line  52)
* _ISOC99_SOURCE:                        Feature Test Macros. (line 168)
* _LARGEFILE64_SOURCE:                   Feature Test Macros. (line 125)
* _LARGEFILE_SOURCE:                     Feature Test Macros. (line 114)
* _PATH_FSTAB:                           Mount Information.   (line  29)
* _PATH_MNTTAB:                          Mount Information.   (line  29)
* _PATH_MOUNTED:                         Mount Information.   (line  29)
* _PATH_UTMP:                            Manipulating the Database.
                                                              (line 260)
* _PATH_WTMP:                            Manipulating the Database.
                                                              (line 263)
* _POSIX2_C_DEV:                         System Options.      (line  42)
* _POSIX2_C_VERSION:                     Version Supported.   (line  28)
* _POSIX2_FORT_DEV:                      System Options.      (line  48)
* _POSIX2_FORT_RUN:                      System Options.      (line  53)
* _POSIX2_LOCALEDEF:                     System Options.      (line  59)
* _POSIX2_SW_DEV:                        System Options.      (line  64)
* _POSIX_C_SOURCE:                       Feature Test Macros. (line  46)
* _POSIX_CHOWN_RESTRICTED:               Options for Files.   (line  27)
* _POSIX_JOB_CONTROL:                    System Options.      (line  20)
* _POSIX_NO_TRUNC:                       Options for Files.   (line  34)
* _POSIX_SAVED_IDS:                      System Options.      (line  26)
* _POSIX_SOURCE:                         Feature Test Macros. (line  38)
* _POSIX_VDISABLE <1>:                   Options for Files.   (line  39)
* _POSIX_VDISABLE:                       Special Characters.  (line  22)
* _POSIX_VERSION:                        Version Supported.   (line   7)
* _REENTRANT:                            Feature Test Macros. (line 193)
* _SC_2_C_DEV:                           Constants for Sysconf.
                                                              (line 241)
* _SC_2_FORT_DEV:                        Constants for Sysconf.
                                                              (line 245)
* _SC_2_FORT_RUN:                        Constants for Sysconf.
                                                              (line 249)
* _SC_2_LOCALEDEF:                       Constants for Sysconf.
                                                              (line 253)
* _SC_2_SW_DEV:                          Constants for Sysconf.
                                                              (line 257)
* _SC_2_VERSION:                         Constants for Sysconf.
                                                              (line 296)
* _SC_AIO_LISTIO_MAX:                    Constants for Sysconf.
                                                              (line  98)
* _SC_AIO_MAX:                           Constants for Sysconf.
                                                              (line 102)
* _SC_AIO_PRIO_DELTA_MAX:                Constants for Sysconf.
                                                              (line 105)
* _SC_ARG_MAX:                           Constants for Sysconf.
                                                              (line  10)
* _SC_ASYNCHRONOUS_IO:                   Constants for Sysconf.
                                                              (line  58)
* _SC_ATEXIT_MAX:                        Constants for Sysconf.
                                                              (line 317)
* _SC_AVPHYS_PAGES <1>:                  Query Memory Parameters.
                                                              (line  49)
* _SC_AVPHYS_PAGES:                      Constants for Sysconf.
                                                              (line 314)
* _SC_BC_BASE_MAX:                       Constants for Sysconf.
                                                              (line 261)
* _SC_BC_DIM_MAX:                        Constants for Sysconf.
                                                              (line 264)
* _SC_BC_SCALE_MAX:                      Constants for Sysconf.
                                                              (line 267)
* _SC_BC_STRING_MAX:                     Constants for Sysconf.
                                                              (line 270)
* _SC_CHAR_BIT:                          Constants for Sysconf.
                                                              (line 358)
* _SC_CHAR_MAX:                          Constants for Sysconf.
                                                              (line 361)
* _SC_CHAR_MIN:                          Constants for Sysconf.
                                                              (line 365)
* _SC_CHARCLASS_NAME_MAX:                Constants for Sysconf.
                                                              (line  41)
* _SC_CHILD_MAX:                         Constants for Sysconf.
                                                              (line  13)
* _SC_CLK_TCK:                           Constants for Sysconf.
                                                              (line  37)
* _SC_COLL_WEIGHTS_MAX:                  Constants for Sysconf.
                                                              (line 274)
* _SC_DELAYTIMER_MAX:                    Constants for Sysconf.
                                                              (line 110)
* _SC_EQUIV_CLASS_MAX:                   Constants for Sysconf.
                                                              (line 286)
* _SC_EXPR_NEST_MAX:                     Constants for Sysconf.
                                                              (line 278)
* _SC_FSYNC:                             Constants for Sysconf.
                                                              (line  70)
* _SC_GETGR_R_SIZE_MAX:                  Constants for Sysconf.
                                                              (line 186)
* _SC_GETPW_R_SIZE_MAX:                  Constants for Sysconf.
                                                              (line 190)
* _SC_INT_MAX:                           Constants for Sysconf.
                                                              (line 369)
* _SC_INT_MIN:                           Constants for Sysconf.
                                                              (line 373)
* _SC_JOB_CONTROL:                       Constants for Sysconf.
                                                              (line  28)
* _SC_LINE_MAX:                          Constants for Sysconf.
                                                              (line 282)
* _SC_LOGIN_NAME_MAX:                    Constants for Sysconf.
                                                              (line 194)
* _SC_LONG_BIT:                          Constants for Sysconf.
                                                              (line 377)
* _SC_MAPPED_FILES:                      Constants for Sysconf.
                                                              (line  73)
* _SC_MB_LEN_MAX:                        Constants for Sysconf.
                                                              (line 383)
* _SC_MEMLOCK:                           Constants for Sysconf.
                                                              (line  76)
* _SC_MEMLOCK_RANGE:                     Constants for Sysconf.
                                                              (line  79)
* _SC_MEMORY_PROTECTION:                 Constants for Sysconf.
                                                              (line  83)
* _SC_MESSAGE_PASSING:                   Constants for Sysconf.
                                                              (line  87)
* _SC_MQ_OPEN_MAX:                       Constants for Sysconf.
                                                              (line 114)
* _SC_MQ_PRIO_MAX:                       Constants for Sysconf.
                                                              (line 117)
* _SC_NGROUPS_MAX:                       Constants for Sysconf.
                                                              (line  25)
* _SC_NL_ARGMAX:                         Constants for Sysconf.
                                                              (line 427)
* _SC_NL_LANGMAX:                        Constants for Sysconf.
                                                              (line 430)
* _SC_NL_MSGMAX:                         Constants for Sysconf.
                                                              (line 433)
* _SC_NL_NMAX:                           Constants for Sysconf.
                                                              (line 436)
* _SC_NL_SETMAX:                         Constants for Sysconf.
                                                              (line 439)
* _SC_NL_TEXTMAX:                        Constants for Sysconf.
                                                              (line 442)
* _SC_NPROCESSORS_CONF <1>:              Constants for Sysconf.
                                                              (line 305)
* _SC_NPROCESSORS_CONF:                  Processor Resources. (line  13)
* _SC_NPROCESSORS_ONLN <1>:              Processor Resources. (line  19)
* _SC_NPROCESSORS_ONLN:                  Constants for Sysconf.
                                                              (line 308)
* _SC_NZERO:                             Constants for Sysconf.
                                                              (line 387)
* _SC_OPEN_MAX:                          Constants for Sysconf.
                                                              (line  16)
* _SC_PAGESIZE <1>:                      Query Memory Parameters.
                                                              (line  29)
* _SC_PAGESIZE <2>:                      Memory-mapped I/O.   (line  29)
* _SC_PAGESIZE:                          Constants for Sysconf.
                                                              (line 300)
* _SC_PHYS_PAGES <1>:                    Constants for Sysconf.
                                                              (line 311)
* _SC_PHYS_PAGES:                        Query Memory Parameters.
                                                              (line  43)
* _SC_PII:                               Constants for Sysconf.
                                                              (line 137)
* _SC_PII_INTERNET:                      Constants for Sysconf.
                                                              (line 146)
* _SC_PII_INTERNET_DGRAM:                Constants for Sysconf.
                                                              (line 162)
* _SC_PII_INTERNET_STREAM:               Constants for Sysconf.
                                                              (line 158)
* _SC_PII_OSI:                           Constants for Sysconf.
                                                              (line 149)
* _SC_PII_OSI_CLTS:                      Constants for Sysconf.
                                                              (line 169)
* _SC_PII_OSI_COTS:                      Constants for Sysconf.
                                                              (line 166)
* _SC_PII_OSI_M:                         Constants for Sysconf.
                                                              (line 172)
* _SC_PII_SOCKET:                        Constants for Sysconf.
                                                              (line 143)
* _SC_PII_XTI:                           Constants for Sysconf.
                                                              (line 140)
* _SC_PRIORITIZED_IO:                    Constants for Sysconf.
                                                              (line  62)
* _SC_PRIORITY_SCHEDULING:               Constants for Sysconf.
                                                              (line  51)
* _SC_REALTIME_SIGNALS:                  Constants for Sysconf.
                                                              (line  47)
* _SC_RTSIG_MAX:                         Constants for Sysconf.
                                                              (line 120)
* _SC_SAVED_IDS:                         Constants for Sysconf.
                                                              (line  31)
* _SC_SCHAR_MAX:                         Constants for Sysconf.
                                                              (line 395)
* _SC_SCHAR_MIN:                         Constants for Sysconf.
                                                              (line 399)
* _SC_SELECT:                            Constants for Sysconf.
                                                              (line 152)
* _SC_SEM_NSEMS_MAX:                     Constants for Sysconf.
                                                              (line 123)
* _SC_SEM_VALUE_MAX:                     Constants for Sysconf.
                                                              (line 127)
* _SC_SEMAPHORES:                        Constants for Sysconf.
                                                              (line  91)
* _SC_SHARED_MEMORY_OBJECTS:             Constants for Sysconf.
                                                              (line  94)
* _SC_SHRT_MAX:                          Constants for Sysconf.
                                                              (line 403)
* _SC_SHRT_MIN:                          Constants for Sysconf.
                                                              (line 407)
* _SC_SIGQUEUE_MAX:                      Constants for Sysconf.
                                                              (line 131)
* _SC_STREAM_MAX:                        Constants for Sysconf.
                                                              (line  19)
* _SC_SYNCHRONIZED_IO:                   Constants for Sysconf.
                                                              (line  66)
* _SC_T_IOV_MAX:                         Constants for Sysconf.
                                                              (line 175)
* _SC_THREAD_ATTR_STACKADDR:             Constants for Sysconf.
                                                              (line 217)
* _SC_THREAD_ATTR_STACKSIZE:             Constants for Sysconf.
                                                              (line 221)
* _SC_THREAD_DESTRUCTOR_ITERATIONS:      Constants for Sysconf.
                                                              (line 201)
* _SC_THREAD_KEYS_MAX:                   Constants for Sysconf.
                                                              (line 205)
* _SC_THREAD_PRIO_INHERIT:               Constants for Sysconf.
                                                              (line 229)
* _SC_THREAD_PRIO_PROTECT:               Constants for Sysconf.
                                                              (line 233)
* _SC_THREAD_PRIORITY_SCHEDULING:        Constants for Sysconf.
                                                              (line 225)
* _SC_THREAD_PROCESS_SHARED:             Constants for Sysconf.
                                                              (line 237)
* _SC_THREAD_SAFE_FUNCTIONS:             Constants for Sysconf.
                                                              (line 182)
* _SC_THREAD_STACK_MIN:                  Constants for Sysconf.
                                                              (line 209)
* _SC_THREAD_THREADS_MAX:                Constants for Sysconf.
                                                              (line 213)
* _SC_THREADS:                           Constants for Sysconf.
                                                              (line 179)
* _SC_TIMER_MAX:                         Constants for Sysconf.
                                                              (line 134)
* _SC_TIMERS:                            Constants for Sysconf.
                                                              (line  55)
* _SC_TTY_NAME_MAX:                      Constants for Sysconf.
                                                              (line 198)
* _SC_TZNAME_MAX:                        Constants for Sysconf.
                                                              (line  22)
* _SC_UCHAR_MAX:                         Constants for Sysconf.
                                                              (line 411)
* _SC_UINT_MAX:                          Constants for Sysconf.
                                                              (line 415)
* _SC_UIO_MAXIOV:                        Constants for Sysconf.
                                                              (line 155)
* _SC_ULONG_MAX:                         Constants for Sysconf.
                                                              (line 419)
* _SC_USHRT_MAX:                         Constants for Sysconf.
                                                              (line 423)
* _SC_VERSION:                           Constants for Sysconf.
                                                              (line 292)
* _SC_WORD_BIT:                          Constants for Sysconf.
                                                              (line 380)
* _SC_XOPEN_CRYPT:                       Constants for Sysconf.
                                                              (line 340)
* _SC_XOPEN_ENH_I18N:                    Constants for Sysconf.
                                                              (line 343)
* _SC_XOPEN_LEGACY:                      Constants for Sysconf.
                                                              (line 337)
* _SC_XOPEN_REALTIME:                    Constants for Sysconf.
                                                              (line 330)
* _SC_XOPEN_REALTIME_THREADS:            Constants for Sysconf.
                                                              (line 333)
* _SC_XOPEN_SHM:                         Constants for Sysconf.
                                                              (line 346)
* _SC_XOPEN_UNIX:                        Constants for Sysconf.
                                                              (line 327)
* _SC_XOPEN_VERSION:                     Constants for Sysconf.
                                                              (line 321)
* _SC_XOPEN_XCU_VERSION:                 Constants for Sysconf.
                                                              (line 324)
* _SC_XOPEN_XPG2:                        Constants for Sysconf.
                                                              (line 349)
* _SC_XOPEN_XPG3:                        Constants for Sysconf.
                                                              (line 352)
* _SC_XOPEN_XPG4:                        Constants for Sysconf.
                                                              (line 355)
* _SVID_SOURCE:                          Feature Test Macros. (line  91)
* _THREAD_SAFE:                          Feature Test Macros. (line 194)
* _XOPEN_SOURCE:                         Feature Test Macros. (line  96)
* _XOPEN_SOURCE_EXTENDED:                Feature Test Macros. (line  97)
* ABDAY_1:                               The Elegant and Fast Way.
                                                              (line  31)
* ABDAY_2:                               The Elegant and Fast Way.
                                                              (line  32)
* ABDAY_3:                               The Elegant and Fast Way.
                                                              (line  33)
* ABDAY_4:                               The Elegant and Fast Way.
                                                              (line  34)
* ABDAY_5:                               The Elegant and Fast Way.
                                                              (line  35)
* ABDAY_6:                               The Elegant and Fast Way.
                                                              (line  36)
* ABDAY_7:                               The Elegant and Fast Way.
                                                              (line  37)
* ABMON_1:                               The Elegant and Fast Way.
                                                              (line  51)
* ABMON_10:                              The Elegant and Fast Way.
                                                              (line  60)
* ABMON_11:                              The Elegant and Fast Way.
                                                              (line  61)
* ABMON_12:                              The Elegant and Fast Way.
                                                              (line  62)
* ABMON_2:                               The Elegant and Fast Way.
                                                              (line  52)
* ABMON_3:                               The Elegant and Fast Way.
                                                              (line  53)
* ABMON_4:                               The Elegant and Fast Way.
                                                              (line  54)
* ABMON_5:                               The Elegant and Fast Way.
                                                              (line  55)
* ABMON_6:                               The Elegant and Fast Way.
                                                              (line  56)
* ABMON_7:                               The Elegant and Fast Way.
                                                              (line  57)
* ABMON_8:                               The Elegant and Fast Way.
                                                              (line  58)
* ABMON_9:                               The Elegant and Fast Way.
                                                              (line  59)
* ACCOUNTING:                            Manipulating the Database.
                                                              (line 102)
* AF_FILE:                               Address Formats.     (line  54)
* AF_INET:                               Address Formats.     (line  58)
* AF_LOCAL:                              Address Formats.     (line  41)
* AF_UNIX:                               Address Formats.     (line  47)
* AF_UNSPEC:                             Address Formats.     (line  67)
* aliases:                               NSS Basics.          (line  26)
* ALT_DIGITS:                            The Elegant and Fast Way.
                                                              (line 149)
* ALTWERASE:                             Local Modes.         (line 119)
* AM_STR:                                The Elegant and Fast Way.
                                                              (line  82)
* ARG_MAX:                               General Limits.      (line  25)
* argp_err_exit_status:                  Argp Global Variables.
                                                              (line  42)
* ARGP_ERR_UNKNOWN:                      Argp Parser Functions.
                                                              (line  46)
* ARGP_HELP_BUG_ADDR:                    Argp Help Flags.     (line  38)
* ARGP_HELP_DOC:                         Argp Help Flags.     (line  35)
* ARGP_HELP_EXIT_ERR:                    Argp Help Flags.     (line  49)
* ARGP_HELP_EXIT_OK:                     Argp Help Flags.     (line  52)
* ARGP_HELP_LONG:                        Argp Help Flags.     (line  23)
* ARGP_HELP_LONG_ONLY:                   Argp Help Flags.     (line  42)
* ARGP_HELP_POST_DOC:                    Argp Help Flags.     (line  31)
* ARGP_HELP_PRE_DOC:                     Argp Help Flags.     (line  27)
* ARGP_HELP_SEE:                         Argp Help Flags.     (line  19)
* ARGP_HELP_SHORT_USAGE:                 Argp Help Flags.     (line  14)
* ARGP_HELP_STD_ERR:                     Argp Help Flags.     (line  58)
* ARGP_HELP_STD_HELP:                    Argp Help Flags.     (line  68)
* ARGP_HELP_STD_USAGE:                   Argp Help Flags.     (line  63)
* ARGP_HELP_USAGE:                       Argp Help Flags.     (line  11)
* ARGP_IN_ORDER:                         Argp Flags.          (line  31)
* ARGP_KEY_ARG:                          Argp Special Keys.   (line  11)
* ARGP_KEY_ARGS:                         Argp Special Keys.   (line  30)
* ARGP_KEY_END:                          Argp Special Keys.   (line  56)
* ARGP_KEY_ERROR:                        Argp Special Keys.   (line  78)
* ARGP_KEY_FINI:                         Argp Special Keys.   (line  82)
* ARGP_KEY_HELP_ARGS_DOC:                Argp Help Filter Keys.
                                                              (line  27)
* ARGP_KEY_HELP_DUP_ARGS_NOTE:           Argp Help Filter Keys.
                                                              (line  23)
* ARGP_KEY_HELP_EXTRA:                   Argp Help Filter Keys.
                                                              (line  19)
* ARGP_KEY_HELP_HEADER:                  Argp Help Filter Keys.
                                                              (line  16)
* ARGP_KEY_HELP_POST_DOC:                Argp Help Filter Keys.
                                                              (line  13)
* ARGP_KEY_HELP_PRE_DOC:                 Argp Help Filter Keys.
                                                              (line  10)
* ARGP_KEY_INIT:                         Argp Special Keys.   (line  68)
* ARGP_KEY_NO_ARGS:                      Argp Special Keys.   (line  61)
* ARGP_KEY_SUCCESS:                      Argp Special Keys.   (line  74)
* ARGP_LONG_ONLY:                        Argp Flags.          (line  45)
* ARGP_NO_ARGS:                          Argp Flags.          (line  24)
* ARGP_NO_ERRS:                          Argp Flags.          (line  17)
* ARGP_NO_EXIT:                          Argp Flags.          (line  41)
* ARGP_NO_HELP:                          Argp Flags.          (line  36)
* ARGP_PARSE_ARGV0:                      Argp Flags.          (line  11)
* argp_program_bug_address:              Argp Global Variables.
                                                              (line  17)
* argp_program_version:                  Argp Global Variables.
                                                              (line  11)
* argp_program_version_hook:             Argp Global Variables.
                                                              (line  23)
* ARGP_SILENT:                           Argp Flags.          (line  52)
* B0:                                    Line Speed.          (line  79)
* B110:                                  Line Speed.          (line  79)
* B115200:                               Line Speed.          (line  79)
* B1200:                                 Line Speed.          (line  79)
* B134:                                  Line Speed.          (line  79)
* B150:                                  Line Speed.          (line  79)
* B1800:                                 Line Speed.          (line  79)
* B19200:                                Line Speed.          (line  79)
* B200:                                  Line Speed.          (line  79)
* B230400:                               Line Speed.          (line  79)
* B2400:                                 Line Speed.          (line  79)
* B300:                                  Line Speed.          (line  79)
* B38400:                                Line Speed.          (line  79)
* B460800:                               Line Speed.          (line  79)
* B4800:                                 Line Speed.          (line  79)
* B50:                                   Line Speed.          (line  79)
* B57600:                                Line Speed.          (line  79)
* B600:                                  Line Speed.          (line  79)
* B75:                                   Line Speed.          (line  79)
* B9600:                                 Line Speed.          (line  79)
* BC_BASE_MAX:                           Utility Limits.      (line  16)
* BC_DIM_MAX:                            Utility Limits.      (line  20)
* BC_SCALE_MAX:                          Utility Limits.      (line  24)
* BC_STRING_MAX:                         Utility Limits.      (line  28)
* BOOT_TIME <1>:                         XPG Functions.       (line  48)
* BOOT_TIME:                             Manipulating the Database.
                                                              (line  78)
* BRKINT:                                Input Modes.         (line  63)
* BUFSIZ:                                Controlling Buffering.
                                                              (line  57)
* CCTS_OFLOW:                            Control Modes.       (line  84)
* CHAR_MAX:                              Range of Type.       (line  36)
* CHAR_MIN:                              Range of Type.       (line  32)
* CHILD_MAX:                             General Limits.      (line  29)
* CIGNORE:                               Control Modes.       (line  95)
* CLK_TCK:                               CPU Time.            (line  39)
* CLOCAL:                                Control Modes.       (line  19)
* CLOCKS_PER_SEC:                        CPU Time.            (line  34)
* CODESET:                               The Elegant and Fast Way.
                                                              (line  27)
* COLL_WEIGHTS_MAX:                      Utility Limits.      (line  32)
* COREFILE:                              Program Error Signals.
                                                              (line  32)
* CPU_SETSIZE:                           CPU Affinity.        (line  58)
* CREAD:                                 Control Modes.       (line  41)
* CRNCYSTR:                              The Elegant and Fast Way.
                                                              (line 163)
* CRTS_IFLOW:                            Control Modes.       (line  88)
* CS5:                                   Control Modes.       (line  69)
* CS6:                                   Control Modes.       (line  72)
* CS7:                                   Control Modes.       (line  75)
* CS8:                                   Control Modes.       (line  78)
* CSIZE:                                 Control Modes.       (line  66)
* CSTOPB:                                Control Modes.       (line  45)
* CURRENCY_SYMBOL:                       The Elegant and Fast Way.
                                                              (line 162)
* D_FMT:                                 The Elegant and Fast Way.
                                                              (line  97)
* D_T_FMT:                               The Elegant and Fast Way.
                                                              (line  92)
* DAY_1:                                 The Elegant and Fast Way.
                                                              (line  41)
* DAY_2:                                 The Elegant and Fast Way.
                                                              (line  42)
* DAY_3:                                 The Elegant and Fast Way.
                                                              (line  43)
* DAY_4:                                 The Elegant and Fast Way.
                                                              (line  44)
* DAY_5:                                 The Elegant and Fast Way.
                                                              (line  45)
* DAY_6:                                 The Elegant and Fast Way.
                                                              (line  46)
* DAY_7:                                 The Elegant and Fast Way.
                                                              (line  47)
* daylight:                              Time Zone Functions. (line  53)
* DBL_DIG:                               Floating Point Parameters.
                                                              (line  99)
* DBL_EPSILON:                           Floating Point Parameters.
                                                              (line 176)
* DBL_MANT_DIG:                          Floating Point Parameters.
                                                              (line  81)
* DBL_MAX:                               Floating Point Parameters.
                                                              (line 154)
* DBL_MAX_10_EXP:                        Floating Point Parameters.
                                                              (line 142)
* DBL_MAX_EXP:                           Floating Point Parameters.
                                                              (line 132)
* DBL_MIN:                               Floating Point Parameters.
                                                              (line 165)
* DBL_MIN_10_EXP:                        Floating Point Parameters.
                                                              (line 121)
* DBL_MIN_EXP:                           Floating Point Parameters.
                                                              (line 111)
* DEAD_PROCESS <1>:                      Manipulating the Database.
                                                              (line  99)
* DEAD_PROCESS:                          XPG Functions.       (line  69)
* DECIMAL_POINT:                         The Elegant and Fast Way.
                                                              (line 245)
* DES_DECRYPT:                           DES Encryption.      (line  81)
* DES_ENCRYPT:                           DES Encryption.      (line  77)
* DES_HW:                                DES Encryption.      (line  85)
* DES_SW:                                DES Encryption.      (line  90)
* DESERR_BADPARAM:                       DES Encryption.      (line 106)
* DESERR_HWERROR:                        DES Encryption.      (line 103)
* DESERR_NOHWDEVICE:                     DES Encryption.      (line  99)
* DESERR_NONE:                           DES Encryption.      (line  96)
* DT_BLK:                                Directory Entries.   (line  53)
* DT_CHR:                                Directory Entries.   (line  50)
* DT_DIR:                                Directory Entries.   (line  41)
* DT_FIFO:                               Directory Entries.   (line  44)
* DT_REG:                                Directory Entries.   (line  38)
* DT_SOCK:                               Directory Entries.   (line  47)
* DT_UNKNOWN:                            Directory Entries.   (line  34)
* E2BIG:                                 Error Codes.         (line  44)
* EACCES:                                Error Codes.         (line  75)
* EADDRINUSE:                            Error Codes.         (line 272)
* EADDRNOTAVAIL:                         Error Codes.         (line 276)
* EADV:                                  Error Codes.         (line 532)
* EAFNOSUPPORT:                          Error Codes.         (line 267)
* EAGAIN:                                Error Codes.         (line 181)
* EALREADY:                              Error Codes.         (line 227)
* EAUTH:                                 Error Codes.         (line 406)
* EBACKGROUND:                           Error Codes.         (line 438)
* EBADE:                                 Error Codes.         (line 512)
* EBADF <1>:                             Error Codes.         (line  54)
* EBADF:                                 Line Control.        (line 119)
* EBADFD:                                Error Codes.         (line 542)
* EBADMSG:                               Error Codes.         (line 463)
* EBADR:                                 Error Codes.         (line 514)
* EBADRPC:                               Error Codes.         (line 378)
* EBADRQC:                               Error Codes.         (line 520)
* EBADSLT:                               Error Codes.         (line 522)
* EBFONT:                                Error Codes.         (line 526)
* EBUSY:                                 Error Codes.         (line  88)
* ECANCELED:                             Error Codes.         (line 485)
* ECHILD:                                Error Codes.         (line  59)
* ECHO:                                  Local Modes.         (line  23)
* ECHOCTL:                               Local Modes.         (line  73)
* ECHOE:                                 Local Modes.         (line  27)
* ECHOK:                                 Local Modes.         (line  48)
* ECHOKE:                                Local Modes.         (line  62)
* ECHONL:                                Local Modes.         (line  68)
* ECHOPRT:                               Local Modes.         (line  37)
* ECHRNG:                                Error Codes.         (line 496)
* ECOMM:                                 Error Codes.         (line 536)
* ECONNABORTED:                          Error Codes.         (line 291)
* ECONNREFUSED:                          Error Codes.         (line 330)
* ECONNRESET:                            Error Codes.         (line 294)
* ED:                                    Error Codes.         (line 451)
* EDEADLK:                               Error Codes.         (line  64)
* EDEADLOCK:                             Error Codes.         (line 524)
* EDESTADDRREQ:                          Error Codes.         (line 314)
* EDIED:                                 Error Codes.         (line 446)
* EDOM:                                  Error Codes.         (line 172)
* EDOTDOT:                               Error Codes.         (line 538)
* EDQUOT:                                Error Codes.         (line 363)
* EEXIST:                                Error Codes.         (line  93)
* EFAULT:                                Error Codes.         (line  79)
* EFBIG:                                 Error Codes.         (line 146)
* EFTYPE:                                Error Codes.         (line 399)
* EGRATUITOUS:                           Error Codes.         (line 460)
* EGREGIOUS:                             Error Codes.         (line 454)
* EHOSTDOWN:                             Error Codes.         (line 343)
* EHOSTUNREACH:                          Error Codes.         (line 346)
* EIDRM:                                 Error Codes.         (line 465)
* EIEIO:                                 Error Codes.         (line 457)
* EILSEQ:                                Error Codes.         (line 433)
* EINPROGRESS:                           Error Codes.         (line 217)
* EINTR:                                 Error Codes.         (line  25)
* EINVAL <1>:                            Error Codes.         (line 115)
* EINVAL:                                Line Control.        (line 125)
* EIO:                                   Error Codes.         (line  34)
* EISCONN:                               Error Codes.         (line 304)
* EISDIR:                                Error Codes.         (line 111)
* EISNAM:                                Error Codes.         (line 564)
* EKEYEXPIRED:                           Error Codes.         (line 574)
* EKEYREJECTED:                          Error Codes.         (line 578)
* EKEYREVOKED:                           Error Codes.         (line 576)
* EL2HLT:                                Error Codes.         (line 510)
* EL2NSYNC:                              Error Codes.         (line 498)
* EL3HLT:                                Error Codes.         (line 500)
* EL3RST:                                Error Codes.         (line 502)
* ELIBACC:                               Error Codes.         (line 546)
* ELIBBAD:                               Error Codes.         (line 548)
* ELIBEXEC:                              Error Codes.         (line 554)
* ELIBMAX:                               Error Codes.         (line 552)
* ELIBSCN:                               Error Codes.         (line 550)
* ELNRNG:                                Error Codes.         (line 504)
* ELOOP:                                 Error Codes.         (line 334)
* EMEDIUMTYPE:                           Error Codes.         (line 570)
* EMFILE:                                Error Codes.         (line 119)
* EMLINK:                                Error Codes.         (line 160)
* EMPTY <1>:                             Manipulating the Database.
                                                              (line  71)
* EMPTY:                                 XPG Functions.       (line  41)
* EMSGSIZE:                              Error Codes.         (line 234)
* EMULTIHOP:                             Error Codes.         (line 467)
* ENAMETOOLONG:                          Error Codes.         (line 338)
* ENAVAIL:                               Error Codes.         (line 562)
* ENEEDAUTH:                             Error Codes.         (line 409)
* ENETDOWN:                              Error Codes.         (line 281)
* ENETRESET:                             Error Codes.         (line 288)
* ENETUNREACH:                           Error Codes.         (line 284)
* ENFILE:                                Error Codes.         (line 128)
* ENOANO:                                Error Codes.         (line 518)
* ENOBUFS:                               Error Codes.         (line 299)
* ENOCSI:                                Error Codes.         (line 508)
* ENODATA:                               Error Codes.         (line 469)
* ENODEV:                                Error Codes.         (line 103)
* ENOENT:                                Error Codes.         (line  17)
* ENOEXEC:                               Error Codes.         (line  50)
* ENOKEY:                                Error Codes.         (line 572)
* ENOLCK:                                Error Codes.         (line 393)
* ENOLINK:                               Error Codes.         (line 471)
* ENOMEDIUM:                             Error Codes.         (line 568)
* ENOMEM:                                Error Codes.         (line  71)
* ENOMSG:                                Error Codes.         (line 473)
* ENONET:                                Error Codes.         (line 528)
* ENOPKG:                                Error Codes.         (line 530)
* ENOPROTOOPT:                           Error Codes.         (line 242)
* ENOSPC:                                Error Codes.         (line 150)
* ENOSR:                                 Error Codes.         (line 475)
* ENOSTR:                                Error Codes.         (line 477)
* ENOSYS:                                Error Codes.         (line 412)
* ENOTBLK:                               Error Codes.         (line  83)
* ENOTCONN:                              Error Codes.         (line 308)
* ENOTDIR:                               Error Codes.         (line 107)
* ENOTEMPTY:                             Error Codes.         (line 350)
* ENOTNAM:                               Error Codes.         (line 560)
* ENOTRECOVERABLE:                       Error Codes.         (line 582)
* ENOTSOCK:                              Error Codes.         (line 231)
* ENOTSUP:                               Error Codes.         (line 419)
* ENOTTY <1>:                            Error Codes.         (line 134)
* ENOTTY:                                Line Control.        (line 122)
* ENOTUNIQ:                              Error Codes.         (line 540)
* environ:                               Environment Access.  (line  91)
* ENXIO:                                 Error Codes.         (line  37)
* EOF:                                   EOF and Errors.      (line  16)
* EOPNOTSUPP:                            Error Codes.         (line 255)
* EOVERFLOW:                             Error Codes.         (line 479)
* EOWNERDEAD:                            Error Codes.         (line 580)
* EPERM:                                 Error Codes.         (line  12)
* EPFNOSUPPORT:                          Error Codes.         (line 263)
* EPIPE:                                 Error Codes.         (line 165)
* EPROCLIM:                              Error Codes.         (line 355)
* EPROCUNAVAIL:                          Error Codes.         (line 390)
* EPROGMISMATCH:                         Error Codes.         (line 387)
* EPROGUNAVAIL:                          Error Codes.         (line 384)
* EPROTO:                                Error Codes.         (line 481)
* EPROTONOSUPPORT:                       Error Codes.         (line 247)
* EPROTOTYPE:                            Error Codes.         (line 238)
* EQUIV_CLASS_MAX:                       Utility Limits.      (line  47)
* ERA:                                   The Elegant and Fast Way.
                                                              (line 113)
* ERA_D_FMT:                             The Elegant and Fast Way.
                                                              (line 139)
* ERA_D_T_FMT:                           The Elegant and Fast Way.
                                                              (line 134)
* ERA_T_FMT:                             The Elegant and Fast Way.
                                                              (line 144)
* ERA_YEAR:                              The Elegant and Fast Way.
                                                              (line 129)
* ERANGE:                                Error Codes.         (line 177)
* EREMCHG:                               Error Codes.         (line 544)
* EREMOTE:                               Error Codes.         (line 372)
* EREMOTEIO:                             Error Codes.         (line 566)
* ERESTART:                              Error Codes.         (line 494)
* ERFKILL:                               Error Codes.         (line 584)
* EROFS:                                 Error Codes.         (line 157)
* ERPCMISMATCH:                          Error Codes.         (line 381)
* errno:                                 Checking for Errors. (line  15)
* error_message_count:                   Error Messages.      (line 218)
* error_one_per_line:                    Error Messages.      (line 223)
* ESHUTDOWN:                             Error Codes.         (line 320)
* ESOCKTNOSUPPORT:                       Error Codes.         (line 252)
* ESPIPE:                                Error Codes.         (line 154)
* ESRCH:                                 Error Codes.         (line  22)
* ESRMNT:                                Error Codes.         (line 534)
* ESTALE:                                Error Codes.         (line 366)
* ESTRPIPE:                              Error Codes.         (line 556)
* ethers:                                NSS Basics.          (line  29)
* ETIME:                                 Error Codes.         (line 483)
* ETIMEDOUT:                             Error Codes.         (line 326)
* ETOOMANYREFS:                          Error Codes.         (line 323)
* ETXTBSY:                               Error Codes.         (line 138)
* EUCLEAN:                               Error Codes.         (line 558)
* EUNATCH:                               Error Codes.         (line 506)
* EUSERS:                                Error Codes.         (line 360)
* EWOULDBLOCK:                           Error Codes.         (line 210)
* EXDEV:                                 Error Codes.         (line  97)
* EXFULL:                                Error Codes.         (line 516)
* EXIT_FAILURE:                          Exit Status.         (line  54)
* EXIT_SUCCESS:                          Exit Status.         (line  46)
* EXPR_NEST_MAX:                         Utility Limits.      (line  36)
* EXTA:                                  Line Speed.          (line  84)
* EXTB:                                  Line Speed.          (line  84)
* F_DUPFD:                               Duplicating Descriptors.
                                                              (line  46)
* F_GETFD:                               Descriptor Flags.    (line  19)
* F_GETFL:                               Getting File Status Flags.
                                                              (line   9)
* F_GETLK:                               File Locks.          (line  66)
* F_GETOWN:                              Interrupt Input.     (line  23)
* F_OK:                                  Testing File Access. (line  85)
* F_RDLCK:                               File Locks.          (line 179)
* F_SETFD:                               Descriptor Flags.    (line  35)
* F_SETFL:                               Getting File Status Flags.
                                                              (line  25)
* F_SETLK:                               File Locks.          (line 104)
* F_SETLKW:                              File Locks.          (line 153)
* F_SETOWN:                              Interrupt Input.     (line  38)
* F_UNLCK:                               File Locks.          (line 185)
* F_WRLCK:                               File Locks.          (line 182)
* FD_CLOEXEC:                            Descriptor Flags.    (line  52)
* FD_SETSIZE:                            Waiting for I/O.     (line  39)
* FE_DFL_ENV:                            Control Functions.   (line  49)
* FE_DIVBYZERO:                          Status bit operations.
                                                              (line  20)
* FE_DOWNWARD:                           Rounding.            (line  45)
* FE_INEXACT:                            Status bit operations.
                                                              (line  17)
* FE_INVALID:                            Status bit operations.
                                                              (line  29)
* FE_NOMASK_ENV:                         Control Functions.   (line  55)
* FE_OVERFLOW:                           Status bit operations.
                                                              (line  26)
* FE_TONEAREST:                          Rounding.            (line  39)
* FE_TOWARDZERO:                         Rounding.            (line  48)
* FE_UNDERFLOW:                          Status bit operations.
                                                              (line  23)
* FE_UPWARD:                             Rounding.            (line  42)
* FILENAME_MAX:                          Limits for Files.    (line  57)
* FLT_DIG:                               Floating Point Parameters.
                                                              (line  87)
* FLT_EPSILON:                           Floating Point Parameters.
                                                              (line 171)
* FLT_MANT_DIG:                          Floating Point Parameters.
                                                              (line  69)
* FLT_MAX:                               Floating Point Parameters.
                                                              (line 147)
* FLT_MAX_10_EXP:                        Floating Point Parameters.
                                                              (line 137)
* FLT_MAX_EXP:                           Floating Point Parameters.
                                                              (line 126)
* FLT_MIN:                               Floating Point Parameters.
                                                              (line 160)
* FLT_MIN_10_EXP:                        Floating Point Parameters.
                                                              (line 116)
* FLT_MIN_EXP:                           Floating Point Parameters.
                                                              (line 105)
* FLT_RADIX:                             Floating Point Parameters.
                                                              (line  63)
* FLT_ROUNDS:                            Floating Point Parameters.
                                                              (line  28)
* FLUSHO:                                Local Modes.         (line 133)
* FOPEN_MAX:                             Opening Streams.     (line 122)
* FP_FAST_FMA:                           Misc FP Arithmetic.  (line  54)
* FP_ILOGB0:                             Exponents and Logarithms.
                                                              (line  79)
* FP_ILOGBNAN:                           Exponents and Logarithms.
                                                              (line  85)
* FP_INFINITE:                           Floating Point Classes.
                                                              (line  17)
* FP_NAN:                                Floating Point Classes.
                                                              (line  13)
* FP_NORMAL:                             Floating Point Classes.
                                                              (line  34)
* FP_SUBNORMAL:                          Floating Point Classes.
                                                              (line  26)
* FP_ZERO:                               Floating Point Classes.
                                                              (line  21)
* FPE_DECOVF_TRAP:                       Program Error Signals.
                                                              (line  89)
* FPE_FLTDIV_TRAP:                       Program Error Signals.
                                                              (line  82)
* FPE_FLTOVF_TRAP:                       Program Error Signals.
                                                              (line  79)
* FPE_FLTUND_TRAP:                       Program Error Signals.
                                                              (line  85)
* FPE_INTDIV_TRAP:                       Program Error Signals.
                                                              (line  73)
* FPE_INTOVF_TRAP:                       Program Error Signals.
                                                              (line  69)
* FPE_SUBRNG_TRAP:                       Program Error Signals.
                                                              (line  76)
* FRAC_DIGITS:                           The Elegant and Fast Way.
                                                              (line 193)
* FSETLOCKING_BYCALLER:                  Streams and Threads. (line 172)
* FSETLOCKING_INTERNAL:                  Streams and Threads. (line 167)
* FSETLOCKING_QUERY:                     Streams and Threads. (line 178)
* FSTAB:                                 Mount Information.   (line  29)
* FSTAB_RO:                              fstab.               (line  58)
* FSTAB_RQ:                              fstab.               (line  54)
* FSTAB_RW:                              fstab.               (line  51)
* FSTAB_SW:                              fstab.               (line  61)
* FSTAB_XX:                              fstab.               (line  64)
* FTW_ACTIONRETVAL:                      Working with Directory Trees.
                                                              (line 224)
* FTW_CHDIR:                             Working with Directory Trees.
                                                              (line 211)
* FTW_D:                                 Working with Directory Trees.
                                                              (line  36)
* FTW_DEPTH:                             Working with Directory Trees.
                                                              (line 217)
* FTW_DNR:                               Working with Directory Trees.
                                                              (line  43)
* FTW_DP:                                Working with Directory Trees.
                                                              (line  75)
* FTW_F:                                 Working with Directory Trees.
                                                              (line  31)
* FTW_MOUNT:                             Working with Directory Trees.
                                                              (line 206)
* FTW_NS:                                Working with Directory Trees.
                                                              (line  39)
* FTW_PHYS:                              Working with Directory Trees.
                                                              (line 199)
* FTW_SL:                                Working with Directory Trees.
                                                              (line  46)
* FTW_SLN:                               Working with Directory Trees.
                                                              (line  75)
* getdate_err:                           General Time String Parsing.
                                                              (line  14)
* GLOB_ABORTED:                          Calling Glob.        (line 188)
* GLOB_ALTDIRFUNC:                       More Flags for Globbing.
                                                              (line  21)
* GLOB_APPEND:                           Flags for Globbing.  (line  10)
* GLOB_BRACE:                            More Flags for Globbing.
                                                              (line  29)
* GLOB_DOOFFS:                           Flags for Globbing.  (line  27)
* GLOB_ERR:                              Flags for Globbing.  (line  32)
* GLOB_MAGCHAR:                          More Flags for Globbing.
                                                              (line  15)
* GLOB_MARK:                             Flags for Globbing.  (line  55)
* GLOB_NOCHECK:                          Flags for Globbing.  (line  59)
* GLOB_NOESCAPE:                         Flags for Globbing.  (line  70)
* GLOB_NOMAGIC:                          More Flags for Globbing.
                                                              (line  58)
* GLOB_NOMATCH:                          Calling Glob.        (line 194)
* GLOB_NOSORT:                           Flags for Globbing.  (line  65)
* GLOB_NOSPACE:                          Calling Glob.        (line 200)
* GLOB_ONLYDIR:                          More Flags for Globbing.
                                                              (line 104)
* GLOB_PERIOD:                           More Flags for Globbing.
                                                              (line  11)
* GLOB_TILDE:                            More Flags for Globbing.
                                                              (line  63)
* GLOB_TILDE_CHECK:                      More Flags for Globbing.
                                                              (line  94)
* group:                                 NSS Basics.          (line  32)
* GROUPING:                              The Elegant and Fast Way.
                                                              (line 260)
* h_errno:                               Host Names.          (line  87)
* HOST_NOT_FOUND:                        Host Names.          (line  95)
* hosts:                                 NSS Basics.          (line  35)
* HUGE_VAL:                              Math Error Reporting.
                                                              (line  36)
* HUGE_VALF:                             Math Error Reporting.
                                                              (line  37)
* HUGE_VALL:                             Math Error Reporting.
                                                              (line  38)
* HUPCL:                                 Control Modes.       (line  36)
* I:                                     Complex Numbers.     (line  32)
* ICANON:                                Local Modes.         (line  18)
* ICRNL:                                 Input Modes.         (line  80)
* IEXTEN:                                Local Modes.         (line  99)
* IFNAMSIZ:                              Interface Naming.    (line  21)
* IGNBRK:                                Input Modes.         (line  56)
* IGNCR:                                 Input Modes.         (line  74)
* IGNPAR:                                Input Modes.         (line  34)
* IMAXBEL:                               Input Modes.         (line 115)
* in6addr_any:                           Host Address Data Type.
                                                              (line  63)
* in6addr_loopback:                      Host Address Data Type.
                                                              (line  57)
* INADDR_ANY:                            Host Address Data Type.
                                                              (line  40)
* INADDR_BROADCAST:                      Host Address Data Type.
                                                              (line  46)
* INADDR_LOOPBACK:                       Host Address Data Type.
                                                              (line  31)
* INADDR_NONE:                           Host Address Data Type.
                                                              (line  49)
* INFINITY:                              Infinity and NaN.    (line  40)
* INIT_PROCESS <1>:                      XPG Functions.       (line  58)
* INIT_PROCESS:                          Manipulating the Database.
                                                              (line  88)
* INLCR:                                 Input Modes.         (line  85)
* INPCK:                                 Input Modes.         (line  17)
* INT_CURR_SYMBOL:                       The Elegant and Fast Way.
                                                              (line 158)
* INT_FRAC_DIGITS:                       The Elegant and Fast Way.
                                                              (line 189)
* INT_MAX:                               Range of Type.       (line  56)
* INT_MIN:                               Range of Type.       (line  51)
* INT_N_CS_PRECEDES:                     The Elegant and Fast Way.
                                                              (line 229)
* INT_N_SEP_BY_SPACE:                    The Elegant and Fast Way.
                                                              (line 233)
* INT_N_SIGN_POSN:                       The Elegant and Fast Way.
                                                              (line 241)
* INT_P_CS_PRECEDES:                     The Elegant and Fast Way.
                                                              (line 221)
* INT_P_SEP_BY_SPACE:                    The Elegant and Fast Way.
                                                              (line 225)
* INT_P_SIGN_POSN:                       The Elegant and Fast Way.
                                                              (line 237)
* IPPORT_RESERVED:                       Ports.               (line  38)
* IPPORT_USERRESERVED:                   Ports.               (line  42)
* ISIG:                                  Local Modes.         (line  83)
* ISTRIP:                                Input Modes.         (line  52)
* ITIMER_PROF:                           Setting an Alarm.    (line  98)
* ITIMER_REAL:                           Setting an Alarm.    (line  90)
* ITIMER_VIRTUAL:                        Setting an Alarm.    (line  94)
* IXANY:                                 Input Modes.         (line 107)
* IXOFF:                                 Input Modes.         (line  90)
* IXON:                                  Input Modes.         (line  99)
* L_ctermid:                             Identifying the Terminal.
                                                              (line  28)
* L_cuserid:                             Who Logged In.       (line  37)
* L_INCR:                                File Positioning.    (line 148)
* L_SET:                                 File Positioning.    (line 145)
* L_tmpnam:                              Temporary Files.     (line  77)
* L_XTND:                                File Positioning.    (line 151)
* LANG:                                  Locale Categories.   (line  45)
* LANGUAGE:                              Locale Categories.   (line  50)
* LC_ALL:                                Locale Categories.   (line  39)
* LC_COLLATE:                            Locale Categories.   (line  12)
* LC_CTYPE:                              Locale Categories.   (line  16)
* LC_MESSAGES:                           Locale Categories.   (line  33)
* LC_MONETARY:                           Locale Categories.   (line  21)
* LC_NUMERIC:                            Locale Categories.   (line  25)
* LC_TIME:                               Locale Categories.   (line  29)
* LDBL_DIG:                              Floating Point Parameters.
                                                              (line 100)
* LDBL_EPSILON:                          Floating Point Parameters.
                                                              (line 177)
* LDBL_MANT_DIG:                         Floating Point Parameters.
                                                              (line  82)
* LDBL_MAX:                              Floating Point Parameters.
                                                              (line 155)
* LDBL_MAX_10_EXP:                       Floating Point Parameters.
                                                              (line 143)
* LDBL_MAX_EXP:                          Floating Point Parameters.
                                                              (line 133)
* LDBL_MIN:                              Floating Point Parameters.
                                                              (line 166)
* LDBL_MIN_10_EXP:                       Floating Point Parameters.
                                                              (line 122)
* LDBL_MIN_EXP:                          Floating Point Parameters.
                                                              (line 112)
* LINE_MAX:                              Utility Limits.      (line  40)
* LINK_MAX:                              Limits for Files.    (line  25)
* LIO_NOP:                               Asynchronous I/O.    (line  94)
* LIO_READ:                              Asynchronous I/O.    (line  84)
* LIO_WRITE:                             Asynchronous I/O.    (line  89)
* LOG_ALERT:                             syslog; vsyslog.     (line  96)
* LOG_AUTH:                              syslog; vsyslog.     (line  31)
* LOG_AUTHPRIV:                          syslog; vsyslog.     (line  49)
* LOG_CRIT:                              syslog; vsyslog.     (line  99)
* LOG_CRON:                              syslog; vsyslog.     (line  46)
* LOG_DAEMON:                            syslog; vsyslog.     (line  28)
* LOG_DEBUG:                             syslog; vsyslog.     (line 114)
* LOG_EMERG:                             syslog; vsyslog.     (line  93)
* LOG_ERR:                               syslog; vsyslog.     (line 102)
* LOG_FTP:                               syslog; vsyslog.     (line  52)
* LOG_INFO:                              syslog; vsyslog.     (line 111)
* LOG_LOCAL0:                            syslog; vsyslog.     (line  55)
* LOG_LOCAL1:                            syslog; vsyslog.     (line  58)
* LOG_LOCAL2:                            syslog; vsyslog.     (line  61)
* LOG_LOCAL3:                            syslog; vsyslog.     (line  64)
* LOG_LOCAL4:                            syslog; vsyslog.     (line  67)
* LOG_LOCAL5:                            syslog; vsyslog.     (line  70)
* LOG_LOCAL6:                            syslog; vsyslog.     (line  73)
* LOG_LOCAL7:                            syslog; vsyslog.     (line  76)
* LOG_LPR:                               syslog; vsyslog.     (line  37)
* LOG_MAIL:                              syslog; vsyslog.     (line  25)
* LOG_NEWS:                              syslog; vsyslog.     (line  40)
* LOG_NOTICE:                            syslog; vsyslog.     (line 108)
* LOG_SYSLOG:                            syslog; vsyslog.     (line  34)
* LOG_USER:                              syslog; vsyslog.     (line  22)
* LOG_UUCP:                              syslog; vsyslog.     (line  43)
* LOG_WARNING:                           syslog; vsyslog.     (line 105)
* LOGIN_PROCESS <1>:                     XPG Functions.       (line  62)
* LOGIN_PROCESS:                         Manipulating the Database.
                                                              (line  92)
* LONG_LONG_MAX:                         Range of Type.       (line  76)
* LONG_LONG_MIN:                         Range of Type.       (line  71)
* LONG_MAX:                              Range of Type.       (line  66)
* LONG_MIN:                              Range of Type.       (line  61)
* M_1_PI:                                Mathematical Constants.
                                                              (line  34)
* M_2_PI:                                Mathematical Constants.
                                                              (line  37)
* M_2_SQRTPI:                            Mathematical Constants.
                                                              (line  40)
* M_E:                                   Mathematical Constants.
                                                              (line  10)
* M_LN10:                                Mathematical Constants.
                                                              (line  22)
* M_LN2:                                 Mathematical Constants.
                                                              (line  19)
* M_LOG10E:                              Mathematical Constants.
                                                              (line  16)
* M_LOG2E:                               Mathematical Constants.
                                                              (line  13)
* M_PI:                                  Mathematical Constants.
                                                              (line  25)
* M_PI_2:                                Mathematical Constants.
                                                              (line  28)
* M_PI_4:                                Mathematical Constants.
                                                              (line  31)
* M_SQRT1_2:                             Mathematical Constants.
                                                              (line  46)
* M_SQRT2:                               Mathematical Constants.
                                                              (line  43)
* MAP_ANON:                              Memory-mapped I/O.   (line  88)
* MAP_ANONYMOUS:                         Memory-mapped I/O.   (line  87)
* MAP_FIXED:                             Memory-mapped I/O.   (line  83)
* MAP_PRIVATE:                           Memory-mapped I/O.   (line  62)
* MAP_SHARED:                            Memory-mapped I/O.   (line  73)
* MAX_CANON:                             Limits for Files.    (line  29)
* MAX_INPUT:                             Limits for Files.    (line  33)
* MAXNAMLEN:                             Limits for Files.    (line  54)
* MAXSYMLINKS:                           Symbolic Links.      (line  35)
* MB_CUR_MAX:                            Selecting the Conversion.
                                                              (line  25)
* MB_LEN_MAX:                            Selecting the Conversion.
                                                              (line  20)
* MDMBUF:                                Control Modes.       (line  92)
* MINSIGSTKSZ:                           Signal Stack.        (line  45)
* MM_APPL:                               Printing Formatted Messages.
                                                              (line  34)
* MM_CONSOLE:                            Printing Formatted Messages.
                                                              (line  14)
* MM_ERROR:                              Printing Formatted Messages.
                                                              (line 101)
* MM_FIRM:                               Printing Formatted Messages.
                                                              (line  27)
* MM_HALT:                               Printing Formatted Messages.
                                                              (line  98)
* MM_HARD:                               Printing Formatted Messages.
                                                              (line  21)
* MM_INFO:                               Printing Formatted Messages.
                                                              (line 107)
* MM_NOSEV:                              Printing Formatted Messages.
                                                              (line  95)
* MM_NRECOV:                             Printing Formatted Messages.
                                                              (line  49)
* MM_NULLACT:                            Printing Formatted Messages.
                                                              (line  82)
* MM_NULLLBL:                            Printing Formatted Messages.
                                                              (line  69)
* MM_NULLMC:                             Printing Formatted Messages.
                                                              (line  75)
* MM_NULLSEV:                            Printing Formatted Messages.
                                                              (line  72)
* MM_NULLTAG:                            Printing Formatted Messages.
                                                              (line  85)
* MM_NULLTXT:                            Printing Formatted Messages.
                                                              (line  79)
* MM_OPSYS:                              Printing Formatted Messages.
                                                              (line  40)
* MM_PRINT:                              Printing Formatted Messages.
                                                              (line  11)
* MM_RECOVER:                            Printing Formatted Messages.
                                                              (line  46)
* MM_SOFT:                               Printing Formatted Messages.
                                                              (line  24)
* MM_UTIL:                               Printing Formatted Messages.
                                                              (line  37)
* MM_WARNING:                            Printing Formatted Messages.
                                                              (line 104)
* MNTOPT_DEFAULTS:                       mtab.                (line  62)
* MNTOPT_NOAUTO:                         mtab.                (line  85)
* MNTOPT_NOSUID:                         mtab.                (line  80)
* MNTOPT_RO:                             mtab.                (line  67)
* MNTOPT_RW:                             mtab.                (line  71)
* MNTOPT_SUID:                           mtab.                (line  75)
* MNTTAB:                                Mount Information.   (line  29)
* MNTTYPE_IGNORE:                        mtab.                (line  33)
* MNTTYPE_NFS:                           mtab.                (line  38)
* MNTTYPE_SWAP:                          mtab.                (line  44)
* MON_1:                                 The Elegant and Fast Way.
                                                              (line  66)
* MON_10:                                The Elegant and Fast Way.
                                                              (line  75)
* MON_11:                                The Elegant and Fast Way.
                                                              (line  76)
* MON_12:                                The Elegant and Fast Way.
                                                              (line  77)
* MON_2:                                 The Elegant and Fast Way.
                                                              (line  67)
* MON_3:                                 The Elegant and Fast Way.
                                                              (line  68)
* MON_4:                                 The Elegant and Fast Way.
                                                              (line  69)
* MON_5:                                 The Elegant and Fast Way.
                                                              (line  70)
* MON_6:                                 The Elegant and Fast Way.
                                                              (line  71)
* MON_7:                                 The Elegant and Fast Way.
                                                              (line  72)
* MON_8:                                 The Elegant and Fast Way.
                                                              (line  73)
* MON_9:                                 The Elegant and Fast Way.
                                                              (line  74)
* MON_DECIMAL_POINT:                     The Elegant and Fast Way.
                                                              (line 169)
* MON_GROUPING:                          The Elegant and Fast Way.
                                                              (line 177)
* MON_THOUSANDS_SEP:                     The Elegant and Fast Way.
                                                              (line 173)
* MOUNTED:                               Mount Information.   (line  29)
* MS_ASYNC:                              Memory-mapped I/O.   (line 177)
* MS_SYNC:                               Memory-mapped I/O.   (line 172)
* MSG_DONTROUTE:                         Socket Data Options. (line  20)
* MSG_OOB:                               Socket Data Options. (line  12)
* MSG_PEEK:                              Socket Data Options. (line  15)
* N_CS_PRECEDES:                         The Elegant and Fast Way.
                                                              (line 205)
* N_SEP_BY_SPACE:                        The Elegant and Fast Way.
                                                              (line 209)
* N_SIGN_POSN:                           The Elegant and Fast Way.
                                                              (line 217)
* NAME_MAX:                              Limits for Files.    (line  37)
* NAN:                                   Infinity and NaN.    (line  52)
* NCCS:                                  Mode Data Types.     (line  51)
* NDEBUG:                                Consistency Checking.
                                                              (line  15)
* NEGATIVE_SIGN:                         The Elegant and Fast Way.
                                                              (line 185)
* netgroup:                              NSS Basics.          (line  38)
* networks:                              NSS Basics.          (line  41)
* NEW_TIME <1>:                          Manipulating the Database.
                                                              (line  85)
* NEW_TIME:                              XPG Functions.       (line  55)
* NGROUPS_MAX:                           General Limits.      (line  51)
* NL_ARGMAX:                             Output Conversion Syntax.
                                                              (line  46)
* NO_ADDRESS:                            Host Names.          (line 105)
* NO_RECOVERY:                           Host Names.          (line 102)
* NOEXPR:                                The Elegant and Fast Way.
                                                              (line 270)
* NOFLSH:                                Local Modes.         (line 106)
* NOKERNINFO:                            Local Modes.         (line 138)
* NOSTR:                                 The Elegant and Fast Way.
                                                              (line 286)
* NSIG:                                  Standard Signals.    (line  18)
* NSS_STATUS_NOTFOUND:                   NSS Modules Interface.
                                                              (line  36)
* NSS_STATUS_SUCCESS:                    NSS Modules Interface.
                                                              (line  39)
* NSS_STATUS_TRYAGAIN:                   NSS Modules Interface.
                                                              (line  30)
* NSS_STATUS_UNAVAIL:                    NSS Modules Interface.
                                                              (line  33)
* NULL:                                  Null Pointer Constant.
                                                              (line  11)
* O_ACCMODE:                             Access Modes.        (line  51)
* O_APPEND:                              Operating Modes.     (line  11)
* O_ASYNC:                               Operating Modes.     (line  43)
* O_CREAT:                               Open-time Flags.     (line  22)
* O_EXCL:                                Open-time Flags.     (line  25)
* O_EXEC:                                Access Modes.        (line  41)
* O_EXLOCK:                              Open-time Flags.     (line 104)
* O_FSYNC:                               Operating Modes.     (line  50)
* O_IGNORE_CTTY:                         Open-time Flags.     (line  60)
* O_NDELAY:                              Operating Modes.     (line  35)
* O_NOATIME:                             Operating Modes.     (line  58)
* O_NOCTTY:                              Open-time Flags.     (line  45)
* O_NOLINK:                              Open-time Flags.     (line  66)
* O_NONBLOCK <1>:                        Operating Modes.     (line  23)
* O_NONBLOCK:                            Open-time Flags.     (line  30)
* O_NOTRANS:                             Open-time Flags.     (line  71)
* O_RDONLY:                              Access Modes.        (line  12)
* O_RDWR:                                Access Modes.        (line  18)
* O_READ:                                Access Modes.        (line  33)
* O_SHLOCK:                              Open-time Flags.     (line  96)
* O_SYNC:                                Operating Modes.     (line  55)
* O_TRUNC:                               Open-time Flags.     (line  80)
* O_WRITE:                               Access Modes.        (line  37)
* O_WRONLY:                              Access Modes.        (line  15)
* obstack_alloc_failed_handler:          Preparing for Obstacks.
                                                              (line  56)
* OLD_TIME <1>:                          Manipulating the Database.
                                                              (line  81)
* OLD_TIME:                              XPG Functions.       (line  51)
* ONLCR:                                 Output Modes.        (line  27)
* ONOEOT:                                Output Modes.        (line  36)
* OPEN_MAX:                              General Limits.      (line  35)
* OPOST:                                 Output Modes.        (line  16)
* optarg:                                Using Getopt.        (line  31)
* opterr:                                Using Getopt.        (line  10)
* optind:                                Using Getopt.        (line  24)
* OPTION_ALIAS:                          Argp Option Flags.   (line  16)
* OPTION_ARG_OPTIONAL:                   Argp Option Flags.   (line  10)
* OPTION_DOC:                            Argp Option Flags.   (line  22)
* OPTION_HIDDEN:                         Argp Option Flags.   (line  13)
* OPTION_NO_USAGE:                       Argp Option Flags.   (line  37)
* optopt:                                Using Getopt.        (line  18)
* OXTABS:                                Output Modes.        (line  31)
* P_CS_PRECEDES:                         The Elegant and Fast Way.
                                                              (line 197)
* P_SEP_BY_SPACE:                        The Elegant and Fast Way.
                                                              (line 201)
* P_SIGN_POSN:                           The Elegant and Fast Way.
                                                              (line 213)
* P_tmpdir:                              Temporary Files.     (line 127)
* PA_CHAR:                               Parsing a Template String.
                                                              (line  48)
* PA_DOUBLE:                             Parsing a Template String.
                                                              (line  62)
* PA_FLAG_LONG:                          Parsing a Template String.
                                                              (line  86)
* PA_FLAG_LONG_DOUBLE:                   Parsing a Template String.
                                                              (line  94)
* PA_FLAG_LONG_LONG:                     Parsing a Template String.
                                                              (line  90)
* PA_FLAG_MASK:                          Parsing a Template String.
                                                              (line  37)
* PA_FLAG_PTR:                           Parsing a Template String.
                                                              (line  77)
* PA_FLAG_SHORT:                         Parsing a Template String.
                                                              (line  82)
* PA_FLOAT:                              Parsing a Template String.
                                                              (line  59)
* PA_INT:                                Parsing a Template String.
                                                              (line  45)
* PA_LAST:                               Parsing a Template String.
                                                              (line  65)
* PA_POINTER:                            Parsing a Template String.
                                                              (line  55)
* PA_STRING:                             Parsing a Template String.
                                                              (line  51)
* PARENB:                                Control Modes.       (line  49)
* PARMRK:                                Input Modes.         (line  38)
* PARODD:                                Control Modes.       (line  58)
* passwd:                                NSS Basics.          (line  47)
* PATH_MAX:                              Limits for Files.    (line  41)
* PENDIN:                                Local Modes.         (line 142)
* PF_CCITT:                              Misc Namespaces.     (line   6)
* PF_FILE:                               Local Namespace Details.
                                                              (line  19)
* PF_IMPLINK:                            Misc Namespaces.     (line   6)
* PF_INET:                               Internet Namespace.  (line  21)
* PF_INET6:                              Internet Namespace.  (line  25)
* PF_ISO:                                Misc Namespaces.     (line   6)
* PF_LOCAL:                              Local Namespace Details.
                                                              (line  11)
* PF_NS:                                 Misc Namespaces.     (line   6)
* PF_ROUTE:                              Misc Namespaces.     (line   6)
* PF_UNIX:                               Local Namespace Details.
                                                              (line  16)
* PI:                                    Mathematical Constants.
                                                              (line  62)
* PIPE_BUF:                              Limits for Files.    (line  45)
* PM_STR:                                The Elegant and Fast Way.
                                                              (line  83)
* POSITIVE_SIGN:                         The Elegant and Fast Way.
                                                              (line 181)
* PRIO_MAX:                              Traditional Scheduling Functions.
                                                              (line  21)
* PRIO_MIN:                              Traditional Scheduling Functions.
                                                              (line  18)
* PRIO_PGRP:                             Traditional Scheduling Functions.
                                                              (line  78)
* PRIO_PROCESS:                          Traditional Scheduling Functions.
                                                              (line  75)
* PRIO_USER:                             Traditional Scheduling Functions.
                                                              (line  82)
* program_invocation_name:               Error Messages.      (line  77)
* program_invocation_short_name:         Error Messages.      (line  83)
* PROT_EXEC:                             Memory-mapped I/O.   (line  45)
* PROT_READ:                             Memory-mapped I/O.   (line  45)
* PROT_WRITE:                            Memory-mapped I/O.   (line  45)
* protocols:                             NSS Basics.          (line  44)
* PWD:                                   Working Directory.   (line  87)
* R_OK:                                  Testing File Access. (line  76)
* RADIXCHAR:                             The Elegant and Fast Way.
                                                              (line 246)
* RAND_MAX:                              ISO Random.          (line  13)
* RE_DUP_MAX:                            General Limits.      (line  69)
* RLIM_INFINITY:                         Limits on Resources. (line 169)
* RLIM_NLIMITS:                          Limits on Resources. (line 165)
* RLIMIT_AS:                             Limits on Resources. (line 159)
* RLIMIT_CORE:                           Limits on Resources. (line 131)
* RLIMIT_CPU:                            Limits on Resources. (line 111)
* RLIMIT_DATA:                           Limits on Resources. (line 121)
* RLIMIT_FSIZE:                          Limits on Resources. (line 116)
* RLIMIT_NOFILE:                         Limits on Resources. (line 152)
* RLIMIT_OFILE:                          Limits on Resources. (line 153)
* RLIMIT_RSS:                            Limits on Resources. (line 137)
* RLIMIT_STACK:                          Limits on Resources. (line 126)
* rpc:                                   NSS Basics.          (line  50)
* RUN_LVL <1>:                           XPG Functions.       (line  45)
* RUN_LVL:                               Manipulating the Database.
                                                              (line  75)
* S_IEXEC:                               Permission Bits.     (line  31)
* S_IFBLK:                               Testing File Type.   (line  76)
* S_IFCHR:                               Testing File Type.   (line  73)
* S_IFDIR:                               Testing File Type.   (line  70)
* S_IFIFO:                               Testing File Type.   (line  88)
* S_IFLNK:                               Testing File Type.   (line  82)
* S_IFMT:                                Testing File Type.   (line  64)
* S_IFREG:                               Testing File Type.   (line  79)
* S_IFSOCK:                              Testing File Type.   (line  85)
* S_IREAD:                               Permission Bits.     (line  20)
* S_IRGRP:                               Permission Bits.     (line  39)
* S_IROTH:                               Permission Bits.     (line  52)
* S_IRUSR:                               Permission Bits.     (line  19)
* S_IRWXG:                               Permission Bits.     (line  49)
* S_IRWXO:                               Permission Bits.     (line  61)
* S_IRWXU:                               Permission Bits.     (line  36)
* S_ISGID:                               Permission Bits.     (line  68)
* S_ISUID:                               Permission Bits.     (line  64)
* S_ISVTX:                               Permission Bits.     (line  72)
* S_IWGRP:                               Permission Bits.     (line  42)
* S_IWOTH:                               Permission Bits.     (line  55)
* S_IWRITE:                              Permission Bits.     (line  26)
* S_IWUSR:                               Permission Bits.     (line  25)
* S_IXGRP:                               Permission Bits.     (line  45)
* S_IXOTH:                               Permission Bits.     (line  58)
* S_IXUSR:                               Permission Bits.     (line  30)
* SA_NOCLDSTOP:                          Flags for Sigaction. (line  26)
* SA_ONSTACK:                            Flags for Sigaction. (line  34)
* SA_RESTART:                            Flags for Sigaction. (line  41)
* SC_SSIZE_MAX:                          Constants for Sysconf.
                                                              (line 391)
* SCHAR_MAX:                             Range of Type.       (line  27)
* SCHAR_MIN:                             Range of Type.       (line  23)
* SEEK_CUR:                              File Positioning.    (line 124)
* SEEK_END:                              File Positioning.    (line 129)
* SEEK_SET:                              File Positioning.    (line 119)
* services:                              NSS Basics.          (line  53)
* shadow:                                NSS Basics.          (line  56)
* SHRT_MAX:                              Range of Type.       (line  46)
* SHRT_MIN:                              Range of Type.       (line  41)
* SIG_BLOCK:                             Process Signal Mask. (line  26)
* SIG_DFL:                               Basic Signal Handling.
                                                              (line  35)
* SIG_ERR:                               Basic Signal Handling.
                                                              (line 142)
* SIG_IGN:                               Basic Signal Handling.
                                                              (line  40)
* SIG_SETMASK:                           Process Signal Mask. (line  35)
* SIG_UNBLOCK:                           Process Signal Mask. (line  31)
* SIGABRT:                               Program Error Signals.
                                                              (line 135)
* SIGALRM:                               Alarm Signals.       (line  16)
* SIGBUS:                                Program Error Signals.
                                                              (line 122)
* SIGCHLD:                               Job Control Signals. (line  14)
* SIGCLD:                                Job Control Signals. (line  25)
* SIGCONT:                               Job Control Signals. (line  28)
* SIGEMT:                                Program Error Signals.
                                                              (line 149)
* SIGFPE:                                Program Error Signals.
                                                              (line  42)
* SIGHUP:                                Termination Signals. (line  72)
* SIGILL:                                Program Error Signals.
                                                              (line  93)
* SIGINFO:                               Miscellaneous Signals.
                                                              (line  33)
* SIGINT:                                Termination Signals. (line  30)
* SIGIO:                                 Asynchronous I/O Signals.
                                                              (line  13)
* SIGIOT:                                Program Error Signals.
                                                              (line 139)
* SIGKILL:                               Termination Signals. (line  53)
* SIGLOST:                               Operation Error Signals.
                                                              (line  27)
* signgam:                               Special Functions.   (line  29)
* SIGPIPE:                               Operation Error Signals.
                                                              (line  13)
* SIGPOLL:                               Asynchronous I/O Signals.
                                                              (line  28)
* SIGPROF:                               Alarm Signals.       (line  26)
* SIGQUIT:                               Termination Signals. (line  36)
* SIGSEGV:                               Program Error Signals.
                                                              (line 108)
* SIGSTKSZ:                              Signal Stack.        (line  41)
* SIGSTOP:                               Job Control Signals. (line  42)
* SIGSYS:                                Program Error Signals.
                                                              (line 154)
* SIGTERM:                               Termination Signals. (line  22)
* SIGTRAP:                               Program Error Signals.
                                                              (line 143)
* SIGTSTP:                               Job Control Signals. (line  46)
* SIGTTIN:                               Job Control Signals. (line  59)
* SIGTTOU:                               Job Control Signals. (line  67)
* SIGURG:                                Asynchronous I/O Signals.
                                                              (line  24)
* SIGUSR1:                               Miscellaneous Signals.
                                                              (line  11)
* SIGUSR2:                               Miscellaneous Signals.
                                                              (line  12)
* SIGVTALRM:                             Alarm Signals.       (line  21)
* SIGWINCH:                              Miscellaneous Signals.
                                                              (line  23)
* SIGXCPU:                               Operation Error Signals.
                                                              (line  37)
* SIGXFSZ:                               Operation Error Signals.
                                                              (line  42)
* SOCK_DGRAM:                            Communication Styles.
                                                              (line  19)
* SOCK_RAW:                              Communication Styles.
                                                              (line  42)
* SOCK_STREAM:                           Communication Styles.
                                                              (line  12)
* SOL_SOCKET:                            Socket-Level Options.
                                                              (line   7)
* SS_DISABLE:                            Signal Stack.        (line  60)
* SS_ONSTACK:                            Signal Stack.        (line  64)
* SSIZE_MAX:                             General Limits.      (line  61)
* stderr:                                Standard Streams.    (line  22)
* STDERR_FILENO:                         Descriptors and Streams.
                                                              (line  62)
* stdin:                                 Standard Streams.    (line  14)
* STDIN_FILENO:                          Descriptors and Streams.
                                                              (line  54)
* stdout:                                Standard Streams.    (line  18)
* STDOUT_FILENO:                         Descriptors and Streams.
                                                              (line  58)
* STREAM_MAX:                            General Limits.      (line  41)
* SV_INTERRUPT:                          BSD Handler.         (line  33)
* SV_ONSTACK:                            BSD Handler.         (line  28)
* SV_RESETHAND:                          BSD Handler.         (line  40)
* sys_siglist:                           Signal Messages.     (line  41)
* T_FMT:                                 The Elegant and Fast Way.
                                                              (line 101)
* T_FMT_AMPM:                            The Elegant and Fast Way.
                                                              (line 105)
* TCIFLUSH:                              Line Control.        (line  65)
* TCIOFF:                                Line Control.        (line 106)
* TCIOFLUSH:                             Line Control.        (line  71)
* TCION:                                 Line Control.        (line 109)
* TCOFLUSH:                              Line Control.        (line  68)
* TCOOFF:                                Line Control.        (line 100)
* TCOON:                                 Line Control.        (line 103)
* TCSADRAIN:                             Mode Functions.      (line  34)
* TCSAFLUSH:                             Mode Functions.      (line  39)
* TCSANOW:                               Mode Functions.      (line  31)
* TCSASOFT:                              Mode Functions.      (line  42)
* THOUSANDS_SEP:                         The Elegant and Fast Way.
                                                              (line 253)
* THOUSEP:                               The Elegant and Fast Way.
                                                              (line 254)
* timezone:                              Time Zone Functions. (line  44)
* TMP_MAX:                               Temporary Files.     (line  82)
* TOSTOP:                                Local Modes.         (line 111)
* TRY_AGAIN:                             Host Names.          (line  98)
* tzname:                                Time Zone Functions. (line   7)
* TZNAME_MAX:                            General Limits.      (line  45)
* UCHAR_MAX:                             Range of Type.       (line  28)
* UINT_MAX:                              Range of Type.       (line  57)
* ULONG_LONG_MAX:                        Range of Type.       (line  77)
* ULONG_MAX:                             Range of Type.       (line  67)
* USER_PROCESS <1>:                      XPG Functions.       (line  66)
* USER_PROCESS:                          Manipulating the Database.
                                                              (line  96)
* USHRT_MAX:                             Range of Type.       (line  47)
* VDISCARD:                              Other Special.       (line  23)
* VDSUSP:                                Signal Characters.   (line  53)
* VEOF:                                  Editing Characters.  (line  10)
* VEOL:                                  Editing Characters.  (line  22)
* VEOL2:                                 Editing Characters.  (line  35)
* VERASE:                                Editing Characters.  (line  47)
* VINTR:                                 Signal Characters.   (line  11)
* VKILL:                                 Editing Characters.  (line  85)
* VLNEXT:                                Other Special.       (line   9)
* VMIN:                                  Noncanonical Input.  (line  26)
* VQUIT:                                 Signal Characters.   (line  22)
* VREPRINT:                              Editing Characters.  (line  96)
* VSTART:                                Start/Stop Characters.
                                                              (line  11)
* VSTATUS:                               Other Special.       (line  35)
* VSTOP:                                 Start/Stop Characters.
                                                              (line  28)
* VSUSP:                                 Signal Characters.   (line  33)
* VTIME:                                 Noncanonical Input.  (line  34)
* VWERASE:                               Editing Characters.  (line  61)
* W_OK:                                  Testing File Access. (line  79)
* WCHAR_MAX <1>:                         Extended Char Intro. (line 110)
* WCHAR_MAX:                             Range of Type.       (line  81)
* WCHAR_MIN:                             Extended Char Intro. (line 104)
* WEOF <1>:                              Extended Char Intro. (line 118)
* WEOF:                                  EOF and Errors.      (line  24)
* X_OK:                                  Testing File Access. (line  82)
* YESEXPR:                               The Elegant and Fast Way.
                                                              (line 264)
* YESSTR:                                The Elegant and Fast Way.
                                                              (line 275)


File: libc.info,  Node: File Index,  Prev: Variable Index,  Up: Top

Program and File Index
**********************

 [index ]
* Menu:

* -lbsd-compat <1>:                      Feature Test Macros. (line  88)
* -lbsd-compat:                          Process Group Functions.
                                                              (line  55)
* /etc/group:                            Group Database.      (line   6)
* /etc/hosts:                            Host Names.          (line  13)
* /etc/localtime:                        TZ Variable.         (line 110)
* /etc/networks:                         Networks Database.   (line   6)
* /etc/passwd:                           User Database.       (line   6)
* /etc/protocols:                        Protocols Database.  (line  19)
* /etc/services:                         Services Database.   (line   6)
* /share/lib/zoneinfo:                   TZ Variable.         (line 118)
* argp.h:                                Argp.                (line  25)
* argz.h:                                Argz Functions.      (line  24)
* arpa/inet.h:                           Host Address Functions.
                                                              (line   6)
* assert.h:                              Consistency Checking.
                                                              (line  11)
* bsd-compat <1>:                        Feature Test Macros. (line  88)
* bsd-compat:                            Process Group Functions.
                                                              (line  55)
* cd:                                    Working Directory.   (line  18)
* chgrp:                                 File Owner.          (line  27)
* chown:                                 File Owner.          (line  27)
* complex.h <1>:                         Operations on Complex.
                                                              (line   6)
* complex.h <2>:                         Mathematics.         (line   9)
* complex.h:                             Complex Numbers.     (line   6)
* ctype.h <1>:                           Classification of Characters.
                                                              (line  25)
* ctype.h <2>:                           Character Handling.  (line   9)
* ctype.h:                               Case Conversion.     (line  21)
* dirent.h <1>:                          Random Access Directory.
                                                              (line   6)
* dirent.h <2>:                          Directory Entries.   (line   6)
* dirent.h <3>:                          Reserved Names.      (line  80)
* dirent.h <4>:                          Opening a Directory. (line   6)
* dirent.h:                              Reading/Closing Directory.
                                                              (line   6)
* envz.h:                                Envz Functions.      (line  26)
* errno.h <1>:                           Checking for Errors. (line  12)
* errno.h <2>:                           Error Reporting.     (line  13)
* errno.h <3>:                           Checking for Errors. (line  53)
* errno.h:                               Error Codes.         (line   6)
* execinfo.h:                            Backtraces.          (line  13)
* fcntl.h <1>:                           Duplicating Descriptors.
                                                              (line  20)
* fcntl.h <2>:                           Descriptor Flags.    (line  16)
* fcntl.h <3>:                           Opening and Closing Files.
                                                              (line   8)
* fcntl.h <4>:                           Reserved Names.      (line  83)
* fcntl.h <5>:                           Interrupt Input.     (line  20)
* fcntl.h <6>:                           Control Operations.  (line  15)
* fcntl.h <7>:                           File Locks.          (line  34)
* fcntl.h:                               File Status Flags.   (line  27)
* float.h:                               Floating Point Parameters.
                                                              (line   6)
* fnmatch.h:                             Wildcard Matching.   (line   6)
* gcc:                                   ISO C.               (line  15)
* gconv.h:                               glibc iconv Implementation.
                                                              (line 203)
* grp.h <1>:                             Setting Groups.      (line  95)
* grp.h <2>:                             Group Data Structure.
                                                              (line   7)
* grp.h:                                 Reserved Names.      (line  85)
* hostid:                                Host Identification. (line  49)
* hostname:                              Host Identification. (line  49)
* iconv.h:                               Generic Conversion Interface.
                                                              (line 191)
* kill:                                  Termination Signals. (line  27)
* ksh:                                   Wildcard Matching.   (line  71)
* langinfo.h:                            The Elegant and Fast Way.
                                                              (line  23)
* limits.h <1>:                          Width of Type.       (line  14)
* limits.h <2>:                          Reserved Names.      (line  87)
* limits.h <3>:                          General Limits.      (line  13)
* limits.h <4>:                          Limits for Files.    (line  14)
* limits.h:                              Selecting the Conversion.
                                                              (line  22)
* locale:                                Setting the Locale.  (line  29)
* locale.h <1>:                          The Lame Way to Locale Data.
                                                              (line  13)
* locale.h:                              Setting the Locale.  (line  21)
* localtime:                             TZ Variable.         (line 110)
* ls:                                    File Attributes.     (line   6)
* malloc.h <1>:                          Statistics of Malloc.
                                                              (line   9)
* malloc.h <2>:                          Malloc Tunable Parameters.
                                                              (line   8)
* malloc.h:                              Hooks for Malloc.    (line  11)
* math.h <1>:                            Absolute Value.      (line  12)
* math.h <2>:                            Rounding Functions.  (line   6)
* math.h <3>:                            Normalization Functions.
                                                              (line  14)
* math.h <4>:                            Floating Point Classes.
                                                              (line   6)
* math.h:                                Mathematics.         (line   9)
* mcheck.h:                              Heap Consistency Checking.
                                                              (line   8)
* mkdir:                                 Creating Directories.
                                                              (line   6)
* netdb.h <1>:                           Host Names.          (line  13)
* netdb.h <2>:                           Networks Database.   (line   6)
* netdb.h <3>:                           Services Database.   (line   9)
* netdb.h:                               Protocols Database.  (line  27)
* netinet/in.h <1>:                      Ports.               (line  35)
* netinet/in.h <2>:                      Byte Order.          (line  33)
* netinet/in.h <3>:                      Internet Address Formats.
                                                              (line  13)
* netinet/in.h:                          Host Address Data Type.
                                                              (line  23)
* obstack.h:                             Creating Obstacks.   (line   7)
* printf.h <1>:                          Conversion Specifier Options.
                                                              (line  13)
* printf.h:                              Registering New Conversions.
                                                              (line   7)
* pwd.h <1>:                             User Data Structure. (line   7)
* pwd.h:                                 Reserved Names.      (line  89)
* setjmp.h <1>:                          Non-Local Details.   (line   8)
* setjmp.h:                              Non-Local Exits and Signals.
                                                              (line  18)
* sh:                                    Running a Command.   (line  12)
* signal.h <1>:                          Basic Signal Handling.
                                                              (line   8)
* signal.h <2>:                          Process Signal Mask. (line  12)
* signal.h <3>:                          Signaling Another Process.
                                                              (line  24)
* signal.h <4>:                          Checking for Pending Signals.
                                                              (line   7)
* signal.h <5>:                          Signaling Yourself.  (line   7)
* signal.h <6>:                          BSD Signal Handling. (line  25)
* signal.h <7>:                          Flags for Sigaction. (line  23)
* signal.h <8>:                          Advanced Signal Handling.
                                                              (line  12)
* signal.h <9>:                          Standard Signals.    (line   6)
* signal.h <10>:                         Reserved Names.      (line  92)
* signal.h:                              Signal Sets.         (line  11)
* stdarg.h <1>:                          Receiving Arguments. (line  10)
* stdarg.h:                              Argument Macros.     (line   7)
* stddef.h:                              Important Data Types.
                                                              (line  11)
* stdint.h:                              Integers.            (line  23)
* stdio.h <1>:                           Formatted Output Functions.
                                                              (line  11)
* stdio.h <2>:                           Block Input/Output.  (line  25)
* stdio.h <3>:                           String Streams.      (line   7)
* stdio.h <4>:                           Character Input.     (line   8)
* stdio.h <5>:                           Signal Messages.     (line  38)
* stdio.h <6>:                           Standard Streams.    (line  11)
* stdio.h <7>:                           Portable Positioning.
                                                              (line  50)
* stdio.h <8>:                           Opening Streams.     (line  10)
* stdio.h <9>:                           Controlling Buffering.
                                                              (line  11)
* stdio.h <10>:                          File Positioning.    (line  19)
* stdio.h <11>:                          Identifying the Terminal.
                                                              (line  13)
* stdio.h <12>:                          Formatted Input Functions.
                                                              (line   7)
* stdio.h <13>:                          Who Logged In.       (line  14)
* stdio.h <14>:                          Flushing Buffers.    (line  23)
* stdio.h <15>:                          Simple Output.       (line  10)
* stdio.h <16>:                          Temporary Files.     (line  17)
* stdio.h <17>:                          Deleting Files.      (line  72)
* stdio.h <18>:                          Streams.             (line  14)
* stdio.h <19>:                          Variable Arguments Output.
                                                              (line  55)
* stdio.h <20>:                          Descriptors and Streams.
                                                              (line   9)
* stdio.h:                               Streams and Cookies. (line  25)
* stdlib.h <1>:                          Variable Size Automatic.
                                                              (line  16)
* stdlib.h <2>:                          Basic Allocation.    (line   7)
* stdlib.h <3>:                          Freeing after Malloc.
                                                              (line   8)
* stdlib.h <4>:                          Changing Block Size. (line  13)
* stdlib.h <5>:                          Allocating Cleared Space.
                                                              (line   7)
* stdlib.h <6>:                          Aligned Memory Blocks.
                                                              (line   6)
* stdlib.h <7>:                          Running a Command.   (line  30)
* stdlib.h <8>:                          Aborting a Program.  (line   7)
* stdlib.h <9>:                          Exit Status.         (line  43)
* stdlib.h <10>:                         Environment Access.  (line  10)
* stdlib.h <11>:                         Selecting the Conversion.
                                                              (line  31)
* stdlib.h <12>:                         Non-reentrant Character Conversion.
                                                              (line  95)
* stdlib.h <13>:                         Parsing of Floats.   (line   6)
* stdlib.h <14>:                         Parsing of Integers. (line   6)
* stdlib.h <15>:                         Absolute Value.      (line  12)
* stdlib.h <16>:                         Integer Division.    (line  16)
* stdlib.h <17>:                         SVID Random.         (line  31)
* stdlib.h <18>:                         BSD Random.          (line  10)
* stdlib.h <19>:                         ISO Random.          (line  10)
* stdlib.h <20>:                         Allocation.          (line   6)
* stdlib.h <21>:                         Temporary Files.     (line 142)
* stdlib.h <22>:                         Array Search Function.
                                                              (line  45)
* stdlib.h:                              Array Sort Function. (line   7)
* string.h <1>:                          Collation Functions. (line  18)
* string.h <2>:                          Trivial Encryption.  (line  15)
* string.h <3>:                          Finding Tokens in a String.
                                                              (line   9)
* string.h <4>:                          Search Functions.    (line   8)
* string.h <5>:                          Signal Messages.     (line  21)
* string.h <6>:                          Copying and Concatenation.
                                                              (line  10)
* string.h <7>:                          String/Array Comparison.
                                                              (line  22)
* string.h:                              String Length.       (line   7)
* sys/param.h:                           Host Identification. (line  69)
* sys/resource.h <1>:                    Traditional Scheduling Functions.
                                                              (line   6)
* sys/resource.h <2>:                    Limits on Resources. (line  26)
* sys/resource.h:                        Resource Usage.      (line   6)
* sys/socket.h <1>:                      Sending Datagrams.   (line   6)
* sys/socket.h <2>:                      Socket Option Functions.
                                                              (line   6)
* sys/socket.h <3>:                      Socket-Level Options.
                                                              (line  11)
* sys/socket.h <4>:                      Receiving Data.      (line   6)
* sys/socket.h <5>:                      Communication Styles.
                                                              (line   9)
* sys/socket.h <6>:                      Address Formats.     (line  20)
* sys/socket.h <7>:                      Setting Address.     (line   6)
* sys/socket.h <8>:                      Reading Address.     (line   6)
* sys/socket.h <9>:                      Local Namespace Details.
                                                              (line   6)
* sys/socket.h <10>:                     Internet Namespace.  (line  18)
* sys/socket.h <11>:                     Creating a Socket.   (line   7)
* sys/socket.h <12>:                     Closing a Socket.    (line  13)
* sys/socket.h <13>:                     Socket Pairs.        (line   6)
* sys/socket.h <14>:                     Sending Data.        (line   6)
* sys/socket.h:                          Socket Data Options. (line   6)
* sys/stat.h <1>:                        Testing File Type.   (line  21)
* sys/stat.h <2>:                        FIFO Special Files.  (line  17)
* sys/stat.h <3>:                        Making Special Files.
                                                              (line  10)
* sys/stat.h <4>:                        Creating Directories.
                                                              (line  47)
* sys/stat.h <5>:                        Setting Permissions. (line  41)
* sys/stat.h <6>:                        Attribute Meanings.  (line  12)
* sys/stat.h <7>:                        Reserved Names.      (line  95)
* sys/stat.h:                            Permission Bits.     (line  13)
* sys/time.h <1>:                        File Times.          (line  94)
* sys/time.h <2>:                        Setting an Alarm.    (line  51)
* sys/time.h:                            High-Resolution Calendar.
                                                              (line  12)
* sys/times.h <1>:                       Processor Time.      (line   9)
* sys/times.h:                           Reserved Names.      (line  97)
* sys/timex.h:                           High Accuracy Clock. (line   6)
* sys/types.h <1>:                       Terminal Access Functions.
                                                              (line   8)
* sys/types.h <2>:                       Process Group Functions.
                                                              (line   8)
* sys/types.h <3>:                       Process Identification.
                                                              (line  10)
* sys/types.h <4>:                       Waiting for I/O.     (line  23)
* sys/types.h <5>:                       Setting Groups.      (line   8)
* sys/types.h <6>:                       Setting User ID.     (line   8)
* sys/types.h:                           Reading Persona.     (line   9)
* sys/un.h:                              Local Namespace Details.
                                                              (line  22)
* sys/utsname.h:                         Platform Type.       (line   8)
* sys/vlimit.h:                          Limits on Resources. (line 212)
* sys/vtimes.h:                          Resource Usage.      (line 105)
* sys/wait.h <1>:                        BSD Wait Functions.  (line  14)
* sys/wait.h <2>:                        Process Completion Status.
                                                              (line  10)
* sys/wait.h:                            Process Completion.  (line   8)
* termios.h <1>:                         Reserved Names.      (line 101)
* termios.h:                             Terminal Modes.      (line   6)
* time.h <1>:                            Formatting Calendar Time.
                                                              (line   7)
* time.h <2>:                            Simple Calendar Time.
                                                              (line   8)
* time.h <3>:                            CPU Time.            (line   7)
* time.h <4>:                            File Times.          (line  14)
* time.h:                                TZ Variable.         (line   9)
* ulimit.h:                              Limits on Resources. (line 175)
* umask:                                 Setting Permissions. (line  29)
* unistd.h <1>:                          Opening and Closing Files.
                                                              (line   8)
* unistd.h <2>:                          I/O Primitives.      (line   8)
* unistd.h <3>:                          Descriptors and Streams.
                                                              (line  51)
* unistd.h <4>:                          Duplicating Descriptors.
                                                              (line  20)
* unistd.h <5>:                          Working Directory.   (line  21)
* unistd.h <6>:                          Hard Links.          (line  25)
* unistd.h <7>:                          Symbolic Links.      (line  43)
* unistd.h <8>:                          Deleting Files.      (line  67)
* unistd.h <9>:                          File Owner.          (line  31)
* unistd.h <10>:                         Testing File Access. (line  73)
* unistd.h <11>:                         Creating a Pipe.     (line  14)
* unistd.h <12>:                         Is It a Terminal.    (line  10)
* unistd.h <13>:                         Setting an Alarm.    (line  51)
* unistd.h <14>:                         Using Getopt.        (line   7)
* unistd.h <15>:                         Termination Internals.
                                                              (line   7)
* unistd.h <16>:                         Process Identification.
                                                              (line  10)
* unistd.h <17>:                         Creating a Process.  (line   7)
* unistd.h <18>:                         Executing a File.    (line  13)
* unistd.h <19>:                         Process Group Functions.
                                                              (line   8)
* unistd.h <20>:                         Terminal Access Functions.
                                                              (line   8)
* unistd.h <21>:                         Reading Persona.     (line   9)
* unistd.h <22>:                         Setting User ID.     (line   8)
* unistd.h <23>:                         Setting Groups.      (line   8)
* unistd.h <24>:                         Who Logged In.       (line  14)
* unistd.h <25>:                         Host Identification. (line  49)
* unistd.h <26>:                         System Options.      (line  11)
* unistd.h:                              Options for Files.   (line  43)
* utime.h:                               File Times.          (line  36)
* utmp.h <1>:                            Logging In and Out.  (line   7)
* utmp.h:                                Manipulating the Database.
                                                              (line   7)
* utmpx.h:                               XPG Functions.       (line   7)
* varargs.h:                             Old Varargs.         (line   6)
* wchar.h <1>:                           Extended Char Intro. (line 142)
* wchar.h <2>:                           Copying and Concatenation.
                                                              (line  10)
* wchar.h <3>:                           Keeping the state.   (line  52)
* wchar.h <4>:                           Parsing of Integers. (line   6)
* wchar.h <5>:                           Character Input.     (line   8)
* wchar.h <6>:                           Converting a Character.
                                                              (line 115)
* wchar.h <7>:                           Simple Output.       (line  10)
* wchar.h <8>:                           Converting a Character.
                                                              (line 282)
* wchar.h <9>:                           Converting Strings.  (line 122)
* wchar.h:                               Collation Functions. (line  18)
* wctype.h <1>:                          Classification of Wide Characters.
                                                              (line 165)
* wctype.h <2>:                          Wide Character Case Conversion.
                                                              (line  17)
* wctype.h:                              Classification of Wide Characters.
                                                              (line 204)
* zoneinfo:                              TZ Variable.         (line 118)



Tag Table:
Node: Top63406
Node: Introduction122576
Node: Getting Started123928
Node: Standards and Portability125392
Node: ISO C126845
Node: POSIX128371
Node: Berkeley Unix130117
Node: SVID130890
Node: XPG131899
Node: Using the Library132849
Node: Header Files133577
Node: Macro Definitions137538
Node: Reserved Names139887
Node: Feature Test Macros144610
Node: Roadmap to the Manual155416
Node: Error Reporting162705
Node: Checking for Errors163624
Node: Error Codes167843
Node: Error Messages187476
Node: Memory201788
Node: Memory Concepts202646
Node: Memory Allocation208328
Node: Memory Allocation and C209222
Node: Unconstrained Allocation212799
Node: Basic Allocation214228
Node: Malloc Examples215944
Node: Freeing after Malloc217924
Node: Changing Block Size219751
Node: Allocating Cleared Space222370
Node: Efficiency and Malloc223394
Node: Aligned Memory Blocks224506
Node: Malloc Tunable Parameters226734
Node: Heap Consistency Checking228819
Node: Hooks for Malloc233937
Node: Statistics of Malloc240122
Node: Summary of Malloc242100
Node: Allocation Debugging244277
Node: Tracing malloc245389
Node: Using the Memory Debugger247257
Node: Tips for the Memory Debugger249150
Node: Interpreting the traces250466
Node: Obstacks254004
Node: Creating Obstacks255627
Node: Preparing for Obstacks257542
Node: Allocation in an Obstack260295
Node: Freeing Obstack Objects262713
Node: Obstack Functions264061
Node: Growing Objects266304
Node: Extra Fast Growing270570
Node: Status of an Obstack274207
Node: Obstacks Data Alignment275642
Node: Obstack Chunks277530
Node: Summary of Obstacks279901
Node: Variable Size Automatic283331
Node: Alloca Example284869
Node: Advantages of Alloca286003
Node: Disadvantages of Alloca287903
Node: GNU C Variable-Size Arrays288659
Node: Resizing the Data Segment289828
Node: Locking Pages291925
Node: Why Lock Pages292693
Node: Locked Memory Details294332
Node: Page Lock Functions296601
Node: Character Handling302483
Node: Classification of Characters303941
Node: Case Conversion307847
Node: Classification of Wide Characters309749
Node: Using Wide Char Classes317511
Node: Wide Character Case Conversion319827
Node: String and Array Utilities322530
Node: Representation of Strings324595
Node: String/Array Conventions330124
Node: String Length333063
Node: Copying and Concatenation336874
Node: String/Array Comparison362272
Node: Collation Functions372423
Node: Search Functions382544
Node: Finding Tokens in a String394754
Node: strfry406558
Node: Trivial Encryption407593
Node: Encode Binary Data409063
Node: Argz and Envz Vectors413738
Node: Argz Functions414345
Node: Envz Functions420926
Node: Character Set Handling423992
Node: Extended Char Intro425145
Node: Charset Function Overview438258
Node: Restartable multibyte conversion439226
Node: Selecting the Conversion441341
Node: Keeping the state443728
Node: Converting a Character446953
Node: Converting Strings462964
Node: Multibyte Conversion Example473083
Node: Non-reentrant Conversion476034
Node: Non-reentrant Character Conversion477723
Node: Non-reentrant String Conversion482438
Node: Shift State485437
Node: Generic Charset Conversion488099
Node: Generic Conversion Interface491286
Node: iconv Examples501240
Node: Other iconv Implementations506538
Node: glibc iconv Implementation511937
Node: Locales551482
Node: Effects of Locale553152
Node: Choosing Locale555121
Node: Locale Categories556500
Node: Setting the Locale559022
Node: Standard Locales563554
Node: Locale Information564848
Node: The Lame Way to Locale Data566569
Node: General Numeric568453
Node: Currency Symbol571449
Node: Sign of Money Amount575650
Node: The Elegant and Fast Way577793
Node: Formatting Numbers589939
Node: Yes-or-No Questions599364
Node: Message Translation601400
Node: Message catalogs a la X/Open603447
Node: The catgets Functions604750
Node: The message catalog files613786
Node: The gencat program620534
Node: Common Usage623677
Node: The Uniforum approach630841
Node: Message catalogs with gettext632340
Node: Translation with gettext633384
Node: Locating gettext catalog639705
Node: Advanced gettext functions646583
Ref: Advanced gettext functions-Footnote-1657325
Node: Charset conversion in gettext657417
Node: GUI program problems659920
Node: Using gettextized software665467
Node: Helper programs for gettext673796
Node: Searching and Sorting675569
Node: Comparison Functions676485
Node: Array Search Function677702
Node: Array Sort Function681059
Node: Search/Sort Example683198
Node: Hash Search Function686579
Node: Tree Search Function694273
Node: Pattern Matching701278
Node: Wildcard Matching702083
Node: Globbing706029
Node: Calling Glob706900
Node: Flags for Globbing716907
Node: More Flags for Globbing720448
Node: Regular Expressions726593
Node: POSIX Regexp Compilation727584
Node: Flags for POSIX Regexps731730
Node: Matching POSIX Regexps732648
Node: Regexp Subexpressions734868
Node: Subexpression Complications736935
Node: Regexp Cleanup739311
Node: Word Expansion741674
Node: Expansion Stages743036
Node: Calling Wordexp744540
Node: Flags for Wordexp748517
Node: Wordexp Example750481
Node: Tilde Expansion752283
Node: Variable Substitution753366
Node: I/O Overview757503
Node: I/O Concepts759020
Node: Streams and File Descriptors760174
Node: File Position763272
Node: File Names765420
Node: Directories766315
Node: File Name Resolution768063
Node: File Name Errors771002
Node: File Name Portability772553
Node: I/O on Streams774556
Node: Streams776781
Node: Standard Streams778132
Node: Opening Streams779937
Node: Closing Streams790066
Node: Streams and Threads792627
Node: Streams and I18N801657
Node: Simple Output807828
Node: Character Input813205
Node: Line Input818473
Node: Unreading825167
Node: Unreading Idea825985
Node: How Unread826824
Node: Block Input/Output829598
Node: Formatted Output832393
Node: Formatted Output Basics834169
Node: Output Conversion Syntax836676
Node: Table of Output Conversions841791
Node: Integer Conversions844810
Node: Floating-Point Conversions850364
Node: Other Output Conversions856209
Node: Formatted Output Functions860028
Node: Dynamic Output866041
Node: Variable Arguments Output867933
Node: Parsing a Template String874099
Node: Example of Parsing877947
Node: Customizing Printf880221
Node: Registering New Conversions882149
Node: Conversion Specifier Options884338
Node: Defining the Output Handler888191
Node: Printf Extension Example890667
Node: Predefined Printf Handlers893029
Node: Formatted Input895825
Node: Formatted Input Basics896913
Node: Input Conversion Syntax899621
Node: Table of Input Conversions903002
Node: Numeric Input Conversions907185
Node: String Input Conversions911653
Node: Dynamic String Input916786
Node: Other Input Conversions917979
Node: Formatted Input Functions919637
Node: Variable Arguments Input922499
Node: EOF and Errors924878
Node: Error Recovery927807
Node: Binary Streams929604
Node: File Positioning932139
Node: Portable Positioning939191
Node: Stream Buffering944897
Node: Buffering Concepts946505
Node: Flushing Buffers947887
Node: Controlling Buffering951013
Node: Other Kinds of Streams956646
Node: String Streams957944
Node: Obstack Streams962176
Node: Custom Streams964234
Node: Streams and Cookies964964
Node: Hook Functions968055
Node: Formatted Messages970319
Node: Printing Formatted Messages970993
Node: Adding Severity Classes977448
Node: Example979069
Node: Low-Level I/O982281
Node: Opening and Closing Files985292
Node: I/O Primitives993288
Node: File Position Primitive1007905
Node: Descriptors and Streams1015232
Node: Stream/Descriptor Precautions1017937
Node: Linked Channels1019150
Node: Independent Channels1020422
Node: Cleaning Streams1022336
Node: Scatter-Gather1024648
Node: Memory-mapped I/O1027248
Node: Waiting for I/O1038731
Node: Synchronizing I/O1046912
Node: Asynchronous I/O1050370
Node: Asynchronous Reads/Writes1058441
Node: Status of AIO Operations1070932
Node: Synchronizing AIO Operations1074518
Node: Cancel AIO Operations1080965
Node: Configuration of AIO1084471
Node: Control Operations1086680
Node: Duplicating Descriptors1089383
Node: Descriptor Flags1093651
Node: File Status Flags1097064
Node: Access Modes1098528
Node: Open-time Flags1100844
Node: Operating Modes1105593
Node: Getting File Status Flags1108378
Node: File Locks1110995
Node: Interrupt Input1119905
Node: IOCTLs1122346
Ref: IOCTLs-Footnote-11124336
Node: File System Interface1124433
Node: Working Directory1125965
Node: Accessing Directories1130987
Node: Directory Entries1132648
Node: Opening a Directory1135916
Node: Reading/Closing Directory1139935
Node: Simple Directory Lister1144443
Node: Random Access Directory1145434
Node: Scanning Directory Content1146956
Node: Simple Directory Lister Mark II1151428
Node: Working with Directory Trees1152534
Node: Hard Links1164868
Node: Symbolic Links1167677
Node: Deleting Files1175182
Node: Renaming Files1178114
Node: Creating Directories1181727
Node: File Attributes1183489
Node: Attribute Meanings1185020
Node: Reading Attributes1194265
Node: Testing File Type1198352
Node: File Owner1202532
Node: Permission Bits1206197
Node: Access Permission1211528
Node: Setting Permissions1212681
Node: Testing File Access1217904
Node: File Times1221584
Node: File Size1227991
Node: Making Special Files1234428
Node: Temporary Files1236116
Node: Pipes and FIFOs1245423
Node: Creating a Pipe1247009
Node: Pipe to a Subprocess1250277
Node: FIFO Special Files1253278
Node: Pipe Atomicity1254860
Node: Sockets1255750
Node: Socket Concepts1257793
Node: Communication Styles1262040
Node: Socket Addresses1263902
Node: Address Formats1265945
Node: Setting Address1269158
Node: Reading Address1270892
Node: Interface Naming1272665
Node: Local Namespace1275085
Node: Local Namespace Concepts1275752
Node: Local Namespace Details1277280
Node: Local Socket Example1279244
Node: Internet Namespace1280733
Node: Internet Address Formats1282967
Node: Host Addresses1285133
Node: Abstract Host Addresses1286312
Node: Host Address Data Type1290834
Node: Host Address Functions1293981
Node: Host Names1298370
Node: Ports1307645
Node: Services Database1309696
Node: Byte Order1312538
Node: Protocols Database1314863
Node: Inet Example1318424
Node: Misc Namespaces1320415
Node: Open/Close Sockets1321168
Node: Creating a Socket1321673
Node: Closing a Socket1323367
Node: Socket Pairs1324905
Node: Connections1326925
Node: Connecting1328026
Node: Listening1330865
Node: Accepting Connections1332941
Node: Who is Connected1336084
Node: Transferring Data1337198
Node: Sending Data1338314
Node: Receiving Data1340859
Node: Socket Data Options1342622
Node: Byte Stream Example1343503
Node: Server Example1345531
Node: Out-of-Band Data1349518
Node: Datagrams1355385
Node: Sending Datagrams1356423
Node: Receiving Datagrams1358362
Node: Datagram Example1360442
Node: Example Receiver1362439
Node: Inetd1364976
Node: Inetd Servers1365794
Node: Configuring Inetd1367049
Node: Socket Options1369731
Node: Socket Option Functions1370448
Node: Socket-Level Options1372020
Node: Networks Database1375667
Node: Low-Level Terminal Interface1378566
Node: Is It a Terminal1380038
Node: I/O Queues1381951
Node: Canonical or Not1383915
Node: Terminal Modes1385768
Node: Mode Data Types1387344
Node: Mode Functions1389187
Node: Setting Modes1393132
Node: Input Modes1395137
Node: Output Modes1400427
Node: Control Modes1402054
Node: Local Modes1406173
Node: Line Speed1412517
Node: Special Characters1416711
Node: Editing Characters1418636
Node: Signal Characters1422998
Node: Start/Stop Characters1425883
Node: Other Special1427770
Node: Noncanonical Input1429602
Node: BSD Terminal Modes1434432
Node: Line Control1435914
Node: Noncanon Example1440643
Node: Pseudo-Terminals1442822
Node: Allocation1443741
Node: Pseudo-Terminal Pairs1448509
Node: Syslog1451062
Node: Overview of Syslog1452014
Node: Submitting Syslog Messages1456209
Node: openlog1457034
Node: syslog; vsyslog1462031
Node: closelog1466239
Node: setlogmask1467391
Node: Syslog Example1469246
Node: Mathematics1469900
Node: Mathematical Constants1471627
Node: Trig Functions1473642
Node: Inverse Trig Functions1477405
Node: Exponents and Logarithms1481235
Node: Hyperbolic Functions1489499
Node: Special Functions1493582
Node: Errors in Math Functions1498163
Node: Pseudo-Random Numbers1538376
Node: ISO Random1540624
Node: BSD Random1542573
Node: SVID Random1547168
Node: FP Function Optimizations1560489
Node: Arithmetic1562583
Node: Integers1563865
Node: Integer Division1566894
Node: Floating Point Numbers1570596
Node: Floating Point Classes1572344
Node: Floating Point Errors1576183
Node: FP Exceptions1576690
Node: Infinity and NaN1581062
Node: Status bit operations1584148
Node: Math Error Reporting1588301
Node: Rounding1590641
Node: Control Functions1594238
Node: Arithmetic Functions1599072
Node: Absolute Value1599947
Node: Normalization Functions1602028
Node: Rounding Functions1605358
Node: Remainder Functions1609817
Node: FP Bit Twiddling1611980
Node: FP Comparison Functions1615116
Node: Misc FP Arithmetic1617844
Node: Complex Numbers1620609
Node: Operations on Complex1622323
Node: Parsing of Numbers1624691
Node: Parsing of Integers1625392
Node: Parsing of Floats1636010
Node: System V Number Conversion1641196
Node: Date and Time1646803
Node: Time Basics1647536
Node: Elapsed Time1649437
Node: Processor And CPU Time1652984
Node: CPU Time1654866
Node: Processor Time1656646
Node: Calendar Time1659063
Node: Simple Calendar Time1661009
Node: High-Resolution Calendar1663429
Node: Broken-down Time1668817
Node: High Accuracy Clock1676797
Node: Formatting Calendar Time1684245
Node: Parsing Date and Time1700207
Node: Low-Level Time String Parsing1701062
Node: General Time String Parsing1714656
Node: TZ Variable1721802
Node: Time Zone Functions1727858
Node: Time Functions Example1730716
Node: Setting an Alarm1731800
Node: Sleeping1737579
Node: Resource Usage And Limitation1742191
Node: Resource Usage1742871
Node: Limits on Resources1748466
Node: Priority1757709
Node: Absolute Priority1760149
Node: Realtime Scheduling1765266
Node: Basic Scheduling Functions1768724
Node: Traditional Scheduling1776680
Node: Traditional Scheduling Intro1777264
Node: Traditional Scheduling Functions1781543
Node: CPU Affinity1785450
Node: Memory Resources1791480
Node: Memory Subsystem1792338
Node: Query Memory Parameters1794731
Node: Processor Resources1798392
Node: Non-Local Exits1800518
Node: Non-Local Intro1801231
Node: Non-Local Details1804944
Node: Non-Local Exits and Signals1808032
Node: System V contexts1809541
Node: Signal Handling1822417
Node: Concepts of Signals1824454
Node: Kinds of Signals1825025
Node: Signal Generation1826431
Node: Delivery of Signal1828709
Node: Standard Signals1831574
Node: Program Error Signals1833175
Node: Termination Signals1840661
Node: Alarm Signals1844520
Node: Asynchronous I/O Signals1845775
Node: Job Control Signals1846979
Node: Operation Error Signals1851609
Node: Miscellaneous Signals1853563
Node: Signal Messages1855272
Node: Signal Actions1857169
Node: Basic Signal Handling1858121
Node: Advanced Signal Handling1864191
Node: Signal and Sigaction1867180
Node: Sigaction Function Example1868943
Node: Flags for Sigaction1871240
Node: Initial Signal Actions1873632
Node: Defining Handlers1875014
Node: Handler Returns1877206
Node: Termination in Handler1879232
Node: Longjmp in Handler1880666
Node: Signals in Handler1882756
Node: Merged Signals1884887
Node: Nonreentrancy1890556
Node: Atomic Data Access1895973
Node: Non-atomic Example1897030
Node: Atomic Types1898816
Node: Atomic Usage1899805
Node: Interrupted Primitives1901290
Node: Generating Signals1904764
Node: Signaling Yourself1905364
Node: Signaling Another Process1907332
Node: Permission for kill1910723
Node: Kill Example1912530
Node: Blocking Signals1914838
Node: Why Block1916617
Node: Signal Sets1918164
Node: Process Signal Mask1921211
Node: Testing for Delivery1924541
Node: Blocking for Handler1925785
Node: Checking for Pending Signals1928200
Node: Remembering a Signal1930206
Node: Waiting for a Signal1933751
Node: Using Pause1934303
Node: Pause Problems1935940
Node: Sigsuspend1937665
Node: Signal Stack1940368
Node: BSD Signal Handling1945701
Node: BSD Handler1946986
Node: Blocking in BSD1949437
Node: Program Basics1950908
Node: Program Arguments1952898
Node: Argument Syntax1954904
Node: Parsing Program Arguments1957589
Node: Getopt1958704
Node: Using Getopt1959349
Node: Example of Getopt1963485
Node: Getopt Long Options1966329
Node: Getopt Long Option Example1971585
Node: Argp1974640
Node: Argp Global Variables1977976
Node: Argp Parsers1980023
Node: Argp Option Vectors1983409
Node: Argp Option Flags1986636
Node: Argp Parser Functions1988697
Node: Argp Special Keys1991401
Node: Argp Helper Functions1996702
Node: Argp Parsing State1999753
Node: Argp Children2003332
Node: Argp Flags2005426
Node: Argp Help Filtering2007715
Node: Argp Help Filter Keys2008962
Node: Argp Help2009890
Node: Argp Help Flags2011082
Node: Argp Examples2013445
Node: Argp Example 12013928
Node: Argp Example 22014730
Node: Argp Example 32017648
Node: Argp Example 42024580
Node: Argp User Customization2032216
Node: Suboptions2033957
Node: Suboptions Example2035917
Node: Environment Variables2038064
Node: Environment Access2039936
Node: Standard Environment2044858
Node: System Calls2049042
Node: Program Termination2052538
Node: Normal Termination2053754
Node: Exit Status2055163
Node: Cleanups on Exit2058538
Node: Aborting a Program2060358
Node: Termination Internals2061271
Node: Processes2063466
Node: Running a Command2065490
Node: Process Creation Concepts2067525
Node: Process Identification2069541
Node: Creating a Process2070477
Node: Executing a File2074108
Node: Process Completion2081260
Node: Process Completion Status2087542
Node: BSD Wait Functions2089201
Node: Process Creation Example2091080
Node: Job Control2093328
Node: Concepts of Job Control2094609
Node: Job Control is Optional2097970
Node: Controlling Terminal2099026
Node: Access to the Terminal2099941
Node: Orphaned Process Groups2101551
Node: Implementing a Shell2102549
Node: Data Structures2103439
Node: Initializing the Shell2106073
Node: Launching Jobs2109765
Node: Foreground and Background2117184
Node: Stopped and Terminated Jobs2120284
Node: Continuing Stopped Jobs2125419
Node: Missing Pieces2127042
Node: Functions for Job Control2128677
Node: Identifying the Terminal2129164
Node: Process Group Functions2130752
Node: Terminal Access Functions2135783
Node: Name Service Switch2139276
Node: NSS Basics2140610
Node: NSS Configuration File2142206
Node: Services in the NSS configuration2143896
Node: Actions in the NSS configuration2145188
Node: Notes on NSS Configuration File2148360
Node: NSS Module Internals2150248
Node: NSS Module Names2150951
Ref: NSS Module Names-Footnote-12153006
Ref: NSS Module Names-Footnote-22153160
Node: NSS Modules Interface2153338
Node: Extending NSS2158041
Node: Adding another Service to NSS2158979
Node: NSS Module Function Internals2161221
Node: Users and Groups2166136
Node: User and Group IDs2168750
Node: Process Persona2169665
Node: Why Change Persona2171357
Node: How Change Persona2173245
Node: Reading Persona2175139
Node: Setting User ID2177425
Node: Setting Groups2180300
Node: Enable/Disable Setuid2185982
Node: Setuid Program Example2188024
Node: Tips for Setuid2191420
Node: Who Logged In2193944
Node: User Accounting Database2196338
Node: Manipulating the Database2197531
Node: XPG Functions2209889
Node: Logging In and Out2214339
Node: User Database2216474
Node: User Data Structure2217145
Node: Lookup User2218418
Node: Scanning All Users2220999
Node: Writing a User Entry2223972
Node: Group Database2224991
Node: Group Data Structure2225576
Node: Lookup Group2226355
Node: Scanning All Groups2228873
Node: Database Example2231922
Node: Netgroup Database2234098
Node: Netgroup Data2234521
Node: Lookup Netgroup2236062
Node: Netgroup Membership2239497
Node: System Management2240841
Node: Host Identification2241775
Node: Platform Type2248282
Node: Filesystem Handling2251598
Node: Mount Information2253105
Node: fstab2255288
Node: mtab2261125
Node: Other Mount Information2270480
Node: Mount-Unmount-Remount2271009
Node: System Parameters2281011
Node: System Configuration2286557
Node: General Limits2288131
Node: System Options2291781
Node: Version Supported2295127
Node: Sysconf2296976
Node: Sysconf Definition2297619
Node: Constants for Sysconf2298306
Node: Examples of Sysconf2311252
Node: Minimums2312256
Node: Limits for Files2314974
Node: Options for Files2317990
Node: File Minimums2320293
Node: Pathconf2322520
Node: Utility Limits2325834
Node: Utility Minimums2327781
Node: String Parameters2329545
Node: Cryptographic Functions2333445
Node: Legal Problems2335421
Node: getpass2337696
Node: crypt2339849
Node: DES Encryption2344579
Node: Debugging Support2350796
Node: Backtraces2351445
Node: Language Features2356209
Node: Consistency Checking2357158
Node: Variadic Functions2361711
Node: Why Variadic2362788
Node: How Variadic2364761
Node: Variadic Prototypes2366059
Node: Receiving Arguments2367213
Node: How Many Arguments2369897
Node: Calling Variadics2371572
Node: Argument Macros2373685
Node: Variadic Example2376540
Node: Old Varargs2377666
Node: Null Pointer Constant2379357
Node: Important Data Types2380446
Node: Data Type Measurements2383019
Node: Width of Type2383881
Node: Range of Type2384795
Node: Floating Type Macros2388072
Node: Floating Point Concepts2389339
Node: Floating Point Parameters2393080
Node: IEEE Floating Point2400035
Node: Structure Measurement2401801
Node: Library Summary2402504
Node: Installation2607347
Node: Configuring and compiling2608539
Node: Running make install2618029
Node: Tools for Compilation2622083
Node: Linux2625235
Node: Reporting Bugs2628141
Node: Maintenance2630468
Node: Source Layout2630873
Node: Porting2634810
Node: Hierarchy Conventions2642605
Node: Porting to Unix2647670
Node: Contributors2649694
Node: Free Manuals2656967
Node: Copying2661906
Node: Documentation License2690077
Node: Concept Index2709981
Node: Type Index2809879
Node: Function Index2822228
Node: Variable Index2949860
Node: File Index3056418

End Tag Table
