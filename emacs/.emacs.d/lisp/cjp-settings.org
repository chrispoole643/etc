* Generic Emacs Configuration

System-agnostic.

** Initial Configuration

*** Requirements

These don't require their own section with other commands:

#+BEGIN_SRC emacs-lisp
  (use-package cl-lib)
  (require 'generic-x)
  (require 'smallurl)
#+END_SRC

*** Themes

Other themes I sometimes use:

- monokai-theme
- tangotango-theme
- sanityinc-tomorrow-eighties

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package color-theme-sanityinc-tomorrow
    :config
    ;; Treat all themes as safe:
    (setq custom-safe-themes t)
    (load-theme 'sanityinc-tomorrow-night t))
#+END_SRC

Setup for solarised themes, not in use right now:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package solarized-theme
    :config
    ;; Make the fringe stand out from the background
    (setq solarized-distinct-fringe-background nil)
    ;; Don't change the font for some headings and titles
    (setq solarized-use-variable-pitch nil)
    ;; Make the modeline high contrast: makes it easy to notice the current buffer
    (setq solarized-high-contrast-mode-line t)
    ;; Draw the underline at the same place as the descent line: looks better
    (setq x-underline-at-descent-line t)
    (load-theme 'solarized-light t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package spacemacs-theme
    :config
    ;; ;; Make the fringe stand out from the background
    ;; (setq solarized-distinct-fringe-background nil)
    ;; ;; Don't change the font for some headings and titles
    ;; (setq solarized-use-variable-pitch nil)
    ;; ;; Make the modeline high contrast: makes it easy to notice the current buffer
    ;; (setq solarized-high-contrast-mode-line t)
    ;; ;; Draw the underline at the same place as the descent line: looks better
    ;; (setq x-underline-at-descent-line t)
    (load-theme 'spacemacs-light t))
#+END_SRC

** Auxiliary Packages

Navigation, etc.

*** Navigation
**** Window and frame moving

Turn on winner mode to move back and forwards between window configurations with C-c left
and C-c right respectively:

#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
  (use-package framemove
    :config
    (setq framemove-hook-into-windmove t))
#+END_SRC

The default keybindings of C-c <left> and C-c <right> are annoying to type if going back
more than one or two window configurations. Use super key for higher level Emacs command
like these to avoid interfering with modes:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s-<left>") 'winner-undo)
  (global-set-key (kbd "C-s-<right>") 'winner-redo)

  (global-set-key (kbd "s-<left>")  'windmove-left)
  (global-set-key (kbd "s-<right>") 'windmove-right)
  (global-set-key (kbd "s-<up>")    'windmove-up)
  (global-set-key (kbd "s-<down>")  'windmove-down)
#+END_SRC

**** Treemacs

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :config
    (progn ;(define-key treemacs-mode-map (kbd "C-p p") nil)
           (setq treemacs-follow-after-init          t
                 treemacs-width                      35
                 treemacs-indentation                2
                 treemacs-git-integration            t
                 treemacs-collapse-dirs              3
                 treemacs-silent-refresh             t
                 treemacs-change-root-without-asking nil
                 treemacs-sorting                    'alphabetic-desc
                 treemacs-show-hidden-files          t
                 treemacs-never-persist              nil
                 treemacs-is-never-other-window      t
                 treemacs-goto-tag-strategy          'refetch-index)
           (treemacs-follow-mode t)
           (treemacs-filewatch-mode t)
           (treemacs-resize-icons 11))
    :bind
    (("s-t" . cjp-add-current-project-to-treemacs)
     ("s-a" . cjp-add-current-project-to-treemacs)

     :map treemacs-mode-map
     ("[mouse-1]" . treemacs-single-click-expand-action)
     ("r" . treemacs-remove-project)
     ("a" . treemacs-projectile)
     ;("C-p" . previous-line)
     ))

  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t
    :config
    (setq treemacs-header-function #'treemacs-projectile-create-header))

  (defun cjp-add-current-project-to-treemacs ()
    ""
    (interactive)
    (let ((project-path (projectile-project-root)))
      (treemacs-add-project-at project-path
                               (file-name-base (directory-file-name project-path)))))

  (defun cjp-select-treemacs-or-toggle ()
    ""
    (interactive)
    (if (eq major-mode 'treemacs-mode)
        (select-window cjp-treemacs-prior-window)
      (setq cjp-treemacs-prior-window (selected-window))
      (treemacs-select-window)))
#+END_SRC

**** Neotree

Disabled for now, while trying Treemacs...

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package neotree
    :ensure all-the-icons
    :config
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow)
          ;projectile-switch-project-action 'neotree-projectile-action
          neo-smart-open t
          neo-show-auto-change-root t
          neo-window-width 30
          neo-show-hidden-files t
          neo-force-change-root t
          neo-vc-integration '(face char)
          neo-default-system-application (if macosxp "open" "xdg-open"))
    :bind (:map neotree-mode-map
                ("^" . neotree-select-up-node)))
#+END_SRC

**** Smex

Start smex, saving into Emacs structure:

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :config
    (setq smex-save-file (cjp-emacs-structure-dir ".smex-items")))
#+END_SRC

Smex updates its list of possible commands when run; don't let it:

#+BEGIN_SRC emacs-lisp
  (setq smex-auto-update t)
#+END_SRC

Update smex when Emacs has been idle for (default 60) seconds:

#+BEGIN_SRC emacs-lisp
  (smex-auto-update)
  (smex-initialize)
#+END_SRC

**** Ido & Flx

_Disbled to use Ivy mode instead._

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido
    :config
    (setq ido-save-directory-list-file (cjp-emacs-structure-dir ".ido.last"))
    (ido-mode t)
    (setq ido-everywhere t
          ido-enable-flex-matching t
          ;; If a buffer name that doesn't exist is chosen, just make a new one without prompting
          ido-create-new-buffer 'always
          ;; Use flx faces
          ido-use-faces nil))

  (use-package flx-ido)
#+END_SRC

Ignore the .aux extensions that TeX programs create:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq completion-ignored-extensions
        (cons "*.aux" completion-ignored-extensions))
#+END_SRC

Order extensions by how I use them:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq ido-file-extensions-order '(".tex" ".txt" ".md" ".py" ".sh" ".el" ".xml" ".htm"))
#+END_SRC

Ignore files defined in variable completion-ignored-extensions:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq ido-ignore-extensions t)
#+END_SRC

Default keybinding is backspace key, but I use C-w in the non-Ido-mode minibuffers often,
so this is more conventient for muscle memory:

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key ido-file-completion-map (kbd "C-w") 'ido-delete-backward-updir)
#+END_SRC

Stops Ido searching for similar-named files if I use C-x C-s to create a new
file and buffer:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq ido-auto-merge-work-directories-length -1)
#+END_SRC

Keep annoying buffers out of my face:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq ido-ignore-buffers (list (rx (or (and bos  " ")
                                         (and bos
                                              (or "*Completions*"
                                                  "*Shell Command Output*"
                                                  "*vc-diff*")
                                              eos)))))
#+END_SRC

Allow spaces when using ido-find-file:

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'ido-make-file-list-hook
            (lambda ()
              (define-key ido-file-dir-completion-map (kbd "SPC") 'self-insert-command)))
#+END_SRC

Use Ido for completing-read, such as describe-variable (C-h v) From
http://www.emacswiki.org/emacs/InteractivelyDoThings#toc13:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (defvar ido-enable-replace-completing-read t
  ;;  "If t, use ido-completing-read instead of completing-read if possible.

  ;; Set it to nil using let in around-advice for functions where the
  ;; original completing-read is required.  For example, if a function
  ;; foo absolutely must use the original completing-read, define some
  ;; advice like this:

  ;;    (defadvice foo (around original-completing-read-only activate)
  ;;      (let (ido-enable-replace-completing-read) ad-do-it))")
#+END_SRC

Replace completing-read wherever possible, unless directed otherwise:

#+BEGIN_SRC emacs-lisp :tangle no
  ;;(defadvice completing-read
  ;;  (around use-ido-when-possible activate)
  ;;  (if (or (not ido-enable-replace-completing-read) ; Manual override disable ido
  ;;          (and (boundp 'ido-cur-list)
  ;;               ido-cur-list)) ; Avoid infinite loop from ido calling this
  ;;      ad-do-it
  ;;    (let ((allcomp (all-completions "" collection predicate)))
  ;;      (if allcomp
  ;;          (setq ad-return-value
  ;;                (ido-completing-read prompt
  ;;                                     allcomp
  ;;                                     nil require-match initial-input hist def))
  ;;        ad-do-it))))
#+END_SRC

Don't guess filenames at all when I'm in dired; it's never what I want.  Also, turn off
ido-completing-read, as it messes up dired-do-rename, and probably other stuff too.

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (add-hook 'dired-mode-hook
  ;;          (lambda ()
  ;;             (set (make-local-variable 'ido-use-filename-at-point) nil)
  ;;             (set (make-local-variable 'ido-enable-replace-completing-read) nil)))
#+END_SRC

python.el doesn't like ido-completing-read either:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (add-hook 'python-mode-hook
  ;;          (lambda ()
  ;;             (set (make-local-variable 'ido-enable-replace-completing-read) nil)))
#+END_SRC

**** Sublimity

This works, but not that well (at least on the Mac)... disable for now.

#+BEGIN_SRC emacs-lisp :tangle no
    (use-package sublimity
      :config
      (sublimity-mode 1)
      (require 'sublimity-scroll)
      (require 'sublimity-map))
#+END_SRC

**** Ace-jump

#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :config
    (setq ace-jump-mode-case-sensitive-search nil)
    ;;:bind
    ;;(("C-c SPC" . ace-jump-char-mode))
    )
#+END_SRC

**** ace-isearch

#+BEGIN_SRC emacs-lisp
  (use-package ace-isearch
    :config
    (global-ace-isearch-mode t)

    (setq ace-isearch-input-idle-delay 0.4
          ace-isearch-input-length 10
          ace-isearch-function-from-isearch 'helm-swoop-from-isearch
          ace-isearch-submode 'ace-jump-char-mode
          ace-isearch-use-ace-jump 'printing-char))
#+END_SRC

**** Helm

_Disabled for now... switching to use Ivy._

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ac-helm)
  (use-package helm-dictionary)
#+END_SRC

Good setup advice from https://tuhdo.github.io/helm-intro.html. Use
curl if it's available. Explicitly disable fuzzy matching, as Helm
seems better without. M-x doesn't work with same keys on all systems,
so bind to C-x X-m too (And C-c for good measure, in case your finger
slips).

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package helm
    :config
    (helm-mode 1)
    (helm-adaptive-mode 1)
    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))
    (setq helm-split-window-in-side-p t ; Open helm buffer inside current window
          helm-move-to-line-cycle-in-source t
          helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp
          helm-scroll-amount 8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t
          helm-yank-symbol-first t
          helm-ff-newfile-prompt-p nil)
    (setq helm-M-x-fuzzy-match nil
          helm-buffers-fuzzy-matching nil
          helm-recentf-fuzzy-match nil
          helm-semantic-fuzzy-match nil
          helm-imenu-fuzzy-match nil
          helm-locate-fuzzy-match nil
          helm-apropos-fuzzy-match nil
          helm-lisp-fuzzy-completion nil)

    :bind
    (("M-x" . helm-M-x)
     ("C-x m" . helm-M-x)
     ("C-x C-m" . helm-M-x)
     ("C-c C-m" . helm-M-x)
     ("C-x b" . helm-mini)
     ("C-x C-r" . helm-recentf)
     ("M-y" . helm-show-kill-ring)
     ("C-x C-d" . helm-find-files)
     ("C-x C-f" . helm-find-files)
     ("C-'" . helm-semantic-or-imenu)
     ("C-." . helm-all-mark-rings)
     ("C-," . helm-filtered-bookmarks)
     ("C-h a" . helm-apropos)
     ("C-S-s" . helm-swoop)

     :map helm-map
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-<tab>" . helm-select-action)
     ("C-w" . backward-kill-word)
     ("M-n" . helm-next-source)
     ("M-p" . helm-previous-source)))
#+END_SRC

If the thing at point is a directory, go into the directory (as though hitting
<tab>). Else, open it. If the directory is `.' or `..', open in dired as usual:

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key helm-find-files-map (kbd "<return>")
    '(lambda () (interactive) (let ((sel (helm-get-selection)))
                           (if (and (file-directory-p sel)
                                    (not (helm-ff-dot-file-p sel)))
                               (helm-execute-persistent-action)
                             (helm-maybe-exit-minibuffer)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key helm-find-files-map (kbd "C-x C-f") (lambda () (interactive)
                                                    (let ((current-prefix-arg '(4)))
                                                      (helm-ff-run-browse-project))))
  (define-key helm-find-files-map (kbd "C-x C-d") 'helm-ff-run-locate)
#+END_SRC

If the first two items in helm-find-files results are '.' and '..', and point would
usually be on the first one, move point down by two:

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'helm-after-update-hook
            (lambda () (when (and (helm-file-completion-source-p)
                             (not (helm-empty-source-p))
                             (string-match "/\\.$" (helm-get-selection)))
                    (helm-next-line 2))))
#+END_SRC

Use thing at point when invoking helm-man-woman:

#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
#+END_SRC

***** helm-swoop

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package helm-swoop)
#+END_SRC

=helm-swoop-multiline-from-helm-swoop= is a result of a [[https://www.reddit.com/r/emacs/comments/334a7a/binding_to_trigger_helmswoop_multiline/cqj6xqd][question I asked on reddit]]:

#+BEGIN_SRC emacs-lisp :tangle no
  (defun helm-swoop-multiline-from-helm-swoop ()
    "Run `helm-swoop' over multiple lines, using the current
  helm-swoop pattern."
    (interactive)
    ;; run after exit the current minibuffer operation
    (run-with-timer
     0 nil (lambda () (helm-swoop :$query helm-swoop-pattern :$multiline 4)))
    (exit-minibuffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key isearch-mode-map (kbd "M-s") 'helm-swoop-from-isearch)
  (define-key helm-swoop-map (kbd "M-s") 'helm-multi-swoop-all-from-helm-swoop)
  (define-key helm-multi-swoop-map (kbd "M-s") 'helm-swoop-multiline-from-helm-swoop)
#+END_SRC

Move up and down like isearch:

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
  (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (setq helm-swoop-use-line-number-face t)
#+END_SRC
**** Ivy mode

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish " Ⓘ"
    :config
    (ivy-mode 1)

    ;; Add recentf-mode and bookmarks to ivy-switch-buffer completion candidates
    (setq ivy-use-virtual-buffers t)

    ;; Allow minibuffer commands in the minibuffer
    (setq enable-recursive-minibuffers t)

    ;; I prefer to be able to match words regardless of their search order
    (setq ivy-re-builders-alist
          '((t . ivy--regex-ignore-order)))
    ;; I tried this but found it more irritating than not...
    ;;(setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))

    (setq ivy-height 14)

    ;; Set Ivy to be used by other modes that don't pick it up by default
    (setq magit-completing-read-function 'ivy-completing-read)
    (setq projectile-completion-system 'ivy)
    :bind (:map ivy-minibuffer-map
                ;; Switch these two bindings round, as this feels more natural
                ("C-j" . ivy-done)
                ("<return>" . ivy-alt-done)
                ;; This is bound to C-w too, but I have years of using this binding with
                ;; Helm
                ("C-l" . ivy-backward-kill-word)))

  (use-package counsel
    :ensure smex
    :config
    (use-package flx
      :ensure t)

    ;; The default is to prefix the input with '^', but I dislike this behaviour
    (add-to-list 'ivy-initial-inputs-alist '(counsel-M-x . ""))
    :bind (("C-x C-r" . counsel-recentf)
           ("M-y" . counsel-yank-pop)
           ("C-x C-d" . counsel-dired-jump)
           ("C-'" . counsel-imenu)
           ("M-x" . counsel-M-x)))

  (use-package swiper
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+END_SRC

*** Visual Improvements
**** GitGutter

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :config
    (global-git-gutter-mode 1))
#+END_SRC

**** Visual Bookmarks

#+BEGIN_SRC emacs-lisp
  (use-package bm
    :ensure t
    :demand t

    :init
    ;; restore on load (even before you require bm)
    (setq bm-restore-repository-on-load t)

    :config
    ;; Allow cross-buffer 'next'
    (setq bm-cycle-all-buffers t)

    ;; where to store persistant files
    (setq bm-repository-file (cjp-data-dir "bm-repository"))

    ;; save bookmarks
    (setq-default bm-buffer-persistence t)

    ;; Loading the repository from file when on start up.
    (add-hook' after-init-hook 'bm-repository-load)
    ;; Restoring bookmarks when on file find.
    (add-hook 'find-file-hooks 'bm-buffer-restore)

    ;; Saving bookmarks
    (add-hook 'kill-buffer-hook #'bm-buffer-save)

    ;; Saving the repository to file when on exit.  kill-buffer-hook is not called
    ;; when Emacs is killed, so we must save all bookmarks first.
    (add-hook 'kill-emacs-hook #'(lambda nil
                                   (bm-buffer-save-all)
                                   (bm-repository-save)))

    ;; The `after-save-hook' is not necessary to use to achieve persistence, but
    ;; it makes the bookmark data in repository more in sync with the file state.
    (add-hook 'after-save-hook #'bm-buffer-save)

    ;; Restoring bookmarks
    (add-hook 'find-file-hooks   #'bm-buffer-restore)
    (add-hook 'after-revert-hook #'bm-buffer-restore)

    ;; The `after-revert-hook' is not necessary to use to achieve persistence, but
    ;; it makes the bookmark data in repository more in sync with the file
    ;; state. This hook might cause trouble when using packages that automatically
    ;; reverts the buffer (like vc after a check-in).  This can easily be avoided
    ;; if the package provides a hook that is called before the buffer is reverted
    ;; (like `vc-before-checkin-hook').  Then new bookmarks can be saved before
    ;; the buffer is reverted.  Make sure bookmarks is saved before check-in (and
    ;; revert-buffer)
    (add-hook 'vc-before-checkin-hook #'bm-buffer-save)

    :bind (("<f2>" . bm-next)
           ("S-<f2>" . bm-previous)
           ("C-<f2>" . bm-toggle)))
#+END_SRC

**** Highlight Indentation

Using [[https://github.com/DarthFennec/highlight-indent-guides][this package]] to show columns, highlighting indentation.

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :config
    (setq highlight-indent-guides-method 'column
          highlight-indent-guides-auto-odd-face-perc 5
          highlight-indent-guides-auto-even-face-perc 5)
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
#+END_SRC

**** Highlight Symbol

#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol)
  ;; (global-set-key [(control f3)] 'highlight-symbol-at-point)
  ;; (global-set-key [f3] 'highlight-symbol-next)
  ;; (global-set-key [(shift f3)] 'highlight-symbol-prev)
  ;; (global-set-key [(meta f3)] 'highlight-symbol-prev)))
  ;; (global-set-key [(control meta f3)] 'highlight-symbol-query-replace)
#+END_SRC

**** Uniquify

#+BEGIN_SRC emacs-lisp
  (require 'uniquify)
#+END_SRC

Instead of <2> etc. after buffer name when opening multiple files with the same name,
Change it to "name" : "directory name":

#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator ":")
#+END_SRC

**** Anzu

[[https://github.com/syohex/emacs-anzu][anzu]] provides a minor mode which displays current match and total matches information
in the mode-line in various search modes.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :config
    (global-anzu-mode t))
#+END_SRC

**** Powerline

#+BEGIN_SRC emacs-lisp
      (use-package powerline
        :ensure all-the-icons
        :config
        ;; Apply a powerline color offset to correct for the wrong colors of the powerline
        ;; separators
                                            ;(load-library "powerline-srgb-offset")
                                            ;(powerline-srgb-offset-activate "solarized-light")

        (setq powerline-default-separator 'wave)
        (defface cjp-powerline-yellow '((t (:background "#ffcc66" :foreground "#2d2d2d" :inherit mode-line)))
          "Powerline yellow face.")

        ;; Same as powerline-default-theme, but move some of the items about a bit
        (setq-default mode-line-format
                      '("%e"
                        (:eval
                         (let* ((active (powerline-selected-window-active))
                                (mode-line (if active 'mode-line 'mode-line-inactive))
                                (face1 (if active 'powerline-active1 'powerline-inactive1))
                                (face2 (if active 'powerline-active2 'powerline-inactive2))
                                (face-yellow (if active 'cjp-powerline-yellow 'powerline-inactive1))
                                (separator-left (intern (format "powerline-%s-%s"
                                                                (powerline-current-separator)
                                                                (car powerline-default-separator-dir))))
                                (separator-right (intern (format "powerline-%s-%s"
                                                                 (powerline-current-separator)
                                                                 (cdr powerline-default-separator-dir))))
                                (height (when macosxp 20))
                                (lhs (list (powerline-raw "%*" face-yellow 'l)
                                           (let ((branch (mapconcat 'concat (cdr (split-string (or vc-mode " ") "[:-]")) "-")))
                                             (powerline-raw (concat "[" (projectile-project-name)
                                                                    (when (> (length branch) 0)
                                                                      (concat "|" branch))
                                                                    "]") face-yellow 'l))
                                           (let ((host (file-remote-p default-directory 'host)))
                                             (when host
                                               (powerline-raw (concat "(" host ")") face-yellow 'l)))
                                           (powerline-buffer-id face-yellow 'l)
                                           (powerline-raw " " face-yellow)
                                           (funcall separator-left face-yellow face1 height)
                                           (when (boundp 'erc-modified-channels-object)
                                             (powerline-raw erc-modified-channels-object face1 'l))
                                           (powerline-major-mode face1 'l)
                                           (powerline-process face1)
                                            ;(powerline-minor-modes face1 'l)
                                           (powerline-narrow face1 'l)
                                           (powerline-raw " " face1)
                                           (funcall separator-left face1 face2 height)
                                           (when (and (boundp 'which-function-mode) which-function-mode)
                                             (powerline-raw which-func-current face2 'l))))
                                (rhs (list (powerline-raw global-mode-string face2 'r)
                                           (funcall separator-right face2 face1 height)
                                           (powerline-raw " " face1)
                                           (unless window-system
                                             (powerline-raw (char-to-string #xe0a1) face1 'l))
                                           (when powerline-display-buffer-size
                                             (powerline-buffer-size face1 'r))
                                           (when powerline-display-mule-info
                                             (powerline-raw mode-line-mule-info face1 'r))
                                           (powerline-raw "%3l:%1c" face1 'r)
                                           (funcall separator-right face1 mode-line height)
                                           (powerline-raw " ")
                                           (powerline-raw "%6p" nil 'r)
                                           (when powerline-display-hud
                                             (powerline-hud face-yellow face1)))))
                           (concat (powerline-render lhs)
                                   (powerline-fill face2 (powerline-width rhs))
                                   (powerline-render rhs)))))))
#+END_SRC

**** Beacon

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :config (beacon-mode 1))
#+END_SRC

*** General

These packages have no particular configuration; I just use them:

#+BEGIN_SRC emacs-lisp
  (use-package htmlize)

  (use-package regex-tool)
  (use-package scpaste)
  (use-package smooth-scrolling)
#+END_SRC

**** Hydra

#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

**** IMenu

#+BEGIN_SRC emacs-lisp
  (use-package imenu-anywhere
    :config
    (setq imenu-anywhere-buffer-filter-functions '(imenu-anywhere-same-project-p))
    :bind (("C-'" . ivy-imenu-anywhere)))
#+END_SRC

**** Ag

#+BEGIN_SRC emacs-lisp
  (use-package ag
    :config
    (setq ag-highlight-search t))
#+END_SRC

**** Projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish " Ⓟ"
    :config
    (projectile-global-mode)
    (setq projectile-enable-caching t)
    :bind (("s-g" . cjp-grep-project-or-swiper-buffer)
           ("s-p" . counsel-projectile-switch-project)
           ("s-g" . cjp-grep-project-or-swiper-buffer)
           ("s-f" . counsel-projectile-find-file)))

  (use-package counsel-projectile
    :config
    (counsel-projectile-mode)
    (setq projectile-switch-project-action #'counsel-projectile-find-file))
#+END_SRC

**** Pandoc mode

#+BEGIN_SRC emacs-lisp
  (use-package pandoc)
#+END_SRC

**** Smart Shift

#+BEGIN_SRC emacs-lisp
  (use-package smart-shift
    :config (global-smart-shift-mode 1))
#+END_SRC

**** Iedit

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :config
    (set-face-attribute 'iedit-occurrence nil :background "#ffcc66" :foreground "#2d2d2d")
    :bind
    (("C-;" . iedit-mode)
     :map isearch-mode-map
     ("C-;" . iedit-mode)
     :map iedit-mode-keymap
     ("M-n" . iedit-next-occurrence)
     ("M-p" . iedit-prev-occurrence)))
#+END_SRC

**** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind
    (("C-M-?" . mc/edit-lines)
     ("C-<" . mc/mark-previous-like-this)
     ("C->" . mc/mark-next-like-this)
     ("C-M-<" . mc/mark-all-like-this)
     ("C-M->" . mc/mark-all-like-this)))
#+END_SRC

**** Expand Region

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind
    (("C-=" . er/expand-region)
     ("C-+" . er/expand-region)
     ("M-+" . er/expand-region)))
#+END_SRC

**** Aspell

Found from http://www.emacswiki.org/emacs/CocoAspell:

#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "aspell"
        ispell-dictionary "english"
        ispell-dictionary-alist
        (let ((default '("[A-Za-z]" "[^A-Za-z]" "[']" nil
                         ("-B" "-d" "english" "--dict-dir"
                          "/Library/Application Support/cocoAspell/aspell6-en-6.0-0")
                         nil iso-8859-1)))
          `((nil ,@default)
            ("english" ,@default))))
#+END_SRC

Save personal dictionary in emacs structure:

#+BEGIN_SRC emacs-lisp
  (setq ispell-personal-dictionary
        (cjp-emacs-structure-dir ".aspell-personal-dictionary"))
#+END_SRC

Spell word at point (Usually M-$):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-s") 'ispell-word)
#+END_SRC

**** ElDoc

#+BEGIN_SRC emacs-lisp
  (use-package c-eldoc)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (mapc (lambda (x) (add-hook x 'turn-on-eldoc-mode))
        '(python-mode-hook
          inferior-python-mode
          emacs-lisp-mode-hook
          scheme-mode-hook
          inferior-scheme-mode-hook
          geiser-repl-mode-hook
          lisp-mode-hook
          slime-mode-hook
          slime-repl-mode-hook
          lisp-interaction-mode-hook
          c-mode-hook))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq c-eldoc-includes "-I./ -I../ -I/usr/include/ -I/usr/local/include/ ")
#+END_SRC

**** Yasnippet

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1))
#+END_SRC

Store my personal snippets in ~/emacs/snippets, still load the stock ones:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'yas/root-directory (cjp-emacs-structure-dir "contributed" "snippets"))
  (add-to-list 'yas/root-directory (cjp-emacs-structure-dir "personal" "snippets"))
#+END_SRC

Load snippets from all directories:

#+BEGIN_SRC emacs-lisp
  ;(mapc 'yas/load-directory yas/root-directory)
#+END_SRC

If there are multiple snippets to choose from, use ido by default in minibuffer:

#+BEGIN_SRC emacs-lisp
  (setq yas-prompt-functions '(yas/ido-prompt
                               yas/dropdown-prompt
                               yas/x-prompt
                               yas/completing-prompt
                               yas/no-prompt))
#+END_SRC

Yasnippet doesn't play well with ansi-term:

#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook (lambda() (yas-minor-mode -1)))
#+END_SRC

**** Recent files

From http://www.masteringemacs.org/articles/2011/01/27/
find-files-faster-recent-files-package

#+BEGIN_SRC emacs-lisp
  (require 'recentf)
#+END_SRC

Tramp mode messes this up, causing Emacs to IO block for a short time. (From
http://www.emacswiki.org/emacs/RecentFiles):

#+BEGIN_SRC emacs-lisp
  (setq recentf-auto-cleanup 'never)
#+END_SRC

50 files ought to be enough:

#+BEGIN_SRC emacs-lisp
  (setq ;; default is ~/.recentf
   recentf-save-file (cjp-emacs-structure-dir ".recentf")
   recentf-max-saved-items 1024
   recentf-exclude '("\.recentf" "\.ido\.last" "\.aux" "~$"))
#+END_SRC

Enable recent files mode:

#+BEGIN_SRC emacs-lisp
  (recentf-mode t)
#+END_SRC

**** Undo-tree

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode 1)
    :bind
    (("C-/" . undo-tree-undo)
     ("M-/" . undo-tree-redo)
     ("C-M-/" . undo-tree-visualize)
     ("C-x o" . other-window)

     ;; Easier bindings than shift-left etc. (nearer home row). "C-x u" binding had to be
     ;; undefined before it could be made to run windmove-left
     :map undo-tree-map
     ("C-x u" . nil)))
#+END_SRC

**** CUA

Turn on for rectangle mode only:

#+BEGIN_SRC emacs-lisp
  (setq cua-enable-cua-keys nil)
  (setq cua-rectangle-mark-key (kbd "<C-M-return>"))
  (cua-mode 1)
#+END_SRC

**** Dictionary

#+BEGIN_SRC emacs-lisp
  (use-package dictionary
    :config
    (autoload 'dictionary-search "dictionary"
      "Ask for a word and search it in all dictionaries" t)
    (autoload 'dictionary-match-words "dictionary"
      "Ask for a word and search all matching words in the dictionaries" t)
    (autoload 'dictionary-lookup-definition "dictionary"
      "Unconditionally lookup the word at point." t)
    (autoload 'dictionary "dictionary"
      "Create a new dictionary buffer" t)

    (setq dictionary-default-strategy "re"
          dictionary-use-single-buffer t)
    :bind
    (("C-c s" . dictionary-lookup-definition)
     ("C-c S" . dictionary-search)
     ("C-c m" . dictionary-match-words)
     ("M-S" . dictionary-lookup-definition)))
#+END_SRC
**** Flymake

Show error messages in minibuffer, not as a GUI menu:

#+BEGIN_SRC emacs-lisp
  (use-package flymake-cursor)
#+END_SRC

Use pyflakes with flymake:

#+BEGIN_SRC emacs-lisp
  (when (load "flymake" t)
    (defun flymake-pyflakes-init ()
      (let* ((temp-file (flymake-init-create-temp-buffer-copy
                         'flymake-create-temp-inplace))
             (local-file (file-relative-name
                          temp-file
                          (file-name-directory buffer-file-name))))
        (list "pyflakes" (list local-file))))

    (add-to-list 'flymake-allowed-file-name-masks
                 '("\\.py\\'" flymake-pyflakes-init)))
#+END_SRC

**** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :diminish " Ⓕ"
    :config
    (global-flycheck-mode)
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (setq flycheck-display-errors-delay 0.2))
#+END_SRC

**** Edit Server

(Editing from Google Chrome.) Chrome extension `Edit with Emacs` supplies edit-server.el,
which has to be loaded for Emacs to get the content from Chrome.

Further details: http://www.emacswiki.org/emacs/Edit_with_Emacs.

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (use-package edit-server
      :config
      (setq edit-server-new-frame nil)
      (edit-server-start)

      ;; Use markdown mode, but still use C-c C-c to send back to Chrome
      (add-hook 'edit-server-start-hook
                (lambda ()
                  (markdown-mode)
                  (local-set-key (kbd "C-c C-c") 'edit-server-done)))))
#+END_SRC

**** DocView

When viewing pdf (for example), have it auto-revert. Useful if viewing a LaTeX document
with AUCTeX:

#+BEGIN_SRC emacs-lisp
  (add-hook 'doc-view-mode-hook 'auto-revert-mode)
#+END_SRC

Higher quality PDFs please:

#+BEGIN_SRC emacs-lisp
  (setq doc-view-resolution 300)
#+END_SRC

**** Bookmarks

#+BEGIN_SRC emacs-lisp
  (use-package bookmark+)
#+END_SRC

Choose a location of bookmarks file. Save bookmarks file every time I put a new bookmark
in the file (not just when Emacs quits):

#+BEGIN_SRC emacs-lisp
  (setq bookmark-default-file (cjp-emacs-structure-dir "bookmarks")
        bookmark-save-flag 1
        bmkp-bmenu-state-file (cjp-emacs-structure-dir ".emacs-bmk-bmenu-state.el")
        bmkp-bmenu-commands-file
        (cjp-emacs-structure-dir ".emacs-bmk-bmenu-commands.el"))
#+END_SRC

**** Company mode

#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (global-company-mode)
    :bind (:map company-active-map
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous)
                ("C-w" . backward-kill-word)))

  (use-package company-quickhelp
    :init
    (use-package pos-tip)
    :config
    (company-quickhelp-mode 1)
    (setq company-quickhelp-delay 0))
#+END_SRC

**** Auto-complete

     Disable for now, to use Company mode instead.

#+BEGIN_SRC
  (use-package auto-complete
    :config
    (require 'auto-complete-config)

    (setq ac-comphist-file (cjp-emacs-structure-dir ".ac-comphist.dat")
          ac-fuzzy-enable t)

    (add-to-list 'ac-dictionary-directories
                 (cjp-emacs-structure-dir "auto-complete/dict" "lisp"))
    (ac-config-default))
#+END_SRC

** Development
*** Lisp Family
**** Common Lisp

***** Slime

#+BEGIN_SRC emacs-lisp
  (use-package slime
    :config
    (setq inferior-lisp-program "/usr/local/bin/sbcl")
    ;;(slime-setup '(slime-fancy))
    ;; Auto-complete
    (add-hook 'slime-mode-hook 'set-up-slime-ac)
    (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
    (eval-after-load "auto-complete"
      '(add-to-list 'ac-modes 'slime-repl-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ac-slime)
#+END_SRC

***** Redshank

#+BEGIN_SRC emacs-lisp
  (use-package redshank
    :init
    (use-package paredit)
    :config
    (require 'redshank-loader)
    (eval-after-load "redshank-loader"
      `(redshank-setup '(lisp-mode-hook
                         slime-repl-mode-hook) t)))
#+END_SRC
**** Clojure

#+BEGIN_SRC emacs-lisp
  (use-package cider)
  (use-package clojure-mode)
#+END_SRC

**** Scheme

#+BEGIN_SRC emacs-lisp
  (use-package geiser)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (require 'quack)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq cjp-scheme-program "mit-scheme")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq scheme-program-name cjp-scheme-program)
#+END_SRC

Geiser is a minor mode built on scheme-mode, supporting racket (PLT-Scheme) and
guile. (See info doc.).

#+BEGIN_SRC emacs-lisp
  ;; (setq load-path (append (list (cjp-emacs-structure-dir "geiser/build/elisp"
  ;;                                                       "lisp"))
  ;;                        load-path))
  ;; (require 'geiser-install)
  ;; (setq geiser-active-implementations '(racket)
  ;;       geiser-repl-history-filename (cjp-emacs-structure-dir ".geiser-history")
  ;;       geiser-repl-autodoc-p nil
  ;;       geiser-mode-autodoc-p nil)
#+END_SRC

Shamelessly stolen from info-look.el, scheme-mode:

#+BEGIN_SRC emacs-lisp
  ;; (info-lookup-maybe-add-help
  ;;  :mode 'geiser-repl-mode
  ;;  :regexp "[^()`',\" \t\n]+"
  ;;  :ignore-case t
  ;;  ;; Aubrey Jaffer's rendition from <URL:ftp://ftp-swiss.ai.mit.edu/pub/scm>
  ;;  :doc-spec '(("(r5rs)Index" nil
  ;;               "^[ \t]+-+ [^:]+:[ \t]*" "\\b")))
#+END_SRC

***** Quack

#+BEGIN_SRC emacs-lisp
  (setq quack-default-program cjp-scheme-program
        quack-run-scheme-always-prompts-p nil)
#+END_SRC

http://synthcode.com/wiki/scheme-complete:

#+BEGIN_SRC emacs-lisp
  (autoload 'scheme-smart-complete "scheme-complete" nil t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (autoload 'scheme-get-current-symbol-info "scheme-complete" nil t)
  (add-hook 'scheme-mode-hook
            (lambda ()
              (make-local-variable 'eldoc-documentation-function)
              (setq eldoc-documentation-function 'scheme-get-current-symbol-info)))
#+END_SRC
**** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav)
  (use-package litable)
  (use-package paredit)
#+END_SRC

***** IELM

[[https://www.emacswiki.org/emacs/InferiorEmacsLispMode][Inferior Emacs Lisp Mode]]. Start ielm with AC, ElDoc, and paredit. Make it inherit local
variables from the buffer it was invoked from:

#+BEGIN_SRC emacs-lisp
  (defvar ielm-invoked-from-buffer nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'ielm-mode-hook
            (lambda ()
              (setq ac-sources '(ac-source-functions
                                 ac-source-variables
                                 ac-source-features
                                 ac-source-symbols
                                 ac-source-words-in-same-mode-buffers))
              (add-to-list 'ac-modes 'inferior-emacs-lisp-mode)
              (auto-complete-mode 1)
              (eldoc-mode 1)
              (paredit-mode 1)
              (ielm-change-working-buffer ielm-invoked-from-buffer)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defadvice ielm (before change-working-buffer activate)
    (setq ielm-invoked-from-buffer (current-buffer)))
#+END_SRC
**** General
***** Pretty Lambda

Turn 'lambda' into the Greek letter:

#+BEGIN_SRC emacs-lisp
  (use-package pretty-lambdada
    :config
    ;; (setq cjp-lispy-modes '(lisp-mode-hook paredit-mode-hook))
    ;; (mapc (lambda (x) (add-hook x 'pretty-lambda)) cjp-lispy-modes)
    (add-hook 'lisp-interaction-mode-hook 'pretty-lambda)
    (add-hook 'emacs-lisp-mode-hook 'pretty-lambda)
    (add-hook 'lisp-mode-hook 'pretty-lambda)
    (add-hook 'slime-mode-hook 'pretty-lambda)
    (add-hook 'slime-mode-hook 'pretty-lambda)
    (add-hook 'slime-repl-mode-hook 'pretty-lambda)
    (add-hook 'scheme-mode-hook 'pretty-lambda)
    (add-hook 'inferior-scheme-mode-hook 'pretty-lambda))
#+END_SRC

***** Paredit

Taken from http://www.emacswiki.org/emacs/ParEdit:

#+BEGIN_SRC emacs-lisp
  (autoload 'paredit-mode "paredit"
    "Minor mode for pseudo-structurally editing Lisp code." t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook       (lambda () (paredit-mode +1)))
  (add-hook 'lisp-mode-hook             (lambda () (paredit-mode +1)))
  (add-hook 'lisp-interaction-mode-hook (lambda () (paredit-mode +1)))
  (add-hook 'scheme-mode-hook           (lambda () (paredit-mode +1)))
  (add-hook 'geiser-repl-mode-hook      (lambda () (paredit-mode +1)))
  (add-hook 'inferior-scheme-mode-hook  (lambda () (paredit-mode +1)))
  (add-hook 'slime-mode-hook            (lambda () (paredit-mode +1)))
  (add-hook 'slime-repl-mode-hook       (lambda () (paredit-mode +1)))
#+END_SRC

Use C-w to backwards kill words, consistent with global custom settings. Also undefine
C-left and C-right, to use these with winner mode:

#+BEGIN_SRC emacs-lisp
  (add-hook 'paredit-mode-hook
            (lambda ()
              (local-set-key (kbd "C-w") 'paredit-backward-kill-word)
              (define-key paredit-mode-map (kbd "C-<left>") nil)
              (define-key paredit-mode-map (kbd "C-<right>") nil)))
#+END_SRC

Stop SLIME's REPL from grabbing DEL, which is annoying when backspacing over a '(':

#+BEGIN_SRC emacs-lisp
  (defun override-slime-repl-bindings-with-paredit ()
    (define-key slime-repl-mode-map
      (read-kbd-macro paredit-backward-delete-key) nil))
  (add-hook 'slime-repl-mode-hook 'override-slime-repl-bindings-with-paredit)
#+END_SRC

*** Python

Using python.el, not python-mode.el. The latter doesn't seem to be able to send the
contents of a buffer to the interpreter easily, as python.el can (with C-c C-c).

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode
    (("\\.py\\'" . python-mode)
     ("\\.pyx\\'" . python-mode))
    :interpreter ("python" . python-mode)
    :bind
    (:map python-mode-map
          ("<s-tab>" . elpy-company-backend)))
#+END_SRC

Use these extras, too:

#+BEGIN_SRC emacs-lisp
  (use-package pydoc-info)
  (use-package python-info)
  (use-package pyvenv)
#+END_SRC

Turn on auto-complete in python shells:

#+BEGIN_SRC emacs-lisp
  (add-hook 'inferior-python-mode-hook (lambda () (auto-complete-mode 1)))
#+END_SRC

Check files for pep8 mistakes:

#+BEGIN_SRC emacs-lisp
  (autoload 'python-pep8 "python-pep8")
  (autoload 'pep8 "python-pep8")
#+END_SRC

displays "\" at the end of lines that wrap:

#+BEGIN_SRC emacs-lisp
  (setq longlines-show-hard-newlines t)
#+END_SRC

**** Ein

[[https://github.com/tkf/emacs-ipython-notebook][Emacs IPython Notebook]].

#+BEGIN_SRC emacs-lisp
  (use-package ein
    :config
    (setq ein:use-auto-complete t))
#+END_SRC

Or, to enable "superpack" (a little bit hacky improvements):

#+BEGIN_SRC emacs-lisp
  ;; (setq ein:use-auto-complete-superpack t)
#+END_SRC

**** elpy

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :config
    ;; `highlight-indentation' conflicts with `highlight-indent-guides'. Disable the former
    ;; and the latter still works.
    (delete 'elpy-module-highlight-indentation elpy-modules)
    ;; I use these keys to scroll the buffer up and down by one line
    (define-key elpy-mode-map (kbd "<C-up>") nil)
    (define-key elpy-mode-map (kbd "<C-down>") nil)
    (elpy-enable)
    (when (executable-find "ipython")
      (elpy-use-ipython)))
#+END_SRC

*** Swift

#+BEGIN_SRC emacs-lisp
  (use-package swift-mode)
#+END_SRC
*** C
*** JavaScript

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode ("\\.js$"
           "\\.json$")
    :config
    (setq js2-basic-offset 2))
#+END_SRC

  * Go

#+BEGIN_SRC emacs-lisp
  (use-package go-mode)

  (use-package go-eldoc)

  (use-package go-autocomplete)
#+END_SRC

*** Ruby
*** Java
**** javadoc

#+BEGIN_SRC emacs-lisp
  ;; (require 'javadoc-help)

  ;; (add-hook 'java-mode-hook (lambda ()
  ;;                            (local-set-key (kbd "C-h C-h") 'javadoc-lookup)
  ;;                            (local-set-key (kbd "C-S-h C-S-h") 'javadoc-help)))
#+END_SRC

** Discrete Modes
*** Web Mode

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode ("\\.html?\\'" "\\.phtml\\'" "\\.tpl\\.php\\'" "\\.[agj]sp\\'"
           "\\.as[cp]x\\'" "\\.erb\\'" "\\.mustache\\'" "\\.djhtml\\'"))
#+END_SRC

*** Ediff

Have diffs show character differences:

#+BEGIN_SRC emacs-lisp
  (setq-default ediff-forward-word-function 'forward-char)
  (setq ediff-split-window-function (if (> (frame-width) 160)
                                        'split-window-horizontally
                                      'split-window-vertically))
#+END_SRC

*** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode)
#+END_SRC

*** Yaml

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode (("\\.yaml\\'" . yaml-mode)
           ("\\.yml\\'" . yaml-mode)))
#+END_SRC

*** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :config
    (setq groovy-indent-offset 2))
#+END_SRC

*** Visual Regexp

#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :bind
    (("C-c r" . vr/replace)
     ("C-c q" . vr/query-replace)))
#+END_SRC

*** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config
    (setq magit-omit-untracked-dir-contents t
          magit-last-seen-setup-instructions "1.4.0"
          git-commit-summary-max-length 50
          git-commit-fill-column 80
          auto-revert-check-vc-info t)
    :bind
    (("C-M-g" . magit-status)
     ("s-l" . magit-log-buffer-file)
     ("s-b" . magit-blame)))
#+END_SRC

*** Ibuffer

Use ibuffer for my buffer menu (C-x C-b):

#+BEGIN_SRC emacs-lisp
  (defalias 'list-buffers 'ibuffer)
#+END_SRC

ibuffer defaults to opening files with ibuffer-find-file; I prefer ido:

#+BEGIN_SRC emacs-lisp
  (add-hook 'ibuffer-load-hook (lambda ()
                                 (define-key ibuffer-mode-map
                                   (kbd "C-x C-f") 'ido-find-file)))
#+END_SRC

`* !' is what dired uses to clear all marks:

#+BEGIN_SRC emacs-lisp
  (add-hook 'ibuffer-load-hook (lambda ()
                                 (define-key ibuffer-mode-map
                                   (kbd "* !") 'ibuffer-unmark-all)))
#+END_SRC

*** AUCTeX

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex
    :config
    ;; These allow AUCTeX to parse TeX files automatically. Creates 'auto' directory with
    ;; parse info for each TeX file, got annoying so disabled for now.

    ;; (setq TeX-auto-save t)

    (setq ;; Use pdflatex as default mode in AuCTEX, always
          TeX-parse-self t
          ;; TeX-electric-sub-and-superscript nil
          TeX-PDF-mode t)

    ;; Enable math mode and auto-fill when typing LaTeX, and RefTeX:
    (add-hook 'LaTeX-mode-hook 'turn-on-auto-fill)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (add-hook 'LaTeX-mode-hook (lambda () (TeX-source-correlate-mode 1)))

    ;; Use tex parser so that TeX commands aren't checked:
    (add-hook 'LaTeX-mode-hook (lambda () (setq ispell-parser 'tex)))
    (setq TeX-source-correlate-method 'synctex)
    (setq ;; Setup RefTeX with AUCTeX automatically
     reftex-plug-into-AUCTeX t
     ;; Use `-', not `:'
     reftex-section-prefixes '((0 . "part-")
                               (1 . "cha-")
                               (t . "sec-"))
     ;; Change citation format to natbib (\citet format)
     reftex-cite-format "\\citet[][]{%l}")
    ;; Highlight keywords from the natbib package:
    (setq font-latex-match-reference-keywords
          '(("citet" "[{")))
    ;; Have AUCTeX ask which is master file for multi-document TeX:
    (setq-default TeX-master nil))

  (use-package reftex)
#+END_SRC

*** Org

#+BEGIN_SRC emacs-lisp
  (use-package org-plus-contrib
    :pin org
    :mode ("\\.org\\'" . org-mode)
    :config

    ;; Enable the extra backends. Required to run before org is required
    (setq org-export-backends '(beamer man md odt org texinfo ascii html icalendar latex))

    ;; Use better defaults when opening files
    (eval-after-load "org" '(setq org-file-apps (if macosxp
                                                    org-file-apps-defaults-macosx
                                                  org-file-apps-defaults-gnu)))

    (setq org-attach-directory (expand-file-name "~/Support/Attachments/"))

    (defun cjp-org-attach-sync ()
      (interactive) (save-excursion
                      (goto-char (point-min))
                      (org-attach-sync)))
    :bind
    (("C-c l" . org-store-link)
     ("C-c c" . org-capture)
     ("C-c a" . org-agenda)
     ("C-c b" . org-iswitchb)

     ;; Make using attachments easier
     ("C-s-o" . org-attach-open)
     ("C-s-d" . org-attach-reveal-in-emacs)
     ("C-s-z" . cjp-org-attach-sync)

     :map org-mode-map
     ("C-c C-'" . org-edit-special)
     ("C-'" . ivy-imenu-anywhere)
     ("M-h" . ns-do-hide-emacs)

     ;; Unbind `C-,' to prevent it overriding the global value of `helm-filtered-bookmarks'
     ("C-," . nil)
     :map org-src-mode-map
     ("C-c C-'" . org-edit-src-exit)))

  (use-package org
    :ensure org-plus-contrib
    :pin org
    :diminish ('org-src . " Ⓞ"))

  (use-package ox-reveal)

  (use-package org-bullets
    :ensure t
    :init
    (setq org-bullets-bullet-list
          '("◉" "◎" "⚫" "○" "►" "◇"))
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

**** Org GTD

My custom mode and configuration for implementing GTD with org-mode.

#+BEGIN_SRC emacs-lisp
  (use-package org-gtd
      :disabled
      :pin manual
      :bind
      (("C-s-e" . gtd-export-agendas-and-calendar)
       ("C-s-e" . gtd-export-agendas-and-calendar)
       ;; Search for things using the refile interface:
       ("C-s-/" . gtd-helm-show-org-agenda-and-reference-files-headings))
      :config
      (setq org-mobile-files gtd-agenda-and-reference-files))
#+END_SRC

**** MobileOrg

#+BEGIN_SRC emacs-lisp
  (setq org-mobile-inbox-for-pull org-default-notes-file
        org-mobile-directory "~/Dropbox/Apps/MobileOrg"
        org-mobile-force-id-on-agenda-items nil)
#+END_SRC

**** Capture templates

#+BEGIN_SRC emacs-lisp
;  (add-to-list 'org-capture-templates
;               '("b" "PBC Entry" entry (file+headline "" "Inbox") "* PBC: %?"))
#+END_SRC

A ton of keybindings. Not really worth joining with the rest of the org-mode keybindings
as I don't really use these anymore, so may remove them.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s-i") (lambda () (interactive) (org-capture nil "i")))
  (global-set-key (kbd "C-s-p") (lambda () (interactive) (org-capture nil "p")))
  (global-set-key (kbd "C-s-s") (lambda () (interactive) (org-capture nil "s")))
  (global-set-key (kbd "C-s-a") (lambda () (interactive) (org-capture nil "a")))
  (global-set-key (kbd "C-s-h") (lambda () (interactive) (org-capture nil "h")))
  (global-set-key (kbd "C-s-b") (lambda () (interactive) (org-capture nil "b")))
  (global-set-key (kbd "C-s-w") (lambda () (interactive) (org-capture nil "w")))
  (global-set-key (kbd "C-s-l") (lambda () (interactive) (org-capture nil "l")))
  (global-set-key (kbd "C-s-r") (lambda () (interactive) (org-capture nil "r")))
#+END_SRC

**** Structure templates

#+BEGIN_SRC emacs-lisp
  (setq org-structure-template-alist
        (append '(("l" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>")
                  ("L" "#+BEGIN_LaTeX\n?\n#+END_LaTeX" "<literal style=\"latex\">\n?\n</literal>"))
                org-structure-template-alist))
#+END_SRC

*** Outline

#+BEGIN_SRC emacs-lisp
  (use-package outline-magic)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'outline-minor-mode-hook
            (lambda ()
              (define-key outline-minor-mode-map (kbd "<tab>") 'outline-cycle)))
#+END_SRC

*** Info

#+BEGIN_SRC emacs-lisp
  (setq Info-default-directory-list
        (append (cjp-get-dir-structure-in "info")
                (cjp-get-dir-structure-in "packages")
                Info-default-directory-list))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq Info-directory-list Info-default-directory-list)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (info-lookup-add-help
  ;;  :mode 'lisp-mode
  ;;  :regexp "[^][()'\" \t\n]+"
  ;;  :ignore-case t
  ;;  :doc-spec '(("(ansicl)Symbol Index" nil nil nil)))

  ;; (info-lookup-maybe-add-help
  ;;  :mode 'emacs-lisp-mode
  ;;  :regexp "[^][()`',\" \t\n]+"
  ;;  :doc-spec '(("(elisp)Index"          nil "^ -+ .*: " "\\( \\|$\\)")
  ;;              ;; Commands with key sequences appear in nodes as `foo' and
  ;;              ;; those without as `M-x foo'.
  ;;              ("(emacs)Command Index"  nil "`\\(M-x[ \t\n]+\\)?" "'")
  ;;              ;; Variables normally appear in nodes as just `foo'.
  ;;              ("(emacs)Variable Index" nil "`" "'")
  ;;              ;; Almost all functions, variables, etc appear in nodes as
  ;;              ;; " -- Function: foo" etc.  A small number of aliases and
  ;;              ;; symbols appear only as `foo', and will miss out on exact
  ;;              ;; positions.  Allowing `foo' would hit too many false matches
  ;;              ;; for things that should go to Function: etc, and those latter
  ;;              ;; are much more important.  Perhaps this could change if some
  ;;              ;; sort of fallback match scheme existed.
  ;;              ))
#+END_SRC

*** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :config
    (setq markdown-command "mmd"
          ;; Use underscores for italics
          markdown-italic-underscore t
          markdown-indent-on-enter nil
          ;; Enable syntax highlighting (LaTeX)
          markdown-enable-math t
          markdown-asymmetric-header t
          markdown-list-indent-width 2
          markdown-reference-location 'end
          markdown-footnote-location 'end)
    ;; Webgen uses markdown syntax in .page files
    (add-to-list 'auto-mode-alist '("\\.page\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.mark\\'" . markdown-mode)))

  (use-package markdown-mode+)
#+END_SRC

*** Eshell

#+BEGIN_SRC emacs-lisp
  (setq eshell-directory-name (cjp-emacs-structure-dir ".eshell")
        eshell-scroll-to-bottom-on-input t)
#+END_SRC

*** Dired

#+BEGIN_SRC emacs-lisp
  (use-package dired+)
  (use-package dired-details+)
  (use-package dired-subtree)
#+END_SRC

Hide and show details (`ls -l` stuff) with '(' and ')':

#+BEGIN_SRC emacs-lisp
  (setq dired-details-hidden-string ""
        dired-details-initially-hide nil
        ;; dired-omit-mode, ignore dotfiles
        dired-omit-files (concat dired-omit-files "\\|^\\..+$"))
#+END_SRC

This is buffer-local variable:

#+BEGIN_SRC emacs-lisp
  (setq-default dired-omit-mode nil)
#+END_SRC

Make return key open files in another window, except if item at point is a directory, and
then open in the current window:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "RET") (lambda ()
                                           (interactive)
                                           (if (cjp-dired-directoryp)
                                               (dired-find-file)
                                             (dired-find-file-other-window))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defadvice dired-details-toggle (after fit-dired-frame activate)
    "Resize dired buffer (horizontally) after toggling details."
    (fix-horizontal-size-to-buffer))
#+END_SRC

Don't show '..' since '^' does this; show human file sizes:

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-Alh")
#+END_SRC

The default fonts don't look nice with Tango theme, at least to my eyes:

#+BEGIN_SRC emacs-lisp
  (setq diredp-compressed-file-suffix '((background dark)
                                        (:foreground "Red"))
        diredp-rare-priv '((background dark)
                           (:background "#FFFF00008080" :foreground "White")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "i") 'dired-subtree-insert)
#+END_SRC

*** w3m

#+BEGIN_SRC emacs-lisp
  ;; (use-package w3m)
  ;; (setq browse-url-browser-function 'w3m-browse-url
  ;;       w3m-default-save-directory "~/Documents/inbox"
  ;;       w3m-use-tab nil
  ;;       w3m-use-tab-menubar nil
  ;;       w3m-key-binding "info")
#+END_SRC

*** RFC

#+BEGIN_SRC emacs-lisp
  (use-package irfc
    :config
    (setq irfc-assoc-mode t))
#+END_SRC

*** Zencoding

#+BEGIN_SRC emacs-lisp
  (use-package zencoding-mode
    :config
    (add-hook 'sgml-mode-hook 'zencoding-mode))
#+END_SRC

*** Deft

Set up deft to work how I like it to. I prefer a slightly different
functionality to the default. If I'm already in the deft buffer, hit
the same key again to clear the text that's already been entered.

#+BEGIN_SRC emacs-lisp
  (use-package deft
    :config
    (setq deft-directory "~/Box Sync/nvAlt/"
          deft-recursive t
          deft-use-filename-as-title t
          deft-default-extension "md"
          deft-use-filter-string-for-filename t
          deft-auto-save-interval 30)
    (global-set-key (kbd "<f12>") 'cjp-deft-clear-if-in-buffer)
    (define-key deft-mode-map (kbd "<C-return>") 'deft-new-file))

  (defun cjp-deft-clear-if-in-buffer ()
    (interactive)
    (if (and (boundp 'deft-buffer)
             (equal (buffer-name) deft-buffer))
        (deft-filter-clear)
      (deft)))
#+END_SRC

*** Restclient

Don't change window focus to the output window when submitting a command:

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :config
    (eval-after-load "restclient-autoloads"
      '(add-hook 'restclient-mode-hook
                 (lambda () (local-set-key (kbd "C-c C-c")
                                      '(lambda () (interactive)
                                         (restclient-http-send-current nil t)))))))
#+END_SRC

*** Writeroom

Defaults to 80. Allow a bit more if using in conjunction with org mode, where the
document might have indented lines:

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :config
    (setq writeroom-width 100))
#+END_SRC

*** Popwin

Fix helm mode buffers at the bottom of the frame.

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :config
    (popwin-mode 1)
    (push '("^\*helm.+\*$" :regexp t :position bottom) popwin:special-display-config))
#+END_SRC

*** Persp-mode

#+BEGIN_SRC emacs-lisp
  (use-package persp-mode)
  ;; (with-eval-after-load "persp-mode-autoloads"
  ;;   ;; switch off animation of restoring window configuration
  ;;   (setq wg-morph-on nil)
  ;;   (add-hook 'after-init-hook #'(lambda () (persp-mode 1))))
#+END_SRC

*** Diminish

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :config
    (eval-after-load "auto-complete" '(diminish 'auto-complete-mode " Ⓐ"))
    (eval-after-load "abbrev" '(diminish 'abbrev-mode " Ⓐ"))
    (eval-after-load "ace-isearch" '(diminish 'ace-isearch-mode " Ⓐ"))
    (eval-after-load "anzu" '(diminish 'anzu-mode " Ⓐ"))
    (eval-after-load "autorevert" '(diminish 'auto-revert-mode " Ⓐ"))
    (eval-after-load "elpy" '(diminish 'elpy-mode " Ⓔ"))
    (eval-after-load "simple" '(diminish 'auto-fill-function " Ⓕ"))
    (eval-after-load "helm" '(diminish 'helm-mode " Ⓗ"))
    (eval-after-load "org-indent" '(diminish 'org-indent-mode " Ⓞ"))
    (eval-after-load "paredit" '(diminish 'paredit-mode " Ⓟ"))
    (eval-after-load "undo-tree" '(diminish 'undo-tree-mode " Ⓤ"))
    (eval-after-load "beacon" '(diminish 'beacon-mode)))
#+END_SRC

Alphanumeric unicode characters with circles around them are listed on
https://en.wikipedia.org/wiki/Enclosed_Alphanumerics
Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ.

** General Configuration

_Broad configuration of Emacs._

I find I hit =C-x C-j= a lot when I want to kill the region:

#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-x C-j"))
  (global-set-key (kbd "C-x C-j") 'kill-region)
#+END_SRC

Automatically revert files once they change on disk:

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode)
#+END_SRC

Recenter the buffer after moving to a line:

#+BEGIN_SRC emacs-lisp
  (advice-add 'goto-line :after (lambda (&optional arg pred) (recenter)))
#+END_SRC

Switch on =which-function-mode=:

#+BEGIN_SRC emacs-lisp
  (which-function-mode 1)
  (setq which-func-unknown "")
#+END_SRC

Open the last-used file on Emacs startup:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda () (find-file (car recentf-list))))
#+END_SRC

Activate save place mode, so files being opened again will restore point to where it was
when the file was closed.

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (setq save-place-file (cjp-data-dir "places"))

    :config
    (if (>= emacs-major-version 25)
        (save-place-mode)
      (setq-default save-place t)))
#+END_SRC

Highlight the expression between parentheses, not just the parens themselves:

#+BEGIN_SRC emacs-lisp
  (setq show-paren-style 'mixed
        show-paren-when-point-inside-paren t
        show-paren-delay 0)
#+END_SRC

Switch on Semantic mode:

#+BEGIN_SRC emacs-lisp
  (semantic-mode 1)
#+END_SRC

cperl-mode is preferred to perl-mode:

#+BEGIN_SRC emacs-lisp
  (defalias 'perl-mode 'cperl-mode)
#+END_SRC

Often I enable [[https://www.gnu.org/savannah-checkouts/gnu/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html][desktop save mode]], but it can get annoying to persist lots of buffers, so
it's disabled here for now.

#+BEGIN_SRC emacs-lisp :tangle no
  (desktop-save-mode 1)
  (add-to-list 'desktop-path (cjp-data-dir "desktop"))
#+END_SRC

Turn off the menu bar, toolbar, and scrollbar:

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+END_SRC

Save (a longer) minibuffer history:

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)
  (setq history-length 1024)
#+END_SRC

A huge number forces windows to be split vertically, like C-x 3 does:

#+BEGIN_SRC emacs-lisp
  ;; (setq split-height-threshold 900)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

Enable narrowing:

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

If using customize, save generated elisp here, not .emacs:

#+BEGIN_SRC emacs-lisp
  (setq custom-file (cjp-emacs-structure-dir ".customize.el"))
#+END_SRC

If saving a .el file in my emacs structure, automatically byte compile it.  From
stackoverflow.com/questions/154097/whats-in-your-emacs/2277001#2277001:

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'after-save-hook
  ;;           (lambda ()
  ;;             (when (string-match
  ;;                    (concat "\.emacs\.d" ".*\.el$")
  ;;                    buffer-file-name)
  ;;               (byte-compile-file buffer-file-name))))
#+END_SRC

Put auto save files here:

#+BEGIN_SRC emacs-lisp
  (setq auto-save-list-file-prefix (cjp-emacs-structure-dir ".auto-save-list/.saves-"))
#+END_SRC

Store tetris scores:

#+BEGIN_SRC emacs-lisp
  (setq tetris-score-file (cjp-emacs-structure-dir ".tetris-scores"))
#+END_SRC

Make scripts executable when saved by default (chmod +x):

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

These functions area disabled by default for new users. I want them!

#+BEGIN_SRC emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+END_SRC

Mode to use for the initial scratch buffer:

#+BEGIN_SRC emacs-lisp
  ;; (setq-default initial-major-mode 'python-mode)
#+END_SRC

Word moving commands move point between CamelCaseWords
FIXME: causes ERC issue --- http://osdir.com/ml/bug-gnu-emacs-gnu/2014-05/msg00914.html:

#+BEGIN_SRC emacs-lisp
  ;; (global-subword-mode 1)
#+END_SRC

In Emacs 24.3.50+ (from git), modeline lists "," - stop this:

#+BEGIN_SRC emacs-lisp
  (let ((entry (assq 'subword-mode minor-mode-alist)))
    (when entry (setcdr entry '(nil))))
#+END_SRC

Don't always ask if I want to make a new file or buffer, just do it:

#+BEGIN_SRC emacs-lisp
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

I use this function a lot so create a shortcut. M-x bc invokes it:

#+BEGIN_SRC emacs-lisp
  (defalias 'bc 'emacs-lisp-byte-compile)
#+END_SRC

Auto-fill mode is useful in text mode:

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

Remove the "This buffer is for notes" text that shows at the top of the scratch buffer
when Emacs loads:

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

Store all backup files in one folder, not all over filesystem:

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist (list (cons "." (cjp-emacs-structure-dir "backup/")))
        ;; Use version numbers for backups
        version-control t
        ;; Number of newest versions to keep
        kept-new-versions 2
        ;; Number of oldest versions to keep
        kept-old-versions 2
        ;; Ask to delete excess backup versions?
        delete-old-versions t
        ;; Copy linked files, don't rename
        backup-by-copying-when-linked t)
#+END_SRC

Store all autosave files in one folder, not all over filesystem:

#+BEGIN_SRC emacs-lisp
  (let ((save-dir (cjp-emacs-structure-dir "autosaves/")))
    (when (not (file-exists-p save-dir)) (make-directory save-dir t))
    (add-to-list 'auto-save-file-name-transforms
                 `(".*" ,save-dir t) t))
#+END_SRC

From [[http://emacs-fu.blogspot.com/2008/12/highlighting-todo-fixme-and-friends.html][emacs-fu]]. Highlights comments like /* FIXME: do something */ in C-like (C, C++,
Obj-C, etc.) languages:

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook
            (lambda ()
              (font-lock-add-keywords nil
                                      '(("\\<\\(FIXME\\|TODO\\|BUG\\):"
                                         1 font-lock-warning-face t)))))
#+END_SRC

Move mouse to top-right corner once it gets too close to cursor.  Move back once mouse
moved away:

#+BEGIN_SRC emacs-lisp
  (mouse-avoidance-mode 'exile)
#+END_SRC

Forces lines longer than buffer width to overlap in a nice way. I don't think I'm too
keen on it, so turned it off for the time being:

#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 0)
#+END_SRC

Use nxml-mode for XML files:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.xml\\'" . nxml-mode))
#+END_SRC

Modifies kill line and copy line (C-x C-k and M-w) in place. If something is selected,
copy/cut as usual. If nothing is selected, copy/cut the current line:

#+BEGIN_SRC emacs-lisp
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single
        line instead."
    (interactive
     (if mark-active
         (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position) (line-beginning-position 2)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))
#+END_SRC

Replace yes/no by y/n:

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Because I know where to find the help file:

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

Require C-x C-c prompt. I've closed too often by accident:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-c")
                  (lambda () (interactive)
                    (cond ((y-or-n-p "Quit? ")
                           (save-buffers-kill-emacs)))))
#+END_SRC

Always flash for parens:

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

Set mode of buffer automatically based on filename or other indications (see
set-auto-mode documentation), so can quickly make a temp. buffer (like *Scratch*) called
'test.txt' to make it open in text-mode, or 'test.js' for javascript-mode, etc:

#+BEGIN_SRC emacs-lisp
  (setq default-major-mode (lambda ()
                             (let ((buffer-file-name (or buffer-file-name (buffer-name))))
                               (set-auto-mode))))
#+END_SRC

Open new buffers (without files or filename extensions) in org-mode:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("" . org-mode) t)
#+END_SRC

Open log files in text mode, for now:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.log\\'" . text-mode))
#+END_SRC

Keep ispell word as M-s even when editing git commit logs:

#+BEGIN_SRC emacs-lisp
  (add-hook 'log-edit-mode-hook
            (lambda () (define-key log-edit-mode-map (kbd "M-s") 'ispell-word)))
#+END_SRC

I like this mode; seems to be on by default under emacs-snapshot on GNU/Linux systems:

#+BEGIN_SRC emacs-lisp
  (transient-mark-mode 1)
#+END_SRC

Make the compilation window appear smallish (not half of frame as default):

#+BEGIN_SRC emacs-lisp
  (setq compilation-window-height 10)
#+END_SRC

Set default path to my inbox:

#+BEGIN_SRC emacs-lisp
  ;; (setq default-directory "~/Documents/Inbox/")
#+END_SRC

True by default in Carbon Emacs. Set here for Aquamacs and other distros:

#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard t)
#+END_SRC

Mute annoying beep:

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Stop cursor from blinking:

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC

Let emacsclient send stuff to existing Emacs process:

#+BEGIN_SRC emacs-lisp
  (use-package server
    :config
    (when (display-graphic-p)
      (or (server-running-p)
          (server-start))))
#+END_SRC

Don't use tabs:

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Set auto-fill-mode to fill to column 89 (ideal for a 90 char width):

#+BEGIN_SRC emacs-lisp
  (setq default-fill-column 89)
#+END_SRC

Set tab key to two spaces:

#+BEGIN_SRC emacs-lisp
  (setq c-basic-offset 2)
#+END_SRC

Tab binary character in files interpreted as mod-4:

#+BEGIN_SRC emacs-lisp
  (setq tab-width 2)
#+END_SRC

My prefered code indentation style:

#+BEGIN_SRC emacs-lisp
  (setq c-set-style "k&r")
#+END_SRC

When double-clicking a file to open in Emacs, make sure it opens in a new window in the
current frame; the default (nil) causes Emacs to create a new frame:

#+BEGIN_SRC emacs-lisp
  (setq display-buffer-reuse-frames t)
#+END_SRC

When lines wrap, `next-line' drops to the next real line, not the next
visual line:

#+BEGIN_SRC emacs-lisp
  (setq line-move-visual t)
#+END_SRC

From [[http://masteringemacs.org/articles/2011/10/02/improving-performance-emacs-display-engine][masteringemacs]]:

#+BEGIN_SRC emacs-lisp
  (setq redisplay-dont-pause t)
#+END_SRC

If I open a symlink file that is backed by a VC'd regular file, don't ask me if I want to
follow the link, just do it:

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

Use hl-line mode everywhere:

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
  (setq global-hl-line-sticky-flag t)
#+END_SRC

Fix scrolling when using the mouse wheel or trackpad:

#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-progressive-speed nil
        mouse-wheel-scroll-amount '(2 ((shift) . 5))
        scroll-conservatively 101)
#+END_SRC

Usually suspend-frame. Annoying:

#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-z"))
#+END_SRC

When running commands like =query-replace=, always keep a few lines of context when the
current match is at the bottom of the screen. Thanks to [[https://emacs.stackexchange.com/questions/10898/query-replace-leaves-potential-match-to-be-replaced-at-bottom-of-window/10903#10903][this answer on Stack Exchange]]:

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 5)
#+END_SRC

Save item in clipboard to the kill ring before killing:

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC

*** Tramp

Use SSH in TRAMP by default:

#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh")
#+END_SRC

Don't make backup files when using TRAMP:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'backup-directory-alist
               (cons tramp-file-name-regexp nil))
#+END_SRC

Store information here (not default ~/.emacs.d/tramp):

#+BEGIN_SRC emacs-lisp
  (setq tramp-persistency-file-name (cjp-emacs-structure-dir ".tramp"))
#+END_SRC
*** Comint

Add current directory to mode line of shell windows:

#+BEGIN_SRC emacs-lisp
  ;; (defun add-mode-line-dirtrack ()
  ;;  (add-to-list 'mode-line-buffer-identification
  ;;               '(:propertize (" " default-directory " ") face dired-directory)))
  ;; (add-hook 'shell-mode-hook 'add-mode-line-dirtrack)
#+END_SRC

Make sure passwords not echoed in shell:

#+BEGIN_SRC emacs-lisp
  (add-hook 'comint-output-filter-functions
            'comint-watch-for-password-prompt)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'comint-mode-hook
            (lambda ()
              (define-key comint-mode-map (kbd "<up>") 'comint-previous-input)
              (define-key comint-mode-map (kbd "<down>") 'comint-next-input)))
#+END_SRC

*** Calendar and Diary

#+BEGIN_SRC emacs-lisp
  (setq ;; Choose my custom diary file
   diary-file (cjp-emacs-structure-dir "diary")
   ;; Start Calendar on Monday
   calendar-week-start-day 1
   ;; European date format (DD/MM/YYYY)
   european-calendar-style 't)
#+END_SRC

*** Abbrev

Operate on startup:

#+BEGIN_SRC emacs-lisp
  (setq-default abbrev-mode t)
#+END_SRC

Save in specified file:

#+BEGIN_SRC emacs-lisp
  (setq abbrev-file-name (cjp-emacs-structure-dir ".abbrev_defs")
        ;; Save abbrevs when files are saved
        save-abbrevs t
        ;; Recognise understores too
        dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
#+END_SRC

*** Unicode

#+BEGIN_SRC emacs-lisp
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+END_SRC
* Custom Keybindings

General, Mac, and Linux keybindings.

** General

Trying to use =pop-global-mark= more often. Usually bound to =C-x C-SPC=, but that
doesn't seem very comfortable:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-\\") 'pop-global-mark)
#+END_SRC

Swap these round from usual; I find it more logical:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x +") 'what-cursor-position)
  (global-set-key (kbd "C-x =") 'balance-windows)
#+END_SRC

Sets current frame or window to width of 80 characters:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x W") 'fix-horizontal-size)
#+END_SRC

TODO: remove this --- don't think I ever use it:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
  (global-set-key (kbd "C-c C-c C-x C-m") 'execute-extended-command)
#+END_SRC

Make scrolling easy:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<up>") '(lambda () (interactive) (scroll-down 1)))
  (global-set-key (kbd "C-<down>") '(lambda () (interactive) (scroll-up 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-g") 'goto-line)
#+END_SRC

I often hit C-x s by mistaken when I want C-x C-s, so bind it to the same command:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x s") 'save-buffer)
#+END_SRC

Backward kill word is used so often that this is useful, but kill-region is
still needed, so move to C-x C-k:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "C-x C-k") 'kill-region)
  (global-set-key (kbd "C-c C-k") 'kill-region)
#+END_SRC

Since re-mapped C-w to backward-kill-word, and moved cut option to C-\, should move copy
command too (M-w -> M-\). Re-map old M-\ -> M-w:

#+BEGIN_SRC emacs-lisp
  ;; (global-set-key (kbd "M-w") 'delete-horizontal-space)
  ;; (global-set-key (kbd "M-\\") 'kill-ring-save)
  ;; (global-set-key (kbd "M-#") 'kill-ring-save)
#+END_SRC

M-/ is used often to expand words as a basic tab completion, so map command to somewhere
easier to press quickly, M-o (previously undefined), or M-i if I miss 'o' with my
fingers.  M-/ also now bound to undo-tree-redo:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-o") 'dabbrev-expand)
  (global-set-key (kbd "M-i") 'dabbrev-expand)
#+END_SRC

C-' is bound to =counsel-imenu=; use this instead:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-\"") 'other-window)
#+END_SRC

C-h h is usually view-hello-file. Forget it, and use handy C-h C-h to lookup stuff in
info docs:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-h h") 'help-for-help)
  (global-set-key (kbd "C-h C-h") 'cjp-lookup-thing-at-point)
  (global-set-key (kbd "C-h C-u") 'cjp-load-url-w3m)
#+END_SRC

Open the current buffer with privileges given by /sudo/:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-V") 'find-alternative-file-with-sudo)
#+END_SRC

*** Custom Binding Prefix

Use /super-SPACE/ as a prefix for more complicated stuff:

#+BEGIN_SRC emacs-lisp
  (mapc (lambda (arg)
          (global-set-key (kbd (concat "s-SPC " (car arg))) (cadr arg)))
        '(("l" find-library)))
#+END_SRC

** Mac

#+BEGIN_SRC emacs-lisp
  (when macosxp
    ;; Toggle fullscreen as usual
    ;; (global-set-key (kbd "C-M-f") 'toggle-frame-fullscreen)

    ;; Set cmd-H to hide Emacs and cmd-shift-h to hide others, as usual in Mac OS
    ;; X. Usually bound to mark-paragraph
    (global-set-key (kbd "M-h") 'ns-do-hide-emacs)
    (global-set-key (kbd "M-s-h") 'ns-do-hide-others)
    (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)

    ;; Easily open files with 'open' and show directories in Finder
    (define-key dired-mode-map (kbd "o") 'cjp-mac-guess-open-file)
    (define-key dired-mode-map (kbd "C-M-f") 'cjp-mac-show-finder)
    (define-key dired-mode-map (kbd "e") 'cjp-mac-textedit-file)
    (define-key dired-mode-map (kbd "q") 'cjp-mac-quicklook-file)
    (define-key dired-mode-map (kbd "C-M-t") 'cjp-mac-open-terminal)

    ;; alt key on Mac is Super, but it also lets you type foreign accents and
    ;; other useful characters. Use self insert for these purposes.
    (global-set-key (kbd "s-3") '(lambda () (interactive) (insert "#")))

    ;; Standard macOS behaviour
    (global-set-key (kbd "M-`") 'other-frame))
#+END_SRC

** Linux

#+BEGIN_SRC emacs-lisp
  (when linuxp
    ;; Outline-minor-mode key map
    (define-prefix-command 'cm-map nil "Outline-")

    (define-key cm-map "q" 'hide-sublevels) ; Hide everything but the top-level headings
    (define-key cm-map "t" 'hide-body)      ; Hide everything but headings (all body lines)
    (define-key cm-map "o" 'hide-other)     ; Hide other branches
    (define-key cm-map "c" 'hide-entry)     ; Hide this entry's body
    (define-key cm-map "l" 'hide-leaves)    ; Hide body lines in this entry and sub-entries
    (define-key cm-map "d" 'hide-subtree)   ; Hide everything in this entry and sub-entries

    (define-key cm-map "a" 'show-all)      ; Show (expand) everything
    (define-key cm-map "e" 'show-entry)    ; Show this heading's body
    (define-key cm-map "i" 'show-children) ; Show this heading's immediate child sub-headings
    (define-key cm-map "k" 'show-branches) ; Show all sub-headings under this heading
    (define-key cm-map "s" 'show-subtree) ; Show (expand) everything in this heading & below

    (define-key cm-map "u" 'outline-up-heading)               ; Up
    (define-key cm-map "n" 'outline-next-visible-heading)     ; Next
    (define-key cm-map "p" 'outline-previous-visible-heading) ; Previous
    (define-key cm-map "f" 'outline-forward-same-level)       ; Forward - same level
    (define-key cm-map "b" 'outline-backward-same-level)      ; Backward - same level
    (global-set-key (kbd "C-c C-c") cm-map)

    ;; Since C-s-f toggles fullscreen on the Mac, maxmimise Emacs' frame on Linux
    ;; with the same binding.
    (global-set-key (kbd "C-s-f") 'toggle-frame-maximized))
#+END_SRC

** Function keys

*** F1

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f1>") 'cjp-select-treemacs-or-toggle)
  (define-key dired-mode-map (kbd "<f1>") 'cjp-select-treemacs-or-toggle)
#+END_SRC

*** F2

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f2>") 'cjp-select-neotree-window-or-toggle)
#+END_SRC

*** F3 and F4 reserved for macros

*** F5

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'compile)
  (global-set-key (kbd "<M-f5>") 'recompile)
#+END_SRC

*** F6

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f6>") 'bookmark-jump)
  (global-set-key (kbd "<M-f6>") 'bookmark-bmenu-list)
#+END_SRC

*** F7

#+BEGIN_SRC emacs-lisp
  (cond (macosxp (global-set-key (kbd "<f7>") 'cjp-mac-show-finder)
                 (global-set-key (kbd "<M-f7>") 'cjp-mac-open-terminal)
                 (global-set-key (kbd "<C-M-f7>") (lambda () (interactive)
                                                    (cjp-mac-open-terminal t))))
        (linuxp (global-set-key (kbd "<f7>") 'cjp-linux-show-directory)))
#+END_SRC

*** F8

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f8>") 'cjp-ispell-guess-usage)
  (global-set-key (kbd "<C-f8>") 'dictionary-search)
  (global-set-key (kbd "<M-f8>") 'dictionary-match-words)
#+END_SRC

*** F9 reserved for Exposé (all windows)

*** F10

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f9>") 'epa-sign-region)
  (global-set-key (kbd "<C-f9>") 'epa-encrypt-region)
  (global-set-key (kbd "<M-f9>") 'epa-decrypt-region)
#+END_SRC

*** F10

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f10>") 'cjp-mac-guess-open-file)
#+END_SRC
*** F11

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f11>") 'cjp-browse-url-on-line)
#+END_SRC

*** F12

#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key (kbd "<f12>") (lambda () (interactive) (org-capture nil "i")))
  (global-set-key (kbd "<C-f12>") 'gtd-open-file)
  (global-set-key (kbd "<M-f12>") 'org-agenda)
  (global-set-key (kbd "<s-f12>") 'org-capture)
#+END_SRC

*** F13-16 (Apple extended keyboard only)

#+BEGIN_SRC emacs-lisp
  (when macosxp
    (global-set-key (kbd "<f13>") 'cjp-deft-clear-if-in-buffer)
    (global-set-key (kbd "<f14>") 'cjp-browse-url-on-line)
    (global-set-key (kbd "<M-f14>") 'cjp-browse-buffer)
    (global-set-key (kbd "<f15>") 'cjp-find-with-google)
    (global-set-key (kbd "<f16>") (lambda () (interactive) (cjp-set-frame-uni t)))
    (global-set-key (kbd "<M-f16>") (lambda () (interactive) (cjp-set-frame-uni))))
#+END_SRC
* Hydras

** Window moving

#+BEGIN_SRC emacs-lisp
  (defhydra hydra-window-nav (global-map "s-w")
    "Hydras for naviating around windows, etc."
    ("j" windmove-down)
    ("k" windmove-up)
    ("h" windmove-left)
    ("l" windmove-right)
    ("J" winner-undo)
    ("K" winner-redo))
#+END_SRC
